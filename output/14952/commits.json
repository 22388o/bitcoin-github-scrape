[
  {
    "sha": "bdacbda25316581ac82eac0820905c833f69c615",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGFjYmRhMjUzMTY1ODFhYzgyZWFjMDgyMDkwNWM4MzNmNjljNjE1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-10-25T01:28:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-12-13T00:32:33Z"
      },
      "message": "Overhaul importmulti logic\n\nThis introduces various changes to the importmulti logic:\n* Instead of processing input and importing things at the same time, first\n  process all input data and verify it, so no changes are made in case of\n  an error.\n* Verify that no superfluous information is provided (no keys or scripts\n  that don't contribute to solvability in particular).\n* Add way more sanity checks, by means of descending into all involved\n  scripts.",
      "tree": {
        "sha": "1afde01dd940ef92b3e93efb9ce912135d4cc6f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1afde01dd940ef92b3e93efb9ce912135d4cc6f1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdacbda25316581ac82eac0820905c833f69c615",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdacbda25316581ac82eac0820905c833f69c615",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bdacbda25316581ac82eac0820905c833f69c615",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdacbda25316581ac82eac0820905c833f69c615/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f65bce858f266b352c9ddd1f5480431dca56fcae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f65bce858f266b352c9ddd1f5480431dca56fcae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f65bce858f266b352c9ddd1f5480431dca56fcae"
      }
    ],
    "stats": {
      "total": 489,
      "additions": 276,
      "deletions": 213
    },
    "files": [
      {
        "sha": "ed1e2d3940563985d470df50e6fd7f7c6827dffd",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 212,
        "deletions": 167,
        "changes": 379,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdacbda25316581ac82eac0820905c833f69c615/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdacbda25316581ac82eac0820905c833f69c615/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=bdacbda25316581ac82eac0820905c833f69c615",
        "patch": "@@ -836,9 +836,98 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n+struct ImportData\n+{\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n+\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript); // Remove redeemscript from import_data to check for superfluous script later.\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n+        }\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript); // Remove redeemscript from import_data to check for superfluous script later.\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n+        }\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n+        }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n+    UniValue warnings(UniValue::VARR);\n+    UniValue result(UniValue::VOBJ);\n+\n     try {\n         // First ensure scriptPubKey has either a script or JSON with \"address\" string\n         const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n@@ -860,222 +949,178 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n-\n         if (!isScript) {\n             dest = DecodeDestination(output);\n             if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n             }\n             script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n             }\n-\n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n             if (!ExtractDestination(script, dest) && !internal) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n-        }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n-        }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n+        // Parse all arguments\n+        ImportData import_data;\n+        if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n             }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+            auto parsed_redeemscript = ParseHex(strRedeemScript);\n+            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n         }\n-\n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (witness_script_hex.size()) {\n             if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n             }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n-\n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n+            auto parsed_witnessscript = ParseHex(witness_script_hex);\n+            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        }\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        for (size_t i = 0; i < pubKeys.size(); ++i) {\n+            const auto& str = pubKeys[i].get_str();\n+            if (!IsHex(str)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n             }\n-\n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            auto parsed_pubkey = ParseHex(str);\n+            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n             }\n-\n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        }\n+        std::map<CKeyID, CKey> privkey_map;\n+        for (size_t i = 0; i < keys.size(); ++i) {\n+            const auto& str = keys[i].get_str();\n+            CKey key = DecodeSecret(str);\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID id = pubkey.GetID();\n+            if (pubkey_map.count(id)) {\n+                pubkey_map.erase(id);\n+            }\n+            privkey_map.emplace(id, key);\n+        }\n \n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        // Verify and process input data\n+        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        if (have_solving_data) {\n+            // Match up data in import_data with the scriptPubKey in script.\n+            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+            // Verify whether the watchonly option corresponds to the availability of private keys.\n+            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+            if (!watchOnly && !spendable) {\n+                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n             }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n-                }\n-                pubkey = pubkey_temp;\n+            if (watchOnly && spendable) {\n+                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            // Check that all required keys for solvability are provided.\n+            if (error.empty()) {\n+                for (const auto& require_key : import_data.used_keys) {\n+                    if (!require_key.second) continue; // Not a required key\n+                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                        error = \"some required keys are missing\";\n+                    }\n                 }\n+            }\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n-\n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            if (!error.empty()) {\n+                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+                import_data = ImportData();\n+                pubkey_map.clear();\n+                privkey_map.clear();\n+                have_solving_data = false;\n+            } else {\n+                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    if (import_data.used_keys.count(oldit->first) == 0) {\n+                        warnings.push_back(\"Ignoring irrelevant private key.\");\n+                        privkey_map.erase(oldit);\n+                    }\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                    auto oldit = it++;\n+                    auto key_data_it = import_data.used_keys.find(oldit->first);\n+                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                        pubkey_map.erase(oldit);\n+                    }\n                 }\n             }\n         }\n \n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+        // Check whether we have any work to do\n+        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n         }\n \n+        // All good, time to import\n         pwallet->MarkDirty();\n-\n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-        }\n-\n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n-        }\n-\n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n-        }\n-\n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n-\n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n-\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        for (const auto& entry : import_data.import_scripts) {\n+            if (!pwallet->HaveCScript(CScriptID(entry)) && !pwallet->AddCScript(entry)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n             }\n-\n-            CPubKey pubKey = key.GetPubKey();\n-            assert(key.VerifyPubKey(pubKey));\n-\n-            CKeyID vchAddress = pubKey.GetID();\n-            pwallet->MarkDirty();\n-\n-            if (pwallet->HaveKey(vchAddress)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-            }\n-\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+        }\n+        for (const auto& entry : privkey_map) {\n+            const CKey& key = entry.second;\n+            CPubKey pubkey = key.GetPubKey();\n+            const CKeyID& id = entry.first;\n+            assert(key.VerifyPubKey(pubkey));\n+            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n+            // If the private key is not present in the wallet, insert it.\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-\n             pwallet->UpdateTimeFirstKey(timestamp);\n         }\n+        for (const auto& entry : pubkey_map) {\n+            const CPubKey& pubkey = entry.second;\n+            const CKeyID& id = entry.first;\n+            CPubKey temp;\n+            if (!pwallet->GetPubKey(id, temp) && !pwallet->AddWatchOnly(GetScriptForRawPubKey(pubkey), timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+            if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+        }\n+        if (!internal) {\n+            assert(IsValidDestination(dest));\n+            pwallet->SetAddressBook(dest, label, \"receive\");\n+        }\n \n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n-        return result;\n     } catch (const UniValue& e) {\n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(false));\n         result.pushKV(\"error\", e);\n-        return result;\n     } catch (...) {\n-        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(false));\n+\n         result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n-        return result;\n     }\n+    if (warnings.size()) result.pushKV(\"warnings\", warnings);\n+    return result;\n }\n \n static int64_t GetImportTimestamp(const UniValue& data, int64_t now)\n@@ -1122,18 +1167,18 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                                     },\n                                     {\"redeemscript\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"omitted\", \"Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey\"},\n                                     {\"witnessscript\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"omitted\", \"Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey\"},\n-                                    {\"pubkeys\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"Array of strings giving pubkeys that must occur in the output or redeemscript\",\n+                                    {\"pubkeys\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"Array of strings giving pubkeys to import. They must occur in P2PKH or P2WPKH scripts. They are not required when the private key is also provided (see the \\\"keys\\\" argument).\",\n                                         {\n                                             {\"pubKey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"\"},\n                                         }\n                                     },\n-                                    {\"keys\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\",\n+                                    {\"keys\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"Array of strings giving private keys to import. The corresponding public keys must occur in the output or redeemscript.\",\n                                         {\n                                             {\"key\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"\"},\n                                         }\n                                     },\n-                                    {\"internal\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be treated as not incoming payments aka change\"},\n-                                    {\"watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\"},\n+                                    {\"internal\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be treated as not incoming payments (also known as change)\"},\n+                                    {\"watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be considered watched even when not all private keys are provided.\"},\n                                     {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"''\", \"Label to assign to the address, only allowed with internal=false\"},\n                                 },\n                             },\n@@ -1154,7 +1199,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n \n             \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n-            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+            \"  [{\\\"success\\\": true}, {\\\"success\\\": true, \\\"warnings\\\": [\\\"Ignoring irrelevant private key\\\"]}, {\\\"success\\\": false, \\\"error\\\": {\\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"}}, ...]\\n\");\n \n \n     RPCTypeCheck(mainRequest.params, {UniValue::VARR, UniValue::VOBJ});"
      },
      {
        "sha": "3492075694c9ca5d33437780944744e3da443298",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 64,
        "deletions": 46,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdacbda25316581ac82eac0820905c833f69c615/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdacbda25316581ac82eac0820905c833f69c615/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=bdacbda25316581ac82eac0820905c833f69c615",
        "patch": "@@ -119,9 +119,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n+        observed_warnings = []\n+        if 'warnings' in result[0]:\n+           observed_warnings = result[0]['warnings']\n+        assert_equal(\"\\n\".join(sorted(warnings)), \"\\n\".join(sorted(observed_warnings)))\n         assert_equal(result[0]['success'], success)\n         if error_code is not None:\n             assert_equal(result[0]['error']['code'], error_code)\n@@ -178,7 +182,7 @@ def run_test(self):\n                                \"timestamp\": \"now\"},\n                               False,\n                               error_code=-5,\n-                              error_message='Invalid address')\n+                              error_message='Invalid address \\\"not valid address\\\"')\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n@@ -227,7 +231,8 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": False},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -241,7 +246,8 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": True},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -284,20 +290,19 @@ def run_test(self):\n                               error_message='The wallet already contains the private key for this address or script')\n \n         # Address + Private key + watchonly\n-        self.log.info(\"Should not import an address with private key and with watchonly\")\n+        self.log.info(\"Should import an address with private key and with watchonly\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"watchonly\": True},\n-                              False,\n-                              error_code=-8,\n-                              error_message='Watch-only addresses should not include private keys')\n+                              True,\n+                              warnings=[\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\"])\n         self.test_address(address,\n                           iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+                          ismine=True,\n+                          timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n@@ -358,8 +363,9 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script},\n-                              True)\n-        self.test_address(multisig.p2sh_addr, timestamp=timestamp)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+        self.test_address(multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n@@ -377,9 +383,13 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2]},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(multisig.p2sh_addr,\n-                          timestamp=timestamp)\n+                          timestamp=timestamp,\n+                          ismine=False,\n+                          iswatchonly=True,\n+                          solvable=True)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n@@ -398,75 +408,78 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n-                              False,\n-                              error_code=-8,\n-                              error_message='Watch-only addresses should not include private keys')\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          solvable=True,\n+                          timestamp=timestamp)\n \n         # Address + Public key + !Internal + Wrong pubkey\n-        self.log.info(\"Should not import an address with a wrong public key\")\n+        self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                              True,\n+                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          iswatchonly=False,\n+                          iswatchonly=True,\n                           ismine=False,\n-                          timestamp=None)\n+                          solvable=False,\n+                          timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n-        self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n+        self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                              True,\n+                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          iswatchonly=False,\n+                          iswatchonly=True,\n                           ismine=False,\n-                          timestamp=None)\n+                          solvable=False,\n+                          timestamp=timestamp)\n \n         # Address + Private key + !watchonly + Wrong private key\n-        self.log.info(\"Should not import an address with a wrong private key\")\n+        self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                               True,\n+                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          iswatchonly=False,\n+                          iswatchonly=True,\n                           ismine=False,\n-                          timestamp=None)\n+                          solvable=False,\n+                          timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal + Wrong private key\n-        self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n+        self.log.info(\"Should import a scriptPubKey with internal and with a wrong private key as non-solvable\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey],\n                                \"internal\": True},\n-                              False,\n-                              error_code=-5,\n-                              error_message='Key does not match address destination')\n+                              True,\n+                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          iswatchonly=False,\n+                          iswatchonly=True,\n                           ismine=False,\n-                          timestamp=None)\n+                          solvable=False,\n+                          timestamp=timestamp)\n \n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n@@ -516,7 +529,8 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n                           ismine=False,\n                           solvable=True)\n@@ -571,7 +585,8 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"pubkeys\": [key.pubkey]},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n                           solvable=True,\n                           ismine=False)\n@@ -591,14 +606,17 @@ def run_test(self):\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n         multisig = self.get_multisig()\n+        address = multisig.p2sh_p2wsh_addr\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n-                              True)\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(address,\n-                          solvable=True)\n+                          solvable=True,\n+                          ismine=False)\n \n if __name__ == '__main__':\n     ImportMultiTest().main()"
      }
    ]
  },
  {
    "sha": "eacff95de4751b500f1cef623e4024918dcb05bb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYWNmZjk1ZGU0NzUxYjUwMGYxY2VmNjIzZTQwMjQ5MThkY2IwNWJi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-10-26T01:00:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-12-13T00:36:51Z"
      },
      "message": "Add release notes",
      "tree": {
        "sha": "3c2e0d79040319ec0e4a5bc95361fd29c59107fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3c2e0d79040319ec0e4a5bc95361fd29c59107fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eacff95de4751b500f1cef623e4024918dcb05bb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eacff95de4751b500f1cef623e4024918dcb05bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eacff95de4751b500f1cef623e4024918dcb05bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eacff95de4751b500f1cef623e4024918dcb05bb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bdacbda25316581ac82eac0820905c833f69c615",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdacbda25316581ac82eac0820905c833f69c615",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdacbda25316581ac82eac0820905c833f69c615"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "38d76fee460553734f9b7d03f93cebe3f0ee7162",
        "filename": "doc/release-notes-14565.md",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eacff95de4751b500f1cef623e4024918dcb05bb/doc/release-notes-14565.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eacff95de4751b500f1cef623e4024918dcb05bb/doc/release-notes-14565.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14565.md?ref=eacff95de4751b500f1cef623e4024918dcb05bb",
        "patch": "@@ -0,0 +1,5 @@\n+Low-level RPC changes\n+---------------------\n+\n+The `importmulti` RPC will now contain a new per-request `warnings` field with strings\n+that explain when fields are being ignored or inconsistant, if any."
      }
    ]
  },
  {
    "sha": "9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Y2YyM2Q0Y2VkYmYzZWZjMDVjZGM3NDUzOTUyODQ0YjRhYTU3Njdl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-13T17:32:50Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-13T17:32:50Z"
      },
      "message": "[tests] tidy up wallet_importmulti.py\n\nFixes review comments from PR 14886.",
      "tree": {
        "sha": "6e63da6222fc859312febcb042f8da06be453a0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e63da6222fc859312febcb042f8da06be453a0f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cf23d4cedbf3efc05cdc7453952844b4aa5767e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eacff95de4751b500f1cef623e4024918dcb05bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eacff95de4751b500f1cef623e4024918dcb05bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eacff95de4751b500f1cef623e4024918dcb05bb"
      }
    ],
    "stats": {
      "total": 189,
      "additions": 85,
      "deletions": 104
    },
    "files": [
      {
        "sha": "4de459d99bd389761223d72717ae0114da3fce09",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 85,
        "deletions": 104,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cf23d4cedbf3efc05cdc7453952844b4aa5767e/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cf23d4cedbf3efc05cdc7453952844b4aa5767e/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
        "patch": "@@ -87,18 +87,18 @@ def get_key(self):\n         addr = self.nodes[0].getnewaddress()\n         pubkey = self.nodes[0].getaddressinfo(addr)['pubkey']\n         pkh = hash160(hex_str_to_bytes(pubkey))\n-        return Key(self.nodes[0].dumpprivkey(addr),\n-                   pubkey,\n-                   CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),  # p2pkh\n-                   key_to_p2pkh(pubkey),  # p2pkh addr\n-                   CScript([OP_0, pkh]).hex(),  # p2wpkh\n-                   key_to_p2wpkh(pubkey),  # p2wpkh addr\n-                   CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),  # p2sh-p2wpkh\n-                   CScript([OP_0, pkh]).hex(),  # p2sh-p2wpkh redeem script\n-                   key_to_p2sh_p2wpkh(pubkey))  # p2sh-p2wpkh addr\n+        return Key(privkey=self.nodes[0].dumpprivkey(addr),\n+                   pubkey=pubkey,\n+                   p2pkh_script=CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),\n+                   p2pkh_addr=key_to_p2pkh(pubkey),\n+                   p2wpkh_script=CScript([OP_0, pkh]).hex(),\n+                   p2wpkh_addr=key_to_p2wpkh(pubkey),\n+                   p2sh_p2wpkh_script=CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),\n+                   p2sh_p2wpkh_redeem_script=CScript([OP_0, pkh]).hex(),\n+                   p2sh_p2wpkh_addr=key_to_p2sh_p2wpkh(pubkey))\n \n     def get_multisig(self):\n-        \"\"\"Generate a fresh multisig on node0\n+        \"\"\"Generate a fresh 2-of-3 multisig on node0\n \n         Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n         addrs = []\n@@ -109,15 +109,15 @@ def get_multisig(self):\n             pubkeys.append(addr['pubkey'])\n         script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n         witness_script = CScript([OP_0, sha256(script_code)])\n-        return Multisig([self.nodes[0].dumpprivkey(addr) for addr in addrs],\n-                        pubkeys,\n-                        CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),  # p2sh\n-                        script_to_p2sh(script_code),  # p2sh addr\n-                        script_code.hex(),  # redeem script\n-                        witness_script.hex(),  # p2wsh\n-                        script_to_p2wsh(script_code),  # p2wsh addr\n-                        CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n-                        script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n+        return Multisig(privkeys=[self.nodes[0].dumpprivkey(addr) for addr in addrs],\n+                        pubkeys=pubkeys,\n+                        p2sh_script=CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),\n+                        p2sh_addr=script_to_p2sh(script_code),\n+                        redeem_script=script_code.hex(),\n+                        p2wsh_script=witness_script.hex(),\n+                        p2wsh_addr=script_to_p2wsh(script_code),\n+                        p2sh_p2wsh_script=CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),\n+                        p2sh_p2wsh_addr=script_to_p2sh_p2wsh(script_code))\n \n     def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n@@ -165,22 +165,21 @@ def run_test(self):\n         # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           timestamp=timestamp,\n                           ischange=False)\n-        watchonly_address = address\n+        watchonly_address = key.p2pkh_addr\n         watchonly_timestamp = timestamp\n \n         self.log.info(\"Should not import an invalid address\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": \"not valid address\"},\n                                \"timestamp\": \"now\"},\n-                              False,\n+                              success=False,\n                               error_code=-5,\n                               error_message='Invalid address \\\"not valid address\\\"')\n \n@@ -190,7 +189,7 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"internal\": True},\n-                              True)\n+                              success=True)\n         self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -204,131 +203,123 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"internal\": True,\n                                \"label\": \"Example label\"},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal addresses should not have a label')\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n         nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\"},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=False,\n                           timestamp=None)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": False},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=False,\n                           timestamp=None)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=True,\n                           timestamp=timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              False,\n+                              success=False,\n                               error_code=-4,\n                               error_message='The wallet already contains the private key for this address or script')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should import an address with private key and with watchonly\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"watchonly\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=True,\n                           timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"internal\": True},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=True,\n                           timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=False,\n                           timestamp=None)\n@@ -343,7 +334,7 @@ def run_test(self):\n         self.log.info(\"Should import a p2sh\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           isscript=True,\n                           iswatchonly=True,\n@@ -363,7 +354,7 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n \n@@ -383,7 +374,7 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(multisig.p2sh_addr,\n                           timestamp=timestamp,\n@@ -408,7 +399,7 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -418,14 +409,13 @@ def run_test(self):\n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -434,15 +424,14 @@ def run_test(self):\n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -451,14 +440,13 @@ def run_test(self):\n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n-                               True,\n+                               success=True,\n                                warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -467,15 +455,14 @@ def run_test(self):\n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong private key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey],\n                                \"internal\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -486,7 +473,7 @@ def run_test(self):\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n                                \"timestamp\": \"now\"},\n-                              True)\n+                              success=True)\n         self.test_address(watchonly_address,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -514,36 +501,33 @@ def run_test(self):\n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n         key = self.get_key()\n-        address = key.p2wpkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2wpkh_addr,\n                           iswatchonly=True,\n                           solvable=False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n         key = self.get_key()\n-        address = key.p2wpkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2wpkh_addr,\n                           ismine=False,\n                           solvable=True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n         key = self.get_key()\n-        address = key.p2wpkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2wpkh_addr,\n                           iswatchonly=False,\n                           ismine=True)\n \n@@ -552,7 +536,7 @@ def run_test(self):\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           solvable=False)\n \n@@ -562,59 +546,56 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"witnessscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           solvable=True,\n                           ismine=True,\n                           sigsrequired=2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n         key = self.get_key()\n-        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2sh_p2wpkh_addr,\n                           solvable=False,\n                           ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"pubkeys\": [key.pubkey]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2sh_p2wpkh_addr,\n                           solvable=True,\n                           ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n         key = self.get_key()\n-        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"keys\": [key.privkey]},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2sh_p2wpkh_addr,\n                           solvable=True,\n                           ismine=True)\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n         multisig = self.get_multisig()\n-        address = multisig.p2sh_p2wsh_addr\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(multisig.p2sh_p2wsh_addr,\n                           solvable=True,\n                           ismine=False)\n "
      }
    ]
  },
  {
    "sha": "cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZjk5NDY1NzQ5YmJlZDQ2NWU3N2M5ZmI4ZWY3NzA1ZDRlMmQwOGZh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-13T17:43:35Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-13T17:43:35Z"
      },
      "message": "[tests] move wallet util functions to wallet_util.py\n\nAdds a new wallet_util.py module and moves generic helper functions\nthere:\n\n- get_key\n- get_multisig\n- test_address",
      "tree": {
        "sha": "afc0e1e796ab522bd7aab1a96ad167f48e2173c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/afc0e1e796ab522bd7aab1a96ad167f48e2173c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cf23d4cedbf3efc05cdc7453952844b4aa5767e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9cf23d4cedbf3efc05cdc7453952844b4aa5767e"
      }
    ],
    "stats": {
      "total": 586,
      "additions": 315,
      "deletions": 271
    },
    "files": [
      {
        "sha": "c0dfa4c3f00c35a8ba401818de79a7b21589321e",
        "filename": "test/functional/test_framework/wallet_util.py",
        "status": "added",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/test/functional/test_framework/wallet_util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/test/functional/test_framework/wallet_util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet_util.py?ref=cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
        "patch": "@@ -0,0 +1,99 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Useful util functions for testing the wallet\"\"\"\n+from collections import namedtuple\n+\n+from test_framework.address import (\n+    key_to_p2pkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2wpkh,\n+    script_to_p2sh,\n+    script_to_p2sh_p2wsh,\n+    script_to_p2wsh,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    OP_2,\n+    OP_3,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKSIG,\n+    OP_DUP,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    hash160,\n+    sha256,\n+)\n+from test_framework.util import hex_str_to_bytes\n+\n+Key = namedtuple('Key', ['privkey',\n+                         'pubkey',\n+                         'p2pkh_script',\n+                         'p2pkh_addr',\n+                         'p2wpkh_script',\n+                         'p2wpkh_addr',\n+                         'p2sh_p2wpkh_script',\n+                         'p2sh_p2wpkh_redeem_script',\n+                         'p2sh_p2wpkh_addr'])\n+\n+Multisig = namedtuple('Multisig', ['privkeys',\n+                                   'pubkeys',\n+                                   'p2sh_script',\n+                                   'p2sh_addr',\n+                                   'redeem_script',\n+                                   'p2wsh_script',\n+                                   'p2wsh_addr',\n+                                   'p2sh_p2wsh_script',\n+                                   'p2sh_p2wsh_addr'])\n+\n+def get_key(node):\n+    \"\"\"Generate a fresh key on node\n+\n+    Returns a named tuple of privkey, pubkey and all address and scripts.\"\"\"\n+    addr = node.getnewaddress()\n+    pubkey = node.getaddressinfo(addr)['pubkey']\n+    pkh = hash160(hex_str_to_bytes(pubkey))\n+    return Key(privkey=node.dumpprivkey(addr),\n+               pubkey=pubkey,\n+               p2pkh_script=CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),\n+               p2pkh_addr=key_to_p2pkh(pubkey),\n+               p2wpkh_script=CScript([OP_0, pkh]).hex(),\n+               p2wpkh_addr=key_to_p2wpkh(pubkey),\n+               p2sh_p2wpkh_script=CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),\n+               p2sh_p2wpkh_redeem_script=CScript([OP_0, pkh]).hex(),\n+               p2sh_p2wpkh_addr=key_to_p2sh_p2wpkh(pubkey))\n+\n+def get_multisig(node):\n+    \"\"\"Generate a fresh 2-of-3 multisig on node\n+\n+    Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n+    addrs = []\n+    pubkeys = []\n+    for _ in range(3):\n+        addr = node.getaddressinfo(node.getnewaddress())\n+        addrs.append(addr['address'])\n+        pubkeys.append(addr['pubkey'])\n+    script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n+    witness_script = CScript([OP_0, sha256(script_code)])\n+    return Multisig(privkeys=[node.dumpprivkey(addr) for addr in addrs],\n+                    pubkeys=pubkeys,\n+                    p2sh_script=CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),\n+                    p2sh_addr=script_to_p2sh(script_code),\n+                    redeem_script=script_code.hex(),\n+                    p2wsh_script=witness_script.hex(),\n+                    p2wsh_addr=script_to_p2wsh(script_code),\n+                    p2sh_p2wsh_script=CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),\n+                    p2sh_p2wsh_addr=script_to_p2sh_p2wsh(script_code))\n+\n+def test_address(node, address, **kwargs):\n+    \"\"\"Get address info for `address` and test whether the returned values are as expected.\"\"\"\n+    addr_info = node.getaddressinfo(address)\n+    for key, value in kwargs.items():\n+        if value is None:\n+            if key in addr_info.keys():\n+                raise AssertionError(\"key {} unexpectedly returned in getaddressinfo.\".format(key))\n+        elif addr_info[key] != value:\n+            raise AssertionError(\"key {} value {} did not match expected value {}\".format(key, addr_info[key], value))"
      },
      {
        "sha": "a623b75606c1f5c169049a0f10ff53c0534a65ce",
        "filename": "test/functional/wallet_import_with_label.py",
        "status": "modified",
        "additions": 39,
        "deletions": 38,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/test/functional/wallet_import_with_label.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/test/functional/wallet_import_with_label.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_with_label.py?ref=cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
        "patch": "@@ -11,7 +11,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n+from test_framework.wallet_util import test_address\n \n \n class ImportWithLabel(BitcoinTestFramework):\n@@ -32,11 +32,11 @@ def run_test(self):\n         address = self.nodes[0].getnewaddress()\n         label = \"Test Label\"\n         self.nodes[1].importaddress(address, label)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-\n-        assert_equal(address_assert[\"iswatchonly\"], True)\n-        assert_equal(address_assert[\"ismine\"], False)\n-        assert_equal(address_assert[\"label\"], label)\n+        test_address(self.nodes[1],\n+                     address,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=label)\n \n         self.log.info(\n             \"Import the watch-only address's private key without a \"\n@@ -45,19 +45,21 @@ def run_test(self):\n         priv_key = self.nodes[0].dumpprivkey(address)\n         self.nodes[1].importprivkey(priv_key)\n \n-        assert_equal(label, self.nodes[1].getaddressinfo(address)[\"label\"])\n+        test_address(self.nodes[1],\n+                     address,\n+                     label=label)\n \n         self.log.info(\n             \"Test importaddress without label and importprivkey with label.\"\n         )\n         self.log.info(\"Import a watch-only address without a label.\")\n         address2 = self.nodes[0].getnewaddress()\n         self.nodes[1].importaddress(address2)\n-        address_assert2 = self.nodes[1].getaddressinfo(address2)\n-\n-        assert_equal(address_assert2[\"iswatchonly\"], True)\n-        assert_equal(address_assert2[\"ismine\"], False)\n-        assert_equal(address_assert2[\"label\"], \"\")\n+        test_address(self.nodes[1],\n+                     address2,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=\"\")\n \n         self.log.info(\n             \"Import the watch-only address's private key with a \"\n@@ -67,18 +69,20 @@ def run_test(self):\n         label2 = \"Test Label 2\"\n         self.nodes[1].importprivkey(priv_key2, label2)\n \n-        assert_equal(label2, self.nodes[1].getaddressinfo(address2)[\"label\"])\n+        test_address(self.nodes[1],\n+                     address2,\n+                     label=label2)\n \n         self.log.info(\"Test importaddress with label and importprivkey with label.\")\n         self.log.info(\"Import a watch-only address with a label.\")\n         address3 = self.nodes[0].getnewaddress()\n         label3_addr = \"Test Label 3 for importaddress\"\n         self.nodes[1].importaddress(address3, label3_addr)\n-        address_assert3 = self.nodes[1].getaddressinfo(address3)\n-\n-        assert_equal(address_assert3[\"iswatchonly\"], True)\n-        assert_equal(address_assert3[\"ismine\"], False)\n-        assert_equal(address_assert3[\"label\"], label3_addr)\n+        test_address(self.nodes[1],\n+                     address3,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=label3_addr)\n \n         self.log.info(\n             \"Import the watch-only address's private key with a \"\n@@ -88,7 +92,9 @@ def run_test(self):\n         label3_priv = \"Test Label 3 for importprivkey\"\n         self.nodes[1].importprivkey(priv_key3, label3_priv)\n \n-        assert_equal(label3_priv, self.nodes[1].getaddressinfo(address3)[\"label\"])\n+        test_address(self.nodes[1],\n+                     address3,\n+                     label=label3_priv)\n \n         self.log.info(\n             \"Test importprivkey won't label new dests with the same \"\n@@ -98,15 +104,12 @@ def run_test(self):\n         address4 = self.nodes[0].getnewaddress()\n         label4_addr = \"Test Label 4 for importaddress\"\n         self.nodes[1].importaddress(address4, label4_addr)\n-        address_assert4 = self.nodes[1].getaddressinfo(address4)\n-\n-        assert_equal(address_assert4[\"iswatchonly\"], True)\n-        assert_equal(address_assert4[\"ismine\"], False)\n-        assert_equal(address_assert4[\"label\"], label4_addr)\n-\n-        self.log.info(\"Asserts address has no embedded field with dests.\")\n-\n-        assert_equal(address_assert4.get(\"embedded\"), None)\n+        test_address(self.nodes[1],\n+                     address4,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=label4_addr,\n+                     embedded=None)\n \n         self.log.info(\n             \"Import the watch-only address's private key without a \"\n@@ -116,16 +119,14 @@ def run_test(self):\n         )\n         priv_key4 = self.nodes[0].dumpprivkey(address4)\n         self.nodes[1].importprivkey(priv_key4)\n-        address_assert4 = self.nodes[1].getaddressinfo(address4)\n-\n-        assert address_assert4.get(\"embedded\")\n-\n-        bcaddress_assert = self.nodes[1].getaddressinfo(\n-            address_assert4[\"embedded\"][\"address\"]\n-        )\n-\n-        assert_equal(address_assert4[\"label\"], label4_addr)\n-        assert_equal(bcaddress_assert[\"label\"], \"\")\n+        embedded_addr = self.nodes[1].getaddressinfo(address4)['embedded']['address']\n+\n+        test_address(self.nodes[1],\n+                     embedded_addr,\n+                     label=\"\")\n+        test_address(self.nodes[1],\n+                     address4,\n+                     label=label4_addr)\n \n         self.stop_nodes()\n "
      },
      {
        "sha": "f122f19e3ab6c6a64f4efbdfccf15d613a07e791",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 177,
        "deletions": 233,
        "changes": 410,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf99465749bbed465e77c9fb8ef7705d4e2d08fa/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=cf99465749bbed465e77c9fb8ef7705d4e2d08fa",
        "patch": "@@ -14,59 +14,23 @@\n   success, and (if unsuccessful) test the error code and error message returned.\n - `test_address()` is called to call getaddressinfo for an address on node1\n   and test the values returned.\"\"\"\n-from collections import namedtuple\n-\n-from test_framework.address import (\n-    key_to_p2pkh,\n-    key_to_p2sh_p2wpkh,\n-    key_to_p2wpkh,\n-    script_to_p2sh,\n-    script_to_p2sh_p2wsh,\n-    script_to_p2wsh,\n-)\n+\n from test_framework.script import (\n     CScript,\n-    OP_0,\n-    OP_2,\n-    OP_3,\n-    OP_CHECKMULTISIG,\n-    OP_CHECKSIG,\n-    OP_DUP,\n-    OP_EQUAL,\n-    OP_EQUALVERIFY,\n-    OP_HASH160,\n     OP_NOP,\n-    hash160,\n-    sha256,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n     bytes_to_hex_str,\n-    hex_str_to_bytes\n )\n-\n-Key = namedtuple('Key', ['privkey',\n-                         'pubkey',\n-                         'p2pkh_script',\n-                         'p2pkh_addr',\n-                         'p2wpkh_script',\n-                         'p2wpkh_addr',\n-                         'p2sh_p2wpkh_script',\n-                         'p2sh_p2wpkh_redeem_script',\n-                         'p2sh_p2wpkh_addr'])\n-\n-Multisig = namedtuple('Multisig', ['privkeys',\n-                                   'pubkeys',\n-                                   'p2sh_script',\n-                                   'p2sh_addr',\n-                                   'redeem_script',\n-                                   'p2wsh_script',\n-                                   'p2wsh_addr',\n-                                   'p2sh_p2wsh_script',\n-                                   'p2sh_p2wsh_addr'])\n+from test_framework.wallet_util import (\n+    get_key,\n+    get_multisig,\n+    test_address,\n+)\n \n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -80,45 +44,6 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.setup_nodes()\n \n-    def get_key(self):\n-        \"\"\"Generate a fresh key on node0\n-\n-        Returns a named tuple of privkey, pubkey and all address and scripts.\"\"\"\n-        addr = self.nodes[0].getnewaddress()\n-        pubkey = self.nodes[0].getaddressinfo(addr)['pubkey']\n-        pkh = hash160(hex_str_to_bytes(pubkey))\n-        return Key(privkey=self.nodes[0].dumpprivkey(addr),\n-                   pubkey=pubkey,\n-                   p2pkh_script=CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),\n-                   p2pkh_addr=key_to_p2pkh(pubkey),\n-                   p2wpkh_script=CScript([OP_0, pkh]).hex(),\n-                   p2wpkh_addr=key_to_p2wpkh(pubkey),\n-                   p2sh_p2wpkh_script=CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),\n-                   p2sh_p2wpkh_redeem_script=CScript([OP_0, pkh]).hex(),\n-                   p2sh_p2wpkh_addr=key_to_p2sh_p2wpkh(pubkey))\n-\n-    def get_multisig(self):\n-        \"\"\"Generate a fresh 2-of-3 multisig on node0\n-\n-        Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n-        addrs = []\n-        pubkeys = []\n-        for _ in range(3):\n-            addr = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-            addrs.append(addr['address'])\n-            pubkeys.append(addr['pubkey'])\n-        script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n-        witness_script = CScript([OP_0, sha256(script_code)])\n-        return Multisig(privkeys=[self.nodes[0].dumpprivkey(addr) for addr in addrs],\n-                        pubkeys=pubkeys,\n-                        p2sh_script=CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),\n-                        p2sh_addr=script_to_p2sh(script_code),\n-                        redeem_script=script_code.hex(),\n-                        p2wsh_script=witness_script.hex(),\n-                        p2wsh_addr=script_to_p2wsh(script_code),\n-                        p2sh_p2wsh_script=CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),\n-                        p2sh_p2wsh_addr=script_to_p2sh_p2wsh(script_code))\n-\n     def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n@@ -131,16 +56,6 @@ def test_importmulti(self, req, success, error_code=None, error_message=None, wa\n             assert_equal(result[0]['error']['code'], error_code)\n             assert_equal(result[0]['error']['message'], error_message)\n \n-    def test_address(self, address, **kwargs):\n-        \"\"\"Get address info for `address` and test whether the returned values are as expected.\"\"\"\n-        addr_info = self.nodes[1].getaddressinfo(address)\n-        for key, value in kwargs.items():\n-            if value is None:\n-                if key in addr_info.keys():\n-                    raise AssertionError(\"key {} unexpectedly returned in getaddressinfo.\".format(key))\n-            elif addr_info[key] != value:\n-                raise AssertionError(\"key {} value {} did not match expected value {}\".format(key, addr_info[key], value))\n-\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n@@ -164,15 +79,16 @@ def run_test(self):\n \n         # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp,\n-                          ischange=False)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp,\n+                     ischange=False)\n         watchonly_address = key.p2pkh_addr\n         watchonly_timestamp = timestamp\n \n@@ -185,20 +101,21 @@ def run_test(self):\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"internal\": True},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp,\n-                          ischange=True)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp,\n+                     ischange=True)\n \n         # ScriptPubKey + internal + label\n         self.log.info(\"Should not allow a label to be specified when internal is true\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"internal\": True,\n@@ -210,70 +127,75 @@ def run_test(self):\n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n         nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\"},\n                               success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=False,\n+                     timestamp=None)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": False},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": True},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n                               success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=False,\n+                     timestamp=None)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True,\n+                     timestamp=timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n@@ -285,47 +207,50 @@ def run_test(self):\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should import an address with private key and with watchonly\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"watchonly\": True},\n                               success=True,\n                               warnings=[\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"internal\": True},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True,\n+                     timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=False,\n+                     timestamp=None)\n \n         # P2SH address\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -335,16 +260,17 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          isscript=True,\n-                          iswatchonly=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     isscript=True,\n+                     iswatchonly=True,\n+                     timestamp=timestamp)\n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n \n         # P2SH + Redeem script\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -356,14 +282,15 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + !Watchonly\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -376,18 +303,19 @@ def run_test(self):\n                                \"keys\": multisig.privkeys[0:2]},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(multisig.p2sh_addr,\n-                          timestamp=timestamp,\n-                          ismine=False,\n-                          iswatchonly=True,\n-                          solvable=True)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     timestamp=timestamp,\n+                     ismine=False,\n+                     iswatchonly=True,\n+                     solvable=True)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -400,93 +328,100 @@ def run_test(self):\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=True,\n+                     timestamp=timestamp)\n \n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n-        key = self.get_key()\n-        wrong_key = self.get_key().pubkey\n+        key = get_key(self.nodes[0])\n+        wrong_key = get_key(self.nodes[0]).pubkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n                               success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n-        key = self.get_key()\n-        wrong_key = self.get_key().pubkey\n+        key = get_key(self.nodes[0])\n+        wrong_key = get_key(self.nodes[0]).pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n                               success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n-        key = self.get_key()\n-        wrong_privkey = self.get_key().privkey\n+        key = get_key(self.nodes[0])\n+        wrong_privkey = get_key(self.nodes[0]).privkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n                                success=True,\n                                warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong private key as non-solvable\")\n-        key = self.get_key()\n-        wrong_privkey = self.get_key().privkey\n+        key = get_key(self.nodes[0])\n+        wrong_privkey = get_key(self.nodes[0]).privkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey],\n                                \"internal\": True},\n                               success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(watchonly_address,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     watchonly_address,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp)\n         watchonly_timestamp = timestamp\n \n         # restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n-        self.test_address(watchonly_address,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=watchonly_timestamp)\n+        test_address(self.nodes[1],\n+                     watchonly_address,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=watchonly_timestamp)\n \n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n@@ -500,45 +435,49 @@ def run_test(self):\n \n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(key.p2wpkh_addr,\n-                          iswatchonly=True,\n-                          solvable=False)\n+        test_address(self.nodes[1],\n+                     key.p2wpkh_addr,\n+                     iswatchonly=True,\n+                     solvable=False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2wpkh_addr,\n-                          ismine=False,\n-                          solvable=True)\n+        test_address(self.nodes[1],\n+                     key.p2wpkh_addr,\n+                     ismine=False,\n+                     solvable=True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               success=True)\n-        self.test_address(key.p2wpkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True)\n+        test_address(self.nodes[1],\n+                     key.p2wpkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True)\n \n         # P2WSH multisig address without scripts or keys\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          solvable=False)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     solvable=False)\n \n         # Same P2WSH multisig address as above, but now with witnessscript + private keys\n         self.log.info(\"Should import a p2wsh with respective witness script and private keys\")\n@@ -547,20 +486,22 @@ def run_test(self):\n                                \"witnessscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          solvable=True,\n-                          ismine=True,\n-                          sigsrequired=2)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     solvable=True,\n+                     ismine=True,\n+                     sigsrequired=2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(key.p2sh_p2wpkh_addr,\n-                          solvable=False,\n-                          ismine=False)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=False,\n+                     ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n@@ -570,34 +511,37 @@ def run_test(self):\n                                \"pubkeys\": [key.pubkey]},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2sh_p2wpkh_addr,\n-                          solvable=True,\n-                          ismine=False)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=True,\n+                     ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"keys\": [key.privkey]},\n                               success=True)\n-        self.test_address(key.p2sh_p2wpkh_addr,\n-                          solvable=True,\n-                          ismine=True)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=True,\n+                     ismine=True)\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(multisig.p2sh_p2wsh_addr,\n-                          solvable=True,\n-                          ismine=False)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_p2wsh_addr,\n+                     solvable=True,\n+                     ismine=False)\n \n if __name__ == '__main__':\n     ImportMultiTest().main()"
      }
    ]
  }
]