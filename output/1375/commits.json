[
  {
    "sha": "bbfad21c3de1ba9dde3d60cc9c2802cb9645504c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYmZhZDIxYzNkZTFiYTlkZGUzZDYwY2M5YzI4MDJjYjk2NDU1MDRj",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2012-05-28T22:29:46Z"
      },
      "committer": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2012-05-29T19:13:24Z"
      },
      "message": "Show peer that sent transaction when it causes a DoS(100).\n\nConflicts:\n\n\tsrc/main.cpp",
      "tree": {
        "sha": "689be511733f05a33f24e529df196e9f632affbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/689be511733f05a33f24e529df196e9f632affbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bbfad21c3de1ba9dde3d60cc9c2802cb9645504c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbfad21c3de1ba9dde3d60cc9c2802cb9645504c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bbfad21c3de1ba9dde3d60cc9c2802cb9645504c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbfad21c3de1ba9dde3d60cc9c2802cb9645504c/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6521b66f7d4e7c3d55e0fd1d006fd6311afc18f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6521b66f7d4e7c3d55e0fd1d006fd6311afc18f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6521b66f7d4e7c3d55e0fd1d006fd6311afc18f"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 70,
      "deletions": 22
    },
    "files": [
      {
        "sha": "2fe1e7e1186a7394ff9eafe012a2cc360fa7fe15",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 22,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbfad21c3de1ba9dde3d60cc9c2802cb9645504c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbfad21c3de1ba9dde3d60cc9c2802cb9645504c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=bbfad21c3de1ba9dde3d60cc9c2802cb9645504c",
        "patch": "@@ -32,6 +32,7 @@ uint256 hashGenesisBlock(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3\n static CBigNum bnProofOfWorkLimit(~uint256(0) >> 32);\n CBlockIndex* pindexGenesisBlock = NULL;\n int nBestHeight = -1;\n+CNode* txnode = NULL;\n CBigNum bnBestChainWork = 0;\n CBigNum bnBestInvalidWork = 0;\n uint256 hashBestChain = 0;\n@@ -430,20 +431,28 @@ bool CTransaction::CheckTransaction() const\n     if (vout.empty())\n         return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n     // Size limits\n-    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n+    }\n \n     // Check for negative or overflow output values\n     int64 nValueOut = 0;\n     BOOST_FOREACH(const CTxOut& txout, vout)\n     {\n-        if (txout.nValue < 0)\n+        if (txout.nValue < 0) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n-        if (txout.nValue > MAX_MONEY)\n+        }\n+        if (txout.nValue > MAX_MONEY) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n+        }\n         nValueOut += txout.nValue;\n-        if (!MoneyRange(nValueOut))\n+        if (!MoneyRange(nValueOut)) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n+        }\n     }\n \n     // Check for duplicate inputs\n@@ -457,8 +466,10 @@ bool CTransaction::CheckTransaction() const\n \n     if (IsCoinBase())\n     {\n-        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n+        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n+        }\n     }\n     else\n     {\n@@ -480,8 +491,10 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n         return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n \n     // Coinbase is only valid in a block, not as a loose transaction\n-    if (tx.IsCoinBase())\n+    if (tx.IsCoinBase()) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n+    }\n \n     // To help v0.1.5 clients who would see it as a negative number\n     if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n@@ -1091,6 +1104,7 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n             // Revisit this if/when transaction replacement is implemented and allows\n             // adding inputs:\n             fInvalid = true;\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n         }\n     }\n@@ -1159,8 +1173,10 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             CTxIndex& txindex = inputs[prevout.hash].first;\n             CTransaction& txPrev = inputs[prevout.hash].second;\n \n-            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n+            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size()) {\n+                if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n                 return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n+            }\n \n             // If prev is coinbase, check that it's matured\n             if (txPrev.IsCoinBase())\n@@ -1170,8 +1186,10 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n \n             // Check for negative or overflow input values\n             nValueIn += txPrev.vout[prevout.n].nValue;\n-            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn)) {\n+                if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n                 return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n+            }\n \n         }\n         // The first loop above does all the inexpensive checks.\n@@ -1203,6 +1221,7 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n                     if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n                         return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n \n+                    if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                 }\n             }\n@@ -1217,16 +1236,22 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             }\n         }\n \n-        if (nValueIn < GetValueOut())\n+        if (nValueIn < GetValueOut()) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n+        }\n \n         // Tally transaction fees\n         int64 nTxFee = nValueIn - GetValueOut();\n-        if (nTxFee < 0)\n+        if (nTxFee < 0) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n+        }\n         nFees += nTxFee;\n-        if (!MoneyRange(nFees))\n+        if (!MoneyRange(nFees)) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n+        }\n     }\n \n     return true;\n@@ -1345,8 +1370,10 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n     BOOST_FOREACH(CTransaction& tx, vtx)\n     {\n         nSigOps += tx.GetLegacySigOpCount();\n-        if (nSigOps > MAX_BLOCK_SIGOPS)\n+        if (nSigOps > MAX_BLOCK_SIGOPS) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+        }\n \n         CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n         nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n@@ -1364,8 +1391,10 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n                 // this is to prevent a \"rogue miner\" from creating\n                 // an incredibly-expensive-to-validate block.\n                 nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n-                if (nSigOps > MAX_BLOCK_SIGOPS)\n+                if (nSigOps > MAX_BLOCK_SIGOPS) {\n+                    if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n                     return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+                }\n             }\n \n             nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n@@ -1676,23 +1705,30 @@ bool CBlock::CheckBlock() const\n     // that can be verified before saving an orphan block.\n \n     // Size limits\n-    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"CheckBlock() : size limits failed\"));\n+    }\n \n     // Check proof of work matches claimed amount\n     if (!CheckProofOfWork(GetHash(), nBits))\n         return DoS(50, error(\"CheckBlock() : proof of work failed\"));\n \n     // Check timestamp\n-    if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n+    if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60) {\n         return error(\"CheckBlock() : block timestamp too far in the future\");\n+    }\n \n     // First transaction must be coinbase, the rest must not be\n-    if (vtx.empty() || !vtx[0].IsCoinBase())\n+    if (vtx.empty() || !vtx[0].IsCoinBase()) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n+    }\n     for (unsigned int i = 1; i < vtx.size(); i++)\n-        if (vtx[i].IsCoinBase())\n+        if (vtx[i].IsCoinBase()) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n             return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n+        }\n \n     // Check transactions\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n@@ -1706,20 +1742,26 @@ bool CBlock::CheckBlock() const\n     {\n         uniqueTx.insert(tx.GetHash());\n     }\n-    if (uniqueTx.size() != vtx.size())\n+    if (uniqueTx.size() != vtx.size()) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n+    }\n \n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         nSigOps += tx.GetLegacySigOpCount();\n     }\n-    if (nSigOps > MAX_BLOCK_SIGOPS)\n+    if (nSigOps > MAX_BLOCK_SIGOPS) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n+    }\n \n     // Check merkleroot\n-    if (hashMerkleRoot != BuildMerkleTree())\n+    if (hashMerkleRoot != BuildMerkleTree()) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n+    }\n \n     return true;\n }\n@@ -1739,8 +1781,10 @@ bool CBlock::AcceptBlock()\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n+    if (nBits != GetNextWorkRequired(pindexPrev, this)) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    }\n \n     // Check timestamp against prev\n     if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n@@ -1752,8 +1796,10 @@ bool CBlock::AcceptBlock()\n             return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n-    if (!Checkpoints::CheckBlock(nHeight, hash))\n+    if (!Checkpoints::CheckBlock(nHeight, hash)) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n         return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+    }\n \n     // Write block to history file\n     if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n@@ -2700,8 +2746,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         pfrom->AddInventoryKnown(inv);\n \n         bool fMissingInputs = false;\n+        txnode = pfrom;\n         if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n         {\n+            txnode = NULL;\n             SyncWithWallets(tx, NULL, true);\n             RelayMessage(inv, vMsg);\n             mapAlreadyAskedFor.erase(inv);"
      }
    ]
  }
]