[
  {
    "sha": "3112ed7ab229a021f9f3a3001231c61e6384b968",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMTEyZWQ3YWIyMjlhMDIxZjlmM2EzMDAxMjMxYzYxZTYzODRiOTY4",
    "commit": {
      "author": {
        "name": "aijs",
        "email": "gift@aijinsong.com",
        "date": "2017-07-04T08:12:07Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2017-07-04T08:12:07Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\ntest",
      "tree": {
        "sha": "1747b25e97a57b1410d7886b815e5935a302f2a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1747b25e97a57b1410d7886b815e5935a302f2a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3112ed7ab229a021f9f3a3001231c61e6384b968",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3112ed7ab229a021f9f3a3001231c61e6384b968",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3112ed7ab229a021f9f3a3001231c61e6384b968",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3112ed7ab229a021f9f3a3001231c61e6384b968/comments",
    "author": {
      "login": "aijs",
      "id": 1544099,
      "node_id": "MDQ6VXNlcjE1NDQwOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1544099?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aijs",
      "html_url": "https://github.com/aijs",
      "followers_url": "https://api.github.com/users/aijs/followers",
      "following_url": "https://api.github.com/users/aijs/following{/other_user}",
      "gists_url": "https://api.github.com/users/aijs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aijs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aijs/subscriptions",
      "organizations_url": "https://api.github.com/users/aijs/orgs",
      "repos_url": "https://api.github.com/users/aijs/repos",
      "events_url": "https://api.github.com/users/aijs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aijs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c2ab38bdd57a16e6c708dcc633d9162331c9d311",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c2ab38bdd57a16e6c708dcc633d9162331c9d311",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c2ab38bdd57a16e6c708dcc633d9162331c9d311"
      },
      {
        "sha": "7397af9d314dd01ca3699efbe6eec68f62a6ef2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7397af9d314dd01ca3699efbe6eec68f62a6ef2b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7397af9d314dd01ca3699efbe6eec68f62a6ef2b"
      }
    ],
    "stats": {
      "total": 4574,
      "additions": 3112,
      "deletions": 1462
    },
    "files": [
      {
        "sha": "8216b7d60811bc01573622eaa5f12a856d6e53e8",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 22,
        "deletions": 29,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -59,10 +59,10 @@ OSX_PACKAGING = $(OSX_DEPLOY_SCRIPT) $(OSX_FANCY_PLIST) $(OSX_INSTALLER_ICONS) \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-apply.sh \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-create.sh\n \n-COVERAGE_INFO = baseline_filtered_combined.info baseline.info \\\n-  leveldb_baseline.info test_bitcoin_filtered.info total_coverage.info \\\n+COVERAGE_INFO = baseline.info \\\n+  test_bitcoin_filtered.info total_coverage.info \\\n   baseline_filtered.info functional_test.info functional_test_filtered.info \\\n-  leveldb_baseline_filtered.info test_bitcoin_coverage.info test_bitcoin.info\n+  test_bitcoin_coverage.info test_bitcoin.info\n \n dist-hook:\n \t-$(GIT) archive --format=tar HEAD -- src/clientversion.cpp | $(AMTAR) -C $(top_distdir) -xf -\n@@ -166,52 +166,45 @@ $(BITCOIN_CLI_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n \n if USE_LCOV\n+LCOV_FILTER_PATTERN=-p \"/usr/include/\" -p \"src/leveldb/\" -p \"src/bench/\" -p \"src/univalue\" -p \"src/crypto/ctaes\" -p \"src/secp256k1\"\n \n baseline.info:\n \t$(LCOV) -c -i -d $(abs_builddir)/src -o $@\n \n baseline_filtered.info: baseline.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n-leveldb_baseline.info: baseline_filtered.info\n-\t$(LCOV) -c -i -d $(abs_builddir)/src/leveldb -b $(abs_builddir)/src/leveldb -o $@\n-\n-leveldb_baseline_filtered.info: leveldb_baseline.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n-\n-baseline_filtered_combined.info: leveldb_baseline_filtered.info baseline_filtered.info\n-\t$(LCOV) -a leveldb_baseline_filtered.info -a baseline_filtered.info -o $@\n-\n-test_bitcoin.info: baseline_filtered_combined.info\n+test_bitcoin.info: baseline_filtered.info\n \t$(MAKE) -C src/ check\n-\t$(LCOV) -c -d $(abs_builddir)/src -t test_bitcoin -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n+\t$(LCOV) -c $(LCOV_OPTS) -d $(abs_builddir)/src -t test_bitcoin -o $@\n+\t$(LCOV) -z $(LCOV_OPTS) -d $(abs_builddir)/src\n \n test_bitcoin_filtered.info: test_bitcoin.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n functional_test.info: test_bitcoin_filtered.info\n-\t-@TIMEOUT=15 python test/functional/test_runner.py $(EXTENDED_FUNCTIONAL_TESTS)\n-\t$(LCOV) -c -d $(abs_builddir)/src --t functional-tests -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n+\t-@TIMEOUT=15 test/functional/test_runner.py $(EXTENDED_FUNCTIONAL_TESTS)\n+\t$(LCOV) -c $(LCOV_OPTS) -d $(abs_builddir)/src --t functional-tests -o $@\n+\t$(LCOV) -z $(LCOV_OPTS) -d $(abs_builddir)/src\n \n functional_test_filtered.info: functional_test.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n-test_bitcoin_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n+test_bitcoin_coverage.info: baseline_filtered.info test_bitcoin_filtered.info\n+\t$(LCOV) -a $(LCOV_OPTS) baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n \n-total_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info functional_test_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -a functional_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n+total_coverage.info: test_bitcoin_filtered.info functional_test_filtered.info\n+\t$(LCOV) -a $(LCOV_OPTS) baseline_filtered.info -a test_bitcoin_filtered.info -a functional_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n \n test_bitcoin.coverage/.dirstamp:  test_bitcoin_coverage.info\n-\t$(GENHTML) -s $< -o $(@D)\n+\t$(GENHTML) -s $(LCOV_OPTS) $< -o $(@D)\n \t@touch $@\n \n total.coverage/.dirstamp: total_coverage.info\n-\t$(GENHTML) -s $< -o $(@D)\n+\t$(GENHTML) -s $(LCOV_OPTS) $< -o $(@D)\n \t@touch $@\n \n cov: test_bitcoin.coverage/.dirstamp total.coverage/.dirstamp"
      },
      {
        "sha": "a90063d9dedc4909648f68e6adb42609f3698f5a",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -158,6 +158,12 @@ AC_ARG_ENABLE([lcov],\n   [enable lcov testing (default is no)])],\n   [use_lcov=yes],\n   [use_lcov=no])\n+  \n+AC_ARG_ENABLE([lcov-branch-coverage],\n+  [AS_HELP_STRING([--enable-lcov-branch-coverage],\n+  [enable lcov testing branch coverage (default is no)])],\n+  [use_lcov_branch=yes],\n+  [use_lcov_branch=no])\n \n AC_ARG_ENABLE([glibc-back-compat],\n   [AS_HELP_STRING([--enable-glibc-back-compat],\n@@ -442,6 +448,12 @@ if test x$use_lcov = xyes; then\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage linker flag does not work\")])\n   AX_CHECK_COMPILE_FLAG([--coverage],[CXXFLAGS=\"$CXXFLAGS --coverage\"],\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage flag does not work\")])\n+  AC_DEFINE(USE_COVERAGE, 1, [Define this symbol if coverage is enabled])\n+  CXXFLAGS=\"$CXXFLAGS -Og\"\n+fi\n+\n+if test x$use_lcov_branch != xno; then\n+  AC_SUBST(LCOV_OPTS, \"$LCOV_OPTS --rc lcov_branch_coverage=1\")\n fi\n \n dnl Check for endianness"
      },
      {
        "sha": "150f368513296525112f09d9732bc7c7a428b32f",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-sendfreetransactions'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "299377d691155308875fb95fe5b7f49f9e8d50dc",
        "filename": "contrib/filter-lcov.py",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/filter-lcov.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/filter-lcov.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/filter-lcov.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -0,0 +1,25 @@\n+#!/usr/bin/env python3\n+\n+import argparse\n+\n+parser = argparse.ArgumentParser(description='Remove the coverage data from a tracefile for all files matching the pattern.')\n+parser.add_argument('--pattern', '-p', action='append', help='the pattern of files to remove', required=True)\n+parser.add_argument('tracefile', help='the tracefile to remove the coverage data from')\n+parser.add_argument('outfile', help='filename for the output to be written to')\n+\n+args = parser.parse_args()\n+tracefile = args.tracefile\n+pattern = args.pattern\n+outfile = args.outfile\n+\n+in_remove = False\n+with open(tracefile, 'r') as f:\n+    with open(outfile, 'w') as wf:\n+        for line in f:\n+            for p in pattern:\n+                if line.startswith(\"SF:\") and p in line:\n+                    in_remove = True\n+            if not in_remove:\n+                wf.write(line)\n+            if line == 'end_of_record\\n':\n+                in_remove = False"
      },
      {
        "sha": "eed232a8722de569dc75dc97fc926e18b060898a",
        "filename": "contrib/gitian-keys/laanwj-key.pgp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/gitian-keys/laanwj-key.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/gitian-keys/laanwj-key.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-keys/laanwj-key.pgp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968"
      },
      {
        "sha": "4ab2f356803a8933edd1fe7b573533281ef7c1f2",
        "filename": "contrib/rpm/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/rpm/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/rpm/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/README.md?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -181,5 +181,5 @@ knows what they are getting when installing the GUI package.\n \n As far as minor differences, I generally prefer to assign the file permissions\n in the `%files` portion of an RPM spec file rather than specifying the\n-permissions of a file during `%install` and other minor things like that that\n+permissions of a file during `%install` and other minor things like that\n are largely just cosmetic."
      },
      {
        "sha": "b206866cc5eb4abc3075f8692637a7096d7f0b0e",
        "filename": "contrib/rpm/bitcoin.if",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/rpm/bitcoin.if",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/rpm/bitcoin.if",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/bitcoin.if?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -121,7 +121,7 @@ interface(`bitcoin_manage_lib_dirs',`\n ########################################\n ## <summary>\n ##\tAll of the rules required to administrate\n-##\tan bitcoin environment\n+##\ta bitcoin environment\n ## </summary>\n ## <param name=\"domain\">\n ##\t<summary>"
      },
      {
        "sha": "3ffe0a2f289556d40fab4f5ed82ddefaab645ea9",
        "filename": "contrib/verifybinaries/README.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/verifybinaries/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/verifybinaries/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/README.md?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -26,6 +26,14 @@ The script returns 0 if everything passes the checks. It returns 1 if either the\n ./verify.sh bitcoin-core-0.13.0-rc3\n ```\n \n+If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:\n+\n+```sh\n+./verify.sh bitcoin-core-0.11.2-osx\n+./verify.sh 0.12.0-linux\n+./verify.sh bitcoin-core-0.13.0-rc3-win64\n+```\n+\n If you do not want to keep the downloaded binaries, specify anything as the second parameter.\n \n ```sh"
      },
      {
        "sha": "c2cc2b7013ad9ddee52374b89750d52342792370",
        "filename": "contrib/verifybinaries/verify.sh",
        "status": "modified",
        "additions": 38,
        "deletions": 5,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/verifybinaries/verify.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/contrib/verifybinaries/verify.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/verify.sh?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -42,13 +42,36 @@ if [ -n \"$1\" ]; then\n       VERSION=\"$VERSIONPREFIX$1\"\n    fi\n \n-   #now let's see if the version string contains \"rc\", and strip it off if it does\n-   #  and simultaneously add RCSUBDIR to BASEDIR, where we will look for SIGNATUREFILENAME\n-   if [[ $VERSION == *\"$RCVERSIONSTRING\"* ]]; then\n-      BASEDIR=\"$BASEDIR${VERSION/%-$RCVERSIONSTRING*}/\"\n-      BASEDIR=\"$BASEDIR$RCSUBDIR.$RCVERSIONSTRING${VERSION: -1}/\"\n+   STRIPPEDLAST=\"${VERSION%-*}\"\n+\n+   #now let's see if the version string contains \"rc\" or a platform name (e.g. \"osx\")\n+   if [[ \"$STRIPPEDLAST-\" == \"$VERSIONPREFIX\" ]]; then\n+      BASEDIR=\"$BASEDIR$VERSION/\"\n    else\n+      # let's examine the last part to see if it's rc and/or platform name\n+      STRIPPEDNEXTTOLAST=\"${STRIPPEDLAST%-*}\"\n+      if [[ \"$STRIPPEDNEXTTOLAST-\" == \"$VERSIONPREFIX\" ]]; then\n+\n+         LASTSUFFIX=\"${VERSION##*-}\"\n+         VERSION=\"$STRIPPEDLAST\"\n+\n+         if [[ $LASTSUFFIX == *\"$RCVERSIONSTRING\"* ]]; then\n+            RCVERSION=\"$LASTSUFFIX\"\n+         else\n+            PLATFORM=\"$LASTSUFFIX\"\n+         fi\n+\n+      else\n+         RCVERSION=\"${STRIPPEDLAST##*-}\"\n+         PLATFORM=\"${VERSION##*-}\"\n+\n+         VERSION=\"$STRIPPEDNEXTTOLAST\"\n+      fi\n+\n       BASEDIR=\"$BASEDIR$VERSION/\"\n+      if [[ $RCVERSION == *\"$RCVERSIONSTRING\"* ]]; then\n+         BASEDIR=\"$BASEDIR$RCSUBDIR.$RCVERSION/\"\n+      fi\n    fi\n \n    SIGNATUREFILE=\"$BASEDIR$SIGNATUREFILENAME\"\n@@ -92,12 +115,22 @@ if [ $RET -ne 0 ]; then\n    exit \"$RET\"\n fi\n \n+if [ -n \"$PLATFORM\" ]; then\n+   grep $PLATFORM $TMPFILE > \"$TMPFILE-plat\"\n+   TMPFILESIZE=$(stat -c%s \"$TMPFILE-plat\")\n+   if [ $TMPFILESIZE -eq 0 ]; then\n+      echo \"error: no files matched the platform specified\" && exit 3\n+   fi\n+   mv \"$TMPFILE-plat\" $TMPFILE\n+fi\n+\n #here we extract the filenames from the signature file\n FILES=$(awk '{print $2}' \"$TMPFILE\")\n \n #and download these one by one\n for file in $FILES\n do\n+   echo \"Downloading $file\"\n    wget --quiet -N \"$BASEDIR$file\"\n done\n "
      },
      {
        "sha": "7f484724a49097b4ed403f16141ad1f2f2ec7b92",
        "filename": "depends/packages/expat.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/depends/packages/expat.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/depends/packages/expat.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/expat.mk?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -1,8 +1,8 @@\n package=expat\n-$(package)_version=2.2.0\n+$(package)_version=2.2.1\n $(package)_download_path=https://downloads.sourceforge.net/project/expat/expat/$($(package)_version)\n $(package)_file_name=$(package)-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=d9e50ff2d19b3538bd2127902a89987474e1a4db8e43a66a4d1a712ab9a504ff\n+$(package)_sha256_hash=1868cadae4c82a018e361e2b2091de103cd820aaacb0d6cfa49bd2cd83978885\n \n define $(package)_set_vars\n $(package)_config_opts=--disable-static"
      },
      {
        "sha": "81bdcc9fdb936f656be7ac38b28a52762b7f2f1a",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -68,7 +68,7 @@ public:\n         return true;\n     }\n }\n-}\n+} // namespace foo\n ```\n \n Doxygen comments\n@@ -287,7 +287,7 @@ General C++\n \n - Assertions should not have side-effects\n \n-  - *Rationale*: Even though the source code is set to to refuse to compile\n+  - *Rationale*: Even though the source code is set to refuse to compile\n     with assertions disabled, having side-effects in assertions is unexpected and\n     makes the code harder to understand\n \n@@ -438,6 +438,21 @@ Source code organization\n \n   - *Rationale*: Avoids symbol conflicts\n \n+- Terminate namespaces with a comment (`// namespace mynamespace`). The comment\n+  should be placed on the same line as the brace closing the namespace, e.g.\n+\n+```c++\n+namespace mynamespace {\n+    ...\n+} // namespace mynamespace\n+\n+namespace {\n+    ...\n+} // namespace\n+```\n+\n+  - *Rationale*: Avoids confusion about the namespace context\n+\n GUI\n -----\n "
      },
      {
        "sha": "0ad554b7738c17a4017b57234fce1132f9a9ed45",
        "filename": "doc/release-notes/release-notes-0.14.2.md",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/doc/release-notes/release-notes-0.14.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/doc/release-notes/release-notes-0.14.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.2.md?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -0,0 +1,102 @@\n+Bitcoin Core version 0.14.2 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.14.2/>\n+\n+This is a new minor version release, including various bugfixes and\n+performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later.\n+\n+Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\n+No attempt is made to prevent installing or running the software on Windows XP, you\n+can still do so at your own risk but be aware that there are known instabilities and issues.\n+Please do not report issues about Windows XP to the issue tracker.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+miniupnp CVE-2017-8798\n+----------------------------\n+\n+Bundled miniupnpc was updated to 2.0.20170509. This fixes an integer signedness error\n+(present in MiniUPnPc v1.4.20101221 through v2.0) that allows remote attackers\n+(within the LAN) to cause a denial of service or possibly have unspecified\n+other impact.\n+\n+This only affects users that have explicitly enabled UPnP through the GUI\n+setting or through the `-upnp` option, as since the last UPnP vulnerability\n+(in Bitcoin Core 0.10.3) it has been disabled by default.\n+\n+If you use this option, it is recommended to upgrade to this version as soon as\n+possible.\n+\n+Known Bugs\n+==========\n+\n+Since 0.14.0 the approximate transaction fee shown in Bitcoin-Qt when using coin\n+control and smart fee estimation does not reflect any change in target from the\n+smart fee slider. It will only present an approximate fee calculated using the\n+default target. The fee calculated using the correct target is still applied to\n+the transaction and shown in the final send confirmation dialog.\n+\n+0.14.2 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and other APIs\n+- #10410 `321419b` Fix importwallet edge case rescan bug (ryanofsky)\n+\n+### P2P protocol and network code\n+- #10424 `37a8fc5` Populate services in GetLocalAddress (morcos)\n+- #10441 `9e3ad50` Only enforce expected services for half of outgoing connections (theuni)\n+\n+### Build system\n+- #10414 `ffb0c4b` miniupnpc 2.0.20170509 (fanquake)\n+- #10228 `ae479bc` Regenerate bitcoin-config.h as necessary (theuni)\n+\n+### Miscellaneous\n+- #10245 `44a17f2` Minor fix in build documentation for FreeBSD 11 (shigeya)\n+- #10215 `0aee4a1` Check interruptNet during dnsseed lookups (TheBlueMatt)\n+\n+### GUI\n+- #10231 `1e936d7` Reduce a significant cs_main lock freeze (jonasschnelli)\n+\n+### Wallet\n+- #10294 `1847642` Unset change position when there is no change (instagibbs)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Cory Fields\n+- fanquake\n+- Gregory Sanders\n+- Jonas Schnelli\n+- Matt Corallo\n+- Russell Yanofsky\n+- Shigeya Suzuki\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "f54e249a0c1e77003e93d9f9a0f1325caa859e42",
        "filename": "share/pixmaps/nsis-header.bmp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/share/pixmaps/nsis-header.bmp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/share/pixmaps/nsis-header.bmp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/pixmaps/nsis-header.bmp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968"
      },
      {
        "sha": "14349528853f1198bfdbf7f9f180a5618820ef76",
        "filename": "share/pixmaps/nsis-wizard.bmp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/share/pixmaps/nsis-wizard.bmp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/share/pixmaps/nsis-wizard.bmp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/pixmaps/nsis-wizard.bmp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968"
      },
      {
        "sha": "5918819d13519a7c7734d2e1ac28ca7b20078898",
        "filename": "src/.clang-format",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/.clang-format",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/.clang-format",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-format?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -47,6 +47,6 @@ SpacesInAngles:  false\n SpacesInContainerLiterals: true\n SpacesInCStyleCastParentheses: false\n SpacesInParentheses: false\n-Standard:        Cpp03\n+Standard:        Cpp11\n TabWidth:        8\n UseTab:          Never"
      },
      {
        "sha": "8ecd3918045b672fbdb1fbe014b661d991ef23ae",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -127,6 +127,7 @@ BITCOIN_CORE_H = \\\n   reverselock.h \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n+  rpc/mining.h \\\n   rpc/protocol.h \\\n   rpc/server.h \\\n   rpc/register.h \\"
      },
      {
        "sha": "7f85c16585aa28b471d16c15b689ba23da6391a8",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 143,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,25 +15,31 @@\n #include \"tinyformat.h\"\n #include \"util.h\"\n \n+namespace {\n \n-CBanDB::CBanDB()\n+template <typename Stream, typename Data>\n+bool SerializeDB(Stream& stream, const Data& data)\n {\n-    pathBanlist = GetDataDir() / \"banlist.dat\";\n+    // Write and commit header, data\n+    try {\n+        CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n+        stream << FLATDATA(Params().MessageStart()) << data;\n+        hasher << FLATDATA(Params().MessageStart()) << data;\n+        stream << hasher.GetHash();\n+    } catch (const std::exception& e) {\n+        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n+    }\n+\n+    return true;\n }\n \n-bool CBanDB::Write(const banmap_t& banSet)\n+template <typename Data>\n+bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)\n {\n     // Generate random temporary filename\n     unsigned short randv = 0;\n     GetRandBytes((unsigned char*)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"banlist.dat.%04x\", randv);\n-\n-    // serialize banlist, checksum data up to that point, then append csum\n-    CDataStream ssBanlist(SER_DISK, CLIENT_VERSION);\n-    ssBanlist << FLATDATA(Params().MessageStart());\n-    ssBanlist << banSet;\n-    uint256 hash = Hash(ssBanlist.begin(), ssBanlist.end());\n-    ssBanlist << hash;\n+    std::string tmpfn = strprintf(\"%s.%04x\", prefix, randv);\n \n     // open temp output file, and associate with CAutoFile\n     fs::path pathTmp = GetDataDir() / tmpfn;\n@@ -42,69 +48,41 @@ bool CBanDB::Write(const banmap_t& banSet)\n     if (fileout.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n \n-    // Write and commit header, data\n-    try {\n-        fileout << ssBanlist;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n+    // Serialize\n+    if (!SerializeDB(fileout, data)) return false;\n     FileCommit(fileout.Get());\n     fileout.fclose();\n \n-    // replace existing banlist.dat, if any, with new banlist.dat.XXXX\n-    if (!RenameOver(pathTmp, pathBanlist))\n+    // replace existing file, if any, with new file\n+    if (!RenameOver(pathTmp, path))\n         return error(\"%s: Rename-into-place failed\", __func__);\n \n     return true;\n }\n \n-bool CBanDB::Read(banmap_t& banSet)\n+template <typename Stream, typename Data>\n+bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fsbridge::fopen(pathBanlist, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathBanlist.string());\n-\n-    // use file size to size memory buffer\n-    uint64_t fileSize = fs::file_size(pathBanlist);\n-    uint64_t dataSize = 0;\n-    // Don't try to resize to a negative number if file is small\n-    if (fileSize >= sizeof(uint256))\n-        dataSize = fileSize - sizeof(uint256);\n-    std::vector<unsigned char> vchData;\n-    vchData.resize(dataSize);\n-    uint256 hashIn;\n-\n-    // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    filein.fclose();\n-\n-    CDataStream ssBanlist(vchData, SER_DISK, CLIENT_VERSION);\n-\n-    // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssBanlist.begin(), ssBanlist.end());\n-    if (hashIn != hashTmp)\n-        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-\n-    unsigned char pchMsgTmp[4];\n     try {\n+        CHashVerifier<Stream> verifier(&stream);\n         // de-serialize file header (network specific magic number) and ..\n-        ssBanlist >> FLATDATA(pchMsgTmp);\n-\n+        unsigned char pchMsgTmp[4];\n+        verifier >> FLATDATA(pchMsgTmp);\n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n             return error(\"%s: Invalid network magic number\", __func__);\n \n-        // de-serialize ban data\n-        ssBanlist >> banSet;\n+        // de-serialize data\n+        verifier >> data;\n+\n+        // verify checksum\n+        if (fCheckSum) {\n+            uint256 hashTmp;\n+            stream >> hashTmp;\n+            if (hashTmp != verifier.GetHash()) {\n+                return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n+            }\n+        }\n     }\n     catch (const std::exception& e) {\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n@@ -113,106 +91,56 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-CAddrDB::CAddrDB()\n+template <typename Data>\n+bool DeserializeFileDB(const fs::path& path, Data& data)\n {\n-    pathAddr = GetDataDir() / \"peers.dat\";\n+    // open input file, and associate with CAutoFile\n+    FILE *file = fsbridge::fopen(path, \"rb\");\n+    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n+    if (filein.IsNull())\n+        return error(\"%s: Failed to open file %s\", __func__, path.string());\n+\n+    return DeserializeDB(filein, data);\n }\n \n-bool CAddrDB::Write(const CAddrMan& addr)\n-{\n-    // Generate random temporary filename\n-    unsigned short randv = 0;\n-    GetRandBytes((unsigned char*)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n+}\n \n-    // serialize addresses, checksum data up to that point, then append csum\n-    CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n-    ssPeers << FLATDATA(Params().MessageStart());\n-    ssPeers << addr;\n-    uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n-    ssPeers << hash;\n+CBanDB::CBanDB()\n+{\n+    pathBanlist = GetDataDir() / \"banlist.dat\";\n+}\n \n-    // open temp output file, and associate with CAutoFile\n-    fs::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n-    CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n-    if (fileout.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n+bool CBanDB::Write(const banmap_t& banSet)\n+{\n+    return SerializeFileDB(\"banlist\", pathBanlist, banSet);\n+}\n \n-    // Write and commit header, data\n-    try {\n-        fileout << ssPeers;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n-    FileCommit(fileout.Get());\n-    fileout.fclose();\n+bool CBanDB::Read(banmap_t& banSet)\n+{\n+    return DeserializeFileDB(pathBanlist, banSet);\n+}\n \n-    // replace existing peers.dat, if any, with new peers.dat.XXXX\n-    if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"%s: Rename-into-place failed\", __func__);\n+CAddrDB::CAddrDB()\n+{\n+    pathAddr = GetDataDir() / \"peers.dat\";\n+}\n \n-    return true;\n+bool CAddrDB::Write(const CAddrMan& addr)\n+{\n+    return SerializeFileDB(\"peers\", pathAddr, addr);\n }\n \n bool CAddrDB::Read(CAddrMan& addr)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fsbridge::fopen(pathAddr, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathAddr.string());\n-\n-    // use file size to size memory buffer\n-    uint64_t fileSize = fs::file_size(pathAddr);\n-    uint64_t dataSize = 0;\n-    // Don't try to resize to a negative number if file is small\n-    if (fileSize >= sizeof(uint256))\n-        dataSize = fileSize - sizeof(uint256);\n-    std::vector<unsigned char> vchData;\n-    vchData.resize(dataSize);\n-    uint256 hashIn;\n-\n-    // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    filein.fclose();\n-\n-    CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n-\n-    // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n-    if (hashIn != hashTmp)\n-        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-\n-    return Read(addr, ssPeers);\n+    return DeserializeFileDB(pathAddr, addr);\n }\n \n bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n {\n-    unsigned char pchMsgTmp[4];\n-    try {\n-        // de-serialize file header (network specific magic number) and ..\n-        ssPeers >> FLATDATA(pchMsgTmp);\n-\n-        // ... verify the network matches ours\n-        if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"%s: Invalid network magic number\", __func__);\n-\n-        // de-serialize address data into one CAddrMan object\n-        ssPeers >> addr;\n-    }\n-    catch (const std::exception& e) {\n-        // de-serialization has failed, ensure addrman is left in a clean state\n+    bool ret = DeserializeDB(ssPeers, addr, false);\n+    if (!ret) {\n+        // Ensure addrman is left in a clean state\n         addr.Clear();\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n-\n-    return true;\n+    return ret;\n }"
      },
      {
        "sha": "6cb36dfac4e60ee8512f8dfdac28101aa6ecc48c",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -85,7 +85,7 @@ class CAddrDB\n     CAddrDB();\n     bool Write(const CAddrMan& addr);\n     bool Read(CAddrMan& addr);\n-    bool Read(CAddrMan& addr, CDataStream& ssPeers);\n+    static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n };\n \n /** Access to the banlist database (banlist.dat) */"
      },
      {
        "sha": "b4952af6f48906a29db02ce9a86766e01d7d92ca",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,6 +15,8 @@\n template <unsigned int BITS>\n base_uint<BITS>::base_uint(const std::string& str)\n {\n+    static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n     SetHex(str);\n }\n "
      },
      {
        "sha": "c7734035df2e0bdf133598bd4581c0146ce18425",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -31,12 +31,16 @@ class base_uint\n \n     base_uint()\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = 0;\n     }\n \n     base_uint(const base_uint& b)\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = b.pn[i];\n     }\n@@ -50,6 +54,8 @@ class base_uint\n \n     base_uint(uint64_t b)\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n         for (int i = 2; i < WIDTH; i++)\n@@ -174,7 +180,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (++pn[i] == 0 && i < WIDTH-1)\n+        while (i < WIDTH && ++pn[i] == 0)\n             i++;\n         return *this;\n     }\n@@ -191,7 +197,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (--pn[i] == (uint32_t)-1 && i < WIDTH-1)\n+        while (i < WIDTH && --pn[i] == (uint32_t)-1)\n             i++;\n         return *this;\n     }"
      },
      {
        "sha": "efa1beb1e4f7c908f23b8f34161494287c3555d6",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -225,7 +225,7 @@ class CBitcoinAddressVisitor : public boost::static_visitor<bool>\n     bool operator()(const CNoDestination& no) const { return false; }\n };\n \n-} // anon namespace\n+} // namespace\n \n bool CBitcoinAddress::Set(const CKeyID& id)\n {"
      },
      {
        "sha": "226861aa7f745a5edb94155ef17dd86494537fd9",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -7,10 +7,12 @@\n #include \"key.h\"\n #include \"validation.h\"\n #include \"util.h\"\n+#include \"random.h\"\n \n int\n main(int argc, char** argv)\n {\n+    RandomInit();\n     ECC_Start();\n     SetupEnvironment();\n     fPrintToDebugLog = false; // don't want to write to debug.log file"
      },
      {
        "sha": "7bb1b93668cf7472dd8781cf750596d204d5314a",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -11,7 +11,7 @@\n \n namespace block_bench {\n #include \"bench/data/block413567.raw.h\"\n-}\n+} // namespace block_bench\n \n // These are the two major time-sinks which happen after we have fully received\n // a block off the wire, but before we can relay the block on to peers using"
      },
      {
        "sha": "6093f78fb13aaf33ee45d564bcc64703c161e3af",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -299,7 +299,6 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str\n     if (!pubkey.IsFullyValid())\n         throw std::runtime_error(\"invalid TX output pubkey\");\n     CScript scriptPubKey = GetScriptForRawPubKey(pubkey);\n-    CBitcoinAddress addr(scriptPubKey);\n \n     // Extract and validate FLAGS\n     bool bSegWit = false;"
      },
      {
        "sha": "ffd58d471d34b5f9926194446137f4e703742a82",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -126,7 +126,7 @@ arith_uint256 GetBlockProof(const CBlockIndex& block)\n     if (fNegative || fOverflow || bnTarget == 0)\n         return 0;\n     // We need to compute 2**256 / (bnTarget+1), but we can't represent 2**256\n-    // as it's too large for a arith_uint256. However, as 2**256 is at least as large\n+    // as it's too large for an arith_uint256. However, as 2**256 is at least as large\n     // as bnTarget+1, it is equal to ((2**256 - bnTarget - 1) / (bnTarget+1)) + 1,\n     // or ~bnTarget / (nTarget+1) + 1.\n     return (~bnTarget / (bnTarget + 1)) + 1;\n@@ -148,3 +148,22 @@ int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& fr\n     }\n     return sign * r.GetLow64();\n }\n+\n+/** Find the last common ancestor two blocks have.\n+ *  Both pa and pb must be non-NULL. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n+    if (pa->nHeight > pb->nHeight) {\n+        pa = pa->GetAncestor(pb->nHeight);\n+    } else if (pb->nHeight > pa->nHeight) {\n+        pb = pb->GetAncestor(pa->nHeight);\n+    }\n+\n+    while (pa != pb && pa && pb) {\n+        pa = pa->pprev;\n+        pb = pb->pprev;\n+    }\n+\n+    // Eventually all chain branches meet at the genesis block.\n+    assert(pa == pb);\n+    return pa;\n+}"
      },
      {
        "sha": "c5304b7d6f3e10bb32a1313d88d308ed14813d11",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -362,6 +362,9 @@ class CBlockIndex\n arith_uint256 GetBlockProof(const CBlockIndex& block);\n /** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\n+/** Find the forking point between two chain tips. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb);\n+\n \n /** Used to marshal pointers into hashes for db storage. */\n class CDiskBlockIndex : public CBlockIndex"
      },
      {
        "sha": "dc4d2621ee0422dd01791031d0bd142439c69f23",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -124,12 +124,12 @@ class CMainParams : public CChainParams {\n         assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n \n         // Note that of those with the service bits flag, most only support a subset of possible options\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.sipa.be\", \"seed.bitcoin.sipa.be\", true)); // Pieter Wuille, only supports x1, x5, x9, and xd\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"dnsseed.bluematt.me\", true)); // Matt Corallo, only supports x9\n-        vSeeds.push_back(CDNSSeedData(\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\")); // Luke Dashjr\n-        vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\", true)); // Christian Decker, supports x1 - xf\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.jonasschnelli.ch\", \"seed.bitcoin.jonasschnelli.ch\", true)); // Jonas Schnelli, only supports x1, x5, x9, and xd\n-        vSeeds.push_back(CDNSSeedData(\"petertodd.org\", \"seed.btc.petertodd.org\", true)); // Peter Todd, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.bitcoin.sipa.be\", true); // Pieter Wuille, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"dnsseed.bluematt.me\", true); // Matt Corallo, only supports x9\n+        vSeeds.emplace_back(\"dnsseed.bitcoin.dashjr.org\", false); // Luke Dashjr\n+        vSeeds.emplace_back(\"seed.bitcoinstats.com\", true); // Christian Decker, supports x1 - xf\n+        vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\", true); // Jonas Schnelli, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.btc.petertodd.org\", true); // Peter Todd, only supports x1, x5, x9, and xd\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n@@ -225,10 +225,10 @@ class CTestNetParams : public CChainParams {\n         vFixedSeeds.clear();\n         vSeeds.clear();\n         // nodes with support for servicebits filtering should be at the top\n-        vSeeds.push_back(CDNSSeedData(\"testnetbitcoin.jonasschnelli.ch\", \"testnet-seed.bitcoin.jonasschnelli.ch\", true));\n-        vSeeds.push_back(CDNSSeedData(\"petertodd.org\", \"seed.tbtc.petertodd.org\", true));\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"testnet-seed.bluematt.me\"));\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.schildbach.de\", \"testnet-seed.bitcoin.schildbach.de\"));\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.jonasschnelli.ch\", true);\n+        vSeeds.emplace_back(\"seed.tbtc.petertodd.org\", true);\n+        vSeeds.emplace_back(\"testnet-seed.bluematt.me\", false);\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.schildbach.de\", false);\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);"
      },
      {
        "sha": "f55ae4cf7f068f8884f976c7a6c431bb7a778bcb",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,9 +15,9 @@\n #include <vector>\n \n struct CDNSSeedData {\n-    std::string name, host;\n+    std::string host;\n     bool supportsServiceBitsFiltering;\n-    CDNSSeedData(const std::string &strName, const std::string &strHost, bool supportsServiceBitsFilteringIn = false) : name(strName), host(strHost), supportsServiceBitsFiltering(supportsServiceBitsFilteringIn) {}\n+    CDNSSeedData(const std::string &strHost, bool supportsServiceBitsFilteringIn) : host(strHost), supportsServiceBitsFiltering(supportsServiceBitsFilteringIn) {}\n };\n \n struct SeedSpec6 {"
      },
      {
        "sha": "b5dc6197bd6956143dd38346eb7830c112af946c",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 8,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -11,16 +11,22 @@\n #include <assert.h>\n \n bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n-bool CCoinsView::HaveCoin(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n+std::vector<uint256> CCoinsView::GetHeadBlocks() const { return std::vector<uint256>(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n+bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n+{\n+    Coin coin;\n+    return GetCoin(outpoint, coin);\n+}\n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n+std::vector<uint256> CCoinsViewBacked::GetHeadBlocks() const { return base->GetHeadBlocks(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n@@ -55,7 +61,7 @@ bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n         coin = it->second.coin;\n-        return true;\n+        return !coin.IsSpent();\n     }\n     return false;\n }\n@@ -81,19 +87,20 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n     cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n }\n \n-void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) {\n     bool fCoinbase = tx.IsCoinBase();\n     const uint256& txid = tx.GetHash();\n     for (size_t i = 0; i < tx.vout.size(); ++i) {\n-        // Pass fCoinbase as the possible_overwrite flag to AddCoin, in order to correctly\n+        bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n+        // Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly\n         // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n-        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), fCoinbase);\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);\n     }\n }\n \n-void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n     CCoinsMap::iterator it = FetchCoin(outpoint);\n-    if (it == cacheCoins.end()) return;\n+    if (it == cacheCoins.end()) return false;\n     cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     if (moveout) {\n         *moveout = std::move(it->second.coin);\n@@ -104,6 +111,7 @@ void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n         it->second.flags |= CCoinsCacheEntry::DIRTY;\n         it->second.coin.Clear();\n     }\n+    return true;\n }\n \n static const Coin coinEmpty;\n@@ -124,7 +132,7 @@ bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n \n bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n     CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n-    return it != cacheCoins.end();\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n uint256 CCoinsViewCache::GetBestBlock() const {"
      },
      {
        "sha": "efb5ce869c3fc13365cc07e436b75c2a7364d3dd",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 27,
        "deletions": 8,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -145,16 +145,24 @@ class CCoinsViewCursor\n class CCoinsView\n {\n public:\n-    //! Retrieve the Coin (unspent transaction output) for a given outpoint.\n+    /** Retrieve the Coin (unspent transaction output) for a given outpoint.\n+     *  Returns true only when an unspent coin was found, which is returned in coin.\n+     *  When false is returned, coin's value is unspecified.\n+     */\n     virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n \n-    //! Just check whether we have data for a given outpoint.\n-    //! This may (but cannot always) return true for spent outputs.\n+    //! Just check whether a given outpoint is unspent.\n     virtual bool HaveCoin(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n+    //! Retrieve the range of blocks that may have been only partially written.\n+    //! If the database is in a consistent state, the result is the empty vector.\n+    //! Otherwise, a two-element vector is returned consisting of the new and\n+    //! the old block hash, in that order.\n+    virtual std::vector<uint256> GetHeadBlocks() const;\n+\n     //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n@@ -181,6 +189,7 @@ class CCoinsViewBacked : public CCoinsView\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     void SetBackend(CCoinsView &viewIn);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n@@ -224,8 +233,13 @@ class CCoinsViewCache : public CCoinsViewBacked\n \n     /**\n      * Return a reference to Coin in the cache, or a pruned one if not found. This is\n-     * more efficient than GetCoin. Modifications to other cache entries are\n-     * allowed while accessing the returned pointer.\n+     * more efficient than GetCoin.\n+     *\n+     * Generally, do not hold the reference returned for more than a short scope.\n+     * While the current implementation allows for modifications to the contents\n+     * of the cache while holding the reference, this behavior should not be relied\n+     * on! To be safe, best to not hold the returned reference through any other\n+     * calls to this cache.\n      */\n     const Coin& AccessCoin(const COutPoint &output) const;\n \n@@ -240,7 +254,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * If no unspent output exists for the passed outpoint, this call\n      * has no effect.\n      */\n-    void SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n+    bool SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n \n     /**\n      * Push the modifications applied to this cache to its base.\n@@ -284,12 +298,17 @@ class CCoinsViewCache : public CCoinsViewBacked\n };\n \n //! Utility function to add all of a transaction's outputs to a cache.\n-// It assumes that overwrites are only possible for coinbase transactions,\n+// When check is false, this assumes that overwrites are only possible for coinbase transactions.\n+// When check is true, the underlying view may be queried to determine whether an addition is\n+// an overwrite.\n // TODO: pass in a boolean to limit these possible overwrites to known\n // (pre-BIP34) cases.\n-void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight, bool check = false);\n \n //! Utility function to find any unspent output with a given txid.\n+// This function can be quite expensive because in the event of a transaction\n+// which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK\n+// lookups to database, so it should be used with care.\n const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n \n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "b4d1c90992b767f2f3676936f0478f2ef44a1b98",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -56,7 +56,7 @@ bool sanity_test_fdelt()\n }\n #endif\n \n-} // anon namespace\n+} // namespace\n \n bool glibc_sanity_test()\n {"
      },
      {
        "sha": "569fb1bbe886c5f561e5273a5f2fa3f086a32333",
        "filename": "src/compat/glibcxx_sanity.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/compat/glibcxx_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/compat/glibcxx_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_sanity.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -38,7 +38,7 @@ bool sanity_test_list(unsigned int size)\n     return true;\n }\n \n-} // anon namespace\n+} // namespace\n \n // trigger: string::at(x) on an empty string to trigger __throw_out_of_range_fmt.\n // test: force std::string to throw an out_of_range exception. Verify that"
      },
      {
        "sha": "58b2ed4b3e623daf4fe57be20fbff8781b40630f",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -12,7 +12,13 @@\n static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n /** The maximum allowed weight for a block, see BIP 141 (network rule) */\n static const unsigned int MAX_BLOCK_WEIGHT = 4000000;\n-/** The maximum allowed size for a block excluding witness data, in bytes (network rule) */\n+/**\n+ * The maximum allowed size for a block excluding witness data, in bytes (network rule).\n+ * This parameter is largely superfluous because it is directly implied by the above block\n+ *  weight limit, even when BIP 141 is not active.  It continues to exist for use in\n+ *  various early tests that run before the witness data has been checked.\n+ * All tests related to it could be removed without breaking consensus compatibility.\n+ */\n static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;"
      },
      {
        "sha": "0671cbc132f1624e0b14b74592a1bc1457e8c14c",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -126,7 +126,9 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n+        const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n+        assert(!coin.IsSpent());\n+        const CTxOut &prevout = coin.out;\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n     }\n@@ -146,7 +148,9 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n+        const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n+        assert(!coin.IsSpent());\n+        const CTxOut &prevout = coin.out;\n         nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n     }\n     return nSigOps;"
      },
      {
        "sha": "fd24d05ee7b998eab6bc7a4510e4d13fd1841f22",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 33,
        "deletions": 2,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -176,15 +176,15 @@ class cache\n      */\n     mutable std::vector<bool> epoch_flags;\n \n-    /** epoch_heuristic_counter is used to determine when a epoch might be aged\n+    /** epoch_heuristic_counter is used to determine when an epoch might be aged\n      * & an expensive scan should be done.  epoch_heuristic_counter is\n      * decremented on insert and reset to the new number of inserts which would\n      * cause the epoch to reach epoch_size when it reaches zero.\n      */\n     uint32_t epoch_heuristic_counter;\n \n     /** epoch_size is set to be the number of elements supposed to be in a\n-     * epoch. When the number of non-erased elements in a epoch\n+     * epoch. When the number of non-erased elements in an epoch\n      * exceeds epoch_size, a new epoch should be started and all\n      * current entries demoted. epoch_size is set to be 45% of size because\n      * we want to keep load around 90%, and we support 3 epochs at once --\n@@ -206,6 +206,37 @@ class cache\n     /** compute_hashes is convenience for not having to write out this\n      * expression everywhere we use the hash values of an Element.\n      *\n+     * We need to map the 32-bit input hash onto a hash bucket in a range [0, size) in a\n+     *  manner which preserves as much of the hash's uniformity as possible.  Ideally\n+     *  this would be done by bitmasking but the size is usually not a power of two.\n+     *\n+     * The naive approach would be to use a mod -- which isn't perfectly uniform but so\n+     *  long as the hash is much larger than size it is not that bad.  Unfortunately,\n+     *  mod/division is fairly slow on ordinary microprocessors (e.g. 90-ish cycles on\n+     *  haswell, ARM doesn't even have an instruction for it.); when the divisor is a\n+     *  constant the compiler will do clever tricks to turn it into a multiply+add+shift,\n+     *  but size is a run-time value so the compiler can't do that here.\n+     *\n+     * One option would be to implement the same trick the compiler uses and compute the\n+     *  constants for exact division based on the size, as described in \"{N}-bit Unsigned\n+     *  Division via {N}-bit Multiply-Add\" by Arch D. Robison in 2005. But that code is\n+     *  somewhat complicated and the result is still slower than other options:\n+     *\n+     * Instead we treat the 32-bit random number as a Q32 fixed-point number in the range\n+     *  [0,1) and simply multiply it by the size.  Then we just shift the result down by\n+     *  32-bits to get our bucket number.  The results has non-uniformity the same as a\n+     *  mod, but it is much faster to compute. More about this technique can be found at\n+     *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n+     *\n+     * The resulting non-uniformity is also more equally distributed which would be\n+     *  advantageous for something like linear probing, though it shouldn't matter\n+     *  one way or the other for a cuckoo table.\n+     *\n+     * The primary disadvantage of this approach is increased intermediate precision is\n+     *  required but for a 32-bit random number we only need the high 32 bits of a\n+     *  32*32->64 multiply, which means the operation is reasonably fast even on a\n+     *  typical 32-bit processor.\n+     *\n      * @param e the element whose hashes will be returned\n      * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n      */"
      },
      {
        "sha": "ba9e21cc1fce8b36a5b199290147b1d2fdbd0ac7",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -209,4 +209,4 @@ const std::vector<unsigned char>& GetObfuscateKey(const CDBWrapper &w)\n     return w.obfuscate_key;\n }\n \n-};\n+} // namespace dbwrapper_private"
      },
      {
        "sha": "8c2e0da32fd166f9af9a787e360d7697b81379f4",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 30,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -47,11 +47,11 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     HTTPRPCTimerInterface(struct event_base* _base) : base(_base)\n     {\n     }\n-    const char* Name()\n+    const char* Name() override\n     {\n         return \"HTTP\";\n     }\n-    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override\n     {\n         return new HTTPRPCTimer(base, func, millis);\n     }\n@@ -92,35 +92,32 @@ static bool multiUserAuthorized(std::string strUserPass)\n     std::string strUser = strUserPass.substr(0, strUserPass.find(\":\"));\n     std::string strPass = strUserPass.substr(strUserPass.find(\":\") + 1);\n \n-    if (gArgs.IsArgSet(\"-rpcauth\")) {\n+    for (const std::string& strRPCAuth : gArgs.GetArgs(\"-rpcauth\")) {\n         //Search for multi-user login/pass \"rpcauth\" from config\n-        for (std::string strRPCAuth : gArgs.GetArgs(\"-rpcauth\"))\n-        {\n-            std::vector<std::string> vFields;\n-            boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n-            if (vFields.size() != 3) {\n-                //Incorrect formatting in config file\n-                continue;\n-            }\n-\n-            std::string strName = vFields[0];\n-            if (!TimingResistantEqual(strName, strUser)) {\n-                continue;\n-            }\n-\n-            std::string strSalt = vFields[1];\n-            std::string strHash = vFields[2];\n-\n-            static const unsigned int KEY_SIZE = 32;\n-            unsigned char out[KEY_SIZE];\n-\n-            CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);\n-            std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n-            std::string strHashFromPass = HexStr(hexvec);\n-\n-            if (TimingResistantEqual(strHashFromPass, strHash)) {\n-                return true;\n-            }\n+        std::vector<std::string> vFields;\n+        boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n+        if (vFields.size() != 3) {\n+            //Incorrect formatting in config file\n+            continue;\n+        }\n+\n+        std::string strName = vFields[0];\n+        if (!TimingResistantEqual(strName, strUser)) {\n+            continue;\n+        }\n+\n+        std::string strSalt = vFields[1];\n+        std::string strHash = vFields[2];\n+\n+        static const unsigned int KEY_SIZE = 32;\n+        unsigned char out[KEY_SIZE];\n+\n+        CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);\n+        std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n+        std::string strHashFromPass = HexStr(hexvec);\n+\n+        if (TimingResistantEqual(strHashFromPass, strHash)) {\n+            return true;\n         }\n     }\n     return false;"
      },
      {
        "sha": "1c53d8d49d2a16da4b8a5940aae9225032d75911",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 28,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -21,13 +21,13 @@\n #include <signal.h>\n #include <future>\n \n-#include <event2/event.h>\n-#include <event2/http.h>\n #include <event2/thread.h>\n #include <event2/buffer.h>\n #include <event2/util.h>\n #include <event2/keyvalq_struct.h>\n \n+#include \"support/events.h\"\n+\n #ifdef EVENT__HAVE_NETINET_IN_H\n #include <netinet/in.h>\n #ifdef _XOPEN_SOURCE_EXTENDED\n@@ -46,7 +46,7 @@ class HTTPWorkItem : public HTTPClosure\n         req(std::move(_req)), path(_path), func(_func)\n     {\n     }\n-    void operator()()\n+    void operator()() override\n     {\n         func(req.get(), path);\n     }\n@@ -196,18 +196,16 @@ static bool InitHTTPAllowList()\n     LookupHost(\"::1\", localv6, false);\n     rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n-    if (gArgs.IsArgSet(\"-rpcallowip\")) {\n-        for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n-            CSubNet subnet;\n-            LookupSubNet(strAllow.c_str(), subnet);\n-            if (!subnet.IsValid()) {\n-                uiInterface.ThreadSafeMessageBox(\n-                    strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n-                return false;\n-            }\n-            rpc_allow_subnets.push_back(subnet);\n+    for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n+        CSubNet subnet;\n+        LookupSubNet(strAllow.c_str(), subnet);\n+        if (!subnet.IsValid()) {\n+            uiInterface.ThreadSafeMessageBox(\n+                strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n+                \"\", CClientUIInterface::MSG_ERROR);\n+            return false;\n         }\n+        rpc_allow_subnets.push_back(subnet);\n     }\n     std::string strAllowed;\n     for (const CSubNet& subnet : rpc_allow_subnets)\n@@ -367,9 +365,6 @@ static void libevent_log_cb(int severity, const char *msg)\n \n bool InitHTTPServer()\n {\n-    struct evhttp* http = 0;\n-    struct event_base* base = 0;\n-\n     if (!InitHTTPAllowList())\n         return false;\n \n@@ -395,17 +390,13 @@ bool InitHTTPServer()\n     evthread_use_pthreads();\n #endif\n \n-    base = event_base_new(); // XXX RAII\n-    if (!base) {\n-        LogPrintf(\"Couldn't create an event_base: exiting\\n\");\n-        return false;\n-    }\n+    raii_event_base base_ctr = obtain_event_base();\n \n     /* Create a new evhttp object to handle requests. */\n-    http = evhttp_new(base); // XXX RAII\n+    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n+    struct evhttp* http = http_ctr.get();\n     if (!http) {\n         LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        event_base_free(base);\n         return false;\n     }\n \n@@ -416,8 +407,6 @@ bool InitHTTPServer()\n \n     if (!HTTPBindAddresses(http)) {\n         LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        evhttp_free(http);\n-        event_base_free(base);\n         return false;\n     }\n \n@@ -426,8 +415,9 @@ bool InitHTTPServer()\n     LogPrintf(\"HTTP: creating work queue of depth %d\\n\", workQueueDepth);\n \n     workQueue = new WorkQueue<HTTPClosure>(workQueueDepth);\n-    eventBase = base;\n-    eventHTTP = http;\n+    // tranfer ownership to eventBase/HTTP via .release()\n+    eventBase = base_ctr.release();\n+    eventHTTP = http_ctr.release();\n     return true;\n }\n "
      },
      {
        "sha": "9df56e5fc554926db46af8efcb47dba7869a403f",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -86,7 +86,7 @@ class HTTPRequest\n \n     /**\n      * Get the request header specified by hdr, or an empty string.\n-     * Return an pair (isPresent,string).\n+     * Return a pair (isPresent,string).\n      */\n     std::pair<bool, std::string> GetHeader(const std::string& hdr);\n \n@@ -125,7 +125,7 @@ class HTTPClosure\n     virtual ~HTTPClosure() {}\n };\n \n-/** Event class. This can be used either as an cross-thread trigger or as a timer.\n+/** Event class. This can be used either as a cross-thread trigger or as a timer.\n  */\n class HTTPEvent\n {"
      },
      {
        "sha": "672ef77e80fa64401195a8e3b8f2c2c0a7258eb5",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 107,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -88,14 +88,6 @@ static CZMQNotificationInterface* pzmqNotificationInterface = NULL;\n #define MIN_CORE_FILEDESCRIPTORS 150\n #endif\n \n-/** Used to pass flags to the Bind() function */\n-enum BindFlags {\n-    BF_NONE         = 0,\n-    BF_EXPLICIT     = (1U << 0),\n-    BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n-};\n-\n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -296,17 +288,6 @@ static void registerSignalHandler(int signal, void(*handler)(int))\n }\n #endif\n \n-bool static Bind(CConnman& connman, const CService &addr, unsigned int flags) {\n-    if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n-        return false;\n-    std::string strError;\n-    if (!connman.BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n-        if (flags & BF_REPORT_ERROR)\n-            return InitError(strError);\n-        return false;\n-    }\n-    return true;\n-}\n void OnRPCStarted()\n {\n     uiInterface.NotifyBlockTip.connect(&RPCNotifyBlockChange);\n@@ -355,6 +336,9 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     }\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n+    if (showDebug) {\n+        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n+    }\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER));\n@@ -463,7 +447,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n         strUsage += HelpMessageOpt(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\");\n-        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit size of signature cache to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n+        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n         strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n     }\n     strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n@@ -822,7 +806,7 @@ int nUserMaxConnections;\n int nFD;\n ServiceFlags nLocalServices = NODE_NETWORK;\n \n-}\n+} // namespace\n \n [[noreturn]] static void new_handler_terminate()\n {\n@@ -844,8 +828,6 @@ bool AppInitBasicSetup()\n     // Turn off Microsoft heap dump noise\n     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n     _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n-#endif\n-#if _MSC_VER >= 1400\n     // Disable confusing \"helpful\" text message on abort, Ctrl-C\n     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n #endif\n@@ -900,10 +882,14 @@ bool AppInitParameterInteraction()\n             return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n     }\n \n+    // -bind and -whitebind can't be set when not listening\n+    size_t nUserBind = gArgs.GetArgs(\"-bind\").size() + gArgs.GetArgs(\"-whitebind\").size();\n+    if (nUserBind != 0 && !gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n+        return InitError(\"Cannot set -bind or -whitebind together with -listen=0\");\n+    }\n+\n     // Make sure enough file descriptors are available\n-    int nBind = std::max(\n-                (gArgs.IsArgSet(\"-bind\") ? gArgs.GetArgs(\"-bind\").size() : 0) +\n-                (gArgs.IsArgSet(\"-whitebind\") ? gArgs.GetArgs(\"-whitebind\").size() : 0), size_t(1));\n+    int nBind = std::max(nUserBind, size_t(1));\n     nUserMaxConnections = GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n@@ -935,15 +921,13 @@ bool AppInitParameterInteraction()\n     }\n \n     // Now remove the logging categories which were explicitly excluded\n-    if (gArgs.IsArgSet(\"-debugexclude\")) {\n-        for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n-            uint32_t flag = 0;\n-            if (!GetLogCategory(&flag, &cat)) {\n-                InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n-                continue;\n-            }\n-            logCategories &= ~flag;\n+    for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n+        uint32_t flag = 0;\n+        if (!GetLogCategory(&flag, &cat)) {\n+            InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n+            continue;\n         }\n+        logCategories &= ~flag;\n     }\n \n     // Check for -debugnet\n@@ -1030,14 +1014,7 @@ bool AppInitParameterInteraction()\n     if (nConnectTimeout <= 0)\n         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n \n-    // Fee-per-kilobyte amount required for mempool acceptance and relay\n-    // If you are mining, be careful setting this:\n-    // if you set it to zero then\n-    // a transaction spammer can cheaply fill blocks using\n-    // 0-fee transactions. It should be set above the real\n-    // cost to you of processing a transaction.\n-    if (IsArgSet(\"-minrelaytxfee\"))\n-    {\n+    if (IsArgSet(\"-minrelaytxfee\")) {\n         CAmount n = 0;\n         if (!ParseMoney(GetArg(\"-minrelaytxfee\", \"\"), n)) {\n             return InitError(AmountErrMsg(\"minrelaytxfee\", GetArg(\"-minrelaytxfee\", \"\")));\n@@ -1214,6 +1191,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     InitSignatureCache();\n+    InitScriptExecutionCache();\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n     if (nScriptCheckThreads) {\n@@ -1260,13 +1238,10 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n-    if (gArgs.IsArgSet(\"-uacomment\")) {\n-        for (std::string cmt : gArgs.GetArgs(\"-uacomment\"))\n-        {\n-            if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n-                return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n-            uacomments.push_back(cmt);\n-        }\n+    for (const std::string& cmt : gArgs.GetArgs(\"-uacomment\")) {\n+        if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n+            return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n+        uacomments.push_back(cmt);\n     }\n     strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);\n     if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {\n@@ -1289,16 +1264,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (gArgs.IsArgSet(\"-whitelist\")) {\n-        for (const std::string& net : gArgs.GetArgs(\"-whitelist\")) {\n-            CSubNet subnet;\n-            LookupSubNet(net.c_str(), subnet);\n-            if (!subnet.IsValid())\n-                return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n-            connman.AddWhitelistedRange(subnet);\n-        }\n-    }\n-\n     // Check for host lookup allowed before parsing any network related parameters\n     fNameLookup = GetBoolArg(\"-dns\", DEFAULT_NAME_LOOKUP);\n \n@@ -1349,44 +1314,12 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     fDiscover = GetBoolArg(\"-discover\", true);\n     fRelayTxes = !GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY);\n \n-    if (fListen) {\n-        bool fBound = false;\n-        if (gArgs.IsArgSet(\"-bind\")) {\n-            for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) {\n-                CService addrBind;\n-                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n-                    return InitError(ResolveErrMsg(\"bind\", strBind));\n-                fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n-            }\n-        }\n-        if (gArgs.IsArgSet(\"-whitebind\")) {\n-            for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) {\n-                CService addrBind;\n-                if (!Lookup(strBind.c_str(), addrBind, 0, false))\n-                    return InitError(ResolveErrMsg(\"whitebind\", strBind));\n-                if (addrBind.GetPort() == 0)\n-                    return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n-                fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n-            }\n-        }\n-        if (!gArgs.IsArgSet(\"-bind\") && !gArgs.IsArgSet(\"-whitebind\")) {\n-            struct in_addr inaddr_any;\n-            inaddr_any.s_addr = INADDR_ANY;\n-            fBound |= Bind(connman, CService(in6addr_any, GetListenPort()), BF_NONE);\n-            fBound |= Bind(connman, CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n-        }\n-        if (!fBound)\n-            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n-    }\n-\n-    if (gArgs.IsArgSet(\"-externalip\")) {\n-        for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) {\n-            CService addrLocal;\n-            if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n-                AddLocal(addrLocal, LOCAL_MANUAL);\n-            else\n-                return InitError(ResolveErrMsg(\"externalip\", strAddr));\n-        }\n+    for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) {\n+        CService addrLocal;\n+        if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n+            AddLocal(addrLocal, LOCAL_MANUAL);\n+        else\n+            return InitError(ResolveErrMsg(\"externalip\", strAddr));\n     }\n \n #if ENABLE_ZMQ\n@@ -1426,7 +1359,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set (plus up to %.1fMiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n     bool fLoaded = false;\n-    while (!fLoaded) {\n+    while (!fLoaded && !fRequestShutdown) {\n         bool fReset = fReindex;\n         std::string strLoadError;\n \n@@ -1444,7 +1377,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n                 pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n-                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n \n                 if (fReindex) {\n                     pblocktree->WriteReindexing(true);\n@@ -1458,6 +1390,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                         break;\n                     }\n                 }\n+                if (fRequestShutdown) break;\n \n                 if (!LoadBlockIndex(chainparams)) {\n                     strLoadError = _(\"Error loading block database\");\n@@ -1488,6 +1421,13 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                if (!ReplayBlocks(chainparams, pcoinsdbview)) {\n+                    strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n+                    break;\n+                }\n+                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n+                LoadChainTip(chainparams);\n+\n                 if (!fReindex && chainActive.Tip() != NULL) {\n                     uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                     if (!RewindBlockIndex(chainparams)) {\n@@ -1528,7 +1468,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             fLoaded = true;\n         } while(false);\n \n-        if (!fLoaded) {\n+        if (!fLoaded && !fRequestShutdown) {\n             // first suggest a reindex\n             if (!fReset) {\n                 bool fRet = uiInterface.ThreadSafeQuestion(\n@@ -1615,10 +1555,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n     std::vector<fs::path> vImportFiles;\n-    if (gArgs.IsArgSet(\"-loadblock\"))\n-    {\n-        for (const std::string& strFile : gArgs.GetArgs(\"-loadblock\"))\n-            vImportFiles.push_back(strFile);\n+    for (const std::string& strFile : gArgs.GetArgs(\"-loadblock\")) {\n+        vImportFiles.push_back(strFile);\n     }\n \n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n@@ -1645,7 +1583,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     // Map ports with UPnP\n     MapPort(GetBoolArg(\"-upnp\", DEFAULT_UPNP));\n \n-    std::string strNodeError;\n     CConnman::Options connOptions;\n     connOptions.nLocalServices = nLocalServices;\n     connOptions.nRelevantServices = nRelevantServices;\n@@ -1661,12 +1598,39 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n \n+    for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) {\n+        CService addrBind;\n+        if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false)) {\n+            return InitError(ResolveErrMsg(\"bind\", strBind));\n+        }\n+        connOptions.vBinds.push_back(addrBind);\n+    }\n+    for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) {\n+        CService addrBind;\n+        if (!Lookup(strBind.c_str(), addrBind, 0, false)) {\n+            return InitError(ResolveErrMsg(\"whitebind\", strBind));\n+        }\n+        if (addrBind.GetPort() == 0) {\n+            return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n+        }\n+        connOptions.vWhiteBinds.push_back(addrBind);\n+    }\n+\n+    for (const auto& net : gArgs.GetArgs(\"-whitelist\")) {\n+        CSubNet subnet;\n+        LookupSubNet(net.c_str(), subnet);\n+        if (!subnet.IsValid())\n+            return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n+        connOptions.vWhitelistedRange.push_back(subnet);\n+    }\n+\n     if (gArgs.IsArgSet(\"-seednode\")) {\n         connOptions.vSeedNodes = gArgs.GetArgs(\"-seednode\");\n     }\n \n-    if (!connman.Start(scheduler, strNodeError, connOptions))\n-        return InitError(strNodeError);\n+    if (!connman.Start(scheduler, connOptions)) {\n+        return false;\n+    }\n \n     // ********************************************************* Step 12: finished\n "
      },
      {
        "sha": "965ae0c79ad865193afe0fb7041ca2c0ffe5f751",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -60,9 +60,9 @@ class CBasicKeyStore : public CKeyStore\n     WatchOnlySet setWatchOnly;\n \n public:\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n-    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n-    bool HaveKey(const CKeyID &address) const\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    bool HaveKey(const CKeyID &address) const override\n     {\n         bool result;\n         {\n@@ -71,7 +71,7 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return result;\n     }\n-    void GetKeys(std::set<CKeyID> &setAddress) const\n+    void GetKeys(std::set<CKeyID> &setAddress) const override\n     {\n         setAddress.clear();\n         {\n@@ -84,7 +84,7 @@ class CBasicKeyStore : public CKeyStore\n             }\n         }\n     }\n-    bool GetKey(const CKeyID &address, CKey &keyOut) const\n+    bool GetKey(const CKeyID &address, CKey &keyOut) const override\n     {\n         {\n             LOCK(cs_KeyStore);\n@@ -97,14 +97,14 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n-    virtual bool AddCScript(const CScript& redeemScript);\n-    virtual bool HaveCScript(const CScriptID &hash) const;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const;\n+    virtual bool AddCScript(const CScript& redeemScript) override;\n+    virtual bool HaveCScript(const CScriptID &hash) const override;\n+    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override;\n \n-    virtual bool AddWatchOnly(const CScript &dest);\n-    virtual bool RemoveWatchOnly(const CScript &dest);\n-    virtual bool HaveWatchOnly(const CScript &dest) const;\n-    virtual bool HaveWatchOnly() const;\n+    virtual bool AddWatchOnly(const CScript &dest) override;\n+    virtual bool RemoveWatchOnly(const CScript &dest) override;\n+    virtual bool HaveWatchOnly(const CScript &dest) const override;\n+    virtual bool HaveWatchOnly() const override;\n };\n \n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;"
      },
      {
        "sha": "7935a965a7c9fdd62533a8c13c9b6033675066df",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -376,7 +376,7 @@ class Compaction {\n   // Each compaction reads inputs from \"level_\" and \"level_+1\"\n   std::vector<FileMetaData*> inputs_[2];      // The two sets of inputs\n \n-  // State used to check for number of of overlapping grandparent files\n+  // State used to check for number of overlapping grandparent files\n   // (parent == level_ + 1, grandparent == level_ + 2)\n   std::vector<FileMetaData*> grandparents_;\n   size_t grandparent_index_;  // Index in grandparent_starts_"
      },
      {
        "sha": "301cf58b8705e4bda0de4f965be097cd7cfeb0d2",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 27,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -64,6 +64,14 @@\n #endif\n #endif\n \n+/** Used to pass flags to the Bind() function */\n+enum BindFlags {\n+    BF_NONE         = 0,\n+    BF_EXPLICIT     = (1U << 0),\n+    BF_REPORT_ERROR = (1U << 1),\n+    BF_WHITELIST    = (1U << 2),\n+};\n+\n const static std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n@@ -240,7 +248,7 @@ bool RemoveLocal(const CService& addr)\n /** Make a particular network entirely off-limits (no automatic connects to it) */\n void SetLimited(enum Network net, bool fLimited)\n {\n-    if (net == NET_UNROUTABLE)\n+    if (net == NET_UNROUTABLE || net == NET_INTERNAL)\n         return;\n     LOCK(cs_mapLocalHost);\n     vfLimited[net] = fLimited;\n@@ -601,20 +609,13 @@ void CConnman::SetBannedSetDirty(bool dirty)\n \n \n bool CConnman::IsWhitelistedRange(const CNetAddr &addr) {\n-    LOCK(cs_vWhitelistedRange);\n     for (const CSubNet& subnet : vWhitelistedRange) {\n         if (subnet.Match(addr))\n             return true;\n     }\n     return false;\n }\n \n-void CConnman::AddWhitelistedRange(const CSubNet &subnet) {\n-    LOCK(cs_vWhitelistedRange);\n-    vWhitelistedRange.push_back(subnet);\n-}\n-\n-\n std::string CNode::GetAddrName() const {\n     LOCK(cs_addrName);\n     return addrName;\n@@ -1604,7 +1605,12 @@ void CConnman::ThreadDNSAddressSeed()\n             std::vector<CNetAddr> vIPs;\n             std::vector<CAddress> vAdd;\n             ServiceFlags requiredServiceBits = nRelevantServices;\n-            if (LookupHost(GetDNSHost(seed, &requiredServiceBits).c_str(), vIPs, 0, true))\n+            std::string host = GetDNSHost(seed, &requiredServiceBits);\n+            CNetAddr resolveSource;\n+            if (!resolveSource.SetInternal(host)) {\n+                continue;\n+            }\n+            if (LookupHost(host.c_str(), vIPs, 0, true))\n             {\n                 for (const CNetAddr& ip : vIPs)\n                 {\n@@ -1614,18 +1620,7 @@ void CConnman::ThreadDNSAddressSeed()\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n-            }\n-            if (interruptNet) {\n-                return;\n-            }\n-            // TODO: The seed name resolve may fail, yielding an IP of [::], which results in\n-            // addrman assigning the same source to results from different seeds.\n-            // This should switch to a hard-coded stable dummy IP for each seed name, so that the\n-            // resolve is not required at all.\n-            if (!vIPs.empty()) {\n-                CService seedSource;\n-                Lookup(seed.name.c_str(), seedSource, 0, true);\n-                addrman.Add(vAdd, seedSource);\n+                addrman.Add(vAdd, resolveSource);\n             }\n         }\n     }\n@@ -1682,7 +1677,7 @@ void CConnman::ProcessOneShot()\n void CConnman::ThreadOpenConnections()\n {\n     // Connect to specific addresses\n-    if (gArgs.IsArgSet(\"-connect\") && gArgs.GetArgs(\"-connect\").size() > 0)\n+    if (gArgs.IsArgSet(\"-connect\"))\n     {\n         for (int64_t nLoop = 0;; nLoop++)\n         {\n@@ -1724,7 +1719,7 @@ void CConnman::ThreadOpenConnections()\n             if (!done) {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n                 CNetAddr local;\n-                LookupHost(\"127.0.0.1\", local, false);\n+                local.SetInternal(\"fixedseeds\");\n                 addrman.Add(convertSeed6(Params().FixedSeeds()), local);\n                 done = true;\n             }\n@@ -1908,8 +1903,7 @@ void CConnman::ThreadOpenAddedConnections()\n {\n     {\n         LOCK(cs_vAddedNodes);\n-        if (gArgs.IsArgSet(\"-addnode\"))\n-            vAddedNodes = gArgs.GetArgs(\"-addnode\");\n+        vAddedNodes = gArgs.GetArgs(\"-addnode\");\n     }\n \n     while (true)\n@@ -2226,7 +2220,38 @@ NodeId CConnman::GetNewNodeId()\n     return nLastNodeId.fetch_add(1, std::memory_order_relaxed);\n }\n \n-bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options connOptions)\n+\n+bool CConnman::Bind(const CService &addr, unsigned int flags) {\n+    if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n+        return false;\n+    std::string strError;\n+    if (!BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n+        if ((flags & BF_REPORT_ERROR) && clientInterface) {\n+            clientInterface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds) {\n+    bool fBound = false;\n+    for (const auto& addrBind : binds) {\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n+    }\n+    for (const auto& addrBind : whiteBinds) {\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n+    }\n+    if (binds.empty() && whiteBinds.empty()) {\n+        struct in_addr inaddr_any;\n+        inaddr_any.s_addr = INADDR_ANY;\n+        fBound |= Bind(CService(in6addr_any, GetListenPort()), BF_NONE);\n+        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n+    }\n+    return fBound;\n+}\n+\n+bool CConnman::Start(CScheduler& scheduler, Options connOptions)\n {\n     nTotalBytesRecv = 0;\n     nTotalBytesSent = 0;\n@@ -2248,11 +2273,23 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n \n     SetBestHeight(connOptions.nBestHeight);\n \n+    clientInterface = connOptions.uiInterface;\n+\n+    if (fListen && !InitBinds(connOptions.vBinds, connOptions.vWhiteBinds)) {\n+        if (clientInterface) {\n+            clientInterface->ThreadSafeMessageBox(\n+                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n+                \"\", CClientUIInterface::MSG_ERROR);\n+        }\n+        return false;\n+    }\n+\n+    vWhitelistedRange = connOptions.vWhitelistedRange;\n+\n     for (const auto& strDest : connOptions.vSeedNodes) {\n         AddOneShot(strDest);\n     }\n \n-    clientInterface = connOptions.uiInterface;\n     if (clientInterface) {\n         clientInterface->InitMessage(_(\"Loading P2P addresses...\"));\n     }"
      },
      {
        "sha": "dc25e7a5dd6c33db12bf8e70579ed08b6051b810",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -144,13 +144,14 @@ class CConnman\n         uint64_t nMaxOutboundTimeframe = 0;\n         uint64_t nMaxOutboundLimit = 0;\n         std::vector<std::string> vSeedNodes;\n+        std::vector<CSubNet> vWhitelistedRange;\n+        std::vector<CService> vBinds, vWhiteBinds;\n     };\n     CConnman(uint64_t seed0, uint64_t seed1);\n     ~CConnman();\n-    bool Start(CScheduler& scheduler, std::string& strNodeError, Options options);\n+    bool Start(CScheduler& scheduler, Options options);\n     void Stop();\n     void Interrupt();\n-    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n     bool GetNetworkActive() const { return fNetworkActive; };\n     void SetNetworkActive(bool active);\n     bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n@@ -244,8 +245,6 @@ class CConnman\n \n     unsigned int GetSendBufferSize() const;\n \n-    void AddWhitelistedRange(const CSubNet &subnet);\n-\n     ServiceFlags GetLocalServices() const;\n \n     //!set the max outbound target in bytes\n@@ -289,6 +288,9 @@ class CConnman\n         ListenSocket(SOCKET socket_, bool whitelisted_) : socket(socket_), whitelisted(whitelisted_) {}\n     };\n \n+    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n+    bool Bind(const CService &addr, unsigned int flags);\n+    bool InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds);\n     void ThreadOpenAddedConnections();\n     void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n@@ -346,7 +348,6 @@ class CConnman\n     // Whitelisted ranges. Any node connecting from these is automatically\n     // whitelisted (as well as those connecting to whitelisted binds).\n     std::vector<CSubNet> vWhitelistedRange;\n-    CCriticalSection cs_vWhitelistedRange;\n \n     unsigned int nSendBufferMaxSize;\n     unsigned int nReceiveFloodSize;"
      },
      {
        "sha": "4d832f37113ef1f78ad95d1c97d938745f77cb9d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 22,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -120,7 +120,7 @@ namespace {\n     MapRelay mapRelay;\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs, protected by cs_main). */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n-} // anon namespace\n+} // namespace\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -342,7 +342,9 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n     // Short-circuit most stuff in case its from the same node\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n-        *pit = &itInFlight->second.second;\n+        if (pit) {\n+            *pit = &itInFlight->second.second;\n+        }\n         return false;\n     }\n \n@@ -450,25 +452,6 @@ bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n     return false;\n }\n \n-/** Find the last common ancestor two blocks have.\n- *  Both pa and pb must be non-NULL. */\n-const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n-    if (pa->nHeight > pb->nHeight) {\n-        pa = pa->GetAncestor(pb->nHeight);\n-    } else if (pb->nHeight > pa->nHeight) {\n-        pb = pb->GetAncestor(pa->nHeight);\n-    }\n-\n-    while (pa != pb && pa && pb) {\n-        pa = pa->pprev;\n-        pb = pb->pprev;\n-    }\n-\n-    // Eventually all chain branches meet at the genesis block.\n-    assert(pa == pb);\n-    return pa;\n-}\n-\n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n@@ -557,7 +540,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n     }\n }\n \n-} // anon namespace\n+} // namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);"
      },
      {
        "sha": "89f257c6422c69a71cf938e4ece666355e6f6650",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 7,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,6 +15,9 @@\n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n \n+// 0xFD + sha256(\"bitcoin\")[0:5]\n+static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n+\n void CNetAddr::Init()\n {\n     memset(ip, 0, sizeof(ip));\n@@ -42,6 +45,18 @@ void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n     }\n }\n \n+bool CNetAddr::SetInternal(const std::string &name)\n+{\n+    if (name.empty()) {\n+        return false;\n+    }\n+    unsigned char hash[32] = {};\n+    CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\n+    memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\n+    memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));\n+    return true;\n+}\n+\n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n@@ -84,7 +99,7 @@ bool CNetAddr::IsIPv4() const\n \n bool CNetAddr::IsIPv6() const\n {\n-    return (!IsIPv4() && !IsTor());\n+    return (!IsIPv4() && !IsTor() && !IsInternal());\n }\n \n bool CNetAddr::IsRFC1918() const\n@@ -199,6 +214,9 @@ bool CNetAddr::IsValid() const\n     if (IsRFC3849())\n         return false;\n \n+    if (IsInternal())\n+        return false;\n+\n     if (IsIPv4())\n     {\n         // INADDR_NONE\n@@ -217,11 +235,19 @@ bool CNetAddr::IsValid() const\n \n bool CNetAddr::IsRoutable() const\n {\n-    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n+    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal() || IsInternal());\n+}\n+\n+bool CNetAddr::IsInternal() const\n+{\n+   return memcmp(ip, g_internal_prefix, sizeof(g_internal_prefix)) == 0;\n }\n \n enum Network CNetAddr::GetNetwork() const\n {\n+    if (IsInternal())\n+        return NET_INTERNAL;\n+\n     if (!IsRoutable())\n         return NET_UNROUTABLE;\n \n@@ -238,6 +264,8 @@ std::string CNetAddr::ToStringIP() const\n {\n     if (IsTor())\n         return EncodeBase32(&ip[6], 10) + \".onion\";\n+    if (IsInternal())\n+        return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + \".internal\";\n     CService serv(*this, 0);\n     struct sockaddr_storage sockaddr;\n     socklen_t socklen = sizeof(sockaddr);\n@@ -305,9 +333,15 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n         nClass = 255;\n         nBits = 0;\n     }\n-\n-    // all unroutable addresses belong to the same group\n-    if (!IsRoutable())\n+    // all internal-usage addresses get their own group\n+    if (IsInternal())\n+    {\n+        nClass = NET_INTERNAL;\n+        nStartByte = sizeof(g_internal_prefix);\n+        nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;\n+    }\n+    // all other unroutable addresses belong to the same group\n+    else if (!IsRoutable())\n     {\n         nClass = NET_UNROUTABLE;\n         nBits = 0;\n@@ -393,7 +427,7 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n         REACH_PRIVATE\n     };\n \n-    if (!IsRoutable())\n+    if (!IsRoutable() || IsInternal())\n         return REACH_UNREACHABLE;\n \n     int ourNet = GetExtNetwork(this);\n@@ -552,7 +586,7 @@ std::string CService::ToStringPort() const\n \n std::string CService::ToStringIPPort() const\n {\n-    if (IsIPv4() || IsTor()) {\n+    if (IsIPv4() || IsTor() || IsInternal()) {\n         return ToStringIP() + \":\" + ToStringPort();\n     } else {\n         return \"[\" + ToStringIP() + \"]:\" + ToStringPort();"
      },
      {
        "sha": "80716600d17f004e765561b142fa9aeada2f3971",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -22,6 +22,7 @@ enum Network\n     NET_IPV4,\n     NET_IPV6,\n     NET_TOR,\n+    NET_INTERNAL,\n \n     NET_MAX,\n };\n@@ -45,6 +46,12 @@ class CNetAddr\n          */\n         void SetRaw(Network network, const uint8_t *data);\n \n+        /**\n+          * Transform an arbitrary string into a non-routable ipv6 address.\n+          * Useful for mapping resolved addresses back to their source.\n+         */\n+        bool SetInternal(const std::string& name);\n+\n         bool SetSpecial(const std::string &strName); // for Tor addresses\n         bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n         bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n@@ -64,6 +71,7 @@ class CNetAddr\n         bool IsTor() const;\n         bool IsLocal() const;\n         bool IsRoutable() const;\n+        bool IsInternal() const;\n         bool IsValid() const;\n         enum Network GetNetwork() const;\n         std::string ToString() const;"
      },
      {
        "sha": "a23f92e1ed00ac56d2e61b2aca296cabac614f74",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -108,17 +108,22 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     struct addrinfo *aiTrav = aiRes;\n     while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n     {\n+        CNetAddr resolved;\n         if (aiTrav->ai_family == AF_INET)\n         {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n-            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n+            resolved = CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\n         }\n \n         if (aiTrav->ai_family == AF_INET6)\n         {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n             struct sockaddr_in6* s6 = (struct sockaddr_in6*) aiTrav->ai_addr;\n-            vIP.push_back(CNetAddr(s6->sin6_addr, s6->sin6_scope_id));\n+            resolved = CNetAddr(s6->sin6_addr, s6->sin6_scope_id);\n+        }\n+        /* Never allow resolving to an internal address. Consider any such result invalid */\n+        if (!resolved.IsInternal()) {\n+            vIP.push_back(resolved);\n         }\n \n         aiTrav = aiTrav->ai_next;"
      },
      {
        "sha": "2029ce37448eb67554db29abd4bdfad833e50b28",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -48,7 +48,7 @@ class TxConfirmStats;\n  * in each bucket and the total amount of feerate paid in each bucket. Then we\n  * calculate how many blocks Y it took each transaction to be mined.  We convert\n  * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n- * blocks.  This is is tracked in 3 different data sets each up to a maximum\n+ * blocks.  This is tracked in 3 different data sets each up to a maximum\n  * number of periods. Within each data set we have an array of counters in each\n  * feerate bucket and we increment all the counters from Y' up to max periods\n  * representing that a tx was successfully confirmed in less than or equal to"
      },
      {
        "sha": "da87e40091f65088ce6fff620cb27884bbbbae22",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -39,7 +39,7 @@ const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n-};\n+} // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n  * messages above and in protocol.h."
      },
      {
        "sha": "a16457ea4ee39babac484348faf98764d0063974",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -11,7 +11,7 @@ namespace\n {\n /* Global secp256k1_context object used for verification. */\n secp256k1_context* secp256k1_context_verify = NULL;\n-}\n+} // namespace\n \n /** This function is taken from the libsecp256k1 distribution and implements\n  *  DER parsing for ECDSA signatures, while supporting an arbitrary subset of"
      },
      {
        "sha": "8a745cadce7d8aa7df069db5578002b5dcf7fb0a",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -578,6 +578,7 @@ int main(int argc, char *argv[])\n     //   Need to pass name here as CAmount is a typedef (see http://qt-project.org/doc/qt-5/qmetatype.html#qRegisterMetaType)\n     //   IMPORTANT if it is no longer a typedef use the normal variant above\n     qRegisterMetaType< CAmount >(\"CAmount\");\n+    qRegisterMetaType< std::function<void(void)> >(\"std::function<void(void)>\");\n \n     /// 3. Application identification\n     // must be set before OptionsModel is initialized or translations are loaded,"
      },
      {
        "sha": "33f4535ee22a56e13d063c005eb63ebe7f7cfb3e",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -26,7 +26,6 @@\n \n class CBlockIndex;\n \n-static const int64_t nClientStartupTime = GetTime();\n static int64_t nLastHeaderTipUpdateNotification = 0;\n static int64_t nLastBlockTipUpdateNotification = 0;\n \n@@ -238,7 +237,7 @@ bool ClientModel::isReleaseVersion() const\n \n QString ClientModel::formatClientStartupTime() const\n {\n-    return QDateTime::fromTime_t(nClientStartupTime).toString();\n+    return QDateTime::fromTime_t(GetStartupTime()).toString();\n }\n \n QString ClientModel::dataDir() const\n@@ -303,7 +302,7 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n     }\n     // if we are in-sync, update the UI regardless of last update time\n     if (!initialSync || now - nLastUpdateNotification > MODEL_UPDATE_DELAY) {\n-        //pass a async signal to the UI thread\n+        //pass an async signal to the UI thread\n         QMetaObject::invokeMethod(clientmodel, \"numBlocksChanged\", Qt::QueuedConnection,\n                                   Q_ARG(int, pIndex->nHeight),\n                                   Q_ARG(QDateTime, QDateTime::fromTime_t(pIndex->GetBlockTime())),"
      },
      {
        "sha": "af9a888d94f971da1f11ac3864157f3e6dd15e35",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -499,7 +499,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             // there is some fudging in these numbers related to the actual virtual transaction size calculation that will keep this estimate from being exact.\n             // usually, the result will be an overestimate within a couple of satoshis so that the confirmation dialog ends up displaying a slightly smaller fee.\n-            // also, the witness stack size value value is a variable sized integer. usually, the number of stack items will be well under the single byte var int limit.\n+            // also, the witness stack size value is a variable sized integer. usually, the number of stack items will be well under the single byte var int limit.\n             nBytes += 2; // account for the serialized marker and flag bytes\n             nBytes += nQuantity; // account for the witness byte that holds the number of stack items for each input.\n         }\n@@ -524,13 +524,10 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n                 CTxOut txout(nChange, (CScript)std::vector<unsigned char>(24, 0));\n                 if (IsDust(txout, ::dustRelayFee))\n                 {\n-                    if (CoinControlDialog::fSubtractFeeFromAmount) // dust-change will be raised until no dust\n-                        nChange = GetDustThreshold(txout, ::dustRelayFee);\n-                    else\n-                    {\n-                        nPayFee += nChange;\n-                        nChange = 0;\n-                    }\n+                    nPayFee += nChange;\n+                    nChange = 0;\n+                    if (CoinControlDialog::fSubtractFeeFromAmount)\n+                        nBytes -= 34; // we didn't detect lack of change above\n                 }\n             }\n "
      },
      {
        "sha": "14078b9ee810503a326b2d212d001e1777c8316c",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -315,7 +315,7 @@\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n-            <string>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n            </property>\n            <property name=\"text\">\n             <string/>\n@@ -338,7 +338,7 @@\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n-            <string>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n            </property>\n            <property name=\"text\">\n             <string/>\n@@ -361,7 +361,7 @@\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n-            <string>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n            </property>\n            <property name=\"text\">\n             <string/>"
      },
      {
        "sha": "a83f285034fdb8b30330800c28e5913fc6b42fd4",
        "filename": "src/qt/modaloverlay.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/modaloverlay.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/modaloverlay.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -126,7 +126,7 @@ void ModalOverlay::tipUpdate(int count, const QDateTime& blockDate, double nVeri\n         return;\n \n     // estimate the number of headers left based on nPowTargetSpacing\n-    // and check if the gui is not aware of the the best header (happens rarely)\n+    // and check if the gui is not aware of the best header (happens rarely)\n     int estimateNumHeadersLeft = bestHeaderDate.secsTo(currentDate) / Params().GetConsensus().nPowTargetSpacing;\n     bool hasBestHeader = bestHeaderHeight >= count;\n "
      },
      {
        "sha": "ec0580b81c24404cd4b664bde411573404f04f11",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -672,7 +672,7 @@ void RPCConsole::setFontSize(int newSize)\n {\n     QSettings settings;\n \n-    //don't allow a insane font size\n+    //don't allow an insane font size\n     if (newSize < FONT_RANGE.width() || newSize > FONT_RANGE.height())\n         return;\n \n@@ -738,7 +738,7 @@ void RPCConsole::clear(bool clearHistory)\n                         tr(\"Use up and down arrows to navigate history, and %1 to clear screen.\").arg(\"<b>\"+clsKey+\"</b>\") + \"<br>\" +\n                         tr(\"Type <b>help</b> for an overview of available commands.\")) +\n                         \"<br><span class=\\\"secwarning\\\">\" +\n-                        tr(\"WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramification of a command.\") +\n+                        tr(\"WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramifications of a command.\") +\n                         \"</span>\",\n                         true);\n }"
      },
      {
        "sha": "1b7cc69231c14a648ddb045b84208aa297e4a9af",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -131,13 +131,24 @@ SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle)\n     move(QApplication::desktop()->screenGeometry().center() - r.center());\n \n     subscribeToCoreSignals();\n+    installEventFilter(this);\n }\n \n SplashScreen::~SplashScreen()\n {\n     unsubscribeFromCoreSignals();\n }\n \n+bool SplashScreen::eventFilter(QObject * obj, QEvent * ev) {\n+    if (ev->type() == QEvent::KeyPress) {\n+        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(ev);\n+        if(keyEvent->text()[0] == 'q' && breakAction != nullptr) {\n+            breakAction();\n+        }\n+    }\n+    return QObject::eventFilter(obj, ev);\n+}\n+\n void SplashScreen::slotFinish(QWidget *mainWin)\n {\n     Q_UNUSED(mainWin);\n@@ -164,6 +175,18 @@ static void ShowProgress(SplashScreen *splash, const std::string &title, int nPr\n     InitMessage(splash, title + strprintf(\"%d\", nProgress) + \"%\");\n }\n \n+void SplashScreen::setBreakAction(const std::function<void(void)> &action)\n+{\n+    breakAction = action;\n+}\n+\n+static void SetProgressBreakAction(SplashScreen *splash, const std::function<void(void)> &action)\n+{\n+    QMetaObject::invokeMethod(splash, \"setBreakAction\",\n+        Qt::QueuedConnection,\n+        Q_ARG(std::function<void(void)>, action));\n+}\n+\n #ifdef ENABLE_WALLET\n void SplashScreen::ConnectWallet(CWallet* wallet)\n {\n@@ -177,6 +200,7 @@ void SplashScreen::subscribeToCoreSignals()\n     // Connect signals to client\n     uiInterface.InitMessage.connect(boost::bind(InitMessage, this, _1));\n     uiInterface.ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n+    uiInterface.SetProgressBreakAction.connect(boost::bind(SetProgressBreakAction, this, _1));\n #ifdef ENABLE_WALLET\n     uiInterface.LoadWallet.connect(boost::bind(&SplashScreen::ConnectWallet, this, _1));\n #endif"
      },
      {
        "sha": "a88ebb98a87400c8d3f06c74b169158564859e95",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_QT_SPLASHSCREEN_H\n #define BITCOIN_QT_SPLASHSCREEN_H\n \n+#include <functional>\n #include <QSplashScreen>\n \n class CWallet;\n@@ -35,6 +36,11 @@ public Q_SLOTS:\n     /** Show message and progress */\n     void showMessage(const QString &message, int alignment, const QColor &color);\n \n+    /** Sets the break action */\n+    void setBreakAction(const std::function<void(void)> &action);\n+protected:\n+    bool eventFilter(QObject * obj, QEvent * ev);\n+\n private:\n     /** Connect core signals to splash screen */\n     void subscribeToCoreSignals();\n@@ -49,6 +55,8 @@ public Q_SLOTS:\n     int curAlignment;\n \n     QList<CWallet*> connectedWallets;\n+\n+    std::function<void(void)> breakAction;\n };\n \n #endif // BITCOIN_QT_SPLASHSCREEN_H"
      },
      {
        "sha": "26dec3c61087acca5b9a261d48c2338bcb209a26",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -33,8 +33,6 @@ static const CRPCCommand vRPCCommands[] =\n \n void RPCNestedTests::rpcNestedTests()\n {\n-    UniValue jsonRPCError;\n-\n     // do some test setup\n     // could be moved to a more generic place when we add more tests on QT level\n     const CChainParams& chainparams = Params();"
      },
      {
        "sha": "43d6e8826ba6fe1699c3899995ead50c48ec0982",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -336,6 +336,10 @@ void TransactionView::changedAmount(const QString &amount)\n \n void TransactionView::exportClicked()\n {\n+    if (!model || !model->getOptionsModel()) {\n+        return;\n+    }\n+\n     // CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Transaction History\"), QString(),"
      },
      {
        "sha": "6538a80233c9acc342dcbf13915075631be091d8",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -339,7 +339,7 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n         transaction_array.append(&(ssTx[0]), ssTx.size());\n     }\n \n-    // Add addresses / update labels that we've sent to to the address book,\n+    // Add addresses / update labels that we've sent to the address book,\n     // and emit coinsSent signal for each recipient\n     for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n     {"
      },
      {
        "sha": "67efc7d945a5a6a093c86c61b39dc8742684e9e0",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -72,10 +72,16 @@ static bool rdrand_supported = false;\n static constexpr uint32_t CPUID_F1_ECX_RDRAND = 0x40000000;\n static void RDRandInit()\n {\n-    //! When calling cpuid function #1, ecx register will have this set if RDRAND is available.\n+    uint32_t eax, ecx, edx;\n+#if defined(__i386__) && ( defined(__PIC__) || defined(__PIE__))\n     // Avoid clobbering ebx, as that is used for PIC on x86.\n-    uint32_t eax, tmp, ecx, edx;\n+    uint32_t tmp;\n     __asm__ (\"mov %%ebx, %1; cpuid; mov %1, %%ebx\": \"=a\"(eax), \"=g\"(tmp), \"=c\"(ecx), \"=d\"(edx) : \"a\"(1));\n+#else\n+    uint32_t ebx;\n+    __asm__ (\"cpuid\": \"=a\"(eax), \"=b\"(ebx), \"=c\"(ecx), \"=d\"(edx) : \"a\"(1));\n+#endif\n+    //! When calling cpuid function #1, ecx register will have this set if RDRAND is available.\n     if (ecx & CPUID_F1_ECX_RDRAND) {\n         LogPrintf(\"Using RdRand as entropy source\\n\");\n         rdrand_supported = true;"
      },
      {
        "sha": "33e3fb4529833d3eb14e89e486e9019206c4c420",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -413,7 +413,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         boost::split(uriParts, strUriParams, boost::is_any_of(\"/\"));\n     }\n \n-    // throw exception in case of a empty request\n+    // throw exception in case of an empty request\n     std::string strRequestMutable = req->ReadBody();\n     if (strRequestMutable.length() == 0 && uriParts.size() == 0)\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");"
      },
      {
        "sha": "c17ca2fa3a1760f57fb9e108d44205734f11860d",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -991,7 +991,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n+        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {\n             return NullUniValue;\n         }\n     } else {"
      },
      {
        "sha": "cb1539dce5bc1a1ab46fef03c51bdaf3885a701b",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -76,6 +76,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"listunspent\", 0, \"minconf\" },\n     { \"listunspent\", 1, \"maxconf\" },\n     { \"listunspent\", 2, \"addresses\" },\n+    { \"listunspent\", 3, \"include_unsafe\" },\n     { \"listunspent\", 4, \"query_options\" },\n     { \"getblock\", 1, \"verbosity\" },\n     { \"getblockheader\", 1, \"verbose\" },"
      },
      {
        "sha": "e50742f36e37a57c2103b02427ecc6185d472525",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 44,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -18,6 +18,7 @@\n #include \"policy/fees.h\"\n #include \"pow.h\"\n #include \"rpc/blockchain.h\"\n+#include \"rpc/mining.h\"\n #include \"rpc/server.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n@@ -141,42 +142,6 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n     return blockHashes;\n }\n \n-UniValue generate(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw std::runtime_error(\n-            \"generate nblocks ( maxtries )\\n\"\n-            \"\\nMine up to nblocks blocks immediately (before the RPC call returns)\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n-            \"2. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n-            \"\\nResult:\\n\"\n-            \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nGenerate 11 blocks\\n\"\n-            + HelpExampleCli(\"generate\", \"11\")\n-        );\n-\n-    int nGenerate = request.params[0].get_int();\n-    uint64_t nMaxTries = 1000000;\n-    if (request.params.size() > 1) {\n-        nMaxTries = request.params[1].get_int();\n-    }\n-\n-    std::shared_ptr<CReserveScript> coinbaseScript;\n-    GetMainSignals().ScriptForMining(coinbaseScript);\n-\n-    // If the keypool is exhausted, no script is returned at all.  Catch this.\n-    if (!coinbaseScript)\n-        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n-\n-    //throw an error if no script was provided\n-    if (coinbaseScript->reserveScript.empty())\n-        throw JSONRPCError(RPC_INTERNAL_ERROR, \"No coinbase script available (mining requires a wallet)\");\n-\n-    return generateBlocks(coinbaseScript, nGenerate, nMaxTries, true);\n-}\n-\n UniValue generatetoaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n@@ -722,19 +687,16 @@ class submitblock_StateCatcher : public CValidationInterface\n \n UniValue submitblock(const JSONRPCRequest& request)\n {\n+    // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n         throw std::runtime_error(\n-            \"submitblock \\\"hexdata\\\" ( \\\"jsonparametersobject\\\" )\\n\"\n+            \"submitblock \\\"hexdata\\\"  ( \\\"dummy\\\" )\\n\"\n             \"\\nAttempts to submit new block to network.\\n\"\n-            \"The 'jsonparametersobject' parameter is currently ignored.\\n\"\n             \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\"\n \n             \"\\nArguments\\n\"\n             \"1. \\\"hexdata\\\"        (string, required) the hex-encoded block data to submit\\n\"\n-            \"2. \\\"parameters\\\"     (string, optional) object of optional parameters\\n\"\n-            \"    {\\n\"\n-            \"      \\\"workid\\\" : \\\"id\\\"    (string, optional) if the server provided a workid, it MUST be included with submissions\\n\"\n-            \"    }\\n\"\n+            \"2. \\\"dummy\\\"          (optional) dummy value, for compatibility with BIP22. This value is ignored.\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n@@ -963,9 +925,8 @@ static const CRPCCommand commands[] =\n     { \"mining\",             \"getmininginfo\",          &getmininginfo,          true,  {} },\n     { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  true,  {\"txid\",\"dummy\",\"fee_delta\"} },\n     { \"mining\",             \"getblocktemplate\",       &getblocktemplate,       true,  {\"template_request\"} },\n-    { \"mining\",             \"submitblock\",            &submitblock,            true,  {\"hexdata\",\"parameters\"} },\n+    { \"mining\",             \"submitblock\",            &submitblock,            true,  {\"hexdata\",\"dummy\"} },\n \n-    { \"generating\",         \"generate\",               &generate,               true,  {\"nblocks\",\"maxtries\"} },\n     { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      true,  {\"nblocks\",\"address\",\"maxtries\"} },\n \n     { \"util\",               \"estimatefee\",            &estimatefee,            true,  {\"nblocks\"} },"
      },
      {
        "sha": "a148d851da0000805729a0eacdc4e33c1de4fe62",
        "filename": "src/rpc/mining.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/mining.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/mining.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_MINING_H\n+#define BITCOIN_RPC_MINING_H\n+\n+#include \"script/script.h\"\n+\n+#include <univalue.h>\n+\n+/** Generate blocks (mine) */\n+UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript);\n+\n+#endif"
      },
      {
        "sha": "5cab0ad5bd8dabcfa41c5ee8197f50602adbc498",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -75,7 +75,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"id\\\": n,                   (numeric) Peer index\\n\"\n-            \"    \\\"addr\\\":\\\"host:port\\\",      (string) The ip address and port of the peer\\n\"\n+            \"    \\\"addr\\\":\\\"host:port\\\",      (string) The IP address and port of the peer\\n\"\n             \"    \\\"addrbind\\\":\\\"ip:port\\\",    (string) Bind address of the connection to the peer\\n\"\n             \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) Local address as reported by the peer\\n\"\n             \"    \\\"services\\\":\\\"xxxxxxxxxxxxxxxx\\\",   (string) The services offered\\n\"\n@@ -199,7 +199,7 @@ UniValue addnode(const JSONRPCRequest& request)\n         (strCommand != \"onetry\" && strCommand != \"add\" && strCommand != \"remove\"))\n         throw std::runtime_error(\n             \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n-            \"\\nAttempts add or remove a node from the addnode list.\\n\"\n+            \"\\nAttempts to add or remove a node from the addnode list.\\n\"\n             \"Or try a connection to a node once.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n@@ -290,7 +290,7 @@ UniValue getaddednodeinfo(const JSONRPCRequest& request)\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n-            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node ip address or name (as provided to addnode)\\n\"\n+            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node IP address or name (as provided to addnode)\\n\"\n             \"    \\\"connected\\\" : true|false,          (boolean) If connected\\n\"\n             \"    \\\"addresses\\\" : [                    (list of objects) Only when connected = true\\n\"\n             \"       {\\n\"\n@@ -397,7 +397,7 @@ static UniValue GetNetworksInfo()\n     for(int n=0; n<NET_MAX; ++n)\n     {\n         enum Network network = static_cast<enum Network>(n);\n-        if(network == NET_UNROUTABLE)\n+        if(network == NET_UNROUTABLE || network == NET_INTERNAL)\n             continue;\n         proxyType proxy;\n         UniValue obj(UniValue::VOBJ);\n@@ -497,12 +497,12 @@ UniValue setban(const JSONRPCRequest& request)\n         (strCommand != \"add\" && strCommand != \"remove\"))\n         throw std::runtime_error(\n                             \"setban \\\"subnet\\\" \\\"add|remove\\\" (bantime) (absolute)\\n\"\n-                            \"\\nAttempts add or remove a IP/Subnet from the banned list.\\n\"\n+                            \"\\nAttempts to add or remove an IP/Subnet from the banned list.\\n\"\n                             \"\\nArguments:\\n\"\n-                            \"1. \\\"subnet\\\"       (string, required) The IP/Subnet (see getpeerinfo for nodes ip) with a optional netmask (default is /32 = single ip)\\n\"\n-                            \"2. \\\"command\\\"      (string, required) 'add' to add a IP/Subnet to the list, 'remove' to remove a IP/Subnet from the list\\n\"\n-                            \"3. \\\"bantime\\\"      (numeric, optional) time in seconds how long (or until when if [absolute] is set) the ip is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\\n\"\n-                            \"4. \\\"absolute\\\"     (boolean, optional) If set, the bantime must be a absolute timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n+                            \"1. \\\"subnet\\\"       (string, required) The IP/Subnet (see getpeerinfo for nodes IP) with an optional netmask (default is /32 = single IP)\\n\"\n+                            \"2. \\\"command\\\"      (string, required) 'add' to add an IP/Subnet to the list, 'remove' to remove an IP/Subnet from the list\\n\"\n+                            \"3. \\\"bantime\\\"      (numeric, optional) time in seconds how long (or until when if [absolute] is set) the IP is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\\n\"\n+                            \"4. \\\"absolute\\\"     (boolean, optional) If set, the bantime must be an absolute timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n                             \"\\nExamples:\\n\"\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.6\\\" \\\"add\\\" 86400\")\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.0/24\\\" \\\"add\\\"\")"
      },
      {
        "sha": "c320d20453f24adcf4790789cca3af84a2208d6b",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -258,6 +258,22 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n     return \"Bitcoin server stopping\";\n }\n \n+UniValue uptime(const JSONRPCRequest& jsonRequest)\n+{\n+    if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n+        throw std::runtime_error(\n+                \"uptime\\n\"\n+                        \"\\nReturns the total uptime of the server.\\n\"\n+                        \"\\nResult:\\n\"\n+                        \"ttt        (numeric) The number of seconds that the server has been running\\n\"\n+                        \"\\nExamples:\\n\"\n+                + HelpExampleCli(\"uptime\", \"\")\n+                + HelpExampleRpc(\"uptime\", \"\")\n+        );\n+\n+    return GetTime() - GetStartupTime();\n+}\n+\n /**\n  * Call Table\n  */\n@@ -267,6 +283,7 @@ static const CRPCCommand vRPCCommands[] =\n     /* Overall control/query calls */\n     { \"control\",            \"help\",                   &help,                   true,  {\"command\"}  },\n     { \"control\",            \"stop\",                   &stop,                   true,  {}  },\n+    { \"control\",            \"uptime\",                 &uptime,                 true,  {}  },\n };\n \n CRPCTable::CRPCTable()"
      },
      {
        "sha": "4b71a42cdff54f87d267dda9655cce335c3eb4f1",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -68,7 +68,7 @@ struct ECCryptoClosure\n };\n \n ECCryptoClosure instance_of_eccryptoclosure;\n-}\n+} // namespace\n \n /** Check that all specified flags are part of the libconsensus interface. */\n static bool verify_flags(unsigned int flags)"
      },
      {
        "sha": "7149c938fc8242c8e90c36f279782b5493b467da",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -31,7 +31,7 @@ inline bool set_error(ScriptError* ret, const ScriptError serror)\n     return false;\n }\n \n-} // anon namespace\n+} // namespace\n \n bool CastToBool(const valtype& vch)\n {\n@@ -1164,7 +1164,7 @@ uint256 GetOutputsHash(const CTransaction& txTo) {\n     return ss.GetHash();\n }\n \n-} // anon namespace\n+} // namespace\n \n PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo)\n {"
      },
      {
        "sha": "ab1dc4e681b4c628898ff3a6885b9154b9e62df7",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -160,9 +160,9 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n public:\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(NULL) {}\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const;\n-    bool CheckLockTime(const CScriptNum& nLockTime) const;\n-    bool CheckSequence(const CScriptNum& nSequence) const;\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckLockTime(const CScriptNum& nLockTime) const override;\n+    bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n class MutableTransactionSignatureChecker : public TransactionSignatureChecker"
      },
      {
        "sha": "ceb573b2ec565340fa6c1fdabc7aa35b2b136868",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -66,18 +66,18 @@ class CSignatureCache\n  * signatureCache could be made local to VerifySignature.\n */\n static CSignatureCache signatureCache;\n-}\n+} // namespace\n \n // To be called once in AppInitMain/BasicTestingSetup to initialize the\n // signatureCache.\n void InitSignatureCache()\n {\n     // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n     // setup_bytes creates the minimum possible cache (2 elements).\n-    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE)), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n     size_t nElems = signatureCache.setup_bytes(nMaxCacheSize);\n-    LogPrintf(\"Using %zu MiB out of %zu requested for signature cache, able to store %zu elements\\n\",\n-            (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);\n+    LogPrintf(\"Using %zu MiB out of %zu/2 requested for signature cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const"
      },
      {
        "sha": "5832b264b36fdb344f3dd63d7645f21c6e0e4841",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -48,7 +48,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n public:\n     CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}\n \n-    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n };\n \n void InitSignatureCache();"
      },
      {
        "sha": "ec93c5451b0cc3be2430a9c2795983f5ddb255bc",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -393,13 +393,13 @@ class DummySignatureChecker : public BaseSignatureChecker\n public:\n     DummySignatureChecker() {}\n \n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n     {\n         return true;\n     }\n };\n const DummySignatureChecker dummyChecker;\n-}\n+} // namespace\n \n const BaseSignatureChecker& DummySignatureCreator::Checker() const\n {"
      },
      {
        "sha": "bd458628922253fe2e85a87019102b678819b628",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -40,8 +40,8 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n \n public:\n     TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n-    const BaseSignatureChecker& Checker() const { return checker; }\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const;\n+    const BaseSignatureChecker& Checker() const override { return checker; }\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n \n class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n@@ -55,8 +55,8 @@ class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n class DummySignatureCreator : public BaseSignatureCreator {\n public:\n     DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n-    const BaseSignatureChecker& Checker() const;\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const;\n+    const BaseSignatureChecker& Checker() const override;\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n \n struct SignatureData {"
      },
      {
        "sha": "8e08acf0c61b70dd07edd29b361fd102b7c94d05",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -273,7 +273,7 @@ class CScriptVisitor : public boost::static_visitor<bool>\n         return true;\n     }\n };\n-}\n+} // namespace\n \n CScript GetScriptForDestination(const CTxDestination& dest)\n {"
      },
      {
        "sha": "5198724bea15360d7c680e76ba8d0b2d3ef75641",
        "filename": "src/secp256k1/sage/group_prover.sage",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/secp256k1/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/secp256k1/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/group_prover.sage?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -3,7 +3,7 @@\n # to independently set assumptions on input or intermediary variables.\n #\n # The general approach is:\n-# * A constraint is a tuple of two sets of of symbolic expressions:\n+# * A constraint is a tuple of two sets of symbolic expressions:\n #   the first of which are required to evaluate to zero, the second of which\n #   are required to evaluate to nonzero.\n #   - A constraint is said to be conflicting if any of its nonzero expressions"
      },
      {
        "sha": "bd2b629e1c2e9b9699533bc598fa7759918e0645",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -11,7 +11,7 @@ Note:\n \n - To avoid unnecessary loads and make use of available registers, two\n   'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n-  which will be added to c and d respectively in the the even passes\n+  which will be added to c and d respectively in the even passes\n \n */\n "
      },
      {
        "sha": "90690876eee05893d7b13fa8cd795401b565832e",
        "filename": "src/support/events.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/support/events.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/support/events.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/events.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -27,26 +27,26 @@ MAKE_RAII(evhttp);\n MAKE_RAII(evhttp_request);\n MAKE_RAII(evhttp_connection);\n \n-raii_event_base obtain_event_base() {\n+inline raii_event_base obtain_event_base() {\n     auto result = raii_event_base(event_base_new());\n     if (!result.get())\n         throw std::runtime_error(\"cannot create event_base\");\n     return result;\n }\n \n-raii_event obtain_event(struct event_base* base, evutil_socket_t s, short events, event_callback_fn cb, void* arg) {\n+inline raii_event obtain_event(struct event_base* base, evutil_socket_t s, short events, event_callback_fn cb, void* arg) {\n     return raii_event(event_new(base, s, events, cb, arg));\n }\n \n-raii_evhttp obtain_evhttp(struct event_base* base) {\n+inline raii_evhttp obtain_evhttp(struct event_base* base) {\n     return raii_evhttp(evhttp_new(base));\n }\n \n-raii_evhttp_request obtain_evhttp_request(void(*cb)(struct evhttp_request *, void *), void *arg) {\n+inline raii_evhttp_request obtain_evhttp_request(void(*cb)(struct evhttp_request *, void *), void *arg) {\n     return raii_evhttp_request(evhttp_request_new(cb, arg));\n }\n \n-raii_evhttp_connection obtain_evhttp_connection_base(struct event_base* base, std::string host, uint16_t port) {\n+inline raii_evhttp_connection obtain_evhttp_connection_base(struct event_base* base, std::string host, uint16_t port) {\n     auto result = raii_evhttp_connection(evhttp_connection_base_new(base, NULL, host.c_str(), port));\n     if (!result.get())\n         throw std::runtime_error(\"create connection failed\");"
      },
      {
        "sha": "2df6b84a5997bfd1dbdaca1555e07899944f14a8",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -148,9 +148,9 @@ class Win32LockedPageAllocator: public LockedPageAllocator\n {\n public:\n     Win32LockedPageAllocator();\n-    void* AllocateLocked(size_t len, bool *lockingSuccess);\n-    void FreeLocked(void* addr, size_t len);\n-    size_t GetLimit();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess) override;\n+    void FreeLocked(void* addr, size_t len) override;\n+    size_t GetLimit() override;\n private:\n     size_t page_size;\n };\n@@ -200,9 +200,9 @@ class PosixLockedPageAllocator: public LockedPageAllocator\n {\n public:\n     PosixLockedPageAllocator();\n-    void* AllocateLocked(size_t len, bool *lockingSuccess);\n-    void FreeLocked(void* addr, size_t len);\n-    size_t GetLimit();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess) override;\n+    void FreeLocked(void* addr, size_t len) override;\n+    size_t GetLimit() override;\n private:\n     size_t page_size;\n };"
      },
      {
        "sha": "bc6aef2c1152fbb470ff8512f1f5130a2fa29144",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -27,7 +27,7 @@ class CAddrManTest : public CAddrMan\n         insecure_rand = FastRandomContext(true);\n     }\n \n-    int RandomInt(int nMax)\n+    int RandomInt(int nMax) override\n     {\n         state = (CHashWriter(SER_GETHASH, 0) << state).GetHash().GetCheapHash();\n         return (unsigned int)(state % nMax);"
      },
      {
        "sha": "4a533b5bf2fb5cbb376ef6b0db8b648649c4aa9a",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -131,7 +131,7 @@ class TestLockedPageAllocator: public LockedPageAllocator\n {\n public:\n     TestLockedPageAllocator(int count_in, int lockedcount_in): count(count_in), lockedcount(lockedcount_in) {}\n-    void* AllocateLocked(size_t len, bool *lockingSuccess)\n+    void* AllocateLocked(size_t len, bool *lockingSuccess) override\n     {\n         *lockingSuccess = false;\n         if (count > 0) {\n@@ -146,10 +146,10 @@ class TestLockedPageAllocator: public LockedPageAllocator\n         }\n         return 0;\n     }\n-    void FreeLocked(void* addr, size_t len)\n+    void FreeLocked(void* addr, size_t len) override\n     {\n     }\n-    size_t GetLimit()\n+    size_t GetLimit() override\n     {\n         return std::numeric_limits<size_t>::max();\n     }"
      },
      {
        "sha": "2c98fbcfd67efa8da6fec19070934611c1770369",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -219,7 +219,7 @@ BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n \n \n // Check if doing _A_ _OP_ _B_ results in the same as applying _OP_ onto each\n-// element of Aarray and Barray, and then converting the result into a arith_uint256.\n+// element of Aarray and Barray, and then converting the result into an arith_uint256.\n #define CHECKBITWISEOPERATOR(_A_,_B_,_OP_)                              \\\n     for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i]; } \\\n     BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (_A_##L _OP_ _B_##L));"
      },
      {
        "sha": "e24431528a2a1e86f09b24333f83d32c8c454532",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 8,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -50,12 +50,6 @@ class CCoinsViewTest : public CCoinsView\n         return true;\n     }\n \n-    bool HaveCoin(const COutPoint& outpoint) const override\n-    {\n-        Coin coin;\n-        return GetCoin(outpoint, coin);\n-    }\n-\n     uint256 GetBestBlock() const override { return hashBestBlock_; }\n \n     bool BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock) override\n@@ -99,7 +93,7 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n     size_t& usage() { return cachedCoinsUsage; }\n };\n \n-}\n+} // namespace\n \n BOOST_FIXTURE_TEST_SUITE(coins_tests, BasicTestingSetup)\n \n@@ -147,8 +141,22 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n         {\n             uint256 txid = txids[InsecureRandRange(txids.size())]; // txid we're going to modify in this iteration.\n             Coin& coin = result[COutPoint(txid, 0)];\n+\n+            // Determine whether to test HaveCoin before or after Access* (or both). As these functions\n+            // can influence each other's behaviour by pulling things into the cache, all combinations\n+            // are tested.\n+            bool test_havecoin_before = InsecureRandBits(2) == 0;\n+            bool test_havecoin_after = InsecureRandBits(2) == 0;\n+\n+            bool result_havecoin = test_havecoin_before ? stack.back()->HaveCoin(COutPoint(txid, 0)) : false;\n             const Coin& entry = (InsecureRandRange(500) == 0) ? AccessByTxid(*stack.back(), txid) : stack.back()->AccessCoin(COutPoint(txid, 0));\n             BOOST_CHECK(coin == entry);\n+            BOOST_CHECK(!test_havecoin_before || result_havecoin == !entry.IsSpent());\n+\n+            if (test_havecoin_after) {\n+                bool ret = stack.back()->HaveCoin(COutPoint(txid, 0));\n+                BOOST_CHECK(ret == !entry.IsSpent());\n+            }\n \n             if (InsecureRandRange(5) == 0 || coin.IsSpent()) {\n                 Coin newcoin;\n@@ -628,7 +636,7 @@ BOOST_AUTO_TEST_CASE(ccoins_access)\n     CheckAccessCoin(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n     CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n     CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoin(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n+    CheckAccessCoin(PRUNED, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n     CheckAccessCoin(PRUNED, PRUNED, PRUNED, 0          , 0          );\n     CheckAccessCoin(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n     CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );"
      },
      {
        "sha": "0390d6806d2bb687190bb08e0afe9352a045c397",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -2506,7 +2506,7 @@\n ],\n \n [\"CHECKSEQUENCEVERIFY tests\"],\n-[\"\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on a empty stack\"],\n+[\"\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on an empty stack\"],\n [\"-1\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"NEGATIVE_LOCKTIME\", \"CSV automatically fails if stack top is negative\"],\n [\"0x0100\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY,MINIMALDATA\", \"UNKNOWN_ERROR\", \"CSV fails if stack top is not minimally encoded\"],\n [\"0\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"UNSATISFIED_LOCKTIME\", \"CSV fails if stack top bit 1 << 31 is set and the tx version < 2\"],"
      },
      {
        "sha": "e6b382af13e70b8466eb935d5aaac65eab1f9b05",
        "filename": "src/test/data/tx_valid.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/data/tx_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/data/tx_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_valid.json?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -174,7 +174,7 @@\n [[[\"5a6b0021a6042a686b6b94abc36b387bef9109847774e8b1e51eb8cc55c53921\", 1, \"DUP HASH160 0x14 0xee5a6aa40facefb2655ac23c0c28c57c65c41f9b EQUALVERIFY CHECKSIG\"]],\n \"01000000012139c555ccb81ee5b1e87477840991ef7b386bc3ab946b6b682a04a621006b5a01000000fdb40148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a5800390148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a5800390121038479a0fa998cd35259a2ef0a7a5c68662c1474f88ccb6d08a7677bbec7f2204148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a5800390175ac4830450220646b72c35beeec51f4d5bc1cbae01863825750d7f490864af354e6ea4f625e9c022100f04b98432df3a9641719dbced53393022e7249fb59db993af1118539830aab870148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a580039017521038479a0fa998cd35259a2ef0a7a5c68662c1474f88ccb6d08a7677bbec7f22041ffffffff010000000000000000016a00000000\", \"P2SH\"],\n \n-[\"Finally CHECKMULTISIG removes all signatures prior to hashing the script containing those signatures. In conjunction with the SIGHASH_SINGLE bug this lets us test whether or not FindAndDelete() is actually present in scriptPubKey/redeemScript evaluation by including a signature of the digest 0x01 We can compute in advance for our pubkey, embed it it in the scriptPubKey, and then also using a normal SIGHASH_ALL signature. If FindAndDelete() wasn't run, the 'bugged' signature would still be in the hashed script, and the normal signature would fail.\"],\n+[\"Finally CHECKMULTISIG removes all signatures prior to hashing the script containing those signatures. In conjunction with the SIGHASH_SINGLE bug this lets us test whether or not FindAndDelete() is actually present in scriptPubKey/redeemScript evaluation by including a signature of the digest 0x01 We can compute in advance for our pubkey, embed it in the scriptPubKey, and then also using a normal SIGHASH_ALL signature. If FindAndDelete() wasn't run, the 'bugged' signature would still be in the hashed script, and the normal signature would fail.\"],\n \n [\"Here's an example on mainnet within a P2SH redeemScript. Remarkably it's a standard transaction in <0.9\"],\n [[[\"b5b598de91787439afd5938116654e0b16b7a0d0f82742ba37564219c5afcbf9\", 0, \"DUP HASH160 0x14 0xf6f365c40f0739b61de827a44751e5e99032ed8f EQUALVERIFY CHECKSIG\"],"
      },
      {
        "sha": "095d86834c0b3711512a8708b78d62275a78f4fe",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -29,7 +29,7 @@ class CAddrManSerializationMock : public CAddrMan\n class CAddrManUncorrupted : public CAddrManSerializationMock\n {\n public:\n-    void Serialize(CDataStream& s) const\n+    void Serialize(CDataStream& s) const override\n     {\n         CAddrMan::Serialize(s);\n     }\n@@ -38,7 +38,7 @@ class CAddrManUncorrupted : public CAddrManSerializationMock\n class CAddrManCorrupted : public CAddrManSerializationMock\n {\n public:\n-    void Serialize(CDataStream& s) const\n+    void Serialize(CDataStream& s) const override\n     {\n         // Produces corrupt output that claims addrman has 20 addrs when it only has one addr.\n         unsigned char nVersion = 1;"
      },
      {
        "sha": "b45a7fcc572fbeb77800084201523cb90e3a6e61",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -25,13 +25,21 @@ static CSubNet ResolveSubNet(const char* subnet)\n     return ret;\n }\n \n+static CNetAddr CreateInternal(const char* host)\n+{\n+    CNetAddr addr;\n+    addr.SetInternal(host);\n+    return addr;\n+}\n+\n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n     BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n     BOOST_CHECK(ResolveIP(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n     BOOST_CHECK(ResolveIP(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n     BOOST_CHECK(ResolveIP(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n     BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+    BOOST_CHECK(CreateInternal(\"foo.com\").GetNetwork()                           == NET_INTERNAL);\n \n }\n \n@@ -58,6 +66,8 @@ BOOST_AUTO_TEST_CASE(netbase_properties)\n     BOOST_CHECK(ResolveIP(\"8.8.8.8\").IsRoutable());\n     BOOST_CHECK(ResolveIP(\"2001::1\").IsRoutable());\n     BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsValid());\n+    BOOST_CHECK(CreateInternal(\"FD6B:88C0:8724:edb1:8e4:3588:e546:35ca\").IsInternal());\n+    BOOST_CHECK(CreateInternal(\"bar.com\").IsInternal());\n \n }\n \n@@ -103,6 +113,11 @@ BOOST_AUTO_TEST_CASE(netbase_lookupnumeric)\n     BOOST_CHECK(TestParse(\"[::]:8333\", \"[::]:8333\"));\n     BOOST_CHECK(TestParse(\"[127.0.0.1]\", \"127.0.0.1:65535\"));\n     BOOST_CHECK(TestParse(\":::\", \"[::]:0\"));\n+\n+    // verify that an internal address fails to resolve\n+    BOOST_CHECK(TestParse(\"[fd6b:88c0:8724:1:2:3:4:5]\", \"[::]:0\"));\n+    // and that a one-off resolves correctly\n+    BOOST_CHECK(TestParse(\"[fd6c:88c0:8724:1:2:3:4:5]\", \"[fd6c:88c0:8724:1:2:3:4:5]:65535\"));\n }\n \n BOOST_AUTO_TEST_CASE(onioncat_test)\n@@ -281,6 +296,9 @@ BOOST_AUTO_TEST_CASE(netbase_getgroup)\n     BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n     BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n \n+    // baz.net sha256 hash: 12929400eb4607c4ac075f087167e75286b179c693eb059a01774b864e8fe505\n+    std::vector<unsigned char> internal_group = {NET_INTERNAL, 0x12, 0x92, 0x94, 0x00, 0xeb, 0x46, 0x07, 0xc4, 0xac, 0x07};\n+    BOOST_CHECK(CreateInternal(\"baz.net\").GetGroup() == internal_group);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1bb191c73d00064fa4998943c52b74e6e0da5797",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -468,7 +468,7 @@ std::string JSONPrettyPrint(const UniValue& univalue)\n     }\n     return ret;\n }\n-}\n+} // namespace\n \n BOOST_AUTO_TEST_CASE(script_build)\n {"
      },
      {
        "sha": "579e96524cc59a5b213abb799f35c2d2fe2127b2",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -38,6 +38,7 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n         SetupEnvironment();\n         SetupNetworking();\n         InitSignatureCache();\n+        InitScriptExecutionCache();\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n         fCheckBlockIndex = true;\n         SelectParams(chainName);"
      },
      {
        "sha": "a74f40251aa3ee1427742e657ce2c3dd98232813",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 284,
        "deletions": 0,
        "changes": 284,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -10,11 +10,17 @@\n #include \"txmempool.h\"\n #include \"random.h\"\n #include \"script/standard.h\"\n+#include \"script/sign.h\"\n #include \"test/test_bitcoin.h\"\n #include \"utiltime.h\"\n+#include \"core_io.h\"\n+#include \"keystore.h\"\n+#include \"policy/policy.h\"\n \n #include <boost/test/unit_test.hpp>\n \n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+\n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n static bool\n@@ -84,4 +90,282 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK_EQUAL(mempool.size(), 0);\n }\n \n+// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n+// flags.  Test that CheckInputs passes for all flags that don't overlap with\n+// the failing_flags argument, but otherwise fails.\n+// CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n+// get reassigned) have an interaction with DISCOURAGE_UPGRADABLE_NOPS: if\n+// the script flags used contain DISCOURAGE_UPGRADABLE_NOPS but don't contain\n+// CHECKLOCKTIMEVERIFY (or CHECKSEQUENCEVERIFY), but the script does contain\n+// OP_CHECKLOCKTIMEVERIFY (or OP_CHECKSEQUENCEVERIFY), then script execution\n+// should fail.\n+// Capture this interaction with the upgraded_nop argument: set it when evaluating\n+// any script flag that is implemented as an upgraded NOP code.\n+void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache, bool upgraded_nop)\n+{\n+    PrecomputedTransactionData txdata(tx);\n+    // If we add many more flags, this loop can get too expensive, but we can\n+    // rewrite in the future to randomly pick a set of flags to evaluate.\n+    for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\n+        CValidationState state;\n+        // Filter out incompatible flag choices\n+        if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\n+            // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in\n+            // script/interpreter.cpp\n+            test_flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\n+        }\n+        if ((test_flags & SCRIPT_VERIFY_WITNESS)) {\n+            // WITNESS requires P2SH\n+            test_flags |= SCRIPT_VERIFY_P2SH;\n+        }\n+        bool ret = CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, nullptr);\n+        // CheckInputs should succeed iff test_flags doesn't intersect with\n+        // failing_flags\n+        bool expected_return_value = !(test_flags & failing_flags);\n+        if (expected_return_value && upgraded_nop) {\n+            // If the script flag being tested corresponds to an upgraded NOP,\n+            // then script execution should fail if DISCOURAGE_UPGRADABLE_NOPS\n+            // is set.\n+            expected_return_value = !(test_flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS);\n+        }\n+        BOOST_CHECK_EQUAL(ret, expected_return_value);\n+\n+        // Test the caching\n+        if (ret && add_to_cache) {\n+            // Check that we get a cache hit if the tx was valid\n+            std::vector<CScriptCheck> scriptchecks;\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(scriptchecks.empty());\n+        } else {\n+            // Check that we get script executions to check, if the transaction\n+            // was invalid, or we didn't add to cache.\n+            std::vector<CScriptCheck> scriptchecks;\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n+{\n+    // Test that passing CheckInputs with one set of script flags doesn't imply\n+    // that we would pass again with a different set of flags.\n+    InitScriptExecutionCache();\n+\n+    CScript p2pk_scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    CScript p2sh_scriptPubKey = GetScriptForDestination(CScriptID(p2pk_scriptPubKey));\n+    CScript p2pkh_scriptPubKey = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\n+    CScript p2wpkh_scriptPubKey = GetScriptForWitness(p2pkh_scriptPubKey);\n+\n+    CBasicKeyStore keystore;\n+    keystore.AddKey(coinbaseKey);\n+    keystore.AddCScript(p2pk_scriptPubKey);\n+\n+    // flags to test: SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, SCRIPT_VERIFY_CHECKSEQUENCE_VERIFY, SCRIPT_VERIFY_NULLDUMMY, uncompressed pubkey thing\n+\n+    // Create 2 outputs that match the three scripts above, spending the first\n+    // coinbase tx.\n+    CMutableTransaction spend_tx;\n+\n+    spend_tx.nVersion = 1;\n+    spend_tx.vin.resize(1);\n+    spend_tx.vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n+    spend_tx.vin[0].prevout.n = 0;\n+    spend_tx.vout.resize(4);\n+    spend_tx.vout[0].nValue = 11*CENT;\n+    spend_tx.vout[0].scriptPubKey = p2sh_scriptPubKey;\n+    spend_tx.vout[1].nValue = 11*CENT;\n+    spend_tx.vout[1].scriptPubKey = p2wpkh_scriptPubKey;\n+    spend_tx.vout[2].nValue = 11*CENT;\n+    spend_tx.vout[2].scriptPubKey = CScript() << OP_CHECKLOCKTIMEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    spend_tx.vout[3].nValue = 11*CENT;\n+    spend_tx.vout[3].scriptPubKey = CScript() << OP_CHECKSEQUENCEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+\n+    // Sign, with a non-DER signature\n+    {\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        spend_tx.vin[0].scriptSig << vchSig;\n+    }\n+\n+    LOCK(cs_main);\n+\n+    // Test that invalidity under a set of flags doesn't preclude validity\n+    // under other (eg consensus) flags.\n+    // spend_tx is invalid according to DERSIG\n+    CValidationState state;\n+    {\n+        PrecomputedTransactionData ptd_spend_tx(spend_tx);\n+\n+        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+\n+        // If we call again asking for scriptchecks (as happens in\n+        // ConnectBlock), we should add a script check object for this -- we're\n+        // not caching invalidity (if that changes, delete this test case).\n+        std::vector<CScriptCheck> scriptchecks;\n+        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 1);\n+\n+        // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n+        // not present.  Don't add these checks to the cache, so that we can\n+        // test later that block validation works fine in the absence of cached\n+        // successes.\n+        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false, false);\n+\n+        // And if we produce a block with this tx, it should be valid (DERSIG not\n+        // enabled yet), even though there's no cache entry.\n+        CBlock block;\n+\n+        block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n+        BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+        BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n+    }\n+\n+    // Test P2SH: construct a transaction that is valid without P2SH, and\n+    // then test validity with P2SH.\n+    {\n+        CMutableTransaction invalid_under_p2sh_tx;\n+        invalid_under_p2sh_tx.nVersion = 1;\n+        invalid_under_p2sh_tx.vin.resize(1);\n+        invalid_under_p2sh_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_under_p2sh_tx.vin[0].prevout.n = 0;\n+        invalid_under_p2sh_tx.vout.resize(1);\n+        invalid_under_p2sh_tx.vout[0].nValue = 11*CENT;\n+        invalid_under_p2sh_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+        std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\n+        invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\n+\n+        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true, false);\n+    }\n+\n+    // Test CHECKLOCKTIMEVERIFY\n+    {\n+        CMutableTransaction invalid_with_cltv_tx;\n+        invalid_with_cltv_tx.nVersion = 1;\n+        invalid_with_cltv_tx.nLockTime = 100;\n+        invalid_with_cltv_tx.vin.resize(1);\n+        invalid_with_cltv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_with_cltv_tx.vin[0].prevout.n = 2;\n+        invalid_with_cltv_tx.vin[0].nSequence = 0;\n+        invalid_with_cltv_tx.vout.resize(1);\n+        invalid_with_cltv_tx.vout[0].nValue = 11*CENT;\n+        invalid_with_cltv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n+\n+        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true);\n+\n+        // Make it valid, and check again\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n+        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip, true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+    }\n+\n+    // TEST CHECKSEQUENCEVERIFY\n+    {\n+        CMutableTransaction invalid_with_csv_tx;\n+        invalid_with_csv_tx.nVersion = 2;\n+        invalid_with_csv_tx.vin.resize(1);\n+        invalid_with_csv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_with_csv_tx.vin[0].prevout.n = 3;\n+        invalid_with_csv_tx.vin[0].nSequence = 100;\n+        invalid_with_csv_tx.vout.resize(1);\n+        invalid_with_csv_tx.vout[0].nValue = 11*CENT;\n+        invalid_with_csv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n+\n+        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true);\n+\n+        // Make it valid, and check again\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(invalid_with_csv_tx);\n+        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip, true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+    }\n+\n+    // TODO: add tests for remaining script flags\n+\n+    // Test that passing CheckInputs with a valid witness doesn't imply success\n+    // for the same tx with a different witness.\n+    {\n+        CMutableTransaction valid_with_witness_tx;\n+        valid_with_witness_tx.nVersion = 1;\n+        valid_with_witness_tx.vin.resize(1);\n+        valid_with_witness_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        valid_with_witness_tx.vin[0].prevout.n = 1;\n+        valid_with_witness_tx.vout.resize(1);\n+        valid_with_witness_tx.vout[0].nValue = 11*CENT;\n+        valid_with_witness_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        SignatureData sigdata;\n+        ProduceSignature(MutableTransactionSignatureCreator(&keystore, &valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n+        UpdateTransaction(valid_with_witness_tx, 0, sigdata);\n+\n+        // This should be valid under all script flags.\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true, false);\n+\n+        // Remove the witness, and check that it is now invalid.\n+        valid_with_witness_tx.vin[0].scriptWitness.SetNull();\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true, false);\n+    }\n+\n+    {\n+        // Test a transaction with multiple inputs.\n+        CMutableTransaction tx;\n+\n+        tx.nVersion = 1;\n+        tx.vin.resize(2);\n+        tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        tx.vin[0].prevout.n = 0;\n+        tx.vin[1].prevout.hash = spend_tx.GetHash();\n+        tx.vin[1].prevout.n = 1;\n+        tx.vout.resize(1);\n+        tx.vout[0].nValue = 22*CENT;\n+        tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        for (int i=0; i<2; ++i) {\n+            SignatureData sigdata;\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n+            UpdateTransaction(tx, i, sigdata);\n+        }\n+\n+        // This should be valid under all script flags\n+        ValidateCheckInputsForAllFlags(tx, 0, true, false);\n+\n+        // Check that if the second input is invalid, but the first input is\n+        // valid, the transaction is not cached.\n+        // Invalidate vin[1]\n+        tx.vin[1].scriptWitness.SetNull();\n+\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(tx);\n+        // This transaction is now invalid under segwit, because of the second input.\n+        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+\n+        std::vector<CScriptCheck> scriptchecks;\n+        // Make sure this transaction was not cached (ie because the first\n+        // input was valid)\n+        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        // Should get 2 script checks back -- caching is on a whole-transaction basis.\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 2);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "722f6ae059ce4d8fc49fc8bc0e52a12a33b5c62a",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -22,11 +22,11 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     mutable ThresholdConditionCache cache;\n \n public:\n-    int64_t BeginTime(const Consensus::Params& params) const { return TestTime(10000); }\n-    int64_t EndTime(const Consensus::Params& params) const { return TestTime(20000); }\n-    int Period(const Consensus::Params& params) const { return 1000; }\n-    int Threshold(const Consensus::Params& params) const { return 900; }\n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const { return (pindex->nVersion & 0x100); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return TestTime(10000); }\n+    int64_t EndTime(const Consensus::Params& params) const override { return TestTime(20000); }\n+    int Period(const Consensus::Params& params) const override { return 1000; }\n+    int Threshold(const Consensus::Params& params) const override { return 900; }\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return (pindex->nVersion & 0x100); }\n \n     ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, paramsDummy, cache); }\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, paramsDummy, cache); }"
      },
      {
        "sha": "4cd64bf0281f15fc371dcf6ae9e1777527f135d4",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -376,8 +376,10 @@ static std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size\n     while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n         // Check for reading errors so we don't return any data if we couldn't\n         // read the entire file (or up to maxsize)\n-        if (ferror(f))\n+        if (ferror(f)) {\n+            fclose(f);\n             return std::make_pair(false,\"\");\n+        }\n         retval.append(buffer, buffer+n);\n         if (retval.size() > maxsize)\n             break;\n@@ -405,7 +407,7 @@ static bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n /****** Bitcoin specific TorController implementation ********/\n \n /** Controller that connects to Tor control socket, authenticate, then create\n- * and maintain a ephemeral hidden service.\n+ * and maintain an ephemeral hidden service.\n  */\n class TorController\n {"
      },
      {
        "sha": "002f6550bcac7deaeecbdf6e14059353841be0ee",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 7,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -7,8 +7,12 @@\n \n #include \"chainparams.h\"\n #include \"hash.h\"\n+#include \"random.h\"\n #include \"pow.h\"\n #include \"uint256.h\"\n+#include \"util.h\"\n+#include \"ui_interface.h\"\n+#include \"init.h\"\n \n #include <stdint.h>\n \n@@ -21,6 +25,7 @@ static const char DB_TXINDEX = 't';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n+static const char DB_HEAD_BLOCKS = 'H';\n static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n@@ -68,10 +73,39 @@ uint256 CCoinsViewDB::GetBestBlock() const {\n     return hashBestChain;\n }\n \n+std::vector<uint256> CCoinsViewDB::GetHeadBlocks() const {\n+    std::vector<uint256> vhashHeadBlocks;\n+    if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) {\n+        return std::vector<uint256>();\n+    }\n+    return vhashHeadBlocks;\n+}\n+\n bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     CDBBatch batch(db);\n     size_t count = 0;\n     size_t changed = 0;\n+    size_t batch_size = (size_t)GetArg(\"-dbbatchsize\", nDefaultDbBatchSize);\n+    int crash_simulate = GetArg(\"-dbcrashratio\", 0);\n+    assert(!hashBlock.IsNull());\n+\n+    uint256 old_tip = GetBestBlock();\n+    if (old_tip.IsNull()) {\n+        // We may be in the middle of replaying.\n+        std::vector<uint256> old_heads = GetHeadBlocks();\n+        if (old_heads.size() == 2) {\n+            assert(old_heads[0] == hashBlock);\n+            old_tip = old_heads[1];\n+        }\n+    }\n+\n+    // In the first batch, mark the database as being in the middle of a\n+    // transition from old_tip to hashBlock.\n+    // A vector is used for future extensibility, as we may want to support\n+    // interrupting after partial writes from multiple independent reorgs.\n+    batch.Erase(DB_BEST_BLOCK);\n+    batch.Write(DB_HEAD_BLOCKS, std::vector<uint256>{hashBlock, old_tip});\n+\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             CoinEntry entry(&it->first);\n@@ -84,10 +118,25 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n         count++;\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n+        if (batch.SizeEstimate() > batch_size) {\n+            LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n+            db.WriteBatch(batch);\n+            batch.Clear();\n+            if (crash_simulate) {\n+                static FastRandomContext rng;\n+                if (rng.randrange(crash_simulate) == 0) {\n+                    LogPrintf(\"Simulating a crash. Goodbye.\\n\");\n+                    _Exit(0);\n+                }\n+            }\n+        }\n     }\n-    if (!hashBlock.IsNull())\n-        batch.Write(DB_BEST_BLOCK, hashBlock);\n \n+    // In the last batch, mark the database as consistent with hashBlock again.\n+    batch.Erase(DB_HEAD_BLOCKS);\n+    batch.Write(DB_BEST_BLOCK, hashBlock);\n+\n+    LogPrint(BCLog::COINDB, \"Writing final batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n     bool ret = db.WriteBatch(batch);\n     LogPrint(BCLog::COINDB, \"Committed %u changed transaction outputs (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n     return ret;\n@@ -210,7 +259,7 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n-bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n+bool CBlockTreeDB::LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());\n \n@@ -238,12 +287,12 @@ bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)\n                 pindexNew->nStatus        = diskindex.nStatus;\n                 pindexNew->nTx            = diskindex.nTx;\n \n-                if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits, Params().GetConsensus()))\n-                    return error(\"LoadBlockIndex(): CheckProofOfWork failed: %s\", pindexNew->ToString());\n+                if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits, consensusParams))\n+                    return error(\"%s: CheckProofOfWork failed: %s\", __func__, pindexNew->ToString());\n \n                 pcursor->Next();\n             } else {\n-                return error(\"LoadBlockIndex() : failed to read value\");\n+                return error(\"%s: failed to read value\", __func__);\n             }\n         } else {\n             break;\n@@ -319,13 +368,30 @@ bool CCoinsViewDB::Upgrade() {\n         return true;\n     }\n \n-    LogPrintf(\"Upgrading database...\\n\");\n+    int64_t count = 0;\n+    LogPrintf(\"Upgrading utxo-set database...\\n\");\n+    LogPrintf(\"[0%%]...\");\n     size_t batch_size = 1 << 24;\n     CDBBatch batch(db);\n+    uiInterface.SetProgressBreakAction(StartShutdown);\n+    int reportDone = 0;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n+        if (ShutdownRequested()) {\n+            break;\n+        }\n         std::pair<unsigned char, uint256> key;\n         if (pcursor->GetKey(key) && key.first == DB_COINS) {\n+            if (count++ % 256 == 0) {\n+                uint32_t high = 0x100 * *key.second.begin() + *(key.second.begin() + 1);\n+                int percentageDone = (int)(high * 100.0 / 65536.0 + 0.5);\n+                uiInterface.ShowProgress(_(\"Upgrading UTXO database\") + \"\\n\"+ _(\"(press q to shutdown and continue later)\") + \"\\n\", percentageDone);\n+                if (reportDone < percentageDone/10) {\n+                    // report max. every 10% step\n+                    LogPrintf(\"[%d%%]...\", percentageDone);\n+                    reportDone = percentageDone/10;\n+                }\n+            }\n             CCoins old_coins;\n             if (!pcursor->GetValue(old_coins)) {\n                 return error(\"%s: cannot parse CCoins record\", __func__);\n@@ -350,5 +416,7 @@ bool CCoinsViewDB::Upgrade() {\n         }\n     }\n     db.WriteBatch(batch);\n+    uiInterface.SetProgressBreakAction(std::function<void(void)>());\n+    LogPrintf(\"[%s].\\n\", ShutdownRequested() ? \"CANCELLED\" : \"DONE\");\n     return true;\n }"
      },
      {
        "sha": "adcbc73380d116ef3cf8fd6fab5e112ea554a7b7",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -19,12 +19,12 @@ class CBlockIndex;\n class CCoinsViewDBCursor;\n class uint256;\n \n-//! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n-static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n //! No need to periodic flush if at least this much space still available.\n-static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n+static constexpr int MAX_BLOCK_COINSDB_USAGE = 10;\n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n+//! -dbbatchsize default (bytes)\n+static const int64_t nDefaultDbBatchSize = 16 << 20;\n //! max. -dbcache (MiB)\n static const int64_t nMaxDbCache = sizeof(void*) > 4 ? 16384 : 1024;\n //! min. -dbcache (MiB)\n@@ -74,6 +74,7 @@ class CCoinsViewDB : public CCoinsView\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n \n@@ -88,12 +89,12 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n public:\n     ~CCoinsViewDBCursor() {}\n \n-    bool GetKey(COutPoint &key) const;\n-    bool GetValue(Coin &coin) const;\n-    unsigned int GetValueSize() const;\n+    bool GetKey(COutPoint &key) const override;\n+    bool GetValue(Coin &coin) const override;\n+    unsigned int GetValueSize() const override;\n \n-    bool Valid() const;\n-    void Next();\n+    bool Valid() const override;\n+    void Next() override;\n \n private:\n     CCoinsViewDBCursor(CDBIterator* pcursorIn, const uint256 &hashBlockIn):\n@@ -122,7 +123,7 @@ class CBlockTreeDB : public CDBWrapper\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n-    bool LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n+    bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "dcfc5ffde0b56aea71fa63945e8473fa316d835b",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -122,7 +122,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     // accounted for in the state of their ancestors)\n     std::set<uint256> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n \n-    // Iterate in reverse, so that whenever we are looking at at a transaction\n+    // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n     // This maximizes the benefit of the descendant cache and guarantees that\n     // setMemPoolChildren will be updated, an assumption made in\n@@ -769,7 +769,7 @@ class DepthAndScoreComparator\n         return counta < countb;\n     }\n };\n-}\n+} // namespace\n \n std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::GetSortedDepthAndScore() const\n {\n@@ -903,11 +903,7 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n             return false;\n         }\n     }\n-    return (base->GetCoin(outpoint, coin) && !coin.IsSpent());\n-}\n-\n-bool CCoinsViewMemPool::HaveCoin(const COutPoint &outpoint) const {\n-    return mempool.exists(outpoint) || base->HaveCoin(outpoint);\n+    return base->GetCoin(outpoint, coin);\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n@@ -1050,9 +1046,7 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpends\n             for (const CTransaction& tx : txn) {\n                 for (const CTxIn& txin : tx.vin) {\n                     if (exists(txin.prevout.hash)) continue;\n-                    if (!mapNextTx.count(txin.prevout)) {\n-                        pvNoSpendsRemaining->push_back(txin.prevout);\n-                    }\n+                    pvNoSpendsRemaining->push_back(txin.prevout);\n                 }\n             }\n         }"
      },
      {
        "sha": "d272114a7c551e29f687e38fec85f8ad05cf5431",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -618,13 +618,6 @@ class CTxMemPool\n         return (mapTx.count(hash) != 0);\n     }\n \n-    bool exists(const COutPoint& outpoint) const\n-    {\n-        LOCK(cs);\n-        auto it = mapTx.find(outpoint.hash);\n-        return (it != mapTx.end() && outpoint.n < it->GetTx().vout.size());\n-    }\n-\n     CTransactionRef get(const uint256& hash) const;\n     TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n@@ -676,6 +669,13 @@ class CTxMemPool\n /** \n  * CCoinsView that brings transactions from a memorypool into view.\n  * It does not check for spendings by memory pool transactions.\n+ * Instead, it provides access to all Coins which are either unspent in the\n+ * base CCoinsView, or are outputs from any mempool transaction!\n+ * This allows transaction replacement to work as expected, as you want to\n+ * have all inputs \"available\" to check signatures, and any cycles in the\n+ * dependency graph are checked directly in AcceptToMemoryPool.\n+ * It also allows you to sign a double-spend directly in signrawtransaction,\n+ * as long as the conflicting transaction is not yet confirmed.\n  */\n class CCoinsViewMemPool : public CCoinsViewBacked\n {\n@@ -684,8 +684,7 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n-    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n-    bool HaveCoin(const COutPoint &outpoint) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n };\n \n /**"
      },
      {
        "sha": "762dd19b1904184d471d861835614f37d1102bed",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -97,6 +97,9 @@ class CClientUIInterface\n     /** Show progress e.g. for verifychain */\n     boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n \n+    /** Set progress break action (possible \"cancel button\" triggers that action) */\n+    boost::signals2::signal<void (std::function<void(void)> action)> SetProgressBreakAction;\n+\n     /** New block has been accepted */\n     boost::signals2::signal<void (bool, const CBlockIndex *)> NotifyBlockTip;\n "
      },
      {
        "sha": "b76c173f90602e56d5457d1c1e9467c662df0663",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -84,6 +84,8 @@\n #include <openssl/rand.h>\n #include <openssl/conf.h>\n \n+// Application startup time (used for uptime calculation)\n+const int64_t nStartupTime = GetTime();\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n@@ -420,7 +422,9 @@ void ArgsManager::ParseParameters(int argc, const char* const argv[])\n std::vector<std::string> ArgsManager::GetArgs(const std::string& strArg)\n {\n     LOCK(cs_args);\n-    return mapMultiArgs.at(strArg);\n+    if (IsArgSet(strArg))\n+        return mapMultiArgs.at(strArg);\n+    return {};\n }\n \n bool ArgsManager::IsArgSet(const std::string& strArg)\n@@ -889,3 +893,9 @@ std::string CopyrightHolders(const std::string& strPrefix)\n     }\n     return strCopyrightHolders;\n }\n+\n+// Obtain the application startup time (used for uptime calculation)\n+int64_t GetStartupTime()\n+{\n+    return nStartupTime;\n+}"
      },
      {
        "sha": "824ad51ac48a08d780db2402d0a037a5bf20f0c7",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 72,
        "deletions": 56,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -5,7 +5,7 @@\n \n /**\n  * Server/client environment: argument handling, config file parsing,\n- * logging, thread wrappers\n+ * logging, thread wrappers, startup time\n  */\n #ifndef BITCOIN_UTIL_H\n #define BITCOIN_UTIL_H\n@@ -29,6 +29,9 @@\n \n #include <boost/signals2/signal.hpp>\n \n+// Application startup time (used for uptime calculation)\n+int64_t GetStartupTime();\n+\n static const bool DEFAULT_LOGTIMEMICROS = false;\n static const bool DEFAULT_LOGIPS        = false;\n static const bool DEFAULT_LOGTIMESTAMPS = true;\n@@ -122,6 +125,17 @@ int LogPrintStr(const std::string &str);\n /** Get format string from VA_ARGS for error reporting */\n template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }\n \n+static inline void MarkUsed() {}\n+template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)\n+{\n+    (void)t;\n+    MarkUsed(args...);\n+}\n+\n+#ifdef USE_COVERAGE\n+#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#else\n #define LogPrintf(...) do { \\\n     std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \\\n     try { \\\n@@ -138,6 +152,7 @@ template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt,\n         LogPrintf(__VA_ARGS__); \\\n     } \\\n } while(0)\n+#endif\n \n template<typename... Args>\n bool error(const char* fmt, const Args&... args)\n@@ -187,62 +202,63 @@ class ArgsManager\n     void ParseParameters(int argc, const char*const argv[]);\n     void ReadConfigFile(const std::string& confPath);\n     std::vector<std::string> GetArgs(const std::string& strArg);\n-/**\n- * Return true if the given argument has been manually set\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @return true if the argument has been set\n- */\n-bool IsArgSet(const std::string& strArg);\n-\n-/**\n- * Return string argument or default value\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @param default (e.g. \"1\")\n- * @return command-line argument or default value\n- */\n-std::string GetArg(const std::string& strArg, const std::string& strDefault);\n-\n-/**\n- * Return integer argument or default value\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @param default (e.g. 1)\n- * @return command-line argument (0 if invalid number) or default value\n- */\n-int64_t GetArg(const std::string& strArg, int64_t nDefault);\n-\n-/**\n- * Return boolean argument or default value\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @param default (true or false)\n- * @return command-line argument or default value\n- */\n-bool GetBoolArg(const std::string& strArg, bool fDefault);\n-\n-/**\n- * Set an argument if it doesn't already have a value\n- *\n- * @param strArg Argument to set (e.g. \"-foo\")\n- * @param strValue Value (e.g. \"1\")\n- * @return true if argument gets set, false if it already had a value\n- */\n-bool SoftSetArg(const std::string& strArg, const std::string& strValue);\n-\n-/**\n- * Set a boolean argument if it doesn't already have a value\n- *\n- * @param strArg Argument to set (e.g. \"-foo\")\n- * @param fValue Value (e.g. false)\n- * @return true if argument gets set, false if it already had a value\n- */\n-bool SoftSetBoolArg(const std::string& strArg, bool fValue);\n \n-// Forces an arg setting. Called by SoftSetArg() if the arg hasn't already\n-// been set. Also called directly in testing.\n-void ForceSetArg(const std::string& strArg, const std::string& strValue);\n+    /**\n+     * Return true if the given argument has been manually set\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @return true if the argument has been set\n+     */\n+    bool IsArgSet(const std::string& strArg);\n+\n+    /**\n+     * Return string argument or default value\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @param default (e.g. \"1\")\n+     * @return command-line argument or default value\n+     */\n+    std::string GetArg(const std::string& strArg, const std::string& strDefault);\n+\n+    /**\n+     * Return integer argument or default value\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @param default (e.g. 1)\n+     * @return command-line argument (0 if invalid number) or default value\n+     */\n+    int64_t GetArg(const std::string& strArg, int64_t nDefault);\n+\n+    /**\n+     * Return boolean argument or default value\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @param default (true or false)\n+     * @return command-line argument or default value\n+     */\n+    bool GetBoolArg(const std::string& strArg, bool fDefault);\n+\n+    /**\n+     * Set an argument if it doesn't already have a value\n+     *\n+     * @param strArg Argument to set (e.g. \"-foo\")\n+     * @param strValue Value (e.g. \"1\")\n+     * @return true if argument gets set, false if it already had a value\n+     */\n+    bool SoftSetArg(const std::string& strArg, const std::string& strValue);\n+\n+    /**\n+     * Set a boolean argument if it doesn't already have a value\n+     *\n+     * @param strArg Argument to set (e.g. \"-foo\")\n+     * @param fValue Value (e.g. false)\n+     * @return true if argument gets set, false if it already had a value\n+     */\n+    bool SoftSetBoolArg(const std::string& strArg, bool fValue);\n+\n+    // Forces an arg setting. Called by SoftSetArg() if the arg hasn't already\n+    // been set. Also called directly in testing.\n+    void ForceSetArg(const std::string& strArg, const std::string& strValue);\n };\n \n extern ArgsManager gArgs;"
      },
      {
        "sha": "93abaec04b1090a25680daf8c2db74c209ad6e97",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -437,7 +437,7 @@ bool ParseInt32(const std::string& str, int32_t *out)\n     errno = 0; // strtol will not set errno if valid\n     long int n = strtol(str.c_str(), &endp, 10);\n     if(out) *out = (int32_t)n;\n-    // Note that strtol returns a *long int*, so even if strtol doesn't report a over/underflow\n+    // Note that strtol returns a *long int*, so even if strtol doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *int32_t*. On 64-bit\n     // platforms the size of these types may be different.\n     return endp && *endp == 0 && !errno &&\n@@ -453,7 +453,7 @@ bool ParseInt64(const std::string& str, int64_t *out)\n     errno = 0; // strtoll will not set errno if valid\n     long long int n = strtoll(str.c_str(), &endp, 10);\n     if(out) *out = (int64_t)n;\n-    // Note that strtoll returns a *long long int*, so even if strtol doesn't report a over/underflow\n+    // Note that strtoll returns a *long long int*, so even if strtol doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *int64_t*.\n     return endp && *endp == 0 && !errno &&\n         n >= std::numeric_limits<int64_t>::min() &&\n@@ -470,7 +470,7 @@ bool ParseUInt32(const std::string& str, uint32_t *out)\n     errno = 0; // strtoul will not set errno if valid\n     unsigned long int n = strtoul(str.c_str(), &endp, 10);\n     if(out) *out = (uint32_t)n;\n-    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report a over/underflow\n+    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *uint32_t*. On 64-bit\n     // platforms the size of these types may be different.\n     return endp && *endp == 0 && !errno &&\n@@ -487,7 +487,7 @@ bool ParseUInt64(const std::string& str, uint64_t *out)\n     errno = 0; // strtoull will not set errno if valid\n     unsigned long long int n = strtoull(str.c_str(), &endp, 10);\n     if(out) *out = (uint64_t)n;\n-    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report a over/underflow\n+    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *uint64_t*.\n     return endp && *endp == 0 && !errno &&\n         n <= std::numeric_limits<uint64_t>::max();"
      },
      {
        "sha": "975cbcc79ffbbfdf3e8bae49ed57cba013bd39e4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 281,
        "deletions": 67,
        "changes": 348,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -14,6 +14,7 @@\n #include \"consensus/merkle.h\"\n #include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n+#include \"cuckoocache.h\"\n #include \"fs.h\"\n #include \"hash.h\"\n #include \"init.h\"\n@@ -96,7 +97,7 @@ namespace {\n \n     struct CBlockIndexWorkComparator\n     {\n-        bool operator()(CBlockIndex *pa, CBlockIndex *pb) const {\n+        bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n             // First sort by most total work, ...\n             if (pa->nChainWork > pb->nChainWork) return false;\n             if (pa->nChainWork < pb->nChainWork) return true;\n@@ -189,7 +190,7 @@ enum FlushStateMode {\n static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n@@ -312,6 +313,9 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n+// Returns the script flags which should be checked for a given block\n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n+\n static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -395,6 +399,42 @@ void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool f\n     LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n \n+// Used to avoid mempool polluting consensus critical paths if CCoinsViewMempool\n+// were somehow broken and returning the wrong scriptPubKeys\n+static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, CTxMemPool& pool,\n+                 unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) {\n+    AssertLockHeld(cs_main);\n+\n+    // pool.cs should be locked already, but go ahead and re-take the lock here\n+    // to enforce that mempool doesn't change between when we check the view\n+    // and when we actually call through to CheckInputs\n+    LOCK(pool.cs);\n+\n+    assert(!tx.IsCoinBase());\n+    for (const CTxIn& txin : tx.vin) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+\n+        // At this point we haven't actually checked if the coins are all\n+        // available (or shouldn't assume we have, since CheckInputs does).\n+        // So we just return failure if the inputs are not available here,\n+        // and then only have to check equivalence for available inputs.\n+        if (coin.IsSpent()) return false;\n+\n+        const CTransactionRef& txFrom = pool.get(txin.prevout.hash);\n+        if (txFrom) {\n+            assert(txFrom->GetHash() == txin.prevout.hash);\n+            assert(txFrom->vout.size() > txin.prevout.n);\n+            assert(txFrom->vout[txin.prevout.n] == coin.out);\n+        } else {\n+            const Coin& coinFromDisk = pcoinsTip->AccessCoin(txin.prevout);\n+            assert(!coinFromDisk.IsSpent());\n+            assert(coinFromDisk.out == coin.out);\n+        }\n+    }\n+\n+    return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n+}\n+\n static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n@@ -430,8 +470,9 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n-    if (pool.exists(hash))\n-        return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-in-mempool\");\n+    if (pool.exists(hash)) {\n+        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+    }\n \n     // Check for conflicts with in-memory transactions\n     std::set<uint256> setConflicts;\n@@ -469,8 +510,9 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                         }\n                     }\n                 }\n-                if (fReplacementOptOut)\n-                    return state.Invalid(false, REJECT_CONFLICT, \"txn-mempool-conflict\");\n+                if (fReplacementOptOut) {\n+                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n             }\n@@ -497,7 +539,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 if (!had_coin_in_cache) {\n                     coins_to_uncache.push_back(outpoint);\n                 }\n-                return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n+                return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n             }\n         }\n \n@@ -749,32 +791,51 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         PrecomputedTransactionData txdata(tx);\n-        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)) {\n+        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n             CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {\n+            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n             return false; // state filled in by CheckInputs\n         }\n \n-        // Check again against just the consensus-critical mandatory script\n-        // verification flags, in case of bugs in the standard flags that cause\n+        // Check again against the current block tip's script verification\n+        // flags to cache our script execution flags. This is, of course,\n+        // useless if the next block has different script flags from the\n+        // previous one, but because the cache tracks script flags for us it\n+        // will auto-invalidate and we'll just have a few blocks of extra\n+        // misses on soft-fork activation.\n+        //\n+        // This is also useful in case of bugs in the standard flags that cause\n         // transactions to pass as valid when they're actually invalid. For\n         // instance the STRICTENC flag was incorrectly allowing certain\n         // CHECKSIG NOT scripts to pass, even though they were invalid.\n         //\n         // There is a similar check in CreateNewBlock() to prevent creating\n-        // invalid blocks, however allowing such transactions into the mempool\n-        // can be exploited as a DoS attack.\n-        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata))\n+        // invalid blocks (using TestBlockValidity), however allowing such\n+        // transactions into the mempool can be exploited as a DoS attack.\n+        unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(chainActive.Tip(), Params().GetConsensus());\n+        if (!CheckInputsFromMempoolAndCache(tx, state, view, pool, currentBlockScriptVerifyFlags, true, txdata))\n         {\n-            return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n-                __func__, hash.ToString(), FormatStateMessage(state));\n+            // If we're using promiscuousmempoolflags, we may hit this normally\n+            // Check if current block has some flags that scriptVerifyFlags\n+            // does not before printing an ominous warning\n+            if (!(~scriptVerifyFlags & currentBlockScriptVerifyFlags)) {\n+                return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against latest-block but not STANDARD flags %s, %s\",\n+                    __func__, hash.ToString(), FormatStateMessage(state));\n+            } else {\n+                if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, false, txdata)) {\n+                    return error(\"%s: ConnectInputs failed against MANDATORY but not STANDARD flags due to promiscuous mempool %s, %s\",\n+                        __func__, hash.ToString(), FormatStateMessage(state));\n+                } else {\n+                    LogPrintf(\"Warning: -promiscuousmempool flags set to not include currently enforced soft forks, this may break mining or otherwise cause instability!\\n\");\n+                }\n+            }\n         }\n \n         // Remove conflicting transactions from the mempool\n@@ -1123,7 +1184,8 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n         txundo.vprevout.reserve(tx.vin.size());\n         for (const CTxIn &txin : tx.vin) {\n             txundo.vprevout.emplace_back();\n-            inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());\n+            bool is_spent = inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());\n+            assert(is_spent);\n         }\n     }\n     // add outputs\n@@ -1149,12 +1211,34 @@ int GetSpendHeight(const CCoinsViewCache& inputs)\n     return pindexPrev->nHeight + 1;\n }\n \n+\n+static CuckooCache::cache<uint256, SignatureCacheHasher> scriptExecutionCache;\n+static uint256 scriptExecutionCacheNonce(GetRandHash());\n+\n+void InitScriptExecutionCache() {\n+    // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n+    // setup_bytes creates the minimum possible cache (2 elements).\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n+    size_t nElems = scriptExecutionCache.setup_bytes(nMaxCacheSize);\n+    LogPrintf(\"Using %zu MiB out of %zu/2 requested for script execution cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n+}\n+\n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n- * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n- * instead of being performed inline.\n+ * This does not modify the UTXO set.\n+ *\n+ * If pvChecks is not NULL, script checks are pushed onto it instead of being performed inline. Any\n+ * script checks which are not necessary (eg due to script execution cache hits) are, obviously,\n+ * not pushed onto pvChecks/run.\n+ *\n+ * Setting cacheSigStore/cacheFullScriptStore to false will remove elements from the corresponding cache\n+ * which are matched. This is useful for checking blocks where we will likely never need the cache\n+ * entry again.\n+ *\n+ * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1174,6 +1258,21 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n         // Of course, if an assumed valid block is invalid due to false scriptSigs\n         // this optimization would allow an invalid chain to be accepted.\n         if (fScriptChecks) {\n+            // First check if script executions have been cached with the same\n+            // flags. Note that this assumes that the inputs provided are\n+            // correct (ie that the transaction hash which is in tx's prevouts\n+            // properly commits to the scriptPubKey in the inputs view of that\n+            // transaction).\n+            uint256 hashCacheEntry;\n+            // We only use the first 19 bytes of nonce to avoid a second SHA\n+            // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n+            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n+            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n+            AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n+            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n+                return true;\n+            }\n+\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n@@ -1188,7 +1287,7 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                 const CAmount amount = coin.out.nValue;\n \n                 // Verify signature\n-                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);\n+                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheSigStore, &txdata);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -1201,12 +1300,12 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n                         CScriptCheck check2(scriptPubKey, amount, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n+                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n-                    // invalid in new blocks, e.g. a invalid P2SH. We DoS ban\n+                    // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n                     // such nodes as they are not following the protocol. That\n                     // said during an upgrade careful thought should be taken\n                     // as to the correct behavior - we may want to continue\n@@ -1215,6 +1314,12 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                     return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n+\n+            if (cacheFullScriptStore && !pvChecks) {\n+                // We executed all of the provided scripts, and were told to\n+                // cache the result. Do so now.\n+                scriptExecutionCache.insert(hashCacheEntry);\n+            }\n         }\n     }\n \n@@ -1294,7 +1399,7 @@ bool AbortNode(CValidationState& state, const std::string& strMessage, const std\n     return state.Error(strMessage);\n }\n \n-} // anon namespace\n+} // namespace\n \n enum DisconnectResult\n {\n@@ -1328,17 +1433,19 @@ int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n             return DISCONNECT_FAILED; // adding output for transaction without known metadata\n         }\n     }\n-    view.AddCoin(out, std::move(undo), undo.fCoinBase);\n+    // The potential_overwrite parameter to AddCoin is only allowed to be false if we know for\n+    // sure that the coin did not already exist in the cache. As we have queried for that above\n+    // using HaveCoin, we don't need to guess. When fClean is false, a coin already existed and\n+    // it is an overwrite.\n+    view.AddCoin(out, std::move(undo), !fClean);\n \n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n- *  When UNCLEAN or FAILED is returned, view is left in an indeterminate state. */\n+ *  When FAILED is returned, view is left in an indeterminate state. */\n static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)\n {\n-    assert(pindex->GetBlockHash() == view.GetBestBlock());\n-\n     bool fClean = true;\n \n     CBlockUndo blockUndo;\n@@ -1361,15 +1468,16 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n         const CTransaction &tx = *(block.vtx[i]);\n         uint256 hash = tx.GetHash();\n+        bool is_coinbase = tx.IsCoinBase();\n \n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n         for (size_t o = 0; o < tx.vout.size(); o++) {\n             if (!tx.vout[o].scriptPubKey.IsUnspendable()) {\n                 COutPoint out(hash, o);\n                 Coin coin;\n-                view.SpendCoin(out, &coin);\n-                if (tx.vout[o] != coin.out) {\n+                bool is_spent = view.SpendCoin(out, &coin);\n+                if (!is_spent || tx.vout[o] != coin.out || pindex->nHeight != coin.nHeight || is_coinbase != coin.fCoinBase) {\n                     fClean = false; // transaction output mismatch\n                 }\n             }\n@@ -1459,12 +1567,12 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n public:\n     WarningBitsConditionChecker(int bitIn) : bit(bitIn) {}\n \n-    int64_t BeginTime(const Consensus::Params& params) const { return 0; }\n-    int64_t EndTime(const Consensus::Params& params) const { return std::numeric_limits<int64_t>::max(); }\n-    int Period(const Consensus::Params& params) const { return params.nMinerConfirmationWindow; }\n-    int Threshold(const Consensus::Params& params) const { return params.nRuleChangeActivationThreshold; }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return 0; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return std::numeric_limits<int64_t>::max(); }\n+    int Period(const Consensus::Params& params) const override { return params.nMinerConfirmationWindow; }\n+    int Threshold(const Consensus::Params& params) const override { return params.nRuleChangeActivationThreshold; }\n \n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override\n     {\n         return ((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) &&\n                ((pindex->nVersion >> bit) & 1) != 0 &&\n@@ -1475,6 +1583,41 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n // Protected by cs_main\n static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS];\n \n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) {\n+    AssertLockHeld(cs_main);\n+\n+    // BIP16 didn't become active until Apr 1 2012\n+    int64_t nBIP16SwitchTime = 1333238400;\n+    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n+\n+    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n+\n+    // Start enforcing the DERSIG (BIP66) rule\n+    if (pindex->nHeight >= consensusparams.BIP66Height) {\n+        flags |= SCRIPT_VERIFY_DERSIG;\n+    }\n+\n+    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n+    if (pindex->nHeight >= consensusparams.BIP65Height) {\n+        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+    }\n+\n+    // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+        flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+    }\n+\n+    // Start enforcing WITNESS rules using versionbits logic.\n+    if (IsWitnessEnabled(pindex->pprev, consensusparams)) {\n+        flags |= SCRIPT_VERIFY_WITNESS;\n+        flags |= SCRIPT_VERIFY_NULLDUMMY;\n+    }\n+\n+    return flags;\n+}\n+\n+\n+\n static int64_t nTimeCheck = 0;\n static int64_t nTimeForks = 0;\n static int64_t nTimeVerify = 0;\n@@ -1578,34 +1721,14 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         }\n     }\n \n-    // BIP16 didn't become active until Apr 1 2012\n-    int64_t nBIP16SwitchTime = 1333238400;\n-    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n-\n-    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n-\n-    // Start enforcing the DERSIG (BIP66) rule\n-    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {\n-        flags |= SCRIPT_VERIFY_DERSIG;\n-    }\n-\n-    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n-    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {\n-        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n-    }\n-\n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n     int nLockTimeFlags = 0;\n     if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n-        flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n-    // Start enforcing WITNESS rules using versionbits logic.\n-    if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {\n-        flags |= SCRIPT_VERIFY_WITNESS;\n-        flags |= SCRIPT_VERIFY_NULLDUMMY;\n-    }\n+    // Get the script flags for this block\n+    unsigned int flags = GetBlockScriptFlags(pindex, chainparams.GetConsensus());\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n     LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);\n@@ -1666,7 +1789,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             control.Add(vChecks);\n@@ -1776,7 +1899,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         nLastSetChain = nNow;\n     }\n     int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n-    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;\n+    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n     int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n     // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n     bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n@@ -1943,6 +2066,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     int64_t nStart = GetTimeMicros();\n     {\n         CCoinsViewCache view(pcoinsTip);\n+        assert(view.GetBestBlock() == pindexDelete->GetBlockHash());\n         if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n         bool flushed = view.Flush();\n@@ -3322,7 +3446,7 @@ CBlockIndex * InsertBlockIndex(uint256 hash)\n \n bool static LoadBlockIndexDB(const CChainParams& chainparams)\n {\n-    if (!pblocktree->LoadBlockIndexGuts(InsertBlockIndex))\n+    if (!pblocktree->LoadBlockIndexGuts(chainparams.GetConsensus(), InsertBlockIndex))\n         return false;\n \n     boost::this_thread::interruption_point();\n@@ -3414,20 +3538,25 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n+    return true;\n+}\n+\n+void LoadChainTip(const CChainParams& chainparams)\n+{\n+    if (chainActive.Tip() && chainActive.Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return;\n+\n     // Load pointer to end of best chain\n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n-        return true;\n+        return;\n     chainActive.SetTip(it->second);\n \n     PruneBlockIndexCandidates();\n \n-    LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,\n+    LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n         chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n         DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n         GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));\n-\n-    return true;\n }\n \n CVerifyDB::CVerifyDB()\n@@ -3496,6 +3625,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n+            assert(coins.GetBestBlock() == pindex->GetBlockHash());\n             DisconnectResult res = DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n@@ -3535,6 +3665,92 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+/** Apply the effects of a block on the utxo cache, ignoring that it may already have been applied. */\n+static bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params)\n+{\n+    // TODO: merge with ConnectBlock\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindex, params.GetConsensus())) {\n+        return error(\"ReplayBlock(): ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+    }\n+\n+    for (const CTransactionRef& tx : block.vtx) {\n+        if (!tx->IsCoinBase()) {\n+            for (const CTxIn &txin : tx->vin) {\n+                inputs.SpendCoin(txin.prevout);\n+            }\n+        }\n+        // Pass check = true as every addition may be an overwrite.\n+        AddCoins(inputs, *tx, pindex->nHeight, true);\n+    }\n+    return true;\n+}\n+\n+bool ReplayBlocks(const CChainParams& params, CCoinsView* view)\n+{\n+    LOCK(cs_main);\n+\n+    CCoinsViewCache cache(view);\n+\n+    std::vector<uint256> hashHeads = view->GetHeadBlocks();\n+    if (hashHeads.empty()) return true; // We're already in a consistent state.\n+    if (hashHeads.size() != 2) return error(\"ReplayBlocks(): unknown inconsistent state\");\n+\n+    uiInterface.ShowProgress(_(\"Replaying blocks...\"), 0);\n+    LogPrintf(\"Replaying blocks\\n\");\n+\n+    const CBlockIndex* pindexOld = nullptr;  // Old tip during the interrupted flush.\n+    const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n+    const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n+\n+    if (mapBlockIndex.count(hashHeads[0]) == 0) {\n+        return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n+    }\n+    pindexNew = mapBlockIndex[hashHeads[0]];\n+\n+    if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n+        if (mapBlockIndex.count(hashHeads[1]) == 0) {\n+            return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n+        }\n+        pindexOld = mapBlockIndex[hashHeads[1]];\n+        pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n+        assert(pindexFork != nullptr);\n+    }\n+\n+    // Rollback along the old branch.\n+    while (pindexOld != pindexFork) {\n+        if (pindexOld->nHeight > 0) { // Never disconnect the genesis block.\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, pindexOld, params.GetConsensus())) {\n+                return error(\"RollbackBlock(): ReadBlockFromDisk() failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n+            }\n+            LogPrintf(\"Rolling back %s (%i)\\n\", pindexOld->GetBlockHash().ToString(), pindexOld->nHeight);\n+            DisconnectResult res = DisconnectBlock(block, pindexOld, cache);\n+            if (res == DISCONNECT_FAILED) {\n+                return error(\"RollbackBlock(): DisconnectBlock failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n+            }\n+            // If DISCONNECT_UNCLEAN is returned, it means a non-existing UTXO was deleted, or an existing UTXO was\n+            // overwritten. It corresponds to cases where the block-to-be-disconnect never had all its operations\n+            // applied to the UTXO set. However, as both writing a UTXO and deleting a UTXO are idempotent operations,\n+            // the result is still a version of the UTXO set with the effects of that block undone.\n+        }\n+        pindexOld = pindexOld->pprev;\n+    }\n+\n+    // Roll forward from the forking point to the new tip.\n+    int nForkHeight = pindexFork ? pindexFork->nHeight : 0;\n+    for (int nHeight = nForkHeight + 1; nHeight <= pindexNew->nHeight; ++nHeight) {\n+        const CBlockIndex* pindex = pindexNew->GetAncestor(nHeight);\n+        LogPrintf(\"Rolling forward %s (%i)\\n\", pindex->GetBlockHash().ToString(), nHeight);\n+        if (!RollforwardBlock(pindex, cache, params)) return false;\n+    }\n+\n+    cache.SetBestBlock(pindexNew->GetBlockHash());\n+    cache.Flush();\n+    uiInterface.ShowProgress(\"\", 100);\n+    return true;\n+}\n+\n bool RewindBlockIndex(const CChainParams& params)\n {\n     LOCK(cs_main);\n@@ -3684,8 +3900,6 @@ bool InitBlockIndex(const CChainParams& chainparams)\n             CBlockIndex *pindex = AddToBlockIndex(block);\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n                 return error(\"LoadBlockIndex(): genesis block not accepted\");\n-            // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n-            return FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n         } catch (const std::runtime_error& e) {\n             return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());\n         }"
      },
      {
        "sha": "a9f995abb887e873a71c7152e83ff665e3091f82",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -260,6 +260,8 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n bool InitBlockIndex(const CChainParams& chainparams);\n /** Load the block tree and coins database from disk */\n bool LoadBlockIndex(const CChainParams& chainparams);\n+/** Update the chain tip based on database information. */\n+void LoadChainTip(const CChainParams& chainparams);\n /** Unload database information */\n void UnloadBlockIndex();\n /** Run an instance of the script checking thread */\n@@ -391,6 +393,9 @@ class CScriptCheck\n     ScriptError GetScriptError() const { return error; }\n };\n \n+/** Initializes the script-execution cache */\n+void InitScriptExecutionCache();\n+\n \n /** Functions for disk access for blocks */\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n@@ -424,6 +429,9 @@ class CVerifyDB {\n     bool VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth);\n };\n \n+/** Replay blocks that aren't fully applied to the database. */\n+bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n+\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n \n@@ -469,10 +477,6 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n static const unsigned int REJECT_INTERNAL = 0x100;\n /** Too high fee. Can not be triggered by P2P transactions */\n static const unsigned int REJECT_HIGHFEE = 0x100;\n-/** Transaction is already known (either in mempool or blockchain) */\n-static const unsigned int REJECT_ALREADY_KNOWN = 0x101;\n-/** Transaction conflicts with a transaction already known */\n-static const unsigned int REJECT_CONFLICT = 0x102;\n \n /** Get block file info entry for one block file */\n CBlockFileInfo* GetBlockFileInfo(size_t n);"
      },
      {
        "sha": "be2f20b8635d9f727e65722b4b2c108e48b30385",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -21,12 +21,10 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n-    g_signals.ScriptForMining.connect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));\n     g_signals.NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n-    g_signals.ScriptForMining.disconnect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));\n     g_signals.BlockChecked.disconnect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n     g_signals.Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n@@ -39,7 +37,6 @@ void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n }\n \n void UnregisterAllValidationInterfaces() {\n-    g_signals.ScriptForMining.disconnect_all_slots();\n     g_signals.BlockChecked.disconnect_all_slots();\n     g_signals.Broadcast.disconnect_all_slots();\n     g_signals.Inventory.disconnect_all_slots();"
      },
      {
        "sha": "17545018df75af6067f2247fd3e3aa2fde0066bf",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -40,7 +40,6 @@ class CValidationInterface {\n     virtual void Inventory(const uint256 &hash) {}\n     virtual void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) {}\n     virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n-    virtual void GetScriptForMining(std::shared_ptr<CReserveScript>&) {};\n     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n@@ -72,8 +71,6 @@ struct CMainSignals {\n      * callback was generated (not necessarily now)\n      */\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n-    /** Notifies listeners that a key for mining is required (coinbase) */\n-    boost::signals2::signal<void (std::shared_ptr<CReserveScript>&)> ScriptForMining;\n     /**\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */"
      },
      {
        "sha": "8047e17aa826dab5f97848c2488a6ad273d17b3d",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -174,12 +174,12 @@ class VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\n     const Consensus::DeploymentPos id;\n \n protected:\n-    int64_t BeginTime(const Consensus::Params& params) const { return params.vDeployments[id].nStartTime; }\n-    int64_t EndTime(const Consensus::Params& params) const { return params.vDeployments[id].nTimeout; }\n-    int Period(const Consensus::Params& params) const { return params.nMinerConfirmationWindow; }\n-    int Threshold(const Consensus::Params& params) const { return params.nRuleChangeActivationThreshold; }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return params.vDeployments[id].nStartTime; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return params.vDeployments[id].nTimeout; }\n+    int Period(const Consensus::Params& params) const override { return params.nMinerConfirmationWindow; }\n+    int Threshold(const Consensus::Params& params) const override { return params.nRuleChangeActivationThreshold; }\n \n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override\n     {\n         return (((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) && (pindex->nVersion & Mask(params)) != 0);\n     }\n@@ -189,7 +189,7 @@ class VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\n     uint32_t Mask(const Consensus::Params& params) const { return ((uint32_t)1) << params.vDeployments[id].bit; }\n };\n \n-}\n+} // namespace\n \n ThresholdState VersionBitsState(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache)\n {"
      },
      {
        "sha": "6fa685628f1cb207bf634c4359708503f655bd29",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -274,7 +274,6 @@ bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) co\n         // Check for watch-only pubkeys\n         return CBasicKeyStore::GetPubKey(address, vchPubKeyOut);\n     }\n-    return false;\n }\n \n bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)"
      },
      {
        "sha": "1dc44e424f631f4cd419443a0b338fc68b9f9f47",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -157,8 +157,8 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool Lock();\n \n     virtual bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n-    bool HaveKey(const CKeyID &address) const\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool HaveKey(const CKeyID &address) const override\n     {\n         {\n             LOCK(cs_KeyStore);\n@@ -168,9 +168,9 @@ class CCryptoKeyStore : public CBasicKeyStore\n         }\n         return false;\n     }\n-    bool GetKey(const CKeyID &address, CKey& keyOut) const;\n-    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n-    void GetKeys(std::set<CKeyID> &setAddress) const\n+    bool GetKey(const CKeyID &address, CKey& keyOut) const override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    void GetKeys(std::set<CKeyID> &setAddress) const override\n     {\n         if (!IsCrypted())\n         {"
      },
      {
        "sha": "b4b5e8c255d55d743f08a096d4a62331bbfa43eb",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 19,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -148,7 +148,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         pwallet->UpdateTimeFirstKey(1);\n \n         if (fRescan) {\n-            pwallet->ScanForWalletTransactions(chainActive.Genesis(), true);\n+            pwallet->RescanFromTime(TIMESTAMP_MIN, true /* update */);\n         }\n     }\n \n@@ -278,7 +278,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n \n     if (fRescan)\n     {\n-        pwallet->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        pwallet->RescanFromTime(TIMESTAMP_MIN, true /* update */);\n         pwallet->ReacceptWalletTransactions();\n     }\n \n@@ -362,7 +362,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\") +\n             \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"removprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n+            + HelpExampleRpc(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n@@ -436,7 +436,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n \n     if (fRescan)\n     {\n-        pwallet->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        pwallet->RescanFromTime(TIMESTAMP_MIN, true /* update */);\n         pwallet->ReacceptWalletTransactions();\n     }\n \n@@ -536,11 +536,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n     file.close();\n     pwallet->ShowProgress(\"\", 100); // hide progress dialog in GUI\n     pwallet->UpdateTimeFirstKey(nTimeBegin);\n-\n-    CBlockIndex *pindex = chainActive.FindEarliestAtLeast(nTimeBegin - TIMESTAMP_WINDOW);\n-\n-    LogPrintf(\"Rescanning last %i blocks\\n\", pindex ? chainActive.Height() - pindex->nHeight + 1 : 0);\n-    pwallet->ScanForWalletTransactions(pindex);\n+    pwallet->RescanFromTime(nTimeBegin, false /* update */);\n     pwallet->MarkDirty();\n \n     if (!fGood)\n@@ -1049,7 +1045,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n             \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n             \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n-            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be treated as not incoming payments\\n\"\n             \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n             \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n             \"    }\\n\"\n@@ -1126,14 +1122,10 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     }\n \n     if (fRescan && fRunScan && requests.size()) {\n-        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(std::max<int64_t>(nLowestTimestamp - TIMESTAMP_WINDOW, 0)) : chainActive.Genesis();\n-        CBlockIndex* scanFailed = nullptr;\n-        if (pindex) {\n-            scanFailed = pwallet->ScanForWalletTransactions(pindex, true);\n-            pwallet->ReacceptWalletTransactions();\n-        }\n+        int64_t scannedTime = pwallet->RescanFromTime(nLowestTimestamp, true /* update */);\n+        pwallet->ReacceptWalletTransactions();\n \n-        if (scanFailed) {\n+        if (scannedTime > nLowestTimestamp) {\n             std::vector<UniValue> results = response.getValues();\n             response.clear();\n             response.setArray();\n@@ -1143,7 +1135,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                 // range, or if the import result already has an error set, let\n                 // the result stand unmodified. Otherwise replace the result\n                 // with an error message.\n-                if (GetImportTimestamp(request, now) - TIMESTAMP_WINDOW > scanFailed->GetBlockTimeMax() || results.at(i).exists(\"error\")) {\n+                if (scannedTime <= GetImportTimestamp(request, now) || results.at(i).exists(\"error\")) {\n                     response.push_back(results.at(i));\n                 } else {\n                     UniValue result = UniValue(UniValue::VOBJ);\n@@ -1159,7 +1151,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                                       \"caused by pruning or data corruption (see bitcoind log for details) and could \"\n                                       \"be dealt with by downloading and rescanning the relevant blocks (see -reindex \"\n                                       \"and -rescan options).\",\n-                                GetImportTimestamp(request, now), scanFailed->GetBlockTimeMax(), TIMESTAMP_WINDOW)));\n+                                GetImportTimestamp(request, now), scannedTime - TIMESTAMP_WINDOW - 1, TIMESTAMP_WINDOW)));\n                     response.push_back(std::move(result));\n                 }\n                 ++i;"
      },
      {
        "sha": "e0c7ab9f0f98686805fd07883c811576c53960a8",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 1,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,6 +15,7 @@\n #include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n+#include \"rpc/mining.h\"\n #include \"rpc/server.h\"\n #include \"script/sign.h\"\n #include \"timedata.h\"\n@@ -1064,7 +1065,6 @@ class Witnessifier : public boost::static_visitor<bool>\n     bool operator()(const CNoDestination &dest) const { return false; }\n \n     bool operator()(const CKeyID &keyID) {\n-        CPubKey pubkey;\n         if (pwallet) {\n             CScript basescript = GetScriptForDestination(keyID);\n             isminetype typ;\n@@ -2923,6 +2923,51 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue generate(const JSONRPCRequest& request)\n+{\n+    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"generate nblocks ( maxtries )\\n\"\n+            \"\\nMine up to nblocks blocks immediately (before the RPC call returns) to an address in the wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n+            \"2. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n+            \"\\nResult:\\n\"\n+            \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nGenerate 11 blocks\\n\"\n+            + HelpExampleCli(\"generate\", \"11\")\n+        );\n+    }\n+\n+    int num_generate = request.params[0].get_int();\n+    uint64_t max_tries = 1000000;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        max_tries = request.params[1].get_int();\n+    }\n+\n+    std::shared_ptr<CReserveScript> coinbase_script;\n+    pwallet->GetScriptForMining(coinbase_script);\n+\n+    // If the keypool is exhausted, no script is returned at all.  Catch this.\n+    if (!coinbase_script) {\n+        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n+    }\n+\n+    //throw an error if no script was provided\n+    if (coinbase_script->reserveScript.empty()) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"No coinbase script available\");\n+    }\n+\n+    return generateBlocks(coinbase_script, num_generate, max_tries, true);\n+}\n+\n extern UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n@@ -2986,6 +3031,8 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"walletpassphrasechange\",   &walletpassphrasechange,   true,   {\"oldpassphrase\",\"newpassphrase\"} },\n     { \"wallet\",             \"walletpassphrase\",         &walletpassphrase,         true,   {\"passphrase\",\"timeout\"} },\n     { \"wallet\",             \"removeprunedfunds\",        &removeprunedfunds,        true,   {\"txid\"} },\n+\n+    { \"generating\",         \"generate\",                 &generate,                 true,   {\"nblocks\",\"maxtries\"} },\n };\n \n void RegisterWalletRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "0d1a86dd244bd9d14afef42c2561d21c646a3af7",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 33,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -205,7 +205,6 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                                                             vchCryptedSecret,\n                                                             mapKeyMetadata[vchPubKey.GetID()]);\n     }\n-    return false;\n }\n \n bool CWallet::LoadKeyMetadata(const CTxDestination& keyID, const CKeyMetadata &meta)\n@@ -221,6 +220,10 @@ bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigne\n     return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n }\n \n+/**\n+ * Update wallet first key creation time. This should be called whenever keys\n+ * are added to the wallet, with the oldest key creation time.\n+ */\n void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n {\n     AssertLockHeld(cs_wallet);\n@@ -1468,6 +1471,34 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n }\n \n+/**\n+ * Scan active chain for relevant transactions after importing keys. This should\n+ * be called whenever new keys are added to the wallet, with the oldest key\n+ * creation time.\n+ *\n+ * @return Earliest timestamp that could be successfully scanned from. Timestamp\n+ * returned will be higher than startTime if relevant blocks could not be read.\n+ */\n+int64_t CWallet::RescanFromTime(int64_t startTime, bool update)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_wallet);\n+\n+    // Find starting block. May be null if nCreateTime is greater than the\n+    // highest blockchain timestamp, in which case there is nothing that needs\n+    // to be scanned.\n+    CBlockIndex* const startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n+    LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n+\n+    if (startBlock) {\n+        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, update);\n+        if (failedBlock) {\n+            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        }\n+    }\n+    return startTime;\n+}\n+\n /**\n  * Scan the block chain (starting in pindexStart) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n@@ -1489,11 +1520,6 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n         fAbortRescan = false;\n         fScanningWallet = true;\n \n-        // no need to read and scan block, if block was created before\n-        // our wallet birthday (as adjusted for block time variability)\n-        while (pindex && nTimeFirstKey && (pindex->GetBlockTime() < (nTimeFirstKey - TIMESTAMP_WINDOW)))\n-            pindex = chainActive.Next(pindex);\n-\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n         double dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n         double dProgressTip = GuessVerificationProgress(chainParams.TxData(), chainActive.Tip());\n@@ -2634,28 +2660,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n \n                     CTxOut newTxOut(nChange, scriptChange);\n \n-                    // We do not move dust-change to fees, because the sender would end up paying more than requested.\n-                    // This would be against the purpose of the all-inclusive feature.\n-                    // So instead we raise the change and deduct from the recipient.\n-                    if (nSubtractFeeFromAmount > 0 && IsDust(newTxOut, ::dustRelayFee))\n-                    {\n-                        CAmount nDust = GetDustThreshold(newTxOut, ::dustRelayFee) - newTxOut.nValue;\n-                        newTxOut.nValue += nDust; // raise change until no more dust\n-                        for (unsigned int i = 0; i < vecSend.size(); i++) // subtract from first recipient\n-                        {\n-                            if (vecSend[i].fSubtractFeeFromAmount)\n-                            {\n-                                txNew.vout[i].nValue -= nDust;\n-                                if (IsDust(txNew.vout[i], ::dustRelayFee))\n-                                {\n-                                    strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                                    return false;\n-                                }\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n                     if (IsDust(newTxOut, ::dustRelayFee))\n@@ -2709,8 +2713,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n \n                 nBytes = GetVirtualTransactionSize(txNew);\n \n-                CTransaction txNewConst(txNew);\n-\n                 // Remove scriptSigs to eliminate the fee calculation dummy signatures\n                 for (auto& vin : txNew.vin) {\n                     vin.scriptSig = CScript();\n@@ -3866,11 +3868,11 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     else if (IsArgSet(\"-usehd\")) {\n         bool useHD = GetBoolArg(\"-usehd\", DEFAULT_USE_HD_WALLET);\n         if (walletInstance->IsHDEnabled() && !useHD) {\n-            InitError(strprintf(_(\"Error loading %s: You can't disable HD on a already existing HD wallet\"), walletFile));\n+            InitError(strprintf(_(\"Error loading %s: You can't disable HD on an already existing HD wallet\"), walletFile));\n             return NULL;\n         }\n         if (!walletInstance->IsHDEnabled() && useHD) {\n-            InitError(strprintf(_(\"Error loading %s: You can't enable HD on a already existing non-HD wallet\"), walletFile));\n+            InitError(strprintf(_(\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"), walletFile));\n             return NULL;\n         }\n     }\n@@ -3890,7 +3892,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n     {\n         //We can't rescan beyond non-pruned blocks, stop and throw an error\n-        //this might happen if a user uses a old wallet within a pruned node\n+        //this might happen if a user uses an old wallet within a pruned node\n         // or if he ran -disablewallet for a longer time, then decided to re-enable\n         if (fPruneMode)\n         {\n@@ -3906,6 +3908,13 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n \n         uiInterface.InitMessage(_(\"Rescanning...\"));\n         LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n+\n+        // No need to read and scan block if block was created before\n+        // our wallet birthday (as adjusted for block time variability)\n+        while (pindexRescan && walletInstance->nTimeFirstKey && (pindexRescan->GetBlockTime() < (walletInstance->nTimeFirstKey - TIMESTAMP_WINDOW))) {\n+            pindexRescan = chainActive.Next(pindexRescan);\n+        }\n+\n         nStart = GetTimeMillis();\n         walletInstance->ScanForWalletTransactions(pindexRescan, true);\n         LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);"
      },
      {
        "sha": "4f558adc772531bbb290fdbe331db8e9b6f2e721",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -68,6 +68,8 @@ static const bool DEFAULT_USE_HD_WALLET = true;\n \n extern const char * DEFAULT_WALLET_DAT;\n \n+static const int64_t TIMESTAMP_MIN = 0;\n+\n class CBlockIndex;\n class CCoinControl;\n class COutput;\n@@ -77,7 +79,7 @@ class CScheduler;\n class CTxMemPool;\n class CBlockPolicyEstimator;\n class CWalletTx;\n-class FeeCalculation;\n+struct FeeCalculation;\n \n /** (client) version numbers for particular wallet features */\n enum WalletFeature\n@@ -919,6 +921,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override;\n     bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate);\n+    int64_t RescanFromTime(int64_t startTime, bool update);\n     CBlockIndex* ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override;\n@@ -1022,7 +1025,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         }\n     }\n \n-    void GetScriptForMining(std::shared_ptr<CReserveScript> &script) override;\n+    void GetScriptForMining(std::shared_ptr<CReserveScript> &script);\n     \n     unsigned int GetKeyPoolSize()\n     {\n@@ -1150,7 +1153,7 @@ class CReserveKey : public CReserveScript\n     void ReturnKey();\n     bool GetReservedKey(CPubKey &pubkey, bool internal = false);\n     void KeepKey();\n-    void KeepScript() { KeepKey(); }\n+    void KeepScript() override { KeepKey(); }\n };\n \n "
      },
      {
        "sha": "8321719b560b61a3724c42f750ce26d5355b8d1d",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -76,21 +76,15 @@ bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n                                 const std::vector<unsigned char>& vchCryptedSecret,\n                                 const CKeyMetadata &keyMeta)\n {\n-    const bool fEraseUnencryptedKey = true;\n-\n     if (!WriteIC(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta)) {\n         return false;\n     }\n \n     if (!WriteIC(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false)) {\n         return false;\n     }\n-    if (fEraseUnencryptedKey)\n-    {\n-        EraseIC(std::make_pair(std::string(\"key\"), vchPubKey));\n-        EraseIC(std::make_pair(std::string(\"wkey\"), vchPubKey));\n-    }\n-\n+    EraseIC(std::make_pair(std::string(\"key\"), vchPubKey));\n+    EraseIC(std::make_pair(std::string(\"wkey\"), vchPubKey));\n     return true;\n }\n "
      },
      {
        "sha": "1790fe56982a1a34c0521ce9c70bf910e0da765f",
        "filename": "src/zmq/zmqpublishnotifier.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/src/zmq/zmqpublishnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/src/zmq/zmqpublishnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.h?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -24,32 +24,32 @@ class CZMQAbstractPublishNotifier : public CZMQAbstractNotifier\n     */\n     bool SendMessage(const char *command, const void* data, size_t size);\n \n-    bool Initialize(void *pcontext);\n-    void Shutdown();\n+    bool Initialize(void *pcontext) override;\n+    void Shutdown() override;\n };\n \n class CZMQPublishHashBlockNotifier : public CZMQAbstractPublishNotifier\n {\n public:\n-    bool NotifyBlock(const CBlockIndex *pindex);\n+    bool NotifyBlock(const CBlockIndex *pindex) override;\n };\n \n class CZMQPublishHashTransactionNotifier : public CZMQAbstractPublishNotifier\n {\n public:\n-    bool NotifyTransaction(const CTransaction &transaction);\n+    bool NotifyTransaction(const CTransaction &transaction) override;\n };\n \n class CZMQPublishRawBlockNotifier : public CZMQAbstractPublishNotifier\n {\n public:\n-    bool NotifyBlock(const CBlockIndex *pindex);\n+    bool NotifyBlock(const CBlockIndex *pindex) override;\n };\n \n class CZMQPublishRawTransactionNotifier : public CZMQAbstractPublishNotifier\n {\n public:\n-    bool NotifyTransaction(const CTransaction &transaction);\n+    bool NotifyTransaction(const CTransaction &transaction) override;\n };\n \n #endif // BITCOIN_ZMQ_ZMQPUBLISHNOTIFIER_H"
      },
      {
        "sha": "15f6df790f9ba6142baf85319dcec6cc52d2119d",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 111,
        "deletions": 43,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,84 +15,152 @@ The util tests are run as part of `make check` target. The functional\n tests are run by the travis continuous build process whenever a pull\n request is opened. Both sets of tests can also be run locally.\n \n-Functional Test dependencies\n-============================\n+# Running tests locally\n+\n+Build for your system first. Be sure to enable wallet, utils and daemon when you configure. Tests will not run otherwise.\n+\n+### Functional tests\n+\n+#### Dependencies\n+\n The ZMQ functional test requires a python ZMQ library. To install it:\n \n - on Unix, run `sudo apt-get install python3-zmq`\n - on mac OS, run `pip3 install pyzmq`\n \n-Running tests locally\n-=====================\n+#### Running the tests\n \n-Build for your system first. Be sure to enable wallet, utils and daemon when you configure. Tests will not run otherwise.\n+Individual tests can be run by directly calling the test script, eg:\n \n-Functional tests\n-----------------\n+```\n+test/functional/replace-by-fee.py\n+```\n \n-You can run any single test by calling\n+or can be run through the test_runner harness, eg:\n \n-    test/functional/test_runner.py <testname>\n+```\n+test/functional/test_runner.py replace-by-fee.py\n+```\n \n-Or you can run any combination (incl. duplicates) of tests by calling\n+You can run any combination (incl. duplicates) of tests by calling:\n \n-    test/functional/test_runner.py <testname1> <testname2> <testname3> ...\n+```\n+test/functional/test_runner.py <testname1> <testname2> <testname3> ...\n+```\n \n-Run the regression test suite with\n+Run the regression test suite with:\n \n-    test/functional/test_runner.py\n+```\n+test/functional/test_runner.py\n+```\n \n Run all possible tests with\n \n-    test/functional/test_runner.py --extended\n+```\n+test/functional/test_runner.py --extended\n+```\n+\n+By default, up to 4 tests will be run in parallel by test_runner. To specify\n+how many jobs to run, append `--jobs=n`\n \n-By default, tests will be run in parallel. To specify how many jobs to run,\n-append `--jobs=n` (default n=4).\n+The individual tests and the test_runner harness have many command-line\n+options. Run `test_runner.py -h` to see them all.\n \n-If you want to create a basic coverage report for the RPC test suite, append `--coverage`.\n+#### Troubleshooting and debugging test failures\n \n-Possible options, which apply to each individual test run:\n+##### Resource contention\n \n+The P2P and RPC ports used by the bitcoind nodes-under-test are chosen to make\n+conflicts with other processes unlikely. However, if there is another bitcoind\n+process running on the system (perhaps from a previous test which hasn't successfully\n+killed all its bitcoind nodes), then there may be a port conflict which will\n+cause the test to fail. It is recommended that you run the tests on a system\n+where no other bitcoind processes are running.\n+\n+On linux, the test_framework will warn if there is another\n+bitcoind process running when the tests are started.\n+\n+If there are zombie bitcoind processes after test failure, you can kill them\n+by running the following commands. **Note that these commands will kill all\n+bitcoind processes running on the system, so should not be used if any non-test\n+bitcoind processes are being run.**\n+\n+```bash\n+killall bitcoind\n ```\n-  -h, --help            show this help message and exit\n-  --nocleanup           Leave bitcoinds and test.* datadir on exit or error\n-  --noshutdown          Don't stop bitcoinds after the test execution\n-  --srcdir=SRCDIR       Source directory containing bitcoind/bitcoin-cli\n-                        (default: ../../src)\n-  --tmpdir=TMPDIR       Root directory for datadirs\n-  --tracerpc            Print out all RPC calls as they are made\n-  --coveragedir=COVERAGEDIR\n-                        Write tested RPC commands into this directory\n-```\n \n-If you set the environment variable `PYTHON_DEBUG=1` you will get some debug\n-output (example: `PYTHON_DEBUG=1 test/functional/test_runner.py wallet`).\n+or\n+\n+```bash\n+pkill -9 bitcoind\n+```\n \n-A 200-block -regtest blockchain and wallets for four nodes\n-is created the first time a regression test is run and\n-is stored in the cache/ directory. Each node has 25 mature\n-blocks (25*50=1250 BTC) in its wallet.\n \n-After the first run, the cache/ blockchain and wallets are\n-copied into a temporary directory and used as the initial\n-test state.\n+##### Data directory cache\n \n-If you get into a bad state, you should be able\n-to recover with:\n+A pre-mined blockchain with 200 blocks is generated the first time a\n+functional test is run and is stored in test/cache. This speeds up\n+test startup times since new blockchains don't need to be generated for\n+each test. However, the cache may get into a bad state, in which case\n+tests will fail. If this happens, remove the cache directory (and make\n+sure bitcoind processes are stopped as above):\n \n ```bash\n rm -rf cache\n killall bitcoind\n ```\n \n-Util tests\n-----------\n+##### Test logging\n+\n+The tests contain logging at different levels (debug, info, warning, etc). By\n+default:\n+\n+- when run through the test_runner harness, *all* logs are written to\n+  `test_framework.log` and no logs are output to the console.\n+- when run directly, *all* logs are written to `test_framework.log` and INFO\n+  level and above are output to the console.\n+- when run on Travis, no logs are output to the console. However, if a test\n+  fails, the `test_framework.log` and bitcoind `debug.log`s will all be dumped\n+  to the console to help troubleshooting.\n+\n+To change the level of logs output to the console, use the `-l` command line\n+argument.\n+\n+`test_framework.log` and bitcoind `debug.log`s can be combined into a single\n+aggregate log by running the `combine_logs.py` script. The output can be plain\n+text, colorized text or html. For example:\n+\n+```\n+combine_logs.py -c <test data directory> | less -r\n+```\n+\n+will pipe the colorized logs from the test into less.\n+\n+Use `--tracerpc` to trace out all the RPC calls and responses to the console. For\n+some tests (eg any that use `submitblock` to submit a full block over RPC),\n+this can result in a lot of screen output.\n+\n+By default, the test data directory will be deleted after a successful run.\n+Use `--nocleanup` to leave the test data directory intact. The test data\n+directory is never deleted after a failed test.\n+\n+##### Attaching a debugger\n+\n+A python debugger can be attached to tests at any point. Just add the line:\n+\n+```py\n+import pdb; pdb.set_trace()\n+```\n+\n+anywhere in the test. You will then be able to inspect variables, as well as\n+call methods that interact with the bitcoind nodes-under-test.\n+\n+### Util tests\n \n Util tests can be run locally by running `test/util/bitcoin-util-test.py`. \n Use the `-v` option for verbose output.\n \n-Writing functional tests\n-========================\n+# Writing functional tests\n \n You are encouraged to write functional tests for new or existing features.\n Further information about the functional test framework and individual "
      },
      {
        "sha": "96fe0beccea9c0b50bcdfb2e8064e72901878cd3",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 110,
        "deletions": 64,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -1,108 +1,154 @@\n-Regression tests\n-================\n+# Functional tests\n \n-### [test_framework/authproxy.py](test_framework/authproxy.py)\n-Taken from the [python-bitcoinrpc repository](https://github.com/jgarzik/python-bitcoinrpc).\n+### Writing Functional Tests\n \n-### [test_framework/test_framework.py](test_framework/test_framework.py)\n-Base class for new regression tests.\n+#### Example test\n \n-### [test_framework/util.py](test_framework/util.py)\n-Generally useful functions.\n+The [example_test.py](example_test.py) is a heavily commented example of a test case that uses both\n+the RPC and P2P interfaces. If you are writing your first test, copy that file\n+and modify to fit your needs.\n \n-### [test_framework/mininode.py](test_framework/mininode.py)\n-Basic code to support p2p connectivity to a bitcoind.\n+#### Coverage\n \n-### [test_framework/comptool.py](test_framework/comptool.py)\n-Framework for comparison-tool style, p2p tests.\n+Running `test_runner.py` with the `--coverage` argument tracks which RPCs are\n+called by the tests and prints a report of uncovered RPCs in the summary. This\n+can be used (along with the `--extended` argument) to find out which RPCs we\n+don't have test cases for.\n \n-### [test_framework/script.py](test_framework/script.py)\n-Utilities for manipulating transaction scripts (originally from python-bitcoinlib)\n+#### Style guidelines\n \n-### [test_framework/blockstore.py](test_framework/blockstore.py)\n-Implements disk-backed block and tx storage.\n+- Where possible, try to adhere to [PEP-8 guidelines]([https://www.python.org/dev/peps/pep-0008/)\n+- Use a python linter like flake8 before submitting PRs to catch common style\n+  nits (eg trailing whitespace, unused imports, etc)\n+- Avoid wildcard imports where possible\n+- Use a module-level docstring to describe what the test is testing, and how it\n+  is testing it.\n+- When subclassing the BitcoinTestFramwork, place overrides for the\n+  `__init__()`, and `setup_xxxx()` methods at the top of the subclass, then\n+  locally-defined helper methods, then the `run_test()` method.\n \n-### [test_framework/key.py](test_framework/key.py)\n-Wrapper around OpenSSL EC_Key (originally from python-bitcoinlib)\n+#### General test-writing advice\n \n-### [test_framework/bignum.py](test_framework/bignum.py)\n-Helpers for script.py\n+- Set `self.num_nodes` to the minimum number of nodes necessary for the test.\n+  Having additional unrequired nodes adds to the execution time of the test as\n+  well as memory/CPU/disk requirements (which is important when running tests in\n+  parallel or on Travis).\n+- Avoid stop-starting the nodes multiple times during the test if possible. A\n+  stop-start takes several seconds, so doing it several times blows up the\n+  runtime of the test.\n+- Set the `self.setup_clean_chain` variable in `__init__()` to control whether\n+  or not to use the cached data directories. The cached data directories\n+  contain a 200-block pre-mined blockchain and wallets for four nodes. Each node\n+  has 25 mature blocks (25x50=1250 BTC) in its wallet.\n+- When calling RPCs with lots of arguments, consider using named keyword\n+  arguments instead of positional arguments to make the intent of the call\n+  clear to readers.\n \n-### [test_framework/blocktools.py](test_framework/blocktools.py)\n-Helper functions for creating blocks and transactions.\n+#### RPC and P2P definitions\n \n-P2P test design notes\n----------------------\n+Test writers may find it helpful to refer to the definitions for the RPC and\n+P2P messages. These can be found in the following source files:\n \n-## Mininode\n+- `/src/rpc/*` for RPCs\n+- `/src/wallet/rpc*` for wallet RPCs\n+- `ProcessMessage()` in `/src/net_processing.cpp` for parsing P2P messages\n \n-* ```mininode.py``` contains all the definitions for objects that pass\n-over the network (```CBlock```, ```CTransaction```, etc, along with the network-level\n-wrappers for them, ```msg_block```, ```msg_tx```, etc).\n+#### Using the P2P interface\n \n-* P2P tests have two threads.  One thread handles all network communication\n+- `mininode.py` contains all the definitions for objects that pass\n+over the network (`CBlock`, `CTransaction`, etc, along with the network-level\n+wrappers for them, `msg_block`, `msg_tx`, etc).\n+\n+- P2P tests have two threads. One thread handles all network communication\n with the bitcoind(s) being tested (using python's asyncore package); the other\n implements the test logic.\n \n-* ```NodeConn``` is the class used to connect to a bitcoind.  If you implement\n-a callback class that derives from ```NodeConnCB``` and pass that to the\n-```NodeConn``` object, your code will receive the appropriate callbacks when\n+- `NodeConn` is the class used to connect to a bitcoind.  If you implement\n+a callback class that derives from `NodeConnCB` and pass that to the\n+`NodeConn` object, your code will receive the appropriate callbacks when\n events of interest arrive.\n \n-* You can pass the same handler to multiple ```NodeConn```'s if you like, or pass\n-different ones to each -- whatever makes the most sense for your test.\n-\n-* Call ```NetworkThread.start()``` after all ```NodeConn``` objects are created to\n+- Call `NetworkThread.start()` after all `NodeConn` objects are created to\n start the networking thread.  (Continue with the test logic in your existing\n thread.)\n \n-* RPC calls are available in p2p tests.\n+- Can be used to write tests where specific P2P protocol behavior is tested.\n+Examples tests are `p2p-accept-block.py`, `p2p-compactblocks.py`.\n \n-* Can be used to write free-form tests, where specific p2p-protocol behavior\n-is tested.  Examples: ```p2p-accept-block.py```, ```p2p-compactblocks.py```.\n+#### Comptool\n \n-## Comptool\n+- Comptool is a Testing framework for writing tests that compare the block/tx acceptance\n+behavior of a bitcoind against 1 or more other bitcoind instances. It should not be used\n+to write static tests with known outcomes, since that type of test is easier to write and\n+maintain using the standard BitcoinTestFramework.\n \n-* Testing framework for writing tests that compare the block/tx acceptance\n-behavior of a bitcoind against 1 or more other bitcoind instances, or against\n-known outcomes, or both.\n-\n-* Set the ```num_nodes``` variable (defined in ```ComparisonTestFramework```) to start up\n-1 or more nodes.  If using 1 node, then ```--testbinary``` can be used as a command line\n+- Set the `num_nodes` variable (defined in `ComparisonTestFramework`) to start up\n+1 or more nodes.  If using 1 node, then `--testbinary` can be used as a command line\n option to change the bitcoind binary used by the test.  If using 2 or more nodes,\n-then ```--refbinary``` can be optionally used to change the bitcoind that will be used\n+then `--refbinary` can be optionally used to change the bitcoind that will be used\n on nodes 2 and up.\n \n-* Implement a (generator) function called ```get_tests()``` which yields ```TestInstance```s.\n-Each ```TestInstance``` consists of:\n-  - a list of ```[object, outcome, hash]``` entries\n-    * ```object``` is a ```CBlock```, ```CTransaction```, or\n-    ```CBlockHeader```.  ```CBlock```'s and ```CTransaction```'s are tested for\n-    acceptance.  ```CBlockHeader```s can be used so that the test runner can deliver\n+- Implement a (generator) function called `get_tests()` which yields `TestInstance`s.\n+Each `TestInstance` consists of:\n+  - a list of `[object, outcome, hash]` entries\n+    * `object` is a `CBlock`, `CTransaction`, or\n+    `CBlockHeader`.  `CBlock`'s and `CTransaction`'s are tested for\n+    acceptance.  `CBlockHeader`s can be used so that the test runner can deliver\n     complete headers-chains when requested from the bitcoind, to allow writing\n     tests where blocks can be delivered out of order but still processed by\n     headers-first bitcoind's.\n-    * ```outcome``` is ```True```, ```False```, or ```None```.  If ```True```\n-    or ```False```, the tip is compared with the expected tip -- either the\n+    * `outcome` is `True`, `False`, or `None`.  If `True`\n+    or `False`, the tip is compared with the expected tip -- either the\n     block passed in, or the hash specified as the optional 3rd entry.  If\n-    ```None``` is specified, then the test will compare all the bitcoind's\n+    `None` is specified, then the test will compare all the bitcoind's\n     being tested to see if they all agree on what the best tip is.\n-    * ```hash``` is the block hash of the tip to compare against. Optional to\n+    * `hash` is the block hash of the tip to compare against. Optional to\n     specify; if left out then the hash of the block passed in will be used as\n     the expected tip.  This allows for specifying an expected tip while testing\n     the handling of either invalid blocks or blocks delivered out of order,\n     which complete a longer chain.\n-  - ```sync_every_block```: ```True/False```.  If ```False```, then all blocks\n+  - `sync_every_block`: `True/False`.  If `False`, then all blocks\n     are inv'ed together, and the test runner waits until the node receives the\n     last one, and tests only the last block for tip acceptance using the\n-    outcome and specified tip.  If ```True```, then each block is tested in\n+    outcome and specified tip.  If `True`, then each block is tested in\n     sequence and synced (this is slower when processing many blocks).\n-  - ```sync_every_transaction```: ```True/False```.  Analogous to\n-    ```sync_every_block```, except if the outcome on the last tx is \"None\",\n+  - `sync_every_transaction`: `True/False`.  Analogous to\n+    `sync_every_block`, except if the outcome on the last tx is \"None\",\n     then the contents of the entire mempool are compared across all bitcoind\n-    connections.  If ```True``` or ```False```, then only the last tx's\n+    connections.  If `True` or `False`, then only the last tx's\n     acceptance is tested against the given outcome.\n \n-* For examples of tests written in this framework, see\n-  ```invalidblockrequest.py``` and ```p2p-fullblocktest.py```.\n+- For examples of tests written in this framework, see\n+  `invalidblockrequest.py` and `p2p-fullblocktest.py`.\n+\n+### test-framework modules\n+\n+#### [test_framework/authproxy.py](test_framework/authproxy.py)\n+Taken from the [python-bitcoinrpc repository](https://github.com/jgarzik/python-bitcoinrpc).\n+\n+#### [test_framework/test_framework.py](test_framework/test_framework.py)\n+Base class for functional tests.\n \n+#### [test_framework/util.py](test_framework/util.py)\n+Generally useful functions.\n+\n+#### [test_framework/mininode.py](test_framework/mininode.py)\n+Basic code to support P2P connectivity to a bitcoind.\n+\n+#### [test_framework/comptool.py](test_framework/comptool.py)\n+Framework for comparison-tool style, P2P tests.\n+\n+#### [test_framework/script.py](test_framework/script.py)\n+Utilities for manipulating transaction scripts (originally from python-bitcoinlib)\n+\n+#### [test_framework/blockstore.py](test_framework/blockstore.py)\n+Implements disk-backed block and tx storage.\n+\n+#### [test_framework/key.py](test_framework/key.py)\n+Wrapper around OpenSSL EC_Key (originally from python-bitcoinlib)\n+\n+#### [test_framework/bignum.py](test_framework/bignum.py)\n+Helpers for script.py\n+\n+#### [test_framework/blocktools.py](test_framework/blocktools.py)\n+Helper functions for creating blocks and transactions."
      },
      {
        "sha": "f00232c9ffe0398f4456b4881c48144873f5d336",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -15,16 +15,17 @@\n test that enforcement has not triggered (which triggers ACTIVE)\n test that enforcement has triggered\n \"\"\"\n+from io import BytesIO\n+import shutil\n+import time\n+import itertools\n \n from test_framework.test_framework import ComparisonTestFramework\n from test_framework.util import *\n from test_framework.mininode import CTransaction, NetworkThread\n from test_framework.blocktools import create_coinbase, create_block\n from test_framework.comptool import TestInstance, TestManager\n from test_framework.script import CScript, OP_1NEGATE, OP_CHECKSEQUENCEVERIFY, OP_DROP\n-from io import BytesIO\n-import time\n-import itertools\n \n class BIP9SoftForksTest(ComparisonTestFramework):\n "
      },
      {
        "sha": "a7034e6bcdbab5f2d743cfaab9cbfefb9a570840",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -18,10 +18,13 @@\n \"\"\"\n \n from decimal import Decimal\n+import http.client\n+import subprocess\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import (BitcoinTestFramework, BITCOIND_PROC_WAIT_TIMEOUT)\n from test_framework.util import (\n     assert_equal,\n+    assert_raises,\n     assert_raises_jsonrpc,\n     assert_is_hex_string,\n     assert_is_hash_string,\n@@ -34,14 +37,16 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = False\n         self.num_nodes = 1\n+        self.extra_args = [['-stopatheight=207']]\n \n     def run_test(self):\n         self._test_getchaintxstats()\n         self._test_gettxoutsetinfo()\n         self._test_getblockheader()\n         self._test_getdifficulty()\n         self._test_getnetworkhashps()\n-        self.nodes[0].verifychain(4, 0)\n+        self._test_stopatheight()\n+        assert self.nodes[0].verifychain(4, 0)\n \n     def _test_getchaintxstats(self):\n         chaintxstats = self.nodes[0].getchaintxstats(1)\n@@ -129,5 +134,21 @@ def _test_getnetworkhashps(self):\n         # This should be 2 hashes every 10 minutes or 1/300\n         assert abs(hashes_per_second * 300 - 1) < 0.0001\n \n+    def _test_stopatheight(self):\n+        assert_equal(self.nodes[0].getblockcount(), 200)\n+        self.nodes[0].generate(6)\n+        assert_equal(self.nodes[0].getblockcount(), 206)\n+        self.log.debug('Node should not stop at this height')\n+        assert_raises(subprocess.TimeoutExpired, lambda: self.bitcoind_processes[0].wait(timeout=3))\n+        try:\n+            self.nodes[0].generate(1)\n+        except (ConnectionError, http.client.BadStatusLine):\n+            pass  # The node already shut down before response\n+        self.log.debug('Node should stop at this height...')\n+        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir)\n+        assert_equal(self.nodes[0].getblockcount(), 207)\n+\n+\n if __name__ == '__main__':\n     BlockchainTest().main()"
      },
      {
        "sha": "9237f0924012b1b1952037d4aab9475f16f45cf3",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -10,7 +10,7 @@\n This module consists of around a dozen individual test cases implemented in the\n top-level functions named as test_<test_case_description>. The test functions\n can be disabled or reordered if needed for debugging. If new test cases are\n-added in the the future, they should try to follow the same convention and not\n+added in the future, they should try to follow the same convention and not\n make assumptions about execution order.\n \"\"\"\n \n@@ -42,7 +42,7 @@ def setup_network(self, split=False):\n \n         # Encrypt wallet for test_locked_wallet_fails test\n         self.nodes[1].encryptwallet(WALLET_PASSPHRASE)\n-        bitcoind_processes[1].wait()\n+        self.bitcoind_processes[1].wait()\n         self.nodes[1] = self.start_node(1, self.options.tmpdir, extra_args[1])\n         self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n "
      },
      {
        "sha": "8339305f5e45250d40540c8aebbfbec3a2c3dccf",
        "filename": "test/functional/dbcrash.py",
        "status": "added",
        "additions": 281,
        "deletions": 0,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/dbcrash.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -0,0 +1,281 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test recovery from a crash during chainstate writing.\n+\n+- 4 nodes\n+  * node0, node1, and node2 will have different dbcrash ratios, and different\n+    dbcache sizes\n+  * node3 will be a regular node, with no crashing.\n+  * The nodes will not connect to each other.\n+\n+- use default test framework starting chain. initialize starting_tip_height to\n+  tip height.\n+\n+- Main loop:\n+  * generate lots of transactions on node3, enough to fill up a block.\n+  * uniformly randomly pick a tip height from starting_tip_height to\n+    tip_height; with probability 1/(height_difference+4), invalidate this block.\n+  * mine enough blocks to overtake tip_height at start of loop.\n+  * for each node in [node0,node1,node2]:\n+     - for each mined block:\n+       * submit block to node\n+       * if node crashed on/after submitting:\n+         - restart until recovery succeeds\n+         - check that utxo matches node3 using gettxoutsetinfo\"\"\"\n+\n+import errno\n+import http.client\n+import random\n+import sys\n+import time\n+\n+from test_framework.mininode import *\n+from test_framework.script import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+HTTP_DISCONNECT_ERRORS = [http.client.CannotSendRequest]\n+try:\n+    HTTP_DISCONNECT_ERRORS.append(http.client.RemoteDisconnected)\n+except AttributeError:\n+    pass\n+\n+class ChainstateWriteCrashTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = False\n+\n+        # Set -maxmempool=0 to turn off mempool memory sharing with dbcache\n+        # Set -rpcservertimeout=900 to reduce socket disconnects in this\n+        # long-running test\n+        self.base_args = [\"-limitdescendantsize=0\", \"-maxmempool=0\", \"-rpcservertimeout=900\", \"-dbbatchsize=200000\"]\n+\n+        # Set different crash ratios and cache sizes.  Note that not all of\n+        # -dbcache goes to pcoinsTip.\n+        self.node0_args = [\"-dbcrashratio=8\", \"-dbcache=4\"] + self.base_args\n+        self.node1_args = [\"-dbcrashratio=16\", \"-dbcache=8\"] + self.base_args\n+        self.node2_args = [\"-dbcrashratio=24\", \"-dbcache=16\"] + self.base_args\n+\n+        # Node3 is a normal node with default args, except will mine full blocks\n+        self.node3_args = [\"-blockmaxweight=4000000\"]\n+        self.extra_args = [self.node0_args, self.node1_args, self.node2_args, self.node3_args]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+        # Leave them unconnected, we'll use submitblock directly in this test\n+\n+    def restart_node(self, node_index, expected_tip):\n+        \"\"\"Start up a given node id, wait for the tip to reach the given block hash, and calculate the utxo hash.\n+\n+        Exceptions on startup should indicate node crash (due to -dbcrashratio), in which case we try again. Give up\n+        after 60 seconds. Returns the utxo hash of the given node.\"\"\"\n+\n+        time_start = time.time()\n+        while time.time() - time_start < 60:\n+            try:\n+                # Any of these RPC calls could throw due to node crash\n+                self.nodes[node_index] = self.start_node(node_index, self.options.tmpdir, self.extra_args[node_index])\n+                self.nodes[node_index].waitforblock(expected_tip)\n+                utxo_hash = self.nodes[node_index].gettxoutsetinfo()['hash_serialized_2']\n+                return utxo_hash\n+            except:\n+                # An exception here should mean the node is about to crash.\n+                # If bitcoind exits, then try again.  wait_for_node_exit()\n+                # should raise an exception if bitcoind doesn't exit.\n+                self.wait_for_node_exit(node_index, timeout=10)\n+            self.crashed_on_restart += 1\n+            time.sleep(1)\n+\n+        # If we got here, bitcoind isn't coming back up on restart.  Could be a\n+        # bug in bitcoind, or we've gotten unlucky with our dbcrash ratio --\n+        # perhaps we generated a test case that blew up our cache?\n+        # TODO: If this happens a lot, we should try to restart without -dbcrashratio\n+        # and make sure that recovery happens.\n+        raise AssertionError(\"Unable to successfully restart node %d in allotted time\", node_index)\n+\n+    def submit_block_catch_error(self, node_index, block):\n+        \"\"\"Try submitting a block to the given node.\n+\n+        Catch any exceptions that indicate the node has crashed.\n+        Returns true if the block was submitted successfully; false otherwise.\"\"\"\n+\n+        try:\n+            self.nodes[node_index].submitblock(block)\n+            return True\n+        except http.client.BadStatusLine as e:\n+            # Prior to 3.5 BadStatusLine('') was raised for a remote disconnect error.\n+            if sys.version_info[0] == 3 and sys.version_info[1] < 5 and e.line == \"''\":\n+                self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n+                return False\n+            else:\n+                raise\n+        except tuple(HTTP_DISCONNECT_ERRORS) as e:\n+            self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n+            return False\n+        except OSError as e:\n+            self.log.debug(\"node %d submitblock raised OSError exception: errno=%s\", node_index, e.errno)\n+            if e.errno in [errno.EPIPE, errno.ECONNREFUSED, errno.ECONNRESET]:\n+                # The node has likely crashed\n+                return False\n+            else:\n+                # Unexpected exception, raise\n+                raise\n+\n+    def sync_node3blocks(self, block_hashes):\n+        \"\"\"Use submitblock to sync node3's chain with the other nodes\n+\n+        If submitblock fails, restart the node and get the new utxo hash.\n+        If any nodes crash while updating, we'll compare utxo hashes to\n+        ensure recovery was successful.\"\"\"\n+\n+        node3_utxo_hash = self.nodes[3].gettxoutsetinfo()['hash_serialized_2']\n+\n+        # Retrieve all the blocks from node3\n+        blocks = []\n+        for block_hash in block_hashes:\n+            blocks.append([block_hash, self.nodes[3].getblock(block_hash, 0)])\n+\n+        # Deliver each block to each other node\n+        for i in range(3):\n+            nodei_utxo_hash = None\n+            self.log.debug(\"Syncing blocks to node %d\", i)\n+            for (block_hash, block) in blocks:\n+                # Get the block from node3, and submit to node_i\n+                self.log.debug(\"submitting block %s\", block_hash)\n+                if not self.submit_block_catch_error(i, block):\n+                    # TODO: more carefully check that the crash is due to -dbcrashratio\n+                    # (change the exit code perhaps, and check that here?)\n+                    self.wait_for_node_exit(i, timeout=30)\n+                    self.log.debug(\"Restarting node %d after block hash %s\", i, block_hash)\n+                    nodei_utxo_hash = self.restart_node(i, block_hash)\n+                    assert nodei_utxo_hash is not None\n+                    self.restart_counts[i] += 1\n+                else:\n+                    # Clear it out after successful submitblock calls -- the cached\n+                    # utxo hash will no longer be correct\n+                    nodei_utxo_hash = None\n+\n+            # Check that the utxo hash matches node3's utxo set\n+            # NOTE: we only check the utxo set if we had to restart the node\n+            # after the last block submitted:\n+            # - checking the utxo hash causes a cache flush, which we don't\n+            # want to do every time; so\n+            # - we only update the utxo cache after a node restart, since flushing\n+            # the cache is a no-op at that point\n+            if nodei_utxo_hash is not None:\n+                self.log.debug(\"Checking txoutsetinfo matches for node %d\", i)\n+                assert_equal(nodei_utxo_hash, node3_utxo_hash)\n+\n+    def verify_utxo_hash(self):\n+        \"\"\"Verify that the utxo hash of each node matches node3.\n+\n+        Restart any nodes that crash while querying.\"\"\"\n+        node3_utxo_hash = self.nodes[3].gettxoutsetinfo()['hash_serialized_2']\n+        self.log.info(\"Verifying utxo hash matches for all nodes\")\n+\n+        for i in range(3):\n+            try:\n+                nodei_utxo_hash = self.nodes[i].gettxoutsetinfo()['hash_serialized_2']\n+            except OSError:\n+                # probably a crash on db flushing\n+                nodei_utxo_hash = self.restart_node(i, self.nodes[3].getbestblockhash())\n+            assert_equal(nodei_utxo_hash, node3_utxo_hash)\n+\n+    def generate_small_transactions(self, node, count, utxo_list):\n+        FEE = 1000  # TODO: replace this with node relay fee based calculation\n+        num_transactions = 0\n+        random.shuffle(utxo_list)\n+        while len(utxo_list) >= 2 and num_transactions < count:\n+            tx = CTransaction()\n+            input_amount = 0\n+            for i in range(2):\n+                utxo = utxo_list.pop()\n+                tx.vin.append(CTxIn(COutPoint(int(utxo['txid'], 16), utxo['vout'])))\n+                input_amount += int(utxo['amount'] * COIN)\n+            output_amount = (input_amount - FEE) // 3\n+\n+            if output_amount <= 0:\n+                # Sanity check -- if we chose inputs that are too small, skip\n+                continue\n+\n+            for i in range(3):\n+                tx.vout.append(CTxOut(output_amount, hex_str_to_bytes(utxo['scriptPubKey'])))\n+\n+            # Sign and send the transaction to get into the mempool\n+            tx_signed_hex = node.signrawtransaction(ToHex(tx))['hex']\n+            node.sendrawtransaction(tx_signed_hex)\n+            num_transactions += 1\n+\n+    def run_test(self):\n+        # Track test coverage statistics\n+        self.restart_counts = [0, 0, 0]  # Track the restarts for nodes 0-2\n+        self.crashed_on_restart = 0      # Track count of crashes during recovery\n+\n+        # Start by creating a lot of utxos on node3\n+        initial_height = self.nodes[3].getblockcount()\n+        utxo_list = create_confirmed_utxos(self.nodes[3].getnetworkinfo()['relayfee'], self.nodes[3], 5000)\n+        self.log.info(\"Prepped %d utxo entries\", len(utxo_list))\n+\n+        # Sync these blocks with the other nodes\n+        block_hashes_to_sync = []\n+        for height in range(initial_height + 1, self.nodes[3].getblockcount() + 1):\n+            block_hashes_to_sync.append(self.nodes[3].getblockhash(height))\n+\n+        self.log.debug(\"Syncing %d blocks with other nodes\", len(block_hashes_to_sync))\n+        # Syncing the blocks could cause nodes to crash, so the test begins here.\n+        self.sync_node3blocks(block_hashes_to_sync)\n+\n+        starting_tip_height = self.nodes[3].getblockcount()\n+\n+        # Main test loop:\n+        # each time through the loop, generate a bunch of transactions,\n+        # and then either mine a single new block on the tip, or some-sized reorg.\n+        for i in range(40):\n+            self.log.info(\"Iteration %d, generating 2500 transactions %s\", i, self.restart_counts)\n+            # Generate a bunch of small-ish transactions\n+            self.generate_small_transactions(self.nodes[3], 2500, utxo_list)\n+            # Pick a random block between current tip, and starting tip\n+            current_height = self.nodes[3].getblockcount()\n+            random_height = random.randint(starting_tip_height, current_height)\n+            self.log.debug(\"At height %d, considering height %d\", current_height, random_height)\n+            if random_height > starting_tip_height:\n+                # Randomly reorg from this point with some probability (1/4 for\n+                # tip, 1/5 for tip-1, ...)\n+                if random.random() < 1.0 / (current_height + 4 - random_height):\n+                    self.log.debug(\"Invalidating block at height %d\", random_height)\n+                    self.nodes[3].invalidateblock(self.nodes[3].getblockhash(random_height))\n+\n+            # Now generate new blocks until we pass the old tip height\n+            self.log.debug(\"Mining longer tip\")\n+            block_hashes = []\n+            while current_height + 1 > self.nodes[3].getblockcount():\n+                block_hashes.extend(self.nodes[3].generate(min(10, current_height + 1 - self.nodes[3].getblockcount())))\n+            self.log.debug(\"Syncing %d new blocks...\", len(block_hashes))\n+            self.sync_node3blocks(block_hashes)\n+            utxo_list = self.nodes[3].listunspent()\n+            self.log.debug(\"Node3 utxo count: %d\", len(utxo_list))\n+\n+        # Check that the utxo hashes agree with node3\n+        # Useful side effect: each utxo cache gets flushed here, so that we\n+        # won't get crashes on shutdown at the end of the test.\n+        self.verify_utxo_hash()\n+\n+        # Check the test coverage\n+        self.log.info(\"Restarted nodes: %s; crashes on restart: %d\", self.restart_counts, self.crashed_on_restart)\n+\n+        # If no nodes were restarted, we didn't test anything.\n+        assert self.restart_counts != [0, 0, 0]\n+\n+        # Make sure we tested the case of crash-during-recovery.\n+        assert self.crashed_on_restart > 0\n+\n+        # Warn if any of the nodes escaped restart.\n+        for i in range(3):\n+            if self.restart_counts[i] == 0:\n+                self.log.warn(\"Node %d never crashed during utxo flush!\", i)\n+\n+if __name__ == \"__main__\":\n+    ChainstateWriteCrashTest().main()"
      },
      {
        "sha": "1ba5f756cd4a05cd4f7388ffad125b0f899bceef",
        "filename": "test/functional/example_test.py",
        "status": "added",
        "additions": 219,
        "deletions": 0,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -0,0 +1,219 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports if possible\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.mininode import (\n+    CInv,\n+    NetworkThread,\n+    NodeConn,\n+    NodeConnCB,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+    wait_until,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    p2p_port,\n+)\n+\n+# NodeConnCB is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass NodeConnCB and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(NodeConnCB):\n+    def __init__(self):\n+        \"\"\"Initialize the NodeConnCB\n+\n+        Used to inialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the NodeConnCB\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, conn, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the __init__(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def __init__(self):\n+        \"\"\"Initialize the test\n+\n+        Call super().__init__() first, and then override any test parameters\n+        for your individual test.\"\"\"\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished __init__\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all([self.nodes[0:1]])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create a P2P connection to one of the nodes\n+        node0 = BaseNode()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n+        node0.add_connection(connections[0])\n+\n+        # Start up network handling in another thread. This needs to be called\n+        # after the P2P connections have been created.\n+        NetworkThread().start()\n+        # wait_for_verack ensures that the P2P connection is fully up.\n+        node0.wait_for_verack()\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.sync_all([self.nodes[0:1]])\n+\n+        # Notice above how we called an RPC by calling a method with the same\n+        # name on the node object. Notice also how we used a keyword argument\n+        # to specify a named RPC argument. Neither of those are defined on the\n+        # node object. Instead there's some __getattr__() magic going on under\n+        # the covers to dispatch unrecognised attribute calls to the RPC\n+        # interface.\n+\n+        # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # breaking the test into sub-sections.\n+        self.log.info(\"Starting test!\")\n+\n+        self.log.info(\"Calling a custom function\")\n+        custom_function()\n+\n+        self.log.info(\"Calling a custom method\")\n+        self.custom_method()\n+\n+        self.log.info(\"Create some blocks\")\n+        self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        height = 1\n+\n+        for i in range(10):\n+            # Use the mininode and blocktools functionality to manually build a block\n+            # Calling the generate() rpc is easier, but this allows us to exactly\n+            # control the blocks and transactions.\n+            block = create_block(self.tip, create_coinbase(height), self.block_time)\n+            block.solve()\n+            block_message = msg_block(block)\n+            # Send message is used to send a P2P message to the node over our NodeConn connection\n+            node0.send_message(block_message)\n+            self.tip = block.sha256\n+            blocks.append(self.tip)\n+            self.block_time += 1\n+            height += 1\n+\n+        self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        self.nodes[1].waitforblockheight(11)\n+\n+        self.log.info(\"Connect node2 and node1\")\n+        connect_nodes(self.nodes[1], 2)\n+\n+        self.log.info(\"Add P2P connection to node2\")\n+        node2 = BaseNode()\n+        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n+        node2.add_connection(connections[1])\n+        node2.wait_for_verack()\n+\n+        self.log.info(\"Wait for node2 reach current tip. Test that it has propogated all the blocks to us\")\n+\n+        for block in blocks:\n+            getdata_request = msg_getdata()\n+            getdata_request.inv.append(CInv(2, block))\n+            node2.send_message(getdata_request)\n+\n+        # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # NodeConnCB objects.\n+        assert wait_until(lambda: sorted(blocks) == sorted(list(node2.block_receive_map.keys())), timeout=5)\n+\n+        self.log.info(\"Check that each block was received only once\")\n+        # The network thread uses a global lock on data access to the NodeConn objects when sending and receiving\n+        # messages. The test thread should acquire the global lock before accessing any NodeConn data to avoid locking\n+        # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        with mininode_lock:\n+            for block in node2.block_receive_map.values():\n+                assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      },
      {
        "sha": "0baab6d01cf3cbb5c4697a6059cb814dce309541",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the fundrawtransaction RPC.\"\"\"\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import BitcoinTestFramework, BITCOIND_PROC_WAIT_TIMEOUT\n from test_framework.util import *\n \n \n@@ -452,7 +452,7 @@ def run_test(self):\n         self.stop_node(2)\n         self.stop_node(3)\n         self.nodes[1].encryptwallet(\"test\")\n-        bitcoind_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.bitcoind_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n \n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n         # This test is not meant to test fee estimation and we'd like"
      },
      {
        "sha": "e8be559918d52ae8449aec4ef1535c6b01c3bc3d",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -18,7 +18,7 @@ def run_test(self):\n         \n         # Encrypt wallet and wait to terminate\n         nodes[0].encryptwallet('test')\n-        bitcoind_processes[0].wait()\n+        self.bitcoind_processes[0].wait()\n         # Restart node 0\n         nodes[0] = self.start_node(0, self.options.tmpdir)\n         # Keep creating keys"
      },
      {
        "sha": "f75a8e29cc7a0b76e4c38451f2b53b16f1faa210",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -23,7 +23,7 @@ def __init__(self):\n \n     def setup_nodes(self):\n         #This test requires mocktime\n-        enable_mocktime()\n+        self.enable_mocktime()\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):"
      },
      {
        "sha": "a30e15ace9e43b9e7653d4eb1d890ea453543fc7",
        "filename": "test/functional/multi_rpc.py",
        "status": "modified",
        "additions": 51,
        "deletions": 7,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/multi_rpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/multi_rpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multi_rpc.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -16,16 +16,21 @@ class HTTPBasicsTest (BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = False\n-        self.num_nodes = 1\n+        self.num_nodes = 2\n \n     def setup_chain(self):\n         super().setup_chain()\n         #Append rpcauth to bitcoin.conf before initialization\n         rpcauth = \"rpcauth=rt:93648e835a54c573682c2eb19f882535$7681e9c5b74bdd85e78166031d2058e1069b3ed7ed967c93fc63abba06f31144\"\n         rpcauth2 = \"rpcauth=rt2:f8607b1a88861fac29dfccf9b52ff9f$ff36a0c23c8c62b4846112e50fa888416e94c17bfd4c42f88fd8f55ec6a3137e\"\n+        rpcuser = \"rpcuser=rpcuser\ud83d\udcbb\"\n+        rpcpassword = \"rpcpassword=rpcpassword\ud83d\udd11\"\n         with open(os.path.join(self.options.tmpdir+\"/node0\", \"bitcoin.conf\"), 'a', encoding='utf8') as f:\n             f.write(rpcauth+\"\\n\")\n             f.write(rpcauth2+\"\\n\")\n+        with open(os.path.join(self.options.tmpdir+\"/node1\", \"bitcoin.conf\"), 'a', encoding='utf8') as f:\n+            f.write(rpcuser+\"\\n\")\n+            f.write(rpcpassword+\"\\n\")\n \n     def run_test(self):\n \n@@ -50,7 +55,7 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         resp = conn.getresponse()\n-        assert_equal(resp.status==401, False)\n+        assert_equal(resp.status, 200)\n         conn.close()\n         \n         #Use new authpair to confirm both work\n@@ -60,7 +65,7 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         resp = conn.getresponse()\n-        assert_equal(resp.status==401, False)\n+        assert_equal(resp.status, 200)\n         conn.close()\n \n         #Wrong login name with rt's password\n@@ -71,7 +76,7 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         resp = conn.getresponse()\n-        assert_equal(resp.status==401, True)\n+        assert_equal(resp.status, 401)\n         conn.close()\n \n         #Wrong password for rt\n@@ -82,7 +87,7 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         resp = conn.getresponse()\n-        assert_equal(resp.status==401, True)\n+        assert_equal(resp.status, 401)\n         conn.close()\n \n         #Correct for rt2\n@@ -93,7 +98,7 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         resp = conn.getresponse()\n-        assert_equal(resp.status==401, False)\n+        assert_equal(resp.status, 200)\n         conn.close()\n \n         #Wrong password for rt2\n@@ -104,7 +109,46 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         resp = conn.getresponse()\n-        assert_equal(resp.status==401, True)\n+        assert_equal(resp.status, 401)\n+        conn.close()\n+\n+        ###############################################################\n+        # Check correctness of the rpcuser/rpcpassword config options #\n+        ###############################################################\n+        url = urllib.parse.urlparse(self.nodes[1].url)\n+\n+        # rpcuser and rpcpassword authpair\n+        rpcuserauthpair = \"rpcuser\ud83d\udcbb:rpcpassword\ud83d\udd11\"\n+\n+        headers = {\"Authorization\": \"Basic \" + str_to_b64str(rpcuserauthpair)}\n+\n+        conn = http.client.HTTPConnection(url.hostname, url.port)\n+        conn.connect()\n+        conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n+        resp = conn.getresponse()\n+        assert_equal(resp.status, 200)\n+        conn.close()\n+\n+        #Wrong login name with rpcuser's password\n+        rpcuserauthpair = \"rpcuserwrong:rpcpassword\"\n+        headers = {\"Authorization\": \"Basic \" + str_to_b64str(rpcuserauthpair)}\n+\n+        conn = http.client.HTTPConnection(url.hostname, url.port)\n+        conn.connect()\n+        conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n+        resp = conn.getresponse()\n+        assert_equal(resp.status, 401)\n+        conn.close()\n+\n+        #Wrong password for rpcuser\n+        rpcuserauthpair = \"rpcuser:rpcpasswordwrong\"\n+        headers = {\"Authorization\": \"Basic \" + str_to_b64str(rpcuserauthpair)}\n+\n+        conn = http.client.HTTPConnection(url.hostname, url.port)\n+        conn.connect()\n+        conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n+        resp = conn.getresponse()\n+        assert_equal(resp.status, 401)\n         conn.close()\n \n "
      },
      {
        "sha": "63dfbb8ae6e564a02f1c067f380f23dc339fd60b",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -1486,7 +1486,7 @@ def test_p2sh_witness(self, segwit_activated):\n     # nodes would have stored, this requires special handling.\n     # To enable this test, pass --oldbinary=<path-to-pre-segwit-bitcoind> to\n     # the test.\n-    def test_upgrade_after_activation(self, node, node_id):\n+    def test_upgrade_after_activation(self, node_id):\n         self.log.info(\"Testing software upgrade after softfork activation\")\n \n         assert(node_id != 0) # node0 is assumed to be a segwit-active bitcoind\n@@ -1502,14 +1502,14 @@ def test_upgrade_after_activation(self, node, node_id):\n         sync_blocks(self.nodes)\n \n         # Make sure that this peer thinks segwit has activated.\n-        assert(get_bip9_status(node, 'segwit')['status'] == \"active\")\n+        assert(get_bip9_status(self.nodes[node_id], 'segwit')['status'] == \"active\")\n \n         # Make sure this peers blocks match those of node0.\n-        height = node.getblockcount()\n+        height = self.nodes[node_id].getblockcount()\n         while height >= 0:\n-            block_hash = node.getblockhash(height)\n+            block_hash = self.nodes[node_id].getblockhash(height)\n             assert_equal(block_hash, self.nodes[0].getblockhash(height))\n-            assert_equal(self.nodes[0].getblock(block_hash), node.getblock(block_hash))\n+            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[node_id].getblock(block_hash))\n             height -= 1\n \n \n@@ -1944,7 +1944,7 @@ def run_test(self):\n         self.test_signature_version_1()\n         self.test_non_standard_witness()\n         sync_blocks(self.nodes)\n-        self.test_upgrade_after_activation(self.nodes[2], 2)\n+        self.test_upgrade_after_activation(node_id=2)\n         self.test_witness_sigops()\n \n "
      },
      {
        "sha": "0af91e0658904fc5422922642d80e946fd7e4313",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -315,17 +315,17 @@ def wallet_test(self):\n         # check that the pruning node's wallet is still in good shape\n         self.log.info(\"Stop and start pruning node to trigger wallet rescan\")\n         self.stop_node(2)\n-        self.start_node(2, self.options.tmpdir, [\"-prune=550\"])\n+        self.nodes[2] = self.start_node(2, self.options.tmpdir, [\"-prune=550\"])\n         self.log.info(\"Success\")\n \n-        # check that wallet loads loads successfully when restarting a pruned node after IBD.\n+        # check that wallet loads successfully when restarting a pruned node after IBD.\n         # this was reported to fail in #7494.\n         self.log.info(\"Syncing node 5 to test wallet\")\n         connect_nodes(self.nodes[0], 5)\n         nds = [self.nodes[0], self.nodes[5]]\n         sync_blocks(nds, wait=5, timeout=300)\n         self.stop_node(5) #stop and start to trigger rescan\n-        self.start_node(5, self.options.tmpdir, [\"-prune=550\"])\n+        self.nodes[5] = self.start_node(5, self.options.tmpdir, [\"-prune=550\"])\n         self.log.info(\"Success\")\n \n     def run_test(self):"
      },
      {
        "sha": "19d99c9c9e9750241da3a46c59bebb9f21eae28f",
        "filename": "test/functional/receivedby.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/receivedby.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -31,7 +31,7 @@ def __init__(self):\n \n     def setup_nodes(self):\n         #This test requires mocktime\n-        enable_mocktime()\n+        self.enable_mocktime()\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):"
      },
      {
        "sha": "a69dbb501333a58e3a8372c316fc9023768ae155",
        "filename": "test/functional/rest.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rest.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -82,9 +82,9 @@ def run_test(self):\n                 n = vout['n']\n \n \n-        ######################################\n-        # GETUTXOS: query a unspent outpoint #\n-        ######################################\n+        #######################################\n+        # GETUTXOS: query an unspent outpoint #\n+        #######################################\n         json_request = '/checkmempool/'+txid+'-'+str(n)\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n@@ -97,9 +97,9 @@ def run_test(self):\n         assert_equal(json_obj['utxos'][0]['value'], 0.1)\n \n \n-        ################################################\n-        # GETUTXOS: now query a already spent outpoint #\n-        ################################################\n+        #################################################\n+        # GETUTXOS: now query an already spent outpoint #\n+        #################################################\n         json_request = '/checkmempool/'+vintx+'-0'\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n@@ -161,24 +161,24 @@ def run_test(self):\n         json_request = '/'+txid+'-'+str(n)\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n-        assert_equal(len(json_obj['utxos']), 0) #there should be a outpoint because it has just added to the mempool\n+        assert_equal(len(json_obj['utxos']), 0) #there should be an outpoint because it has just added to the mempool\n \n         json_request = '/checkmempool/'+txid+'-'+str(n)\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n-        assert_equal(len(json_obj['utxos']), 1) #there should be a outpoint because it has just added to the mempool\n+        assert_equal(len(json_obj['utxos']), 1) #there should be an outpoint because it has just added to the mempool\n \n         #do some invalid requests\n         json_request = '{\"checkmempool'\n         response = http_post_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n-        assert_equal(response.status, 400) #must be a 400 because we send a invalid json request\n+        assert_equal(response.status, 400) #must be a 400 because we send an invalid json request\n \n         json_request = '{\"checkmempool'\n         response = http_post_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', json_request, True)\n-        assert_equal(response.status, 400) #must be a 400 because we send a invalid bin request\n+        assert_equal(response.status, 400) #must be a 400 because we send an invalid bin request\n \n         response = http_post_call(url.hostname, url.port, '/rest/getutxos/checkmempool'+self.FORMAT_SEPARATOR+'bin', '', True)\n-        assert_equal(response.status, 400) #must be a 400 because we send a invalid bin request\n+        assert_equal(response.status, 400) #must be a 400 because we send an invalid bin request\n \n         #test limits\n         json_request = '/checkmempool/'"
      },
      {
        "sha": "951685aa7606a16c089c4280d0b221e836902774",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -37,7 +37,7 @@ def run_bind_test(self, allow_ips, connect_to, addresses, expected):\n             base_args += ['-rpcallowip=' + x for x in allow_ips]\n         binds = ['-rpcbind='+addr for addr in addresses]\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n-        pid = bitcoind_processes[0].pid\n+        pid = self.bitcoind_processes[0].pid\n         assert_equal(set(get_bind_addrs(pid)), set(expected))\n         self.stop_nodes()\n \n@@ -49,7 +49,7 @@ def run_allowip_test(self, allow_ips, rpchost, rpcport):\n         base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args])\n         # connect to node through non-loopback interface\n-        node = get_rpc_proxy(rpc_url(0, \"%s:%d\" % (rpchost, rpcport)), 0)\n+        node = get_rpc_proxy(rpc_url(get_datadir_path(self.options.tmpdir, 0), 0, \"%s:%d\" % (rpchost, rpcport)), 0)\n         node.getnetworkinfo()\n         self.stop_nodes()\n "
      },
      {
        "sha": "bc42a319df79dc061a89eab78351911972c6f087",
        "filename": "test/functional/smartfees.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/smartfees.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -10,7 +10,7 @@\n from test_framework.mininode import CTransaction, CTxIn, CTxOut, COutPoint, ToHex, COIN\n \n # Construct 2 trivial P2SH's and the ScriptSigs that spend them\n-# So we can create many many transactions without needing to spend\n+# So we can create many transactions without needing to spend\n # time signing.\n redeem_script_1 = CScript([OP_1, OP_DROP])\n redeem_script_2 = CScript([OP_2, OP_DROP])"
      },
      {
        "sha": "688347a68ff53db386e8bbec62e091627ca4c43e",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -61,7 +61,7 @@\n \n # One lock for synchronizing all data access between the networking thread (see\n # NetworkThread below) and the thread running the test logic.  For simplicity,\n-# NodeConn acquires this lock whenever delivering a message to to a NodeConnCB,\n+# NodeConn acquires this lock whenever delivering a message to a NodeConnCB,\n # and whenever adding anything to the send buffer (in send_message()).  This\n # lock should be acquired in the thread running the test logic to synchronize\n # access to any data shared with the NodeConnCB or NodeConn."
      },
      {
        "sha": "8d698a73276a1eb38f4963fb67e4b5d0fb71d6f5",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 157,
        "deletions": 47,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -5,7 +5,9 @@\n \"\"\"Base class for RPC testing.\"\"\"\n \n from collections import deque\n+import errno\n from enum import Enum\n+import http.client\n import logging\n import optparse\n import os\n@@ -14,33 +16,27 @@\n import sys\n import tempfile\n import time\n+import traceback\n \n+from .authproxy import JSONRPCException\n+from . import coverage\n from .util import (\n-    PortSeed,\n     MAX_NODES,\n-    bitcoind_processes,\n+    PortSeed,\n+    assert_equal,\n     check_json_precision,\n     connect_nodes_bi,\n-    disable_mocktime,\n     disconnect_nodes,\n-    enable_coverage,\n-    enable_mocktime,\n-    get_mocktime,\n     get_rpc_proxy,\n     initialize_datadir,\n+    get_datadir_path,\n     log_filename,\n     p2p_port,\n     rpc_url,\n     set_node_times,\n-    _start_node,\n-    _start_nodes,\n-    _stop_node,\n-    _stop_nodes,\n     sync_blocks,\n     sync_mempools,\n-    wait_for_bitcoind_start,\n )\n-from .authproxy import JSONRPCException\n \n class TestStatus(Enum):\n     PASSED = 1\n@@ -51,6 +47,8 @@ class TestStatus(Enum):\n TEST_EXIT_FAILED = 1\n TEST_EXIT_SKIPPED = 77\n \n+BITCOIND_PROC_WAIT_TIMEOUT = 60\n+\n class BitcoinTestFramework(object):\n     \"\"\"Base class for a bitcoin test script.\n \n@@ -70,13 +68,15 @@ class BitcoinTestFramework(object):\n     def __init__(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = False\n-        self.nodes = None\n+        self.nodes = []\n+        self.bitcoind_processes = {}\n+        self.mocktime = 0\n \n     def add_options(self, parser):\n         pass\n \n     def setup_chain(self):\n-        self.log.info(\"Initializing test directory \"+self.options.tmpdir)\n+        self.log.info(\"Initializing test directory \" + self.options.tmpdir)\n         if self.setup_clean_chain:\n             self._initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n         else:\n@@ -96,7 +96,7 @@ def setup_nodes(self):\n         extra_args = None\n         if hasattr(self, \"extra_args\"):\n             extra_args = self.extra_args\n-        self.nodes = _start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n     def run_test(self):\n         raise NotImplementedError\n@@ -110,9 +110,9 @@ def main(self):\n                           help=\"Leave bitcoinds and test.* datadir on exit or error\")\n         parser.add_option(\"--noshutdown\", dest=\"noshutdown\", default=False, action=\"store_true\",\n                           help=\"Don't stop bitcoinds after the test execution\")\n-        parser.add_option(\"--srcdir\", dest=\"srcdir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../../src\"),\n+        parser.add_option(\"--srcdir\", dest=\"srcdir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__)) + \"/../../../src\"),\n                           help=\"Source directory containing bitcoind/bitcoin-cli (default: %default)\")\n-        parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../cache\"),\n+        parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__)) + \"/../../cache\"),\n                           help=\"Directory for caching pregenerated datadirs\")\n         parser.add_option(\"--tmpdir\", dest=\"tmpdir\", help=\"Root directory for datadirs\")\n         parser.add_option(\"-l\", \"--loglevel\", dest=\"loglevel\", default=\"INFO\",\n@@ -128,12 +128,9 @@ def main(self):\n         self.add_options(parser)\n         (self.options, self.args) = parser.parse_args()\n \n-        if self.options.coveragedir:\n-            enable_coverage(self.options.coveragedir)\n-\n         PortSeed.n = self.options.port_seed\n \n-        os.environ['PATH'] = self.options.srcdir+\":\"+self.options.srcdir+\"/qt:\"+os.environ['PATH']\n+        os.environ['PATH'] = self.options.srcdir + \":\" + self.options.srcdir + \"/qt:\" + os.environ['PATH']\n \n         check_json_precision()\n \n@@ -187,7 +184,7 @@ def main(self):\n                 for fn in filenames:\n                     try:\n                         with open(fn, 'r') as f:\n-                            print(\"From\" , fn, \":\")\n+                            print(\"From\", fn, \":\")\n                             print(\"\".join(deque(f, MAX_LINES_TO_PRINT)))\n                     except OSError:\n                         print(\"Opening file %s failed.\" % fn)\n@@ -207,16 +204,88 @@ def main(self):\n     # Public helper methods. These can be accessed by the subclass test scripts.\n \n     def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-        return _start_node(i, dirname, extra_args, rpchost, timewait, binary, stderr)\n+        \"\"\"Start a bitcoind and return RPC connection to it\"\"\"\n+\n+        datadir = os.path.join(dirname, \"node\" + str(i))\n+        if binary is None:\n+            binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n+        args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(self.mocktime), \"-uacomment=testnode%d\" % i]\n+        if extra_args is not None:\n+            args.extend(extra_args)\n+        self.bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n+        self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n+        self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i, rpchost)\n+        self.log.debug(\"initialize_chain: RPC successfully started\")\n+        proxy = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, timeout=timewait)\n+\n+        if self.options.coveragedir:\n+            coverage.write_all_rpc_commands(self.options.coveragedir, proxy)\n+\n+        return proxy\n \n     def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-        return _start_nodes(num_nodes, dirname, extra_args, rpchost, timewait, binary)\n+        \"\"\"Start multiple bitcoinds, return RPC connections to them\"\"\"\n+\n+        if extra_args is None:\n+            extra_args = [None] * num_nodes\n+        if binary is None:\n+            binary = [None] * num_nodes\n+        assert_equal(len(extra_args), num_nodes)\n+        assert_equal(len(binary), num_nodes)\n+        rpcs = []\n+        try:\n+            for i in range(num_nodes):\n+                rpcs.append(self.start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n+        except:\n+            # If one node failed to start, stop the others\n+            # TODO: abusing self.nodes in this way is a little hacky.\n+            # Eventually we should do a better job of tracking nodes\n+            self.nodes.extend(rpcs)\n+            self.stop_nodes()\n+            self.nodes = []\n+            raise\n+        return rpcs\n+\n+    def stop_node(self, i):\n+        \"\"\"Stop a bitcoind test node\"\"\"\n \n-    def stop_node(self, num_node):\n-        _stop_node(self.nodes[num_node], num_node)\n+        self.log.debug(\"Stopping node %d\" % i)\n+        try:\n+            self.nodes[i].stop()\n+        except http.client.CannotSendRequest as e:\n+            self.log.exception(\"Unable to stop node\")\n+        return_code = self.bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        del self.bitcoind_processes[i]\n+        assert_equal(return_code, 0)\n \n     def stop_nodes(self):\n-        _stop_nodes(self.nodes)\n+        \"\"\"Stop multiple bitcoind test nodes\"\"\"\n+\n+        for i in range(len(self.nodes)):\n+            self.stop_node(i)\n+        assert not self.bitcoind_processes.values()  # All connections must be gone now\n+\n+    def assert_start_raises_init_error(self, i, dirname, extra_args=None, expected_msg=None):\n+        with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n+            try:\n+                self.start_node(i, dirname, extra_args, stderr=log_stderr)\n+                self.stop_node(i)\n+            except Exception as e:\n+                assert 'bitcoind exited' in str(e)  # node must have shutdown\n+                if expected_msg is not None:\n+                    log_stderr.seek(0)\n+                    stderr = log_stderr.read().decode('utf-8')\n+                    if expected_msg not in stderr:\n+                        raise AssertionError(\"Expected error \\\"\" + expected_msg + \"\\\" not found in:\\n\" + stderr)\n+            else:\n+                if expected_msg is None:\n+                    assert_msg = \"bitcoind should have exited with an error\"\n+                else:\n+                    assert_msg = \"bitcoind should have exited with expected error \" + expected_msg\n+                raise AssertionError(assert_msg)\n+\n+    def wait_for_node_exit(self, i, timeout):\n+        self.bitcoind_processes[i].wait(timeout)\n \n     def split_network(self):\n         \"\"\"\n@@ -241,6 +310,21 @@ def sync_all(self, node_groups=None):\n             sync_blocks(group)\n             sync_mempools(group)\n \n+    def enable_mocktime(self):\n+        \"\"\"Enable mocktime for the script.\n+\n+        mocktime may be needed for scripts that use the cached version of the\n+        blockchain.  If the cached version of the blockchain is used without\n+        mocktime then the mempools will not sync due to IBD.\n+\n+        For backwared compatibility of the python scripts with previous\n+        versions of the cache, this helper function sets mocktime to Jan 1,\n+        2014 + (201 * 10 * 60)\"\"\"\n+        self.mocktime = 1388534400 + (201 * 10 * 60)\n+\n+    def disable_mocktime(self):\n+        self.mocktime = 0\n+\n     # Private helper methods. These should not be accessed by the subclass test scripts.\n \n     def _start_logging(self):\n@@ -256,7 +340,7 @@ def _start_logging(self):\n         ll = int(self.options.loglevel) if self.options.loglevel.isdigit() else self.options.loglevel.upper()\n         ch.setLevel(ll)\n         # Format logs the same as bitcoind's debug.log with microprecision (so log files can be concatenated and sorted)\n-        formatter = logging.Formatter(fmt = '%(asctime)s.%(msecs)03d000 %(name)s (%(levelname)s): %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n+        formatter = logging.Formatter(fmt='%(asctime)s.%(msecs)03d000 %(name)s (%(levelname)s): %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n         formatter.converter = time.gmtime\n         fh.setFormatter(formatter)\n         ch.setFormatter(formatter)\n@@ -298,15 +382,15 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n                 args = [os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\" + datadir, \"-discover=0\"]\n                 if i > 0:\n                     args.append(\"-connect=127.0.0.1:\" + str(p2p_port(0)))\n-                bitcoind_processes[i] = subprocess.Popen(args)\n+                self.bitcoind_processes[i] = subprocess.Popen(args)\n                 self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-                wait_for_bitcoind_start(bitcoind_processes[i], rpc_url(i), i)\n+                self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i)\n                 self.log.debug(\"initialize_chain: RPC successfully started\")\n \n             self.nodes = []\n             for i in range(MAX_NODES):\n                 try:\n-                    self.nodes.append(get_rpc_proxy(rpc_url(i), i))\n+                    self.nodes.append(get_rpc_proxy(rpc_url(get_datadir_path(cachedir, i), i), i))\n                 except:\n                     self.log.exception(\"Error connecting to node %d\" % i)\n                     sys.exit(1)\n@@ -318,8 +402,8 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n             #\n             # blocks are created with timestamps 10 minutes apart\n             # starting from 2010 minutes in the past\n-            enable_mocktime()\n-            block_time = get_mocktime() - (201 * 10 * 60)\n+            self.enable_mocktime()\n+            block_time = self.mocktime - (201 * 10 * 60)\n             for i in range(2):\n                 for peer in range(4):\n                     for j in range(25):\n@@ -332,7 +416,7 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n             # Shut them down, and clean up cache directories:\n             self.stop_nodes()\n             self.nodes = []\n-            disable_mocktime()\n+            self.disable_mocktime()\n             for i in range(MAX_NODES):\n                 os.remove(log_filename(cachedir, i, \"debug.log\"))\n                 os.remove(log_filename(cachedir, i, \"db.log\"))\n@@ -353,18 +437,37 @@ def _initialize_chain_clean(self, test_dir, num_nodes):\n         for i in range(num_nodes):\n             initialize_datadir(test_dir, i)\n \n-# Test framework for doing p2p comparison testing, which sets up some bitcoind\n-# binaries:\n-# 1 binary: test binary\n-# 2 binaries: 1 test binary, 1 ref binary\n-# n>2 binaries: 1 test binary, n-1 ref binaries\n-\n-class SkipTest(Exception):\n-    \"\"\"This exception is raised to skip a test\"\"\"\n-    def __init__(self, message):\n-        self.message = message\n+    def _wait_for_bitcoind_start(self, process, datadir, i, rpchost=None):\n+        \"\"\"Wait for bitcoind to start.\n+\n+        This means that RPC is accessible and fully initialized.\n+        Raise an exception if bitcoind exits during initialization.\"\"\"\n+        while True:\n+            if process.poll() is not None:\n+                raise Exception('bitcoind exited with status %i during initialization' % process.returncode)\n+            try:\n+                # Check if .cookie file to be created\n+                rpc = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, coveragedir=self.options.coveragedir)\n+                rpc.getblockcount()\n+                break  # break out of loop on success\n+            except IOError as e:\n+                if e.errno != errno.ECONNREFUSED:  # Port not yet open?\n+                    raise  # unknown IO error\n+            except JSONRPCException as e:  # Initialization phase\n+                if e.error['code'] != -28:  # RPC in warmup?\n+                    raise  # unknown JSON RPC exception\n+            except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n+                if \"No RPC credentials\" not in str(e):\n+                    raise\n+            time.sleep(0.25)\n \n class ComparisonTestFramework(BitcoinTestFramework):\n+    \"\"\"Test framework for doing p2p comparison testing\n+\n+    Sets up some bitcoind binaries:\n+    - 1 binary: test binary\n+    - 2 binaries: 1 test binary, 1 ref binary\n+    - n>2 binaries: 1 test binary, n-1 ref binaries\"\"\"\n \n     def __init__(self):\n         super().__init__()\n@@ -380,8 +483,15 @@ def add_options(self, parser):\n                           help=\"bitcoind binary to use for reference nodes (if any)\")\n \n     def setup_network(self):\n+        extra_args = [['-whitelist=127.0.0.1']]*self.num_nodes\n+        if hasattr(self, \"extra_args\"):\n+            extra_args = self.extra_args\n         self.nodes = self.start_nodes(\n-            self.num_nodes, self.options.tmpdir,\n-            extra_args=[['-whitelist=127.0.0.1']] * self.num_nodes,\n+            self.num_nodes, self.options.tmpdir, extra_args,\n             binary=[self.options.testbinary] +\n-            [self.options.refbinary]*(self.num_nodes-1))\n+            [self.options.refbinary] * (self.num_nodes - 1))\n+\n+class SkipTest(Exception):\n+    \"\"\"This exception is raised to skip a test\"\"\"\n+    def __init__(self, message):\n+        self.message = message"
      },
      {
        "sha": "8a2d8de50ebc826258cea9b654bf290db2ff826a",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 253,
        "deletions": 362,
        "changes": 615,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -4,72 +4,174 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Helpful routines for regression testing.\"\"\"\n \n-import os\n-import sys\n-\n-from binascii import hexlify, unhexlify\n from base64 import b64encode\n+from binascii import hexlify, unhexlify\n from decimal import Decimal, ROUND_DOWN\n import json\n-import http.client\n+import logging\n+import os\n import random\n-import shutil\n-import subprocess\n-import tempfile\n-import time\n import re\n-import errno\n-import logging\n+import time\n \n from . import coverage\n from .authproxy import AuthServiceProxy, JSONRPCException\n \n-COVERAGE_DIR = None\n-\n logger = logging.getLogger(\"TestFramework.utils\")\n \n+# Assert functions\n+##################\n+\n+def assert_fee_amount(fee, tx_size, fee_per_kB):\n+    \"\"\"Assert the fee was in range\"\"\"\n+    target_fee = tx_size * fee_per_kB / 1000\n+    if fee < target_fee:\n+        raise AssertionError(\"Fee of %s BTC too low! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n+    # allow the wallet's estimation to be at most 2 bytes off\n+    if fee > (tx_size + 2) * fee_per_kB / 1000:\n+        raise AssertionError(\"Fee of %s BTC too high! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n+\n+def assert_equal(thing1, thing2, *args):\n+    if thing1 != thing2 or any(thing1 != arg for arg in args):\n+        raise AssertionError(\"not(%s)\" % \" == \".join(str(arg) for arg in (thing1, thing2) + args))\n+\n+def assert_greater_than(thing1, thing2):\n+    if thing1 <= thing2:\n+        raise AssertionError(\"%s <= %s\" % (str(thing1), str(thing2)))\n+\n+def assert_greater_than_or_equal(thing1, thing2):\n+    if thing1 < thing2:\n+        raise AssertionError(\"%s < %s\" % (str(thing1), str(thing2)))\n+\n+def assert_raises(exc, fun, *args, **kwds):\n+    assert_raises_message(exc, None, fun, *args, **kwds)\n+\n+def assert_raises_message(exc, message, fun, *args, **kwds):\n+    try:\n+        fun(*args, **kwds)\n+    except exc as e:\n+        if message is not None and message not in e.error['message']:\n+            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n+    except Exception as e:\n+        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n+    else:\n+        raise AssertionError(\"No exception raised\")\n+\n+def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n+    \"\"\"Run an RPC and verify that a specific JSONRPC exception code and message is raised.\n+\n+    Calls function `fun` with arguments `args` and `kwds`. Catches a JSONRPCException\n+    and verifies that the error code and message are as expected. Throws AssertionError if\n+    no JSONRPCException was returned or if the error code/message are not as expected.\n+\n+    Args:\n+        code (int), optional: the error code returned by the RPC call (defined\n+            in src/rpc/protocol.h). Set to None if checking the error code is not required.\n+        message (string), optional: [a substring of] the error string returned by the\n+            RPC call. Set to None if checking the error string is not required\n+        fun (function): the function to call. This should be the name of an RPC.\n+        args*: positional arguments for the function.\n+        kwds**: named arguments for the function.\n+    \"\"\"\n+    try:\n+        fun(*args, **kwds)\n+    except JSONRPCException as e:\n+        # JSONRPCException was thrown as expected. Check the code and message values are correct.\n+        if (code is not None) and (code != e.error[\"code\"]):\n+            raise AssertionError(\"Unexpected JSONRPC error code %i\" % e.error[\"code\"])\n+        if (message is not None) and (message not in e.error['message']):\n+            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n+    except Exception as e:\n+        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n+    else:\n+        raise AssertionError(\"No exception raised\")\n+\n+def assert_is_hex_string(string):\n+    try:\n+        int(string, 16)\n+    except Exception as e:\n+        raise AssertionError(\n+            \"Couldn't interpret %r as hexadecimal; raised: %s\" % (string, e))\n+\n+def assert_is_hash_string(string, length=64):\n+    if not isinstance(string, str):\n+        raise AssertionError(\"Expected a string, got type %r\" % type(string))\n+    elif length and len(string) != length:\n+        raise AssertionError(\n+            \"String of length %d expected; got %d\" % (length, len(string)))\n+    elif not re.match('[abcdef0-9]+$', string):\n+        raise AssertionError(\n+            \"String %r contains invalid characters for a hash.\" % string)\n+\n+def assert_array_result(object_array, to_match, expected, should_not_find=False):\n+    \"\"\"\n+        Pass in array of JSON objects, a dictionary with key/value pairs\n+        to match against, and another dictionary with expected key/value\n+        pairs.\n+        If the should_not_find flag is true, to_match should not be found\n+        in object_array\n+        \"\"\"\n+    if should_not_find:\n+        assert_equal(expected, {})\n+    num_matched = 0\n+    for item in object_array:\n+        all_match = True\n+        for key, value in to_match.items():\n+            if item[key] != value:\n+                all_match = False\n+        if not all_match:\n+            continue\n+        elif should_not_find:\n+            num_matched = num_matched + 1\n+        for key, value in expected.items():\n+            if item[key] != value:\n+                raise AssertionError(\"%s : expected %s=%s\" % (str(item), str(key), str(value)))\n+            num_matched = num_matched + 1\n+    if num_matched == 0 and not should_not_find:\n+        raise AssertionError(\"No objects matched %s\" % (str(to_match)))\n+    if num_matched > 0 and should_not_find:\n+        raise AssertionError(\"Objects were found %s\" % (str(to_match)))\n+\n+# Utility functions\n+###################\n+\n+def check_json_precision():\n+    \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n+    n = Decimal(\"20000000.00000003\")\n+    satoshis = int(json.loads(json.dumps(float(n))) * 1.0e8)\n+    if satoshis != 2000000000000003:\n+        raise RuntimeError(\"JSON encode/decode loses precision\")\n+\n+def count_bytes(hex_string):\n+    return len(bytearray.fromhex(hex_string))\n+\n+def bytes_to_hex_str(byte_str):\n+    return hexlify(byte_str).decode('ascii')\n+\n+def hex_str_to_bytes(hex_str):\n+    return unhexlify(hex_str.encode('ascii'))\n+\n+def str_to_b64str(string):\n+    return b64encode(string.encode('utf-8')).decode('ascii')\n+\n+def satoshi_round(amount):\n+    return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n+# RPC/P2P connection constants and functions\n+############################################\n+\n # The maximum number of nodes a single test can spawn\n MAX_NODES = 8\n # Don't assign rpc or p2p ports lower than this\n PORT_MIN = 11000\n # The number of ports to \"reserve\" for p2p and rpc, each\n PORT_RANGE = 5000\n \n-BITCOIND_PROC_WAIT_TIMEOUT = 60\n-\n-\n class PortSeed:\n     # Must be initialized with a unique integer for each process\n     n = None\n \n-#Set Mocktime default to OFF.\n-#MOCKTIME is only needed for scripts that use the\n-#cached version of the blockchain.  If the cached\n-#version of the blockchain is used without MOCKTIME\n-#then the mempools will not sync due to IBD.\n-MOCKTIME = 0\n-\n-def enable_mocktime():\n-    #For backwared compatibility of the python scripts\n-    #with previous versions of the cache, set MOCKTIME \n-    #to Jan 1, 2014 + (201 * 10 * 60)\n-    global MOCKTIME\n-    MOCKTIME = 1388534400 + (201 * 10 * 60)\n-\n-def disable_mocktime():\n-    global MOCKTIME\n-    MOCKTIME = 0\n-\n-def get_mocktime():\n-    return MOCKTIME\n-\n-def enable_coverage(dirname):\n-    \"\"\"Maintain a log of which RPC calls are made during testing.\"\"\"\n-    global COVERAGE_DIR\n-    COVERAGE_DIR = dirname\n-\n-\n-def get_rpc_proxy(url, node_number, timeout=None):\n+def get_rpc_proxy(url, node_number, timeout=None, coveragedir=None):\n     \"\"\"\n     Args:\n         url (str): URL of the RPC server to call\n@@ -90,36 +192,101 @@ def get_rpc_proxy(url, node_number, timeout=None):\n     proxy.url = url  # store URL on proxy for info\n \n     coverage_logfile = coverage.get_filename(\n-        COVERAGE_DIR, node_number) if COVERAGE_DIR else None\n+        coveragedir, node_number) if coveragedir else None\n \n     return coverage.AuthServiceProxyWrapper(proxy, coverage_logfile)\n \n-\n def p2p_port(n):\n     assert(n <= MAX_NODES)\n     return PORT_MIN + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n def rpc_port(n):\n     return PORT_MIN + PORT_RANGE + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n-def check_json_precision():\n-    \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n-    n = Decimal(\"20000000.00000003\")\n-    satoshis = int(json.loads(json.dumps(float(n)))*1.0e8)\n-    if satoshis != 2000000000000003:\n-        raise RuntimeError(\"JSON encode/decode loses precision\")\n+def rpc_url(datadir, i, rpchost=None):\n+    rpc_u, rpc_p = get_auth_cookie(datadir, i)\n+    host = '127.0.0.1'\n+    port = rpc_port(i)\n+    if rpchost:\n+        parts = rpchost.split(':')\n+        if len(parts) == 2:\n+            host, port = parts\n+        else:\n+            host = rpchost\n+    return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, host, int(port))\n \n-def count_bytes(hex_string):\n-    return len(bytearray.fromhex(hex_string))\n+# Node functions\n+################\n \n-def bytes_to_hex_str(byte_str):\n-    return hexlify(byte_str).decode('ascii')\n+def initialize_datadir(dirname, n):\n+    datadir = os.path.join(dirname, \"node\" + str(n))\n+    if not os.path.isdir(datadir):\n+        os.makedirs(datadir)\n+    with open(os.path.join(datadir, \"bitcoin.conf\"), 'w', encoding='utf8') as f:\n+        f.write(\"regtest=1\\n\")\n+        f.write(\"port=\" + str(p2p_port(n)) + \"\\n\")\n+        f.write(\"rpcport=\" + str(rpc_port(n)) + \"\\n\")\n+        f.write(\"listenonion=0\\n\")\n+    return datadir\n \n-def hex_str_to_bytes(hex_str):\n-    return unhexlify(hex_str.encode('ascii'))\n+def get_datadir_path(dirname, n):\n+    return os.path.join(dirname, \"node\" + str(n))\n+\n+def get_auth_cookie(datadir, n):\n+    user = None\n+    password = None\n+    if os.path.isfile(os.path.join(datadir, \"bitcoin.conf\")):\n+        with open(os.path.join(datadir, \"bitcoin.conf\"), 'r') as f:\n+            for line in f:\n+                if line.startswith(\"rpcuser=\"):\n+                    assert user is None  # Ensure that there is only one rpcuser line\n+                    user = line.split(\"=\")[1].strip(\"\\n\")\n+                if line.startswith(\"rpcpassword=\"):\n+                    assert password is None  # Ensure that there is only one rpcpassword line\n+                    password = line.split(\"=\")[1].strip(\"\\n\")\n+    if os.path.isfile(os.path.join(datadir, \"regtest\", \".cookie\")):\n+        with open(os.path.join(datadir, \"regtest\", \".cookie\"), 'r') as f:\n+            userpass = f.read()\n+            split_userpass = userpass.split(':')\n+            user = split_userpass[0]\n+            password = split_userpass[1]\n+    if user is None or password is None:\n+        raise ValueError(\"No RPC credentials\")\n+    return user, password\n \n-def str_to_b64str(string):\n-    return b64encode(string.encode('utf-8')).decode('ascii')\n+def log_filename(dirname, n_node, logname):\n+    return os.path.join(dirname, \"node\" + str(n_node), \"regtest\", logname)\n+\n+def get_bip9_status(node, key):\n+    info = node.getblockchaininfo()\n+    return info['bip9_softforks'][key]\n+\n+def set_node_times(nodes, t):\n+    for node in nodes:\n+        node.setmocktime(t)\n+\n+def disconnect_nodes(from_connection, node_num):\n+    for peer_id in [peer['id'] for peer in from_connection.getpeerinfo() if \"testnode%d\" % node_num in peer['subver']]:\n+        from_connection.disconnectnode(nodeid=peer_id)\n+\n+    for _ in range(50):\n+        if [peer['id'] for peer in from_connection.getpeerinfo() if \"testnode%d\" % node_num in peer['subver']] == []:\n+            break\n+        time.sleep(0.1)\n+    else:\n+        raise AssertionError(\"timed out waiting for disconnect\")\n+\n+def connect_nodes(from_connection, node_num):\n+    ip_port = \"127.0.0.1:\" + str(p2p_port(node_num))\n+    from_connection.addnode(ip_port, \"onetry\")\n+    # poll until version handshake complete to avoid race conditions\n+    # with transaction relaying\n+    while any(peer['version'] == 0 for peer in from_connection.getpeerinfo()):\n+        time.sleep(0.1)\n+\n+def connect_nodes_bi(nodes, a, b):\n+    connect_nodes(nodes[a], b)\n+    connect_nodes(nodes[b], a)\n \n def sync_blocks(rpc_connections, *, wait=1, timeout=60):\n     \"\"\"\n@@ -152,7 +319,7 @@ def sync_chain(rpc_connections, *, wait=1, timeout=60):\n     \"\"\"\n     while timeout > 0:\n         best_hash = [x.getbestblockhash() for x in rpc_connections]\n-        if best_hash == [best_hash[0]]*len(best_hash):\n+        if best_hash == [best_hash[0]] * len(best_hash):\n             return\n         time.sleep(wait)\n         timeout -= wait\n@@ -168,176 +335,15 @@ def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n         num_match = 1\n         for i in range(1, len(rpc_connections)):\n             if set(rpc_connections[i].getrawmempool()) == pool:\n-                num_match = num_match+1\n+                num_match = num_match + 1\n         if num_match == len(rpc_connections):\n             return\n         time.sleep(wait)\n         timeout -= wait\n     raise AssertionError(\"Mempool sync failed\")\n \n-bitcoind_processes = {}\n-\n-def initialize_datadir(dirname, n):\n-    datadir = os.path.join(dirname, \"node\"+str(n))\n-    if not os.path.isdir(datadir):\n-        os.makedirs(datadir)\n-    rpc_u, rpc_p = rpc_auth_pair(n)\n-    with open(os.path.join(datadir, \"bitcoin.conf\"), 'w', encoding='utf8') as f:\n-        f.write(\"regtest=1\\n\")\n-        f.write(\"rpcuser=\" + rpc_u + \"\\n\")\n-        f.write(\"rpcpassword=\" + rpc_p + \"\\n\")\n-        f.write(\"port=\"+str(p2p_port(n))+\"\\n\")\n-        f.write(\"rpcport=\"+str(rpc_port(n))+\"\\n\")\n-        f.write(\"listenonion=0\\n\")\n-    return datadir\n-\n-def rpc_auth_pair(n):\n-    return 'rpcuser\ud83d\udcbb' + str(n), 'rpcpass\ud83d\udd11' + str(n)\n-\n-def rpc_url(i, rpchost=None):\n-    rpc_u, rpc_p = rpc_auth_pair(i)\n-    host = '127.0.0.1'\n-    port = rpc_port(i)\n-    if rpchost:\n-        parts = rpchost.split(':')\n-        if len(parts) == 2:\n-            host, port = parts\n-        else:\n-            host = rpchost\n-    return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, host, int(port))\n-\n-def wait_for_bitcoind_start(process, url, i):\n-    '''\n-    Wait for bitcoind to start. This means that RPC is accessible and fully initialized.\n-    Raise an exception if bitcoind exits during initialization.\n-    '''\n-    while True:\n-        if process.poll() is not None:\n-            raise Exception('bitcoind exited with status %i during initialization' % process.returncode)\n-        try:\n-            rpc = get_rpc_proxy(url, i)\n-            blocks = rpc.getblockcount()\n-            break # break out of loop on success\n-        except IOError as e:\n-            if e.errno != errno.ECONNREFUSED: # Port not yet open?\n-                raise # unknown IO error\n-        except JSONRPCException as e: # Initialization phase\n-            if e.error['code'] != -28: # RPC in warmup?\n-                raise # unknown JSON RPC exception\n-        time.sleep(0.25)\n-\n-\n-def _start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-    \"\"\"Start a bitcoind and return RPC connection to it\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    datadir = os.path.join(dirname, \"node\"+str(i))\n-    if binary is None:\n-        binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-    args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime()), \"-uacomment=testnode%d\" % i]\n-    if extra_args is not None: args.extend(extra_args)\n-    bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n-    logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-    url = rpc_url(i, rpchost)\n-    wait_for_bitcoind_start(bitcoind_processes[i], url, i)\n-    logger.debug(\"initialize_chain: RPC successfully started\")\n-    proxy = get_rpc_proxy(url, i, timeout=timewait)\n-\n-    if COVERAGE_DIR:\n-        coverage.write_all_rpc_commands(COVERAGE_DIR, proxy)\n-\n-    return proxy\n-\n-def assert_start_raises_init_error(i, dirname, extra_args=None, expected_msg=None):\n-    with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n-        try:\n-            node = _start_node(i, dirname, extra_args, stderr=log_stderr)\n-            _stop_node(node, i)\n-        except Exception as e:\n-            assert 'bitcoind exited' in str(e) #node must have shutdown\n-            if expected_msg is not None:\n-                log_stderr.seek(0)\n-                stderr = log_stderr.read().decode('utf-8')\n-                if expected_msg not in stderr:\n-                    raise AssertionError(\"Expected error \\\"\" + expected_msg + \"\\\" not found in:\\n\" + stderr)\n-        else:\n-            if expected_msg is None:\n-                assert_msg = \"bitcoind should have exited with an error\"\n-            else:\n-                assert_msg = \"bitcoind should have exited with expected error \" + expected_msg\n-            raise AssertionError(assert_msg)\n-\n-def _start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-    \"\"\"Start multiple bitcoinds, return RPC connections to them\n-    \n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    if extra_args is None: extra_args = [ None for _ in range(num_nodes) ]\n-    if binary is None: binary = [ None for _ in range(num_nodes) ]\n-    assert_equal(len(extra_args), num_nodes)\n-    assert_equal(len(binary), num_nodes)\n-    rpcs = []\n-    try:\n-        for i in range(num_nodes):\n-            rpcs.append(_start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n-    except: # If one node failed to start, stop the others\n-        _stop_nodes(rpcs)\n-        raise\n-    return rpcs\n-\n-def log_filename(dirname, n_node, logname):\n-    return os.path.join(dirname, \"node\"+str(n_node), \"regtest\", logname)\n-\n-def _stop_node(node, i):\n-    \"\"\"Stop a bitcoind test node\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    logger.debug(\"Stopping node %d\" % i)\n-    try:\n-        node.stop()\n-    except http.client.CannotSendRequest as e:\n-        logger.exception(\"Unable to stop node\")\n-    return_code = bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n-    assert_equal(return_code, 0)\n-    del bitcoind_processes[i]\n-\n-def _stop_nodes(nodes):\n-    \"\"\"Stop multiple bitcoind test nodes\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    for i, node in enumerate(nodes):\n-        _stop_node(node, i)\n-    assert not bitcoind_processes.values() # All connections must be gone now\n-\n-def set_node_times(nodes, t):\n-    for node in nodes:\n-        node.setmocktime(t)\n-\n-def disconnect_nodes(from_connection, node_num):\n-    for peer_id in [peer['id'] for peer in from_connection.getpeerinfo() if \"testnode%d\" % node_num in peer['subver']]:\n-        from_connection.disconnectnode(nodeid=peer_id)\n-\n-    for _ in range(50):\n-        if [peer['id'] for peer in from_connection.getpeerinfo() if \"testnode%d\" % node_num in peer['subver']] == []:\n-            break\n-        time.sleep(0.1)\n-    else:\n-        raise AssertionError(\"timed out waiting for disconnect\")\n-\n-def connect_nodes(from_connection, node_num):\n-    ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n-    from_connection.addnode(ip_port, \"onetry\")\n-    # poll until version handshake complete to avoid race conditions\n-    # with transaction relaying\n-    while any(peer['version'] == 0 for peer in from_connection.getpeerinfo()):\n-        time.sleep(0.1)\n-\n-def connect_nodes_bi(nodes, a, b):\n-    connect_nodes(nodes[a], b)\n-    connect_nodes(nodes[b], a)\n+# Transaction/Block functions\n+#############################\n \n def find_output(node, txid, amount):\n     \"\"\"\n@@ -348,38 +354,37 @@ def find_output(node, txid, amount):\n     for i in range(len(txdata[\"vout\"])):\n         if txdata[\"vout\"][i][\"value\"] == amount:\n             return i\n-    raise RuntimeError(\"find_output txid %s : %s not found\"%(txid,str(amount)))\n-\n+    raise RuntimeError(\"find_output txid %s : %s not found\" % (txid, str(amount)))\n \n def gather_inputs(from_node, amount_needed, confirmations_required=1):\n     \"\"\"\n     Return a random set of unspent txouts that are enough to pay amount_needed\n     \"\"\"\n-    assert(confirmations_required >=0)\n+    assert(confirmations_required >= 0)\n     utxo = from_node.listunspent(confirmations_required)\n     random.shuffle(utxo)\n     inputs = []\n     total_in = Decimal(\"0.00000000\")\n     while total_in < amount_needed and len(utxo) > 0:\n         t = utxo.pop()\n         total_in += t[\"amount\"]\n-        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"], \"address\" : t[\"address\"] } )\n+        inputs.append({\"txid\": t[\"txid\"], \"vout\": t[\"vout\"], \"address\": t[\"address\"]})\n     if total_in < amount_needed:\n-        raise RuntimeError(\"Insufficient funds: need %d, have %d\"%(amount_needed, total_in))\n+        raise RuntimeError(\"Insufficient funds: need %d, have %d\" % (amount_needed, total_in))\n     return (total_in, inputs)\n \n def make_change(from_node, amount_in, amount_out, fee):\n     \"\"\"\n     Create change output(s), return them\n     \"\"\"\n     outputs = {}\n-    amount = amount_out+fee\n+    amount = amount_out + fee\n     change = amount_in - amount\n-    if change > amount*2:\n+    if change > amount * 2:\n         # Create an extra change output to break up big inputs\n         change_address = from_node.getnewaddress()\n         # Split change in two, being careful of rounding:\n-        outputs[change_address] = Decimal(change/2).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+        outputs[change_address] = Decimal(change / 2).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n         change = amount_in - amount - outputs[change_address]\n     if change > 0:\n         outputs[from_node.getnewaddress()] = change\n@@ -392,9 +397,9 @@ def random_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n     \"\"\"\n     from_node = random.choice(nodes)\n     to_node = random.choice(nodes)\n-    fee = min_fee + fee_increment*random.randint(0,fee_variants)\n+    fee = min_fee + fee_increment * random.randint(0, fee_variants)\n \n-    (total_in, inputs) = gather_inputs(from_node, amount+fee)\n+    (total_in, inputs) = gather_inputs(from_node, amount + fee)\n     outputs = make_change(from_node, total_in, amount, fee)\n     outputs[to_node.getnewaddress()] = float(amount)\n \n@@ -404,123 +409,13 @@ def random_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n \n     return (txid, signresult[\"hex\"], fee)\n \n-def assert_fee_amount(fee, tx_size, fee_per_kB):\n-    \"\"\"Assert the fee was in range\"\"\"\n-    target_fee = tx_size * fee_per_kB / 1000\n-    if fee < target_fee:\n-        raise AssertionError(\"Fee of %s BTC too low! (Should be %s BTC)\"%(str(fee), str(target_fee)))\n-    # allow the wallet's estimation to be at most 2 bytes off\n-    if fee > (tx_size + 2) * fee_per_kB / 1000:\n-        raise AssertionError(\"Fee of %s BTC too high! (Should be %s BTC)\"%(str(fee), str(target_fee)))\n-\n-def assert_equal(thing1, thing2, *args):\n-    if thing1 != thing2 or any(thing1 != arg for arg in args):\n-        raise AssertionError(\"not(%s)\" % \" == \".join(str(arg) for arg in (thing1, thing2) + args))\n-\n-def assert_greater_than(thing1, thing2):\n-    if thing1 <= thing2:\n-        raise AssertionError(\"%s <= %s\"%(str(thing1),str(thing2)))\n-\n-def assert_greater_than_or_equal(thing1, thing2):\n-    if thing1 < thing2:\n-        raise AssertionError(\"%s < %s\"%(str(thing1),str(thing2)))\n-\n-def assert_raises(exc, fun, *args, **kwds):\n-    assert_raises_message(exc, None, fun, *args, **kwds)\n-\n-def assert_raises_message(exc, message, fun, *args, **kwds):\n-    try:\n-        fun(*args, **kwds)\n-    except exc as e:\n-        if message is not None and message not in e.error['message']:\n-            raise AssertionError(\"Expected substring not found:\"+e.error['message'])\n-    except Exception as e:\n-        raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n-    else:\n-        raise AssertionError(\"No exception raised\")\n-\n-def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n-    \"\"\"Run an RPC and verify that a specific JSONRPC exception code and message is raised.\n-\n-    Calls function `fun` with arguments `args` and `kwds`. Catches a JSONRPCException\n-    and verifies that the error code and message are as expected. Throws AssertionError if\n-    no JSONRPCException was returned or if the error code/message are not as expected.\n-\n-    Args:\n-        code (int), optional: the error code returned by the RPC call (defined\n-            in src/rpc/protocol.h). Set to None if checking the error code is not required.\n-        message (string), optional: [a substring of] the error string returned by the\n-            RPC call. Set to None if checking the error string is not required\n-        fun (function): the function to call. This should be the name of an RPC.\n-        args*: positional arguments for the function.\n-        kwds**: named arguments for the function.\n-    \"\"\"\n-    try:\n-        fun(*args, **kwds)\n-    except JSONRPCException as e:\n-        # JSONRPCException was thrown as expected. Check the code and message values are correct.\n-        if (code is not None) and (code != e.error[\"code\"]):\n-            raise AssertionError(\"Unexpected JSONRPC error code %i\" % e.error[\"code\"])\n-        if (message is not None) and (message not in e.error['message']):\n-            raise AssertionError(\"Expected substring not found:\"+e.error['message'])\n-    except Exception as e:\n-        raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n-    else:\n-        raise AssertionError(\"No exception raised\")\n-\n-def assert_is_hex_string(string):\n-    try:\n-        int(string, 16)\n-    except Exception as e:\n-        raise AssertionError(\n-            \"Couldn't interpret %r as hexadecimal; raised: %s\" % (string, e))\n-\n-def assert_is_hash_string(string, length=64):\n-    if not isinstance(string, str):\n-        raise AssertionError(\"Expected a string, got type %r\" % type(string))\n-    elif length and len(string) != length:\n-        raise AssertionError(\n-            \"String of length %d expected; got %d\" % (length, len(string)))\n-    elif not re.match('[abcdef0-9]+$', string):\n-        raise AssertionError(\n-            \"String %r contains invalid characters for a hash.\" % string)\n-\n-def assert_array_result(object_array, to_match, expected, should_not_find = False):\n-    \"\"\"\n-        Pass in array of JSON objects, a dictionary with key/value pairs\n-        to match against, and another dictionary with expected key/value\n-        pairs.\n-        If the should_not_find flag is true, to_match should not be found\n-        in object_array\n-        \"\"\"\n-    if should_not_find == True:\n-        assert_equal(expected, { })\n-    num_matched = 0\n-    for item in object_array:\n-        all_match = True\n-        for key,value in to_match.items():\n-            if item[key] != value:\n-                all_match = False\n-        if not all_match:\n-            continue\n-        elif should_not_find == True:\n-            num_matched = num_matched+1\n-        for key,value in expected.items():\n-            if item[key] != value:\n-                raise AssertionError(\"%s : expected %s=%s\"%(str(item), str(key), str(value)))\n-            num_matched = num_matched+1\n-    if num_matched == 0 and should_not_find != True:\n-        raise AssertionError(\"No objects matched %s\"%(str(to_match)))\n-    if num_matched > 0 and should_not_find == True:\n-        raise AssertionError(\"Objects were found %s\"%(str(to_match)))\n-\n-def satoshi_round(amount):\n-    return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n-\n # Helper to create at least \"count\" utxos\n # Pass in a fee that is sufficient for relay and mining new transactions.\n def create_confirmed_utxos(fee, node, count):\n-    node.generate(int(0.5*count)+101)\n+    to_generate = int(0.5 * count) + 101\n+    while to_generate > 0:\n+        node.generate(min(25, to_generate))\n+        to_generate -= 25\n     utxos = node.listunspent()\n     iterations = count - len(utxos)\n     addr1 = node.getnewaddress()\n@@ -530,14 +425,14 @@ def create_confirmed_utxos(fee, node, count):\n     for i in range(iterations):\n         t = utxos.pop()\n         inputs = []\n-        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n+        inputs.append({\"txid\": t[\"txid\"], \"vout\": t[\"vout\"]})\n         outputs = {}\n         send_value = t['amount'] - fee\n-        outputs[addr1] = satoshi_round(send_value/2)\n-        outputs[addr2] = satoshi_round(send_value/2)\n+        outputs[addr1] = satoshi_round(send_value / 2)\n+        outputs[addr2] = satoshi_round(send_value / 2)\n         raw_tx = node.createrawtransaction(inputs, outputs)\n         signed_tx = node.signrawtransaction(raw_tx)[\"hex\"]\n-        txid = node.sendrawtransaction(signed_tx)\n+        node.sendrawtransaction(signed_tx)\n \n     while (node.getmempoolinfo()['size'] > 0):\n         node.generate(1)\n@@ -552,8 +447,8 @@ def gen_return_txouts():\n     # Some pre-processing to create a bunch of OP_RETURN txouts to insert into transactions we create\n     # So we have big transactions (and therefore can't fit very many into each block)\n     # create one script_pubkey\n-    script_pubkey = \"6a4d0200\" #OP_RETURN OP_PUSH2 512 bytes\n-    for i in range (512):\n+    script_pubkey = \"6a4d0200\"  # OP_RETURN OP_PUSH2 512 bytes\n+    for i in range(512):\n         script_pubkey = script_pubkey + \"01\"\n     # concatenate 128 txouts of above script_pubkey which we'll insert before the txout for change\n     txouts = \"81\"\n@@ -567,8 +462,8 @@ def gen_return_txouts():\n     return txouts\n \n def create_tx(node, coinbase, to_address, amount):\n-    inputs = [{ \"txid\" : coinbase, \"vout\" : 0}]\n-    outputs = { to_address : amount }\n+    inputs = [{\"txid\": coinbase, \"vout\": 0}]\n+    outputs = {to_address: amount}\n     rawtx = node.createrawtransaction(inputs, outputs)\n     signresult = node.signrawtransaction(rawtx)\n     assert_equal(signresult[\"complete\"], True)\n@@ -581,7 +476,7 @@ def create_lots_of_big_transactions(node, txouts, utxos, num, fee):\n     txids = []\n     for _ in range(num):\n         t = utxos.pop()\n-        inputs=[{ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]}]\n+        inputs = [{\"txid\": t[\"txid\"], \"vout\": t[\"vout\"]}]\n         outputs = {}\n         change = t['amount'] - fee\n         outputs[addr] = satoshi_round(change)\n@@ -606,7 +501,3 @@ def mine_large_block(node, utxos=None):\n     fee = 100 * node.getnetworkinfo()[\"relayfee\"]\n     create_lots_of_big_transactions(node, txouts, utxos, num, fee=fee)\n     node.generate(1)\n-\n-def get_bip9_status(node, key):\n-    info = node.getblockchaininfo()\n-    return info['bip9_softforks'][key]"
      },
      {
        "sha": "54f625514bd9f1e3e24a2db2d6c83287190b55aa",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -20,6 +20,7 @@\n import os\n import time\n import shutil\n+import signal\n import sys\n import subprocess\n import tempfile\n@@ -78,7 +79,7 @@\n     'rawtransactions.py',\n     'reindex.py',\n     # vv Tests less than 30s vv\n-    \"zmq_test.py\",\n+    'zmq_test.py',\n     'mempool_resurrect_test.py',\n     'txn_doublespend.py --mineblock',\n     'txn_clone.py',\n@@ -112,6 +113,7 @@\n     'listsinceblock.py',\n     'p2p-leaktests.py',\n     'wallet-encryption.py',\n+    'uptime.py',\n ]\n \n EXTENDED_SCRIPTS = [\n@@ -123,6 +125,7 @@\n     # vv Tests less than 5m vv\n     'maxuploadtarget.py',\n     'mempool_packages.py',\n+    'dbcrash.py',\n     # vv Tests less than 2m vv\n     'bip68-sequence.py',\n     'getblocktemplate_longpoll.py',\n@@ -137,6 +140,7 @@\n     'bip65-cltv-p2p.py',\n     'bipdersig-p2p.py',\n     'bipdersig.py',\n+    'example_test.py',\n     'getblocktemplate_proposals.py',\n     'txn_doublespend.py',\n     'txn_clone.py --mineblock',\n@@ -390,6 +394,10 @@ def get_next(self):\n             time.sleep(.5)\n             for j in self.jobs:\n                 (name, time0, proc, log_out, log_err) = j\n+                if os.getenv('TRAVIS') == 'true' and int(time.time() - time0) > 20 * 60:\n+                    # In travis, timeout individual tests after 20 minutes (to stop tests hanging and not\n+                    # providing useful output.\n+                    proc.send_signal(signal.SIGINT)\n                 if proc.poll() is not None:\n                     log_out.seek(0), log_err.seek(0)\n                     [stdout, stderr] = [l.read().decode('utf-8') for l in (log_out, log_err)]"
      },
      {
        "sha": "b20d6f5cb62bfe755905bf89d06720fd67390881",
        "filename": "test/functional/uptime.py",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/uptime.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/uptime.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/uptime.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -0,0 +1,32 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the RPC call related to the uptime command.\n+\n+Test corresponds to code in rpc/server.cpp.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+\n+class UptimeTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        self._test_uptime()\n+\n+    def _test_uptime(self):\n+        wait_time = 10\n+        self.nodes[0].setmocktime(int(time.time() + wait_time))\n+        assert(self.nodes[0].uptime() >= wait_time)\n+\n+\n+if __name__ == '__main__':\n+    UptimeTest().main()"
      },
      {
        "sha": "569cc46e6cf92cea3c3e3d991673f8710056c825",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -7,7 +7,7 @@\n import os\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (assert_equal, bitcoind_processes)\n+from test_framework.util import assert_equal\n \n \n def read_dump(file_name, addrs, hd_master_addr_old):\n@@ -95,7 +95,7 @@ def run_test (self):\n \n         #encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n-        bitcoind_processes[0].wait()\n+        self.bitcoind_processes[0].wait()\n         self.nodes[0] = self.start_node(0, self.options.tmpdir, self.extra_args[0])\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:"
      },
      {
        "sha": "ba72918fe1564dcf09153c5711ef9e9e8c373fc4",
        "filename": "test/functional/wallet-encryption.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/wallet-encryption.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/wallet-encryption.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-encryption.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -6,12 +6,10 @@\n \n import time\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import BitcoinTestFramework, BITCOIND_PROC_WAIT_TIMEOUT\n from test_framework.util import (\n     assert_equal,\n     assert_raises_jsonrpc,\n-    bitcoind_processes,\n-    BITCOIND_PROC_WAIT_TIMEOUT,\n )\n \n class WalletEncryptionTest(BitcoinTestFramework):\n@@ -33,7 +31,7 @@ def run_test(self):\n \n         # Encrypt the wallet\n         self.nodes[0].encryptwallet(passphrase)\n-        bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n \n         # Test that the wallet is encrypted"
      },
      {
        "sha": "dfd3dc83c523a47ca59a9700ff2051b2238ed7d9",
        "filename": "test/functional/wallet-hd.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/wallet-hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/wallet-hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-hd.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -8,7 +8,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes_bi,\n-    assert_start_raises_init_error\n )\n import os\n import shutil\n@@ -27,7 +26,7 @@ def run_test (self):\n \n         # Make sure can't switch off usehd after wallet creation\n         self.stop_node(1)\n-        assert_start_raises_init_error(1, self.options.tmpdir, ['-usehd=0'], 'already existing HD wallet')\n+        self.assert_start_raises_init_error(1, self.options.tmpdir, ['-usehd=0'], 'already existing HD wallet')\n         self.nodes[1] = self.start_node(1, self.options.tmpdir, self.extra_args[1])\n         connect_nodes_bi(self.nodes, 0, 1)\n "
      },
      {
        "sha": "ff51cba4b3f64f94c6de22081400a97a25e63cd1",
        "filename": "test/functional/walletbackup.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/walletbackup.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -30,10 +30,11 @@\n Shutdown again, restore using importwallet,\n and confirm again balances are correct.\n \"\"\"\n+from random import randint\n+import shutil\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from random import randint\n \n class WalletBackupTest(BitcoinTestFramework):\n "
      },
      {
        "sha": "e4d40520ef6361e62cdcd50eb6f5147b574ef4c8",
        "filename": "test/functional/zapwallettxes.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zapwallettxes.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -70,7 +70,7 @@ def run_test (self):\n         self.nodes[0] = self.start_node(0,self.options.tmpdir, [\"-zapwallettxes=1\"])\n         \n         assert_raises(JSONRPCException, self.nodes[0].gettransaction, [txid3])\n-        #there must be a expection because the unconfirmed wallettx0 must be gone by now\n+        #there must be an exception because the unconfirmed wallettx0 must be gone by now\n \n         tx0 = self.nodes[0].gettransaction(txid0)\n         assert_equal(tx0['txid'], txid0) #tx0 (confirmed) must still be available because it was confirmed"
      },
      {
        "sha": "26c946d215eb36bffe80c060c4e11fb0f930500f",
        "filename": "test/functional/zmq_test.py",
        "status": "modified",
        "additions": 35,
        "deletions": 30,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3112ed7ab229a021f9f3a3001231c61e6384b968/test/functional/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zmq_test.py?ref=3112ed7ab229a021f9f3a3001231c61e6384b968",
        "patch": "@@ -8,15 +8,15 @@\n import struct\n \n from test_framework.test_framework import BitcoinTestFramework, SkipTest\n-from test_framework.util import *\n+from test_framework.util import (assert_equal,\n+                                 bytes_to_hex_str,\n+                                 )\n \n class ZMQTest (BitcoinTestFramework):\n \n     def __init__(self):\n         super().__init__()\n-        self.num_nodes = 4\n-\n-    port = 28332\n+        self.num_nodes = 2\n \n     def setup_nodes(self):\n         # Try to import python3-zmq. Skip this test if the import fails.\n@@ -28,82 +28,87 @@ def setup_nodes(self):\n         # Check that bitcoin has been built with ZMQ enabled\n         config = configparser.ConfigParser()\n         if not self.options.configfile:\n-            self.options.configfile = os.path.dirname(__file__) + \"/config.ini\"\n+            self.options.configfile = os.path.dirname(__file__) + \"/../config.ini\"\n         config.read_file(open(self.options.configfile))\n \n         if not config[\"components\"].getboolean(\"ENABLE_ZMQ\"):\n             raise SkipTest(\"bitcoind has not been built with zmq enabled.\")\n \n         self.zmqContext = zmq.Context()\n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n+        self.zmqSubSocket.set(zmq.RCVTIMEO, 60000)\n         self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashblock\")\n         self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashtx\")\n-        self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % self.port)\n-        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args=[\n-            ['-zmqpubhashtx=tcp://127.0.0.1:'+str(self.port), '-zmqpubhashblock=tcp://127.0.0.1:'+str(self.port)],\n-            [],\n-            [],\n-            []\n-            ])\n+        ip_address = \"tcp://127.0.0.1:28332\"\n+        self.zmqSubSocket.connect(ip_address)\n+        extra_args = [['-zmqpubhashtx=%s' % ip_address, '-zmqpubhashblock=%s' % ip_address], []]\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n     def run_test(self):\n-        self.sync_all()\n+        try:\n+            self._zmq_test()\n+        finally:\n+            # Destroy the zmq context\n+            self.log.debug(\"Destroying zmq context\")\n+            self.zmqContext.destroy(linger=None)\n \n+    def _zmq_test(self):\n         genhashes = self.nodes[0].generate(1)\n         self.sync_all()\n \n-        self.log.info(\"listen...\")\n+        self.log.info(\"Wait for tx\")\n         msg = self.zmqSubSocket.recv_multipart()\n         topic = msg[0]\n         assert_equal(topic, b\"hashtx\")\n         body = msg[1]\n         msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0) #must be sequence 0 on hashtx\n+        assert_equal(msgSequence, 0)  # must be sequence 0 on hashtx\n \n+        self.log.info(\"Wait for block\")\n         msg = self.zmqSubSocket.recv_multipart()\n         topic = msg[0]\n         body = msg[1]\n         msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0) #must be sequence 0 on hashblock\n+        assert_equal(msgSequence, 0)  # must be sequence 0 on hashblock\n         blkhash = bytes_to_hex_str(body)\n \n-        assert_equal(genhashes[0], blkhash) #blockhash from generate must be equal to the hash received over zmq\n+        assert_equal(genhashes[0], blkhash)  # blockhash from generate must be equal to the hash received over zmq\n \n+        self.log.info(\"Generate 10 blocks (and 10 coinbase txes)\")\n         n = 10\n         genhashes = self.nodes[1].generate(n)\n         self.sync_all()\n \n         zmqHashes = []\n         blockcount = 0\n-        for x in range(0,n*2):\n+        for x in range(n * 2):\n             msg = self.zmqSubSocket.recv_multipart()\n             topic = msg[0]\n             body = msg[1]\n             if topic == b\"hashblock\":\n                 zmqHashes.append(bytes_to_hex_str(body))\n                 msgSequence = struct.unpack('<I', msg[-1])[-1]\n-                assert_equal(msgSequence, blockcount+1)\n+                assert_equal(msgSequence, blockcount + 1)\n                 blockcount += 1\n \n-        for x in range(0,n):\n-            assert_equal(genhashes[x], zmqHashes[x]) #blockhash from generate must be equal to the hash received over zmq\n+        for x in range(n):\n+            assert_equal(genhashes[x], zmqHashes[x])  # blockhash from generate must be equal to the hash received over zmq\n \n-        #test tx from a second node\n+        self.log.info(\"Wait for tx from second node\")\n+        # test tx from a second node\n         hashRPC = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n         self.sync_all()\n \n         # now we should receive a zmq msg because the tx was broadcast\n         msg = self.zmqSubSocket.recv_multipart()\n         topic = msg[0]\n         body = msg[1]\n-        hashZMQ = \"\"\n-        if topic == b\"hashtx\":\n-            hashZMQ = bytes_to_hex_str(body)\n-            msgSequence = struct.unpack('<I', msg[-1])[-1]\n-            assert_equal(msgSequence, blockcount+1)\n-\n-        assert_equal(hashRPC, hashZMQ) #blockhash from generate must be equal to the hash received over zmq\n+        assert_equal(topic, b\"hashtx\")\n+        hashZMQ = bytes_to_hex_str(body)\n+        msgSequence = struct.unpack('<I', msg[-1])[-1]\n+        assert_equal(msgSequence, blockcount + 1)\n \n+        assert_equal(hashRPC, hashZMQ)  # txid from sendtoaddress must be equal to the hash received over zmq\n \n if __name__ == '__main__':\n-    ZMQTest ().main ()\n+    ZMQTest().main()"
      }
    ]
  }
]