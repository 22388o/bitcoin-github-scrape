DrahtBot,2020-03-30 02:43:17,<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-605752932,605752932,
sipa,2020-03-30 04:48:24,"Here is one caveat that may not be obvious: whenever you have some iterator/pointer/object that stores objects of type `B` (which supertype `A`), it should *not* be possible to construct a `Span<A>` for it, despite `B*` being implicitly convertible to `A*`. The reason is that `A` and `B` may have different sizes, so pointer arithmetic in one may not correspond to the right operations in the other.",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-605780145,605780145,
sipa,2020-05-01 18:28:21,Rebased after #18591 (which included a commit from this PR).,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-622505998,622505998,
jb55,2020-05-02 01:36:38,I was trying to MakeSpan on a prevector today and I realized I needed this PR. Concept ACK. will test and ACK soon.,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-622650104,622650104,
jb55,2020-05-02 08:12:06,"Seems to be working well on a branch I'm testing. one spooky thing I ran into was:\n\n```c++\nstatic std::vector<unsigned char> RandomData()\n{\n    uint256 r = InsecureRand256();\n    return std::vector<unsigned char>(r.begin(), r.end());\n}\n\nauto d = MakeSpan(RandomData());\nrb1.insert(d)\nBOOST_CHECK(rb1.contains(d));\n```\n\n```\nRunning 12 test cases...\ntest/bloom_tests.cpp",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-622846597,622846597,
aminroosta,2020-05-02 08:53:33," I may be wrong, but i think in your first example, the return value of `RandomData()` is destructed immediately.\n\n```c++\nauto d = MakeSpan(RandomData());\n// d contains dangling pointers by this line.\nrb1.insert(d)\nBOOST_CHECK(rb1.contains(d));\n```\n\nMakeSpan takes a [universal reference](https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-Referen",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-622899783,622899783,
jb55,2020-05-02 09:04:48,@aminroosta I understand some of those words. thanks!,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-622914063,622914063,
sipa,2020-05-02 17:20:46,"Yes, exactly what @aminroosta said.",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-622986496,622986496,
sipa,2020-05-02 23:51:16,"@jb55 @aminroosta Ok, interesting. I guess the reasoning is that an `std::span` should really be thought of a a ""reference + size"" thing. You can't pass a temporary to a function that takes a non-const lvalue reference (because it would be surprising to make modifications to an input that's going to be discarded) - similarly you shouldn't be able to pass a temporary to a function that takes a muta",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-623030711,623030711,
promag,2020-05-03 22:20:07,"Concept ACK. I'm curious why span constructors aren't declared `explicit` - I'm aware `std::span` doesn't have them - since this is the project implementation and ""should"" follow #11112.",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-623191588,623191588,
sipa,2020-05-03 22:39:36,"@promag That would partially defeat the purpose, in my view. With std::span/Span, the point is that you can write a single function that accepts a span as input, and it will automatically work with whatever continuous container you pass it. This is safe as spans are restricted in features to be a strict subset of those containers.",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-623194442,623194442,
promag,2020-05-03 22:46:52,"@sipa right, I see you have edited your comment. Don't get me wrong, I like/prefer this way.",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-623195515,623195515,
sipa,2020-05-05 18:42:01,"I added a workaround that seems necessary on CentOS 7 (GCC 4.8.5). It seems that when both a function `template<typename T> F(T&)` and `template<typename T> F(T&&)` are present, passing an lvalue rerence is treated as ambiguous there (other compilers correctly prefer the explicitly lvalue reference first version over the universal reference in the second).",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-624235722,624235722,
jb55,2020-05-16 01:29:49,"```\n-----BEGIN OPENTIMESTAMPS MESSAGE-----\n\n- -----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nTested ACK 1f790a1147ad9a5fe06987d84b6cd71f91cbec4b \n- -----BEGIN PGP SIGNATURE-----\n\niHUEARYIAB0WIQTgLT/U60WFpjUxwdDhv8uQof96HAUCXr8/HwAKCRDhv8uQof96\nHHdWAP4oLAWAFyl89rmXCkOLhabnQH0eA1WuQLms9sGQ/0ZuIAEA95NqgBdDXeNy\nLNZONShuQyUhND7sV3DFtdnwlMdwRAM=\n=eezA\n- -----END PGP SIGNATURE",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-629568997,629568997,
fanquake,2020-05-16 01:44:24,"@jb55 Which key did you use to sign this? I'm seeing `E02D3FD4EB4585A63531C1D0E1BFCB90A1FF7A1C` which doesn't seem to match the one I have for you `1514A56A573AADFCA0EBFF908FB01059E7960F33` (from your website).\n",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-629570690,629570690,
jb55,2020-05-16 01:51:38,thanks for verifying :) @fanquake https://jb55.com/s/8f099795a120ae13.txt ,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-629571454,629571454,
laanwj,2020-06-04 16:48:05,"~~Code review ACK 2676aeadfa0e43dcaaccc4720623cdfe0beed528~~\nCode review ACK 26acc8dd9b512f220c1facdba2c5de7976d3c258",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-638976042,638976042,
sipa,2020-06-04 18:06:35,Added a commit that adds a bunch of asserts that are enabled on `-DDEBUG`.,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-639016510,639016510,
Empact,2020-06-05 00:22:12,Code review ACK https://github.com/bitcoin/bitcoin/pull/18468/commits/3d9ef83776f831a1f077674c16807391ec5f5d57,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-639187198,639187198,
practicalswift,2020-06-05 07:33:00,Concept ACK,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-639310657,639310657,
sipa,2020-06-24 02:11:45,@jb55 @theuni I've opened https://github.com/bitcoin/bitcoin/pull/19367 to document some of the pitfalls you mentioned in comments above.,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-648539738,648539738,
fjahr,2020-06-24 11:11:12,post-merge code review ACK,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-648756399,648756399,
theuni,2020-06-24 17:05:39,"Continuing the discussion from here: https://github.com/bitcoin/bitcoin/pull/19367/files#r445025361 because I don't know where else to stick it.\n\nI believe that adding clang's lifetimebound attribute points out a valid issue here:\n```\nutil/spanparsing.cpp:46:28: warning: temporary whose address is used as value of local variable 'ret' will be destroyed at the end of the full-expression [-W",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-648946546,648946546,
jnewbery,2020-06-24 18:21:43,Should any function that returns a subspan of the passed-in span be declared with non-const argument? Would that prevent temporaries from being passed in? Or is there a better way to do that?,https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-648987266,648987266,
practicalswift,2020-06-24 21:57:31,"@theuni \n\n> It would be really easy to miss in review, though :(\n\nAgreed! It is very easy to get things wrong when reasoning about lifetime issues. This is really subtle topic filled with gotchas.\n\nThe introduction of `std::span` and `std::string_view` will bring a new golden age of use-after-frees/returns to C++ :)\n\nPersonally I'm not convinced that it is a good idea to use `std::",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-649094742,649094742,
jonatack,2020-06-25 16:37:31,"> MakeSpan takes a [universal reference](https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11) (`V&&`) in this PR.\n\n@aminroosta Thank you -- I found your link (and the [downloadable presentation slides](https://onedrive.live.com/redir?resid=F1B8FF18A2AEC5C5!1062&page=Download)) really informative.",https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-649679286,649679286,
aminroosta,2020-04-03 13:05:19,"This will cover the generic copy constructor as well, because `Span<O>` has both `.data()` & `.size()` methods.\n```c++\n    template <typename O, typename std::enable_if<std::is_convertible<O (*)[], C (*)[]>::value, int>::type = 0>\n    constexpr Span(const Span<O>& other) noexcept : m_data(other.m_data), m_size(other.m_size) {}\n```",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r402990362,402990362,src/span.h
sipa,2020-04-04 05:34:08,"That's true, though the specification and common other span implementations still have a default copy constructor too - I don't know why.",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r403428718,403428718,src/span.h
jb55,2020-05-02 08:10:32,"copy paste typo? shouldn't this be:\n```suggestion\n    const Span<const char> another_span{another_str};\n```",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r418929147,418929147,src/test/fuzz/span.cpp
aminroosta,2020-05-02 11:23:27,"@sipa @jb55 I think passing any rvalue/temporary here will result in dangling pointers.\n\nI did check the docs and the [c++ 20 span](https://en.cppreference.com/w/cpp/container/span/span) has a ctor that takes `R&&` ...\n\n```c++\ntemplate <class R>\nconstexpr span(R&& r);\n```\nhowever It says R must model [borrowed_range](https://en.cppreference.com/w/cpp/ranges/borrowed_range). \nIn o",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r418946459,418946459,src/span.h
sipa,2020-05-02 23:44:29,"Thanks, fixed!",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r419022378,419022378,src/test/fuzz/span.cpp
sipa,2020-05-02 23:55:42,"I've made some changes, and commented below.",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r419023328,419023328,src/span.h
jb55,2020-05-03 17:13:21,"```suggestion\n    const Span<const char> another_span{another_str};\n```\n:sweat_smile: ",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r419132291,419132291,src/test/fuzz/span.cpp
Empact,2020-05-16 05:07:15,nit: could pass `descriptor` directly to `CheckChecksum`,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r426119379,426119379,src/script/descriptor.cpp
Empact,2020-05-16 05:15:30,nit: should we assert or otherwise check against end < data here?,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r426119873,426119873,src/span.h
sipa,2020-05-27 20:28:36,"I'd rather not. This is an extremely lightweight object, so adding any kind of runtime checking may have significant performance impact.",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r431422379,431422379,src/span.h
sipa,2020-05-27 20:48:54,That doesn't work; `CheckChecksum` needs a reference to a mutable `Span<const char>` (it's an input/output argument). You can't bind a temporary to that.,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r431432959,431432959,src/script/descriptor.cpp
laanwj,2020-06-04 16:47:48,You could add the check only if `#ifdef DEBUG`. Then at least these kind of out of bounds issues will be flagged in debug builds. No strong opinion though.,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r435402480,435402480,src/span.h
sipa,2020-06-04 18:44:56,"Good idea, done.",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r435476137,435476137,src/span.h
promag,2020-06-11 21:20:24,"3d9ef83776f831a1f077674c16807391ec5f5d57\n\n#define ASSERT_IF_DEBUG ?",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r439076706,439076706,src/span.h
sipa,2020-06-17 22:13:01,"Good idea, done!",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r441862983,441862983,src/span.h
theuni,2020-06-19 18:54:58,"Could you help me understand the lifetime of a temporary here? It seems like you'd want this to be lvalue only.\nFor example, this works and passes undefined/memory sanitizer checks, but I don't understand why:\n```c++\nSpan<const char> foo(""bar"");\nprintf(""foo: %s\n"", foo.data());\n```\nI would have expected the lifetime of the literal to end after the constructor, but the memory appears to",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r442998211,442998211,src/span.h
sipa,2020-06-19 19:01:29,"That's a good question, but not the right example. String literals have static lifetime in C++, so in this specific case there is no problem.\n\nHowever, there are pitfalls around constructing a Span from a temporary, see https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-623030711 for more discussion. It's an inherent problem with objects that store references unfortunately, and present",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443000807,443000807,src/span.h
rajarshimaitra,2020-06-22 14:50:36,"Which modification in `span.h` exactly is allowing us to use list initialization? \n",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443616796,443616796,src/script/interpreter.cpp
rajarshimaitra,2020-06-22 14:50:48,"This seemed fairly new to me. Here's what I understood so far. Depending upon the context (weather DEBUG or not) we want to evaluate some of the methods differently. In non-debug mode we want them to be `constexpr` whereas in debug mode we want them to evaluate at run time. Thus we are defining some debug specific declaration here.\nIs that correct understanding, and can you add if there's someth",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443616961,443616961,src/span.h
rajarshimaitra,2020-06-22 14:53:25,Can you elaborate a little more on this specific restriction? I read your comment on [#18648(comment)](https://github.com/bitcoin/bitcoin/pull/18468#issuecomment-623030711) but was wondering what if we want to cast a span from an rvalue reference then modify its values for whatever reason? Is it something not possible or an inherently stupid thing to do?  ,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443618892,443618892,src/span.h
rajarshimaitra,2020-06-22 15:00:49,"Can you explain why we are not returning `Span<V>(v.data(), v.size())` or something like that here? More precisely, I am confused about how `V v` value is being automatically cast into a span?",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443624418,443624418,src/span.h
rajarshimaitra,2020-06-22 15:10:43,Why don't we want assertions to happen in non-debug mode?,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443631402,443631402,src/span.h
rajarshimaitra,2020-06-22 15:18:35,"This was wild learning curve. If I try to translate this in English it sounds like:\nIf a `T` type pointer array is convertible into a `C` type pointer array, then only use this constructor.\nDoes that sound correct? \nThen my question is if I pass in the `T` at the time of construction, how does the compiler know about the `C` in order to evaluate the above statement?     ",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r443636758,443636758,src/span.h
sipa,2020-06-24 02:10:52,Follow-up: https://github.com/bitcoin/bitcoin/pull/19367,https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444604838,444604838,src/span.h
sipa,2020-06-24 02:16:06,"This is not list initialization, but value initialization (see https://en.cppreference.com/w/cpp/language/value_initialization). In short, `Type{arg1, arg2}` is the preferred way in >=C++11 to invoke a type's constructor.\n\nIn this case, it's effectively calling `Span<const valtype>(witness.stack)`.",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444606254,444606254,src/script/interpreter.cpp
sipa,2020-06-24 02:21:52,"Note that `constexpr` for a function does not mean that the function will necessarily always be (entirely) evaluated at compile time; only that at least for some inputs, parts of the function can be evaluated at compile time (C++20 adds a `consteval` keyword for things that are guaranteed to be evaluated at compile time).\n\nThe problem is that (in C++11) we can't mark functions `constexpr` if t",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444607841,444607841,src/span.h
sipa,2020-06-24 02:23:10,"I've documented this here: https://github.com/bitcoin/bitcoin/pull/19367/files#diff-9f772f6f8808fe74c65228b3a74a07c2R62-R79\n\nDoes that explain?",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444608256,444608256,src/span.h
sipa,2020-06-24 02:29:55,"It's converting the argument to the return type, so this is effectively evaluating `Span<typename std::remove_pointer<decltype(v.data())>::type>(v)`. As `Span` has a constructor for converting from any data type that exposes a proper `size()` and `data()` member function (the range-like object constructor), so that's what is invoked here.\n\nThe reason for not calling the pointer/size constructo",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444610007,444610007,src/span.h
sipa,2020-06-24 02:32:16,"Performance.\n\n`Span` is an extreme lightweight object, which I imagine we'll use in very tight loops or other performance critical situations. In normal production code these asserts would be an unreasonable burden. But at the same time, it's nice to be able to verify in tests that these properties hold, so they're enabled in DEBUG mode.\n\n",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444610618,444610618,src/span.h
sipa,2020-06-24 02:37:42,"At least in C++11, because you're telling it what `C` is, perhaps without knowing it.\n\nYou could invoke this constructor like this:\n\n```c++\nint arr[5] = {1, 2, 3, 4, 5};\nSpan<const int> sp{&arr[1], 3};\n```\n\nWhich is actually a conversion, as `&arr[1]` has type `T`=`int`, but `C`=`const int`.\n\nIn other contexts, `C` may be set implicitly. For example:\n\n```c++\nvoid Foo(Sp",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444611936,444611936,src/span.h
jnewbery,2020-06-24 14:38:38,"The casts in spanparsing.cpp can now be removed:\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/util/spanparsing.cpp#L16\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/util/spanparsing.cpp#L25",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r444943525,444943525,src/span.h
jnewbery,2020-06-24 16:09:32,"I'm pretty sure that these default declarations are unnecessary, since they'll be generated by default anyway.\n\nThe only place I'm aware of needing to declare default ctors/assignment operators is when you're using a unique_ptr for an incomplete type, and you need to declare them in the header file and define them (as default) in the implementation file (eg when using a unique_ptr for a pimpl)",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r445008787,445008787,src/span.h
jonatack,2020-06-25 15:42:59,"> I'm pretty sure that these default declarations are unnecessary, since they'll be generated by default anyway.\n\nBuilt, tested, and fuzzed this PR and #19326 with the default copy constructor and assignment operator in `span.h` both removed and yes, AFAICT it seems fine.\n",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r445655300,445655300,src/span.h
theuni,2020-06-25 16:01:34,"I believe the default declarations aren't actually a no-op here and may be considered harmful as default move ctor/assignment is disabled when a copy/assignment oper are provided.\n\nSee [here under  Implicitly-declared move constructor for reference](https://en.cppreference.com/w/cpp/language/move_constructor). From a quick local test, it seems that even declaring a ```= default``` constructor/",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r445667901,445667901,src/span.h
jnewbery,2020-06-25 16:15:00,"> it seems that even declaring a = default constructor/assignment operator is enough to disable the implicit moves.\n\nFascinating! I didn't know that.\n\n> +1 for removing them unless there was a reason for disabling those moves.\n\nIf this is the case, presumably it'd be better to explicitly delete those move ctor/assigments than rely on this behavior.\n",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r445676920,445676920,src/span.h
theuni,2020-06-25 16:24:01,"> > it seems that even declaring a = default constructor/assignment operator is enough to disable the implicit moves.\n> \n> Fascinating! I didn't know that.\n\nPlease double-check me on this! I'm assuming that based on my testing with lifetimebound, but I haven't managed to track down a definitive answer.",https://github.com/bitcoin/bitcoin/pull/18468#discussion_r445682882,445682882,src/span.h
