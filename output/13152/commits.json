[
  {
    "sha": "a2eb6f540538d32725aecf678301a96247db6fd9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMmViNmY1NDA1MzhkMzI3MjVhZWNmNjc4MzAxYTk2MjQ3ZGI2ZmQ5",
    "commit": {
      "author": {
        "name": "chris-belcher",
        "email": "chris-belcher@users.noreply.github.com",
        "date": "2018-05-02T12:19:40Z"
      },
      "committer": {
        "name": "chris-belcher",
        "email": "chris-belcher@users.noreply.github.com",
        "date": "2018-09-17T21:55:23Z"
      },
      "message": "[rpc] Add getnodeaddresses RPC command\n\nNew getnodeaddresses call gives access via RPC to the peers known by\nthe node. It may be useful for bitcoin wallets to broadcast their\ntransactions over tor for improved privacy without using the\ncentralized DNS seeds. getnodeaddresses is very similar to the getaddr\np2p method.\n\nTests the new rpc call by feeding IP address to a test node via the p2p\nprotocol, then obtaining someone of those addresses with\ngetnodeaddresses and checking that they are a subset.",
      "tree": {
        "sha": "b0932b58f76526fa61d9e43a7fc6935e16d3d836",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b0932b58f76526fa61d9e43a7fc6935e16d3d836"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a2eb6f540538d32725aecf678301a96247db6fd9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2eb6f540538d32725aecf678301a96247db6fd9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a2eb6f540538d32725aecf678301a96247db6fd9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2eb6f540538d32725aecf678301a96247db6fd9/comments",
    "author": {
      "login": "chris-belcher",
      "id": 8398185,
      "node_id": "MDQ6VXNlcjgzOTgxODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chris-belcher",
      "html_url": "https://github.com/chris-belcher",
      "followers_url": "https://api.github.com/users/chris-belcher/followers",
      "following_url": "https://api.github.com/users/chris-belcher/following{/other_user}",
      "gists_url": "https://api.github.com/users/chris-belcher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chris-belcher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
      "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
      "repos_url": "https://api.github.com/users/chris-belcher/repos",
      "events_url": "https://api.github.com/users/chris-belcher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "chris-belcher",
      "id": 8398185,
      "node_id": "MDQ6VXNlcjgzOTgxODU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chris-belcher",
      "html_url": "https://github.com/chris-belcher",
      "followers_url": "https://api.github.com/users/chris-belcher/followers",
      "following_url": "https://api.github.com/users/chris-belcher/following{/other_user}",
      "gists_url": "https://api.github.com/users/chris-belcher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chris-belcher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
      "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
      "repos_url": "https://api.github.com/users/chris-belcher/repos",
      "events_url": "https://api.github.com/users/chris-belcher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4901c00792c1dabae4bb01e6373c9b1ed9ef3008",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4901c00792c1dabae4bb01e6373c9b1ed9ef3008",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4901c00792c1dabae4bb01e6373c9b1ed9ef3008"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 97,
      "deletions": 0
    },
    "files": [
      {
        "sha": "72526f53551b05ee92ccda8c7d7e78c9bb94271f",
        "filename": "doc/release-notes-13152.md",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2eb6f540538d32725aecf678301a96247db6fd9/doc/release-notes-13152.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2eb6f540538d32725aecf678301a96247db6fd9/doc/release-notes-13152.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-13152.md?ref=a2eb6f540538d32725aecf678301a96247db6fd9",
        "patch": "@@ -0,0 +1,4 @@\n+New RPC methods\n+------------\n+\n+- `getnodeaddresses` returns peer addresses known to this node. It may be used to connect to nodes over TCP without using the DNS seeds.\n\\ No newline at end of file"
      },
      {
        "sha": "649e222c3953e5aebedf0a376bacead9f486986d",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2eb6f540538d32725aecf678301a96247db6fd9/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2eb6f540538d32725aecf678301a96247db6fd9/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=a2eb6f540538d32725aecf678301a96247db6fd9",
        "patch": "@@ -163,6 +163,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"rescanblockchain\", 0, \"start_height\"},\n     { \"rescanblockchain\", 1, \"stop_height\"},\n     { \"createwallet\", 1, \"disable_private_keys\"},\n+    { \"getnodeaddresses\", 0, \"count\"},\n };\n // clang-format on\n "
      },
      {
        "sha": "846d90cd0a8c032cc96e936bc61acfd7454f2854",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2eb6f540538d32725aecf678301a96247db6fd9/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2eb6f540538d32725aecf678301a96247db6fd9/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=a2eb6f540538d32725aecf678301a96247db6fd9",
        "patch": "@@ -626,6 +626,58 @@ static UniValue setnetworkactive(const JSONRPCRequest& request)\n     return g_connman->GetNetworkActive();\n }\n \n+static UniValue getnodeaddresses(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"getnodeaddresses ( count )\\n\"\n+            \"\\nReturn known addresses which can potentially be used to find new nodes in the network\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"count\\\"    (numeric, optional) How many addresses to return. Limited to the smaller of \" + std::to_string(ADDRMAN_GETADDR_MAX) +\n+                \" or \" + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + \"% of all known addresses. (default = 1)\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"time\\\": ttt,                (numeric) Timestamp in seconds since epoch (Jan 1 1970 GMT) keeping track of when the node was last seen\\n\"\n+            \"    \\\"services\\\": n,              (numeric) The services offered\\n\"\n+            \"    \\\"address\\\": \\\"host\\\",          (string) The address of the node\\n\"\n+            \"    \\\"port\\\": n                   (numeric) The port of the node\\n\"\n+            \"  }\\n\"\n+            \"  ,....\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getnodeaddresses\", \"8\")\n+            + HelpExampleRpc(\"getnodeaddresses\", \"8\")\n+        );\n+    }\n+    if (!g_connman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n+\n+    int count = 1;\n+    if (!request.params[0].isNull()) {\n+        count = request.params[0].get_int();\n+        if (count <= 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Address count out of range\");\n+        }\n+    }\n+    // returns a shuffled list of CAddress\n+    std::vector<CAddress> vAddr = g_connman->GetAddresses();\n+    UniValue ret(UniValue::VARR);\n+\n+    int address_return_count = std::min<int>(count, vAddr.size());\n+    for (int i = 0; i < address_return_count; ++i) {\n+        UniValue obj(UniValue::VOBJ);\n+        const CAddress& addr = vAddr[i];\n+        obj.pushKV(\"time\", (int)addr.nTime);\n+        obj.pushKV(\"services\", (uint64_t)addr.nServices);\n+        obj.pushKV(\"address\", addr.ToStringIP());\n+        obj.pushKV(\"port\", addr.GetPort());\n+        ret.push_back(obj);\n+    }\n+    return ret;\n+}\n+\n // clang-format off\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         argNames\n@@ -642,6 +694,7 @@ static const CRPCCommand commands[] =\n     { \"network\",            \"listbanned\",             &listbanned,             {} },\n     { \"network\",            \"clearbanned\",            &clearbanned,            {} },\n     { \"network\",            \"setnetworkactive\",       &setnetworkactive,       {\"state\"} },\n+    { \"network\",            \"getnodeaddresses\",       &getnodeaddresses,       {\"count\"} },\n };\n // clang-format on\n "
      },
      {
        "sha": "1e525214fac4b4e7cf0d6c0ed107bc9a4edb2100",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2eb6f540538d32725aecf678301a96247db6fd9/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2eb6f540538d32725aecf678301a96247db6fd9/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=a2eb6f540538d32725aecf678301a96247db6fd9",
        "patch": "@@ -13,11 +13,14 @@\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than_or_equal,\n+    assert_greater_than,\n     assert_raises_rpc_error,\n     connect_nodes_bi,\n     p2p_port,\n     wait_until,\n )\n+from test_framework.mininode import P2PInterface\n+from test_framework.messages import CAddress, msg_addr, NODE_NETWORK, NODE_WITNESS\n \n class NetTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -31,6 +34,7 @@ def run_test(self):\n         self._test_getnetworkinginfo()\n         self._test_getaddednodeinfo()\n         self._test_getpeerinfo()\n+        self._test_getnodeaddresses()\n \n     def _test_connection_count(self):\n         # connect_nodes_bi connects each node to the other\n@@ -101,5 +105,40 @@ def _test_getpeerinfo(self):\n         assert_equal(peer_info[0][0]['minfeefilter'], Decimal(\"0.00000500\"))\n         assert_equal(peer_info[1][0]['minfeefilter'], Decimal(\"0.00001000\"))\n \n+    def _test_getnodeaddresses(self):\n+        self.nodes[0].add_p2p_connection(P2PInterface())\n+\n+        # send some addresses to the node via the p2p message addr\n+        msg = msg_addr()\n+        imported_addrs = []\n+        for i in range(256):\n+            a = \"123.123.123.{}\".format(i)\n+            imported_addrs.append(a)\n+            addr = CAddress()\n+            addr.time = 100000000\n+            addr.nServices = NODE_NETWORK | NODE_WITNESS\n+            addr.ip = a\n+            addr.port = 8333\n+            msg.addrs.append(addr)\n+        self.nodes[0].p2p.send_and_ping(msg)\n+\n+        # obtain addresses via rpc call and check they were ones sent in before\n+        REQUEST_COUNT = 10\n+        node_addresses = self.nodes[0].getnodeaddresses(REQUEST_COUNT)\n+        assert_equal(len(node_addresses), REQUEST_COUNT)\n+        for a in node_addresses:\n+            assert_greater_than(a[\"time\"], 1527811200) # 1st June 2018\n+            assert_equal(a[\"services\"], NODE_NETWORK | NODE_WITNESS)\n+            assert a[\"address\"] in imported_addrs\n+            assert_equal(a[\"port\"], 8333)\n+\n+        assert_raises_rpc_error(-8, \"Address count out of range\", self.nodes[0].getnodeaddresses, -1)\n+\n+        # addrman's size cannot be known reliably after insertion, as hash collisions may occur\n+        # so only test that requesting a large number of addresses returns less than that\n+        LARGE_REQUEST_COUNT = 10000\n+        node_addresses = self.nodes[0].getnodeaddresses(LARGE_REQUEST_COUNT)\n+        assert_greater_than(LARGE_REQUEST_COUNT, len(node_addresses))\n+\n if __name__ == '__main__':\n     NetTest().main()"
      }
    ]
  }
]