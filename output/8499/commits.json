[
  {
    "sha": "3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYWRlMmY2NGNmZTQzYWI1M2U0ODY5ZmZjMzVkNWZkMjMyMDFlMWMx",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T15:53:16Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T15:53:35Z"
      },
      "message": "Add standard limits for P2WSH with tests",
      "tree": {
        "sha": "78eff29685321a56c9456c5d457c4c079aa7ddb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78eff29685321a56c9456c5d457c4c079aa7ddb9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "03dd707dc027fbf6f24120213f8eb66571600374",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03dd707dc027fbf6f24120213f8eb66571600374",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/03dd707dc027fbf6f24120213f8eb66571600374"
      }
    ],
    "stats": {
      "total": 183,
      "additions": 181,
      "deletions": 2
    },
    "files": [
      {
        "sha": "16d1e8680273f878ba43dc1aa12d2cdc6306ed0e",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 111,
        "deletions": 0,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
        "patch": "@@ -1706,6 +1706,116 @@ def test_getblocktemplate_before_lockin(self):\n         assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n         self.nodes[0].setmocktime(0) # undo mocktime\n \n+    def test_non_standard_witness(self):\n+        print(\"\\tTesting detection of non-standard P2WSH witness\")\n+        pad = chr(1).encode('latin-1')\n+\n+        # Create scripts for tests\n+        scripts = []\n+        scripts.append(CScript([OP_DROP] * 100))\n+        scripts.append(CScript([OP_DROP] * 99))\n+        scripts.append(CScript([pad * 59] * 59 + [OP_DROP] * 60))\n+        scripts.append(CScript([pad * 59] * 59 + [OP_DROP] * 61))\n+\n+        p2wsh_scripts = []\n+\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # For each script, generate a pair of P2WSH and P2SH-P2WSH output.\n+        outputvalue = (self.utxo[0].nValue - 1000) // (len(scripts) * 2)\n+        for i in scripts:\n+            p2wsh = CScript([OP_0, sha256(i)])\n+            p2sh = hash160(p2wsh)\n+            p2wsh_scripts.append(p2wsh)\n+            tx.vout.append(CTxOut(outputvalue, p2wsh))\n+            tx.vout.append(CTxOut(outputvalue, CScript([OP_HASH160, p2sh, OP_EQUAL])))\n+        tx.rehash()\n+        txid = tx.sha256\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        # Creating transactions for tests\n+        p2wsh_txs = []\n+        p2sh_txs = []\n+        for i in range(len(scripts)):\n+            p2wsh_tx = CTransaction()\n+            p2wsh_tx.vin.append(CTxIn(COutPoint(txid,i*2)))\n+            p2wsh_tx.vout.append(CTxOut(outputvalue - 5000, CScript([OP_0, hash160(hex_str_to_bytes(\"\"))])))\n+            p2wsh_tx.wit.vtxinwit.append(CTxInWitness())\n+            p2wsh_tx.rehash()\n+            p2wsh_txs.append(p2wsh_tx)\n+            p2sh_tx = CTransaction()\n+            p2sh_tx.vin.append(CTxIn(COutPoint(txid,i*2+1), CScript([p2wsh_scripts[i]])))\n+            p2sh_tx.vout.append(CTxOut(outputvalue - 5000, CScript([OP_0, hash160(hex_str_to_bytes(\"\"))])))\n+            p2sh_tx.wit.vtxinwit.append(CTxInWitness())\n+            p2sh_tx.rehash()\n+            p2sh_txs.append(p2sh_tx)\n+\n+        # Testing native P2WSH\n+        # Witness stack size, excluding witnessScript, over 100 is non-standard\n+        p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        # Non-standard nodes should accept\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[0], True, True)\n+\n+        # Stack element size over 80 bytes is non-standard\n+        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n+        # It can't be used to blind a node to the transaction\n+        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        # Non-standard nodes should accept\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+        # Standard nodes should accept if element size is not over 80 bytes\n+        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n+        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+\n+        # witnessScript size at 3600 bytes is standard\n+        p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n+\n+        # witnessScript size at 3601 bytes is non-standard\n+        p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        # Non-standard nodes should accept\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[3], True, True)\n+\n+        # Repeating the same tests with P2SH-P2WSH\n+        p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n+        self.std_node.test_transaction_acceptance(p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        self.test_node.test_transaction_acceptance(p2sh_txs[0], True, True)\n+        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n+        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        self.test_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n+        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n+        self.test_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n+        self.std_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n+        p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n+        self.std_node.test_transaction_acceptance(p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        self.test_node.test_transaction_acceptance(p2sh_txs[3], True, True)\n+\n+        self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n+        # Valid but non-standard transactions in a block should be accepted by standard node\n+        sync_blocks(self.nodes)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+\n+        self.utxo.pop(0)\n+\n+\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         self.test_node = TestNode() # sets NODE_WITNESS|NODE_NETWORK\n@@ -1778,6 +1888,7 @@ def run_test(self):\n         self.test_segwit_versions()\n         self.test_premature_coinbase_witness_spend()\n         self.test_signature_version_1()\n+        self.test_non_standard_witness()\n         sync_blocks(self.nodes)\n         if self.test_upgrade:\n             self.test_upgrade_after_activation(self.nodes[2], 2)"
      },
      {
        "sha": "020378b5dc4ea09535f4d1fdb02c5459ee79a120",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -1273,6 +1273,10 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n+        // Check for non-standard witness in P2WSH\n+        if (!tx.wit.IsNull() && fRequireStandard && !IsWitnessStandard(tx, view))\n+            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+\n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n         CAmount nValueOut = tx.GetValueOut();"
      },
      {
        "sha": "ae42b2bd74fd8b3bbe38cefa0d4f13a82db7ae9f",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 1,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin developers\n+// Copyright (c) 2009-2016 The Bitcoin developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -154,6 +154,58 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n     return true;\n }\n \n+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n+{\n+    if (tx.IsCoinBase())\n+        return true; // Coinbases are skipped\n+\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        // We don't care if witness for this input is empty, since it must not be bloated.\n+        // If the script is invalid without witness, it would be caught sooner or later during validation.\n+        if (tx.wit.vtxinwit[i].IsNull())\n+            continue;\n+\n+        const CTxOut &prev = mapInputs.GetOutputFor(tx.vin[i]);\n+\n+        // get the scriptPubKey corresponding to this input:\n+        CScript prevScript = prev.scriptPubKey;\n+\n+        if (prevScript.IsPayToScriptHash()) {\n+            std::vector <std::vector<unsigned char> > stack;\n+            // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n+            // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.\n+            // If the check fails at this stage, we know that this txid must be a bad one.\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+                return false;\n+            if (stack.empty())\n+                return false;\n+            prevScript = CScript(stack.back().begin(), stack.back().end());\n+        }\n+\n+        int witnessversion = 0;\n+        std::vector<unsigned char> witnessprogram;\n+\n+        // Non-witness program must not be associated with any witness\n+        if (!prevScript.IsWitnessProgram(witnessversion, witnessprogram))\n+            return false;\n+\n+        // Check P2WSH standard limits\n+        if (witnessversion == 0 && witnessprogram.size() == 32) {\n+            if (tx.wit.vtxinwit[i].scriptWitness.stack.back().size() > MAX_STANDARD_P2WSH_SCRIPT_SIZE)\n+                return false;\n+            size_t sizeWitnessStack = tx.wit.vtxinwit[i].scriptWitness.stack.size() - 1;\n+            if (sizeWitnessStack > MAX_STANDARD_P2WSH_STACK_ITEMS)\n+                return false;\n+            for (unsigned int j = 0; j < sizeWitnessStack; j++) {\n+                if (tx.wit.vtxinwit[i].scriptWitness.stack[j].size() > MAX_STANDARD_P2WSH_STACK_ITEM_SIZE)\n+                    return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;\n \n int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost)"
      },
      {
        "sha": "fb528d74868c56b770998c36799dc853b1bf38eb",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
        "patch": "@@ -30,6 +30,12 @@ static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\n /** Default for -bytespersigop */\n static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\n+/** The maximum number of witness stack items in a standard P2WSH script */\n+static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n+/** The maximum size of each witness stack item in a standard P2WSH script */\n+static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n+/** The maximum size of a standard witnessScript */\n+static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n /**\n  * Standard script verification flags that standard transactions will comply\n  * with. However scripts violating these flags may still be present in valid\n@@ -69,6 +75,12 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n      * @return True if all inputs (scriptSigs) use only standard transaction forms\n      */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n+    /**\n+     * Check if the transaction is over standard P2WSH resources limit:\n+     * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements\n+     * These limits are adequate for multi-signature up to n-of-100 using OP_CHECKSIG, OP_ADD, and OP_EQUAL,\n+     */\n+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n extern unsigned int nBytesPerSigOp;\n "
      }
    ]
  },
  {
    "sha": "4c0c25a604cec39675187507df423cff5d707ab5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzBjMjVhNjA0Y2VjMzk2NzUxODc1MDdkZjQyM2NmZjVkNzA3YWI1",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-01T17:19:33Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T15:53:35Z"
      },
      "message": "Require compressed keys in segwit as policy and disable signing with uncompressed keys for segwit scripts",
      "tree": {
        "sha": "efdefd6a50693257a234ebf9a8988c306a54a12b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efdefd6a50693257a234ebf9a8988c306a54a12b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c0c25a604cec39675187507df423cff5d707ab5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c0c25a604cec39675187507df423cff5d707ab5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c0c25a604cec39675187507df423cff5d707ab5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c0c25a604cec39675187507df423cff5d707ab5/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1"
      }
    ],
    "stats": {
      "total": 85,
      "additions": 49,
      "deletions": 36
    },
    "files": [
      {
        "sha": "814e6c0b6ff94231f48b54830191e0ab819b1e65",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin developers\n+// Copyright (c) 2009-2016 The Bitcoin developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -54,7 +54,8 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n                                                          SCRIPT_VERIFY_LOW_S |\n                                                          SCRIPT_VERIFY_WITNESS |\n-                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM;\n+                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\n+                                                         SCRIPT_VERIFY_WITNESS_PUBKEYTYPE;\n \n /** For convenience, standard but not mandatory verify flags. */\n static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;"
      },
      {
        "sha": "836cf9ee352a04037b7c773abba6fccda5682720",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 6,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -79,8 +79,20 @@ bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n             return false;\n         }\n     } else {\n-          //  Non-canonical public key: neither compressed nor uncompressed\n-          return false;\n+        //  Non-canonical public key: neither compressed nor uncompressed\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool static IsCompressedPubKey(const valtype &vchPubKey) {\n+    if (vchPubKey.size() != 33) {\n+        //  Non-canonical public key: invalid length for compressed key\n+        return false;\n+    }\n+    if (vchPubKey[0] != 0x02 && vchPubKey[0] != 0x03) {\n+        //  Non-canonical public key: invalid prefix for compressed key\n+        return false;\n     }\n     return true;\n }\n@@ -199,10 +211,14 @@ bool CheckSignatureEncoding(const vector<unsigned char> &vchSig, unsigned int fl\n     return true;\n }\n \n-bool static CheckPubKeyEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n-    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchSig)) {\n+bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, const SigVersion &sigversion, ScriptError* serror) {\n+    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n+    // Only compressed keys are accepted in segwit\n+    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+        return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n+    }\n     return true;\n }\n \n@@ -879,7 +895,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         scriptCode.FindAndDelete(CScript(vchSig));\n                     }\n \n-                    if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, serror)) {\n+                    if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n                         //serror is set\n                         return false;\n                     }\n@@ -953,7 +969,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         // Note how this makes the exact order of pubkey/signature evaluation\n                         // distinguishable by CHECKMULTISIG NOT if the STRICTENC flag is set.\n                         // See the script_(in)valid tests for details.\n-                        if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, serror)) {\n+                        if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n                             // serror is set\n                             return false;\n                         }"
      },
      {
        "sha": "79894c53003480de5a8b547ca00689f549422204",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -102,6 +102,10 @@ enum\n     // Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n     //\n     SCRIPT_VERIFY_NULLFAIL = (1U << 14),\n+\n+    // Public keys in segregated witness scripts must be compressed\n+    //\n+    SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1U << 15),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "2c5359fe8afdb96b56d8649735d07f9fba4f7a26",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -85,6 +85,8 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Witness requires only-redeemscript scriptSig\";\n         case SCRIPT_ERR_WITNESS_UNEXPECTED:\n             return \"Witness provided for non-witness script\";\n+        case SCRIPT_ERR_WITNESS_PUBKEYTYPE:\n+            return \"Using non-compressed keys in segwit\";\n         case SCRIPT_ERR_UNKNOWN_ERROR:\n         case SCRIPT_ERR_ERROR_COUNT:\n         default: break;"
      },
      {
        "sha": "430836991b2cf5bd7652e279263ae676cf9a6fa1",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -62,6 +62,7 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_WITNESS_MALLEATED,\n     SCRIPT_ERR_WITNESS_MALLEATED_P2SH,\n     SCRIPT_ERR_WITNESS_UNEXPECTED,\n+    SCRIPT_ERR_WITNESS_PUBKEYTYPE,\n \n     SCRIPT_ERR_ERROR_COUNT\n } ScriptError;"
      },
      {
        "sha": "f552ad5bbad25a95443e5733fd6b114d625dbf6d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -26,6 +26,10 @@ bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig,\n     if (!keystore->GetKey(address, key))\n         return false;\n \n+    // Signing with uncompressed keys is disabled in witness scripts\n+    if (sigversion == SIGVERSION_WITNESS_V0 && !key.IsCompressed())\n+        return false;\n+\n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n     if (!key.Sign(hash, vchSig))\n         return false;"
      },
      {
        "sha": "7da95488afc4365b13b9202e4dd92209f53c3e4b",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -99,6 +99,7 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_WITNESS_MALLEATED, \"WITNESS_MALLEATED\"},\n     {SCRIPT_ERR_WITNESS_MALLEATED_P2SH, \"WITNESS_MALLEATED_P2SH\"},\n     {SCRIPT_ERR_WITNESS_UNEXPECTED, \"WITNESS_UNEXPECTED\"},\n+    {SCRIPT_ERR_WITNESS_PUBKEYTYPE, \"WITNESS_PUBKEYTYPE\"},\n };\n \n const char *FormatScriptError(ScriptError_t err)"
      },
      {
        "sha": "34d9547f3dc6013189560ac68c8c6585ca2a1166",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 26,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c0c25a604cec39675187507df423cff5d707ab5/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c0c25a604cec39675187507df423cff5d707ab5/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=4c0c25a604cec39675187507df423cff5d707ab5",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -55,7 +55,8 @@ static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n     (string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n     (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n     (string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n-    (string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n+    (string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n+    (string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n \n unsigned int ParseScriptFlags(string strFlags)\n {\n@@ -429,7 +430,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     mtx.nVersion = 1;\n \n     CKey key;\n-    key.MakeNewKey(false);\n+    key.MakeNewKey(true); // Need to use compressed keys in segwit or the signing will fail\n     CBasicKeyStore keystore;\n     keystore.AddKeyPubKey(key, key.GetPubKey());\n     CKeyID hash = key.GetPubKey().GetID();\n@@ -625,30 +626,13 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n \n-    // Witness pay-to-uncompressed-pubkey (v1).\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+    // Signing disabled for witness pay-to-uncompressed-pubkey (v1).\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1, false);\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2, false);\n \n-    // P2SH witness pay-to-uncompressed-pubkey (v1).\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2);\n-    ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1L));\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+    // Signing disabled for P2SH witness pay-to-uncompressed-pubkey (v1).\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1, false);\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2, false);\n \n     // Normal 2-of-2 multisig\n     CreateCreditAndSpend(keystore, scriptMulti, output1, input1, false);"
      }
    ]
  },
  {
    "sha": "9f0397aff7afa2afa9328daea0a2053122e79d44",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZjAzOTdhZmY3YWZhMmFmYTkzMjhkYWVhMGEyMDUzMTIyZTc5ZDQ0",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-08-24T06:44:17Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T15:53:35Z"
      },
      "message": "Make test framework produce lowS signatures",
      "tree": {
        "sha": "4f93095e7c5dab4be0bed8494401e70ca5ee818f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4f93095e7c5dab4be0bed8494401e70ca5ee818f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f0397aff7afa2afa9328daea0a2053122e79d44",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f0397aff7afa2afa9328daea0a2053122e79d44",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9f0397aff7afa2afa9328daea0a2053122e79d44",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f0397aff7afa2afa9328daea0a2053122e79d44/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c0c25a604cec39675187507df423cff5d707ab5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c0c25a604cec39675187507df423cff5d707ab5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c0c25a604cec39675187507df423cff5d707ab5"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 23,
      "deletions": 2
    },
    "files": [
      {
        "sha": "c63a15c1e0c92bd4a63d2b47bff4499e341cab3a",
        "filename": "qa/rpc-tests/test_framework/key.py",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f0397aff7afa2afa9328daea0a2053122e79d44/qa/rpc-tests/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f0397aff7afa2afa9328daea0a2053122e79d44/qa/rpc-tests/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/key.py?ref=9f0397aff7afa2afa9328daea0a2053122e79d44",
        "patch": "@@ -75,6 +75,9 @@\n # this specifies the curve used with ECDSA.\n NID_secp256k1 = 714 # from openssl/obj_mac.h\n \n+SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+\n # Thx to Sam Devlin for the ctypes magic 64-bit fix.\n def _check_result(val, func, args):\n     if val == 0:\n@@ -147,7 +150,7 @@ def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n         r = self.get_raw_ecdh_key(other_pubkey)\n         return kdf(r)\n \n-    def sign(self, hash):\n+    def sign(self, hash, low_s = True):\n         # FIXME: need unit tests for below cases\n         if not isinstance(hash, bytes):\n             raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n@@ -159,7 +162,25 @@ def sign(self, hash):\n         mb_sig = ctypes.create_string_buffer(sig_size0.value)\n         result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n         assert 1 == result\n-        return mb_sig.raw[:sig_size0.value]\n+        assert mb_sig.raw[0] == 0x30\n+        assert mb_sig.raw[1] == sig_size0.value - 2\n+        total_size = mb_sig.raw[1]\n+        assert mb_sig.raw[2] == 2\n+        r_size = mb_sig.raw[3]\n+        assert mb_sig.raw[4 + r_size] == 2\n+        s_size = mb_sig.raw[5 + r_size]\n+        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n+        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n+            return mb_sig.raw[:sig_size0.value]\n+        else:\n+            low_s_value = SECP256K1_ORDER - s_value\n+            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n+            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n+                low_s_bytes = low_s_bytes[1:]\n+            new_s_size = len(low_s_bytes)\n+            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n+            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n+            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n \n     def verify(self, hash, sig):\n         \"\"\"Verify a DER signature\"\"\""
      }
    ]
  },
  {
    "sha": "b811124202152424109b8e95ebe7ac25ff2e83c0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiODExMTI0MjAyMTUyNDI0MTA5YjhlOTVlYmU3YWMyNWZmMmU4M2Mw",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-10-06T17:15:33Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T15:53:35Z"
      },
      "message": "[qa] Add tests for uncompressed pubkeys in segwit",
      "tree": {
        "sha": "8c4238543241718a6de2b4a67b91a60dd43b630d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c4238543241718a6de2b4a67b91a60dd43b630d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b811124202152424109b8e95ebe7ac25ff2e83c0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b811124202152424109b8e95ebe7ac25ff2e83c0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b811124202152424109b8e95ebe7ac25ff2e83c0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b811124202152424109b8e95ebe7ac25ff2e83c0/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9f0397aff7afa2afa9328daea0a2053122e79d44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f0397aff7afa2afa9328daea0a2053122e79d44",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9f0397aff7afa2afa9328daea0a2053122e79d44"
      }
    ],
    "stats": {
      "total": 125,
      "additions": 117,
      "deletions": 8
    },
    "files": [
      {
        "sha": "fa505d60c9b66a8ab1e1cd5eb7851d3a287412ab",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 117,
        "deletions": 8,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b811124202152424109b8e95ebe7ac25ff2e83c0/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b811124202152424109b8e95ebe7ac25ff2e83c0/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=b811124202152424109b8e95ebe7ac25ff2e83c0",
        "patch": "@@ -166,6 +166,17 @@ def __init__(self, sha256, n, nValue):\n         self.n = n\n         self.nValue = nValue\n \n+# Helper for getting the script associated with a P2PKH\n+def GetP2PKHScript(pubkeyhash):\n+    return CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+\n+# Add signature for a P2PK witness program.\n+def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n+    tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n+    signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n+    txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n+    txTo.rehash()\n+\n \n class SegWitTest(BitcoinTestFramework):\n \n@@ -1323,13 +1334,6 @@ def test_signature_version_1(self):\n         sync_blocks(self.nodes)\n         self.utxo.pop(0)\n \n-        # Add signature for a P2PK witness program.\n-        def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n-            tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n-            signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n-            txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n-            txTo.rehash()\n-\n         # Test each hashtype\n         prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n         for sigflag in [ 0, SIGHASH_ANYONECANPAY ]:\n@@ -1443,7 +1447,7 @@ def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n \n-        script = CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+        script = GetP2PKHScript(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n         signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n \n@@ -1706,6 +1710,110 @@ def test_getblocktemplate_before_lockin(self):\n         assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n         self.nodes[0].setmocktime(0) # undo mocktime\n \n+    # Uncompressed pubkeys are no longer supported in default relay policy,\n+    # but (for now) are still valid in blocks.\n+    def test_uncompressed_pubkey(self):\n+        print(\"\\tTesting uncompressed pubkeys\")\n+        # Segwit transactions using uncompressed pubkeys are not accepted\n+        # under default policy, but should still pass consensus.\n+        key = CECKey()\n+        key.set_secretbytes(b\"9\")\n+        key.set_compressed(False)\n+        pubkey = CPubKey(key.get_pubkey())\n+        assert_equal(len(pubkey), 65) # This should be an uncompressed pubkey\n+\n+        assert(len(self.utxo) > 0)\n+        utxo = self.utxo.pop(0)\n+\n+        # Test 1: P2WPKH\n+        # First create a P2WPKH output that uses an uncompressed pubkey\n+        pubkeyhash = hash160(pubkey)\n+        scriptPKH = CScript([OP_0, pubkeyhash])\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(utxo.sha256, utxo.n), b\"\"))\n+        tx.vout.append(CTxOut(utxo.nValue-1000, scriptPKH))\n+        tx.rehash()\n+\n+        # Confirm it in a block.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try to spend it. Send it to a P2WSH output, which we'll\n+        # use in the next test.\n+        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        witness_hash = sha256(witness_program)\n+        scriptWSH = CScript([OP_0, witness_hash])\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptWSH))\n+        script = GetP2PKHScript(pubkeyhash)\n+        sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n+        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ signature, pubkey ]\n+        tx2.rehash()\n+\n+        # Should fail policy test.\n+        self.test_node.test_transaction_acceptance(tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        # But passes consensus.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Test 2: P2WSH\n+        # Try to spend the P2WSH output created in last test.\n+        # Send it to a P2SH(P2WSH) output, which we'll use in the next test.\n+        p2sh_witness_hash = hash160(scriptWSH)\n+        scriptP2SH = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        scriptSig = CScript([scriptWSH])\n+\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, scriptP2SH))\n+        tx3.wit.vtxinwit.append(CTxInWitness())\n+        sign_P2PK_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n+\n+        # Should fail policy test.\n+        self.test_node.test_transaction_acceptance(tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        # But passes consensus.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx3])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Test 3: P2SH(P2WSH)\n+        # Try to spend the P2SH output created in the last test.\n+        # Send it to a P2PKH output, which we'll use in the next test.\n+        scriptPubKey = GetP2PKHScript(pubkeyhash)\n+        tx4 = CTransaction()\n+        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), scriptSig))\n+        tx4.vout.append(CTxOut(tx3.vout[0].nValue-1000, scriptPubKey))\n+        tx4.wit.vtxinwit.append(CTxInWitness())\n+        sign_P2PK_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+\n+        # Should fail policy test.\n+        self.test_node.test_transaction_acceptance(tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx4])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n+        # transactions.\n+        tx5 = CTransaction()\n+        tx5.vin.append(CTxIn(COutPoint(tx4.sha256, 0), b\"\"))\n+        tx5.vout.append(CTxOut(tx4.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        (sig_hash, err) = SignatureHash(scriptPubKey, tx5, 0, SIGHASH_ALL)\n+        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        tx5.vin[0].scriptSig = CScript([signature, pubkey])\n+        tx5.rehash()\n+        # Should pass policy and consensus.\n+        self.test_node.test_transaction_acceptance(tx5, True, True)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx5])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n+\n     def test_non_standard_witness(self):\n         print(\"\\tTesting detection of non-standard P2WSH witness\")\n         pad = chr(1).encode('latin-1')\n@@ -1887,6 +1995,7 @@ def run_test(self):\n         self.test_standardness_v0(segwit_activated=True)\n         self.test_segwit_versions()\n         self.test_premature_coinbase_witness_spend()\n+        self.test_uncompressed_pubkey()\n         self.test_signature_version_1()\n         self.test_non_standard_witness()\n         sync_blocks(self.nodes)"
      }
    ]
  },
  {
    "sha": "248f3a76a825a332e5495c5947ad283a9e5e938f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDhmM2E3NmE4MjVhMzMyZTU0OTVjNTk0N2FkMjgzYTllNWU5Mzhm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-16T16:32:36Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T16:34:37Z"
      },
      "message": "Fix ismine and addwitnessaddress: no uncompressed keys in segwit",
      "tree": {
        "sha": "558883d85e04a20c45d9292659dd60c7b178599b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/558883d85e04a20c45d9292659dd60c7b178599b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/248f3a76a825a332e5495c5947ad283a9e5e938f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/248f3a76a825a332e5495c5947ad283a9e5e938f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/248f3a76a825a332e5495c5947ad283a9e5e938f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/248f3a76a825a332e5495c5947ad283a9e5e938f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b811124202152424109b8e95ebe7ac25ff2e83c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b811124202152424109b8e95ebe7ac25ff2e83c0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b811124202152424109b8e95ebe7ac25ff2e83c0"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 75,
      "deletions": 15
    },
    "files": [
      {
        "sha": "7467d23b2d3a20f4a655db73d0504c124f26a6a5",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 8,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/248f3a76a825a332e5495c5947ad283a9e5e938f/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/248f3a76a825a332e5495c5947ad283a9e5e938f/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=248f3a76a825a332e5495c5947ad283a9e5e938f",
        "patch": "@@ -29,13 +29,25 @@ unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n     return nResult;\n }\n \n-isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest)\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion sigversion)\n+{\n+    bool isInvalid = false;\n+    return IsMine(keystore, scriptPubKey, isInvalid, sigversion);\n+}\n+\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion sigversion)\n+{\n+    bool isInvalid = false;\n+    return IsMine(keystore, dest, isInvalid, sigversion);\n+}\n+\n+isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& isInvalid, SigVersion sigversion)\n {\n     CScript script = GetScriptForDestination(dest);\n-    return IsMine(keystore, script);\n+    return IsMine(keystore, script, isInvalid, sigversion);\n }\n \n-isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n+isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n     vector<valtype> vSolutions;\n     txnouttype whichType;\n@@ -53,12 +65,35 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n+        if (sigversion != SIGVERSION_BASE && vSolutions[0].size() != 33) {\n+            isInvalid = true;\n+            return ISMINE_NO;\n+        }\n         if (keystore.HaveKey(keyID))\n             return ISMINE_SPENDABLE;\n         break;\n-    case TX_PUBKEYHASH:\n     case TX_WITNESS_V0_KEYHASH:\n+    {\n+        if (!keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+            // We do not support bare witness outputs unless the P2SH version of it would be\n+            // acceptable as well. This protects against matching before segwit activates.\n+            // This also applies to the P2WSH case.\n+            break;\n+        }\n+        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SIGVERSION_WITNESS_V0);\n+        if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n+            return ret;\n+        break;\n+    }\n+    case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n+        if (sigversion != SIGVERSION_BASE) {\n+            CPubKey pubkey;\n+            if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n+                isInvalid = true;\n+                return ISMINE_NO;\n+            }\n+        }\n         if (keystore.HaveKey(keyID))\n             return ISMINE_SPENDABLE;\n         break;\n@@ -67,21 +102,24 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript);\n-            if (ret == ISMINE_SPENDABLE)\n+            isminetype ret = IsMine(keystore, subscript, isInvalid);\n+            if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n         break;\n     }\n     case TX_WITNESS_V0_SCRIPTHASH:\n     {\n+        if (!keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+            break;\n+        }\n         uint160 hash;\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(hash.begin());\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript);\n-            if (ret == ISMINE_SPENDABLE)\n+            isminetype ret = IsMine(keystore, subscript, isInvalid, SIGVERSION_WITNESS_V0);\n+            if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n         break;\n@@ -95,6 +133,14 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        if (sigversion != SIGVERSION_BASE) {\n+            for (size_t i = 0; i < keys.size(); i++) {\n+                if (keys[i].size() != 33) {\n+                    isInvalid = true;\n+                    return ISMINE_NO;\n+                }\n+            }\n+        }\n         if (HaveKeys(keys, keystore) == keys.size())\n             return ISMINE_SPENDABLE;\n         break;"
      },
      {
        "sha": "ec7a620e330cb57faa81cfec09beff9c2b8b1153",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/248f3a76a825a332e5495c5947ad283a9e5e938f/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/248f3a76a825a332e5495c5947ad283a9e5e938f/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=248f3a76a825a332e5495c5947ad283a9e5e938f",
        "patch": "@@ -28,7 +28,14 @@ enum isminetype\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n+/* isInvalid becomes true when the script is found invalid by consensus or policy. This will terminate the recursion\n+ * and return a ISMINE_NO immediately, as an invalid script should never be considered as \"mine\". This is needed as\n+ * different SIGVERSION may have different network rules. Currently the only use of isInvalid is indicate uncompressed\n+ * keys in SIGVERSION_WITNESS_V0 script, but could also be used in similar cases in the future\n+ */\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SIGVERSION_BASE);\n \n #endif // BITCOIN_SCRIPT_ISMINE_H"
      },
      {
        "sha": "8e95426d11bdf74d5c24ba9f5866d113fa28a04d",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/248f3a76a825a332e5495c5947ad283a9e5e938f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/248f3a76a825a332e5495c5947ad283a9e5e938f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=248f3a76a825a332e5495c5947ad283a9e5e938f",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -1025,9 +1025,12 @@ class Witnessifier : public boost::static_visitor<bool>\n \n     bool operator()(const CKeyID &keyID) {\n         CPubKey pubkey;\n-        if (pwalletMain && pwalletMain->GetPubKey(keyID, pubkey)) {\n-            CScript basescript;\n-            basescript << ToByteVector(pubkey) << OP_CHECKSIG;\n+        if (pwalletMain) {\n+            CScript basescript = GetScriptForDestination(keyID);\n+            isminetype typ;\n+            typ = IsMine(*pwalletMain, basescript, SIGVERSION_WITNESS_V0);\n+            if (typ != ISMINE_SPENDABLE && typ != ISMINE_WATCH_SOLVABLE)\n+                return false;\n             CScript witscript = GetScriptForWitness(basescript);\n             pwalletMain->AddCScript(witscript);\n             result = CScriptID(witscript);\n@@ -1045,6 +1048,10 @@ class Witnessifier : public boost::static_visitor<bool>\n                 result = scriptID;\n                 return true;\n             }\n+            isminetype typ;\n+            typ = IsMine(*pwalletMain, subscript, SIGVERSION_WITNESS_V0);\n+            if (typ != ISMINE_SPENDABLE && typ != ISMINE_WATCH_SOLVABLE)\n+                return false;\n             CScript witscript = GetScriptForWitness(subscript);\n             pwalletMain->AddCScript(witscript);\n             result = CScriptID(witscript);\n@@ -1090,7 +1097,7 @@ UniValue addwitnessaddress(const UniValue& params, bool fHelp)\n     CTxDestination dest = address.Get();\n     bool ret = boost::apply_visitor(w, dest);\n     if (!ret) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet\");\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet, or the key is uncompressed\");\n     }\n \n     pwalletMain->SetAddressBook(w.result, \"\", \"receive\");"
      }
    ]
  },
  {
    "sha": "9260085377e89e666d0cb95b462261d7e3a9c82f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjYwMDg1Mzc3ZTg5ZTY2NmQwY2I5NWI0NjIyNjFkN2UzYTljODJm",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-14T18:29:39Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T16:34:37Z"
      },
      "message": "test segwit uncompressed key fixes",
      "tree": {
        "sha": "88673704000636fad9ff454279f2632dea14a73e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88673704000636fad9ff454279f2632dea14a73e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9260085377e89e666d0cb95b462261d7e3a9c82f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9260085377e89e666d0cb95b462261d7e3a9c82f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9260085377e89e666d0cb95b462261d7e3a9c82f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9260085377e89e666d0cb95b462261d7e3a9c82f/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "248f3a76a825a332e5495c5947ad283a9e5e938f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/248f3a76a825a332e5495c5947ad283a9e5e938f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/248f3a76a825a332e5495c5947ad283a9e5e938f"
      }
    ],
    "stats": {
      "total": 895,
      "additions": 893,
      "deletions": 2
    },
    "files": [
      {
        "sha": "41a1b3b20fd00fbb7961b5c8c6b83c3e85297e37",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 359,
        "deletions": 1,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9260085377e89e666d0cb95b462261d7e3a9c82f/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9260085377e89e666d0cb95b462261d7e3a9c82f/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=9260085377e89e666d0cb95b462261d7e3a9c82f",
        "patch": "@@ -9,7 +9,10 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.mininode import sha256, ripemd160\n+from test_framework.mininode import sha256, ripemd160, CTransaction, CTxIn, COutPoint, CTxOut\n+from test_framework.address import script_to_p2sh, key_to_p2pkh\n+from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG\n+from io import BytesIO\n \n NODE_0 = 0\n NODE_1 = 1\n@@ -242,5 +245,360 @@ def run_test(self):\n             # This is an acceptable outcome\n             pass\n \n+        print(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n+\n+        # Some public keys to be used later\n+        pubkeys = [\n+            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\", # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n+            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\", # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n+            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\", # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n+            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\", # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n+            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\", # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n+            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\", # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n+            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\", # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n+        ]\n+\n+        # Import a compressed key and an uncompressed key, generate some multisig addresses\n+        self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n+        uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n+        self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n+        compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n+        assert ((self.nodes[0].validateaddress(uncompressed_spendable_address[0])['iscompressed'] == False))\n+        assert ((self.nodes[0].validateaddress(compressed_spendable_address[0])['iscompressed'] == True))\n+\n+        self.nodes[0].importpubkey(pubkeys[0])\n+        compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n+        self.nodes[0].importpubkey(pubkeys[1])\n+        compressed_solvable_address.append(key_to_p2pkh(pubkeys[1]))\n+        self.nodes[0].importpubkey(pubkeys[2])\n+        uncompressed_solvable_address = [key_to_p2pkh(pubkeys[2])]\n+\n+        spendable_anytime = []                      # These outputs should be seen anytime after importprivkey and addmultisigaddress\n+        spendable_after_importaddress = []          # These outputs should be seen after importaddress\n+        solvable_after_importaddress = []           # These outputs should be seen after importaddress but not spendable\n+        unsolvable_after_importaddress = []         # These outputs should be unsolvable after importaddress\n+        solvable_anytime = []                       # These outputs should be solvable after importpubkey\n+        unseen_anytime = []                         # These outputs should never be seen\n+\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]]))\n+        unknown_address = [\"mtKKyoHabkk6e4ppT7NaM7THqPUt7AzPrT\", \"2NDP3jLWAFT8NDAiUa9qiE6oBt2awmMq7Dx\"]\n+\n+        # Test multisig_without_privkey\n+        # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n+        # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n+\n+        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])\n+        script = CScript([OP_2, hex_str_to_bytes(pubkeys[3]), hex_str_to_bytes(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n+        solvable_after_importaddress.append(CScript([OP_HASH160, hash160(script), OP_EQUAL]))\n+\n+        for i in compressed_spendable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # bare and p2sh multisig with compressed keys should always be spendable\n+                spendable_anytime.extend([bare, p2sh])\n+                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after direct importaddress\n+                spendable_after_importaddress.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with compressed keys should always be spendable\n+                spendable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK, P2SH_P2PKH, and witness with compressed keys are spendable after direct importaddress\n+                spendable_after_importaddress.extend([p2wpkh, p2sh_p2wpkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        for i in uncompressed_spendable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # bare and p2sh multisig with uncompressed keys should always be spendable\n+                spendable_anytime.extend([bare, p2sh])\n+                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with uncompressed keys should always be spendable\n+                spendable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK and P2SH_P2PKH are spendable after direct importaddress\n+                spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n+                # witness with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        for i in compressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                # Multisig without private is not seen after addmultisigaddress, but seen after importaddress\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                solvable_after_importaddress.extend([bare, p2sh, p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with compressed keys should always be seen\n+                solvable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK, P2SH_P2PKH, and witness with compressed keys are seen after direct importaddress\n+                solvable_after_importaddress.extend([p2wpkh, p2sh_p2wpkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        for i in uncompressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # Base uncompressed multisig without private is not seen after addmultisigaddress, but seen after importaddress\n+                solvable_after_importaddress.extend([bare, p2sh])\n+                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with uncompressed keys should always be seen\n+                solvable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK, P2SH_P2PKH with uncompressed keys are seen after direct importaddress\n+                solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n+                # witness with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        op1 = CScript([OP_1])\n+        op0 = CScript([OP_0])\n+        # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n+        unsolvable_address = [\"mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\", \"2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe\", script_to_p2sh(op1), script_to_p2sh(op0)]\n+        unsolvable_address_key = hex_str_to_bytes(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n+        unsolvablep2pkh = CScript([OP_DUP, OP_HASH160, hash160(unsolvable_address_key), OP_EQUALVERIFY, OP_CHECKSIG])\n+        unsolvablep2wshp2pkh = CScript([OP_0, sha256(unsolvablep2pkh)])\n+        p2shop0 = CScript([OP_HASH160, hash160(op0), OP_EQUAL])\n+        p2wshop1 = CScript([OP_0, sha256(op1)])\n+        unsolvable_after_importaddress.append(unsolvablep2pkh)\n+        unsolvable_after_importaddress.append(unsolvablep2wshp2pkh)\n+        unsolvable_after_importaddress.append(op1) # OP_1 will be imported as script\n+        unsolvable_after_importaddress.append(p2wshop1)\n+        unseen_anytime.append(op0) # OP_0 will be imported as P2SH address with no script provided\n+        unsolvable_after_importaddress.append(p2shop0)\n+\n+        spendable_txid = []\n+        solvable_txid = []\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime, 1))\n+        self.mine_and_test_listunspent(spendable_after_importaddress + solvable_after_importaddress + unseen_anytime + unsolvable_after_importaddress, 0)\n+\n+        importlist = []\n+        for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                bare = hex_str_to_bytes(v['hex'])\n+                importlist.append(bytes_to_hex_str(bare))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(bare)])))\n+            else:\n+                pubkey = hex_str_to_bytes(v['pubkey'])\n+                p2pk = CScript([pubkey, OP_CHECKSIG])\n+                p2pkh = CScript([OP_DUP, OP_HASH160, hash160(pubkey), OP_EQUALVERIFY, OP_CHECKSIG])\n+                importlist.append(bytes_to_hex_str(p2pk))\n+                importlist.append(bytes_to_hex_str(p2pkh))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, hash160(pubkey)])))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(p2pk)])))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(p2pkh)])))\n+\n+        importlist.append(bytes_to_hex_str(unsolvablep2pkh))\n+        importlist.append(bytes_to_hex_str(unsolvablep2wshp2pkh))\n+        importlist.append(bytes_to_hex_str(op1))\n+        importlist.append(bytes_to_hex_str(p2wshop1))\n+\n+        for i in importlist:\n+            try:\n+                self.nodes[0].importaddress(i,\"\",False,True)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], \"The wallet already contains the private key for this address or script\")\n+\n+        self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n+        self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey\n+\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n+        self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n+        self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used or the address is\n+        # not in the wallet\n+        # note that no witness address should be returned by unsolvable addresses\n+        # the multisig_without_privkey_address will fail because its keys were not added with importpubkey\n+        for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address + [multisig_without_privkey_address]:\n+            try:\n+                self.nodes[0].addwitnessaddress(i)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n+            else:\n+                assert(False)\n+\n+        for i in compressed_spendable_address + compressed_solvable_address:\n+            witaddress = self.nodes[0].addwitnessaddress(i)\n+            # addwitnessaddress should return the same address if it is a known P2SH-witness address\n+            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n+\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n+        self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n+        self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+        # Repeat some tests. This time we don't add witness scripts with importaddress\n+        # Import a compressed key and an uncompressed key, generate some multisig addresses\n+        self.nodes[0].importprivkey(\"927pw6RW8ZekycnXqBQ2JS5nPyo1yRfGNN8oq74HeddWSpafDJH\")\n+        uncompressed_spendable_address = [\"mguN2vNSCEUh6rJaXoAVwY3YZwZvEmf5xi\"]\n+        self.nodes[0].importprivkey(\"cMcrXaaUC48ZKpcyydfFo8PxHAjpsYLhdsp6nmtB3E2ER9UUHWnw\")\n+        compressed_spendable_address = [\"n1UNmpmbVUJ9ytXYXiurmGPQ3TRrXqPWKL\"]\n+\n+        self.nodes[0].importpubkey(pubkeys[5])\n+        compressed_solvable_address = [key_to_p2pkh(pubkeys[5])]\n+        self.nodes[0].importpubkey(pubkeys[6])\n+        uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n+\n+        spendable_after_addwitnessaddress = []      # These outputs should be seen after importaddress\n+        solvable_after_addwitnessaddress=[]         # These outputs should be seen after importaddress but not spendable\n+        unseen_anytime = []                         # These outputs should never be seen\n+\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n+\n+        premature_witaddress = []\n+\n+        for i in compressed_spendable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after addwitnessaddress\n+                spendable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n+                premature_witaddress.append(script_to_p2sh(p2wsh))\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # P2WPKH, P2SH_P2WPKH are spendable after addwitnessaddress\n+                spendable_after_addwitnessaddress.extend([p2wpkh, p2sh_p2wpkh])\n+                premature_witaddress.append(script_to_p2sh(p2wpkh))\n+\n+        for i in uncompressed_spendable_address + uncompressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # P2WPKH, P2SH_P2WPKH with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh])\n+\n+        for i in compressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                # P2WSH multisig without private key are seen after addwitnessaddress\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                solvable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n+                premature_witaddress.append(script_to_p2sh(p2wsh))\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # P2SH_P2PK, P2SH_P2PKH with compressed keys are seen after addwitnessaddress\n+                solvable_after_addwitnessaddress.extend([p2wpkh, p2sh_p2wpkh])\n+                premature_witaddress.append(script_to_p2sh(p2wpkh))\n+\n+        self.mine_and_test_listunspent(spendable_after_addwitnessaddress + solvable_after_addwitnessaddress + unseen_anytime, 0)\n+\n+        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n+        # note that a multisig address returned by addmultisigaddress is not solvable until it is added with importaddress\n+        # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n+        for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress + [compressed_solvable_address[1]]:\n+            try:\n+                self.nodes[0].addwitnessaddress(i)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n+            else:\n+                assert(False)\n+\n+        # after importaddress it should pass addwitnessaddress\n+        v = self.nodes[0].validateaddress(compressed_solvable_address[1])\n+        self.nodes[0].importaddress(v['hex'],\"\",False,True)\n+        for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n+            witaddress = self.nodes[0].addwitnessaddress(i)\n+            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n+\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_after_addwitnessaddress, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_after_addwitnessaddress, 1))\n+        self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+        # Check that spendable outputs are really spendable\n+        self.create_and_mine_tx_from_txids(spendable_txid)\n+\n+        # import all the private keys so solvable addresses become spendable\n+        self.nodes[0].importprivkey(\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n+        self.nodes[0].importprivkey(\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n+        self.nodes[0].importprivkey(\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")\n+        self.nodes[0].importprivkey(\"cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\")\n+        self.nodes[0].importprivkey(\"cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\")\n+        self.nodes[0].importprivkey(\"cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\")\n+        self.create_and_mine_tx_from_txids(solvable_txid)\n+\n+    def mine_and_test_listunspent(self, script_list, ismine):\n+        utxo = find_unspent(self.nodes[0], 50)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(int('0x'+utxo['txid'],0), utxo['vout'])))\n+        for i in script_list:\n+            tx.vout.append(CTxOut(10000000, i))\n+        tx.rehash()\n+        signresults = self.nodes[0].signrawtransaction(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        txid = self.nodes[0].sendrawtransaction(signresults, True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+        watchcount = 0\n+        spendcount = 0\n+        for i in self.nodes[0].listunspent():\n+            if (i['txid'] == txid):\n+                watchcount += 1\n+                if (i['spendable'] == True):\n+                    spendcount += 1\n+        if (ismine == 2):\n+            assert_equal(spendcount, len(script_list))\n+        elif (ismine == 1):\n+            assert_equal(watchcount, len(script_list))\n+            assert_equal(spendcount, 0)\n+        else:\n+            assert_equal(watchcount, 0)\n+        return txid\n+\n+    def p2sh_address_to_script(self,v):\n+        bare = CScript(hex_str_to_bytes(v['hex']))\n+        p2sh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n+        p2wsh = CScript([OP_0, sha256(bare)])\n+        p2sh_p2wsh = CScript([OP_HASH160, hash160(p2wsh), OP_EQUAL])\n+        return([bare, p2sh, p2wsh, p2sh_p2wsh])\n+\n+    def p2pkh_address_to_script(self,v):\n+        pubkey = hex_str_to_bytes(v['pubkey'])\n+        p2wpkh = CScript([OP_0, hash160(pubkey)])\n+        p2sh_p2wpkh = CScript([OP_HASH160, hash160(p2wpkh), OP_EQUAL])\n+        p2pk = CScript([pubkey, OP_CHECKSIG])\n+        p2pkh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n+        p2sh_p2pk = CScript([OP_HASH160, hash160(p2pk), OP_EQUAL])\n+        p2sh_p2pkh = CScript([OP_HASH160, hash160(p2pkh), OP_EQUAL])\n+        p2wsh_p2pk = CScript([OP_0, sha256(p2pk)])\n+        p2wsh_p2pkh = CScript([OP_0, sha256(p2pkh)])\n+        p2sh_p2wsh_p2pk = CScript([OP_HASH160, hash160(p2wsh_p2pk), OP_EQUAL])\n+        p2sh_p2wsh_p2pkh = CScript([OP_HASH160, hash160(p2wsh_p2pkh), OP_EQUAL])\n+        return [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh]\n+\n+    def create_and_mine_tx_from_txids(self, txids, success = True):\n+        tx = CTransaction()\n+        for i in txids:\n+            txtmp = CTransaction()\n+            txraw = self.nodes[0].getrawtransaction(i)\n+            f = BytesIO(hex_str_to_bytes(txraw))\n+            txtmp.deserialize(f)\n+            for j in range(len(txtmp.vout)):\n+                tx.vin.append(CTxIn(COutPoint(int('0x'+i,0), j)))\n+        tx.vout.append(CTxOut(0, CScript()))\n+        tx.rehash()\n+        signresults = self.nodes[0].signrawtransaction(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        self.nodes[0].sendrawtransaction(signresults, True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+\n if __name__ == '__main__':\n     SegWitTest().main()"
      },
      {
        "sha": "50b999be6110d91df1730cc11961d14d5c87ccd9",
        "filename": "qa/rpc-tests/test_framework/address.py",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9260085377e89e666d0cb95b462261d7e3a9c82f/qa/rpc-tests/test_framework/address.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9260085377e89e666d0cb95b462261d7e3a9c82f/qa/rpc-tests/test_framework/address.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/address.py?ref=9260085377e89e666d0cb95b462261d7e3a9c82f",
        "patch": "@@ -0,0 +1,74 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# address.py\n+#\n+# This file encodes and decodes BASE58 P2PKH and P2SH addresses\n+#\n+\n+from .script import hash256, hash160, sha256, CScript, OP_0\n+from .util import bytes_to_hex_str, hex_str_to_bytes\n+\n+chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n+\n+def byte_to_base58(b, version):\n+    result = ''\n+    str = bytes_to_hex_str(b)\n+    str = bytes_to_hex_str(chr(version).encode('latin-1')) + str\n+    checksum = bytes_to_hex_str(hash256(hex_str_to_bytes(str)))\n+    str += checksum[:8]\n+    value = int('0x'+str,0)\n+    while value > 0:\n+        result = chars[value % 58] + result\n+        value //= 58\n+    while (str[:2] == '00'):\n+        result = chars[0] + result\n+        str = str[2:]\n+    return result\n+\n+# TODO: def base58_decode\n+\n+def keyhash_to_p2pkh(hash, main = False):\n+    assert (len(hash) == 20)\n+    version = 0 if main else 111\n+    return byte_to_base58(hash, version)\n+\n+def scripthash_to_p2sh(hash, main = False):\n+    assert (len(hash) == 20)\n+    version = 5 if main else 196\n+    return byte_to_base58(hash, version)\n+\n+def key_to_p2pkh(key, main = False):\n+    key = check_key(key)\n+    return keyhash_to_p2pkh(hash160(key), main)\n+\n+def script_to_p2sh(script, main = False):\n+    script = check_script(script)\n+    return scripthash_to_p2sh(hash160(script), main)\n+\n+def key_to_p2sh_p2wpkh(key, main = False):\n+    key = check_key(key)\n+    p2shscript = CScript([OP_0, hash160(key)])\n+    return script_to_p2sh(p2shscript, main)\n+\n+def script_to_p2sh_p2wsh(script, main = False):\n+    script = check_script(script)\n+    p2shscript = CScript([OP_0, sha256(script)])\n+    return script_to_p2sh(p2shscript, main)\n+\n+def check_key(key):\n+    if (type(key) is str):\n+        key = hex_str_to_bytes(key) # Assuming this is hex string\n+    if (type(key) is bytes and (len(key) == 33 or len(key) == 65)):\n+        return key\n+    assert(False)\n+\n+def check_script(script):\n+    if (type(script) is str):\n+        script = hex_str_to_bytes(script) # Assuming this is hex string\n+    if (type(script) is bytes or type(script) is CScript):\n+        return script\n+    assert(False)"
      },
      {
        "sha": "5c054ed3e8fb06939a31061e6d2fe7d09222c9a2",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 367,
        "deletions": 1,
        "changes": 368,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9260085377e89e666d0cb95b462261d7e3a9c82f/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9260085377e89e666d0cb95b462261d7e3a9c82f/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=9260085377e89e666d0cb95b462261d7e3a9c82f",
        "patch": "@@ -1855,6 +1855,8 @@\n     \"OK\",\n     \"P2SH with CLEANSTACK\"\n ],\n+\n+[\"Testing with uncompressed keys in witness v0 without WITNESS_PUBKEYTYPE\"],\n [\n     [\n         \"304402200d461c140cfdfcf36b94961db57ae8c18d1cb80e9d95a9e47ac22470c1bf125502201c8dc1cbfef6a3ef90acbbb992ca22fe9466ee6f9d4898eda277a7ac3ab4b25101\",\n@@ -2139,7 +2141,371 @@\n     \"P2PK with witness\"\n ],\n \n-[\"CHECKSEQUENCEVERIFY tests\"], \n+[\"Testing with compressed keys in witness v0 with WITNESS_PUBKEYTYPE\"],\n+[\n+    [\n+        \"304402204256146fcf8e73b0fd817ffa2a4e408ff0418ff987dd08a4f485b62546f6c43c02203f3c8c3e2febc051e1222867f5f9d0eaf039d6792911c10940aa3cc74123378e01\",\n+        \"210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ac\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x1863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2WSH with compressed key\"\n+],\n+[\n+    [\n+        \"304402204edf27486f11432466b744df533e1acac727e0c83e5f912eb289a3df5bf8035f022075809fdd876ede40ad21667eba8b7e96394938f9c9c50f11b6a1280cce2cea8601\",\n+        \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x14 0x751e76e8199196d454941c45d1b3a323f1433bd6\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2WPKH with compressed key\"\n+],\n+[\n+    [\n+        \"304402203a549090cc46bce1e5e95c4922ea2c12747988e0207b04c42f81cdbe87bb1539022050f57a245b875fd5119c419aaf050bcdf41384f0765f04b809e5bced1fe7093d01\",\n+        \"210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ac\",\n+        0.00000001\n+    ],\n+    \"0x22 0x00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262\",\n+    \"HASH160 0x14 0xe4300531190587e3880d4c3004f5355d88ff928d EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2SH(P2WSH) with compressed key\"\n+],\n+[\n+    [\n+        \"304402201bc0d53046827f4a35a3166e33e3b3366c4085540dc383b95d21ed2ab11e368a0220333e78c6231214f5f8e59621e15d7eeab0d4e4d0796437e00bfbd2680c5f9c1701\",\n+        \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n+        0.00000001\n+    ],\n+    \"0x16 0x0014751e76e8199196d454941c45d1b3a323f1433bd6\",\n+    \"HASH160 0x14 0xbcfeb728b584253d5f3f70bcb780e9ef218a68f4 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2SH(P2WPKH) with compressed key\"\n+],\n+\n+[\"Testing with uncompressed keys in witness v0 with WITNESS_PUBKEYTYPE\"],\n+[\n+    [\n+        \"304402200d461c140cfdfcf36b94961db57ae8c18d1cb80e9d95a9e47ac22470c1bf125502201c8dc1cbfef6a3ef90acbbb992ca22fe9466ee6f9d4898eda277a7ac3ab4b25101\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2WSH\"\n+],\n+[\n+    [\n+        \"304402201e7216e5ccb3b61d46946ec6cc7e8c4e0117d13ac2fd4b152197e4805191c74202203e9903e33e84d9ee1dd13fb057afb7ccfb47006c23f6a067185efbc9dd780fc501\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2WPKH\"\n+],\n+[\n+    [\n+        \"3044022066e02c19a513049d49349cf5311a1b012b7c4fae023795a18ab1d91c23496c22022025e216342c8e07ce8ef51e8daee88f84306a9de66236cab230bb63067ded1ad301\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020b95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"HASH160 0x14 0xf386c2ba255cc56d20cfa6ea8b062f8b59945518 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2SH(P2WSH)\"\n+],\n+[\n+    [\n+        \"304402200929d11561cd958460371200f82e9cae64c727a495715a31828e27a7ad57b36d0220361732ced04a6f97351ecca21a56d0b8cd4932c1da1f8f569a2b68e5e48aed7801\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000001\n+    ],\n+    \"0x16 0x001491b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"HASH160 0x14 0x17743beb429c55c942d2ec703b98c4d57c2df5c6 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2SH(P2WPKH)\"\n+],\n+\n+[\"Testing P2WSH multisig with compressed keys\"],\n+[\n+    [\n+        \"\",\n+        \"304402207eb8a59b5c65fc3f6aeef77066556ed5c541948a53a3ba7f7c375b8eed76ee7502201e036a7a9a98ff919ff94dc905d67a1ec006f79ef7cff0708485c8bb79dce38e01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x06c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with compressed keys\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022033706aed33b8155d5486df3b9bca8cdd3bd4bdb5436dce46d72cdaba51d22b4002203626e94fe53a178af46624f17315c6931f20a30b103f5e044e1eda0c3fe185c601\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002006c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"HASH160 0x14 0x26282aad7c29369d15fed062a778b6100d31a340 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402204048b7371ab1c544362efb89af0c80154747d665aa4fcfb2edfd2d161e57b42e02207e043748e96637080ffc3acbd4dcc6fee1e58d30f6d1269535f32188e5ddae7301\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x06c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with compressed keys\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022073902ef0b8a554c36c44cc03c1b64df96ce2914ebcf946f5bb36078fd5245cdf02205b148f1ba127065fb8c83a5a9576f2dcd111739788ed4bb3ee08b2bd3860c91c01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002006c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"HASH160 0x14 0x26282aad7c29369d15fed062a778b6100d31a340 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\"\n+],\n+\n+[\"Testing P2WSH multisig with compressed and uncompressed keys (first key being the key closer to the top of stack)\"],\n+[\n+    [\n+        \"\",\n+        \"304402202d092ededd1f060609dbf8cb76950634ff42b3e62cf4adb69ab92397b07d742302204ff886f8d0817491a96d1daccdcc820f6feb122ee6230143303100db37dfa79f01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402202dd7e91243f2235481ffb626c3b7baf2c859ae3a5a77fb750ef97b99a8125dc002204960de3d3c3ab9496e218ec57e5240e0e10a6f9546316fe240c216d45116d29301\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402202d092ededd1f060609dbf8cb76950634ff42b3e62cf4adb69ab92397b07d742302204ff886f8d0817491a96d1daccdcc820f6feb122ee6230143303100db37dfa79f01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402202dd7e91243f2235481ffb626c3b7baf2c859ae3a5a77fb750ef97b99a8125dc002204960de3d3c3ab9496e218ec57e5240e0e10a6f9546316fe240c216d45116d29301\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402201e9e6f7deef5b2f21d8223c5189b7d5e82d237c10e97165dd08f547c4e5ce6ed02206796372eb1cc6acb52e13ee2d7f45807780bf96b132cb6697f69434be74b1af901\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022045e667f3f0f3147b95597a24babe9afecea1f649fd23637dfa7ed7e9f3ac18440220295748e81005231135289fe3a88338dabba55afa1bdb4478691337009d82b68d01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402201e9e6f7deef5b2f21d8223c5189b7d5e82d237c10e97165dd08f547c4e5ce6ed02206796372eb1cc6acb52e13ee2d7f45807780bf96b132cb6697f69434be74b1af901\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022045e667f3f0f3147b95597a24babe9afecea1f649fd23637dfa7ed7e9f3ac18440220295748e81005231135289fe3a88338dabba55afa1bdb4478691337009d82b68d01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022046f5367a261fd8f8d7de6eb390491344f8ec2501638fb9a1095a0599a21d3f4c02205c1b3b51d20091c5f1020841bbca87b44ebe25405c64e4acf758f2eae8665f8401\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022053e210e4fb1881e6092fd75c3efc5163105599e246ded661c0ee2b5682cc2d6c02203a26b7ada8682a095b84c6d1b881637000b47d761fc837c4cee33555296d63f101\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022046f5367a261fd8f8d7de6eb390491344f8ec2501638fb9a1095a0599a21d3f4c02205c1b3b51d20091c5f1020841bbca87b44ebe25405c64e4acf758f2eae8665f8401\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022053e210e4fb1881e6092fd75c3efc5163105599e246ded661c0ee2b5682cc2d6c02203a26b7ada8682a095b84c6d1b881637000b47d761fc837c4cee33555296d63f101\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402206c6d9f5daf85b54af2a93ec38b15ab27f205dbf5c735365ff12451e43613d1f40220736a44be63423ed5ebf53491618b7cc3d8a5093861908da853739c73717938b701\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"30440220687871bc6144012d75baf585bb26ce13997f7d8c626f4d8825b069c3b2d064470220108936fe1c57327764782253e99090b09c203ec400ed35ce9e026ce2ecf842a001\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402206c6d9f5daf85b54af2a93ec38b15ab27f205dbf5c735365ff12451e43613d1f40220736a44be63423ed5ebf53491618b7cc3d8a5093861908da853739c73717938b701\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"30440220687871bc6144012d75baf585bb26ce13997f7d8c626f4d8825b069c3b2d064470220108936fe1c57327764782253e99090b09c203ec400ed35ce9e026ce2ecf842a001\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+\n+[\"CHECKSEQUENCEVERIFY tests\"],\n [\"\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on a empty stack\"],\n [\"-1\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"NEGATIVE_LOCKTIME\", \"CSV automatically fails if stack top is negative\"],\n [\"0x0100\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY,MINIMALDATA\", \"UNKNOWN_ERROR\", \"CSV fails if stack top is not minimally encoded\"],"
      },
      {
        "sha": "561adb8ea2252a9eebfa70ec8bd2a580c8dcbb4a",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9260085377e89e666d0cb95b462261d7e3a9c82f/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9260085377e89e666d0cb95b462261d7e3a9c82f/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=9260085377e89e666d0cb95b462261d7e3a9c82f",
        "patch": "@@ -826,6 +826,99 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                 \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n                                ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n \n+    // Compressed keys should pass SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n+                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n+                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n+                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit().PushRedeem());\n+\n+    // Testing uncompressed key in witness with SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+\n+    // P2WSH 1-of-2 multisig with compressed keys\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n+\n+    // P2WSH 1-of-2 multisig with first key uncompressed\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    // P2WSH 1-of-2 multisig with second key uncompressed\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+\n     std::set<std::string> tests_set;\n \n     {"
      }
    ]
  },
  {
    "sha": "67d6ee1e3679504f46473fe0818970565ff3b137",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2N2Q2ZWUxZTM2Nzk1MDRmNDY0NzNmZTA4MTg5NzA1NjVmZjNiMTM3",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T19:18:36Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T19:18:36Z"
      },
      "message": "remove redundant tests in p2p-segwit.py",
      "tree": {
        "sha": "3a298b47bb9f6a33d96ba79599c9fccf80d22713",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a298b47bb9f6a33d96ba79599c9fccf80d22713"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67d6ee1e3679504f46473fe0818970565ff3b137",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67d6ee1e3679504f46473fe0818970565ff3b137",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/67d6ee1e3679504f46473fe0818970565ff3b137",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67d6ee1e3679504f46473fe0818970565ff3b137/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9260085377e89e666d0cb95b462261d7e3a9c82f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9260085377e89e666d0cb95b462261d7e3a9c82f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9260085377e89e666d0cb95b462261d7e3a9c82f"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 0,
      "deletions": 9
    },
    "files": [
      {
        "sha": "09ab1b80fcbb2de0fda73a53a379a26c6197dc6d",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67d6ee1e3679504f46473fe0818970565ff3b137/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67d6ee1e3679504f46473fe0818970565ff3b137/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=67d6ee1e3679504f46473fe0818970565ff3b137",
        "patch": "@@ -1872,16 +1872,11 @@ def test_non_standard_witness(self):\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        # It can't be used to blind a node to the transaction\n-        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n-        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n         self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         self.test_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n         self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n \n         # witnessScript size at 3600 bytes is standard\n@@ -1900,13 +1895,9 @@ def test_non_standard_witness(self):\n         self.std_node.test_transaction_acceptance(p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n         self.test_node.test_transaction_acceptance(p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n-        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n-        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n         self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n         self.test_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n         self.std_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n         self.test_node.test_transaction_acceptance(p2sh_txs[2], True, True)"
      }
    ]
  }
]