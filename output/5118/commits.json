[
  {
    "sha": "bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGFlYzZhYmQzNWRkOTNhZTZiMjlmNDRiOGNiZjljM2FmM2Y2ODA1",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-10-21T18:38:25Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-10-27T18:39:32Z"
      },
      "message": "boost: remove CPubKey dependency from CECKey. Follow-up of e405aa48",
      "tree": {
        "sha": "7a5af30417c1a7f63091856193b0f47c790903d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a5af30417c1a7f63091856193b0f47c790903d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25cc1cf8dc03b9ba0ae886d354855adc207b5b6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25cc1cf8dc03b9ba0ae886d354855adc207b5b6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25cc1cf8dc03b9ba0ae886d354855adc207b5b6e"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 28,
      "deletions": 21
    },
    "files": [
      {
        "sha": "d2001717f1abf16a64433a470f75105ea871f162",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 21,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
        "patch": "@@ -201,21 +201,20 @@ class CECKey {\n         return false;\n     }\n \n-    void GetPubKey(CPubKey &pubkey, bool fCompressed) {\n+    void GetPubKey(std::vector<unsigned char> &pubkey, bool fCompressed) {\n         EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n         int nSize = i2o_ECPublicKey(pkey, NULL);\n         assert(nSize);\n         assert(nSize <= 65);\n-        unsigned char c[65];\n-        unsigned char *pbegin = c;\n+        pubkey.clear();\n+        pubkey.resize(nSize);\n+        unsigned char *pbegin(begin_ptr(pubkey));\n         int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n         assert(nSize == nSize2);\n-        pubkey.Set(&c[0], &c[nSize]);\n     }\n \n-    bool SetPubKey(const CPubKey &pubkey) {\n-        const unsigned char* pbegin = pubkey.begin();\n-        return o2i_ECPublicKey(&pkey, &pbegin, pubkey.size()) != NULL;\n+    bool SetPubKey(const unsigned char* pubkey, size_t size) {\n+        return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n     }\n \n     bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS) {\n@@ -261,12 +260,12 @@ class CECKey {\n         int nBitsR = BN_num_bits(sig->r);\n         int nBitsS = BN_num_bits(sig->s);\n         if (nBitsR <= 256 && nBitsS <= 256) {\n-            CPubKey pubkey;\n+            std::vector<unsigned char> pubkey;\n             GetPubKey(pubkey, true);\n             for (int i=0; i<4; i++) {\n                 CECKey keyRec;\n                 if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1) {\n-                    CPubKey pubkeyRec;\n+                    std::vector<unsigned char> pubkeyRec;\n                     keyRec.GetPubKey(pubkeyRec, true);\n                     if (pubkeyRec == pubkey) {\n                         rec = i;\n@@ -455,19 +454,21 @@ CPrivKey CKey::GetPrivKey() const {\n \n CPubKey CKey::GetPubKey() const {\n     assert(fValid);\n-    CPubKey pubkey;\n+    CPubKey result;\n #ifdef USE_SECP256K1\n     int clen = 65;\n-    int ret = secp256k1_ecdsa_pubkey_create((unsigned char*)pubkey.begin(), &clen, begin(), fCompressed);\n+    int ret = secp256k1_ecdsa_pubkey_create((unsigned char*)result.begin(), &clen, begin(), fCompressed);\n+    assert((int)result.size() == clen);\n     assert(ret);\n-    assert(pubkey.IsValid());\n-    assert((int)pubkey.size() == clen);\n #else\n+    std::vector<unsigned char> pubkey;\n     CECKey key;\n     key.SetSecretBytes(vch);\n     key.GetPubKey(pubkey, fCompressed);\n+    result.Set(pubkey.begin(), pubkey.end());\n #endif\n-    return pubkey;\n+    assert(result.IsValid());\n+    return result;\n }\n \n bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS) const {\n@@ -544,7 +545,7 @@ bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchS\n         return false;\n #else\n     CECKey key;\n-    if (!key.SetPubKey(*this))\n+    if (!key.SetPubKey(begin(), size()))\n         return false;\n     if (!key.Verify(hash, vchSig))\n         return false;\n@@ -566,7 +567,9 @@ bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned cha\n     CECKey key;\n     if (!key.Recover(hash, &vchSig[1], recid))\n         return false;\n-    key.GetPubKey(*this, fComp);\n+    std::vector<unsigned char> pubkey;\n+    key.GetPubKey(pubkey, fComp);\n+    Set(pubkey.begin(), pubkey.end());\n #endif\n     return true;\n }\n@@ -579,7 +582,7 @@ bool CPubKey::IsFullyValid() const {\n         return false;\n #else\n     CECKey key;\n-    if (!key.SetPubKey(*this))\n+    if (!key.SetPubKey(begin(), size()))\n         return false;\n #endif\n     return true;\n@@ -595,9 +598,11 @@ bool CPubKey::Decompress() {\n     assert(clen == (int)size());\n #else\n     CECKey key;\n-    if (!key.SetPubKey(*this))\n+    if (!key.SetPubKey(begin(), size()))\n         return false;\n-    key.GetPubKey(*this, false);\n+    std::vector<unsigned char> pubkey;\n+    key.GetPubKey(pubkey, false);\n+    Set(pubkey.begin(), pubkey.end());\n #endif\n     return true;\n }\n@@ -652,9 +657,11 @@ bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned i\n     bool ret = secp256k1_ecdsa_pubkey_tweak_add((unsigned char*)pubkeyChild.begin(), pubkeyChild.size(), out);\n #else\n     CECKey key;\n-    bool ret = key.SetPubKey(*this);\n+    bool ret = key.SetPubKey(begin(), size());\n     ret &= key.TweakPublic(out);\n-    key.GetPubKey(pubkeyChild, true);\n+    std::vector<unsigned char> pubkey;\n+    key.GetPubKey(pubkey, true);\n+    pubkeyChild.Set(pubkey.begin(), pubkey.end());\n #endif\n     return ret;\n }"
      }
    ]
  },
  {
    "sha": "50f71cd52e1eb35b10564f73a54fe5ea5b245418",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MGY3MWNkNTJlMWViMzViMTA1NjRmNzNhNTRmZTVlYTViMjQ1NDE4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-10-21T19:04:03Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-10-27T19:00:58Z"
      },
      "message": "boost: code movement only: split CECKey into separate files",
      "tree": {
        "sha": "92d6277bca657230aac6aaa6dc0bca5e578181b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92d6277bca657230aac6aaa6dc0bca5e578181b2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/50f71cd52e1eb35b10564f73a54fe5ea5b245418",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50f71cd52e1eb35b10564f73a54fe5ea5b245418",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/50f71cd52e1eb35b10564f73a54fe5ea5b245418",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50f71cd52e1eb35b10564f73a54fe5ea5b245418/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdaec6abd35dd93ae6b29f44b8cbf9c3af3f6805"
      }
    ],
    "stats": {
      "total": 714,
      "additions": 384,
      "deletions": 330
    },
    "files": [
      {
        "sha": "00da8b2372353d764c554c1f73aefbd98603c647",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=50f71cd52e1eb35b10564f73a54fe5ea5b245418",
        "patch": "@@ -82,6 +82,7 @@ BITCOIN_CORE_H = \\\n   core_io.h \\\n   crypter.h \\\n   db.h \\\n+  ecwrapper.h \\\n   hash.h \\\n   init.h \\\n   key.h \\\n@@ -211,6 +212,7 @@ libbitcoin_common_a_SOURCES = \\\n   core.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\\n+  ecwrapper.cpp \\\n   hash.cpp \\\n   key.cpp \\\n   keystore.cpp \\"
      },
      {
        "sha": "e5db6709272d56d3c8b2756679267997878c234d",
        "filename": "src/ecwrapper.cpp",
        "status": "added",
        "additions": 333,
        "deletions": 0,
        "changes": 333,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/ecwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/ecwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.cpp?ref=50f71cd52e1eb35b10564f73a54fe5ea5b245418",
        "patch": "@@ -0,0 +1,333 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"ecwrapper.h\"\n+\n+#include \"serialize.h\"\n+#include \"uint256.h\"\n+\n+#include <openssl/bn.h>\n+#include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+\n+namespace {\n+\n+// Generate a private key from just the secret parameter\n+int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n+{\n+    int ok = 0;\n+    BN_CTX *ctx = NULL;\n+    EC_POINT *pub_key = NULL;\n+\n+    if (!eckey) return 0;\n+\n+    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n+\n+    if ((ctx = BN_CTX_new()) == NULL)\n+        goto err;\n+\n+    pub_key = EC_POINT_new(group);\n+\n+    if (pub_key == NULL)\n+        goto err;\n+\n+    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n+        goto err;\n+\n+    EC_KEY_set_private_key(eckey,priv_key);\n+    EC_KEY_set_public_key(eckey,pub_key);\n+\n+    ok = 1;\n+\n+err:\n+\n+    if (pub_key)\n+        EC_POINT_free(pub_key);\n+    if (ctx != NULL)\n+        BN_CTX_free(ctx);\n+\n+    return(ok);\n+}\n+\n+// Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n+// recid selects which key is recovered\n+// if check is non-zero, additional checks are performed\n+int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n+{\n+    if (!eckey) return 0;\n+\n+    int ret = 0;\n+    BN_CTX *ctx = NULL;\n+\n+    BIGNUM *x = NULL;\n+    BIGNUM *e = NULL;\n+    BIGNUM *order = NULL;\n+    BIGNUM *sor = NULL;\n+    BIGNUM *eor = NULL;\n+    BIGNUM *field = NULL;\n+    EC_POINT *R = NULL;\n+    EC_POINT *O = NULL;\n+    EC_POINT *Q = NULL;\n+    BIGNUM *rr = NULL;\n+    BIGNUM *zero = NULL;\n+    int n = 0;\n+    int i = recid / 2;\n+\n+    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n+    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n+    BN_CTX_start(ctx);\n+    order = BN_CTX_get(ctx);\n+    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n+    x = BN_CTX_get(ctx);\n+    if (!BN_copy(x, order)) { ret=-1; goto err; }\n+    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n+    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n+    field = BN_CTX_get(ctx);\n+    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n+    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n+    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n+    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n+    if (check)\n+    {\n+        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n+        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n+        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n+    }\n+    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n+    n = EC_GROUP_get_degree(group);\n+    e = BN_CTX_get(ctx);\n+    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n+    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n+    zero = BN_CTX_get(ctx);\n+    if (!BN_zero(zero)) { ret=-1; goto err; }\n+    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n+    rr = BN_CTX_get(ctx);\n+    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n+    sor = BN_CTX_get(ctx);\n+    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n+    eor = BN_CTX_get(ctx);\n+    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n+    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n+    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n+\n+    ret = 1;\n+\n+err:\n+    if (ctx) {\n+        BN_CTX_end(ctx);\n+        BN_CTX_free(ctx);\n+    }\n+    if (R != NULL) EC_POINT_free(R);\n+    if (O != NULL) EC_POINT_free(O);\n+    if (Q != NULL) EC_POINT_free(Q);\n+    return ret;\n+}\n+\n+} // anon namespace\n+\n+CECKey::CECKey() {\n+    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    assert(pkey != NULL);\n+}\n+\n+CECKey::~CECKey() {\n+    EC_KEY_free(pkey);\n+}\n+\n+void CECKey::GetSecretBytes(unsigned char vch[32]) const {\n+    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n+    assert(bn);\n+    int nBytes = BN_num_bytes(bn);\n+    int n=BN_bn2bin(bn,&vch[32 - nBytes]);\n+    assert(n == nBytes);\n+    memset(vch, 0, 32 - nBytes);\n+}\n+\n+void CECKey::SetSecretBytes(const unsigned char vch[32]) {\n+    bool ret;\n+    BIGNUM bn;\n+    BN_init(&bn);\n+    ret = BN_bin2bn(vch, 32, &bn) != NULL;\n+    assert(ret);\n+    ret = EC_KEY_regenerate_key(pkey, &bn) != 0;\n+    assert(ret);\n+    BN_clear_free(&bn);\n+}\n+\n+int CECKey::GetPrivKeySize(bool fCompressed) {\n+    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n+    return i2d_ECPrivateKey(pkey, NULL);\n+}\n+int CECKey::GetPrivKey(unsigned char* privkey, bool fCompressed) {\n+    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n+    return i2d_ECPrivateKey(pkey, &privkey);\n+}\n+\n+bool CECKey::SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck) {\n+    if (d2i_ECPrivateKey(&pkey, &privkey, size)) {\n+        if(fSkipCheck)\n+            return true;\n+\n+        // d2i_ECPrivateKey returns true if parsing succeeds.\n+        // This doesn't necessarily mean the key is valid.\n+        if (EC_KEY_check_key(pkey))\n+            return true;\n+    }\n+    return false;\n+}\n+\n+void CECKey::GetPubKey(std::vector<unsigned char> &pubkey, bool fCompressed) {\n+    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n+    int nSize = i2o_ECPublicKey(pkey, NULL);\n+    assert(nSize);\n+    assert(nSize <= 65);\n+    pubkey.clear();\n+    pubkey.resize(nSize);\n+    unsigned char *pbegin(begin_ptr(pubkey));\n+    int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n+    assert(nSize == nSize2);\n+}\n+\n+bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size) {\n+    return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n+}\n+\n+bool CECKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS) {\n+    vchSig.clear();\n+    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+    if (sig == NULL)\n+        return false;\n+    BN_CTX *ctx = BN_CTX_new();\n+    BN_CTX_start(ctx);\n+    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n+    BIGNUM *order = BN_CTX_get(ctx);\n+    BIGNUM *halforder = BN_CTX_get(ctx);\n+    EC_GROUP_get_order(group, order, ctx);\n+    BN_rshift1(halforder, order);\n+    if (lowS && BN_cmp(sig->s, halforder) > 0) {\n+        // enforce low S values, by negating the value (modulo the order) if above order/2.\n+        BN_sub(sig->s, order, sig->s);\n+    }\n+    BN_CTX_end(ctx);\n+    BN_CTX_free(ctx);\n+    unsigned int nSize = ECDSA_size(pkey);\n+    vchSig.resize(nSize); // Make sure it is big enough\n+    unsigned char *pos = &vchSig[0];\n+    nSize = i2d_ECDSA_SIG(sig, &pos);\n+    ECDSA_SIG_free(sig);\n+    vchSig.resize(nSize); // Shrink to fit actual size\n+    return true;\n+}\n+\n+bool CECKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n+    // -1 = error, 0 = bad sig, 1 = good\n+    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n+        return false;\n+    return true;\n+}\n+\n+bool CECKey::SignCompact(const uint256 &hash, unsigned char *p64, int &rec) {\n+    bool fOk = false;\n+    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+    if (sig==NULL)\n+        return false;\n+    memset(p64, 0, 64);\n+    int nBitsR = BN_num_bits(sig->r);\n+    int nBitsS = BN_num_bits(sig->s);\n+    if (nBitsR <= 256 && nBitsS <= 256) {\n+        std::vector<unsigned char> pubkey;\n+        GetPubKey(pubkey, true);\n+        for (int i=0; i<4; i++) {\n+            CECKey keyRec;\n+            if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1) {\n+                std::vector<unsigned char> pubkeyRec;\n+                keyRec.GetPubKey(pubkeyRec, true);\n+                if (pubkeyRec == pubkey) {\n+                    rec = i;\n+                    fOk = true;\n+                    break;\n+                }\n+            }\n+        }\n+        assert(fOk);\n+        BN_bn2bin(sig->r,&p64[32-(nBitsR+7)/8]);\n+        BN_bn2bin(sig->s,&p64[64-(nBitsS+7)/8]);\n+    }\n+    ECDSA_SIG_free(sig);\n+    return fOk;\n+}\n+\n+bool CECKey::Recover(const uint256 &hash, const unsigned char *p64, int rec)\n+{\n+    if (rec<0 || rec>=3)\n+        return false;\n+    ECDSA_SIG *sig = ECDSA_SIG_new();\n+    BN_bin2bn(&p64[0],  32, sig->r);\n+    BN_bin2bn(&p64[32], 32, sig->s);\n+    bool ret = ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), rec, 0) == 1;\n+    ECDSA_SIG_free(sig);\n+    return ret;\n+}\n+\n+bool CECKey::TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32], const unsigned char vchTweak[32])\n+{\n+    bool ret = true;\n+    BN_CTX *ctx = BN_CTX_new();\n+    BN_CTX_start(ctx);\n+    BIGNUM *bnSecret = BN_CTX_get(ctx);\n+    BIGNUM *bnTweak = BN_CTX_get(ctx);\n+    BIGNUM *bnOrder = BN_CTX_get(ctx);\n+    EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+    EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n+    BN_bin2bn(vchTweak, 32, bnTweak);\n+    if (BN_cmp(bnTweak, bnOrder) >= 0)\n+        ret = false; // extremely unlikely\n+    BN_bin2bn(vchSecretIn, 32, bnSecret);\n+    BN_add(bnSecret, bnSecret, bnTweak);\n+    BN_nnmod(bnSecret, bnSecret, bnOrder, ctx);\n+    if (BN_is_zero(bnSecret))\n+        ret = false; // ridiculously unlikely\n+    int nBits = BN_num_bits(bnSecret);\n+    memset(vchSecretOut, 0, 32);\n+    BN_bn2bin(bnSecret, &vchSecretOut[32-(nBits+7)/8]);\n+    EC_GROUP_free(group);\n+    BN_CTX_end(ctx);\n+    BN_CTX_free(ctx);\n+    return ret;\n+}\n+\n+bool CECKey::TweakPublic(const unsigned char vchTweak[32]) {\n+    bool ret = true;\n+    BN_CTX *ctx = BN_CTX_new();\n+    BN_CTX_start(ctx);\n+    BIGNUM *bnTweak = BN_CTX_get(ctx);\n+    BIGNUM *bnOrder = BN_CTX_get(ctx);\n+    BIGNUM *bnOne = BN_CTX_get(ctx);\n+    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n+    EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n+    BN_bin2bn(vchTweak, 32, bnTweak);\n+    if (BN_cmp(bnTweak, bnOrder) >= 0)\n+        ret = false; // extremely unlikely\n+    EC_POINT *point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n+    BN_one(bnOne);\n+    EC_POINT_mul(group, point, bnTweak, point, bnOne, ctx);\n+    if (EC_POINT_is_at_infinity(group, point))\n+        ret = false; // ridiculously unlikely\n+    EC_KEY_set_public_key(pkey, point);\n+    EC_POINT_free(point);\n+    BN_CTX_end(ctx);\n+    BN_CTX_free(ctx);\n+    return ret;\n+}\n+\n+bool CECKey::SanityCheck()\n+{\n+    EC_KEY *pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    if(pkey == NULL)\n+        return false;\n+    EC_KEY_free(pkey);\n+\n+    // TODO Is there more EC functionality that could be missing?\n+    return true;\n+}"
      },
      {
        "sha": "072da4a942f1d4487eb1eee2818d96e6ef62f88d",
        "filename": "src/ecwrapper.h",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/ecwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/ecwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.h?ref=50f71cd52e1eb35b10564f73a54fe5ea5b245418",
        "patch": "@@ -0,0 +1,46 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_EC_WRAPPER_H\n+#define BITCOIN_EC_WRAPPER_H\n+\n+#include <cstddef>\n+#include <vector>\n+\n+#include <openssl/ec.h>\n+\n+class uint256;\n+\n+// RAII Wrapper around OpenSSL's EC_KEY\n+class CECKey {\n+private:\n+    EC_KEY *pkey;\n+\n+public:\n+    CECKey();\n+    ~CECKey();\n+\n+    void GetSecretBytes(unsigned char vch[32]) const;\n+    void SetSecretBytes(const unsigned char vch[32]);\n+    int GetPrivKeySize(bool fCompressed);\n+    int GetPrivKey(unsigned char* privkey, bool fCompressed);\n+    bool SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck=false);\n+    void GetPubKey(std::vector<unsigned char>& pubkey, bool fCompressed);\n+    bool SetPubKey(const unsigned char* pubkey, size_t size);\n+    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS);\n+    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n+    bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec);\n+\n+    // reconstruct public key from a compact signature\n+    // This is only slightly more CPU intensive than just verifying it.\n+    // If this function succeeds, the recovered public key is guaranteed to be valid\n+    // (the signature is a valid signature of the given data for that key)\n+    bool Recover(const uint256 &hash, const unsigned char *p64, int rec);\n+\n+    static bool TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32], const unsigned char vchTweak[32]);\n+    bool TweakPublic(const unsigned char vchTweak[32]);\n+    static bool SanityCheck();\n+};\n+\n+#endif"
      },
      {
        "sha": "0f4bc6652c8caf76e11136a6f9d6b2fe23471bb6",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 330,
        "changes": 333,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50f71cd52e1eb35b10564f73a54fe5ea5b245418/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=50f71cd52e1eb35b10564f73a54fe5ea5b245418",
        "patch": "@@ -10,12 +10,10 @@\n #ifdef USE_SECP256K1\n #include <secp256k1.h>\n #else\n-#include <openssl/bn.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n+#include \"ecwrapper.h\"\n #endif\n \n-// anonymous namespace with local implementation code (OpenSSL interaction)\n+// anonymous namespace\n namespace {\n \n #ifdef USE_SECP256K1\n@@ -31,325 +29,6 @@ class CSecp256k1Init {\n };\n static CSecp256k1Init instance_of_csecp256k1;\n \n-#else\n-\n-// Generate a private key from just the secret parameter\n-int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n-{\n-    int ok = 0;\n-    BN_CTX *ctx = NULL;\n-    EC_POINT *pub_key = NULL;\n-\n-    if (!eckey) return 0;\n-\n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n-\n-    if ((ctx = BN_CTX_new()) == NULL)\n-        goto err;\n-\n-    pub_key = EC_POINT_new(group);\n-\n-    if (pub_key == NULL)\n-        goto err;\n-\n-    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n-        goto err;\n-\n-    EC_KEY_set_private_key(eckey,priv_key);\n-    EC_KEY_set_public_key(eckey,pub_key);\n-\n-    ok = 1;\n-\n-err:\n-\n-    if (pub_key)\n-        EC_POINT_free(pub_key);\n-    if (ctx != NULL)\n-        BN_CTX_free(ctx);\n-\n-    return(ok);\n-}\n-\n-// Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n-// recid selects which key is recovered\n-// if check is non-zero, additional checks are performed\n-int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n-{\n-    if (!eckey) return 0;\n-\n-    int ret = 0;\n-    BN_CTX *ctx = NULL;\n-\n-    BIGNUM *x = NULL;\n-    BIGNUM *e = NULL;\n-    BIGNUM *order = NULL;\n-    BIGNUM *sor = NULL;\n-    BIGNUM *eor = NULL;\n-    BIGNUM *field = NULL;\n-    EC_POINT *R = NULL;\n-    EC_POINT *O = NULL;\n-    EC_POINT *Q = NULL;\n-    BIGNUM *rr = NULL;\n-    BIGNUM *zero = NULL;\n-    int n = 0;\n-    int i = recid / 2;\n-\n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n-    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n-    BN_CTX_start(ctx);\n-    order = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n-    x = BN_CTX_get(ctx);\n-    if (!BN_copy(x, order)) { ret=-1; goto err; }\n-    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n-    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n-    field = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n-    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n-    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n-    if (check)\n-    {\n-        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n-        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n-    }\n-    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-    n = EC_GROUP_get_degree(group);\n-    e = BN_CTX_get(ctx);\n-    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n-    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n-    zero = BN_CTX_get(ctx);\n-    if (!BN_zero(zero)) { ret=-1; goto err; }\n-    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n-    rr = BN_CTX_get(ctx);\n-    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n-    sor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n-    eor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n-    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n-    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n-\n-    ret = 1;\n-\n-err:\n-    if (ctx) {\n-        BN_CTX_end(ctx);\n-        BN_CTX_free(ctx);\n-    }\n-    if (R != NULL) EC_POINT_free(R);\n-    if (O != NULL) EC_POINT_free(O);\n-    if (Q != NULL) EC_POINT_free(Q);\n-    return ret;\n-}\n-\n-// RAII Wrapper around OpenSSL's EC_KEY\n-class CECKey {\n-private:\n-    EC_KEY *pkey;\n-\n-public:\n-    CECKey() {\n-        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-        assert(pkey != NULL);\n-    }\n-\n-    ~CECKey() {\n-        EC_KEY_free(pkey);\n-    }\n-\n-    void GetSecretBytes(unsigned char vch[32]) const {\n-        const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n-        assert(bn);\n-        int nBytes = BN_num_bytes(bn);\n-        int n=BN_bn2bin(bn,&vch[32 - nBytes]);\n-        assert(n == nBytes);\n-        memset(vch, 0, 32 - nBytes);\n-    }\n-\n-    void SetSecretBytes(const unsigned char vch[32]) {\n-        bool ret;\n-        BIGNUM bn;\n-        BN_init(&bn);\n-        ret = BN_bin2bn(vch, 32, &bn) != NULL;\n-        assert(ret);\n-        ret = EC_KEY_regenerate_key(pkey, &bn) != 0;\n-        assert(ret);\n-        BN_clear_free(&bn);\n-    }\n-\n-    int GetPrivKeySize(bool fCompressed) {\n-        EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-        return i2d_ECPrivateKey(pkey, NULL);\n-    }\n-    int GetPrivKey(unsigned char* privkey, bool fCompressed) {\n-        EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-        return i2d_ECPrivateKey(pkey, &privkey);\n-    }\n-\n-    bool SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck=false) {\n-        if (d2i_ECPrivateKey(&pkey, &privkey, size)) {\n-            if(fSkipCheck)\n-                return true;\n-\n-            // d2i_ECPrivateKey returns true if parsing succeeds.\n-            // This doesn't necessarily mean the key is valid.\n-            if (EC_KEY_check_key(pkey))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n-    void GetPubKey(std::vector<unsigned char> &pubkey, bool fCompressed) {\n-        EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-        int nSize = i2o_ECPublicKey(pkey, NULL);\n-        assert(nSize);\n-        assert(nSize <= 65);\n-        pubkey.clear();\n-        pubkey.resize(nSize);\n-        unsigned char *pbegin(begin_ptr(pubkey));\n-        int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n-        assert(nSize == nSize2);\n-    }\n-\n-    bool SetPubKey(const unsigned char* pubkey, size_t size) {\n-        return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n-    }\n-\n-    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS) {\n-        vchSig.clear();\n-        ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-        if (sig == NULL)\n-            return false;\n-        BN_CTX *ctx = BN_CTX_new();\n-        BN_CTX_start(ctx);\n-        const EC_GROUP *group = EC_KEY_get0_group(pkey);\n-        BIGNUM *order = BN_CTX_get(ctx);\n-        BIGNUM *halforder = BN_CTX_get(ctx);\n-        EC_GROUP_get_order(group, order, ctx);\n-        BN_rshift1(halforder, order);\n-        if (lowS && BN_cmp(sig->s, halforder) > 0) {\n-            // enforce low S values, by negating the value (modulo the order) if above order/2.\n-            BN_sub(sig->s, order, sig->s);\n-        }\n-        BN_CTX_end(ctx);\n-        BN_CTX_free(ctx);\n-        unsigned int nSize = ECDSA_size(pkey);\n-        vchSig.resize(nSize); // Make sure it is big enough\n-        unsigned char *pos = &vchSig[0];\n-        nSize = i2d_ECDSA_SIG(sig, &pos);\n-        ECDSA_SIG_free(sig);\n-        vchSig.resize(nSize); // Shrink to fit actual size\n-        return true;\n-    }\n-\n-    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n-        // -1 = error, 0 = bad sig, 1 = good\n-        if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n-            return false;\n-        return true;\n-    }\n-\n-    bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec) {\n-        bool fOk = false;\n-        ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-        if (sig==NULL)\n-            return false;\n-        memset(p64, 0, 64);\n-        int nBitsR = BN_num_bits(sig->r);\n-        int nBitsS = BN_num_bits(sig->s);\n-        if (nBitsR <= 256 && nBitsS <= 256) {\n-            std::vector<unsigned char> pubkey;\n-            GetPubKey(pubkey, true);\n-            for (int i=0; i<4; i++) {\n-                CECKey keyRec;\n-                if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1) {\n-                    std::vector<unsigned char> pubkeyRec;\n-                    keyRec.GetPubKey(pubkeyRec, true);\n-                    if (pubkeyRec == pubkey) {\n-                        rec = i;\n-                        fOk = true;\n-                        break;\n-                    }\n-                }\n-            }\n-            assert(fOk);\n-            BN_bn2bin(sig->r,&p64[32-(nBitsR+7)/8]);\n-            BN_bn2bin(sig->s,&p64[64-(nBitsS+7)/8]);\n-        }\n-        ECDSA_SIG_free(sig);\n-        return fOk;\n-    }\n-\n-    // reconstruct public key from a compact signature\n-    // This is only slightly more CPU intensive than just verifying it.\n-    // If this function succeeds, the recovered public key is guaranteed to be valid\n-    // (the signature is a valid signature of the given data for that key)\n-    bool Recover(const uint256 &hash, const unsigned char *p64, int rec)\n-    {\n-        if (rec<0 || rec>=3)\n-            return false;\n-        ECDSA_SIG *sig = ECDSA_SIG_new();\n-        BN_bin2bn(&p64[0],  32, sig->r);\n-        BN_bin2bn(&p64[32], 32, sig->s);\n-        bool ret = ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), rec, 0) == 1;\n-        ECDSA_SIG_free(sig);\n-        return ret;\n-    }\n-\n-    static bool TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32], const unsigned char vchTweak[32])\n-    {\n-        bool ret = true;\n-        BN_CTX *ctx = BN_CTX_new();\n-        BN_CTX_start(ctx);\n-        BIGNUM *bnSecret = BN_CTX_get(ctx);\n-        BIGNUM *bnTweak = BN_CTX_get(ctx);\n-        BIGNUM *bnOrder = BN_CTX_get(ctx);\n-        EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-        EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n-        BN_bin2bn(vchTweak, 32, bnTweak);\n-        if (BN_cmp(bnTweak, bnOrder) >= 0)\n-            ret = false; // extremely unlikely\n-        BN_bin2bn(vchSecretIn, 32, bnSecret);\n-        BN_add(bnSecret, bnSecret, bnTweak);\n-        BN_nnmod(bnSecret, bnSecret, bnOrder, ctx);\n-        if (BN_is_zero(bnSecret))\n-            ret = false; // ridiculously unlikely\n-        int nBits = BN_num_bits(bnSecret);\n-        memset(vchSecretOut, 0, 32);\n-        BN_bn2bin(bnSecret, &vchSecretOut[32-(nBits+7)/8]);\n-        EC_GROUP_free(group);\n-        BN_CTX_end(ctx);\n-        BN_CTX_free(ctx);\n-        return ret;\n-    }\n-\n-    bool TweakPublic(const unsigned char vchTweak[32]) {\n-        bool ret = true;\n-        BN_CTX *ctx = BN_CTX_new();\n-        BN_CTX_start(ctx);\n-        BIGNUM *bnTweak = BN_CTX_get(ctx);\n-        BIGNUM *bnOrder = BN_CTX_get(ctx);\n-        BIGNUM *bnOne = BN_CTX_get(ctx);\n-        const EC_GROUP *group = EC_KEY_get0_group(pkey);\n-        EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n-        BN_bin2bn(vchTweak, 32, bnTweak);\n-        if (BN_cmp(bnTweak, bnOrder) >= 0)\n-            ret = false; // extremely unlikely\n-        EC_POINT *point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n-        BN_one(bnOne);\n-        EC_POINT_mul(group, point, bnTweak, point, bnOne, ctx);\n-        if (EC_POINT_is_at_infinity(group, point))\n-            ret = false; // ridiculously unlikely\n-        EC_KEY_set_public_key(pkey, point);\n-        EC_POINT_free(point);\n-        BN_CTX_end(ctx);\n-        BN_CTX_free(ctx);\n-        return ret;\n-    }\n-};\n-\n #endif\n \n int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char *c2, size_t c2len) {\n@@ -746,12 +425,6 @@ bool ECC_InitSanityCheck() {\n #ifdef USE_SECP256K1\n     return true;\n #else\n-    EC_KEY *pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    if(pkey == NULL)\n-        return false;\n-    EC_KEY_free(pkey);\n-\n-    // TODO Is there more EC functionality that could be missing?\n-    return true;\n+    return CECKey::SanityCheck();\n #endif\n }"
      }
    ]
  }
]