[
  {
    "sha": "84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NDY3NDA4MmIwYzRjZmNkZDU0ZmI5N2EyOWJjODQxYWE3ZjY5MWMy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2013-11-05T01:27:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-11-10T18:22:53Z"
      },
      "message": "Make CCoinsView use block hashes instead of indices",
      "tree": {
        "sha": "87fb3462d81b84c0d4a64cb5eca7ab8c64895091",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87fb3462d81b84c0d4a64cb5eca7ab8c64895091"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f76c122e2eac8ef66f69d142231bd33c88a24c50",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f76c122e2eac8ef66f69d142231bd33c88a24c50",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f76c122e2eac8ef66f69d142231bd33c88a24c50"
      }
    ],
    "stats": {
      "total": 116,
      "additions": 60,
      "deletions": 56
    },
    "files": [
      {
        "sha": "5b330536fd2661d0439a718b9b4cee320bd47d4e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 26,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "patch": "@@ -236,23 +236,23 @@ CBlockIndex *CChain::FindFork(const CBlockLocator &locator) const {\n bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) { return false; }\n bool CCoinsView::SetCoins(const uint256 &txid, const CCoins &coins) { return false; }\n bool CCoinsView::HaveCoins(const uint256 &txid) { return false; }\n-CBlockIndex *CCoinsView::GetBestBlock() { return NULL; }\n-bool CCoinsView::SetBestBlock(CBlockIndex *pindex) { return false; }\n-bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return false; }\n+uint256 CCoinsView::GetBestBlock() { return uint256(0); }\n+bool CCoinsView::SetBestBlock(const uint256 &hashBlock) { return false; }\n+bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return false; }\n bool CCoinsView::GetStats(CCoinsStats &stats) { return false; }\n \n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) { return base->GetCoins(txid, coins); }\n bool CCoinsViewBacked::SetCoins(const uint256 &txid, const CCoins &coins) { return base->SetCoins(txid, coins); }\n bool CCoinsViewBacked::HaveCoins(const uint256 &txid) { return base->HaveCoins(txid); }\n-CBlockIndex *CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n-bool CCoinsViewBacked::SetBestBlock(CBlockIndex *pindex) { return base->SetBestBlock(pindex); }\n+uint256 CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n+bool CCoinsViewBacked::SetBestBlock(const uint256 &hashBlock) { return base->SetBestBlock(hashBlock); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return base->BatchWrite(mapCoins, pindex); }\n+bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n bool CCoinsViewBacked::GetStats(CCoinsStats &stats) { return base->GetStats(stats); }\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), pindexTip(NULL) { }\n+CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), hashBlock(0) { }\n \n bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) {\n     if (cacheCoins.count(txid)) {\n@@ -293,26 +293,26 @@ bool CCoinsViewCache::HaveCoins(const uint256 &txid) {\n     return FetchCoins(txid) != cacheCoins.end();\n }\n \n-CBlockIndex *CCoinsViewCache::GetBestBlock() {\n-    if (pindexTip == NULL)\n-        pindexTip = base->GetBestBlock();\n-    return pindexTip;\n+uint256 CCoinsViewCache::GetBestBlock() {\n+    if (hashBlock == uint256(0))\n+        hashBlock = base->GetBestBlock();\n+    return hashBlock;\n }\n \n-bool CCoinsViewCache::SetBestBlock(CBlockIndex *pindex) {\n-    pindexTip = pindex;\n+bool CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n+    hashBlock = hashBlockIn;\n     return true;\n }\n \n-bool CCoinsViewCache::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n+bool CCoinsViewCache::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlockIn) {\n     for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n         cacheCoins[it->first] = it->second;\n-    pindexTip = pindex;\n+    hashBlock = hashBlockIn;\n     return true;\n }\n \n bool CCoinsViewCache::Flush() {\n-    bool fOk = base->BatchWrite(cacheCoins, pindexTip);\n+    bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     if (fOk)\n         cacheCoins.clear();\n     return fOk;\n@@ -1498,7 +1498,8 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n \n         // While checking, GetBestBlock() refers to the parent block.\n         // This is also true for mempool checks.\n-        int nSpendHeight = inputs.GetBestBlock()->nHeight + 1;\n+        CBlockIndex *pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;\n+        int nSpendHeight = pindexPrev->nHeight + 1;\n         int64_t nValueIn = 0;\n         int64_t nFees = 0;\n         for (unsigned int i = 0; i < tx.vin.size(); i++)\n@@ -1568,7 +1569,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n \n bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, bool* pfClean)\n {\n-    assert(pindex == view.GetBestBlock());\n+    assert(pindex->GetBlockHash() == view.GetBestBlock());\n \n     if (pfClean)\n         *pfClean = false;\n@@ -1644,7 +1645,7 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n     }\n \n     // move best block pointer to prevout block\n-    view.SetBestBlock(pindex->pprev);\n+    view.SetBestBlock(pindex->pprev->GetBlockHash());\n \n     if (pfClean) {\n         *pfClean = fClean;\n@@ -1693,12 +1694,13 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         return false;\n \n     // verify that the view's current state corresponds to the previous block\n-    assert(pindex->pprev == view.GetBestBlock());\n+    uint256 hashPrevBlock = pindex->pprev == NULL ? uint256(0) : pindex->pprev->GetBlockHash();\n+    assert(hashPrevBlock == view.GetBestBlock());\n \n     // Special case for the genesis block, skipping connection of its transactions\n     // (its coinbase is unspendable)\n     if (block.GetHash() == Params().HashGenesisBlock()) {\n-        view.SetBestBlock(pindex);\n+        view.SetBestBlock(pindex->GetBlockHash());\n         return true;\n     }\n \n@@ -1828,7 +1830,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n             return state.Abort(_(\"Failed to write transaction index\"));\n \n     // add this block to the view's block chain\n-    assert(view.SetBestBlock(pindex));\n+    assert(view.SetBestBlock(pindex->GetBlockHash()));\n \n     // Watch for transactions paying to me\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n@@ -1846,7 +1848,9 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     CCoinsViewCache view(*pcoinsTip, true);\n \n     // Find the fork (typically, there is none)\n-    CBlockIndex* pfork = view.GetBestBlock();\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(view.GetBestBlock());\n+    CBlockIndex* ptip = (it != mapBlockIndex.end()) ? it->second : NULL;\n+    CBlockIndex* pfork = ptip;\n     CBlockIndex* plonger = pindexNew;\n     while (pfork && pfork != plonger)\n     {\n@@ -1862,7 +1866,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n \n     // List of what to disconnect (typically nothing)\n     vector<CBlockIndex*> vDisconnect;\n-    for (CBlockIndex* pindex = view.GetBestBlock(); pindex != pfork; pindex = pindex->pprev)\n+    for (CBlockIndex* pindex = ptip; pindex != pfork; pindex = pindex->pprev)\n         vDisconnect.push_back(pindex);\n \n     // List of what to connect (typically only pindexNew)\n@@ -2687,9 +2691,10 @@ bool static LoadBlockIndexDB()\n     LogPrintf(\"LoadBlockIndexDB(): transaction index %s\\n\", fTxIndex ? \"enabled\" : \"disabled\");\n \n     // Load pointer to end of best chain\n-    chainActive.SetTip(pcoinsTip->GetBestBlock());\n-    if (chainActive.Tip() == NULL)\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n+    if (it == mapBlockIndex.end())\n         return true;\n+    chainActive.SetTip(it->second);\n     LogPrintf(\"LoadBlockIndexDB(): hashBestChain=%s  height=%d date=%s\\n\",\n         chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(),\n         DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());"
      },
      {
        "sha": "b8db357aedfb45805dcc2ad7094d6ce3bc040093",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "patch": "@@ -1062,14 +1062,14 @@ class CCoinsView\n     // This may (but cannot always) return true for fully spent transactions\n     virtual bool HaveCoins(const uint256 &txid);\n \n-    // Retrieve the block index whose state this CCoinsView currently represents\n-    virtual CBlockIndex *GetBestBlock();\n+    // Retrieve the block hash whose state this CCoinsView currently represents\n+    virtual uint256 GetBestBlock();\n \n-    // Modify the currently active block index\n-    virtual bool SetBestBlock(CBlockIndex *pindex);\n+    // Modify the currently active block hash\n+    virtual bool SetBestBlock(const uint256 &hashBlock);\n \n     // Do a bulk modification (multiple SetCoins + one SetBestBlock)\n-    virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n \n     // Calculate statistics about the unspent transaction output set\n     virtual bool GetStats(CCoinsStats &stats);\n@@ -1089,18 +1089,18 @@ class CCoinsViewBacked : public CCoinsView\n     bool GetCoins(const uint256 &txid, CCoins &coins);\n     bool SetCoins(const uint256 &txid, const CCoins &coins);\n     bool HaveCoins(const uint256 &txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n+    uint256 GetBestBlock();\n+    bool SetBestBlock(const uint256 &hashBlock);\n     void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n     bool GetStats(CCoinsStats &stats);\n };\n \n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n {\n protected:\n-    CBlockIndex *pindexTip;\n+    uint256 hashBlock;\n     std::map<uint256,CCoins> cacheCoins;\n \n public:\n@@ -1110,9 +1110,9 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool GetCoins(const uint256 &txid, CCoins &coins);\n     bool SetCoins(const uint256 &txid, const CCoins &coins);\n     bool HaveCoins(const uint256 &txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    uint256 GetBestBlock();\n+    bool SetBestBlock(const uint256 &hashBlock);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n \n     // Return a modifiable reference to a CCoins. Check HaveCoins first.\n     // Many methods explicitly require a CCoinsViewCache because of this method, to reduce"
      },
      {
        "sha": "483d8d2e8d409149340be070614d5a6a399667a1",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "patch": "@@ -245,11 +245,13 @@ Value gettxout(const Array& params, bool fHelp)\n     if (n<0 || (unsigned int)n>=coins.vout.size() || coins.vout[n].IsNull())\n         return Value::null;\n \n-    ret.push_back(Pair(\"bestblock\", pcoinsTip->GetBestBlock()->GetBlockHash().GetHex()));\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n+    CBlockIndex *pindex = it->second;\n+    ret.push_back(Pair(\"bestblock\", pindex->GetBlockHash().GetHex()));\n     if ((unsigned int)coins.nHeight == MEMPOOL_HEIGHT)\n         ret.push_back(Pair(\"confirmations\", 0));\n     else\n-        ret.push_back(Pair(\"confirmations\", pcoinsTip->GetBestBlock()->nHeight - coins.nHeight + 1));\n+        ret.push_back(Pair(\"confirmations\", pindex->nHeight - coins.nHeight + 1));\n     ret.push_back(Pair(\"value\", ValueFromAmount(coins.vout[n].nValue)));\n     Object o;\n     ScriptPubKeyToJSON(coins.vout[n].scriptPubKey, o, true);"
      },
      {
        "sha": "99deb31404a6beb2defc39234d6c2ddc72daae42",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 13,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "patch": "@@ -40,30 +40,27 @@ bool CCoinsViewDB::HaveCoins(const uint256 &txid) {\n     return db.Exists(make_pair('c', txid)); \n }\n \n-CBlockIndex *CCoinsViewDB::GetBestBlock() {\n+uint256 CCoinsViewDB::GetBestBlock() {\n     uint256 hashBestChain;\n     if (!db.Read('B', hashBestChain))\n-        return NULL;\n-    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n-    if (it == mapBlockIndex.end())\n-        return NULL;\n-    return it->second;\n+        return uint256(0);\n+    return hashBestChain;\n }\n \n-bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) {\n+bool CCoinsViewDB::SetBestBlock(const uint256 &hashBlock) {\n     CLevelDBBatch batch;\n-    BatchWriteHashBestChain(batch, pindex->GetBlockHash()); \n+    BatchWriteHashBestChain(batch, hashBlock);\n     return db.WriteBatch(batch);\n }\n \n-bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n+bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) {\n     LogPrint(\"coindb\", \"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n \n     CLevelDBBatch batch;\n     for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n         BatchWriteCoins(batch, it->first, it->second);\n-    if (pindex)\n-        BatchWriteHashBestChain(batch, pindex->GetBlockHash());\n+    if (hashBlock != uint256(0))\n+        BatchWriteHashBestChain(batch, hashBlock);\n \n     return db.WriteBatch(batch);\n }\n@@ -115,7 +112,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n     pcursor->SeekToFirst();\n \n     CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n-    stats.hashBlock = GetBestBlock()->GetBlockHash();\n+    stats.hashBlock = GetBestBlock();\n     ss << stats.hashBlock;\n     int64_t nTotalAmount = 0;\n     while (pcursor->Valid()) {\n@@ -155,7 +152,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n         }\n     }\n     delete pcursor;\n-    stats.nHeight = GetBestBlock()->nHeight;\n+    stats.nHeight = mapBlockIndex.find(GetBestBlock())->second->nHeight;\n     stats.hashSerialized = ss.GetHash();\n     stats.nTotalAmount = nTotalAmount;\n     return true;"
      },
      {
        "sha": "7ce6585d37f15ab87e6d03248a9d029a35487f98",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84674082b0c4cfcdd54fb97a29bc841aa7f691c2/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "patch": "@@ -29,9 +29,9 @@ class CCoinsViewDB : public CCoinsView\n     bool GetCoins(const uint256 &txid, CCoins &coins);\n     bool SetCoins(const uint256 &txid, const CCoins &coins);\n     bool HaveCoins(const uint256 &txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    uint256 GetBestBlock();\n+    bool SetBestBlock(const uint256 &hashBlock);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n     bool GetStats(CCoinsStats &stats);\n };\n "
      }
    ]
  },
  {
    "sha": "a0fa20a12b69717636050dd8742713b1d82ae524",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMGZhMjBhMTJiNjk3MTc2MzYwNTBkZDg3NDI3MTNiMWQ4MmFlNTI0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-11-05T01:47:07Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-11-10T18:37:56Z"
      },
      "message": "Move CCoins-related logic to coins.{cpp.h}",
      "tree": {
        "sha": "d1db4dc173a9f4d24904a1636f5cf82cd3c1c737",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d1db4dc173a9f4d24904a1636f5cf82cd3c1c737"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a0fa20a12b69717636050dd8742713b1d82ae524",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0fa20a12b69717636050dd8742713b1d82ae524",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a0fa20a12b69717636050dd8742713b1d82ae524",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0fa20a12b69717636050dd8742713b1d82ae524/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84674082b0c4cfcdd54fb97a29bc841aa7f691c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/84674082b0c4cfcdd54fb97a29bc841aa7f691c2"
      }
    ],
    "stats": {
      "total": 1158,
      "additions": 581,
      "deletions": 577
    },
    "files": [
      {
        "sha": "d4d17b2a9be1d7cb80e8a850ebb1bc68242b785b",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -14,7 +14,7 @@ DIST_SUBDIRS = . qt test\n # bitcoin core #\n BITCOIN_CORE_H = addrman.h alert.h allocators.h base58.h bignum.h \\\n   bitcoinrpc.h bloom.h chainparams.h checkpoints.h checkqueue.h \\\n-  clientversion.h compat.h core.h crypter.h db.h hash.h init.h \\\n+  clientversion.h compat.h core.h coins.h crypter.h db.h hash.h init.h \\\n   key.h keystore.h leveldbwrapper.h limitedmap.h main.h miner.h mruset.h \\\n   netbase.h net.h noui.h protocol.h script.h serialize.h sync.h threadsafety.h \\\n   txdb.h txmempool.h ui_interface.h uint256.h util.h version.h walletdb.h wallet.h\n@@ -32,7 +32,7 @@ obj/build.h: FORCE\n version.o: obj/build.h\n \n libbitcoin_a_SOURCES = addrman.cpp alert.cpp allocators.cpp bitcoinrpc.cpp bloom.cpp \\\n-  chainparams.cpp checkpoints.cpp core.cpp crypter.cpp db.cpp hash.cpp \\\n+  chainparams.cpp checkpoints.cpp core.cpp coins.cpp crypter.cpp db.cpp hash.cpp \\\n   init.cpp key.cpp keystore.cpp leveldbwrapper.cpp main.cpp miner.cpp \\\n   netbase.cpp net.cpp noui.cpp protocol.cpp rpcblockchain.cpp rpcdump.cpp \\\n   rpcmining.cpp rpcnet.cpp rpcrawtransaction.cpp rpcwallet.cpp script.cpp \\"
      },
      {
        "sha": "ed82c9df8bed3a9e36f5fc110cdbeaf82a594295",
        "filename": "src/coins.cpp",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -0,0 +1,180 @@\n+// Copyright (c) 2012-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"coins.h\"\n+\n+#include <assert.h>\n+\n+// calculate number of bytes for the bitmask, and its number of non-zero bytes\n+// each bit in the bitmask represents the availability of one output, but the\n+// availabilities of the first two outputs are encoded separately\n+void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n+    unsigned int nLastUsedByte = 0;\n+    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n+        bool fZero = true;\n+        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n+            if (!vout[2+b*8+i].IsNull()) {\n+                fZero = false;\n+                continue;\n+            }\n+        }\n+        if (!fZero) {\n+            nLastUsedByte = b + 1;\n+            nNonzeroBytes++;\n+        }\n+    }\n+    nBytes += nLastUsedByte;\n+}\n+\n+bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo) {\n+    if (out.n >= vout.size())\n+        return false;\n+    if (vout[out.n].IsNull())\n+        return false;\n+    undo = CTxInUndo(vout[out.n]);\n+    vout[out.n].SetNull();\n+    Cleanup();\n+    if (vout.size() == 0) {\n+        undo.nHeight = nHeight;\n+        undo.fCoinBase = fCoinBase;\n+        undo.nVersion = this->nVersion;\n+    }\n+    return true;\n+}\n+\n+bool CCoins::Spend(int nPos) {\n+    CTxInUndo undo;\n+    COutPoint out(0, nPos);\n+    return Spend(out, undo);\n+}\n+\n+\n+bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) { return false; }\n+bool CCoinsView::SetCoins(const uint256 &txid, const CCoins &coins) { return false; }\n+bool CCoinsView::HaveCoins(const uint256 &txid) { return false; }\n+uint256 CCoinsView::GetBestBlock() { return uint256(0); }\n+bool CCoinsView::SetBestBlock(const uint256 &hashBlock) { return false; }\n+bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return false; }\n+bool CCoinsView::GetStats(CCoinsStats &stats) { return false; }\n+\n+\n+CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n+bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) { return base->GetCoins(txid, coins); }\n+bool CCoinsViewBacked::SetCoins(const uint256 &txid, const CCoins &coins) { return base->SetCoins(txid, coins); }\n+bool CCoinsViewBacked::HaveCoins(const uint256 &txid) { return base->HaveCoins(txid); }\n+uint256 CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n+bool CCoinsViewBacked::SetBestBlock(const uint256 &hashBlock) { return base->SetBestBlock(hashBlock); }\n+void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n+bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n+bool CCoinsViewBacked::GetStats(CCoinsStats &stats) { return base->GetStats(stats); }\n+\n+CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), hashBlock(0) { }\n+\n+bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) {\n+    if (cacheCoins.count(txid)) {\n+        coins = cacheCoins[txid];\n+        return true;\n+    }\n+    if (base->GetCoins(txid, coins)) {\n+        cacheCoins[txid] = coins;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+std::map<uint256,CCoins>::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) {\n+    std::map<uint256,CCoins>::iterator it = cacheCoins.lower_bound(txid);\n+    if (it != cacheCoins.end() && it->first == txid)\n+        return it;\n+    CCoins tmp;\n+    if (!base->GetCoins(txid,tmp))\n+        return cacheCoins.end();\n+    std::map<uint256,CCoins>::iterator ret = cacheCoins.insert(it, std::make_pair(txid, CCoins()));\n+    tmp.swap(ret->second);\n+    return ret;\n+}\n+\n+CCoins &CCoinsViewCache::GetCoins(const uint256 &txid) {\n+    std::map<uint256,CCoins>::iterator it = FetchCoins(txid);\n+    assert(it != cacheCoins.end());\n+    return it->second;\n+}\n+\n+bool CCoinsViewCache::SetCoins(const uint256 &txid, const CCoins &coins) {\n+    cacheCoins[txid] = coins;\n+    return true;\n+}\n+\n+bool CCoinsViewCache::HaveCoins(const uint256 &txid) {\n+    return FetchCoins(txid) != cacheCoins.end();\n+}\n+\n+uint256 CCoinsViewCache::GetBestBlock() {\n+    if (hashBlock == uint256(0))\n+        hashBlock = base->GetBestBlock();\n+    return hashBlock;\n+}\n+\n+bool CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n+    hashBlock = hashBlockIn;\n+    return true;\n+}\n+\n+bool CCoinsViewCache::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlockIn) {\n+    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n+        cacheCoins[it->first] = it->second;\n+    hashBlock = hashBlockIn;\n+    return true;\n+}\n+\n+bool CCoinsViewCache::Flush() {\n+    bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n+    if (fOk)\n+        cacheCoins.clear();\n+    return fOk;\n+}\n+\n+unsigned int CCoinsViewCache::GetCacheSize() {\n+    return cacheCoins.size();\n+}\n+\n+const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input)\n+{\n+    const CCoins &coins = GetCoins(input.prevout.hash);\n+    assert(coins.IsAvailable(input.prevout.n));\n+    return coins.vout[input.prevout.n];\n+}\n+\n+int64_t CCoinsViewCache::GetValueIn(const CTransaction& tx)\n+{\n+    if (tx.IsCoinBase())\n+        return 0;\n+\n+    int64_t nResult = 0;\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        nResult += GetOutputFor(tx.vin[i]).nValue;\n+\n+    return nResult;\n+}\n+\n+bool CCoinsViewCache::HaveInputs(const CTransaction& tx)\n+{\n+    if (!tx.IsCoinBase()) {\n+        // first check whether information about the prevout hash is available\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            const COutPoint &prevout = tx.vin[i].prevout;\n+            if (!HaveCoins(prevout.hash))\n+                return false;\n+        }\n+\n+        // then check whether the actual outputs are available\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            const COutPoint &prevout = tx.vin[i].prevout;\n+            const CCoins &coins = GetCoins(prevout.hash);\n+            if (!coins.IsAvailable(prevout.n))\n+                return false;\n+        }\n+    }\n+    return true;\n+}"
      },
      {
        "sha": "2c72ee88e1409ba16cc1eb2e444a667421fb8ec3",
        "filename": "src/coins.h",
        "status": "added",
        "additions": 356,
        "deletions": 0,
        "changes": 356,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -0,0 +1,356 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_COINS_H\n+#define BITCOIN_COINS_H\n+\n+#include \"core.h\"\n+#include \"serialize.h\"\n+#include \"uint256.h\"\n+\n+#include <assert.h>\n+#include <stdint.h>\n+\n+#include <boost/foreach.hpp>\n+\n+/** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n+ *\n+ * Serialized format:\n+ * - VARINT(nVersion)\n+ * - VARINT(nCode)\n+ * - unspentness bitvector, for vout[2] and further; least significant byte first\n+ * - the non-spent CTxOuts (via CTxOutCompressor)\n+ * - VARINT(nHeight)\n+ *\n+ * The nCode value consists of:\n+ * - bit 1: IsCoinBase()\n+ * - bit 2: vout[0] is not spent\n+ * - bit 4: vout[1] is not spent\n+ * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n+ *   - In case both bit 2 and bit 4 are unset, they encode N-1, as there must be at\n+ *     least one non-spent output).\n+ *\n+ * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n+ *          <><><--------------------------------------------><---->\n+ *          |  \\                  |                             /\n+ *    version   code             vout[1]                  height\n+ *\n+ *    - version = 1\n+ *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n+ *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n+ *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n+ *               * 8358: compact amount representation for 60000000000 (600 BTC)\n+ *               * 00: special txout type pay-to-pubkey-hash\n+ *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n+ *    - height = 203998\n+ *\n+ *\n+ * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n+ *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n+ *         /  \\   \\                     |                                                           |                     /\n+ *  version  code  unspentness       vout[4]                                                     vout[16]           height\n+ *\n+ *  - version = 1\n+ *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n+ *                2 (1, +1 because both bit 2 and bit 4 are unset) non-zero bitvector bytes follow)\n+ *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n+ *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n+ *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n+ *             * 00: special txout type pay-to-pubkey-hash\n+ *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n+ *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n+ *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n+ *              * 00: special txout type pay-to-pubkey-hash\n+ *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n+ *  - height = 120891\n+ */\n+class CCoins\n+{\n+public:\n+    // whether transaction is a coinbase\n+    bool fCoinBase;\n+\n+    // unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n+    std::vector<CTxOut> vout;\n+\n+    // at which height this transaction was included in the active block chain\n+    int nHeight;\n+\n+    // version of the CTransaction; accesses to this value should probably check for nHeight as well,\n+    // as new tx version will probably only be introduced at certain heights\n+    int nVersion;\n+\n+    // construct a CCoins from a CTransaction, at a given height\n+    CCoins(const CTransaction &tx, int nHeightIn) : fCoinBase(tx.IsCoinBase()), vout(tx.vout), nHeight(nHeightIn), nVersion(tx.nVersion) {\n+        ClearUnspendable();\n+    }\n+\n+    // empty constructor\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n+\n+    // remove spent outputs at the end of vout\n+    void Cleanup() {\n+        while (vout.size() > 0 && vout.back().IsNull())\n+            vout.pop_back();\n+        if (vout.empty())\n+            std::vector<CTxOut>().swap(vout);\n+    }\n+\n+    void ClearUnspendable() {\n+        BOOST_FOREACH(CTxOut &txout, vout) {\n+            if (txout.scriptPubKey.IsUnspendable())\n+                txout.SetNull();\n+        }\n+        Cleanup();\n+    }\n+\n+    void swap(CCoins &to) {\n+        std::swap(to.fCoinBase, fCoinBase);\n+        to.vout.swap(vout);\n+        std::swap(to.nHeight, nHeight);\n+        std::swap(to.nVersion, nVersion);\n+    }\n+\n+    // equality test\n+    friend bool operator==(const CCoins &a, const CCoins &b) {\n+         // Empty CCoins objects are always equal.\n+         if (a.IsPruned() && b.IsPruned())\n+             return true;\n+         return a.fCoinBase == b.fCoinBase &&\n+                a.nHeight == b.nHeight &&\n+                a.nVersion == b.nVersion &&\n+                a.vout == b.vout;\n+    }\n+    friend bool operator!=(const CCoins &a, const CCoins &b) {\n+        return !(a == b);\n+    }\n+\n+    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n+\n+    bool IsCoinBase() const {\n+        return fCoinBase;\n+    }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+        unsigned int nSize = 0;\n+        unsigned int nMaskSize = 0, nMaskCode = 0;\n+        CalcMaskSize(nMaskSize, nMaskCode);\n+        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n+        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n+        assert(fFirst || fSecond || nMaskCode);\n+        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n+        // version\n+        nSize += ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion);\n+        // size of header code\n+        nSize += ::GetSerializeSize(VARINT(nCode), nType, nVersion);\n+        // spentness bitmask\n+        nSize += nMaskSize;\n+        // txouts themself\n+        for (unsigned int i = 0; i < vout.size(); i++)\n+            if (!vout[i].IsNull())\n+                nSize += ::GetSerializeSize(CTxOutCompressor(REF(vout[i])), nType, nVersion);\n+        // height\n+        nSize += ::GetSerializeSize(VARINT(nHeight), nType, nVersion);\n+        return nSize;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersion) const {\n+        unsigned int nMaskSize = 0, nMaskCode = 0;\n+        CalcMaskSize(nMaskSize, nMaskCode);\n+        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n+        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n+        assert(fFirst || fSecond || nMaskCode);\n+        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n+        // version\n+        ::Serialize(s, VARINT(this->nVersion), nType, nVersion);\n+        // header code\n+        ::Serialize(s, VARINT(nCode), nType, nVersion);\n+        // spentness bitmask\n+        for (unsigned int b = 0; b<nMaskSize; b++) {\n+            unsigned char chAvail = 0;\n+            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n+                if (!vout[2+b*8+i].IsNull())\n+                    chAvail |= (1 << i);\n+            ::Serialize(s, chAvail, nType, nVersion);\n+        }\n+        // txouts themself\n+        for (unsigned int i = 0; i < vout.size(); i++) {\n+            if (!vout[i].IsNull())\n+                ::Serialize(s, CTxOutCompressor(REF(vout[i])), nType, nVersion);\n+        }\n+        // coinbase height\n+        ::Serialize(s, VARINT(nHeight), nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s, int nType, int nVersion) {\n+        unsigned int nCode = 0;\n+        // version\n+        ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);\n+        // header code\n+        ::Unserialize(s, VARINT(nCode), nType, nVersion);\n+        fCoinBase = nCode & 1;\n+        std::vector<bool> vAvail(2, false);\n+        vAvail[0] = nCode & 2;\n+        vAvail[1] = nCode & 4;\n+        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n+        // spentness bitmask\n+        while (nMaskCode > 0) {\n+            unsigned char chAvail = 0;\n+            ::Unserialize(s, chAvail, nType, nVersion);\n+            for (unsigned int p = 0; p < 8; p++) {\n+                bool f = (chAvail & (1 << p)) != 0;\n+                vAvail.push_back(f);\n+            }\n+            if (chAvail != 0)\n+                nMaskCode--;\n+        }\n+        // txouts themself\n+        vout.assign(vAvail.size(), CTxOut());\n+        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+            if (vAvail[i])\n+                ::Unserialize(s, REF(CTxOutCompressor(vout[i])), nType, nVersion);\n+        }\n+        // coinbase height\n+        ::Unserialize(s, VARINT(nHeight), nType, nVersion);\n+        Cleanup();\n+    }\n+\n+    // mark an outpoint spent, and construct undo information\n+    bool Spend(const COutPoint &out, CTxInUndo &undo);\n+\n+    // mark a vout spent\n+    bool Spend(int nPos);\n+\n+    // check whether a particular output is still available\n+    bool IsAvailable(unsigned int nPos) const {\n+        return (nPos < vout.size() && !vout[nPos].IsNull());\n+    }\n+\n+    // check whether the entire CCoins is spent\n+    // note that only !IsPruned() CCoins can be serialized\n+    bool IsPruned() const {\n+        BOOST_FOREACH(const CTxOut &out, vout)\n+            if (!out.IsNull())\n+                return false;\n+        return true;\n+    }\n+};\n+\n+\n+struct CCoinsStats\n+{\n+    int nHeight;\n+    uint256 hashBlock;\n+    uint64_t nTransactions;\n+    uint64_t nTransactionOutputs;\n+    uint64_t nSerializedSize;\n+    uint256 hashSerialized;\n+    int64_t nTotalAmount;\n+\n+    CCoinsStats() : nHeight(0), hashBlock(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), hashSerialized(0), nTotalAmount(0) {}\n+};\n+\n+\n+/** Abstract view on the open txout dataset. */\n+class CCoinsView\n+{\n+public:\n+    // Retrieve the CCoins (unspent transaction outputs) for a given txid\n+    virtual bool GetCoins(const uint256 &txid, CCoins &coins);\n+\n+    // Modify the CCoins for a given txid\n+    virtual bool SetCoins(const uint256 &txid, const CCoins &coins);\n+\n+    // Just check whether we have data for a given txid.\n+    // This may (but cannot always) return true for fully spent transactions\n+    virtual bool HaveCoins(const uint256 &txid);\n+\n+    // Retrieve the block hash whose state this CCoinsView currently represents\n+    virtual uint256 GetBestBlock();\n+\n+    // Modify the currently active block hash\n+    virtual bool SetBestBlock(const uint256 &hashBlock);\n+\n+    // Do a bulk modification (multiple SetCoins + one SetBestBlock)\n+    virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+\n+    // Calculate statistics about the unspent transaction output set\n+    virtual bool GetStats(CCoinsStats &stats);\n+\n+    // As we use CCoinsViews polymorphically, have a virtual destructor\n+    virtual ~CCoinsView() {}\n+};\n+\n+\n+/** CCoinsView backed by another CCoinsView */\n+class CCoinsViewBacked : public CCoinsView\n+{\n+protected:\n+    CCoinsView *base;\n+\n+public:\n+    CCoinsViewBacked(CCoinsView &viewIn);\n+    bool GetCoins(const uint256 &txid, CCoins &coins);\n+    bool SetCoins(const uint256 &txid, const CCoins &coins);\n+    bool HaveCoins(const uint256 &txid);\n+    uint256 GetBestBlock();\n+    bool SetBestBlock(const uint256 &hashBlock);\n+    void SetBackend(CCoinsView &viewIn);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+    bool GetStats(CCoinsStats &stats);\n+};\n+\n+\n+/** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n+class CCoinsViewCache : public CCoinsViewBacked\n+{\n+protected:\n+    uint256 hashBlock;\n+    std::map<uint256,CCoins> cacheCoins;\n+\n+public:\n+    CCoinsViewCache(CCoinsView &baseIn, bool fDummy = false);\n+\n+    // Standard CCoinsView methods\n+    bool GetCoins(const uint256 &txid, CCoins &coins);\n+    bool SetCoins(const uint256 &txid, const CCoins &coins);\n+    bool HaveCoins(const uint256 &txid);\n+    uint256 GetBestBlock();\n+    bool SetBestBlock(const uint256 &hashBlock);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+\n+    // Return a modifiable reference to a CCoins. Check HaveCoins first.\n+    // Many methods explicitly require a CCoinsViewCache because of this method, to reduce\n+    // copying.\n+    CCoins &GetCoins(const uint256 &txid);\n+\n+    // Push the modifications applied to this cache to its base.\n+    // Failure to call this method before destruction will cause the changes to be forgotten.\n+    bool Flush();\n+\n+    // Calculate the size of the cache (in number of transactions)\n+    unsigned int GetCacheSize();\n+\n+    /** Amount of bitcoins coming in to a transaction\n+        Note that lightweight clients may not know anything besides the hash of previous transactions,\n+        so may not be able to calculate this.\n+\n+        @param[in] tx\ttransaction for which we are checking input total\n+        @return\tSum of value of all inputs (scriptSigs)\n+        @see CTransaction::FetchInputs\n+     */\n+    int64_t GetValueIn(const CTransaction& tx);\n+\n+    // Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n+    bool HaveInputs(const CTransaction& tx);\n+\n+    const CTxOut &GetOutputFor(const CTxIn& input);\n+\n+private:\n+    std::map<uint256,CCoins>::iterator FetchCoins(const uint256 &txid);\n+};\n+\n+#endif"
      },
      {
        "sha": "80cdcb08492b7bc1cf8a39179e2a753fbfa9e924",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 43,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -183,49 +183,6 @@ uint64_t CTxOutCompressor::DecompressAmount(uint64_t x)\n     return n;\n }\n \n-// calculate number of bytes for the bitmask, and its number of non-zero bytes\n-// each bit in the bitmask represents the availability of one output, but the\n-// availabilities of the first two outputs are encoded separately\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n-    unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n-        bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n-                fZero = false;\n-                continue;\n-            }\n-        }\n-        if (!fZero) {\n-            nLastUsedByte = b + 1;\n-            nNonzeroBytes++;\n-        }\n-    }\n-    nBytes += nLastUsedByte;\n-}\n-\n-bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo) {\n-    if (out.n >= vout.size())\n-        return false;\n-    if (vout[out.n].IsNull())\n-        return false;\n-    undo = CTxInUndo(vout[out.n]);\n-    vout[out.n].SetNull();\n-    Cleanup();\n-    if (vout.size() == 0) {\n-        undo.nHeight = nHeight;\n-        undo.fCoinBase = fCoinBase;\n-        undo.nVersion = this->nVersion;\n-    }\n-    return true;\n-}\n-\n-bool CCoins::Spend(int nPos) {\n-    CTxInUndo undo;\n-    COutPoint out(0, nPos);\n-    return Spend(out, undo);\n-}\n-\n uint256 CBlockHeader::GetHash() const\n {\n     return Hash(BEGIN(nVersion), END(nNonce));"
      },
      {
        "sha": "e31a7e6582fcdf7b179844894b98296928e478da",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 0,
        "deletions": 228,
        "changes": 228,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -12,8 +12,6 @@\n \n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n-\n class CTransaction;\n \n /** An outpoint - a combination of a transaction hash and an index n into its vout */\n@@ -324,232 +322,6 @@ class CTxUndo\n };\n \n \n-/** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n- *\n- * Serialized format:\n- * - VARINT(nVersion)\n- * - VARINT(nCode)\n- * - unspentness bitvector, for vout[2] and further; least significant byte first\n- * - the non-spent CTxOuts (via CTxOutCompressor)\n- * - VARINT(nHeight)\n- *\n- * The nCode value consists of:\n- * - bit 1: IsCoinBase()\n- * - bit 2: vout[0] is not spent\n- * - bit 4: vout[1] is not spent\n- * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n- *   - In case both bit 2 and bit 4 are unset, they encode N-1, as there must be at\n- *     least one non-spent output).\n- *\n- * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n- *          <><><--------------------------------------------><---->\n- *          |  \\                  |                             /\n- *    version   code             vout[1]                  height\n- *\n- *    - version = 1\n- *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n- *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n- *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n- *               * 8358: compact amount representation for 60000000000 (600 BTC)\n- *               * 00: special txout type pay-to-pubkey-hash\n- *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n- *    - height = 203998\n- *\n- *\n- * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n- *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n- *         /  \\   \\                     |                                                           |                     /\n- *  version  code  unspentness       vout[4]                                                     vout[16]           height\n- *\n- *  - version = 1\n- *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n- *                2 (1, +1 because both bit 2 and bit 4 are unset) non-zero bitvector bytes follow)\n- *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n- *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n- *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n- *             * 00: special txout type pay-to-pubkey-hash\n- *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n- *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n- *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n- *              * 00: special txout type pay-to-pubkey-hash\n- *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n- *  - height = 120891\n- */\n-class CCoins\n-{\n-public:\n-    // whether transaction is a coinbase\n-    bool fCoinBase;\n-\n-    // unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n-    std::vector<CTxOut> vout;\n-\n-    // at which height this transaction was included in the active block chain\n-    int nHeight;\n-\n-    // version of the CTransaction; accesses to this value should probably check for nHeight as well,\n-    // as new tx version will probably only be introduced at certain heights\n-    int nVersion;\n-\n-    // construct a CCoins from a CTransaction, at a given height\n-    CCoins(const CTransaction &tx, int nHeightIn) : fCoinBase(tx.IsCoinBase()), vout(tx.vout), nHeight(nHeightIn), nVersion(tx.nVersion) {\n-        ClearUnspendable();\n-    }\n-\n-    // empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n-\n-    // remove spent outputs at the end of vout\n-    void Cleanup() {\n-        while (vout.size() > 0 && vout.back().IsNull())\n-            vout.pop_back();\n-        if (vout.empty())\n-            std::vector<CTxOut>().swap(vout);\n-    }\n-\n-    void ClearUnspendable() {\n-        BOOST_FOREACH(CTxOut &txout, vout) {\n-            if (txout.scriptPubKey.IsUnspendable())\n-                txout.SetNull();\n-        }\n-        Cleanup();\n-    }\n-\n-    void swap(CCoins &to) {\n-        std::swap(to.fCoinBase, fCoinBase);\n-        to.vout.swap(vout);\n-        std::swap(to.nHeight, nHeight);\n-        std::swap(to.nVersion, nVersion);\n-    }\n-\n-    // equality test\n-    friend bool operator==(const CCoins &a, const CCoins &b) {\n-         // Empty CCoins objects are always equal.\n-         if (a.IsPruned() && b.IsPruned())\n-             return true;\n-         return a.fCoinBase == b.fCoinBase &&\n-                a.nHeight == b.nHeight &&\n-                a.nVersion == b.nVersion &&\n-                a.vout == b.vout;\n-    }\n-    friend bool operator!=(const CCoins &a, const CCoins &b) {\n-        return !(a == b);\n-    }\n-\n-    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n-\n-    bool IsCoinBase() const {\n-        return fCoinBase;\n-    }\n-\n-    unsigned int GetSerializeSize(int nType, int nVersion) const {\n-        unsigned int nSize = 0;\n-        unsigned int nMaskSize = 0, nMaskCode = 0;\n-        CalcMaskSize(nMaskSize, nMaskCode);\n-        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n-        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n-        assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n-        // version\n-        nSize += ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion);\n-        // size of header code\n-        nSize += ::GetSerializeSize(VARINT(nCode), nType, nVersion);\n-        // spentness bitmask\n-        nSize += nMaskSize;\n-        // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++)\n-            if (!vout[i].IsNull())\n-                nSize += ::GetSerializeSize(CTxOutCompressor(REF(vout[i])), nType, nVersion);\n-        // height\n-        nSize += ::GetSerializeSize(VARINT(nHeight), nType, nVersion);\n-        return nSize;\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream &s, int nType, int nVersion) const {\n-        unsigned int nMaskSize = 0, nMaskCode = 0;\n-        CalcMaskSize(nMaskSize, nMaskCode);\n-        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n-        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n-        assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n-        // version\n-        ::Serialize(s, VARINT(this->nVersion), nType, nVersion);\n-        // header code\n-        ::Serialize(s, VARINT(nCode), nType, nVersion);\n-        // spentness bitmask\n-        for (unsigned int b = 0; b<nMaskSize; b++) {\n-            unsigned char chAvail = 0;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n-                if (!vout[2+b*8+i].IsNull())\n-                    chAvail |= (1 << i);\n-            ::Serialize(s, chAvail, nType, nVersion);\n-        }\n-        // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++) {\n-            if (!vout[i].IsNull())\n-                ::Serialize(s, CTxOutCompressor(REF(vout[i])), nType, nVersion);\n-        }\n-        // coinbase height\n-        ::Serialize(s, VARINT(nHeight), nType, nVersion);\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream &s, int nType, int nVersion) {\n-        unsigned int nCode = 0;\n-        // version\n-        ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);\n-        // header code\n-        ::Unserialize(s, VARINT(nCode), nType, nVersion);\n-        fCoinBase = nCode & 1;\n-        std::vector<bool> vAvail(2, false);\n-        vAvail[0] = nCode & 2;\n-        vAvail[1] = nCode & 4;\n-        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n-        // spentness bitmask\n-        while (nMaskCode > 0) {\n-            unsigned char chAvail = 0;\n-            ::Unserialize(s, chAvail, nType, nVersion);\n-            for (unsigned int p = 0; p < 8; p++) {\n-                bool f = (chAvail & (1 << p)) != 0;\n-                vAvail.push_back(f);\n-            }\n-            if (chAvail != 0)\n-                nMaskCode--;\n-        }\n-        // txouts themself\n-        vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n-            if (vAvail[i])\n-                ::Unserialize(s, REF(CTxOutCompressor(vout[i])), nType, nVersion);\n-        }\n-        // coinbase height\n-        ::Unserialize(s, VARINT(nHeight), nType, nVersion);\n-        Cleanup();\n-    }\n-\n-    // mark an outpoint spent, and construct undo information\n-    bool Spend(const COutPoint &out, CTxInUndo &undo);\n-\n-    // mark a vout spent\n-    bool Spend(int nPos);\n-\n-    // check whether a particular output is still available\n-    bool IsAvailable(unsigned int nPos) const {\n-        return (nPos < vout.size() && !vout[nPos].IsNull());\n-    }\n-\n-    // check whether the entire CCoins is spent\n-    // note that only !IsPruned() CCoins can be serialized\n-    bool IsPruned() const {\n-        BOOST_FOREACH(const CTxOut &out, vout)\n-            if (!out.IsNull())\n-                return false;\n-        return true;\n-    }\n-};\n-\n-\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block"
      },
      {
        "sha": "3c4b108c8bfc22c020942766bc71f8c572b8ee78",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 166,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -228,128 +228,6 @@ CBlockIndex *CChain::FindFork(const CBlockLocator &locator) const {\n     return Genesis();\n }\n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// CCoinsView implementations\n-//\n-\n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) { return false; }\n-bool CCoinsView::SetCoins(const uint256 &txid, const CCoins &coins) { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) { return false; }\n-uint256 CCoinsView::GetBestBlock() { return uint256(0); }\n-bool CCoinsView::SetBestBlock(const uint256 &hashBlock) { return false; }\n-bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return false; }\n-bool CCoinsView::GetStats(CCoinsStats &stats) { return false; }\n-\n-\n-CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::SetCoins(const uint256 &txid, const CCoins &coins) { return base->SetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) { return base->HaveCoins(txid); }\n-uint256 CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n-bool CCoinsViewBacked::SetBestBlock(const uint256 &hashBlock) { return base->SetBestBlock(hashBlock); }\n-void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n-bool CCoinsViewBacked::GetStats(CCoinsStats &stats) { return base->GetStats(stats); }\n-\n-CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), hashBlock(0) { }\n-\n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) {\n-    if (cacheCoins.count(txid)) {\n-        coins = cacheCoins[txid];\n-        return true;\n-    }\n-    if (base->GetCoins(txid, coins)) {\n-        cacheCoins[txid] = coins;\n-        return true;\n-    }\n-    return false;\n-}\n-\n-std::map<uint256,CCoins>::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) {\n-    std::map<uint256,CCoins>::iterator it = cacheCoins.lower_bound(txid);\n-    if (it != cacheCoins.end() && it->first == txid)\n-        return it;\n-    CCoins tmp;\n-    if (!base->GetCoins(txid,tmp))\n-        return cacheCoins.end();\n-    std::map<uint256,CCoins>::iterator ret = cacheCoins.insert(it, std::make_pair(txid, CCoins()));\n-    tmp.swap(ret->second);\n-    return ret;\n-}\n-\n-CCoins &CCoinsViewCache::GetCoins(const uint256 &txid) {\n-    std::map<uint256,CCoins>::iterator it = FetchCoins(txid);\n-    assert(it != cacheCoins.end());\n-    return it->second;\n-}\n-\n-bool CCoinsViewCache::SetCoins(const uint256 &txid, const CCoins &coins) {\n-    cacheCoins[txid] = coins;\n-    return true;\n-}\n-\n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) {\n-    return FetchCoins(txid) != cacheCoins.end();\n-}\n-\n-uint256 CCoinsViewCache::GetBestBlock() {\n-    if (hashBlock == uint256(0))\n-        hashBlock = base->GetBestBlock();\n-    return hashBlock;\n-}\n-\n-bool CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n-    hashBlock = hashBlockIn;\n-    return true;\n-}\n-\n-bool CCoinsViewCache::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlockIn) {\n-    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n-        cacheCoins[it->first] = it->second;\n-    hashBlock = hashBlockIn;\n-    return true;\n-}\n-\n-bool CCoinsViewCache::Flush() {\n-    bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n-    if (fOk)\n-        cacheCoins.clear();\n-    return fOk;\n-}\n-\n-unsigned int CCoinsViewCache::GetCacheSize() {\n-    return cacheCoins.size();\n-}\n-\n-/** Helper; lookup from tip (used calling mempool.check()\n-    NOTE: code calling this MUST hold the cs_main lock so\n-    another thread doesn't modify pcoinsTip. When we switch\n-    to C++11 this should be replaced by lambda expressions...\n- **/\n-static CCoins &LookupFromTip(const uint256& hash) {\n-    return pcoinsTip->GetCoins(hash);\n-}\n-\n-/** CCoinsView that brings transactions from a memorypool into view.\n-    It does not check for spendings by memory pool transactions. */\n-CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n-\n-bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) {\n-    if (base->GetCoins(txid, coins))\n-        return true;\n-    CTransaction tx;\n-    if (mempool.lookup(txid, tx)) {\n-        coins = CCoins(tx, MEMPOOL_HEIGHT);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) {\n-    return mempool.exists(txid) || base->HaveCoins(txid);\n-}\n-\n CCoinsViewCache *pcoinsTip = NULL;\n CBlockTreeDB *pblocktree = NULL;\n \n@@ -1416,25 +1294,6 @@ void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev)\n \n \n \n-const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input)\n-{\n-    const CCoins &coins = GetCoins(input.prevout.hash);\n-    assert(coins.IsAvailable(input.prevout.n));\n-    return coins.vout[input.prevout.n];\n-}\n-\n-int64_t CCoinsViewCache::GetValueIn(const CTransaction& tx)\n-{\n-    if (tx.IsCoinBase())\n-        return 0;\n-\n-    int64_t nResult = 0;\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        nResult += GetOutputFor(tx.vin[i]).nValue;\n-\n-    return nResult;\n-}\n-\n void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash)\n {\n     // mark inputs spent\n@@ -1451,27 +1310,6 @@ void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n     assert(inputs.SetCoins(txhash, CCoins(tx, nHeight)));\n }\n \n-bool CCoinsViewCache::HaveInputs(const CTransaction& tx)\n-{\n-    if (!tx.IsCoinBase()) {\n-        // first check whether information about the prevout hash is available\n-        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            if (!HaveCoins(prevout.hash))\n-                return false;\n-        }\n-\n-        // then check whether the actual outputs are available\n-        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins &coins = GetCoins(prevout.hash);\n-            if (!coins.IsAvailable(prevout.n))\n-                return false;\n-        }\n-    }\n-    return true;\n-}\n-\n bool CScriptCheck::operator()() const {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     if (!VerifyScript(scriptSig, scriptPubKey, *ptxTo, nIn, nFlags, nHashType))\n@@ -1841,7 +1679,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n {\n-    mempool.check(&LookupFromTip);\n+    mempool.check(pcoinsTip);\n \n     // All modifications to the coin state will be done in this cache.\n     // Only when all have succeeded, we push it to pcoinsTip.\n@@ -1966,7 +1804,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         mempool.removeConflicts(tx);\n     }\n \n-    mempool.check(&LookupFromTip);\n+    mempool.check(pcoinsTip);\n \n     // Update best block in wallet (so we can detect restored wallets)\n     if ((pindexNew->nHeight % 20160) == 0 || (!fIsInitialDownload && (pindexNew->nHeight % 144) == 0))\n@@ -3540,7 +3378,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CValidationState state;\n         if (AcceptToMemoryPool(mempool, state, tx, true, &fMissingInputs))\n         {\n-            mempool.check(&LookupFromTip);\n+            mempool.check(pcoinsTip);\n             RelayTransaction(tx, inv.hash);\n             mapAlreadyAskedFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n@@ -3576,7 +3414,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                         vEraseQueue.push_back(orphanHash);\n                         LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString().c_str());\n                     }\n-                    mempool.check(&LookupFromTip);\n+                    mempool.check(pcoinsTip);\n                 }\n             }\n "
      },
      {
        "sha": "48e83d98f4e905ff358e95c54c8af729ce84ef5d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 133,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -12,6 +12,7 @@\n \n #include \"bignum.h\"\n #include \"chainparams.h\"\n+#include \"coins.h\"\n #include \"core.h\"\n #include \"net.h\"\n #include \"script.h\"\n@@ -48,8 +49,6 @@ static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n /** The pre-allocation chunk size for rev?????.dat files (since 0.8) */\n static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n-/** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n-static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n /** No amount larger than this (in satoshi) is valid */\n static const int64_t MAX_MONEY = 21000000 * COIN;\n inline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n@@ -101,8 +100,6 @@ class CCoinsDB;\n class CBlockTreeDB;\n struct CDiskBlockPos;\n class CTxUndo;\n-class CCoinsView;\n-class CCoinsViewCache;\n class CScriptCheck;\n class CValidationState;\n class CWalletInterface;\n@@ -1030,135 +1027,6 @@ class CChain {\n extern CChain chainActive;\n \n \n-\n-\n-\n-\n-\n-struct CCoinsStats\n-{\n-    int nHeight;\n-    uint256 hashBlock;\n-    uint64_t nTransactions;\n-    uint64_t nTransactionOutputs;\n-    uint64_t nSerializedSize;\n-    uint256 hashSerialized;\n-    int64_t nTotalAmount;\n-\n-    CCoinsStats() : nHeight(0), hashBlock(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), hashSerialized(0), nTotalAmount(0) {}\n-};\n-\n-/** Abstract view on the open txout dataset. */\n-class CCoinsView\n-{\n-public:\n-    // Retrieve the CCoins (unspent transaction outputs) for a given txid\n-    virtual bool GetCoins(const uint256 &txid, CCoins &coins);\n-\n-    // Modify the CCoins for a given txid\n-    virtual bool SetCoins(const uint256 &txid, const CCoins &coins);\n-\n-    // Just check whether we have data for a given txid.\n-    // This may (but cannot always) return true for fully spent transactions\n-    virtual bool HaveCoins(const uint256 &txid);\n-\n-    // Retrieve the block hash whose state this CCoinsView currently represents\n-    virtual uint256 GetBestBlock();\n-\n-    // Modify the currently active block hash\n-    virtual bool SetBestBlock(const uint256 &hashBlock);\n-\n-    // Do a bulk modification (multiple SetCoins + one SetBestBlock)\n-    virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n-\n-    // Calculate statistics about the unspent transaction output set\n-    virtual bool GetStats(CCoinsStats &stats);\n-\n-    // As we use CCoinsViews polymorphically, have a virtual destructor\n-    virtual ~CCoinsView() {}\n-};\n-\n-/** CCoinsView backed by another CCoinsView */\n-class CCoinsViewBacked : public CCoinsView\n-{\n-protected:\n-    CCoinsView *base;\n-\n-public:\n-    CCoinsViewBacked(CCoinsView &viewIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins);\n-    bool SetCoins(const uint256 &txid, const CCoins &coins);\n-    bool HaveCoins(const uint256 &txid);\n-    uint256 GetBestBlock();\n-    bool SetBestBlock(const uint256 &hashBlock);\n-    void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n-    bool GetStats(CCoinsStats &stats);\n-};\n-\n-/** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n-class CCoinsViewCache : public CCoinsViewBacked\n-{\n-protected:\n-    uint256 hashBlock;\n-    std::map<uint256,CCoins> cacheCoins;\n-\n-public:\n-    CCoinsViewCache(CCoinsView &baseIn, bool fDummy = false);\n-\n-    // Standard CCoinsView methods\n-    bool GetCoins(const uint256 &txid, CCoins &coins);\n-    bool SetCoins(const uint256 &txid, const CCoins &coins);\n-    bool HaveCoins(const uint256 &txid);\n-    uint256 GetBestBlock();\n-    bool SetBestBlock(const uint256 &hashBlock);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n-\n-    // Return a modifiable reference to a CCoins. Check HaveCoins first.\n-    // Many methods explicitly require a CCoinsViewCache because of this method, to reduce\n-    // copying.\n-    CCoins &GetCoins(const uint256 &txid);\n-\n-    // Push the modifications applied to this cache to its base.\n-    // Failure to call this method before destruction will cause the changes to be forgotten.\n-    bool Flush();\n-\n-    // Calculate the size of the cache (in number of transactions)\n-    unsigned int GetCacheSize();\n-\n-    /** Amount of bitcoins coming in to a transaction\n-        Note that lightweight clients may not know anything besides the hash of previous transactions,\n-        so may not be able to calculate this.\n-\n-        @param[in] tx\ttransaction for which we are checking input total\n-        @return\tSum of value of all inputs (scriptSigs)\n-        @see CTransaction::FetchInputs\n-     */\n-    int64_t GetValueIn(const CTransaction& tx);\n-\n-\n-    // Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n-    bool HaveInputs(const CTransaction& tx);\n-\n-    const CTxOut &GetOutputFor(const CTxIn& input);\n-\n-private:\n-    std::map<uint256,CCoins>::iterator FetchCoins(const uint256 &txid);\n-};\n-\n-/** CCoinsView that brings transactions from a memorypool into view.\n-    It does not check for spendings by memory pool transactions. */\n-class CCoinsViewMemPool : public CCoinsViewBacked\n-{\n-protected:\n-    CTxMemPool &mempool;\n-\n-public:\n-    CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins);\n-    bool HaveCoins(const uint256 &txid);\n-};\n-\n /** Global variable that points to the active CCoinsView (protected by cs_main) */\n extern CCoinsViewCache *pcoinsTip;\n "
      },
      {
        "sha": "4f3d400058a0dff7bc9f0c9ac3e8684d814ddcb8",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -32,7 +32,6 @@\n \n class CAddrMan;\n class CBlockIndex;\n-class CNetAddr;\n class CNode;\n \n namespace boost {"
      },
      {
        "sha": "d501b89ecf7ea9a0fd2b84f1446d89d2581d498d",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 2,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -105,7 +105,7 @@ void CTxMemPool::clear()\n     ++nTransactionsUpdated;\n }\n \n-void CTxMemPool::check(CTxMemPool::CoinLookupFunc fnLookup) const\n+void CTxMemPool::check(CCoinsViewCache *pcoins) const\n {\n     if (!fSanityCheck)\n         return;\n@@ -121,7 +121,7 @@ void CTxMemPool::check(CTxMemPool::CoinLookupFunc fnLookup) const\n             if (it2 != mapTx.end()) {\n                 assert(it2->second.vout.size() > txin.prevout.n && !it2->second.vout[txin.prevout.n].IsNull());\n             } else {\n-                CCoins &coins = (*fnLookup)(txin.prevout.hash);\n+                CCoins &coins = pcoins->GetCoins(txin.prevout.hash);\n                 assert(coins.IsAvailable(txin.prevout.n));\n             }\n             // Check whether its inputs are marked in mapNextTx.\n@@ -160,3 +160,21 @@ bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n     result = i->second;\n     return true;\n }\n+\n+CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n+\n+bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) {\n+    if (base->GetCoins(txid, coins))\n+        return true;\n+    CTransaction tx;\n+    if (mempool.lookup(txid, tx)) {\n+        coins = CCoins(tx, MEMPOOL_HEIGHT);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) {\n+    return mempool.exists(txid) || base->HaveCoins(txid);\n+}\n+"
      },
      {
        "sha": "57b92789fbca077b3f05e2d3427807b07d9c9a01",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0fa20a12b69717636050dd8742713b1d82ae524/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0fa20a12b69717636050dd8742713b1d82ae524/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=a0fa20a12b69717636050dd8742713b1d82ae524",
        "patch": "@@ -5,9 +5,13 @@\n #ifndef BITCOIN_TXMEMPOOL_H\n #define BITCOIN_TXMEMPOOL_H\n \n+#include \"coins.h\"\n #include \"core.h\"\n #include \"sync.h\"\n \n+/** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n+static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n+\n /*\n  * CTxMemPool stores valid-according-to-the-current-best-chain\n  * transactions that may be included in the next block.\n@@ -37,8 +41,7 @@ class CTxMemPool\n      * all inputs are in the mapNextTx array). If sanity-checking is turned off,\n      * check does nothing.\n      */\n-    typedef CCoins& (*CoinLookupFunc)(const uint256&);\n-    void check(CoinLookupFunc fnLookup) const;\n+    void check(CCoinsViewCache *pcoins) const;\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n     bool addUnchecked(const uint256& hash, const CTransaction &tx);\n@@ -65,4 +68,17 @@ class CTxMemPool\n     bool lookup(uint256 hash, CTransaction& result) const;\n };\n \n+/** CCoinsView that brings transactions from a memorypool into view.\n+    It does not check for spendings by memory pool transactions. */\n+class CCoinsViewMemPool : public CCoinsViewBacked\n+{\n+protected:\n+    CTxMemPool &mempool;\n+\n+public:\n+    CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn);\n+    bool GetCoins(const uint256 &txid, CCoins &coins);\n+    bool HaveCoins(const uint256 &txid);\n+};\n+\n #endif /* BITCOIN_TXMEMPOOL_H */"
      }
    ]
  }
]