[
  {
    "sha": "9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YjRlN2Q5YTVlYzBmNjljMTc1ZDIzZGM5Yzk0ZWQ3MjMxNDdjZjQ1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-05-01T13:21:06Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-06-11T08:03:23Z"
      },
      "message": "Add DummySignatureCreator which just creates zeroed sigs",
      "tree": {
        "sha": "c03c9ea3ca882d8302e3f7029437de8b9670ef75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c03c9ea3ca882d8302e3f7029437de8b9670ef75"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eba2f061a02573b62792614260181c615f753225",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eba2f061a02573b62792614260181c615f753225",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eba2f061a02573b62792614260181c615f753225"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 44,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4543ca303fa48e37b705eaf164d3aed2521aead9",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
        "patch": "@@ -275,3 +275,39 @@ CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecke\n \n     return CombineSignatures(scriptPubKey, checker, txType, vSolutions, stack1, stack2);\n }\n+\n+namespace {\n+/** Dummy signature checker which accepts all signatures. */\n+class DummySignatureChecker : public BaseSignatureChecker\n+{\n+public:\n+    DummySignatureChecker() {}\n+\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const\n+    {\n+        return true;\n+    }\n+};\n+const DummySignatureChecker dummyChecker;\n+}\n+\n+const BaseSignatureChecker& DummySignatureCreator::Checker() const\n+{\n+    return dummyChecker;\n+}\n+\n+bool DummySignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const\n+{\n+    // Create a dummy signature that is a valid DER-encoding\n+    vchSig.assign(72, '\\000');\n+    vchSig[0] = 0x30;\n+    vchSig[1] = 69;\n+    vchSig[2] = 0x02;\n+    vchSig[3] = 33;\n+    vchSig[4] = 0x01;\n+    vchSig[4 + 33] = 0x02;\n+    vchSig[5 + 33] = 32;\n+    vchSig[6 + 33] = 0x01;\n+    vchSig[6 + 33 + 32] = SIGHASH_ALL;\n+    return true;\n+}"
      },
      {
        "sha": "13f45007dda574260769b1c6ea4b55ca4d3c5042",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
        "patch": "@@ -43,6 +43,14 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n     bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const;\n };\n \n+/** A signature creator that just produces 72-byte empty signatyres. */\n+class DummySignatureCreator : public BaseSignatureCreator {\n+public:\n+    DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n+    const BaseSignatureChecker& Checker() const;\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const;\n+};\n+\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, CScript& scriptSig);\n "
      }
    ]
  },
  {
    "sha": "2d84e22703594643c70dfa36dac2a83f8f0f713e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZDg0ZTIyNzAzNTk0NjQzYzcwZGZhMzZkYWMyYTgzZjhmMGY3MTNl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-04-25T01:27:00Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-06-11T08:03:23Z"
      },
      "message": "Small tweaks to CCoinControl for fundrawtransaction",
      "tree": {
        "sha": "8b51c1108f6913272262c1794ee6f22b9ee27f1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b51c1108f6913272262c1794ee6f22b9ee27f1c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2d84e22703594643c70dfa36dac2a83f8f0f713e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d84e22703594643c70dfa36dac2a83f8f0f713e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2d84e22703594643c70dfa36dac2a83f8f0f713e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d84e22703594643c70dfa36dac2a83f8f0f713e/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9b4e7d9a5ec0f69c175d23dc9c94ed723147cf45"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 4,
      "deletions": 1
    },
    "files": [
      {
        "sha": "3e8de83c395389a3a7db7df42dae8d050b8c8ea0",
        "filename": "src/coincontrol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d84e22703594643c70dfa36dac2a83f8f0f713e/src/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d84e22703594643c70dfa36dac2a83f8f0f713e/src/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coincontrol.h?ref=2d84e22703594643c70dfa36dac2a83f8f0f713e",
        "patch": "@@ -12,6 +12,8 @@ class CCoinControl\n {\n public:\n     CTxDestination destChange;\n+    //! If false, allows unselected inputs, but requires all selected inputs be used\n+    bool fAllowOtherInputs;\n \n     CCoinControl()\n     {\n@@ -21,6 +23,7 @@ class CCoinControl\n     void SetNull()\n     {\n         destChange = CNoDestination();\n+        fAllowOtherInputs = false;\n         setSelected.clear();\n     }\n \n@@ -50,7 +53,7 @@ class CCoinControl\n         setSelected.clear();\n     }\n \n-    void ListSelected(std::vector<COutPoint>& vOutpoints)\n+    void ListSelected(std::vector<COutPoint>& vOutpoints) const\n     {\n         vOutpoints.assign(setSelected.begin(), setSelected.end());\n     }"
      }
    ]
  },
  {
    "sha": "1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZTBkMWEyZmYwMjk4MmQ2ZmZlNjFlNzBiMDI3YzU2ZjNiZjIyZDBi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-04-25T01:29:00Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-06-11T08:03:23Z"
      },
      "message": "Add FundTransaction method to wallet\n\nSome code stolen from Jonas Schnelli <jonas.schnelli@include7.ch>",
      "tree": {
        "sha": "0a4c0556f3def59bed7253a559ed621b00666969",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a4c0556f3def59bed7253a559ed621b00666969"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2d84e22703594643c70dfa36dac2a83f8f0f713e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d84e22703594643c70dfa36dac2a83f8f0f713e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2d84e22703594643c70dfa36dac2a83f8f0f713e"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 117,
      "deletions": 13
    },
    "files": [
      {
        "sha": "eee57900b52666d72b98aecc4e40285c97513922",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 114,
        "deletions": 11,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
        "patch": "@@ -1509,7 +1509,7 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n                 isminetype mine = IsMine(pcoin->vout[i]);\n                 if (!(IsSpent(wtxid, i)) && mine != ISMINE_NO &&\n                     !IsLockedCoin((*it).first, i) && (pcoin->vout[i].nValue > 0 || fIncludeZeroValue) &&\n-                    (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n+                    (!coinControl || !coinControl->HasSelected() || coinControl->fAllowOtherInputs || coinControl->IsSelected((*it).first, i)))\n                         vCoins.push_back(COutput(pcoin, i, nDepth, (mine & ISMINE_SPENDABLE) != ISMINE_NO));\n             }\n         }\n@@ -1669,25 +1669,108 @@ bool CWallet::SelectCoins(const CAmount& nTargetValue, set<pair<const CWalletTx*\n     AvailableCoins(vCoins, true, coinControl);\n \n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n-    if (coinControl && coinControl->HasSelected())\n+    if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n     {\n         BOOST_FOREACH(const COutput& out, vCoins)\n         {\n-            if(!out.fSpendable)\n-                continue;\n+            if (!out.fSpendable)\n+                 continue;\n             nValueRet += out.tx->vout[out.i].nValue;\n             setCoinsRet.insert(make_pair(out.tx, out.i));\n         }\n         return (nValueRet >= nTargetValue);\n     }\n \n-    return (SelectCoinsMinConf(nTargetValue, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n-            (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue, 0, 1, vCoins, setCoinsRet, nValueRet)));\n+    // calculate value from preset inputs and store them\n+    set<pair<const CWalletTx*, uint32_t> > setPresetCoins;\n+    CAmount nValueFromPresetInputs = 0;\n+\n+    std::vector<COutPoint> vPresetInputs;\n+    if (coinControl)\n+        coinControl->ListSelected(vPresetInputs);\n+    BOOST_FOREACH(const COutPoint& outpoint, vPresetInputs)\n+    {\n+        map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n+        if (it != mapWallet.end())\n+        {\n+            const CWalletTx* pcoin = &it->second;\n+            // Clearly invalid input, fail\n+            if (pcoin->vout.size() <= outpoint.n)\n+                return false;\n+            nValueFromPresetInputs += pcoin->vout[outpoint.n].nValue;\n+            setPresetCoins.insert(make_pair(pcoin, outpoint.n));\n+        } else\n+            return false; // TODO: Allow non-wallet inputs\n+    }\n+\n+    // remove preset inputs from vCoins\n+    for (vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n+    {\n+        if (setPresetCoins.count(make_pair(it->tx, it->i)))\n+            it = vCoins.erase(it);\n+        else\n+            ++it;\n+    }\n+\n+    bool res = nTargetValue <= nValueFromPresetInputs ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, vCoins, setCoinsRet, nValueRet));\n+\n+    // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n+    setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());\n+\n+    // add preset inputs to the total value selected\n+    nValueRet += nValueFromPresetInputs;\n+\n+    return res;\n }\n \n-bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend,\n-                                CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, const CCoinControl* coinControl)\n+bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount &nFeeRet, int& nChangePosRet, std::string& strFailReason)\n+{\n+    vector<CRecipient> vecSend;\n+\n+    // Turn the txout set into a CRecipient vector\n+    BOOST_FOREACH(const CTxOut& txOut, tx.vout)\n+    {\n+        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, false};\n+        vecSend.push_back(recipient);\n+    }\n+\n+    CCoinControl coinControl;\n+    coinControl.fAllowOtherInputs = true;\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        coinControl.Select(txin.prevout);\n+\n+    CReserveKey reservekey(this);\n+    CWalletTx wtx;\n+    if (!CreateTransaction(vecSend, wtx, reservekey, nFeeRet, nChangePosRet, strFailReason, &coinControl, false))\n+        return false;\n+\n+    if (nChangePosRet != -1)\n+        tx.vout.insert(tx.vout.begin() + nChangePosRet, wtx.vout[nChangePosRet]);\n+\n+    // Add new txins (keeping original txin scriptSig/order)\n+    BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+    {\n+        bool found = false;\n+        BOOST_FOREACH(const CTxIn& origTxIn, tx.vin)\n+        {\n+            if (txin.prevout.hash == origTxIn.prevout.hash && txin.prevout.n == origTxIn.prevout.n)\n+            {\n+                found = true;\n+                break;\n+            }\n+        }\n+        if (!found)\n+            tx.vin.push_back(txin);\n+    }\n+\n+    return true;\n+}\n+\n+bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n+                                int& nChangePosRet, std::string& strFailReason, const CCoinControl* coinControl, bool sign)\n {\n     CAmount nValue = 0;\n     unsigned int nSubtractFeeFromAmount = 0;\n@@ -1890,23 +1973,43 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend,\n \n                 // Sign\n                 int nIn = 0;\n+                CTransaction txNewConst(txNew);\n                 BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n-                    if (!SignSignature(*this, *coin.first, txNew, nIn++))\n+                {\n+                    bool signSuccess;\n+                    const CScript& scriptPubKey = coin.first->vout[coin.second].scriptPubKey;\n+                    CScript& scriptSigRes = txNew.vin[nIn].scriptSig;\n+                    if (sign)\n+                        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, scriptSigRes);\n+                    else\n+                        signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, scriptSigRes);\n+\n+                    if (!signSuccess)\n                     {\n                         strFailReason = _(\"Signing transaction failed\");\n                         return false;\n                     }\n+                    nIn++;\n+                }\n+\n+                unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n+\n+                // Remove scriptSigs if we used dummy signatures for fee calculation\n+                if (!sign) {\n+                    BOOST_FOREACH (CTxIn& vin, txNew.vin)\n+                        vin.scriptSig = CScript();\n+                }\n \n                 // Embed the constructed transaction data in wtxNew.\n                 *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);\n \n                 // Limit size\n-                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                 if (nBytes >= MAX_STANDARD_TX_SIZE)\n                 {\n                     strFailReason = _(\"Transaction too large\");\n                     return false;\n                 }\n+\n                 dPriority = wtxNew.ComputePriority(dPriority, nBytes);\n \n                 // Can we complete this as a free transaction?"
      },
      {
        "sha": "b6a8e8671f214fc8c9bbb2c6e7b23f7ddf9f292e",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
        "patch": "@@ -625,8 +625,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CAmount GetWatchOnlyBalance() const;\n     CAmount GetUnconfirmedWatchOnlyBalance() const;\n     CAmount GetImmatureWatchOnlyBalance() const;\n-    bool CreateTransaction(const std::vector<CRecipient>& vecSend,\n-                           CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, const CCoinControl *coinControl = NULL);\n+    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason);\n+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet,\n+                           std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);\n     bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n \n     static CFeeRate minTxFee;"
      }
    ]
  },
  {
    "sha": "21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMWJiZDkyMGU1Y2MwMmRhZTVlNzU3OTVjMWYwYmJmYmE5YTQxYjUz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-04-25T01:27:30Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-06-11T08:03:23Z"
      },
      "message": "Add fundrawtransaction RPC method",
      "tree": {
        "sha": "0d19c14fe84346df6c0aef5169bec725cd71552e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0d19c14fe84346df6c0aef5169bec725cd71552e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1e0d1a2ff02982d6ffe61e70b027c56f3bf22d0b"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 65,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ca673aa527761975d2feeecca39ac18680f24717",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "patch": "@@ -78,6 +78,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"signrawtransaction\", 1 },\n     { \"signrawtransaction\", 2 },\n     { \"sendrawtransaction\", 1 },\n+    { \"fundrawtransaction\", 1 },\n     { \"gettxout\", 1 },\n     { \"gettxout\", 2 },\n     { \"gettxoutproof\", 0 },"
      },
      {
        "sha": "011cfcb34e537d325d72cb4adb7673a579984693",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "patch": "@@ -316,6 +316,9 @@ static const CRPCCommand vRPCCommands[] =\n     { \"rawtransactions\",    \"getrawtransaction\",      &getrawtransaction,      true  },\n     { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     false },\n     { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     false }, /* uses wallet if enabled */\n+#ifdef ENABLE_WALLET\n+    { \"rawtransactions\",    \"fundrawtransaction\",     &fundrawtransaction,     false },\n+#endif\n \n     /* Utility functions */\n     { \"util\",               \"createmultisig\",         &createmultisig,         true  },"
      },
      {
        "sha": "5fb4faa8f94b93a39d75d148210d59a9ff0f2378",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "patch": "@@ -217,6 +217,7 @@ extern UniValue listlockunspent(const UniValue& params, bool fHelp);\n extern UniValue createrawtransaction(const UniValue& params, bool fHelp);\n extern UniValue decoderawtransaction(const UniValue& params, bool fHelp);\n extern UniValue decodescript(const UniValue& params, bool fHelp);\n+extern UniValue fundrawtransaction(const UniValue& params, bool fHelp);\n extern UniValue signrawtransaction(const UniValue& params, bool fHelp);\n extern UniValue sendrawtransaction(const UniValue& params, bool fHelp);\n extern UniValue gettxoutproof(const UniValue& params, bool fHelp);"
      },
      {
        "sha": "9368963ff2f37a5e3b233011d6a234aa13be40e5",
        "filename": "src/test/rpc_wallet_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/test/rpc_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/test/rpc_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_wallet_tests.cpp?ref=21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "patch": "@@ -217,6 +217,12 @@ BOOST_AUTO_TEST_CASE(rpc_wallet)\n     UniValue arr = retValue.get_array();\n     BOOST_CHECK(arr.size() > 0);\n     BOOST_CHECK(CBitcoinAddress(arr[0].get_str()).Get() == demoAddress.Get());\n+\n+    /*********************************\n+     * \t     fundrawtransaction\n+     *********************************/\n+    BOOST_CHECK_THROW(CallRPC(\"fundrawtransaction 28z\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"fundrawtransaction 01000000000180969800000000001976a91450ce0a4b0ee0ddeb633da85199728b940ac3fe9488ac00000000\"), runtime_error);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1ef2980e88f531bddbca75a02cea7f7d2e448ae3",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "patch": "@@ -2359,3 +2359,57 @@ UniValue listunspent(const UniValue& params, bool fHelp)\n \n     return results;\n }\n+\n+UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+                            \"fundrawtransaction \\\"hexstring\\\"\\n\"\n+                            \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n+                            \"This will not modify existing inputs, and will add one change output to the outputs.\\n\"\n+                            \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n+                            \"The inputs added will not be signed, use signrawtransaction for that.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"    (string, required) The hex string of the raw transaction\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"hex\\\":       \\\"value\\\", (string)  The resulting raw transaction (hex-encoded string)\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) The fee added to the transaction\\n\"\n+                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n+                            \"}\\n\"\n+                            \"\\\"hex\\\"             \\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction with no inputs\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+                            \"\\nAdd sufficient unsigned inputs to meet the output value\\n\"\n+                            + HelpExampleCli(\"fundrawtransaction\", \"\\\"rawtransactionhex\\\"\") +\n+                            \"\\nSign the transaction\\n\"\n+                            + HelpExampleCli(\"signrawtransaction\", \"\\\"fundedtransactionhex\\\"\") +\n+                            \"\\nSend the transaction\\n\"\n+                            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedtransactionhex\\\"\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR));\n+\n+    // parse hex string from parameter\n+    CTransaction origTx;\n+    if (!DecodeHexTx(origTx, params[0].get_str()))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+\n+    CMutableTransaction tx(origTx);\n+    CAmount nFee;\n+    string strFailReason;\n+    int nChangePos = -1;\n+    if(!pwalletMain->FundTransaction(tx, nFee, nChangePos, strFailReason))\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, strFailReason);\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"hex\", EncodeHexTx(tx)));\n+    result.push_back(Pair(\"changepos\", nChangePos));\n+    result.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n+\n+    return result;\n+}"
      }
    ]
  },
  {
    "sha": "208589514cdc344c2d33228dba7f00b305d0174b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDg1ODk1MTRjZGMzNDRjMmQzMzIyOGRiYTdmMDBiMzA1ZDAxNzRi",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-25T01:26:30Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2015-06-11T08:03:23Z"
      },
      "message": "fundrawtransaction tests",
      "tree": {
        "sha": "76c6bcfde798491345e2e1506933673a547f5720",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/76c6bcfde798491345e2e1506933673a547f5720"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/208589514cdc344c2d33228dba7f00b305d0174b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/208589514cdc344c2d33228dba7f00b305d0174b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/208589514cdc344c2d33228dba7f00b305d0174b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/208589514cdc344c2d33228dba7f00b305d0174b/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/21bbd920e5cc02dae5e75795c1f0bbfba9a41b53"
      }
    ],
    "stats": {
      "total": 557,
      "additions": 557,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f7f7b13cf9fb0754c1712c4d5fc9883911b59582",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/208589514cdc344c2d33228dba7f00b305d0174b/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/208589514cdc344c2d33228dba7f00b305d0174b/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=208589514cdc344c2d33228dba7f00b305d0174b",
        "patch": "@@ -30,6 +30,7 @@ testScripts=(\n     'zapwallettxes.py'\n     'proxy_test.py'\n     'merkle_blocks.py'\n+    'fundrawtransaction.py'\n     'signrawtransactions.py'\n     'walletbackup.py'\n );"
      },
      {
        "sha": "e859b264330609c27f22dfcf5480929cc56d04f2",
        "filename": "qa/rpc-tests/fundrawtransaction.py",
        "status": "added",
        "additions": 556,
        "deletions": 0,
        "changes": 556,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/208589514cdc344c2d33228dba7f00b305d0174b/qa/rpc-tests/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/208589514cdc344c2d33228dba7f00b305d0174b/qa/rpc-tests/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/fundrawtransaction.py?ref=208589514cdc344c2d33228dba7f00b305d0174b",
        "patch": "@@ -0,0 +1,556 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from pprint import pprint\n+from time import sleep\n+\n+# Create one-input, one-output, no-fee transaction:\n+class RawTransactionsTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        feeTolerance = Decimal(0.00000002) #if the fee's positive delta is higher than this value tests will fail, neg. delta always fail the tests\n+\n+        self.nodes[2].generate(1)\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.5);\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.0);\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0);\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        ###############\n+        # simple test #\n+        ###############\n+        inputs  = [ ]\n+        outputs = { self.nodes[0].getnewaddress() : 1.0 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+\n+        assert_equal(len(dec_tx['vin']), 1) #one vin coin\n+        assert_equal(dec_tx['vin'][0]['scriptSig']['hex'], '')\n+        assert_equal(fee + totalOut, 1.5) #the 1.5BTC coin must be taken\n+\n+        ##############################\n+        # simple test with two coins #\n+        ##############################\n+        inputs  = [ ]\n+        outputs = { self.nodes[0].getnewaddress() : 2.2 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+\n+        assert_equal(len(dec_tx['vin']), 2) #one vin coin\n+        assert_equal(dec_tx['vin'][0]['scriptSig']['hex'], '')\n+        assert_equal(dec_tx['vin'][1]['scriptSig']['hex'], '')\n+        assert_equal(fee + totalOut, 2.5) #the 1.5BTC+1.0BTC coins must have be taken\n+\n+        ##############################\n+        # simple test with two coins #\n+        ##############################\n+        inputs  = [ ]\n+        outputs = { self.nodes[0].getnewaddress() : 2.6 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+\n+        assert_equal(len(dec_tx['vin']), 1) #one vin coin\n+        assert_equal(dec_tx['vin'][0]['scriptSig']['hex'], '')\n+        assert_equal(fee + totalOut, 5.0) #the 5.0BTC coin must have be taken\n+\n+\n+        ################################\n+        # simple test with two outputs #\n+        ################################\n+        inputs  = [ ]\n+        outputs = { self.nodes[0].getnewaddress() : 2.6, self.nodes[1].getnewaddress() : 2.5 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+\n+        assert_equal(len(dec_tx['vin']), 2) #one vin coin\n+        assert_equal(dec_tx['vin'][0]['scriptSig']['hex'], '')\n+        assert_equal(dec_tx['vin'][1]['scriptSig']['hex'], '')\n+        assert_equal(fee + totalOut, 6.0) #the 5.0BTC + 1.0BTC coins must have be taken\n+\n+\n+\n+        #########################################################################\n+        # test a fundrawtransaction with a VIN greater than the required amount #\n+        #########################################################################\n+        utx = False\n+        listunspent = self.nodes[2].listunspent()\n+        for aUtx in listunspent:\n+            if aUtx['amount'] == 5.0:\n+                utx = aUtx\n+                break;\n+\n+        assert_equal(utx!=False, True)\n+\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']}]\n+        outputs = { self.nodes[0].getnewaddress() : 1.0 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+        assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+\n+        assert_equal(fee + totalOut, utx['amount']) #compare vin total and totalout+fee\n+\n+\n+\n+        #####################################################################\n+        # test a fundrawtransaction with which will not get a change output #\n+        #####################################################################\n+        utx = False\n+        listunspent = self.nodes[2].listunspent()\n+        for aUtx in listunspent:\n+            if aUtx['amount'] == 5.0:\n+                utx = aUtx\n+                break;\n+\n+        assert_equal(utx!=False, True)\n+\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']}]\n+        outputs = { self.nodes[0].getnewaddress() : Decimal(5.0) - fee - feeTolerance }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+        assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+\n+        assert_equal(rawtxfund['changepos'], -1)\n+        assert_equal(fee + totalOut, utx['amount']) #compare vin total and totalout+fee\n+\n+\n+\n+        #########################################################################\n+        # test a fundrawtransaction with a VIN smaller than the required amount #\n+        #########################################################################\n+        utx = False\n+        listunspent = self.nodes[2].listunspent()\n+        for aUtx in listunspent:\n+            if aUtx['amount'] == 1.0:\n+                utx = aUtx\n+                break;\n+\n+        assert_equal(utx!=False, True)\n+\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']}]\n+        outputs = { self.nodes[0].getnewaddress() : 1.0 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+\n+        # 4-byte version + 1-byte vin count + 36-byte prevout then script_len\n+        rawtx = rawtx[:82] + \"0100\" + rawtx[84:]\n+\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+        assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n+        assert_equal(\"00\", dec_tx['vin'][0]['scriptSig']['hex'])\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        matchingOuts = 0\n+        for i, out in enumerate(dec_tx['vout']):\n+            totalOut += out['value']\n+            if outputs.has_key(out['scriptPubKey']['addresses'][0]):\n+                matchingOuts+=1\n+            else:\n+                assert_equal(i, rawtxfund['changepos'])\n+\n+        assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n+        assert_equal(\"00\", dec_tx['vin'][0]['scriptSig']['hex'])\n+\n+        assert_equal(matchingOuts, 1)\n+        assert_equal(len(dec_tx['vout']), 2)\n+\n+        assert_equal(fee + totalOut, 2.5) #this tx must use the 1.0BTC and the 1.5BTC coin\n+\n+\n+        ###########################################\n+        # test a fundrawtransaction with two VINs #\n+        ###########################################\n+        utx  = False\n+        utx2 = False\n+        listunspent = self.nodes[2].listunspent()\n+        for aUtx in listunspent:\n+            if aUtx['amount'] == 1.0:\n+                utx = aUtx\n+            if aUtx['amount'] == 5.0:\n+                utx2 = aUtx\n+\n+\n+        assert_equal(utx!=False, True)\n+\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']},{'txid' : utx2['txid'], 'vout' : utx2['vout']} ]\n+        outputs = { self.nodes[0].getnewaddress() : 6.0 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+        assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        matchingOuts = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+            if outputs.has_key(out['scriptPubKey']['addresses'][0]):\n+                matchingOuts+=1\n+\n+        assert_equal(matchingOuts, 1)\n+        assert_equal(len(dec_tx['vout']), 2)\n+\n+        matchingIns = 0\n+        for vinOut in dec_tx['vin']:\n+            for vinIn in inputs:\n+                if vinIn['txid'] == vinOut['txid']:\n+                    matchingIns+=1\n+\n+        assert_equal(matchingIns, 2) #we now must see two vins identical to vins given as params\n+        assert_equal(fee + totalOut, 7.5) #this tx must use the 1.0BTC and the 1.5BTC coin\n+\n+\n+        #########################################################\n+        # test a fundrawtransaction with two VINs and two vOUTs #\n+        #########################################################\n+        utx  = False\n+        utx2 = False\n+        listunspent = self.nodes[2].listunspent()\n+        for aUtx in listunspent:\n+            if aUtx['amount'] == 1.0:\n+                utx = aUtx\n+            if aUtx['amount'] == 5.0:\n+                utx2 = aUtx\n+\n+\n+        assert_equal(utx!=False, True)\n+\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']},{'txid' : utx2['txid'], 'vout' : utx2['vout']} ]\n+        outputs = { self.nodes[0].getnewaddress() : 6.0, self.nodes[0].getnewaddress() : 1.0 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+        assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n+\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        fee = rawtxfund['fee']\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n+        totalOut = 0\n+        matchingOuts = 0\n+        for out in dec_tx['vout']:\n+            totalOut += out['value']\n+            if outputs.has_key(out['scriptPubKey']['addresses'][0]):\n+                matchingOuts+=1\n+\n+        assert_equal(matchingOuts, 2)\n+        assert_equal(len(dec_tx['vout']), 3)\n+        assert_equal(fee + totalOut, 7.5) #this tx must use the 1.0BTC and the 1.5BTC coin\n+\n+\n+        ##############################################\n+        # test a fundrawtransaction with invalid vin #\n+        ##############################################\n+        listunspent = self.nodes[2].listunspent()\n+        inputs  = [ {'txid' : \"1c7f966dab21119bac53213a2bc7532bff1fa844c124fd750a7d0b1332440bd1\", 'vout' : 0} ] #invalid vin!\n+        outputs = { self.nodes[0].getnewaddress() : 1.0}\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n+\n+        errorString = \"\"\n+        try:\n+            rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        except JSONRPCException,e:\n+            errorString = e.error['message']\n+\n+        assert_equal(\"Insufficient\" in errorString, True);\n+\n+\n+\n+        ############################################################\n+        #compare fee of a standard pubkeyhash transaction\n+        inputs = []\n+        outputs = {self.nodes[1].getnewaddress():1.1}\n+        rawTx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[0].fundrawtransaction(rawTx)\n+\n+        #create same transaction over sendtoaddress\n+        txId = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1.1);\n+        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+\n+        #compare fee\n+        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee);\n+        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        ############################################################\n+\n+        ############################################################\n+        #compare fee of a standard pubkeyhash transaction with multiple outputs\n+        inputs = []\n+        outputs = {self.nodes[1].getnewaddress():1.1,self.nodes[1].getnewaddress():1.2,self.nodes[1].getnewaddress():0.1,self.nodes[1].getnewaddress():1.3,self.nodes[1].getnewaddress():0.2,self.nodes[1].getnewaddress():0.3}\n+        rawTx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[0].fundrawtransaction(rawTx)\n+        #create same transaction over sendtoaddress\n+        txId = self.nodes[0].sendmany(\"\", outputs);\n+        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+\n+        #compare fee\n+        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee);\n+        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        ############################################################\n+\n+\n+        ############################################################\n+        #compare fee of a 2of2 multisig p2sh transaction\n+\n+        # create 2of2 addr\n+        addr1 = self.nodes[1].getnewaddress()\n+        addr2 = self.nodes[1].getnewaddress()\n+\n+        addr1Obj = self.nodes[1].validateaddress(addr1)\n+        addr2Obj = self.nodes[1].validateaddress(addr2)\n+\n+        mSigObj = self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+\n+        inputs = []\n+        outputs = {mSigObj:1.1}\n+        rawTx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[0].fundrawtransaction(rawTx)\n+\n+        #create same transaction over sendtoaddress\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 1.1);\n+        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+\n+        #compare fee\n+        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee);\n+        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        ############################################################\n+\n+\n+        ############################################################\n+        #compare fee of a standard pubkeyhash transaction\n+\n+        # create 4of5 addr\n+        addr1 = self.nodes[1].getnewaddress()\n+        addr2 = self.nodes[1].getnewaddress()\n+        addr3 = self.nodes[1].getnewaddress()\n+        addr4 = self.nodes[1].getnewaddress()\n+        addr5 = self.nodes[1].getnewaddress()\n+\n+        addr1Obj = self.nodes[1].validateaddress(addr1)\n+        addr2Obj = self.nodes[1].validateaddress(addr2)\n+        addr3Obj = self.nodes[1].validateaddress(addr3)\n+        addr4Obj = self.nodes[1].validateaddress(addr4)\n+        addr5Obj = self.nodes[1].validateaddress(addr5)\n+\n+        mSigObj = self.nodes[1].addmultisigaddress(4, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey'], addr4Obj['pubkey'], addr5Obj['pubkey']])\n+\n+        inputs = []\n+        outputs = {mSigObj:1.1}\n+        rawTx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[0].fundrawtransaction(rawTx)\n+\n+        #create same transaction over sendtoaddress\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 1.1);\n+        signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n+\n+        #compare fee\n+        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee);\n+        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        ############################################################\n+\n+\n+        ############################################################\n+        # spend a 2of2 multisig transaction over fundraw\n+\n+        # create 2of2 addr\n+        addr1 = self.nodes[2].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[2].validateaddress(addr1)\n+        addr2Obj = self.nodes[2].validateaddress(addr2)\n+\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+\n+\n+        # send 1.2 BTC to msig addr\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 1.2);\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+\n+        oldBalance = self.nodes[1].getbalance()\n+        inputs = []\n+        outputs = {self.nodes[1].getnewaddress():1.1}\n+        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[2].fundrawtransaction(rawTx)\n+\n+        signedTx = self.nodes[2].signrawtransaction(fundedTx['hex'])\n+        txId = self.nodes[2].sendrawtransaction(signedTx['hex'])\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+\n+        # make sure funds are received at node1\n+        assert_equal(oldBalance+Decimal('1.10000000'), self.nodes[1].getbalance())\n+\n+        ############################################################\n+        # locked wallet test\n+        self.nodes[1].encryptwallet(\"test\")\n+        self.nodes.pop(1)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+        error = False\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.2);\n+        except:\n+            error = True\n+        assert(error)\n+\n+        oldBalance = self.nodes[0].getbalance()\n+\n+        inputs = []\n+        outputs = {self.nodes[0].getnewaddress():1.1}\n+        rawTx = self.nodes[1].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[1].fundrawtransaction(rawTx)\n+\n+        #now we need to unlock\n+        self.nodes[1].walletpassphrase(\"test\", 100)\n+        signedTx = self.nodes[1].signrawtransaction(fundedTx['hex'])\n+        txId = self.nodes[1].sendrawtransaction(signedTx['hex'])\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+\n+        # make sure funds are received at node1\n+        assert_equal(oldBalance+Decimal('51.10000000'), self.nodes[0].getbalance())\n+\n+\n+\n+        ###############################################\n+        # multiple (~19) inputs tx test | Compare fee #\n+        ###############################################\n+\n+        #empty node1, send some small coins from node0 to node1\n+        self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True);\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        for i in range(0,20):\n+            self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01);\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        #fund a tx with ~20 small inputs\n+        inputs = []\n+        outputs = {self.nodes[0].getnewaddress():0.15,self.nodes[0].getnewaddress():0.04}\n+        rawTx = self.nodes[1].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[1].fundrawtransaction(rawTx)\n+\n+        #create same transaction over sendtoaddress\n+        txId = self.nodes[1].sendmany(\"\", outputs);\n+        signedFee = self.nodes[1].getrawmempool(True)[txId]['fee']\n+\n+        #compare fee\n+        feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee);\n+        assert(feeDelta >= 0 and feeDelta <= feeTolerance*19) #~19 inputs\n+\n+\n+        #############################################\n+        # multiple (~19) inputs tx test | sign/send #\n+        #############################################\n+\n+        #again, empty node1, send some small coins from node0 to node1\n+        self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True);\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        for i in range(0,20):\n+            self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01);\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        #fund a tx with ~20 small inputs\n+        oldBalance = self.nodes[0].getbalance()\n+\n+        inputs = []\n+        outputs = {self.nodes[0].getnewaddress():0.15,self.nodes[0].getnewaddress():0.04}\n+        rawTx = self.nodes[1].createrawtransaction(inputs, outputs)\n+        fundedTx = self.nodes[1].fundrawtransaction(rawTx)\n+        fundedAndSignedTx = self.nodes[1].signrawtransaction(fundedTx['hex'])\n+        txId = self.nodes[1].sendrawtransaction(fundedAndSignedTx['hex'])\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(oldBalance+Decimal('50.19000000'), self.nodes[0].getbalance()) #0.19+block reward\n+\n+\n+if __name__ == '__main__':\n+    RawTransactionsTest().main()"
      }
    ]
  }
]