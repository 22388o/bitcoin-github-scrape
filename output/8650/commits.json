[
  {
    "sha": "1af4697f8f6cb155d03044ce8c93a43613c75fd7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYWY0Njk3ZjhmNmNiMTU1ZDAzMDQ0Y2U4YzkzYTQzNjEzYzc1ZmQ3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-09-02T04:23:39Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-09-02T04:52:51Z"
      },
      "message": "Make tests much faster by replacing BOOST_CHECK with FAST_CHECK",
      "tree": {
        "sha": "58a2fc932bacb275d45b3aa9ca211f64e34e3ba6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/58a2fc932bacb275d45b3aa9ca211f64e34e3ba6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1af4697f8f6cb155d03044ce8c93a43613c75fd7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af4697f8f6cb155d03044ce8c93a43613c75fd7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1af4697f8f6cb155d03044ce8c93a43613c75fd7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af4697f8f6cb155d03044ce8c93a43613c75fd7/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b23dbaee5b88d7237144e14eff01391e2cc201d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b23dbaee5b88d7237144e14eff01391e2cc201d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b23dbaee5b88d7237144e14eff01391e2cc201d"
      }
    ],
    "stats": {
      "total": 4651,
      "additions": 2329,
      "deletions": 2322
    },
    "files": [
      {
        "sha": "2e96b11a046a613a1268c22281df83dfcd5ad958",
        "filename": "src/test/Checkpoints_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/Checkpoints_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/Checkpoints_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/Checkpoints_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -21,7 +21,7 @@ BOOST_FIXTURE_TEST_SUITE(Checkpoints_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(sanity)\n {\n     const CCheckpointData& checkpoints = Params(CBaseChainParams::MAIN).Checkpoints();\n-    BOOST_CHECK(Checkpoints::GetTotalBlocksEstimate(checkpoints) >= 134444);\n+    FAST_CHECK(Checkpoints::GetTotalBlocksEstimate(checkpoints) >= 134444);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e82a87d84f832440222eb0ca762add84b96445c1",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -50,19 +50,19 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     SendMessages(&dummyNode1);\n-    BOOST_CHECK(CNode::IsBanned(addr1));\n-    BOOST_CHECK(!CNode::IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n+    FAST_CHECK(CNode::IsBanned(addr1));\n+    FAST_CHECK(!CNode::IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(INVALID_SOCKET, addr2, \"\", true);\n     dummyNode2.nVersion = 1;\n     Misbehaving(dummyNode2.GetId(), 50);\n     SendMessages(&dummyNode2);\n-    BOOST_CHECK(!CNode::IsBanned(addr2)); // 2 not banned yet...\n-    BOOST_CHECK(CNode::IsBanned(addr1));  // ... but 1 still should be\n+    FAST_CHECK(!CNode::IsBanned(addr2)); // 2 not banned yet...\n+    FAST_CHECK(CNode::IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n     SendMessages(&dummyNode2);\n-    BOOST_CHECK(CNode::IsBanned(addr2));\n+    FAST_CHECK(CNode::IsBanned(addr2));\n }\n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n@@ -74,13 +74,13 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100);\n     SendMessages(&dummyNode1);\n-    BOOST_CHECK(!CNode::IsBanned(addr1));\n+    FAST_CHECK(!CNode::IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n     SendMessages(&dummyNode1);\n-    BOOST_CHECK(!CNode::IsBanned(addr1));\n+    FAST_CHECK(!CNode::IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n     SendMessages(&dummyNode1);\n-    BOOST_CHECK(CNode::IsBanned(addr1));\n+    FAST_CHECK(CNode::IsBanned(addr1));\n     mapArgs.erase(\"-banscore\");\n }\n \n@@ -96,13 +96,13 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n \n     Misbehaving(dummyNode.GetId(), 100);\n     SendMessages(&dummyNode);\n-    BOOST_CHECK(CNode::IsBanned(addr));\n+    FAST_CHECK(CNode::IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);\n-    BOOST_CHECK(CNode::IsBanned(addr));\n+    FAST_CHECK(CNode::IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60*24+1);\n-    BOOST_CHECK(!CNode::IsBanned(addr));\n+    FAST_CHECK(!CNode::IsBanned(addr));\n }\n \n CTransaction RandomOrphan()\n@@ -174,25 +174,25 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         for (unsigned int j = 1; j < tx.vin.size(); j++)\n             tx.vin[j].scriptSig = tx.vin[0].scriptSig;\n \n-        BOOST_CHECK(!AddOrphanTx(tx, i));\n+        FAST_CHECK(!AddOrphanTx(tx, i));\n     }\n \n     // Test EraseOrphansFor:\n     for (NodeId i = 0; i < 3; i++)\n     {\n         size_t sizeBefore = mapOrphanTransactions.size();\n         EraseOrphansFor(i);\n-        BOOST_CHECK(mapOrphanTransactions.size() < sizeBefore);\n+        FAST_CHECK(mapOrphanTransactions.size() < sizeBefore);\n     }\n \n     // Test LimitOrphanTxSize() function:\n     LimitOrphanTxSize(40);\n-    BOOST_CHECK(mapOrphanTransactions.size() <= 40);\n+    FAST_CHECK(mapOrphanTransactions.size() <= 40);\n     LimitOrphanTxSize(10);\n-    BOOST_CHECK(mapOrphanTransactions.size() <= 10);\n+    FAST_CHECK(mapOrphanTransactions.size() <= 10);\n     LimitOrphanTxSize(0);\n-    BOOST_CHECK(mapOrphanTransactions.empty());\n-    BOOST_CHECK(mapOrphanTransactionsByPrev.empty());\n+    FAST_CHECK(mapOrphanTransactions.empty());\n+    FAST_CHECK(mapOrphanTransactionsByPrev.empty());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "18cffc4fcd9b21549c367fdaa1a43cb96aef65b4",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 67,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -87,35 +87,35 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test 1: Does Addrman respond correctly when empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null = addrman.Select();\n-    BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n+    FAST_CHECK(addr_null.ToString() == \"[::]:0\");\n \n     // Test 2: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    FAST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n     // Test 3: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n     CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1_dup, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n \n \n     // Test 5: New table has one addr and we add a diff addr we should\n     //  have two addrs.\n     CService addr2 = ResolveService(\"250.1.1.2\", 8333);\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 2);\n+    FAST_CHECK(addrman.size() == 2);\n \n     // Test 6: AddrMan::Clear() should empty the new table.\n     addrman.Clear();\n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null2 = addrman.Select();\n-    BOOST_CHECK(addr_null2.ToString() == \"[::]:0\");\n+    FAST_CHECK(addr_null2.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n@@ -127,26 +127,26 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n \n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n-    BOOST_CHECK(addr_ret2.ToString() == \"250.1.1.1:8333\");\n+    FAST_CHECK(addr_ret2.ToString() == \"250.1.1.1:8333\");\n \n     // Test 8: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n     bool newOnly = true;\n     CAddrInfo addr_ret3 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    FAST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n }\n \n \n@@ -162,22 +162,22 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Test 9: Select from new with 1 addr in new.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n \n     bool newOnly = true;\n     CAddrInfo addr_ret1 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    FAST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n     // Test 10: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret2 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret2.ToString() == \"[::]:0\");\n+    FAST_CHECK(addr_ret2.ToString() == \"[::]:0\");\n \n     CAddrInfo addr_ret3 = addrman.Select();\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    FAST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n \n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n \n \n     // Add three addresses to new table.\n@@ -202,13 +202,13 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n     // Test 11: 6 addrs + 1 addr from last test = 7.\n-    BOOST_CHECK(addrman.size() == 7);\n+    FAST_CHECK(addrman.size() == 7);\n \n     // Test 12: Select pulls from new and tried regardless of port number.\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.4.6.6:8333\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.3.2.2:9999\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.3.3.3:9999\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.4.4.4:8333\");\n+    FAST_CHECK(addrman.Select().ToString() == \"250.4.6.6:8333\");\n+    FAST_CHECK(addrman.Select().ToString() == \"250.3.2.2:9999\");\n+    FAST_CHECK(addrman.Select().ToString() == \"250.3.3.3:9999\");\n+    FAST_CHECK(addrman.Select().ToString() == \"250.4.4.4:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n@@ -220,24 +220,24 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n         //Test 13: No collision in new table yet.\n-        BOOST_CHECK(addrman.size() == i);\n+        FAST_CHECK(addrman.size() == i);\n     }\n \n     //Test 14: new table collision!\n     CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 17);\n+    FAST_CHECK(addrman.size() == 17);\n \n     CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 18);\n+    FAST_CHECK(addrman.size() == 18);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n@@ -249,7 +249,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n@@ -258,17 +258,17 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n         //Test 15: No collision in tried table yet.\n         BOOST_TEST_MESSAGE(addrman.size());\n-        BOOST_CHECK(addrman.size() == i);\n+        FAST_CHECK(addrman.size() == i);\n     }\n \n     //Test 16: tried table collision!\n     CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 79);\n+    FAST_CHECK(addrman.size() == 79);\n \n     CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 80);\n+    FAST_CHECK(addrman.size() == 80);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -293,21 +293,21 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n \n     // Test 17: ensure Find returns an IP matching what we searched on.\n     CAddrInfo* info1 = addrman.Find(addr1);\n-    BOOST_CHECK(info1);\n+    FAST_CHECK(info1);\n     if (info1)\n-        BOOST_CHECK(info1->ToString() == \"250.1.2.1:8333\");\n+        FAST_CHECK(info1->ToString() == \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n     CAddrInfo* info2 = addrman.Find(addr2);\n-    BOOST_CHECK(info2);\n+    FAST_CHECK(info2);\n     if (info2)\n-        BOOST_CHECK(info2->ToString() == info1->ToString());\n+        FAST_CHECK(info2->ToString() == info1->ToString());\n \n     // Test 19: Find returns another IP matching what we searched on.\n     CAddrInfo* info3 = addrman.Find(addr3);\n-    BOOST_CHECK(info3);\n+    FAST_CHECK(info3);\n     if (info3)\n-        BOOST_CHECK(info3->ToString() == \"251.255.2.1:8333\");\n+        FAST_CHECK(info3->ToString() == \"251.255.2.1:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n@@ -317,7 +317,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n@@ -326,10 +326,10 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n     // Test 20: The result should be the same as the input addr.\n-    BOOST_CHECK(pinfo->ToString() == \"250.1.2.1:8333\");\n+    FAST_CHECK(pinfo->ToString() == \"250.1.2.1:8333\");\n \n     CAddrInfo* info2 = addrman.Find(addr1);\n-    BOOST_CHECK(info2->ToString() == \"250.1.2.1:8333\");\n+    FAST_CHECK(info2->ToString() == \"250.1.2.1:8333\");\n }\n \n \n@@ -340,7 +340,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n@@ -349,11 +349,11 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     addrman.Create(addr1, source1, &nId);\n \n     // Test 21: Delete should actually delete the addr.\n-    BOOST_CHECK(addrman.size() == 1);\n+    FAST_CHECK(addrman.size() == 1);\n     addrman.Delete(nId);\n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n     CAddrInfo* info2 = addrman.Find(addr1);\n-    BOOST_CHECK(info2 == NULL);\n+    FAST_CHECK(info2 == NULL);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)\n@@ -365,9 +365,9 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n     // Test 22: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    FAST_CHECK(addrman.size() == 0);\n     vector<CAddress> vAddr1 = addrman.GetAddr();\n-    BOOST_CHECK(vAddr1.size() == 0);\n+    FAST_CHECK(vAddr1.size() == 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n@@ -390,12 +390,12 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     addrman.Add(addr5, source1);\n \n     // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n-    BOOST_CHECK(addrman.GetAddr().size() == 1); \n+    FAST_CHECK(addrman.GetAddr().size() == 1); \n \n     // Test 24: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK(addrman.GetAddr().size() == 1);\n+    FAST_CHECK(addrman.GetAddr().size() == 1);\n \n     // Test 25: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n@@ -414,10 +414,10 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     vector<CAddress> vAddr = addrman.GetAddr();\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n-    BOOST_CHECK(vAddr.size() == percent23);\n-    BOOST_CHECK(vAddr.size() == 461);\n+    FAST_CHECK(vAddr.size() == percent23);\n+    FAST_CHECK(vAddr.size() == 461);\n     // (Addrman.size() < number of addresses added) due to address collisons.\n-    BOOST_CHECK(addrman.size() == 2007);\n+    FAST_CHECK(addrman.size() == 2007);\n }\n \n \n@@ -440,18 +440,18 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n \n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) == 40);\n+    FAST_CHECK(info1.GetTriedBucket(nKey1) == 40);\n \n     // Test 26: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n+    FAST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n \n     // Test 27: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n \n-    BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) != info2.GetTriedBucket(nKey1));\n+    FAST_CHECK(info1.GetKey() != info2.GetKey());\n+    FAST_CHECK(info1.GetTriedBucket(nKey1) != info2.GetTriedBucket(nKey1));\n \n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n@@ -463,7 +463,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     }\n     // Test 28: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  never get more than 8 buckets\n-    BOOST_CHECK(buckets.size() == 8);\n+    FAST_CHECK(buckets.size() == 8);\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n@@ -475,7 +475,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     }\n     // Test 29: IP addresses in the different groups should map to more than\n     //  8 buckets.\n-    BOOST_CHECK(buckets.size() == 160);\n+    FAST_CHECK(buckets.size() == 160);\n }\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n@@ -495,16 +495,16 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == 786);\n+    FAST_CHECK(info1.GetNewBucket(nKey1) == 786);\n \n     // Test 30: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n+    FAST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n \n     // Test 31: Ports should not effect bucket placement in the addr\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n-    BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n+    FAST_CHECK(info1.GetKey() != info2.GetKey());\n+    FAST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n \n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n@@ -516,7 +516,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     }\n     // Test 32: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  always map to the same bucket.\n-    BOOST_CHECK(buckets.size() == 1);\n+    FAST_CHECK(buckets.size() == 1);\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n@@ -529,7 +529,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     }\n     // Test 33: IP addresses in the same source groups should map to no more\n     //  than 64 buckets.\n-    BOOST_CHECK(buckets.size() <= 64);\n+    FAST_CHECK(buckets.size() <= 64);\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n@@ -541,6 +541,6 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     }\n     // Test 34: IP addresses in the different source groups should map to more\n     //  than 64 buckets.\n-    BOOST_CHECK(buckets.size() > 64);\n+    FAST_CHECK(buckets.size() > 64);\n }\n BOOST_AUTO_TEST_SUITE_END()\n\\ No newline at end of file"
      },
      {
        "sha": "9577063d3dfaac4fd320e27db360cd58c82071dc",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -62,17 +62,17 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n     }\n     /* one very large object, straddling pages */\n     lpm.LockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n-    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(600+500)));\n+    FAST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(600+500)));\n     /* one very large object, page aligned */\n     lpm.LockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n-    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(1200+500-1)));\n+    FAST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(1200+500-1)));\n \n-    BOOST_CHECK(lpm.GetLockedPageCount() == (\n+    FAST_CHECK(lpm.GetLockedPageCount() == (\n         (1000*33+test_page_size-1)/test_page_size + // small objects\n         101 + 100 +  // page-sized objects\n         501 + 500)); // large objects\n-    BOOST_CHECK((last_lock_len & (test_page_size-1)) == 0); // always lock entire pages\n-    BOOST_CHECK(last_unlock_len == 0); // nothing unlocked yet\n+    FAST_CHECK((last_lock_len & (test_page_size-1)) == 0); // always lock entire pages\n+    FAST_CHECK(last_unlock_len == 0); // nothing unlocked yet\n \n     /* And unlock again */\n     addr = 0;\n@@ -97,7 +97,7 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n     lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n \n     /* Check that everything is released */\n-    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n+    FAST_CHECK(lpm.GetLockedPageCount() == 0);\n \n     /* A few and unlocks of size zero (should have no effect) */\n     addr = 0;\n@@ -106,15 +106,15 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n         lpm.LockRange(reinterpret_cast<void*>(addr), 0);\n         addr += 1;\n     }\n-    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n+    FAST_CHECK(lpm.GetLockedPageCount() == 0);\n     addr = 0;\n     for(int i=0; i<1000; ++i)\n     {\n         lpm.UnlockRange(reinterpret_cast<void*>(addr), 0);\n         addr += 1;\n     }\n-    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n-    BOOST_CHECK((last_unlock_len & (test_page_size-1)) == 0); // always unlock entire pages\n+    FAST_CHECK(lpm.GetLockedPageCount() == 0);\n+    FAST_CHECK((last_unlock_len & (test_page_size-1)) == 0); // always unlock entire pages\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "66a9525be8b2c4b10c407b9e91015d5bfe00c3b6",
        "filename": "src/test/amount_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/amount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/amount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/amount_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -15,55 +15,55 @@ BOOST_AUTO_TEST_CASE(GetFeeTest)\n \n     feeRate = CFeeRate(0);\n     // Must always return 0\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(1e5), 0);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(1e5), 0);\n \n     feeRate = CFeeRate(1000);\n     // Must always just return the arg\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(1), 1);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(121), 121);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(999), 999);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(1e3), 1e3);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(9e3), 9e3);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(1), 1);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(121), 121);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(999), 999);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(1e3), 1e3);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(9e3), 9e3);\n \n     feeRate = CFeeRate(-1000);\n     // Must always just return -1 * arg\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(1), -1);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(121), -121);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(999), -999);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(1e3), -1e3);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(9e3), -9e3);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(1), -1);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(121), -121);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(999), -999);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(1e3), -1e3);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(9e3), -9e3);\n \n     feeRate = CFeeRate(123);\n     // Truncates the result, if not integer\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(8), 1); // Special case: returns 1 instead of 0\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(9), 1);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(121), 14);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(122), 15);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(999), 122);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(1e3), 123);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(9e3), 1107);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(8), 1); // Special case: returns 1 instead of 0\n+    FAST_CHECK_EQUAL(feeRate.GetFee(9), 1);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(121), 14);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(122), 15);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(999), 122);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(1e3), 123);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(9e3), 1107);\n \n     feeRate = CFeeRate(-123);\n     // Truncates the result, if not integer\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(8), -1); // Special case: returns -1 instead of 0\n-    BOOST_CHECK_EQUAL(feeRate.GetFee(9), -1);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(0), 0);\n+    FAST_CHECK_EQUAL(feeRate.GetFee(8), -1); // Special case: returns -1 instead of 0\n+    FAST_CHECK_EQUAL(feeRate.GetFee(9), -1);\n \n     // Check full constructor\n     // default value\n-    BOOST_CHECK(CFeeRate(CAmount(-1), 1000) == CFeeRate(-1));\n-    BOOST_CHECK(CFeeRate(CAmount(0), 1000) == CFeeRate(0));\n-    BOOST_CHECK(CFeeRate(CAmount(1), 1000) == CFeeRate(1));\n+    FAST_CHECK(CFeeRate(CAmount(-1), 1000) == CFeeRate(-1));\n+    FAST_CHECK(CFeeRate(CAmount(0), 1000) == CFeeRate(0));\n+    FAST_CHECK(CFeeRate(CAmount(1), 1000) == CFeeRate(1));\n     // lost precision (can only resolve satoshis per kB)\n-    BOOST_CHECK(CFeeRate(CAmount(1), 1001) == CFeeRate(0));\n-    BOOST_CHECK(CFeeRate(CAmount(2), 1001) == CFeeRate(1));\n+    FAST_CHECK(CFeeRate(CAmount(1), 1001) == CFeeRate(0));\n+    FAST_CHECK(CFeeRate(CAmount(2), 1001) == CFeeRate(1));\n     // some more integer checks\n-    BOOST_CHECK(CFeeRate(CAmount(26), 789) == CFeeRate(32));\n-    BOOST_CHECK(CFeeRate(CAmount(27), 789) == CFeeRate(34));\n+    FAST_CHECK(CFeeRate(CAmount(26), 789) == CFeeRate(32));\n+    FAST_CHECK(CFeeRate(CAmount(27), 789) == CFeeRate(34));\n     // Maximum size in bytes, should not crash\n     CFeeRate(MAX_MONEY, std::numeric_limits<size_t>::max() >> 1).GetFeePerK();\n }"
      },
      {
        "sha": "d958a0b97ebacb0917b4c13d5cc7a4869c642229",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 240,
        "deletions": 240,
        "changes": 480,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -66,60 +66,60 @@ std::string ArrayToString(const unsigned char A[], unsigned int width)\n \n BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n {\n-    BOOST_CHECK(1 == 0+1);\n+    FAST_CHECK(1 == 0+1);\n     // constructor arith_uint256(vector<char>):\n-    BOOST_CHECK(R1L.ToString() == ArrayToString(R1Array,32));\n-    BOOST_CHECK(R2L.ToString() == ArrayToString(R2Array,32));\n-    BOOST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray,32));\n-    BOOST_CHECK(OneL.ToString() == ArrayToString(OneArray,32));\n-    BOOST_CHECK(MaxL.ToString() == ArrayToString(MaxArray,32));\n-    BOOST_CHECK(OneL.ToString() != ArrayToString(ZeroArray,32));\n+    FAST_CHECK(R1L.ToString() == ArrayToString(R1Array,32));\n+    FAST_CHECK(R2L.ToString() == ArrayToString(R2Array,32));\n+    FAST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray,32));\n+    FAST_CHECK(OneL.ToString() == ArrayToString(OneArray,32));\n+    FAST_CHECK(MaxL.ToString() == ArrayToString(MaxArray,32));\n+    FAST_CHECK(OneL.ToString() != ArrayToString(ZeroArray,32));\n \n     // == and !=\n-    BOOST_CHECK(R1L != R2L);\n-    BOOST_CHECK(ZeroL != OneL);\n-    BOOST_CHECK(OneL != ZeroL);\n-    BOOST_CHECK(MaxL != ZeroL);\n-    BOOST_CHECK(~MaxL == ZeroL);\n-    BOOST_CHECK( ((R1L ^ R2L) ^ R1L) == R2L);\n+    FAST_CHECK(R1L != R2L);\n+    FAST_CHECK(ZeroL != OneL);\n+    FAST_CHECK(OneL != ZeroL);\n+    FAST_CHECK(MaxL != ZeroL);\n+    FAST_CHECK(~MaxL == ZeroL);\n+    FAST_CHECK( ((R1L ^ R2L) ^ R1L) == R2L);\n \n     uint64_t Tmp64 = 0xc4dab720d9c7acaaULL;\n     for (unsigned int i = 0; i < 256; ++i)\n     {\n-        BOOST_CHECK(ZeroL != (OneL << i));\n-        BOOST_CHECK((OneL << i) != ZeroL);\n-        BOOST_CHECK(R1L != (R1L ^ (OneL << i)));\n-        BOOST_CHECK(((arith_uint256(Tmp64) ^ (OneL << i) ) != Tmp64 ));\n+        FAST_CHECK(ZeroL != (OneL << i));\n+        FAST_CHECK((OneL << i) != ZeroL);\n+        FAST_CHECK(R1L != (R1L ^ (OneL << i)));\n+        FAST_CHECK(((arith_uint256(Tmp64) ^ (OneL << i) ) != Tmp64 ));\n     }\n-    BOOST_CHECK(ZeroL == (OneL << 256));\n+    FAST_CHECK(ZeroL == (OneL << 256));\n \n     // String Constructor and Copy Constructor\n-    BOOST_CHECK(arith_uint256(\"0x\"+R1L.ToString()) == R1L);\n-    BOOST_CHECK(arith_uint256(\"0x\"+R2L.ToString()) == R2L);\n-    BOOST_CHECK(arith_uint256(\"0x\"+ZeroL.ToString()) == ZeroL);\n-    BOOST_CHECK(arith_uint256(\"0x\"+OneL.ToString()) == OneL);\n-    BOOST_CHECK(arith_uint256(\"0x\"+MaxL.ToString()) == MaxL);\n-    BOOST_CHECK(arith_uint256(R1L.ToString()) == R1L);\n-    BOOST_CHECK(arith_uint256(\"   0x\"+R1L.ToString()+\"   \") == R1L);\n-    BOOST_CHECK(arith_uint256(\"\") == ZeroL);\n-    BOOST_CHECK(R1L == arith_uint256(R1ArrayHex));\n-    BOOST_CHECK(arith_uint256(R1L) == R1L);\n-    BOOST_CHECK((arith_uint256(R1L^R2L)^R2L) == R1L);\n-    BOOST_CHECK(arith_uint256(ZeroL) == ZeroL);\n-    BOOST_CHECK(arith_uint256(OneL) == OneL);\n+    FAST_CHECK(arith_uint256(\"0x\"+R1L.ToString()) == R1L);\n+    FAST_CHECK(arith_uint256(\"0x\"+R2L.ToString()) == R2L);\n+    FAST_CHECK(arith_uint256(\"0x\"+ZeroL.ToString()) == ZeroL);\n+    FAST_CHECK(arith_uint256(\"0x\"+OneL.ToString()) == OneL);\n+    FAST_CHECK(arith_uint256(\"0x\"+MaxL.ToString()) == MaxL);\n+    FAST_CHECK(arith_uint256(R1L.ToString()) == R1L);\n+    FAST_CHECK(arith_uint256(\"   0x\"+R1L.ToString()+\"   \") == R1L);\n+    FAST_CHECK(arith_uint256(\"\") == ZeroL);\n+    FAST_CHECK(R1L == arith_uint256(R1ArrayHex));\n+    FAST_CHECK(arith_uint256(R1L) == R1L);\n+    FAST_CHECK((arith_uint256(R1L^R2L)^R2L) == R1L);\n+    FAST_CHECK(arith_uint256(ZeroL) == ZeroL);\n+    FAST_CHECK(arith_uint256(OneL) == OneL);\n \n     // uint64_t constructor\n-    BOOST_CHECK( (R1L & arith_uint256(\"0xffffffffffffffff\")) == arith_uint256(R1LLow64));\n-    BOOST_CHECK(ZeroL == arith_uint256(0));\n-    BOOST_CHECK(OneL == arith_uint256(1));\n-    BOOST_CHECK(arith_uint256(\"0xffffffffffffffff\") = arith_uint256(0xffffffffffffffffULL));\n+    FAST_CHECK( (R1L & arith_uint256(\"0xffffffffffffffff\")) == arith_uint256(R1LLow64));\n+    FAST_CHECK(ZeroL == arith_uint256(0));\n+    FAST_CHECK(OneL == arith_uint256(1));\n+    FAST_CHECK(arith_uint256(\"0xffffffffffffffff\") = arith_uint256(0xffffffffffffffffULL));\n \n     // Assignment (from base_uint)\n-    arith_uint256 tmpL = ~ZeroL; BOOST_CHECK(tmpL == ~ZeroL);\n-    tmpL = ~OneL; BOOST_CHECK(tmpL == ~OneL);\n-    tmpL = ~R1L; BOOST_CHECK(tmpL == ~R1L);\n-    tmpL = ~R2L; BOOST_CHECK(tmpL == ~R2L);\n-    tmpL = ~MaxL; BOOST_CHECK(tmpL == ~MaxL);\n+    arith_uint256 tmpL = ~ZeroL; FAST_CHECK(tmpL == ~ZeroL);\n+    tmpL = ~OneL; FAST_CHECK(tmpL == ~OneL);\n+    tmpL = ~R1L; FAST_CHECK(tmpL == ~R1L);\n+    tmpL = ~R2L; FAST_CHECK(tmpL == ~R2L);\n+    tmpL = ~MaxL; FAST_CHECK(tmpL == ~MaxL);\n }\n \n void shiftArrayRight(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n@@ -159,73 +159,73 @@ BOOST_AUTO_TEST_CASE( shifts ) { // \"<<\"  \">>\"  \"<<=\"  \">>=\"\n     for (unsigned int i = 0; i < 256; ++i)\n     {\n         shiftArrayLeft(TmpArray, OneArray, 32, i);\n-        BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (OneL << i));\n+        FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (OneL << i));\n         TmpL = OneL; TmpL <<= i;\n-        BOOST_CHECK(TmpL == (OneL << i));\n-        BOOST_CHECK((HalfL >> (255-i)) == (OneL << i));\n+        FAST_CHECK(TmpL == (OneL << i));\n+        FAST_CHECK((HalfL >> (255-i)) == (OneL << i));\n         TmpL = HalfL; TmpL >>= (255-i);\n-        BOOST_CHECK(TmpL == (OneL << i));\n+        FAST_CHECK(TmpL == (OneL << i));\n \n         shiftArrayLeft(TmpArray, R1Array, 32, i);\n-        BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (R1L << i));\n+        FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (R1L << i));\n         TmpL = R1L; TmpL <<= i;\n-        BOOST_CHECK(TmpL == (R1L << i));\n+        FAST_CHECK(TmpL == (R1L << i));\n \n         shiftArrayRight(TmpArray, R1Array, 32, i);\n-        BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (R1L >> i));\n+        FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (R1L >> i));\n         TmpL = R1L; TmpL >>= i;\n-        BOOST_CHECK(TmpL == (R1L >> i));\n+        FAST_CHECK(TmpL == (R1L >> i));\n \n         shiftArrayLeft(TmpArray, MaxArray, 32, i);\n-        BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (MaxL << i));\n+        FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (MaxL << i));\n         TmpL = MaxL; TmpL <<= i;\n-        BOOST_CHECK(TmpL == (MaxL << i));\n+        FAST_CHECK(TmpL == (MaxL << i));\n \n         shiftArrayRight(TmpArray, MaxArray, 32, i);\n-        BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (MaxL >> i));\n+        FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (MaxL >> i));\n         TmpL = MaxL; TmpL >>= i;\n-        BOOST_CHECK(TmpL == (MaxL >> i));\n+        FAST_CHECK(TmpL == (MaxL >> i));\n     }\n     arith_uint256 c1L = arith_uint256(0x0123456789abcdefULL);\n     arith_uint256 c2L = c1L << 128;\n     for (unsigned int i = 0; i < 128; ++i) {\n-        BOOST_CHECK((c1L << i) == (c2L >> (128-i)));\n+        FAST_CHECK((c1L << i) == (c2L >> (128-i)));\n     }\n     for (unsigned int i = 128; i < 256; ++i) {\n-        BOOST_CHECK((c1L << i) == (c2L << (i-128)));\n+        FAST_CHECK((c1L << i) == (c2L << (i-128)));\n     }\n }\n \n BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n {\n-    BOOST_CHECK(!ZeroL);\n-    BOOST_CHECK(!(!OneL));\n+    FAST_CHECK(!ZeroL);\n+    FAST_CHECK(!(!OneL));\n     for (unsigned int i = 0; i < 256; ++i)\n-        BOOST_CHECK(!(!(OneL<<i)));\n-    BOOST_CHECK(!(!R1L));\n-    BOOST_CHECK(!(!MaxL));\n+        FAST_CHECK(!(!(OneL<<i)));\n+    FAST_CHECK(!(!R1L));\n+    FAST_CHECK(!(!MaxL));\n \n-    BOOST_CHECK(~ZeroL == MaxL);\n+    FAST_CHECK(~ZeroL == MaxL);\n \n     unsigned char TmpArray[32];\n     for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = ~R1Array[i]; }\n-    BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (~R1L));\n+    FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (~R1L));\n \n-    BOOST_CHECK(-ZeroL == ZeroL);\n-    BOOST_CHECK(-R1L == (~R1L)+1);\n+    FAST_CHECK(-ZeroL == ZeroL);\n+    FAST_CHECK(-R1L == (~R1L)+1);\n     for (unsigned int i = 0; i < 256; ++i)\n-        BOOST_CHECK(-(OneL<<i) == (MaxL << i));\n+        FAST_CHECK(-(OneL<<i) == (MaxL << i));\n }\n \n \n // Check if doing _A_ _OP_ _B_ results in the same as applying _OP_ onto each\n // element of Aarray and Barray, and then converting the result into a arith_uint256.\n #define CHECKBITWISEOPERATOR(_A_,_B_,_OP_)                              \\\n     for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i]; } \\\n-    BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (_A_##L _OP_ _B_##L));\n+    FAST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (_A_##L _OP_ _B_##L));\n \n #define CHECKASSIGNMENTOPERATOR(_A_,_B_,_OP_)                           \\\n-    TmpL = _A_##L; TmpL _OP_##= _B_##L; BOOST_CHECK(TmpL == (_A_##L _OP_ _B_##L));\n+    TmpL = _A_##L; TmpL _OP_##= _B_##L; FAST_CHECK(TmpL == (_A_##L _OP_ _B_##L));\n \n BOOST_AUTO_TEST_CASE( bitwiseOperators )\n {\n@@ -265,107 +265,107 @@ BOOST_AUTO_TEST_CASE( bitwiseOperators )\n     CHECKASSIGNMENTOPERATOR(Max,R1,&)\n \n     uint64_t Tmp64 = 0xe1db685c9a0b47a2ULL;\n-    TmpL = R1L; TmpL |= Tmp64;  BOOST_CHECK(TmpL == (R1L | arith_uint256(Tmp64)));\n-    TmpL = R1L; TmpL |= 0; BOOST_CHECK(TmpL == R1L);\n-    TmpL ^= 0; BOOST_CHECK(TmpL == R1L);\n-    TmpL ^= Tmp64;  BOOST_CHECK(TmpL == (R1L ^ arith_uint256(Tmp64)));\n+    TmpL = R1L; TmpL |= Tmp64;  FAST_CHECK(TmpL == (R1L | arith_uint256(Tmp64)));\n+    TmpL = R1L; TmpL |= 0; FAST_CHECK(TmpL == R1L);\n+    TmpL ^= 0; FAST_CHECK(TmpL == R1L);\n+    TmpL ^= Tmp64;  FAST_CHECK(TmpL == (R1L ^ arith_uint256(Tmp64)));\n }\n \n BOOST_AUTO_TEST_CASE( comparison ) // <= >= < >\n {\n     arith_uint256 TmpL;\n     for (unsigned int i = 0; i < 256; ++i) {\n         TmpL= OneL<< i;\n-        BOOST_CHECK( TmpL >= ZeroL && TmpL > ZeroL && ZeroL < TmpL && ZeroL <= TmpL);\n-        BOOST_CHECK( TmpL >= 0 && TmpL > 0 && 0 < TmpL && 0 <= TmpL);\n+        FAST_CHECK( TmpL >= ZeroL && TmpL > ZeroL && ZeroL < TmpL && ZeroL <= TmpL);\n+        FAST_CHECK( TmpL >= 0 && TmpL > 0 && 0 < TmpL && 0 <= TmpL);\n         TmpL |= R1L;\n-        BOOST_CHECK( TmpL >= R1L ); BOOST_CHECK( (TmpL == R1L) != (TmpL > R1L)); BOOST_CHECK( (TmpL == R1L) || !( TmpL <= R1L));\n-        BOOST_CHECK( R1L <= TmpL ); BOOST_CHECK( (R1L == TmpL) != (R1L < TmpL)); BOOST_CHECK( (TmpL == R1L) || !( R1L >= TmpL));\n-        BOOST_CHECK(! (TmpL < R1L)); BOOST_CHECK(! (R1L > TmpL));\n+        FAST_CHECK( TmpL >= R1L ); FAST_CHECK( (TmpL == R1L) != (TmpL > R1L)); FAST_CHECK( (TmpL == R1L) || !( TmpL <= R1L));\n+        FAST_CHECK( R1L <= TmpL ); FAST_CHECK( (R1L == TmpL) != (R1L < TmpL)); FAST_CHECK( (TmpL == R1L) || !( R1L >= TmpL));\n+        FAST_CHECK(! (TmpL < R1L)); FAST_CHECK(! (R1L > TmpL));\n     }\n }\n \n BOOST_AUTO_TEST_CASE( plusMinus )\n {\n     arith_uint256 TmpL = 0;\n-    BOOST_CHECK(R1L+R2L == arith_uint256(R1LplusR2L));\n+    FAST_CHECK(R1L+R2L == arith_uint256(R1LplusR2L));\n     TmpL += R1L;\n-    BOOST_CHECK(TmpL == R1L);\n+    FAST_CHECK(TmpL == R1L);\n     TmpL += R2L;\n-    BOOST_CHECK(TmpL == R1L + R2L);\n-    BOOST_CHECK(OneL+MaxL == ZeroL);\n-    BOOST_CHECK(MaxL+OneL == ZeroL);\n+    FAST_CHECK(TmpL == R1L + R2L);\n+    FAST_CHECK(OneL+MaxL == ZeroL);\n+    FAST_CHECK(MaxL+OneL == ZeroL);\n     for (unsigned int i = 1; i < 256; ++i) {\n-        BOOST_CHECK( (MaxL >> i) + OneL == (HalfL >> (i-1)) );\n-        BOOST_CHECK( OneL + (MaxL >> i) == (HalfL >> (i-1)) );\n+        FAST_CHECK( (MaxL >> i) + OneL == (HalfL >> (i-1)) );\n+        FAST_CHECK( OneL + (MaxL >> i) == (HalfL >> (i-1)) );\n         TmpL = (MaxL>>i); TmpL += OneL;\n-        BOOST_CHECK( TmpL == (HalfL >> (i-1)) );\n+        FAST_CHECK( TmpL == (HalfL >> (i-1)) );\n         TmpL = (MaxL>>i); TmpL += 1;\n-        BOOST_CHECK( TmpL == (HalfL >> (i-1)) );\n+        FAST_CHECK( TmpL == (HalfL >> (i-1)) );\n         TmpL = (MaxL>>i);\n-        BOOST_CHECK( TmpL++ == (MaxL>>i) );\n-        BOOST_CHECK( TmpL == (HalfL >> (i-1)));\n+        FAST_CHECK( TmpL++ == (MaxL>>i) );\n+        FAST_CHECK( TmpL == (HalfL >> (i-1)));\n     }\n-    BOOST_CHECK(arith_uint256(0xbedc77e27940a7ULL) + 0xee8d836fce66fbULL == arith_uint256(0xbedc77e27940a7ULL + 0xee8d836fce66fbULL));\n+    FAST_CHECK(arith_uint256(0xbedc77e27940a7ULL) + 0xee8d836fce66fbULL == arith_uint256(0xbedc77e27940a7ULL + 0xee8d836fce66fbULL));\n     TmpL = arith_uint256(0xbedc77e27940a7ULL); TmpL += 0xee8d836fce66fbULL;\n-    BOOST_CHECK(TmpL == arith_uint256(0xbedc77e27940a7ULL+0xee8d836fce66fbULL));\n-    TmpL -= 0xee8d836fce66fbULL;  BOOST_CHECK(TmpL == 0xbedc77e27940a7ULL);\n+    FAST_CHECK(TmpL == arith_uint256(0xbedc77e27940a7ULL+0xee8d836fce66fbULL));\n+    TmpL -= 0xee8d836fce66fbULL;  FAST_CHECK(TmpL == 0xbedc77e27940a7ULL);\n     TmpL = R1L;\n-    BOOST_CHECK(++TmpL == R1L+1);\n+    FAST_CHECK(++TmpL == R1L+1);\n \n-    BOOST_CHECK(R1L -(-R2L) == R1L+R2L);\n-    BOOST_CHECK(R1L -(-OneL) == R1L+OneL);\n-    BOOST_CHECK(R1L - OneL == R1L+(-OneL));\n+    FAST_CHECK(R1L -(-R2L) == R1L+R2L);\n+    FAST_CHECK(R1L -(-OneL) == R1L+OneL);\n+    FAST_CHECK(R1L - OneL == R1L+(-OneL));\n     for (unsigned int i = 1; i < 256; ++i) {\n-        BOOST_CHECK((MaxL>>i) - (-OneL)  == (HalfL >> (i-1)));\n-        BOOST_CHECK((HalfL >> (i-1)) - OneL == (MaxL>>i));\n+        FAST_CHECK((MaxL>>i) - (-OneL)  == (HalfL >> (i-1)));\n+        FAST_CHECK((HalfL >> (i-1)) - OneL == (MaxL>>i));\n         TmpL = (HalfL >> (i-1));\n-        BOOST_CHECK(TmpL-- == (HalfL >> (i-1)));\n-        BOOST_CHECK(TmpL == (MaxL >> i));\n+        FAST_CHECK(TmpL-- == (HalfL >> (i-1)));\n+        FAST_CHECK(TmpL == (MaxL >> i));\n         TmpL = (HalfL >> (i-1));\n-        BOOST_CHECK(--TmpL == (MaxL >> i));\n+        FAST_CHECK(--TmpL == (MaxL >> i));\n     }\n     TmpL = R1L;\n-    BOOST_CHECK(--TmpL == R1L-1);\n+    FAST_CHECK(--TmpL == R1L-1);\n }\n \n BOOST_AUTO_TEST_CASE( multiply )\n {\n-    BOOST_CHECK((R1L * R1L).ToString() == \"62a38c0486f01e45879d7910a7761bf30d5237e9873f9bff3642a732c4d84f10\");\n-    BOOST_CHECK((R1L * R2L).ToString() == \"de37805e9986996cfba76ff6ba51c008df851987d9dd323f0e5de07760529c40\");\n-    BOOST_CHECK((R1L * ZeroL) == ZeroL);\n-    BOOST_CHECK((R1L * OneL) == R1L);\n-    BOOST_CHECK((R1L * MaxL) == -R1L);\n-    BOOST_CHECK((R2L * R1L) == (R1L * R2L));\n-    BOOST_CHECK((R2L * R2L).ToString() == \"ac8c010096767d3cae5005dec28bb2b45a1d85ab7996ccd3e102a650f74ff100\");\n-    BOOST_CHECK((R2L * ZeroL) == ZeroL);\n-    BOOST_CHECK((R2L * OneL) == R2L);\n-    BOOST_CHECK((R2L * MaxL) == -R2L);\n-\n-    BOOST_CHECK(MaxL * MaxL == OneL);\n-\n-    BOOST_CHECK((R1L * 0) == 0);\n-    BOOST_CHECK((R1L * 1) == R1L);\n-    BOOST_CHECK((R1L * 3).ToString() == \"7759b1c0ed14047f961ad09b20ff83687876a0181a367b813634046f91def7d4\");\n-    BOOST_CHECK((R2L * 0x87654321UL).ToString() == \"23f7816e30c4ae2017257b7a0fa64d60402f5234d46e746b61c960d09a26d070\");\n+    FAST_CHECK((R1L * R1L).ToString() == \"62a38c0486f01e45879d7910a7761bf30d5237e9873f9bff3642a732c4d84f10\");\n+    FAST_CHECK((R1L * R2L).ToString() == \"de37805e9986996cfba76ff6ba51c008df851987d9dd323f0e5de07760529c40\");\n+    FAST_CHECK((R1L * ZeroL) == ZeroL);\n+    FAST_CHECK((R1L * OneL) == R1L);\n+    FAST_CHECK((R1L * MaxL) == -R1L);\n+    FAST_CHECK((R2L * R1L) == (R1L * R2L));\n+    FAST_CHECK((R2L * R2L).ToString() == \"ac8c010096767d3cae5005dec28bb2b45a1d85ab7996ccd3e102a650f74ff100\");\n+    FAST_CHECK((R2L * ZeroL) == ZeroL);\n+    FAST_CHECK((R2L * OneL) == R2L);\n+    FAST_CHECK((R2L * MaxL) == -R2L);\n+\n+    FAST_CHECK(MaxL * MaxL == OneL);\n+\n+    FAST_CHECK((R1L * 0) == 0);\n+    FAST_CHECK((R1L * 1) == R1L);\n+    FAST_CHECK((R1L * 3).ToString() == \"7759b1c0ed14047f961ad09b20ff83687876a0181a367b813634046f91def7d4\");\n+    FAST_CHECK((R2L * 0x87654321UL).ToString() == \"23f7816e30c4ae2017257b7a0fa64d60402f5234d46e746b61c960d09a26d070\");\n }\n \n BOOST_AUTO_TEST_CASE( divide )\n {\n     arith_uint256 D1L(\"AD7133AC1977FA2B7\");\n     arith_uint256 D2L(\"ECD751716\");\n-    BOOST_CHECK((R1L / D1L).ToString() == \"00000000000000000b8ac01106981635d9ed112290f8895545a7654dde28fb3a\");\n-    BOOST_CHECK((R1L / D2L).ToString() == \"000000000873ce8efec5b67150bad3aa8c5fcb70e947586153bf2cec7c37c57a\");\n-    BOOST_CHECK(R1L / OneL == R1L);\n-    BOOST_CHECK(R1L / MaxL == ZeroL);\n-    BOOST_CHECK(MaxL / R1L == 2);\n-    BOOST_CHECK_THROW(R1L / ZeroL, uint_error);\n-    BOOST_CHECK((R2L / D1L).ToString() == \"000000000000000013e1665895a1cc981de6d93670105a6b3ec3b73141b3a3c5\");\n-    BOOST_CHECK((R2L / D2L).ToString() == \"000000000e8f0abe753bb0afe2e9437ee85d280be60882cf0bd1aaf7fa3cc2c4\");\n-    BOOST_CHECK(R2L / OneL == R2L);\n-    BOOST_CHECK(R2L / MaxL == ZeroL);\n-    BOOST_CHECK(MaxL / R2L == 1);\n-    BOOST_CHECK_THROW(R2L / ZeroL, uint_error);\n+    FAST_CHECK((R1L / D1L).ToString() == \"00000000000000000b8ac01106981635d9ed112290f8895545a7654dde28fb3a\");\n+    FAST_CHECK((R1L / D2L).ToString() == \"000000000873ce8efec5b67150bad3aa8c5fcb70e947586153bf2cec7c37c57a\");\n+    FAST_CHECK(R1L / OneL == R1L);\n+    FAST_CHECK(R1L / MaxL == ZeroL);\n+    FAST_CHECK(MaxL / R1L == 2);\n+    FAST_CHECK_THROW(R1L / ZeroL, uint_error);\n+    FAST_CHECK((R2L / D1L).ToString() == \"000000000000000013e1665895a1cc981de6d93670105a6b3ec3b73141b3a3c5\");\n+    FAST_CHECK((R2L / D2L).ToString() == \"000000000e8f0abe753bb0afe2e9437ee85d280be60882cf0bd1aaf7fa3cc2c4\");\n+    FAST_CHECK(R2L / OneL == R2L);\n+    FAST_CHECK(R2L / MaxL == ZeroL);\n+    FAST_CHECK(MaxL / R2L == 1);\n+    FAST_CHECK_THROW(R2L / ZeroL, uint_error);\n }\n \n \n@@ -376,36 +376,36 @@ bool almostEqual(double d1, double d2)\n \n BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex size() GetLow64 GetSerializeSize, Serialize, Unserialize\n {\n-    BOOST_CHECK(R1L.GetHex() == R1L.ToString());\n-    BOOST_CHECK(R2L.GetHex() == R2L.ToString());\n-    BOOST_CHECK(OneL.GetHex() == OneL.ToString());\n-    BOOST_CHECK(MaxL.GetHex() == MaxL.ToString());\n+    FAST_CHECK(R1L.GetHex() == R1L.ToString());\n+    FAST_CHECK(R2L.GetHex() == R2L.ToString());\n+    FAST_CHECK(OneL.GetHex() == OneL.ToString());\n+    FAST_CHECK(MaxL.GetHex() == MaxL.ToString());\n     arith_uint256 TmpL(R1L);\n-    BOOST_CHECK(TmpL == R1L);\n-    TmpL.SetHex(R2L.ToString());   BOOST_CHECK(TmpL == R2L);\n-    TmpL.SetHex(ZeroL.ToString()); BOOST_CHECK(TmpL == 0);\n-    TmpL.SetHex(HalfL.ToString()); BOOST_CHECK(TmpL == HalfL);\n+    FAST_CHECK(TmpL == R1L);\n+    TmpL.SetHex(R2L.ToString());   FAST_CHECK(TmpL == R2L);\n+    TmpL.SetHex(ZeroL.ToString()); FAST_CHECK(TmpL == 0);\n+    TmpL.SetHex(HalfL.ToString()); FAST_CHECK(TmpL == HalfL);\n \n     TmpL.SetHex(R1L.ToString());\n-    BOOST_CHECK(R1L.size() == 32);\n-    BOOST_CHECK(R2L.size() == 32);\n-    BOOST_CHECK(ZeroL.size() == 32);\n-    BOOST_CHECK(MaxL.size() == 32);\n-    BOOST_CHECK(R1L.GetLow64()  == R1LLow64);\n-    BOOST_CHECK(HalfL.GetLow64() ==0x0000000000000000ULL);\n-    BOOST_CHECK(OneL.GetLow64() ==0x0000000000000001ULL);\n+    FAST_CHECK(R1L.size() == 32);\n+    FAST_CHECK(R2L.size() == 32);\n+    FAST_CHECK(ZeroL.size() == 32);\n+    FAST_CHECK(MaxL.size() == 32);\n+    FAST_CHECK(R1L.GetLow64()  == R1LLow64);\n+    FAST_CHECK(HalfL.GetLow64() ==0x0000000000000000ULL);\n+    FAST_CHECK(OneL.GetLow64() ==0x0000000000000001ULL);\n \n     for (unsigned int i = 0; i < 255; ++i)\n     {\n-        BOOST_CHECK((OneL << i).getdouble() == ldexp(1.0,i));\n+        FAST_CHECK((OneL << i).getdouble() == ldexp(1.0,i));\n     }\n-    BOOST_CHECK(ZeroL.getdouble() == 0.0);\n+    FAST_CHECK(ZeroL.getdouble() == 0.0);\n     for (int i = 256; i > 53; --i)\n-        BOOST_CHECK(almostEqual((R1L>>(256-i)).getdouble(), ldexp(R1Ldouble,i)));\n+        FAST_CHECK(almostEqual((R1L>>(256-i)).getdouble(), ldexp(R1Ldouble,i)));\n     uint64_t R1L64part = (R1L>>192).GetLow64();\n     for (int i = 53; i > 0; --i) // doubles can store all integers in {0,...,2^54-1} exactly\n     {\n-        BOOST_CHECK((R1L>>(256-i)).getdouble() == (double)(R1L64part >> (64-i)));\n+        FAST_CHECK((R1L>>(256-i)).getdouble() == (double)(R1L64part >> (64-i)));\n     }\n }\n \n@@ -415,146 +415,146 @@ BOOST_AUTO_TEST_CASE(bignum_SetCompact)\n     bool fNegative;\n     bool fOverflow;\n     num.SetCompact(0, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x00123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x01003456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x02000056, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x03000000, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x04000000, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x00923456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x01803456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x02800056, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x03800000, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x04800000, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x01123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000012\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x01120000U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000000012\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x01120000U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     // Make sure that we don't generate compacts with the 0x00800000 bit set\n     num = 0x80;\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x02008000U);\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x02008000U);\n \n     num.SetCompact(0x01fedcba, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"000000000000000000000000000000000000000000000000000000000000007e\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(true), 0x01fe0000U);\n-    BOOST_CHECK_EQUAL(fNegative, true);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"000000000000000000000000000000000000000000000000000000000000007e\");\n+    FAST_CHECK_EQUAL(num.GetCompact(true), 0x01fe0000U);\n+    FAST_CHECK_EQUAL(fNegative, true);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x02123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000001234\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x02123400U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000001234\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x02123400U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x03123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000123456\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x03123456U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000000123456\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x03123456U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x04123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000012345600\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x04123456U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000012345600\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x04123456U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x04923456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000012345600\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(true), 0x04923456U);\n-    BOOST_CHECK_EQUAL(fNegative, true);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000012345600\");\n+    FAST_CHECK_EQUAL(num.GetCompact(true), 0x04923456U);\n+    FAST_CHECK_EQUAL(fNegative, true);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x05009234, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000092340000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x05009234U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"0000000000000000000000000000000000000000000000000000000092340000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x05009234U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0x20123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(num.GetHex(), \"1234560000000000000000000000000000000000000000000000000000000000\");\n-    BOOST_CHECK_EQUAL(num.GetCompact(), 0x20123456U);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, false);\n+    FAST_CHECK_EQUAL(num.GetHex(), \"1234560000000000000000000000000000000000000000000000000000000000\");\n+    FAST_CHECK_EQUAL(num.GetCompact(), 0x20123456U);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, false);\n \n     num.SetCompact(0xff123456, &fNegative, &fOverflow);\n-    BOOST_CHECK_EQUAL(fNegative, false);\n-    BOOST_CHECK_EQUAL(fOverflow, true);\n+    FAST_CHECK_EQUAL(fNegative, false);\n+    FAST_CHECK_EQUAL(fOverflow, true);\n }\n \n \n BOOST_AUTO_TEST_CASE( getmaxcoverage ) // some more tests just to get 100% coverage\n {\n     // ~R1L give a base_uint<256>\n-    BOOST_CHECK((~~R1L >> 10) == (R1L >> 10));\n-    BOOST_CHECK((~~R1L << 10) == (R1L << 10));\n-    BOOST_CHECK(!(~~R1L < R1L));\n-    BOOST_CHECK(~~R1L <= R1L);\n-    BOOST_CHECK(!(~~R1L > R1L));\n-    BOOST_CHECK(~~R1L >= R1L);\n-    BOOST_CHECK(!(R1L < ~~R1L));\n-    BOOST_CHECK(R1L <= ~~R1L);\n-    BOOST_CHECK(!(R1L > ~~R1L));\n-    BOOST_CHECK(R1L >= ~~R1L);\n-\n-    BOOST_CHECK(~~R1L + R2L == R1L + ~~R2L);\n-    BOOST_CHECK(~~R1L - R2L == R1L - ~~R2L);\n-    BOOST_CHECK(~R1L != R1L); BOOST_CHECK(R1L != ~R1L);\n+    FAST_CHECK((~~R1L >> 10) == (R1L >> 10));\n+    FAST_CHECK((~~R1L << 10) == (R1L << 10));\n+    FAST_CHECK(!(~~R1L < R1L));\n+    FAST_CHECK(~~R1L <= R1L);\n+    FAST_CHECK(!(~~R1L > R1L));\n+    FAST_CHECK(~~R1L >= R1L);\n+    FAST_CHECK(!(R1L < ~~R1L));\n+    FAST_CHECK(R1L <= ~~R1L);\n+    FAST_CHECK(!(R1L > ~~R1L));\n+    FAST_CHECK(R1L >= ~~R1L);\n+\n+    FAST_CHECK(~~R1L + R2L == R1L + ~~R2L);\n+    FAST_CHECK(~~R1L - R2L == R1L - ~~R2L);\n+    FAST_CHECK(~R1L != R1L); FAST_CHECK(R1L != ~R1L);\n     unsigned char TmpArray[32];\n     CHECKBITWISEOPERATOR(~R1,R2,|)\n     CHECKBITWISEOPERATOR(~R1,R2,^)"
      },
      {
        "sha": "c43d034b259ff3bd0a1d34d41e8604adf3f59395",
        "filename": "src/test/base32_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/base32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/base32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base32_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -16,9 +16,9 @@ BOOST_AUTO_TEST_CASE(base32_testvectors)\n     for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n     {\n         std::string strEnc = EncodeBase32(vstrIn[i]);\n-        BOOST_CHECK(strEnc == vstrOut[i]);\n+        FAST_CHECK(strEnc == vstrOut[i]);\n         std::string strDec = DecodeBase32(vstrOut[i]);\n-        BOOST_CHECK(strDec == vstrIn[i]);\n+        FAST_CHECK(strDec == vstrIn[i]);\n     }\n }\n "
      },
      {
        "sha": "fb4be2e1450f17128af156b6597f705cfadf77d0",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -64,13 +64,13 @@ BOOST_AUTO_TEST_CASE(base58_DecodeBase58)\n         BOOST_CHECK_MESSAGE(result.size() == expected.size() && std::equal(result.begin(), result.end(), expected.begin()), strTest);\n     }\n \n-    BOOST_CHECK(!DecodeBase58(\"invalid\", result));\n+    FAST_CHECK(!DecodeBase58(\"invalid\", result));\n \n     // check that DecodeBase58 skips whitespace, but still fails with unexpected non-whitespace at the end.\n-    BOOST_CHECK(!DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t a\", result));\n-    BOOST_CHECK( DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t \", result));\n+    FAST_CHECK(!DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t a\", result));\n+    FAST_CHECK( DecodeBase58(\" \\t\\n\\v\\f\\r skip \\r\\f\\v\\n\\t \", result));\n     std::vector<unsigned char> expected = ParseHex(\"971a55\");\n-    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n+    FAST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n }\n \n // Visitor to check address type\n@@ -236,7 +236,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n     // Visiting a CNoDestination must fail\n     CBitcoinAddress dummyAddr;\n     CTxDestination nodest = CNoDestination();\n-    BOOST_CHECK(!dummyAddr.Set(nodest));\n+    FAST_CHECK(!dummyAddr.Set(nodest));\n \n     SelectParams(CBaseChainParams::MAIN);\n }"
      },
      {
        "sha": "6d50f101e145953565053cfb08c3836d3c2ef559",
        "filename": "src/test/base64_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/base64_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/base64_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base64_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -16,9 +16,9 @@ BOOST_AUTO_TEST_CASE(base64_testvectors)\n     for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n     {\n         std::string strEnc = EncodeBase64(vstrIn[i]);\n-        BOOST_CHECK(strEnc == vstrOut[i]);\n+        FAST_CHECK(strEnc == vstrOut[i]);\n         std::string strDec = DecodeBase64(strEnc);\n-        BOOST_CHECK(strDec == vstrIn[i]);\n+        FAST_CHECK(strDec == vstrIn[i]);\n     }\n }\n "
      },
      {
        "sha": "cdb2e3b538cc4a723a819cd235489c839b63a553",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -91,48 +91,48 @@ void RunTest(const TestVector &test) {\n \n         // Test private key\n         CBitcoinExtKey b58key; b58key.SetKey(key);\n-        BOOST_CHECK(b58key.ToString() == derive.prv);\n+        FAST_CHECK(b58key.ToString() == derive.prv);\n \n         CBitcoinExtKey b58keyDecodeCheck(derive.prv);\n         CExtKey checkKey = b58keyDecodeCheck.GetKey();\n         assert(checkKey == key); //ensure a base58 decoded key also matches\n \n         // Test public key\n         CBitcoinExtPubKey b58pubkey; b58pubkey.SetKey(pubkey);\n-        BOOST_CHECK(b58pubkey.ToString() == derive.pub);\n+        FAST_CHECK(b58pubkey.ToString() == derive.pub);\n \n         CBitcoinExtPubKey b58PubkeyDecodeCheck(derive.pub);\n         CExtPubKey checkPubKey = b58PubkeyDecodeCheck.GetKey();\n         assert(checkPubKey == pubkey); //ensure a base58 decoded pubkey also matches\n \n         // Derive new keys\n         CExtKey keyNew;\n-        BOOST_CHECK(key.Derive(keyNew, derive.nChild));\n+        FAST_CHECK(key.Derive(keyNew, derive.nChild));\n         CExtPubKey pubkeyNew = keyNew.Neuter();\n         if (!(derive.nChild & 0x80000000)) {\n             // Compare with public derivation\n             CExtPubKey pubkeyNew2;\n-            BOOST_CHECK(pubkey.Derive(pubkeyNew2, derive.nChild));\n-            BOOST_CHECK(pubkeyNew == pubkeyNew2);\n+            FAST_CHECK(pubkey.Derive(pubkeyNew2, derive.nChild));\n+            FAST_CHECK(pubkeyNew == pubkeyNew2);\n         }\n         key = keyNew;\n         pubkey = pubkeyNew;\n \n         CDataStream ssPub(SER_DISK, CLIENT_VERSION);\n         ssPub << pubkeyNew;\n-        BOOST_CHECK(ssPub.size() == 75);\n+        FAST_CHECK(ssPub.size() == 75);\n \n         CDataStream ssPriv(SER_DISK, CLIENT_VERSION);\n         ssPriv << keyNew;\n-        BOOST_CHECK(ssPriv.size() == 75);\n+        FAST_CHECK(ssPriv.size() == 75);\n \n         CExtPubKey pubCheck;\n         CExtKey privCheck;\n         ssPub >> pubCheck;\n         ssPriv >> privCheck;\n \n-        BOOST_CHECK(pubCheck == pubkeyNew);\n-        BOOST_CHECK(privCheck == keyNew);\n+        FAST_CHECK(pubCheck == pubkeyNew);\n+        FAST_CHECK(privCheck == keyNew);\n     }\n }\n "
      },
      {
        "sha": "845aceb310fb678e161bff8b0a2bbc8bdd77baf2",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 51,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -60,7 +60,7 @@ BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n     CBlock block(BuildBlockTestCase());\n \n     pool.addUnchecked(block.vtx[2].GetHash(), entry.FromTx(block.vtx[2]));\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n \n     // Do a simple ShortTxIDs RT\n     {\n@@ -73,32 +73,32 @@ BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n         stream >> shortIDs2;\n \n         PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n-        BOOST_CHECK( partialBlock.IsTxAvailable(0));\n-        BOOST_CHECK(!partialBlock.IsTxAvailable(1));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n+        FAST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        FAST_CHECK( partialBlock.IsTxAvailable(0));\n+        FAST_CHECK(!partialBlock.IsTxAvailable(1));\n+        FAST_CHECK( partialBlock.IsTxAvailable(2));\n \n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+        FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n \n         std::list<CTransaction> removed;\n         pool.removeRecursive(block.vtx[2], removed);\n-        BOOST_CHECK_EQUAL(removed.size(), 1);\n+        FAST_CHECK_EQUAL(removed.size(), 1);\n \n         CBlock block2;\n         std::vector<CTransaction> vtx_missing;\n-        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_INVALID); // No transactions\n+        FAST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_INVALID); // No transactions\n \n         vtx_missing.push_back(block.vtx[2]); // Wrong transaction\n         partialBlock.FillBlock(block2, vtx_missing); // Current implementation doesn't check txn here, but don't require that\n         bool mutated;\n-        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n+        FAST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n \n         vtx_missing[0] = block.vtx[1];\n         CBlock block3;\n-        BOOST_CHECK(partialBlock.FillBlock(block3, vtx_missing) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n+        FAST_CHECK(partialBlock.FillBlock(block3, vtx_missing) == READ_STATUS_OK);\n+        FAST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n+        FAST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n+        FAST_CHECK(!mutated);\n     }\n }\n \n@@ -153,7 +153,7 @@ BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n     CBlock block(BuildBlockTestCase());\n \n     pool.addUnchecked(block.vtx[2].GetHash(), entry.FromTx(block.vtx[2]));\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n \n     // Test with pre-forwarding tx 1, but not coinbase\n     {\n@@ -171,32 +171,32 @@ BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n         stream >> shortIDs2;\n \n         PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n-        BOOST_CHECK(!partialBlock.IsTxAvailable(0));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(1));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n+        FAST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        FAST_CHECK(!partialBlock.IsTxAvailable(0));\n+        FAST_CHECK( partialBlock.IsTxAvailable(1));\n+        FAST_CHECK( partialBlock.IsTxAvailable(2));\n \n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+        FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n \n         CBlock block2;\n         std::vector<CTransaction> vtx_missing;\n-        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_INVALID); // No transactions\n+        FAST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_INVALID); // No transactions\n \n         vtx_missing.push_back(block.vtx[1]); // Wrong transaction\n         partialBlock.FillBlock(block2, vtx_missing); // Current implementation doesn't check txn here, but don't require that\n         bool mutated;\n-        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n+        FAST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n \n         vtx_missing[0] = block.vtx[0];\n         CBlock block3;\n-        BOOST_CHECK(partialBlock.FillBlock(block3, vtx_missing) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n+        FAST_CHECK(partialBlock.FillBlock(block3, vtx_missing) == READ_STATUS_OK);\n+        FAST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n+        FAST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n+        FAST_CHECK(!mutated);\n \n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+        FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n     }\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n }\n \n BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n@@ -206,7 +206,7 @@ BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n     CBlock block(BuildBlockTestCase());\n \n     pool.addUnchecked(block.vtx[1].GetHash(), entry.FromTx(block.vtx[1]));\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n \n     // Test with pre-forwarding coinbase + tx 2 with tx 1 in mempool\n     {\n@@ -224,24 +224,24 @@ BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n         stream >> shortIDs2;\n \n         PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n-        BOOST_CHECK( partialBlock.IsTxAvailable(0));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(1));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n+        FAST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        FAST_CHECK( partialBlock.IsTxAvailable(0));\n+        FAST_CHECK( partialBlock.IsTxAvailable(1));\n+        FAST_CHECK( partialBlock.IsTxAvailable(2));\n \n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+        FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n \n         CBlock block2;\n         std::vector<CTransaction> vtx_missing;\n-        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n+        FAST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n+        FAST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n         bool mutated;\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n+        FAST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n+        FAST_CHECK(!mutated);\n \n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+        FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n     }\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    FAST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n }\n \n BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n@@ -276,16 +276,16 @@ BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n         stream >> shortIDs2;\n \n         PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n-        BOOST_CHECK(partialBlock.IsTxAvailable(0));\n+        FAST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        FAST_CHECK(partialBlock.IsTxAvailable(0));\n \n         CBlock block2;\n         std::vector<CTransaction> vtx_missing;\n-        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n+        FAST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n+        FAST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n         bool mutated;\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n+        FAST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n+        FAST_CHECK(!mutated);\n     }\n }\n \n@@ -304,12 +304,12 @@ BOOST_AUTO_TEST_CASE(TransactionsRequestSerializationTest) {\n     BlockTransactionsRequest req2;\n     stream >> req2;\n \n-    BOOST_CHECK_EQUAL(req1.blockhash.ToString(), req2.blockhash.ToString());\n-    BOOST_CHECK_EQUAL(req1.indexes.size(), req2.indexes.size());\n-    BOOST_CHECK_EQUAL(req1.indexes[0], req2.indexes[0]);\n-    BOOST_CHECK_EQUAL(req1.indexes[1], req2.indexes[1]);\n-    BOOST_CHECK_EQUAL(req1.indexes[2], req2.indexes[2]);\n-    BOOST_CHECK_EQUAL(req1.indexes[3], req2.indexes[3]);\n+    FAST_CHECK_EQUAL(req1.blockhash.ToString(), req2.blockhash.ToString());\n+    FAST_CHECK_EQUAL(req1.indexes.size(), req2.indexes.size());\n+    FAST_CHECK_EQUAL(req1.indexes[0], req2.indexes[0]);\n+    FAST_CHECK_EQUAL(req1.indexes[1], req2.indexes[1]);\n+    FAST_CHECK_EQUAL(req1.indexes[2], req2.indexes[2]);\n+    FAST_CHECK_EQUAL(req1.indexes[3], req2.indexes[3]);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "477a2e682d6693f2a7a38dad468720745c84135f",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 94,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -49,7 +49,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n+    FAST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n \n     BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n     filter.clear();\n@@ -81,14 +81,14 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n+    FAST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n }\n \n BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n {\n     string strSecret = string(\"5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C\");\n     CBitcoinSecret vchSecret;\n-    BOOST_CHECK(vchSecret.SetString(strSecret));\n+    FAST_CHECK(vchSecret.SetString(strSecret));\n \n     CKey key = vchSecret.GetKey();\n     CPubKey pubkey = key.GetPubKey();\n@@ -108,7 +108,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n+    FAST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n }\n \n BOOST_AUTO_TEST_CASE(bloom_match)\n@@ -195,37 +195,37 @@ BOOST_AUTO_TEST_CASE(merkle_block_1)\n     filter.insert(uint256S(\"0x74d681e0e03bafa802c8aa084379aa98d9fcd632ddc2ed9782b586ec87451f20\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n     pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x74d681e0e03bafa802c8aa084379aa98d9fcd632ddc2ed9782b586ec87451f20\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 8);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x74d681e0e03bafa802c8aa084379aa98d9fcd632ddc2ed9782b586ec87451f20\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 8);\n \n     vector<uint256> vMatched;\n     vector<unsigned int> vIndex;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n \n     // Also match the 8th transaction\n     filter.insert(uint256S(\"0xdd1fd2a6fc16404faf339881a90adbde7f4f728691ac62e8f168809cdfae1053\"));\n     merkleBlock = CMerkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 2);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 2);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[1] == pair);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[1] == pair);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xdd1fd2a6fc16404faf339881a90adbde7f4f728691ac62e8f168809cdfae1053\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 7);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xdd1fd2a6fc16404faf339881a90adbde7f4f728691ac62e8f168809cdfae1053\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 7);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_2)\n@@ -241,46 +241,46 @@ BOOST_AUTO_TEST_CASE(merkle_block_2)\n     filter.insert(uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n     pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n     vector<uint256> vMatched;\n     vector<unsigned int> vIndex;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n \n     // Match an output from the second transaction (the pubkey for address 1DZTzaBHUDM7T3QvUKBz4qXMRpkg8jsfB5)\n     // This should match the third transaction because it spends the output matched\n     // It also matches the fourth transaction, which spends to the pubkey again\n     filter.insert(ParseHex(\"044a656f065871a353f216ca26cef8dde2f03e8c16202d2e8ad769f02032cb86a5eb5e56842e92e19141d60a01928f8dd2c875a390f67c1f6c94cfc617c0ea45af\"));\n \n     merkleBlock = CMerkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 4);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 4);\n \n-    BOOST_CHECK(pair == merkleBlock.vMatchedTxn[0]);\n+    FAST_CHECK(pair == merkleBlock.vMatchedTxn[0]);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[1].second == uint256S(\"0x28204cad1d7fc1d199e8ef4fa22f182de6258a3eaafe1bbe56ebdcacd3069a5f\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[1].first == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[1].second == uint256S(\"0x28204cad1d7fc1d199e8ef4fa22f182de6258a3eaafe1bbe56ebdcacd3069a5f\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[1].first == 1);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[2].second == uint256S(\"0x6b0f8a73a56c04b519f1883e8aafda643ba61a30bd1439969df21bea5f4e27e2\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[2].first == 2);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[2].second == uint256S(\"0x6b0f8a73a56c04b519f1883e8aafda643ba61a30bd1439969df21bea5f4e27e2\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[2].first == 2);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[3].second == uint256S(\"0x3c1d7e82342158e4109df2e0b6348b6e84e403d8b4046d7007663ace63cddb23\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[3].first == 3);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[3].second == uint256S(\"0x3c1d7e82342158e4109df2e0b6348b6e84e403d8b4046d7007663ace63cddb23\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[3].first == 3);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_2_with_update_none)\n@@ -296,43 +296,43 @@ BOOST_AUTO_TEST_CASE(merkle_block_2_with_update_none)\n     filter.insert(uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n     pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n     vector<uint256> vMatched;\n     vector<unsigned int> vIndex;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n \n     // Match an output from the second transaction (the pubkey for address 1DZTzaBHUDM7T3QvUKBz4qXMRpkg8jsfB5)\n     // This should not match the third transaction though it spends the output matched\n     // It will match the fourth transaction, which has another pay-to-pubkey output to the same address\n     filter.insert(ParseHex(\"044a656f065871a353f216ca26cef8dde2f03e8c16202d2e8ad769f02032cb86a5eb5e56842e92e19141d60a01928f8dd2c875a390f67c1f6c94cfc617c0ea45af\"));\n \n     merkleBlock = CMerkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 3);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 3);\n \n-    BOOST_CHECK(pair == merkleBlock.vMatchedTxn[0]);\n+    FAST_CHECK(pair == merkleBlock.vMatchedTxn[0]);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[1].second == uint256S(\"0x28204cad1d7fc1d199e8ef4fa22f182de6258a3eaafe1bbe56ebdcacd3069a5f\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[1].first == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[1].second == uint256S(\"0x28204cad1d7fc1d199e8ef4fa22f182de6258a3eaafe1bbe56ebdcacd3069a5f\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[1].first == 1);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[2].second == uint256S(\"0x3c1d7e82342158e4109df2e0b6348b6e84e403d8b4046d7007663ace63cddb23\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[2].first == 3);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[2].second == uint256S(\"0x3c1d7e82342158e4109df2e0b6348b6e84e403d8b4046d7007663ace63cddb23\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[2].first == 3);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n@@ -348,19 +348,19 @@ BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n     filter.insert(uint256S(\"0x63194f18be0af63f2c6bc9dc0f777cbefed3d9415c4af83f3ee3a3d669c00cb5\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x63194f18be0af63f2c6bc9dc0f777cbefed3d9415c4af83f3ee3a3d669c00cb5\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x63194f18be0af63f2c6bc9dc0f777cbefed3d9415c4af83f3ee3a3d669c00cb5\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n     vector<uint256> vMatched;\n     vector<unsigned int> vIndex;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n \n     CDataStream merkleStream(SER_NETWORK, PROTOCOL_VERSION);\n     merkleStream << merkleBlock;\n@@ -371,7 +371,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(expected.begin(), expected.end(), merkleStream.begin(), merkleStream.end());\n+    FAST_CHECK_EQUAL_COLLECTIONS(expected.begin(), expected.end(), merkleStream.begin(), merkleStream.end());\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_4)\n@@ -387,37 +387,37 @@ BOOST_AUTO_TEST_CASE(merkle_block_4)\n     filter.insert(uint256S(\"0x0a2a92f0bda4727d0a13eaddf4dd9ac6b5c61a1429e6b2b818f19b15df0ac154\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n     pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x0a2a92f0bda4727d0a13eaddf4dd9ac6b5c61a1429e6b2b818f19b15df0ac154\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 6);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x0a2a92f0bda4727d0a13eaddf4dd9ac6b5c61a1429e6b2b818f19b15df0ac154\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 6);\n \n     vector<uint256> vMatched;\n     vector<unsigned int> vIndex;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n \n     // Also match the 4th transaction\n     filter.insert(uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"));\n     merkleBlock = CMerkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 2);\n+    FAST_CHECK(merkleBlock.vMatchedTxn.size() == 2);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"));\n-    BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 3);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"));\n+    FAST_CHECK(merkleBlock.vMatchedTxn[0].first == 3);\n \n-    BOOST_CHECK(merkleBlock.vMatchedTxn[1] == pair);\n+    FAST_CHECK(merkleBlock.vMatchedTxn[1] == pair);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n-    BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n+    FAST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n+    FAST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n-        BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n+        FAST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_4_test_p2pubkey_only)\n@@ -435,12 +435,12 @@ BOOST_AUTO_TEST_CASE(merkle_block_4_test_p2pubkey_only)\n     filter.insert(ParseHex(\"b6efd80d99179f4f4ff6f4dd0a007d018c385d21\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n     // We should match the generation outpoint\n-    BOOST_CHECK(filter.contains(COutPoint(uint256S(\"0x147caa76786596590baa4e98f5d9f48b86c7765e489f7a6ff3360fe5c674360b\"), 0)));\n+    FAST_CHECK(filter.contains(COutPoint(uint256S(\"0x147caa76786596590baa4e98f5d9f48b86c7765e489f7a6ff3360fe5c674360b\"), 0)));\n     // ... but not the 4th transaction's output (its not pay-2-pubkey)\n-    BOOST_CHECK(!filter.contains(COutPoint(uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"), 0)));\n+    FAST_CHECK(!filter.contains(COutPoint(uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"), 0)));\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_4_test_update_none)\n@@ -458,11 +458,11 @@ BOOST_AUTO_TEST_CASE(merkle_block_4_test_update_none)\n     filter.insert(ParseHex(\"b6efd80d99179f4f4ff6f4dd0a007d018c385d21\"));\n \n     CMerkleBlock merkleBlock(block, filter);\n-    BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n+    FAST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n     // We shouldn't match any outpoints (UPDATE_NONE)\n-    BOOST_CHECK(!filter.contains(COutPoint(uint256S(\"0x147caa76786596590baa4e98f5d9f48b86c7765e489f7a6ff3360fe5c674360b\"), 0)));\n-    BOOST_CHECK(!filter.contains(COutPoint(uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"), 0)));\n+    FAST_CHECK(!filter.contains(COutPoint(uint256S(\"0x147caa76786596590baa4e98f5d9f48b86c7765e489f7a6ff3360fe5c674360b\"), 0)));\n+    FAST_CHECK(!filter.contains(COutPoint(uint256S(\"0x02981fa052f0481dbc5868f4fc2166035a10f27a03cfd2de67326471df5bc041\"), 0)));\n }\n \n static std::vector<unsigned char> RandomData()\n@@ -485,7 +485,7 @@ BOOST_AUTO_TEST_CASE(rolling_bloom)\n     }\n     // Last 100 guaranteed to be remembered:\n     for (int i = 299; i < DATASIZE; i++) {\n-        BOOST_CHECK(rb1.contains(data[i]));\n+        FAST_CHECK(rb1.contains(data[i]));\n     }\n \n     // false positive rate is 1%, so we should get about 100 hits if\n@@ -501,27 +501,27 @@ BOOST_AUTO_TEST_CASE(rolling_bloom)\n     BOOST_TEST_MESSAGE(\"RollingBloomFilter got \" << nHits << \" false positives (~100 expected)\");\n \n     // Insanely unlikely to get a fp count outside this range:\n-    BOOST_CHECK(nHits > 25);\n-    BOOST_CHECK(nHits < 175);\n+    FAST_CHECK(nHits > 25);\n+    FAST_CHECK(nHits < 175);\n \n-    BOOST_CHECK(rb1.contains(data[DATASIZE-1]));\n+    FAST_CHECK(rb1.contains(data[DATASIZE-1]));\n     rb1.reset();\n-    BOOST_CHECK(!rb1.contains(data[DATASIZE-1]));\n+    FAST_CHECK(!rb1.contains(data[DATASIZE-1]));\n \n     // Now roll through data, make sure last 100 entries\n     // are always remembered:\n     for (int i = 0; i < DATASIZE; i++) {\n         if (i >= 100)\n-            BOOST_CHECK(rb1.contains(data[i-100]));\n+            FAST_CHECK(rb1.contains(data[i-100]));\n         rb1.insert(data[i]);\n-        BOOST_CHECK(rb1.contains(data[i]));\n+        FAST_CHECK(rb1.contains(data[i]));\n     }\n \n     // Insert 999 more random entries:\n     for (int i = 0; i < 999; i++) {\n         std::vector<unsigned char> d = RandomData();\n         rb1.insert(d);\n-        BOOST_CHECK(rb1.contains(d));\n+        FAST_CHECK(rb1.contains(d));\n     }\n     // Sanity check to make sure the filter isn't just filling up:\n     nHits = 0;\n@@ -532,7 +532,7 @@ BOOST_AUTO_TEST_CASE(rolling_bloom)\n     // Expect about 5 false positives, more than 100 means\n     // something is definitely broken.\n     BOOST_TEST_MESSAGE(\"RollingBloomFilter got \" << nHits << \" false positives (~5 expected)\");\n-    BOOST_CHECK(nHits < 100);\n+    FAST_CHECK(nHits < 100);\n \n     // last-1000-entry, 0.01% false positive:\n     CRollingBloomFilter rb2(1000, 0.001);\n@@ -541,7 +541,7 @@ BOOST_AUTO_TEST_CASE(rolling_bloom)\n     }\n     // ... room for all of them:\n     for (int i = 0; i < DATASIZE; i++) {\n-        BOOST_CHECK(rb2.contains(data[i]));\n+        FAST_CHECK(rb2.contains(data[i]));\n     }\n }\n "
      },
      {
        "sha": "622da034b0629de030de6fa2feb02a6094410fa1",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 40,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -77,7 +77,7 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n         for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n             ret += it->second.coins.DynamicMemoryUsage();\n         }\n-        BOOST_CHECK_EQUAL(DynamicMemoryUsage(), ret);\n+        FAST_CHECK_EQUAL(DynamicMemoryUsage(), ret);\n     }\n \n };\n@@ -129,7 +129,7 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n             uint256 txid = txids[insecure_rand() % txids.size()]; // txid we're going to modify in this iteration.\n             CCoins& coins = result[txid];\n             CCoinsModifier entry = stack.back()->ModifyCoins(txid);\n-            BOOST_CHECK(coins == *entry);\n+            FAST_CHECK(coins == *entry);\n             if (insecure_rand() % 5 == 0 || coins.IsPruned()) {\n                 if (coins.IsPruned()) {\n                     added_an_entry = true;\n@@ -152,10 +152,10 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n             for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n                 const CCoins* coins = stack.back()->AccessCoins(it->first);\n                 if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n+                    FAST_CHECK(*coins == it->second);\n                     found_an_entry = true;\n                 } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n+                    FAST_CHECK(it->second.IsPruned());\n                     missed_an_entry = true;\n                 }\n             }\n@@ -202,13 +202,13 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     }\n \n     // Verify coverage.\n-    BOOST_CHECK(removed_all_caches);\n-    BOOST_CHECK(reached_4_caches);\n-    BOOST_CHECK(added_an_entry);\n-    BOOST_CHECK(removed_an_entry);\n-    BOOST_CHECK(updated_an_entry);\n-    BOOST_CHECK(found_an_entry);\n-    BOOST_CHECK(missed_an_entry);\n+    FAST_CHECK(removed_all_caches);\n+    FAST_CHECK(reached_4_caches);\n+    FAST_CHECK(added_an_entry);\n+    FAST_CHECK(removed_an_entry);\n+    FAST_CHECK(updated_an_entry);\n+    FAST_CHECK(found_an_entry);\n+    FAST_CHECK(missed_an_entry);\n }\n \n // This test is similar to the previous test\n@@ -305,9 +305,9 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n                 const CCoins* coins = stack.back()->AccessCoins(it->first);\n                 if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n+                    FAST_CHECK(*coins == it->second);\n                  } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n+                    FAST_CHECK(it->second.IsPruned());\n                  }\n             }\n         }\n@@ -343,7 +343,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n     }\n \n     // Verify coverage.\n-    BOOST_CHECK(spent_a_duplicate_coinbase);\n+    FAST_CHECK(spent_a_duplicate_coinbase);\n }\n \n BOOST_AUTO_TEST_CASE(ccoins_serialization)\n@@ -352,45 +352,45 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     CDataStream ss1(ParseHex(\"0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\"), SER_DISK, CLIENT_VERSION);\n     CCoins cc1;\n     ss1 >> cc1;\n-    BOOST_CHECK_EQUAL(cc1.nVersion, 1);\n-    BOOST_CHECK_EQUAL(cc1.fCoinBase, false);\n-    BOOST_CHECK_EQUAL(cc1.nHeight, 203998);\n-    BOOST_CHECK_EQUAL(cc1.vout.size(), 2);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(0), false);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(1), true);\n-    BOOST_CHECK_EQUAL(cc1.vout[1].nValue, 60000000000ULL);\n-    BOOST_CHECK_EQUAL(HexStr(cc1.vout[1].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n+    FAST_CHECK_EQUAL(cc1.nVersion, 1);\n+    FAST_CHECK_EQUAL(cc1.fCoinBase, false);\n+    FAST_CHECK_EQUAL(cc1.nHeight, 203998);\n+    FAST_CHECK_EQUAL(cc1.vout.size(), 2);\n+    FAST_CHECK_EQUAL(cc1.IsAvailable(0), false);\n+    FAST_CHECK_EQUAL(cc1.IsAvailable(1), true);\n+    FAST_CHECK_EQUAL(cc1.vout[1].nValue, 60000000000ULL);\n+    FAST_CHECK_EQUAL(HexStr(cc1.vout[1].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n \n     // Good example\n     CDataStream ss2(ParseHex(\"0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\"), SER_DISK, CLIENT_VERSION);\n     CCoins cc2;\n     ss2 >> cc2;\n-    BOOST_CHECK_EQUAL(cc2.nVersion, 1);\n-    BOOST_CHECK_EQUAL(cc2.fCoinBase, true);\n-    BOOST_CHECK_EQUAL(cc2.nHeight, 120891);\n-    BOOST_CHECK_EQUAL(cc2.vout.size(), 17);\n+    FAST_CHECK_EQUAL(cc2.nVersion, 1);\n+    FAST_CHECK_EQUAL(cc2.fCoinBase, true);\n+    FAST_CHECK_EQUAL(cc2.nHeight, 120891);\n+    FAST_CHECK_EQUAL(cc2.vout.size(), 17);\n     for (int i = 0; i < 17; i++) {\n-        BOOST_CHECK_EQUAL(cc2.IsAvailable(i), i == 4 || i == 16);\n+        FAST_CHECK_EQUAL(cc2.IsAvailable(i), i == 4 || i == 16);\n     }\n-    BOOST_CHECK_EQUAL(cc2.vout[4].nValue, 234925952);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[4].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"61b01caab50f1b8e9c50a5057eb43c2d9563a4ee\"))))));\n-    BOOST_CHECK_EQUAL(cc2.vout[16].nValue, 110397);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[16].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n+    FAST_CHECK_EQUAL(cc2.vout[4].nValue, 234925952);\n+    FAST_CHECK_EQUAL(HexStr(cc2.vout[4].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"61b01caab50f1b8e9c50a5057eb43c2d9563a4ee\"))))));\n+    FAST_CHECK_EQUAL(cc2.vout[16].nValue, 110397);\n+    FAST_CHECK_EQUAL(HexStr(cc2.vout[16].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n \n     // Smallest possible example\n     CDataStream ssx(SER_DISK, CLIENT_VERSION);\n-    BOOST_CHECK_EQUAL(HexStr(ssx.begin(), ssx.end()), \"\");\n+    FAST_CHECK_EQUAL(HexStr(ssx.begin(), ssx.end()), \"\");\n \n     CDataStream ss3(ParseHex(\"0002000600\"), SER_DISK, CLIENT_VERSION);\n     CCoins cc3;\n     ss3 >> cc3;\n-    BOOST_CHECK_EQUAL(cc3.nVersion, 0);\n-    BOOST_CHECK_EQUAL(cc3.fCoinBase, false);\n-    BOOST_CHECK_EQUAL(cc3.nHeight, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout.size(), 1);\n-    BOOST_CHECK_EQUAL(cc3.IsAvailable(0), true);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].nValue, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].scriptPubKey.size(), 0);\n+    FAST_CHECK_EQUAL(cc3.nVersion, 0);\n+    FAST_CHECK_EQUAL(cc3.fCoinBase, false);\n+    FAST_CHECK_EQUAL(cc3.nHeight, 0);\n+    FAST_CHECK_EQUAL(cc3.vout.size(), 1);\n+    FAST_CHECK_EQUAL(cc3.IsAvailable(0), true);\n+    FAST_CHECK_EQUAL(cc3.vout[0].nValue, 0);\n+    FAST_CHECK_EQUAL(cc3.vout[0].scriptPubKey.size(), 0);\n \n     // scriptPubKey that ends beyond the end of the stream\n     CDataStream ss4(ParseHex(\"0002000800\"), SER_DISK, CLIENT_VERSION);\n@@ -405,7 +405,7 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     CDataStream tmp(SER_DISK, CLIENT_VERSION);\n     uint64_t x = 3000000000ULL;\n     tmp << VARINT(x);\n-    BOOST_CHECK_EQUAL(HexStr(tmp.begin(), tmp.end()), \"8a95c0bb00\");\n+    FAST_CHECK_EQUAL(HexStr(tmp.begin(), tmp.end()), \"8a95c0bb00\");\n     CDataStream ss5(ParseHex(\"0002008a95c0bb0000\"), SER_DISK, CLIENT_VERSION);\n     try {\n         CCoins cc5;"
      },
      {
        "sha": "f4500122dbfa9a419f642fba17557654c0a4c373",
        "filename": "src/test/compress_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -39,27 +39,27 @@ bool static TestPair(uint64_t dec, uint64_t enc) {\n \n BOOST_AUTO_TEST_CASE(compress_amounts)\n {\n-    BOOST_CHECK(TestPair(            0,       0x0));\n-    BOOST_CHECK(TestPair(            1,       0x1));\n-    BOOST_CHECK(TestPair(         CENT,       0x7));\n-    BOOST_CHECK(TestPair(         COIN,       0x9));\n-    BOOST_CHECK(TestPair(      50*COIN,      0x32));\n-    BOOST_CHECK(TestPair(21000000*COIN, 0x1406f40));\n+    FAST_CHECK(TestPair(            0,       0x0));\n+    FAST_CHECK(TestPair(            1,       0x1));\n+    FAST_CHECK(TestPair(         CENT,       0x7));\n+    FAST_CHECK(TestPair(         COIN,       0x9));\n+    FAST_CHECK(TestPair(      50*COIN,      0x32));\n+    FAST_CHECK(TestPair(21000000*COIN, 0x1406f40));\n \n     for (uint64_t i = 1; i <= NUM_MULTIPLES_UNIT; i++)\n-        BOOST_CHECK(TestEncode(i));\n+        FAST_CHECK(TestEncode(i));\n \n     for (uint64_t i = 1; i <= NUM_MULTIPLES_CENT; i++)\n-        BOOST_CHECK(TestEncode(i * CENT));\n+        FAST_CHECK(TestEncode(i * CENT));\n \n     for (uint64_t i = 1; i <= NUM_MULTIPLES_1BTC; i++)\n-        BOOST_CHECK(TestEncode(i * COIN));\n+        FAST_CHECK(TestEncode(i * COIN));\n \n     for (uint64_t i = 1; i <= NUM_MULTIPLES_50BTC; i++)\n-        BOOST_CHECK(TestEncode(i * 50 * COIN));\n+        FAST_CHECK(TestEncode(i * 50 * COIN));\n \n     for (uint64_t i = 0; i < 100000; i++)\n-        BOOST_CHECK(TestDecode(i));\n+        FAST_CHECK(TestDecode(i));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7888e43819e3a074626ec69604ec11368452e4a2",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -25,12 +25,12 @@ BOOST_FIXTURE_TEST_SUITE(crypto_tests, BasicTestingSetup)\n template<typename Hasher, typename In, typename Out>\n void TestVector(const Hasher &h, const In &in, const Out &out) {\n     Out hash;\n-    BOOST_CHECK(out.size() == h.OUTPUT_SIZE);\n+    FAST_CHECK(out.size() == h.OUTPUT_SIZE);\n     hash.resize(out.size());\n     {\n         // Test that writing the whole input string at once works.\n         Hasher(h).Write((unsigned char*)&in[0], in.size()).Finalize(&hash[0]);\n-        BOOST_CHECK(hash == out);\n+        FAST_CHECK(hash == out);\n     }\n     for (int i=0; i<32; i++) {\n         // Test that writing the string broken up in random pieces works.\n@@ -43,11 +43,11 @@ void TestVector(const Hasher &h, const In &in, const Out &out) {\n             if (pos > 0 && pos + 2 * out.size() > in.size() && pos < in.size()) {\n                 // Test that writing the rest at once to a copy of a hasher works.\n                 Hasher(hasher).Write((unsigned char*)&in[pos], in.size() - pos).Finalize(&hash[0]);\n-                BOOST_CHECK(hash == out);\n+                FAST_CHECK(hash == out);\n             }\n         }\n         hasher.Finalize(&hash[0]);\n-        BOOST_CHECK(hash == out);\n+        FAST_CHECK(hash == out);\n     }\n }\n \n@@ -80,10 +80,10 @@ void TestAES128(const std::string &hexkey, const std::string &hexin, const std::\n     buf.resize(correctout.size());\n     buf2.resize(correctout.size());\n     enc.Encrypt(&buf[0], &in[0]);\n-    BOOST_CHECK_EQUAL(HexStr(buf), HexStr(correctout));\n+    FAST_CHECK_EQUAL(HexStr(buf), HexStr(correctout));\n     AES128Decrypt dec(&key[0]);\n     dec.Decrypt(&buf2[0], &buf[0]);\n-    BOOST_CHECK_EQUAL(HexStr(buf2), HexStr(in));\n+    FAST_CHECK_EQUAL(HexStr(buf2), HexStr(in));\n }\n \n void TestAES256(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n@@ -99,10 +99,10 @@ void TestAES256(const std::string &hexkey, const std::string &hexin, const std::\n     AES256Encrypt enc(&key[0]);\n     buf.resize(correctout.size());\n     enc.Encrypt(&buf[0], &in[0]);\n-    BOOST_CHECK(buf == correctout);\n+    FAST_CHECK(buf == correctout);\n     AES256Decrypt dec(&key[0]);\n     dec.Decrypt(&buf[0], &buf[0]);\n-    BOOST_CHECK(buf == in);\n+    FAST_CHECK(buf == in);\n }\n \n void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n@@ -117,15 +117,15 @@ void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n     AES128CBCEncrypt enc(&key[0], &iv[0], pad);\n     int size = enc.Encrypt(&in[0], in.size(), &realout[0]);\n     realout.resize(size);\n-    BOOST_CHECK(realout.size() == correctout.size());\n+    FAST_CHECK(realout.size() == correctout.size());\n     BOOST_CHECK_MESSAGE(realout == correctout, HexStr(realout) + std::string(\" != \") + hexout);\n \n     // Decrypt the cipher and verify that it equals the plaintext\n     std::vector<unsigned char> decrypted(correctout.size());\n     AES128CBCDecrypt dec(&key[0], &iv[0], pad);\n     size = dec.Decrypt(&correctout[0], correctout.size(), &decrypted[0]);\n     decrypted.resize(size);\n-    BOOST_CHECK(decrypted.size() == in.size());\n+    FAST_CHECK(decrypted.size() == in.size());\n     BOOST_CHECK_MESSAGE(decrypted == in, HexStr(decrypted) + std::string(\" != \") + hexin);\n \n     // Encrypt and re-decrypt substrings of the plaintext and verify that they equal each-other\n@@ -140,7 +140,7 @@ void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n             std::vector<unsigned char> subdecrypted(subout.size());\n             size = dec.Decrypt(&subout[0], subout.size(), &subdecrypted[0]);\n             subdecrypted.resize(size);\n-            BOOST_CHECK(decrypted.size() == in.size());\n+            FAST_CHECK(decrypted.size() == in.size());\n             BOOST_CHECK_MESSAGE(subdecrypted == sub, HexStr(subdecrypted) + std::string(\" != \") + HexStr(sub));\n         }\n     }\n@@ -158,15 +158,15 @@ void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n     AES256CBCEncrypt enc(&key[0], &iv[0], pad);\n     int size = enc.Encrypt(&in[0], in.size(), &realout[0]);\n     realout.resize(size);\n-    BOOST_CHECK(realout.size() == correctout.size());\n+    FAST_CHECK(realout.size() == correctout.size());\n     BOOST_CHECK_MESSAGE(realout == correctout, HexStr(realout) + std::string(\" != \") + hexout);\n \n     // Decrypt the cipher and verify that it equals the plaintext\n     std::vector<unsigned char> decrypted(correctout.size());\n     AES256CBCDecrypt dec(&key[0], &iv[0], pad);\n     size = dec.Decrypt(&correctout[0], correctout.size(), &decrypted[0]);\n     decrypted.resize(size);\n-    BOOST_CHECK(decrypted.size() == in.size());\n+    FAST_CHECK(decrypted.size() == in.size());\n     BOOST_CHECK_MESSAGE(decrypted == in, HexStr(decrypted) + std::string(\" != \") + hexin);\n \n     // Encrypt and re-decrypt substrings of the plaintext and verify that they equal each-other\n@@ -181,7 +181,7 @@ void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n             std::vector<unsigned char> subdecrypted(subout.size());\n             size = dec.Decrypt(&subout[0], subout.size(), &subdecrypted[0]);\n             subdecrypted.resize(size);\n-            BOOST_CHECK(decrypted.size() == in.size());\n+            FAST_CHECK(decrypted.size() == in.size());\n             BOOST_CHECK_MESSAGE(subdecrypted == sub, HexStr(subdecrypted) + std::string(\" != \") + HexStr(sub));\n         }\n     }"
      },
      {
        "sha": "a2b392919d668a4fb6d50115cd3b59f1c5f14cbd",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 48,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -39,11 +39,11 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n         uint256 res;\n \n         // Ensure that we're doing real obfuscation when obfuscate=true\n-        BOOST_CHECK(obfuscate != is_null_key(dbwrapper_private::GetObfuscateKey(dbw)));\n+        FAST_CHECK(obfuscate != is_null_key(dbwrapper_private::GetObfuscateKey(dbw)));\n \n-        BOOST_CHECK(dbw.Write(key, in));\n-        BOOST_CHECK(dbw.Read(key, res));\n-        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+        FAST_CHECK(dbw.Write(key, in));\n+        FAST_CHECK(dbw.Read(key, res));\n+        FAST_CHECK_EQUAL(res.ToString(), in.ToString());\n     }\n }\n \n@@ -75,13 +75,13 @@ BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n \n         dbw.WriteBatch(batch);\n \n-        BOOST_CHECK(dbw.Read(key, res));\n-        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n-        BOOST_CHECK(dbw.Read(key2, res));\n-        BOOST_CHECK_EQUAL(res.ToString(), in2.ToString());\n+        FAST_CHECK(dbw.Read(key, res));\n+        FAST_CHECK_EQUAL(res.ToString(), in.ToString());\n+        FAST_CHECK(dbw.Read(key2, res));\n+        FAST_CHECK_EQUAL(res.ToString(), in2.ToString());\n \n         // key3 never should've been written\n-        BOOST_CHECK(dbw.Read(key3, res) == false);\n+        FAST_CHECK(dbw.Read(key3, res) == false);\n     }\n }\n \n@@ -96,10 +96,10 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n         // The two keys are intentionally chosen for ordering\n         char key = 'j';\n         uint256 in = GetRandHash();\n-        BOOST_CHECK(dbw.Write(key, in));\n+        FAST_CHECK(dbw.Write(key, in));\n         char key2 = 'k';\n         uint256 in2 = GetRandHash();\n-        BOOST_CHECK(dbw.Write(key2, in2));\n+        FAST_CHECK(dbw.Write(key2, in2));\n \n         boost::scoped_ptr<CDBIterator> it(const_cast<CDBWrapper*>(&dbw)->NewIterator());\n \n@@ -111,18 +111,18 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n \n         it->GetKey(key_res);\n         it->GetValue(val_res);\n-        BOOST_CHECK_EQUAL(key_res, key);\n-        BOOST_CHECK_EQUAL(val_res.ToString(), in.ToString());\n+        FAST_CHECK_EQUAL(key_res, key);\n+        FAST_CHECK_EQUAL(val_res.ToString(), in.ToString());\n \n         it->Next();\n \n         it->GetKey(key_res);\n         it->GetValue(val_res);\n-        BOOST_CHECK_EQUAL(key_res, key2);\n-        BOOST_CHECK_EQUAL(val_res.ToString(), in2.ToString());\n+        FAST_CHECK_EQUAL(key_res, key2);\n+        FAST_CHECK_EQUAL(val_res.ToString(), in2.ToString());\n \n         it->Next();\n-        BOOST_CHECK_EQUAL(it->Valid(), false);\n+        FAST_CHECK_EQUAL(it->Valid(), false);\n     }\n }\n \n@@ -139,9 +139,9 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n     uint256 in = GetRandHash();\n     uint256 res;\n \n-    BOOST_CHECK(dbw->Write(key, in));\n-    BOOST_CHECK(dbw->Read(key, res));\n-    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+    FAST_CHECK(dbw->Write(key, in));\n+    FAST_CHECK(dbw->Read(key, res));\n+    FAST_CHECK_EQUAL(res.ToString(), in.ToString());\n \n     // Call the destructor to free leveldb LOCK\n     delete dbw;\n@@ -152,19 +152,19 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n     // Check that the key/val we wrote with unobfuscated wrapper exists and \n     // is readable.\n     uint256 res2;\n-    BOOST_CHECK(odbw.Read(key, res2));\n-    BOOST_CHECK_EQUAL(res2.ToString(), in.ToString());\n+    FAST_CHECK(odbw.Read(key, res2));\n+    FAST_CHECK_EQUAL(res2.ToString(), in.ToString());\n \n-    BOOST_CHECK(!odbw.IsEmpty()); // There should be existing data\n-    BOOST_CHECK(is_null_key(dbwrapper_private::GetObfuscateKey(odbw))); // The key should be an empty string\n+    FAST_CHECK(!odbw.IsEmpty()); // There should be existing data\n+    FAST_CHECK(is_null_key(dbwrapper_private::GetObfuscateKey(odbw))); // The key should be an empty string\n \n     uint256 in2 = GetRandHash();\n     uint256 res3;\n  \n     // Check that we can write successfully\n-    BOOST_CHECK(odbw.Write(key, in2));\n-    BOOST_CHECK(odbw.Read(key, res3));\n-    BOOST_CHECK_EQUAL(res3.ToString(), in2.ToString());\n+    FAST_CHECK(odbw.Write(key, in2));\n+    FAST_CHECK(odbw.Read(key, res3));\n+    FAST_CHECK_EQUAL(res3.ToString(), in2.ToString());\n }\n                         \n // Ensure that we start obfuscating during a reindex.\n@@ -180,9 +180,9 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n     uint256 in = GetRandHash();\n     uint256 res;\n \n-    BOOST_CHECK(dbw->Write(key, in));\n-    BOOST_CHECK(dbw->Read(key, res));\n-    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+    FAST_CHECK(dbw->Write(key, in));\n+    FAST_CHECK(dbw->Read(key, res));\n+    FAST_CHECK_EQUAL(res.ToString(), in.ToString());\n \n     // Call the destructor to free leveldb LOCK\n     delete dbw;\n@@ -192,16 +192,16 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n \n     // Check that the key/val we wrote with unobfuscated wrapper doesn't exist\n     uint256 res2;\n-    BOOST_CHECK(!odbw.Read(key, res2));\n-    BOOST_CHECK(!is_null_key(dbwrapper_private::GetObfuscateKey(odbw)));\n+    FAST_CHECK(!odbw.Read(key, res2));\n+    FAST_CHECK(!is_null_key(dbwrapper_private::GetObfuscateKey(odbw)));\n \n     uint256 in2 = GetRandHash();\n     uint256 res3;\n  \n     // Check that we can write successfully\n-    BOOST_CHECK(odbw.Write(key, in2));\n-    BOOST_CHECK(odbw.Read(key, res3));\n-    BOOST_CHECK_EQUAL(res3.ToString(), in2.ToString());\n+    FAST_CHECK(odbw.Write(key, in2));\n+    FAST_CHECK(odbw.Read(key, res3));\n+    FAST_CHECK_EQUAL(res3.ToString(), in2.ToString());\n }\n \n BOOST_AUTO_TEST_CASE(iterator_ordering)\n@@ -211,7 +211,7 @@ BOOST_AUTO_TEST_CASE(iterator_ordering)\n     for (int x=0x00; x<256; ++x) {\n         uint8_t key = x;\n         uint32_t value = x*x;\n-        BOOST_CHECK(dbw.Write(key, value));\n+        FAST_CHECK(dbw.Write(key, value));\n     }\n \n     boost::scoped_ptr<CDBIterator> it(const_cast<CDBWrapper*>(&dbw)->NewIterator());\n@@ -225,16 +225,16 @@ BOOST_AUTO_TEST_CASE(iterator_ordering)\n         for (int x=seek_start; x<256; ++x) {\n             uint8_t key;\n             uint32_t value;\n-            BOOST_CHECK(it->Valid());\n+            FAST_CHECK(it->Valid());\n             if (!it->Valid()) // Avoid spurious errors about invalid iterator's key and value in case of failure\n                 break;\n-            BOOST_CHECK(it->GetKey(key));\n-            BOOST_CHECK(it->GetValue(value));\n-            BOOST_CHECK_EQUAL(key, x);\n-            BOOST_CHECK_EQUAL(value, x*x);\n+            FAST_CHECK(it->GetKey(key));\n+            FAST_CHECK(it->GetValue(value));\n+            FAST_CHECK_EQUAL(key, x);\n+            FAST_CHECK_EQUAL(value, x*x);\n             it->Next();\n         }\n-        BOOST_CHECK(!it->Valid());\n+        FAST_CHECK(!it->Valid());\n     }\n }\n \n@@ -286,7 +286,7 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n             for (int z = 0; z < y; z++)\n                 key += key;\n             uint32_t value = x*x;\n-            BOOST_CHECK(dbw.Write(key, value));\n+            FAST_CHECK(dbw.Write(key, value));\n         }\n     }\n \n@@ -308,17 +308,17 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n                     exp_key += exp_key;\n                 StringContentsSerializer key;\n                 uint32_t value;\n-                BOOST_CHECK(it->Valid());\n+                FAST_CHECK(it->Valid());\n                 if (!it->Valid()) // Avoid spurious errors about invalid iterator's key and value in case of failure\n                     break;\n-                BOOST_CHECK(it->GetKey(key));\n-                BOOST_CHECK(it->GetValue(value));\n-                BOOST_CHECK_EQUAL(key.str, exp_key);\n-                BOOST_CHECK_EQUAL(value, x*x);\n+                FAST_CHECK(it->GetKey(key));\n+                FAST_CHECK(it->GetValue(value));\n+                FAST_CHECK_EQUAL(key.str, exp_key);\n+                FAST_CHECK_EQUAL(value, x*x);\n                 it->Next();\n             }\n         }\n-        BOOST_CHECK(!it->Valid());\n+        FAST_CHECK(!it->Valid());\n     }\n }\n "
      },
      {
        "sha": "b60123bf79ca0d7bfc4a22afd3eb600c1b2a0c1a",
        "filename": "src/test/getarg_tests.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 55,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/getarg_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/getarg_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/getarg_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -34,129 +34,129 @@ static void ResetArgs(const std::string& strArg)\n BOOST_AUTO_TEST_CASE(boolarg)\n {\n     ResetArgs(\"-foo\");\n-    BOOST_CHECK(GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(GetBoolArg(\"-foo\", true));\n \n-    BOOST_CHECK(!GetBoolArg(\"-fo\", false));\n-    BOOST_CHECK(GetBoolArg(\"-fo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-fo\", false));\n+    FAST_CHECK(GetBoolArg(\"-fo\", true));\n \n-    BOOST_CHECK(!GetBoolArg(\"-fooo\", false));\n-    BOOST_CHECK(GetBoolArg(\"-fooo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-fooo\", false));\n+    FAST_CHECK(GetBoolArg(\"-fooo\", true));\n \n     ResetArgs(\"-foo=0\");\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo=1\");\n-    BOOST_CHECK(GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(GetBoolArg(\"-foo\", true));\n \n     // New 0.6 feature: auto-map -nosomething to !-something:\n     ResetArgs(\"-nofoo\");\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-nofoo=1\");\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo -nofoo\");  // -nofoo should win\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo=1 -nofoo=1\");  // -nofoo should win\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"-foo=0 -nofoo=0\");  // -nofoo=0 should win\n-    BOOST_CHECK(GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(GetBoolArg(\"-foo\", true));\n \n     // New 0.6 feature: treat -- same as -:\n     ResetArgs(\"--foo=1\");\n-    BOOST_CHECK(GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(GetBoolArg(\"-foo\", true));\n \n     ResetArgs(\"--nofoo=1\");\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n \n }\n \n BOOST_AUTO_TEST_CASE(stringarg)\n {\n     ResetArgs(\"\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"eleven\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"eleven\");\n \n     ResetArgs(\"-foo -bar\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"\");\n \n     ResetArgs(\"-foo=\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"\");\n \n     ResetArgs(\"-foo=11\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"11\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"11\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"11\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"11\");\n \n     ResetArgs(\"-foo=eleven\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"eleven\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"eleven\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"eleven\");\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"eleven\"), \"eleven\");\n \n }\n \n BOOST_AUTO_TEST_CASE(intarg)\n {\n     ResetArgs(\"\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", 11), 11);\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", 0), 0);\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", 11), 11);\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", 0), 0);\n \n     ResetArgs(\"-foo -bar\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", 11), 0);\n-    BOOST_CHECK_EQUAL(GetArg(\"-bar\", 11), 0);\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", 11), 0);\n+    FAST_CHECK_EQUAL(GetArg(\"-bar\", 11), 0);\n \n     ResetArgs(\"-foo=11 -bar=12\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", 0), 11);\n-    BOOST_CHECK_EQUAL(GetArg(\"-bar\", 11), 12);\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", 0), 11);\n+    FAST_CHECK_EQUAL(GetArg(\"-bar\", 11), 12);\n \n     ResetArgs(\"-foo=NaN -bar=NotANumber\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", 1), 0);\n-    BOOST_CHECK_EQUAL(GetArg(\"-bar\", 11), 0);\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", 1), 0);\n+    FAST_CHECK_EQUAL(GetArg(\"-bar\", 11), 0);\n }\n \n BOOST_AUTO_TEST_CASE(doubledash)\n {\n     ResetArgs(\"--foo\");\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"-foo\", false), true);\n+    FAST_CHECK_EQUAL(GetBoolArg(\"-foo\", false), true);\n \n     ResetArgs(\"--foo=verbose --bar=1\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"verbose\");\n-    BOOST_CHECK_EQUAL(GetArg(\"-bar\", 0), 1);\n+    FAST_CHECK_EQUAL(GetArg(\"-foo\", \"\"), \"verbose\");\n+    FAST_CHECK_EQUAL(GetArg(\"-bar\", 0), 1);\n }\n \n BOOST_AUTO_TEST_CASE(boolargno)\n {\n     ResetArgs(\"-nofoo\");\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-nofoo=1\");\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-nofoo=0\");\n-    BOOST_CHECK(GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-foo --nofoo\"); // --nofoo should win\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(!GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(!GetBoolArg(\"-foo\", false));\n \n     ResetArgs(\"-nofoo -foo\"); // foo always wins:\n-    BOOST_CHECK(GetBoolArg(\"-foo\", true));\n-    BOOST_CHECK(GetBoolArg(\"-foo\", false));\n+    FAST_CHECK(GetBoolArg(\"-foo\", true));\n+    FAST_CHECK(GetBoolArg(\"-foo\", false));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "3889133bfca5a2916efaf05a6732e916d380a6c3",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -17,7 +17,7 @@ BOOST_FIXTURE_TEST_SUITE(hash_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(murmurhash3)\n {\n \n-#define T(expected, seed, data) BOOST_CHECK_EQUAL(MurmurHash3(seed, ParseHex(data)), expected)\n+#define T(expected, seed, data) FAST_CHECK_EQUAL(MurmurHash3(seed, ParseHex(data)), expected)\n \n     // Test MurmurHash3 with various inputs. Of course this is retested in the\n     // bloom filter tests - they would fail if MurmurHash3() had any problems -\n@@ -82,50 +82,50 @@ uint64_t siphash_4_2_testvec[] = {\n BOOST_AUTO_TEST_CASE(siphash)\n {\n     CSipHasher hasher(0x0706050403020100ULL, 0x0F0E0D0C0B0A0908ULL);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x726fdb47dd0e0e31ull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x726fdb47dd0e0e31ull);\n     static const unsigned char t0[1] = {0};\n     hasher.Write(t0, 1);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x74f839c593dc67fdull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x74f839c593dc67fdull);\n     static const unsigned char t1[7] = {1,2,3,4,5,6,7};\n     hasher.Write(t1, 7);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x93f5f5799a932462ull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x93f5f5799a932462ull);\n     hasher.Write(0x0F0E0D0C0B0A0908ULL);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x3f2acc7f57c29bdbull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x3f2acc7f57c29bdbull);\n     static const unsigned char t2[2] = {16,17};\n     hasher.Write(t2, 2);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x4bc1b3f0968dd39cull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x4bc1b3f0968dd39cull);\n     static const unsigned char t3[9] = {18,19,20,21,22,23,24,25,26};\n     hasher.Write(t3, 9);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x2f2e6163076bcfadull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x2f2e6163076bcfadull);\n     static const unsigned char t4[5] = {27,28,29,30,31};\n     hasher.Write(t4, 5);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x7127512f72f27cceull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x7127512f72f27cceull);\n     hasher.Write(0x2726252423222120ULL);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0x0e3ea96b5304a7d0ull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0x0e3ea96b5304a7d0ull);\n     hasher.Write(0x2F2E2D2C2B2A2928ULL);\n-    BOOST_CHECK_EQUAL(hasher.Finalize(),  0xe612a3cb9ecba951ull);\n+    FAST_CHECK_EQUAL(hasher.Finalize(),  0xe612a3cb9ecba951ull);\n \n-    BOOST_CHECK_EQUAL(SipHashUint256(0x0706050403020100ULL, 0x0F0E0D0C0B0A0908ULL, uint256S(\"1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100\")), 0x7127512f72f27cceull);\n+    FAST_CHECK_EQUAL(SipHashUint256(0x0706050403020100ULL, 0x0F0E0D0C0B0A0908ULL, uint256S(\"1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100\")), 0x7127512f72f27cceull);\n \n     // Check test vectors from spec, one byte at a time\n     CSipHasher hasher2(0x0706050403020100ULL, 0x0F0E0D0C0B0A0908ULL);\n     for (uint8_t x=0; x<ARRAYLEN(siphash_4_2_testvec); ++x)\n     {\n-        BOOST_CHECK_EQUAL(hasher2.Finalize(), siphash_4_2_testvec[x]);\n+        FAST_CHECK_EQUAL(hasher2.Finalize(), siphash_4_2_testvec[x]);\n         hasher2.Write(&x, 1);\n     }\n     // Check test vectors from spec, eight bytes at a time\n     CSipHasher hasher3(0x0706050403020100ULL, 0x0F0E0D0C0B0A0908ULL);\n     for (uint8_t x=0; x<ARRAYLEN(siphash_4_2_testvec); x+=8)\n     {\n-        BOOST_CHECK_EQUAL(hasher3.Finalize(), siphash_4_2_testvec[x]);\n+        FAST_CHECK_EQUAL(hasher3.Finalize(), siphash_4_2_testvec[x]);\n         hasher3.Write(uint64_t(x)|(uint64_t(x+1)<<8)|(uint64_t(x+2)<<16)|(uint64_t(x+3)<<24)|\n                      (uint64_t(x+4)<<32)|(uint64_t(x+5)<<40)|(uint64_t(x+6)<<48)|(uint64_t(x+7)<<56));\n     }\n \n     CHashWriter ss(SER_DISK, CLIENT_VERSION);\n     ss << CTransaction();\n-    BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n+    FAST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2577a3907be2db94914efed9f7c7f465df51f2dc",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 77,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -64,50 +64,50 @@ BOOST_FIXTURE_TEST_SUITE(key_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(key_test1)\n {\n     CBitcoinSecret bsecret1, bsecret2, bsecret1C, bsecret2C, baddress1;\n-    BOOST_CHECK( bsecret1.SetString (strSecret1));\n-    BOOST_CHECK( bsecret2.SetString (strSecret2));\n-    BOOST_CHECK( bsecret1C.SetString(strSecret1C));\n-    BOOST_CHECK( bsecret2C.SetString(strSecret2C));\n-    BOOST_CHECK(!baddress1.SetString(strAddressBad));\n+    FAST_CHECK( bsecret1.SetString (strSecret1));\n+    FAST_CHECK( bsecret2.SetString (strSecret2));\n+    FAST_CHECK( bsecret1C.SetString(strSecret1C));\n+    FAST_CHECK( bsecret2C.SetString(strSecret2C));\n+    FAST_CHECK(!baddress1.SetString(strAddressBad));\n \n     CKey key1  = bsecret1.GetKey();\n-    BOOST_CHECK(key1.IsCompressed() == false);\n+    FAST_CHECK(key1.IsCompressed() == false);\n     CKey key2  = bsecret2.GetKey();\n-    BOOST_CHECK(key2.IsCompressed() == false);\n+    FAST_CHECK(key2.IsCompressed() == false);\n     CKey key1C = bsecret1C.GetKey();\n-    BOOST_CHECK(key1C.IsCompressed() == true);\n+    FAST_CHECK(key1C.IsCompressed() == true);\n     CKey key2C = bsecret2C.GetKey();\n-    BOOST_CHECK(key2C.IsCompressed() == true);\n+    FAST_CHECK(key2C.IsCompressed() == true);\n \n     CPubKey pubkey1  = key1. GetPubKey();\n     CPubKey pubkey2  = key2. GetPubKey();\n     CPubKey pubkey1C = key1C.GetPubKey();\n     CPubKey pubkey2C = key2C.GetPubKey();\n \n-    BOOST_CHECK(key1.VerifyPubKey(pubkey1));\n-    BOOST_CHECK(!key1.VerifyPubKey(pubkey1C));\n-    BOOST_CHECK(!key1.VerifyPubKey(pubkey2));\n-    BOOST_CHECK(!key1.VerifyPubKey(pubkey2C));\n+    FAST_CHECK(key1.VerifyPubKey(pubkey1));\n+    FAST_CHECK(!key1.VerifyPubKey(pubkey1C));\n+    FAST_CHECK(!key1.VerifyPubKey(pubkey2));\n+    FAST_CHECK(!key1.VerifyPubKey(pubkey2C));\n \n-    BOOST_CHECK(!key1C.VerifyPubKey(pubkey1));\n-    BOOST_CHECK(key1C.VerifyPubKey(pubkey1C));\n-    BOOST_CHECK(!key1C.VerifyPubKey(pubkey2));\n-    BOOST_CHECK(!key1C.VerifyPubKey(pubkey2C));\n+    FAST_CHECK(!key1C.VerifyPubKey(pubkey1));\n+    FAST_CHECK(key1C.VerifyPubKey(pubkey1C));\n+    FAST_CHECK(!key1C.VerifyPubKey(pubkey2));\n+    FAST_CHECK(!key1C.VerifyPubKey(pubkey2C));\n \n-    BOOST_CHECK(!key2.VerifyPubKey(pubkey1));\n-    BOOST_CHECK(!key2.VerifyPubKey(pubkey1C));\n-    BOOST_CHECK(key2.VerifyPubKey(pubkey2));\n-    BOOST_CHECK(!key2.VerifyPubKey(pubkey2C));\n+    FAST_CHECK(!key2.VerifyPubKey(pubkey1));\n+    FAST_CHECK(!key2.VerifyPubKey(pubkey1C));\n+    FAST_CHECK(key2.VerifyPubKey(pubkey2));\n+    FAST_CHECK(!key2.VerifyPubKey(pubkey2C));\n \n-    BOOST_CHECK(!key2C.VerifyPubKey(pubkey1));\n-    BOOST_CHECK(!key2C.VerifyPubKey(pubkey1C));\n-    BOOST_CHECK(!key2C.VerifyPubKey(pubkey2));\n-    BOOST_CHECK(key2C.VerifyPubKey(pubkey2C));\n+    FAST_CHECK(!key2C.VerifyPubKey(pubkey1));\n+    FAST_CHECK(!key2C.VerifyPubKey(pubkey1C));\n+    FAST_CHECK(!key2C.VerifyPubKey(pubkey2));\n+    FAST_CHECK(key2C.VerifyPubKey(pubkey2C));\n \n-    BOOST_CHECK(addr1.Get()  == CTxDestination(pubkey1.GetID()));\n-    BOOST_CHECK(addr2.Get()  == CTxDestination(pubkey2.GetID()));\n-    BOOST_CHECK(addr1C.Get() == CTxDestination(pubkey1C.GetID()));\n-    BOOST_CHECK(addr2C.Get() == CTxDestination(pubkey2C.GetID()));\n+    FAST_CHECK(addr1.Get()  == CTxDestination(pubkey1.GetID()));\n+    FAST_CHECK(addr2.Get()  == CTxDestination(pubkey2.GetID()));\n+    FAST_CHECK(addr1C.Get() == CTxDestination(pubkey1C.GetID()));\n+    FAST_CHECK(addr2C.Get() == CTxDestination(pubkey2C.GetID()));\n \n     for (int n=0; n<16; n++)\n     {\n@@ -118,74 +118,74 @@ BOOST_AUTO_TEST_CASE(key_test1)\n \n         vector<unsigned char> sign1, sign2, sign1C, sign2C;\n \n-        BOOST_CHECK(key1.Sign (hashMsg, sign1));\n-        BOOST_CHECK(key2.Sign (hashMsg, sign2));\n-        BOOST_CHECK(key1C.Sign(hashMsg, sign1C));\n-        BOOST_CHECK(key2C.Sign(hashMsg, sign2C));\n+        FAST_CHECK(key1.Sign (hashMsg, sign1));\n+        FAST_CHECK(key2.Sign (hashMsg, sign2));\n+        FAST_CHECK(key1C.Sign(hashMsg, sign1C));\n+        FAST_CHECK(key2C.Sign(hashMsg, sign2C));\n \n-        BOOST_CHECK( pubkey1.Verify(hashMsg, sign1));\n-        BOOST_CHECK(!pubkey1.Verify(hashMsg, sign2));\n-        BOOST_CHECK( pubkey1.Verify(hashMsg, sign1C));\n-        BOOST_CHECK(!pubkey1.Verify(hashMsg, sign2C));\n+        FAST_CHECK( pubkey1.Verify(hashMsg, sign1));\n+        FAST_CHECK(!pubkey1.Verify(hashMsg, sign2));\n+        FAST_CHECK( pubkey1.Verify(hashMsg, sign1C));\n+        FAST_CHECK(!pubkey1.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK(!pubkey2.Verify(hashMsg, sign1));\n-        BOOST_CHECK( pubkey2.Verify(hashMsg, sign2));\n-        BOOST_CHECK(!pubkey2.Verify(hashMsg, sign1C));\n-        BOOST_CHECK( pubkey2.Verify(hashMsg, sign2C));\n+        FAST_CHECK(!pubkey2.Verify(hashMsg, sign1));\n+        FAST_CHECK( pubkey2.Verify(hashMsg, sign2));\n+        FAST_CHECK(!pubkey2.Verify(hashMsg, sign1C));\n+        FAST_CHECK( pubkey2.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK( pubkey1C.Verify(hashMsg, sign1));\n-        BOOST_CHECK(!pubkey1C.Verify(hashMsg, sign2));\n-        BOOST_CHECK( pubkey1C.Verify(hashMsg, sign1C));\n-        BOOST_CHECK(!pubkey1C.Verify(hashMsg, sign2C));\n+        FAST_CHECK( pubkey1C.Verify(hashMsg, sign1));\n+        FAST_CHECK(!pubkey1C.Verify(hashMsg, sign2));\n+        FAST_CHECK( pubkey1C.Verify(hashMsg, sign1C));\n+        FAST_CHECK(!pubkey1C.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK(!pubkey2C.Verify(hashMsg, sign1));\n-        BOOST_CHECK( pubkey2C.Verify(hashMsg, sign2));\n-        BOOST_CHECK(!pubkey2C.Verify(hashMsg, sign1C));\n-        BOOST_CHECK( pubkey2C.Verify(hashMsg, sign2C));\n+        FAST_CHECK(!pubkey2C.Verify(hashMsg, sign1));\n+        FAST_CHECK( pubkey2C.Verify(hashMsg, sign2));\n+        FAST_CHECK(!pubkey2C.Verify(hashMsg, sign1C));\n+        FAST_CHECK( pubkey2C.Verify(hashMsg, sign2C));\n \n         // compact signatures (with key recovery)\n \n         vector<unsigned char> csign1, csign2, csign1C, csign2C;\n \n-        BOOST_CHECK(key1.SignCompact (hashMsg, csign1));\n-        BOOST_CHECK(key2.SignCompact (hashMsg, csign2));\n-        BOOST_CHECK(key1C.SignCompact(hashMsg, csign1C));\n-        BOOST_CHECK(key2C.SignCompact(hashMsg, csign2C));\n+        FAST_CHECK(key1.SignCompact (hashMsg, csign1));\n+        FAST_CHECK(key2.SignCompact (hashMsg, csign2));\n+        FAST_CHECK(key1C.SignCompact(hashMsg, csign1C));\n+        FAST_CHECK(key2C.SignCompact(hashMsg, csign2C));\n \n         CPubKey rkey1, rkey2, rkey1C, rkey2C;\n \n-        BOOST_CHECK(rkey1.RecoverCompact (hashMsg, csign1));\n-        BOOST_CHECK(rkey2.RecoverCompact (hashMsg, csign2));\n-        BOOST_CHECK(rkey1C.RecoverCompact(hashMsg, csign1C));\n-        BOOST_CHECK(rkey2C.RecoverCompact(hashMsg, csign2C));\n+        FAST_CHECK(rkey1.RecoverCompact (hashMsg, csign1));\n+        FAST_CHECK(rkey2.RecoverCompact (hashMsg, csign2));\n+        FAST_CHECK(rkey1C.RecoverCompact(hashMsg, csign1C));\n+        FAST_CHECK(rkey2C.RecoverCompact(hashMsg, csign2C));\n \n-        BOOST_CHECK(rkey1  == pubkey1);\n-        BOOST_CHECK(rkey2  == pubkey2);\n-        BOOST_CHECK(rkey1C == pubkey1C);\n-        BOOST_CHECK(rkey2C == pubkey2C);\n+        FAST_CHECK(rkey1  == pubkey1);\n+        FAST_CHECK(rkey2  == pubkey2);\n+        FAST_CHECK(rkey1C == pubkey1C);\n+        FAST_CHECK(rkey2C == pubkey2C);\n     }\n \n     // test deterministic signing\n \n     std::vector<unsigned char> detsig, detsigc;\n     string strMsg = \"Very deterministic message\";\n     uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());\n-    BOOST_CHECK(key1.Sign(hashMsg, detsig));\n-    BOOST_CHECK(key1C.Sign(hashMsg, detsigc));\n-    BOOST_CHECK(detsig == detsigc);\n-    BOOST_CHECK(detsig == ParseHex(\"304402205dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d022014ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n-    BOOST_CHECK(key2.Sign(hashMsg, detsig));\n-    BOOST_CHECK(key2C.Sign(hashMsg, detsigc));\n-    BOOST_CHECK(detsig == detsigc);\n-    BOOST_CHECK(detsig == ParseHex(\"3044022052d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd5022061d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n-    BOOST_CHECK(key1.SignCompact(hashMsg, detsig));\n-    BOOST_CHECK(key1C.SignCompact(hashMsg, detsigc));\n-    BOOST_CHECK(detsig == ParseHex(\"1c5dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d14ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n-    BOOST_CHECK(detsigc == ParseHex(\"205dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d14ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n-    BOOST_CHECK(key2.SignCompact(hashMsg, detsig));\n-    BOOST_CHECK(key2C.SignCompact(hashMsg, detsigc));\n-    BOOST_CHECK(detsig == ParseHex(\"1c52d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd561d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n-    BOOST_CHECK(detsigc == ParseHex(\"2052d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd561d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n+    FAST_CHECK(key1.Sign(hashMsg, detsig));\n+    FAST_CHECK(key1C.Sign(hashMsg, detsigc));\n+    FAST_CHECK(detsig == detsigc);\n+    FAST_CHECK(detsig == ParseHex(\"304402205dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d022014ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n+    FAST_CHECK(key2.Sign(hashMsg, detsig));\n+    FAST_CHECK(key2C.Sign(hashMsg, detsigc));\n+    FAST_CHECK(detsig == detsigc);\n+    FAST_CHECK(detsig == ParseHex(\"3044022052d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd5022061d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n+    FAST_CHECK(key1.SignCompact(hashMsg, detsig));\n+    FAST_CHECK(key1C.SignCompact(hashMsg, detsigc));\n+    FAST_CHECK(detsig == ParseHex(\"1c5dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d14ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n+    FAST_CHECK(detsigc == ParseHex(\"205dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d14ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n+    FAST_CHECK(key2.SignCompact(hashMsg, detsig));\n+    FAST_CHECK(key2C.SignCompact(hashMsg, detsigc));\n+    FAST_CHECK(detsig == ParseHex(\"1c52d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd561d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n+    FAST_CHECK(detsigc == ParseHex(\"2052d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd561d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "8eee636f4c097a225ec834130fd03331df0f6b16",
        "filename": "src/test/limitedmap_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/limitedmap_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/limitedmap_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/limitedmap_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -16,68 +16,68 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n     limitedmap<int, int> map(10);\n \n     // check that the max size is 10\n-    BOOST_CHECK(map.max_size() == 10);\n+    FAST_CHECK(map.max_size() == 10);\n \n     // check that it's empty\n-    BOOST_CHECK(map.size() == 0);\n+    FAST_CHECK(map.size() == 0);\n \n     // insert (-1, -1)\n     map.insert(std::pair<int, int>(-1, -1));\n \n     // make sure that the size is updated\n-    BOOST_CHECK(map.size() == 1);\n+    FAST_CHECK(map.size() == 1);\n \n     // make sure that the new items is in the map\n-    BOOST_CHECK(map.count(-1) == 1);\n+    FAST_CHECK(map.count(-1) == 1);\n \n     // insert 10 new items\n     for (int i = 0; i < 10; i++) {\n         map.insert(std::pair<int, int>(i, i + 1));\n     }\n \n     // make sure that the map now contains 10 items...\n-    BOOST_CHECK(map.size() == 10);\n+    FAST_CHECK(map.size() == 10);\n \n     // ...and that the first item has been discarded\n-    BOOST_CHECK(map.count(-1) == 0);\n+    FAST_CHECK(map.count(-1) == 0);\n \n     // iterate over the map, both with an index and an iterator\n     limitedmap<int, int>::const_iterator it = map.begin();\n     for (int i = 0; i < 10; i++) {\n         // make sure the item is present\n-        BOOST_CHECK(map.count(i) == 1);\n+        FAST_CHECK(map.count(i) == 1);\n \n         // use the iterator to check for the expected key adn value\n-        BOOST_CHECK(it->first == i);\n-        BOOST_CHECK(it->second == i + 1);\n+        FAST_CHECK(it->first == i);\n+        FAST_CHECK(it->second == i + 1);\n         \n         // use find to check for the value\n-        BOOST_CHECK(map.find(i)->second == i + 1);\n+        FAST_CHECK(map.find(i)->second == i + 1);\n         \n         // update and recheck\n         map.update(it, i + 2);\n-        BOOST_CHECK(map.find(i)->second == i + 2);\n+        FAST_CHECK(map.find(i)->second == i + 2);\n \n         it++;\n     }\n \n     // check that we've exhausted the iterator\n-    BOOST_CHECK(it == map.end());\n+    FAST_CHECK(it == map.end());\n \n     // resize the map to 5 items\n     map.max_size(5);\n \n     // check that the max size and size are now 5\n-    BOOST_CHECK(map.max_size() == 5);\n-    BOOST_CHECK(map.size() == 5);\n+    FAST_CHECK(map.max_size() == 5);\n+    FAST_CHECK(map.size() == 5);\n \n     // check that items less than 5 have been discarded\n     // and items greater than 5 are retained\n     for (int i = 0; i < 10; i++) {\n         if (i < 5) {\n-            BOOST_CHECK(map.count(i) == 0);\n+            FAST_CHECK(map.count(i) == 0);\n         } else {\n-            BOOST_CHECK(map.count(i) == 1);\n+            FAST_CHECK(map.count(i) == 1);\n         }\n     }\n \n@@ -87,15 +87,15 @@ BOOST_AUTO_TEST_CASE(limitedmap_test)\n     }\n \n     // check that the size is unaffected\n-    BOOST_CHECK(map.size() == 5);\n+    FAST_CHECK(map.size() == 5);\n \n     // erase the remaining elements\n     for (int i = 5; i < 10; i++) {\n         map.erase(i);\n     }\n \n     // check that the map is now empty\n-    BOOST_CHECK(map.empty());\n+    FAST_CHECK(map.empty());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "b7ade445856b45e33d781b8cd96a3f4a1c78e4e1",
        "filename": "src/test/main_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/main_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/main_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/main_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -18,15 +18,15 @@ static void TestBlockSubsidyHalvings(const Consensus::Params& consensusParams)\n     CAmount nInitialSubsidy = 50 * COIN;\n \n     CAmount nPreviousSubsidy = nInitialSubsidy * 2; // for height == 0\n-    BOOST_CHECK_EQUAL(nPreviousSubsidy, nInitialSubsidy * 2);\n+    FAST_CHECK_EQUAL(nPreviousSubsidy, nInitialSubsidy * 2);\n     for (int nHalvings = 0; nHalvings < maxHalvings; nHalvings++) {\n         int nHeight = nHalvings * consensusParams.nSubsidyHalvingInterval;\n         CAmount nSubsidy = GetBlockSubsidy(nHeight, consensusParams);\n-        BOOST_CHECK(nSubsidy <= nInitialSubsidy);\n-        BOOST_CHECK_EQUAL(nSubsidy, nPreviousSubsidy / 2);\n+        FAST_CHECK(nSubsidy <= nInitialSubsidy);\n+        FAST_CHECK_EQUAL(nSubsidy, nPreviousSubsidy / 2);\n         nPreviousSubsidy = nSubsidy;\n     }\n-    BOOST_CHECK_EQUAL(GetBlockSubsidy(maxHalvings * consensusParams.nSubsidyHalvingInterval, consensusParams), 0);\n+    FAST_CHECK_EQUAL(GetBlockSubsidy(maxHalvings * consensusParams.nSubsidyHalvingInterval, consensusParams), 0);\n }\n \n static void TestBlockSubsidyHalvings(int nSubsidyHalvingInterval)\n@@ -49,11 +49,11 @@ BOOST_AUTO_TEST_CASE(subsidy_limit_test)\n     CAmount nSum = 0;\n     for (int nHeight = 0; nHeight < 14000000; nHeight += 1000) {\n         CAmount nSubsidy = GetBlockSubsidy(nHeight, consensusParams);\n-        BOOST_CHECK(nSubsidy <= 50 * COIN);\n+        FAST_CHECK(nSubsidy <= 50 * COIN);\n         nSum += nSubsidy * 1000;\n-        BOOST_CHECK(MoneyRange(nSum));\n+        FAST_CHECK(MoneyRange(nSum));\n     }\n-    BOOST_CHECK_EQUAL(nSum, 2099999997690000ULL);\n+    FAST_CHECK_EQUAL(nSum, 2099999997690000ULL);\n }\n \n bool ReturnFalse() { return false; }\n@@ -62,14 +62,14 @@ bool ReturnTrue() { return true; }\n BOOST_AUTO_TEST_CASE(test_combiner_all)\n {\n     boost::signals2::signal<bool (), CombinerAll> Test;\n-    BOOST_CHECK(Test());\n+    FAST_CHECK(Test());\n     Test.connect(&ReturnFalse);\n-    BOOST_CHECK(!Test());\n+    FAST_CHECK(!Test());\n     Test.connect(&ReturnTrue);\n-    BOOST_CHECK(!Test());\n+    FAST_CHECK(!Test());\n     Test.disconnect(&ReturnFalse);\n-    BOOST_CHECK(Test());\n+    FAST_CHECK(Test());\n     Test.disconnect(&ReturnTrue);\n-    BOOST_CHECK(Test());\n+    FAST_CHECK(Test());\n }\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "f9d277a2b669f8f53f125e5b9b138f3fdcbdfe32",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 47,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -59,12 +59,12 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n \n     // Nothing in pool, remove should do nothing:\n     testPool.removeRecursive(txParent, removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 0);\n+    FAST_CHECK_EQUAL(removed.size(), 0);\n \n     // Just the parent:\n     testPool.addUnchecked(txParent.GetHash(), entry.FromTx(txParent));\n     testPool.removeRecursive(txParent, removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 1);\n+    FAST_CHECK_EQUAL(removed.size(), 1);\n     removed.clear();\n     \n     // Parent, children, grandchildren:\n@@ -76,17 +76,17 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     }\n     // Remove Child[0], GrandChild[0] should be removed:\n     testPool.removeRecursive(txChild[0], removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 2);\n+    FAST_CHECK_EQUAL(removed.size(), 2);\n     removed.clear();\n     // ... make sure grandchild and child are gone:\n     testPool.removeRecursive(txGrandChild[0], removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 0);\n+    FAST_CHECK_EQUAL(removed.size(), 0);\n     testPool.removeRecursive(txChild[0], removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 0);\n+    FAST_CHECK_EQUAL(removed.size(), 0);\n     // Remove parent, all children/grandchildren should go:\n     testPool.removeRecursive(txParent, removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 5);\n-    BOOST_CHECK_EQUAL(testPool.size(), 0);\n+    FAST_CHECK_EQUAL(removed.size(), 5);\n+    FAST_CHECK_EQUAL(testPool.size(), 0);\n     removed.clear();\n \n     // Add children and grandchildren, but NOT the parent (simulate the parent being in a block)\n@@ -98,19 +98,19 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     // Now remove the parent, as might happen if a block-re-org occurs but the parent cannot be\n     // put into the mempool (maybe because it is non-standard):\n     testPool.removeRecursive(txParent, removed);\n-    BOOST_CHECK_EQUAL(removed.size(), 6);\n-    BOOST_CHECK_EQUAL(testPool.size(), 0);\n+    FAST_CHECK_EQUAL(removed.size(), 6);\n+    FAST_CHECK_EQUAL(testPool.size(), 0);\n     removed.clear();\n }\n \n template<typename name>\n void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder)\n {\n-    BOOST_CHECK_EQUAL(pool.size(), sortedOrder.size());\n+    FAST_CHECK_EQUAL(pool.size(), sortedOrder.size());\n     typename CTxMemPool::indexed_transaction_set::index<name>::type::iterator it = pool.mapTx.get<name>().begin();\n     int count=0;\n     for (; it != pool.mapTx.get<name>().end(); ++it, ++count) {\n-        BOOST_CHECK_EQUAL(it->GetTx().GetHash().ToString(), sortedOrder[count]);\n+        FAST_CHECK_EQUAL(it->GetTx().GetHash().ToString(), sortedOrder[count]);\n     }\n }\n \n@@ -156,7 +156,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     entry.nTime = 1;\n     entry.dPriority = 10.0;\n     pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));\n-    BOOST_CHECK_EQUAL(pool.size(), 5);\n+    FAST_CHECK_EQUAL(pool.size(), 5);\n \n     std::vector<std::string> sortedOrder;\n     sortedOrder.resize(5);\n@@ -174,7 +174,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n     pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));\n-    BOOST_CHECK_EQUAL(pool.size(), 6);\n+    FAST_CHECK_EQUAL(pool.size(), 6);\n     // Check that at this point, tx6 is sorted low\n     sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n     CheckSort<descendant_score>(pool, sortedOrder);\n@@ -193,11 +193,11 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n \n     CTxMemPool::setEntries setAncestorsCalculated;\n     std::string dummy;\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(2000000LL).FromTx(tx7), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n-    BOOST_CHECK(setAncestorsCalculated == setAncestors);\n+    FAST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(2000000LL).FromTx(tx7), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    FAST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(tx7.GetHash(), entry.FromTx(tx7), setAncestors);\n-    BOOST_CHECK_EQUAL(pool.size(), 7);\n+    FAST_CHECK_EQUAL(pool.size(), 7);\n \n     // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n     sortedOrder.erase(sortedOrder.begin());\n@@ -231,7 +231,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     pool.addUnchecked(tx9.GetHash(), entry.Fee(0LL).Time(3).FromTx(tx9), setAncestors);\n \n     // tx9 should be sorted low\n-    BOOST_CHECK_EQUAL(pool.size(), 9);\n+    FAST_CHECK_EQUAL(pool.size(), 9);\n     sortedOrder.insert(sortedOrder.begin(), tx9.GetHash().ToString());\n     CheckSort<descendant_score>(pool, sortedOrder);\n \n@@ -251,8 +251,8 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx10.vout[0].nValue = 10 * COIN;\n \n     setAncestorsCalculated.clear();\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(200000LL).Time(4).FromTx(tx10), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n-    BOOST_CHECK(setAncestorsCalculated == setAncestors);\n+    FAST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(200000LL).Time(4).FromTx(tx10), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    FAST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(tx10.GetHash(), entry.FromTx(tx10), setAncestors);\n \n@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     CheckSort<descendant_score>(pool, sortedOrder);\n \n     // there should be 10 transactions in the mempool\n-    BOOST_CHECK_EQUAL(pool.size(), 10);\n+    FAST_CHECK_EQUAL(pool.size(), 10);\n \n     // Now try removing tx10 and verify the sort order returns to normal\n     std::list<CTransaction> removed;\n@@ -359,7 +359,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx5.vout[0].nValue = 11 * COIN;\n     pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));\n-    BOOST_CHECK_EQUAL(pool.size(), 5);\n+    FAST_CHECK_EQUAL(pool.size(), 5);\n \n     std::vector<std::string> sortedOrder;\n     sortedOrder.resize(5);\n@@ -388,7 +388,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     uint64_t tx6Size = GetVirtualTransactionSize(tx6);\n \n     pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));\n-    BOOST_CHECK_EQUAL(pool.size(), 6);\n+    FAST_CHECK_EQUAL(pool.size(), 6);\n     sortedOrder.push_back(tx6.GetHash().ToString());\n     CheckSort<ancestor_score>(pool, sortedOrder);\n \n@@ -406,7 +406,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n \n     //CTxMemPoolEntry entry7(tx7, fee, 2, 10.0, 1, true);\n     pool.addUnchecked(tx7.GetHash(), entry.Fee(fee).FromTx(tx7));\n-    BOOST_CHECK_EQUAL(pool.size(), 7);\n+    FAST_CHECK_EQUAL(pool.size(), 7);\n     sortedOrder.insert(sortedOrder.begin()+1, tx7.GetHash().ToString());\n     CheckSort<ancestor_score>(pool, sortedOrder);\n \n@@ -446,12 +446,12 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     pool.addUnchecked(tx2.GetHash(), entry.Fee(5000LL).FromTx(tx2, &pool));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage()); // should do nothing\n-    BOOST_CHECK(pool.exists(tx1.GetHash()));\n-    BOOST_CHECK(pool.exists(tx2.GetHash()));\n+    FAST_CHECK(pool.exists(tx1.GetHash()));\n+    FAST_CHECK(pool.exists(tx2.GetHash()));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // should remove the lower-feerate transaction\n-    BOOST_CHECK(pool.exists(tx1.GetHash()));\n-    BOOST_CHECK(!pool.exists(tx2.GetHash()));\n+    FAST_CHECK(pool.exists(tx1.GetHash()));\n+    FAST_CHECK(!pool.exists(tx2.GetHash()));\n \n     pool.addUnchecked(tx2.GetHash(), entry.FromTx(tx2, &pool));\n     CMutableTransaction tx3 = CMutableTransaction();\n@@ -464,17 +464,17 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     pool.addUnchecked(tx3.GetHash(), entry.Fee(20000LL).FromTx(tx3, &pool));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // tx3 should pay for tx2 (CPFP)\n-    BOOST_CHECK(!pool.exists(tx1.GetHash()));\n-    BOOST_CHECK(pool.exists(tx2.GetHash()));\n-    BOOST_CHECK(pool.exists(tx3.GetHash()));\n+    FAST_CHECK(!pool.exists(tx1.GetHash()));\n+    FAST_CHECK(pool.exists(tx2.GetHash()));\n+    FAST_CHECK(pool.exists(tx3.GetHash()));\n \n     pool.TrimToSize(GetVirtualTransactionSize(tx1)); // mempool is limited to tx1's size in memory usage, so nothing fits\n-    BOOST_CHECK(!pool.exists(tx1.GetHash()));\n-    BOOST_CHECK(!pool.exists(tx2.GetHash()));\n-    BOOST_CHECK(!pool.exists(tx3.GetHash()));\n+    FAST_CHECK(!pool.exists(tx1.GetHash()));\n+    FAST_CHECK(!pool.exists(tx2.GetHash()));\n+    FAST_CHECK(!pool.exists(tx3.GetHash()));\n \n     CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(tx3) + GetVirtualTransactionSize(tx2));\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n \n     CMutableTransaction tx4 = CMutableTransaction();\n     tx4.vin.resize(2);\n@@ -531,19 +531,19 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n \n     // we only require this remove, at max, 2 txn, because its not clear what we're really optimizing for aside from that\n     pool.TrimToSize(pool.DynamicMemoryUsage() - 1);\n-    BOOST_CHECK(pool.exists(tx4.GetHash()));\n-    BOOST_CHECK(pool.exists(tx6.GetHash()));\n-    BOOST_CHECK(!pool.exists(tx7.GetHash()));\n+    FAST_CHECK(pool.exists(tx4.GetHash()));\n+    FAST_CHECK(pool.exists(tx6.GetHash()));\n+    FAST_CHECK(!pool.exists(tx7.GetHash()));\n \n     if (!pool.exists(tx5.GetHash()))\n         pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5, &pool));\n     pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7, &pool));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7\n-    BOOST_CHECK(pool.exists(tx4.GetHash()));\n-    BOOST_CHECK(!pool.exists(tx5.GetHash()));\n-    BOOST_CHECK(pool.exists(tx6.GetHash()));\n-    BOOST_CHECK(!pool.exists(tx7.GetHash()));\n+    FAST_CHECK(pool.exists(tx4.GetHash()));\n+    FAST_CHECK(!pool.exists(tx5.GetHash()));\n+    FAST_CHECK(pool.exists(tx6.GetHash()));\n+    FAST_CHECK(!pool.exists(tx7.GetHash()));\n \n     pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5, &pool));\n     pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7, &pool));\n@@ -552,27 +552,27 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     std::list<CTransaction> conflicts;\n     SetMockTime(42);\n     SetMockTime(42 + CTxMemPool::ROLLING_FEE_HALFLIFE);\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n     // ... we should keep the same min fee until we get a block\n     pool.removeForBlock(vtx, 1, conflicts);\n     SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE);\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), (maxFeeRateRemoved.GetFeePerK() + 1000)/2);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), (maxFeeRateRemoved.GetFeePerK() + 1000)/2);\n     // ... then feerate should drop 1/2 each halflife\n \n     SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2);\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 5 / 2).GetFeePerK(), (maxFeeRateRemoved.GetFeePerK() + 1000)/4);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 5 / 2).GetFeePerK(), (maxFeeRateRemoved.GetFeePerK() + 1000)/4);\n     // ... with a 1/2 halflife when mempool is < 1/2 its target size\n \n     SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 9 / 2).GetFeePerK(), (maxFeeRateRemoved.GetFeePerK() + 1000)/8);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 9 / 2).GetFeePerK(), (maxFeeRateRemoved.GetFeePerK() + 1000)/8);\n     // ... with a 1/4 halflife when mempool is < 1/4 its target size\n \n     SetMockTime(42 + 7*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 1000);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 1000);\n     // ... but feerate should never drop below 1000\n \n     SetMockTime(42 + 8*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);\n-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 0);\n+    FAST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 0);\n     // ... unless it has gone all the way to 0 (after getting past 1000/2)\n \n     SetMockTime(0);"
      },
      {
        "sha": "f78be4824ee196a0318955390332f85ce2bcca5f",
        "filename": "src/test/merkle_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/merkle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/merkle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkle_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -91,7 +91,7 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n             // Compute the root of the block before mutating it.\n             bool unmutatedMutated = false;\n             uint256 unmutatedRoot = BlockMerkleRoot(block, &unmutatedMutated);\n-            BOOST_CHECK(unmutatedMutated == false);\n+            FAST_CHECK(unmutatedMutated == false);\n             // Optionally mutate by duplicating the last transactions, resulting in the same merkle root.\n             block.vtx.resize(ntx3);\n             for (int j = 0; j < duplicate1; j++) {\n@@ -110,11 +110,11 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n             // Compute the merkle root using the new mechanism.\n             bool newMutated = false;\n             uint256 newRoot = BlockMerkleRoot(block, &newMutated);\n-            BOOST_CHECK(oldRoot == newRoot);\n-            BOOST_CHECK(newRoot == unmutatedRoot);\n-            BOOST_CHECK((newRoot == uint256()) == (ntx == 0));\n-            BOOST_CHECK(oldMutated == newMutated);\n-            BOOST_CHECK(newMutated == !!mutate);\n+            FAST_CHECK(oldRoot == newRoot);\n+            FAST_CHECK(newRoot == unmutatedRoot);\n+            FAST_CHECK((newRoot == uint256()) == (ntx == 0));\n+            FAST_CHECK(oldMutated == newMutated);\n+            FAST_CHECK(newMutated == !!mutate);\n             // If no mutation was done (once for every ntx value), try up to 16 branches.\n             if (mutate == 0) {\n                 for (int loop = 0; loop < std::min(ntx, 16); loop++) {\n@@ -125,8 +125,8 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n                     }\n                     std::vector<uint256> newBranch = BlockMerkleBranch(block, mtx);\n                     std::vector<uint256> oldBranch = BlockGetMerkleBranch(block, merkleTree, mtx);\n-                    BOOST_CHECK(oldBranch == newBranch);\n-                    BOOST_CHECK(ComputeMerkleRootFromBranch(block.vtx[mtx].GetHash(), newBranch, mtx) == oldRoot);\n+                    FAST_CHECK(oldBranch == newBranch);\n+                    FAST_CHECK(ComputeMerkleRootFromBranch(block.vtx[mtx].GetHash(), newBranch, mtx) == oldRoot);\n                 }\n             }\n         }"
      },
      {
        "sha": "935f08084a61358692e1e1199c1fcbd7069ba94e",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -106,9 +106,9 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n     mempool.addUnchecked(hashHighFeeTx, entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n     CBlockTemplate *pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n-    BOOST_CHECK(pblocktemplate->block.vtx[1].GetHash() == hashParentTx);\n-    BOOST_CHECK(pblocktemplate->block.vtx[2].GetHash() == hashHighFeeTx);\n-    BOOST_CHECK(pblocktemplate->block.vtx[3].GetHash() == hashMediumFeeTx);\n+    FAST_CHECK(pblocktemplate->block.vtx[1].GetHash() == hashParentTx);\n+    FAST_CHECK(pblocktemplate->block.vtx[2].GetHash() == hashHighFeeTx);\n+    FAST_CHECK(pblocktemplate->block.vtx[3].GetHash() == hashMediumFeeTx);\n \n     // Test that a package below the min relay fee doesn't get included\n     tx.vin[0].prevout.hash = hashHighFeeTx;\n@@ -128,8 +128,8 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n     pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n-        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashFreeTx);\n-        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashLowFeeTx);\n+        FAST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashFreeTx);\n+        FAST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashLowFeeTx);\n     }\n \n     // Test that packages above the min relay fee do get included, even if one\n@@ -141,8 +141,8 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n     hashLowFeeTx = tx.GetHash();\n     mempool.addUnchecked(hashLowFeeTx, entry.Fee(feeToUse+2).FromTx(tx));\n     pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n-    BOOST_CHECK(pblocktemplate->block.vtx[4].GetHash() == hashFreeTx);\n-    BOOST_CHECK(pblocktemplate->block.vtx[5].GetHash() == hashLowFeeTx);\n+    FAST_CHECK(pblocktemplate->block.vtx[4].GetHash() == hashFreeTx);\n+    FAST_CHECK(pblocktemplate->block.vtx[5].GetHash() == hashLowFeeTx);\n \n     // Test that transaction selection properly updates ancestor fee\n     // calculations as ancestor transactions get included in a block.\n@@ -165,8 +165,8 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n \n     // Verify that this tx isn't selected.\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n-        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashFreeTx2);\n-        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashLowFeeTx2);\n+        FAST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashFreeTx2);\n+        FAST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashLowFeeTx2);\n     }\n \n     // This tx will be mineable, and should cause hashLowFeeTx2 to be selected\n@@ -175,7 +175,7 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n     mempool.addUnchecked(tx.GetHash(), entry.Fee(10000).FromTx(tx));\n     pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n-    BOOST_CHECK(pblocktemplate->block.vtx[8].GetHash() == hashLowFeeTx2);\n+    FAST_CHECK(pblocktemplate->block.vtx[8].GetHash() == hashLowFeeTx2);\n }\n \n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n@@ -197,7 +197,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     fCheckpointsEnabled = false;\n \n     // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 100 blocks :)\n@@ -222,14 +222,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n-        BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));\n-        BOOST_CHECK(state.IsValid());\n+        FAST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));\n+        FAST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n     delete pblocktemplate;\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n \n     const CAmount BLOCKSUBSIDY = 50*COIN;\n@@ -254,7 +254,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n+    FAST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n     mempool.clear();\n \n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -268,7 +268,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -289,14 +289,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // orphan in mempool, template creation fails\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n+    FAST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n     mempool.clear();\n \n     // child with higher priority than parent\n@@ -313,7 +313,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -325,7 +325,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     hash = tx.GetHash();\n     // give it a fee so it'll get mined\n     mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n-    BOOST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n+    FAST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n     mempool.clear();\n \n     // invalid (pre-p2sh) txn in mempool, template creation fails\n@@ -342,7 +342,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue -= LOWFEE;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n-    BOOST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n+    FAST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n     mempool.clear();\n \n     // double spend txn pair in mempool, template creation fails\n@@ -355,7 +355,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n+    FAST_CHECK_THROW(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error);\n     mempool.clear();\n \n     // subsidy changing\n@@ -371,7 +371,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         chainActive.SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     // Extend to a 210000-long block chain.\n     while (chainActive.Tip()->nHeight < 210000) {\n@@ -384,7 +384,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         chainActive.SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     // Delete the dummy blocks again.\n     while (chainActive.Tip()->nHeight > nHeight) {\n@@ -416,22 +416,22 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.nLockTime = 0;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n-    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n+    FAST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    FAST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    FAST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n \n     // relative time locked\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((chainActive.Tip()->GetMedianTimePast()+1-chainActive[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n     prevheights[0] = baseheight + 2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    FAST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    FAST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n \n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n-    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n+    FAST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n \n@@ -442,9 +442,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.nLockTime = chainActive.Tip()->nHeight + 1;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n+    FAST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n+    FAST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    FAST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n \n     // absolute time locked\n     tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n@@ -453,40 +453,40 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     prevheights[0] = baseheight + 4;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n+    FAST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n+    FAST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    FAST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n \n     // mempool-dependent transactions (not added)\n     tx.vin[0].prevout.hash = hash;\n     prevheights[0] = chainActive.Tip()->nHeight + 1;\n     tx.nLockTime = 0;\n     tx.vin[0].nSequence = 0;\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    FAST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    FAST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n     tx.vin[0].nSequence = 1;\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    FAST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG;\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    FAST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    FAST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n \n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n \n     // None of the of the absolute height/time locked tx should have made\n     // it into the template because we still check IsFinalTx in CreateNewBlock,\n     // but relative locked txs will if inconsistently added to mempool.\n     // For now these will still generate a valid template until BIP68 soft fork\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n+    FAST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n     delete pblocktemplate;\n     // However if we advance height by 1 and time by 512, all of them should be mined\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n     chainActive.Tip()->nHeight++;\n     SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n \n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n+    FAST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    FAST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n     delete pblocktemplate;\n \n     chainActive.Tip()->nHeight--;"
      },
      {
        "sha": "b5b180a39263bc8b775931f8fbfef41d23c5ce9b",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 37,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -33,7 +33,7 @@ sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction,\n     BOOST_FOREACH(const CKey &key, keys)\n     {\n         vector<unsigned char> vchSig;\n-        BOOST_CHECK(key.Sign(hash, vchSig));\n+        FAST_CHECK(key.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         result << vchSig;\n     }\n@@ -82,7 +82,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n+    FAST_CHECK(VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n@@ -117,7 +117,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     }\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n+    FAST_CHECK(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n \n \n@@ -150,19 +150,19 @@ BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n \n     CScript a_and_b;\n     a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(::IsStandard(a_and_b, whichType));\n+    FAST_CHECK(::IsStandard(a_and_b, whichType));\n \n     CScript a_or_b;\n     a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(::IsStandard(a_or_b, whichType));\n+    FAST_CHECK(::IsStandard(a_or_b, whichType));\n \n     CScript escrow;\n     escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(::IsStandard(escrow, whichType));\n+    FAST_CHECK(::IsStandard(escrow, whichType));\n \n     CScript one_of_four;\n     one_of_four << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << ToByteVector(key[3].GetPubKey()) << OP_4 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(!::IsStandard(one_of_four, whichType));\n+    FAST_CHECK(!::IsStandard(one_of_four, whichType));\n \n     CScript malformed[6];\n     malformed[0] << OP_3 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n@@ -173,7 +173,7 @@ BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n     malformed[5] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey());\n \n     for (int i = 0; i < 6; i++)\n-        BOOST_CHECK(!::IsStandard(malformed[i], whichType));\n+        FAST_CHECK(!::IsStandard(malformed[i], whichType));\n }\n \n BOOST_AUTO_TEST_CASE(multisig_Solver1)\n@@ -204,64 +204,64 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n         txnouttype whichType;\n         CScript s;\n         s << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK(solutions.size() == 1);\n+        FAST_CHECK(Solver(s, whichType, solutions));\n+        FAST_CHECK(solutions.size() == 1);\n         CTxDestination addr;\n-        BOOST_CHECK(ExtractDestination(s, addr));\n-        BOOST_CHECK(addr == keyaddr[0]);\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n+        FAST_CHECK(ExtractDestination(s, addr));\n+        FAST_CHECK(addr == keyaddr[0]);\n+        FAST_CHECK(IsMine(keystore, s));\n+        FAST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n         vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_DUP << OP_HASH160 << ToByteVector(key[0].GetPubKey().GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK(solutions.size() == 1);\n+        FAST_CHECK(Solver(s, whichType, solutions));\n+        FAST_CHECK(solutions.size() == 1);\n         CTxDestination addr;\n-        BOOST_CHECK(ExtractDestination(s, addr));\n-        BOOST_CHECK(addr == keyaddr[0]);\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n+        FAST_CHECK(ExtractDestination(s, addr));\n+        FAST_CHECK(addr == keyaddr[0]);\n+        FAST_CHECK(IsMine(keystore, s));\n+        FAST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n         vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK_EQUAL(solutions.size(), 4U);\n+        FAST_CHECK(Solver(s, whichType, solutions));\n+        FAST_CHECK_EQUAL(solutions.size(), 4U);\n         CTxDestination addr;\n-        BOOST_CHECK(!ExtractDestination(s, addr));\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n-        BOOST_CHECK(!IsMine(partialkeystore, s));\n+        FAST_CHECK(!ExtractDestination(s, addr));\n+        FAST_CHECK(IsMine(keystore, s));\n+        FAST_CHECK(!IsMine(emptykeystore, s));\n+        FAST_CHECK(!IsMine(partialkeystore, s));\n     }\n     {\n         vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK_EQUAL(solutions.size(), 4U);\n+        FAST_CHECK(Solver(s, whichType, solutions));\n+        FAST_CHECK_EQUAL(solutions.size(), 4U);\n         vector<CTxDestination> addrs;\n         int nRequired;\n-        BOOST_CHECK(ExtractDestinations(s, whichType, addrs, nRequired));\n-        BOOST_CHECK(addrs[0] == keyaddr[0]);\n-        BOOST_CHECK(addrs[1] == keyaddr[1]);\n-        BOOST_CHECK(nRequired == 1);\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n-        BOOST_CHECK(!IsMine(partialkeystore, s));\n+        FAST_CHECK(ExtractDestinations(s, whichType, addrs, nRequired));\n+        FAST_CHECK(addrs[0] == keyaddr[0]);\n+        FAST_CHECK(addrs[1] == keyaddr[1]);\n+        FAST_CHECK(nRequired == 1);\n+        FAST_CHECK(IsMine(keystore, s));\n+        FAST_CHECK(!IsMine(emptykeystore, s));\n+        FAST_CHECK(!IsMine(partialkeystore, s));\n     }\n     {\n         vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK(solutions.size() == 5);\n+        FAST_CHECK(Solver(s, whichType, solutions));\n+        FAST_CHECK(solutions.size() == 5);\n     }\n }\n "
      },
      {
        "sha": "9c5974050fc8625c1b9c7ec2998c52676cb6da8b",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -96,7 +96,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     bool exceptionThrown = false;\n     CAddrMan addrman1;\n \n-    BOOST_CHECK(addrman1.size() == 0);\n+    FAST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n         ssPeers1 >> FLATDATA(pchMsgTmp);\n@@ -105,17 +105,17 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n         exceptionThrown = true;\n     }\n \n-    BOOST_CHECK(addrman1.size() == 3);\n-    BOOST_CHECK(exceptionThrown == false);\n+    FAST_CHECK(addrman1.size() == 3);\n+    FAST_CHECK(exceptionThrown == false);\n \n     // Test that CAddrDB::Read creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n     CAddrMan addrman2;\n     CAddrDB adb;\n-    BOOST_CHECK(addrman2.size() == 0);\n+    FAST_CHECK(addrman2.size() == 0);\n     adb.Read(addrman2, ssPeers2);\n-    BOOST_CHECK(addrman2.size() == 3);\n+    FAST_CHECK(addrman2.size() == 3);\n }\n \n \n@@ -128,7 +128,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n     CAddrMan addrman1;\n-    BOOST_CHECK(addrman1.size() == 0);\n+    FAST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n         ssPeers1 >> FLATDATA(pchMsgTmp);\n@@ -137,17 +137,17 @@ BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n         exceptionThrown = true;\n     }\n     // Even through de-serialization failed addrman is not left in a clean state.\n-    BOOST_CHECK(addrman1.size() == 1);\n-    BOOST_CHECK(exceptionThrown);\n+    FAST_CHECK(addrman1.size() == 1);\n+    FAST_CHECK(exceptionThrown);\n \n     // Test that CAddrDB::Read leaves addrman in a clean state if de-serialization fails.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n     CAddrMan addrman2;\n     CAddrDB adb;\n-    BOOST_CHECK(addrman2.size() == 0);\n+    FAST_CHECK(addrman2.size() == 0);\n     adb.Read(addrman2, ssPeers2);\n-    BOOST_CHECK(addrman2.size() == 0);\n+    FAST_CHECK(addrman2.size() == 0);\n }\n \n BOOST_AUTO_TEST_CASE(cnode_simple_test)\n@@ -163,13 +163,13 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n \n     // Test that fFeeler is false by default.\n     CNode* pnode1 = new CNode(hSocket, addr, pszDest, fInboundIn);\n-    BOOST_CHECK(pnode1->fInbound == false);\n-    BOOST_CHECK(pnode1->fFeeler == false);\n+    FAST_CHECK(pnode1->fInbound == false);\n+    FAST_CHECK(pnode1->fFeeler == false);\n \n     fInboundIn = true;\n     CNode* pnode2 = new CNode(hSocket, addr, pszDest, fInboundIn);\n-    BOOST_CHECK(pnode2->fInbound == true);\n-    BOOST_CHECK(pnode2->fFeeler == false);\n+    FAST_CHECK(pnode2->fInbound == true);\n+    FAST_CHECK(pnode2->fFeeler == false);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c2225d7197bcc8fc143523b551187a85679d8932",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 149,
        "deletions": 149,
        "changes": 298,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -30,37 +30,37 @@ static CSubNet ResolveSubNet(const char* subnet)\n \n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n-    BOOST_CHECK(ResolveIP(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n-    BOOST_CHECK(ResolveIP(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n-    BOOST_CHECK(ResolveIP(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n-    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+    FAST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n+    FAST_CHECK(ResolveIP(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n+    FAST_CHECK(ResolveIP(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n+    FAST_CHECK(ResolveIP(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n+    FAST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n \n }\n \n BOOST_AUTO_TEST_CASE(netbase_properties)\n {\n \n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsIPv4());\n-    BOOST_CHECK(ResolveIP(\"::FFFF:192.168.1.1\").IsIPv4());\n-    BOOST_CHECK(ResolveIP(\"::1\").IsIPv6());\n-    BOOST_CHECK(ResolveIP(\"10.0.0.1\").IsRFC1918());\n-    BOOST_CHECK(ResolveIP(\"192.168.1.1\").IsRFC1918());\n-    BOOST_CHECK(ResolveIP(\"172.31.255.255\").IsRFC1918());\n-    BOOST_CHECK(ResolveIP(\"2001:0DB8::\").IsRFC3849());\n-    BOOST_CHECK(ResolveIP(\"169.254.1.1\").IsRFC3927());\n-    BOOST_CHECK(ResolveIP(\"2002::1\").IsRFC3964());\n-    BOOST_CHECK(ResolveIP(\"FC00::\").IsRFC4193());\n-    BOOST_CHECK(ResolveIP(\"2001::2\").IsRFC4380());\n-    BOOST_CHECK(ResolveIP(\"2001:10::\").IsRFC4843());\n-    BOOST_CHECK(ResolveIP(\"FE80::\").IsRFC4862());\n-    BOOST_CHECK(ResolveIP(\"64:FF9B::\").IsRFC6052());\n-    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").IsTor());\n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsLocal());\n-    BOOST_CHECK(ResolveIP(\"::1\").IsLocal());\n-    BOOST_CHECK(ResolveIP(\"8.8.8.8\").IsRoutable());\n-    BOOST_CHECK(ResolveIP(\"2001::1\").IsRoutable());\n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsValid());\n+    FAST_CHECK(ResolveIP(\"127.0.0.1\").IsIPv4());\n+    FAST_CHECK(ResolveIP(\"::FFFF:192.168.1.1\").IsIPv4());\n+    FAST_CHECK(ResolveIP(\"::1\").IsIPv6());\n+    FAST_CHECK(ResolveIP(\"10.0.0.1\").IsRFC1918());\n+    FAST_CHECK(ResolveIP(\"192.168.1.1\").IsRFC1918());\n+    FAST_CHECK(ResolveIP(\"172.31.255.255\").IsRFC1918());\n+    FAST_CHECK(ResolveIP(\"2001:0DB8::\").IsRFC3849());\n+    FAST_CHECK(ResolveIP(\"169.254.1.1\").IsRFC3927());\n+    FAST_CHECK(ResolveIP(\"2002::1\").IsRFC3964());\n+    FAST_CHECK(ResolveIP(\"FC00::\").IsRFC4193());\n+    FAST_CHECK(ResolveIP(\"2001::2\").IsRFC4380());\n+    FAST_CHECK(ResolveIP(\"2001:10::\").IsRFC4843());\n+    FAST_CHECK(ResolveIP(\"FE80::\").IsRFC4862());\n+    FAST_CHECK(ResolveIP(\"64:FF9B::\").IsRFC6052());\n+    FAST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").IsTor());\n+    FAST_CHECK(ResolveIP(\"127.0.0.1\").IsLocal());\n+    FAST_CHECK(ResolveIP(\"::1\").IsLocal());\n+    FAST_CHECK(ResolveIP(\"8.8.8.8\").IsRoutable());\n+    FAST_CHECK(ResolveIP(\"2001::1\").IsRoutable());\n+    FAST_CHECK(ResolveIP(\"127.0.0.1\").IsValid());\n \n }\n \n@@ -74,21 +74,21 @@ bool static TestSplitHost(string test, string host, int port)\n \n BOOST_AUTO_TEST_CASE(netbase_splithost)\n {\n-    BOOST_CHECK(TestSplitHost(\"www.bitcoin.org\", \"www.bitcoin.org\", -1));\n-    BOOST_CHECK(TestSplitHost(\"[www.bitcoin.org]\", \"www.bitcoin.org\", -1));\n-    BOOST_CHECK(TestSplitHost(\"www.bitcoin.org:80\", \"www.bitcoin.org\", 80));\n-    BOOST_CHECK(TestSplitHost(\"[www.bitcoin.org]:80\", \"www.bitcoin.org\", 80));\n-    BOOST_CHECK(TestSplitHost(\"127.0.0.1\", \"127.0.0.1\", -1));\n-    BOOST_CHECK(TestSplitHost(\"127.0.0.1:8333\", \"127.0.0.1\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"[127.0.0.1]\", \"127.0.0.1\", -1));\n-    BOOST_CHECK(TestSplitHost(\"[127.0.0.1]:8333\", \"127.0.0.1\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"::ffff:127.0.0.1\", \"::ffff:127.0.0.1\", -1));\n-    BOOST_CHECK(TestSplitHost(\"[::ffff:127.0.0.1]:8333\", \"::ffff:127.0.0.1\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"[::]:8333\", \"::\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"::8333\", \"::8333\", -1));\n-    BOOST_CHECK(TestSplitHost(\":8333\", \"\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"[]:8333\", \"\", 8333));\n-    BOOST_CHECK(TestSplitHost(\"\", \"\", -1));\n+    FAST_CHECK(TestSplitHost(\"www.bitcoin.org\", \"www.bitcoin.org\", -1));\n+    FAST_CHECK(TestSplitHost(\"[www.bitcoin.org]\", \"www.bitcoin.org\", -1));\n+    FAST_CHECK(TestSplitHost(\"www.bitcoin.org:80\", \"www.bitcoin.org\", 80));\n+    FAST_CHECK(TestSplitHost(\"[www.bitcoin.org]:80\", \"www.bitcoin.org\", 80));\n+    FAST_CHECK(TestSplitHost(\"127.0.0.1\", \"127.0.0.1\", -1));\n+    FAST_CHECK(TestSplitHost(\"127.0.0.1:8333\", \"127.0.0.1\", 8333));\n+    FAST_CHECK(TestSplitHost(\"[127.0.0.1]\", \"127.0.0.1\", -1));\n+    FAST_CHECK(TestSplitHost(\"[127.0.0.1]:8333\", \"127.0.0.1\", 8333));\n+    FAST_CHECK(TestSplitHost(\"::ffff:127.0.0.1\", \"::ffff:127.0.0.1\", -1));\n+    FAST_CHECK(TestSplitHost(\"[::ffff:127.0.0.1]:8333\", \"::ffff:127.0.0.1\", 8333));\n+    FAST_CHECK(TestSplitHost(\"[::]:8333\", \"::\", 8333));\n+    FAST_CHECK(TestSplitHost(\"::8333\", \"::8333\", -1));\n+    FAST_CHECK(TestSplitHost(\":8333\", \"\", 8333));\n+    FAST_CHECK(TestSplitHost(\"[]:8333\", \"\", 8333));\n+    FAST_CHECK(TestSplitHost(\"\", \"\", -1));\n }\n \n bool static TestParse(string src, string canon)\n@@ -99,13 +99,13 @@ bool static TestParse(string src, string canon)\n \n BOOST_AUTO_TEST_CASE(netbase_lookupnumeric)\n {\n-    BOOST_CHECK(TestParse(\"127.0.0.1\", \"127.0.0.1:65535\"));\n-    BOOST_CHECK(TestParse(\"127.0.0.1:8333\", \"127.0.0.1:8333\"));\n-    BOOST_CHECK(TestParse(\"::ffff:127.0.0.1\", \"127.0.0.1:65535\"));\n-    BOOST_CHECK(TestParse(\"::\", \"[::]:65535\"));\n-    BOOST_CHECK(TestParse(\"[::]:8333\", \"[::]:8333\"));\n-    BOOST_CHECK(TestParse(\"[127.0.0.1]\", \"127.0.0.1:65535\"));\n-    BOOST_CHECK(TestParse(\":::\", \"[::]:0\"));\n+    FAST_CHECK(TestParse(\"127.0.0.1\", \"127.0.0.1:65535\"));\n+    FAST_CHECK(TestParse(\"127.0.0.1:8333\", \"127.0.0.1:8333\"));\n+    FAST_CHECK(TestParse(\"::ffff:127.0.0.1\", \"127.0.0.1:65535\"));\n+    FAST_CHECK(TestParse(\"::\", \"[::]:65535\"));\n+    FAST_CHECK(TestParse(\"[::]:8333\", \"[::]:8333\"));\n+    FAST_CHECK(TestParse(\"[127.0.0.1]\", \"127.0.0.1:65535\"));\n+    FAST_CHECK(TestParse(\":::\", \"[::]:0\"));\n }\n \n BOOST_AUTO_TEST_CASE(onioncat_test)\n@@ -114,175 +114,175 @@ BOOST_AUTO_TEST_CASE(onioncat_test)\n     // values from https://web.archive.org/web/20121122003543/http://www.cypherpunk.at/onioncat/wiki/OnionCat\n     CNetAddr addr1(ResolveIP(\"5wyqrzbvrdsumnok.onion\"));\n     CNetAddr addr2(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\"));\n-    BOOST_CHECK(addr1 == addr2);\n-    BOOST_CHECK(addr1.IsTor());\n-    BOOST_CHECK(addr1.ToStringIP() == \"5wyqrzbvrdsumnok.onion\");\n-    BOOST_CHECK(addr1.IsRoutable());\n+    FAST_CHECK(addr1 == addr2);\n+    FAST_CHECK(addr1.IsTor());\n+    FAST_CHECK(addr1.ToStringIP() == \"5wyqrzbvrdsumnok.onion\");\n+    FAST_CHECK(addr1.IsRoutable());\n \n }\n \n BOOST_AUTO_TEST_CASE(subnet_test)\n {\n \n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\") == ResolveSubNet(\"1.2.3.0/255.255.255.0\"));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\") != ResolveSubNet(\"1.2.4.0/255.255.255.0\"));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(!ResolveSubNet(\"1.2.2.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(!ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"5.6.7.8\")));\n-    BOOST_CHECK(!ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"5.6.7.8\")));\n-    BOOST_CHECK(ResolveSubNet(\"::ffff:127.0.0.1\").Match(ResolveIP(\"127.0.0.1\")));\n-    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:0/112\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(ResolveSubNet(\"192.168.0.1/24\").Match(ResolveIP(\"192.168.0.2\")));\n-    BOOST_CHECK(ResolveSubNet(\"192.168.0.20/29\").Match(ResolveIP(\"192.168.0.18\")));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n-    BOOST_CHECK(ResolveSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.0/24\") == ResolveSubNet(\"1.2.3.0/255.255.255.0\"));\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.0/24\") != ResolveSubNet(\"1.2.4.0/255.255.255.0\"));\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    FAST_CHECK(!ResolveSubNet(\"1.2.2.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"1.2.3.4\")));\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"1.2.3.4\")));\n+    FAST_CHECK(!ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"5.6.7.8\")));\n+    FAST_CHECK(!ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"5.6.7.8\")));\n+    FAST_CHECK(ResolveSubNet(\"::ffff:127.0.0.1\").Match(ResolveIP(\"127.0.0.1\")));\n+    FAST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    FAST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    FAST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:0/112\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    FAST_CHECK(ResolveSubNet(\"192.168.0.1/24\").Match(ResolveIP(\"192.168.0.2\")));\n+    FAST_CHECK(ResolveSubNet(\"192.168.0.20/29\").Match(ResolveIP(\"192.168.0.18\")));\n+    FAST_CHECK(ResolveSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n+    FAST_CHECK(ResolveSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n+    FAST_CHECK(ResolveSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n     // All-Matching IPv6 Matches arbitrary IPv4 and IPv6\n-    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n+    FAST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    FAST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n     // All-Matching IPv4 does not Match IPv6\n-    BOOST_CHECK(!ResolveSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    FAST_CHECK(!ResolveSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n     // Invalid subnets Match nothing (not even invalid addresses)\n-    BOOST_CHECK(!CSubNet().Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(!ResolveSubNet(\"\").Match(ResolveIP(\"4.5.6.7\")));\n-    BOOST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"0.0.0.0\")));\n-    BOOST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"hab\")));\n+    FAST_CHECK(!CSubNet().Match(ResolveIP(\"1.2.3.4\")));\n+    FAST_CHECK(!ResolveSubNet(\"\").Match(ResolveIP(\"4.5.6.7\")));\n+    FAST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"0.0.0.0\")));\n+    FAST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"hab\")));\n     // Check valid/invalid\n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/0\").IsValid());\n-    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/-1\").IsValid());\n-    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/32\").IsValid());\n-    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/33\").IsValid());\n-    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n-    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n-    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n-    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/128\").IsValid());\n-    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/129\").IsValid());\n-    BOOST_CHECK(!ResolveSubNet(\"fuzzy\").IsValid());\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.0/0\").IsValid());\n+    FAST_CHECK(!ResolveSubNet(\"1.2.3.0/-1\").IsValid());\n+    FAST_CHECK(ResolveSubNet(\"1.2.3.0/32\").IsValid());\n+    FAST_CHECK(!ResolveSubNet(\"1.2.3.0/33\").IsValid());\n+    FAST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n+    FAST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n+    FAST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n+    FAST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/128\").IsValid());\n+    FAST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/129\").IsValid());\n+    FAST_CHECK(!ResolveSubNet(\"fuzzy\").IsValid());\n \n     //CNetAddr constructor test\n-    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).IsValid());\n-    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.1\")));\n-    BOOST_CHECK(!CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.2\")));\n-    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n+    FAST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).IsValid());\n+    FAST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.1\")));\n+    FAST_CHECK(!CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.2\")));\n+    FAST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n \n     CSubNet subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 32);\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n     subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 8);\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n     subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 0);\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n \n     subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"255.255.255.255\"));\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n     subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"255.0.0.0\"));\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n     subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"0.0.0.0\"));\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n \n-    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).IsValid());\n-    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n+    FAST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).IsValid());\n+    FAST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    FAST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    FAST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n \n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.255\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.254\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/31\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/31\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.252\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/30\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/30\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.248\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/29\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/29\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.240\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/28\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/28\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.224\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/27\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/27\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.192\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/26\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/26\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.128\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/25\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/25\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/24\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/24\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.254.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.2.0/23\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.2.0/23\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.252.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/22\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/22\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.248.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/21\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/21\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.240.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/20\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/20\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.224.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/19\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/19\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.192.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/18\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/18\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.128.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/17\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/17\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/16\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/16\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.254.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/15\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/15\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.252.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/14\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/14\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.248.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/13\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/13\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.240.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/12\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/12\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.224.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/11\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/11\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.192.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/10\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/10\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.128.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/9\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/9\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n     subnet = ResolveSubNet(\"1.2.3.4/254.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/7\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/7\");\n     subnet = ResolveSubNet(\"1.2.3.4/252.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/6\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/6\");\n     subnet = ResolveSubNet(\"1.2.3.4/248.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/5\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/5\");\n     subnet = ResolveSubNet(\"1.2.3.4/240.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/4\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/4\");\n     subnet = ResolveSubNet(\"1.2.3.4/224.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/3\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/3\");\n     subnet = ResolveSubNet(\"1.2.3.4/192.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/2\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/2\");\n     subnet = ResolveSubNet(\"1.2.3.4/128.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/1\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/1\");\n     subnet = ResolveSubNet(\"1.2.3.4/0.0.0.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n \n     subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/128\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/128\");\n     subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:0000:0000:0000:0000:0000:0000:0000\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1::/16\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1::/16\");\n     subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"::/0\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"::/0\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.232.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/255.255.232.0\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/255.255.232.0\");\n     subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n+    FAST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n \n }\n \n BOOST_AUTO_TEST_CASE(netbase_getgroup)\n {\n \n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n-    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n-    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n-    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n-    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n-    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n-    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n-    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n+    FAST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n+    FAST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n+    FAST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n+    FAST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n+    FAST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n+    FAST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n+    FAST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n+    FAST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n+    FAST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n+    FAST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n+    FAST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n+    FAST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n \n }\n "
      },
      {
        "sha": "9128fdfd0ac5c30f8dbdc7c15d0b85add873e5f4",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -80,7 +80,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n \n             // verify CPartialMerkleTree's size guarantees\n             unsigned int n = std::min<unsigned int>(nTx, 1 + vMatchTxid1.size()*nHeight);\n-            BOOST_CHECK(ss.size() <= 10 + (258*n+7)/8);\n+            FAST_CHECK(ss.size() <= 10 + (258*n+7)/8);\n \n             // deserialize into a tester copy\n             CPartialMerkleTreeTester pmt2;\n@@ -92,19 +92,19 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             uint256 merkleRoot2 = pmt2.ExtractMatches(vMatchTxid2, vIndex);\n \n             // check that it has the same merkle root as the original, and a valid one\n-            BOOST_CHECK(merkleRoot1 == merkleRoot2);\n-            BOOST_CHECK(!merkleRoot2.IsNull());\n+            FAST_CHECK(merkleRoot1 == merkleRoot2);\n+            FAST_CHECK(!merkleRoot2.IsNull());\n \n             // check that it contains the matched transactions (in the same order!)\n-            BOOST_CHECK(vMatchTxid1 == vMatchTxid2);\n+            FAST_CHECK(vMatchTxid1 == vMatchTxid2);\n \n             // check that random bit flips break the authentication\n             for (int j=0; j<4; j++) {\n                 CPartialMerkleTreeTester pmt3(pmt2);\n                 pmt3.Damage();\n                 std::vector<uint256> vMatchTxid3;\n                 uint256 merkleRoot3 = pmt3.ExtractMatches(vMatchTxid3, vIndex);\n-                BOOST_CHECK(merkleRoot3 != merkleRoot1);\n+                FAST_CHECK(merkleRoot3 != merkleRoot1);\n             }\n         }\n     }\n@@ -123,7 +123,7 @@ BOOST_AUTO_TEST_CASE(pmt_malleability)\n \n     CPartialMerkleTree tree(vTxid, vMatch);\n     std::vector<unsigned int> vIndex;\n-    BOOST_CHECK(tree.ExtractMatches(vTxid, vIndex).IsNull());\n+    FAST_CHECK(tree.ExtractMatches(vTxid, vIndex).IsNull());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a7dca64a5f1072d1036d3fe8d8827a070ae3c831",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 31,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -87,16 +87,16 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n             // At this point we should need to combine 5 buckets to get enough data points\n             // So estimateFee(1,2,3) should fail and estimateFee(4) should return somewhere around\n             // 8*baserate.  estimateFee(4) %'s are 100,100,100,100,90 = average 98%\n-            BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(2) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(3) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(4).GetFeePerK() < 8*baseRate.GetFeePerK() + deltaFee);\n-            BOOST_CHECK(mpool.estimateFee(4).GetFeePerK() > 8*baseRate.GetFeePerK() - deltaFee);\n+            FAST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n+            FAST_CHECK(mpool.estimateFee(2) == CFeeRate(0));\n+            FAST_CHECK(mpool.estimateFee(3) == CFeeRate(0));\n+            FAST_CHECK(mpool.estimateFee(4).GetFeePerK() < 8*baseRate.GetFeePerK() + deltaFee);\n+            FAST_CHECK(mpool.estimateFee(4).GetFeePerK() > 8*baseRate.GetFeePerK() - deltaFee);\n             int answerFound;\n-            BOOST_CHECK(mpool.estimateSmartFee(1, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(3, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(4, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(8, &answerFound) == mpool.estimateFee(8) && answerFound == 8);\n+            FAST_CHECK(mpool.estimateSmartFee(1, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n+            FAST_CHECK(mpool.estimateSmartFee(3, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n+            FAST_CHECK(mpool.estimateSmartFee(4, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n+            FAST_CHECK(mpool.estimateSmartFee(8, &answerFound) == mpool.estimateFee(8) && answerFound == 8);\n         }\n     }\n \n@@ -112,14 +112,14 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         origFeeEst.push_back(mpool.estimateFee(i).GetFeePerK());\n         origPriEst.push_back(mpool.estimatePriority(i));\n         if (i > 1) { // Fee estimates should be monotonically decreasing\n-            BOOST_CHECK(origFeeEst[i-1] <= origFeeEst[i-2]);\n-            BOOST_CHECK(origPriEst[i-1] <= origPriEst[i-2]);\n+            FAST_CHECK(origFeeEst[i-1] <= origFeeEst[i-2]);\n+            FAST_CHECK(origPriEst[i-1] <= origPriEst[i-2]);\n         }\n         int mult = 11-i;\n-        BOOST_CHECK(origFeeEst[i-1] < mult*baseRate.GetFeePerK() + deltaFee);\n-        BOOST_CHECK(origFeeEst[i-1] > mult*baseRate.GetFeePerK() - deltaFee);\n-        BOOST_CHECK(origPriEst[i-1] < pow(10,mult) * basepri + deltaPri);\n-        BOOST_CHECK(origPriEst[i-1] > pow(10,mult) * basepri - deltaPri);\n+        FAST_CHECK(origFeeEst[i-1] < mult*baseRate.GetFeePerK() + deltaFee);\n+        FAST_CHECK(origFeeEst[i-1] > mult*baseRate.GetFeePerK() - deltaFee);\n+        FAST_CHECK(origPriEst[i-1] < pow(10,mult) * basepri + deltaPri);\n+        FAST_CHECK(origPriEst[i-1] > pow(10,mult) * basepri - deltaPri);\n     }\n \n     // Mine 50 more blocks with no transactions happening, estimates shouldn't change\n@@ -128,10 +128,10 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         mpool.removeForBlock(block, ++blocknum, dummyConflicted);\n \n     for (int i = 1; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] + deltaPri);\n-        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n+        FAST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n+        FAST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        FAST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] + deltaPri);\n+        FAST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n     }\n \n \n@@ -151,10 +151,10 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n \n     int answerFound;\n     for (int i = 1; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i) == CFeeRate(0) || mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimateSmartFee(i, &answerFound).GetFeePerK() > origFeeEst[answerFound-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) == -1 || mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n-        BOOST_CHECK(mpool.estimateSmartPriority(i, &answerFound) > origPriEst[answerFound-1] - deltaPri);\n+        FAST_CHECK(mpool.estimateFee(i) == CFeeRate(0) || mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        FAST_CHECK(mpool.estimateSmartFee(i, &answerFound).GetFeePerK() > origFeeEst[answerFound-1] - deltaFee);\n+        FAST_CHECK(mpool.estimatePriority(i) == -1 || mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n+        FAST_CHECK(mpool.estimateSmartPriority(i, &answerFound) > origPriEst[answerFound-1] - deltaPri);\n     }\n \n     // Mine all those transactions\n@@ -170,8 +170,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     mpool.removeForBlock(block, 265, dummyConflicted);\n     block.clear();\n     for (int i = 1; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n+        FAST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        FAST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n     }\n \n     // Mine 200 more blocks where everything is mined every block\n@@ -191,20 +191,20 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         block.clear();\n     }\n     for (int i = 1; i < 10; i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] - deltaPri);\n+        FAST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n+        FAST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] - deltaPri);\n     }\n \n     // Test that if the mempool is limited, estimateSmartFee won't return a value below the mempool min fee\n     // and that estimateSmartPriority returns essentially an infinite value\n     mpool.addUnchecked(tx.GetHash(),  entry.Fee(feeV[0][5]).Time(GetTime()).Priority(priV[1][5]).Height(blocknum).FromTx(tx, &mpool));\n     // evict that transaction which should set a mempool min fee of minRelayTxFee + feeV[0][5]\n     mpool.TrimToSize(1);\n-    BOOST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[0][5]);\n+    FAST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[0][5]);\n     for (int i = 1; i < 10; i++) {\n-        BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.estimateFee(i).GetFeePerK());\n-        BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n-        BOOST_CHECK(mpool.estimateSmartPriority(i) == INF_PRIORITY);\n+        FAST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.estimateFee(i).GetFeePerK());\n+        FAST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n+        FAST_CHECK(mpool.estimateSmartPriority(i) == INF_PRIORITY);\n     }\n }\n "
      },
      {
        "sha": "c6060757e7ed840f2cd84afe463f607c56e20ef6",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -26,7 +26,7 @@ BOOST_AUTO_TEST_CASE(get_next_work)\n     pindexLast.nHeight = 32255;\n     pindexLast.nTime = 1262152739;  // Block #32255\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00d86a);\n+    FAST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00d86a);\n }\n \n /* Test the constraint on the upper bound for next work */\n@@ -40,7 +40,7 @@ BOOST_AUTO_TEST_CASE(get_next_work_pow_limit)\n     pindexLast.nHeight = 2015;\n     pindexLast.nTime = 1233061996;  // Block #2015\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00ffff);\n+    FAST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00ffff);\n }\n \n /* Test the constraint on the lower bound for actual time taken */\n@@ -54,7 +54,7 @@ BOOST_AUTO_TEST_CASE(get_next_work_lower_limit_actual)\n     pindexLast.nHeight = 68543;\n     pindexLast.nTime = 1279297671;  // Block #68543\n     pindexLast.nBits = 0x1c05a3f4;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1c0168fd);\n+    FAST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1c0168fd);\n }\n \n /* Test the constraint on the upper bound for actual time taken */\n@@ -68,7 +68,7 @@ BOOST_AUTO_TEST_CASE(get_next_work_upper_limit_actual)\n     pindexLast.nHeight = 46367;\n     pindexLast.nTime = 1269211443;  // Block #46367\n     pindexLast.nBits = 0x1c387f6f;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00e1fd);\n+    FAST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00e1fd);\n }\n \n BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n@@ -91,7 +91,7 @@ BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n         CBlockIndex *p3 = &blocks[GetRand(10000)];\n \n         int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, params);\n-        BOOST_CHECK_EQUAL(tdiff, p1->GetBlockTime() - p2->GetBlockTime());\n+        FAST_CHECK_EQUAL(tdiff, p1->GetBlockTime() - p2->GetBlockTime());\n     }\n }\n "
      },
      {
        "sha": "02569280f8bd26fbcf616f5b893f47c381de8849",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -29,54 +29,54 @@ class prevector_tester {\n \n     void test() {\n         const pretype& const_pre_vector = pre_vector;\n-        BOOST_CHECK_EQUAL(real_vector.size(), pre_vector.size());\n-        BOOST_CHECK_EQUAL(real_vector.empty(), pre_vector.empty());\n+        FAST_CHECK_EQUAL(real_vector.size(), pre_vector.size());\n+        FAST_CHECK_EQUAL(real_vector.empty(), pre_vector.empty());\n         for (Size s = 0; s < real_vector.size(); s++) {\n-             BOOST_CHECK(real_vector[s] == pre_vector[s]);\n-             BOOST_CHECK(&(pre_vector[s]) == &(pre_vector.begin()[s]));\n-             BOOST_CHECK(&(pre_vector[s]) == &*(pre_vector.begin() + s));\n-             BOOST_CHECK(&(pre_vector[s]) == &*((pre_vector.end() + s) - real_vector.size()));\n+             FAST_CHECK(real_vector[s] == pre_vector[s]);\n+             FAST_CHECK(&(pre_vector[s]) == &(pre_vector.begin()[s]));\n+             FAST_CHECK(&(pre_vector[s]) == &*(pre_vector.begin() + s));\n+             FAST_CHECK(&(pre_vector[s]) == &*((pre_vector.end() + s) - real_vector.size()));\n         }\n-        // BOOST_CHECK(realtype(pre_vector) == real_vector);\n-        BOOST_CHECK(pretype(real_vector.begin(), real_vector.end()) == pre_vector);\n-        BOOST_CHECK(pretype(pre_vector.begin(), pre_vector.end()) == pre_vector);\n+        // FAST_CHECK(realtype(pre_vector) == real_vector);\n+        FAST_CHECK(pretype(real_vector.begin(), real_vector.end()) == pre_vector);\n+        FAST_CHECK(pretype(pre_vector.begin(), pre_vector.end()) == pre_vector);\n         size_t pos = 0;\n         BOOST_FOREACH(const T& v, pre_vector) {\n-             BOOST_CHECK(v == real_vector[pos++]);\n+             FAST_CHECK(v == real_vector[pos++]);\n         }\n         BOOST_REVERSE_FOREACH(const T& v, pre_vector) {\n-             BOOST_CHECK(v == real_vector[--pos]);\n+             FAST_CHECK(v == real_vector[--pos]);\n         }\n         BOOST_FOREACH(const T& v, const_pre_vector) {\n-             BOOST_CHECK(v == real_vector[pos++]);\n+             FAST_CHECK(v == real_vector[pos++]);\n         }\n         BOOST_REVERSE_FOREACH(const T& v, const_pre_vector) {\n-             BOOST_CHECK(v == real_vector[--pos]);\n+             FAST_CHECK(v == real_vector[--pos]);\n         }\n         CDataStream ss1(SER_DISK, 0);\n         CDataStream ss2(SER_DISK, 0);\n         ss1 << real_vector;\n         ss2 << pre_vector;\n-        BOOST_CHECK_EQUAL(ss1.size(), ss2.size());\n+        FAST_CHECK_EQUAL(ss1.size(), ss2.size());\n         for (Size s = 0; s < ss1.size(); s++) {\n-            BOOST_CHECK_EQUAL(ss1[s], ss2[s]);\n+            FAST_CHECK_EQUAL(ss1[s], ss2[s]);\n         }\n     }\n \n public:\n     void resize(Size s) {\n         real_vector.resize(s);\n-        BOOST_CHECK_EQUAL(real_vector.size(), s);\n+        FAST_CHECK_EQUAL(real_vector.size(), s);\n         pre_vector.resize(s);\n-        BOOST_CHECK_EQUAL(pre_vector.size(), s);\n+        FAST_CHECK_EQUAL(pre_vector.size(), s);\n         test();\n     }\n \n     void reserve(Size s) {\n         real_vector.reserve(s);\n-        BOOST_CHECK(real_vector.capacity() >= s);\n+        FAST_CHECK(real_vector.capacity() >= s);\n         pre_vector.reserve(s);\n-        BOOST_CHECK(pre_vector.capacity() >= s);\n+        FAST_CHECK(pre_vector.capacity() >= s);\n         test();\n     }\n "
      },
      {
        "sha": "aa439c4750d6938dd002178b8505cdf01b178838",
        "filename": "src/test/reverselock_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/reverselock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/reverselock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/reverselock_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -14,12 +14,12 @@ BOOST_AUTO_TEST_CASE(reverselock_basics)\n     boost::mutex mutex;\n     boost::unique_lock<boost::mutex> lock(mutex);\n \n-    BOOST_CHECK(lock.owns_lock());\n+    FAST_CHECK(lock.owns_lock());\n     {\n         reverse_lock<boost::unique_lock<boost::mutex> > rlock(lock);\n-        BOOST_CHECK(!lock.owns_lock());\n+        FAST_CHECK(!lock.owns_lock());\n     }\n-    BOOST_CHECK(lock.owns_lock());\n+    FAST_CHECK(lock.owns_lock());\n }\n \n BOOST_AUTO_TEST_CASE(reverselock_errors)\n@@ -30,7 +30,7 @@ BOOST_AUTO_TEST_CASE(reverselock_errors)\n     // Make sure trying to reverse lock an unlocked lock fails\n     lock.unlock();\n \n-    BOOST_CHECK(!lock.owns_lock());\n+    FAST_CHECK(!lock.owns_lock());\n \n     bool failed = false;\n     try {\n@@ -39,22 +39,22 @@ BOOST_AUTO_TEST_CASE(reverselock_errors)\n         failed = true;\n     }\n \n-    BOOST_CHECK(failed);\n-    BOOST_CHECK(!lock.owns_lock());\n+    FAST_CHECK(failed);\n+    FAST_CHECK(!lock.owns_lock());\n \n     // Locking the original lock after it has been taken by a reverse lock\n     // makes no sense. Ensure that the original lock no longer owns the lock\n     // after giving it to a reverse one.\n \n     lock.lock();\n-    BOOST_CHECK(lock.owns_lock());\n+    FAST_CHECK(lock.owns_lock());\n     {\n         reverse_lock<boost::unique_lock<boost::mutex> > rlock(lock);\n-        BOOST_CHECK(!lock.owns_lock());\n+        FAST_CHECK(!lock.owns_lock());\n     }\n \n-    BOOST_CHECK(failed);\n-    BOOST_CHECK(lock.owns_lock());\n+    FAST_CHECK(failed);\n+    FAST_CHECK(lock.owns_lock());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "655daa9fd30d509def831780517bf3c8261c78be",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 166,
        "deletions": 166,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -25,7 +25,7 @@ UniValue CallRPC(string args)\n     string strMethod = vArgs[0];\n     vArgs.erase(vArgs.begin());\n     UniValue params = RPCConvertValues(strMethod, vArgs);\n-    BOOST_CHECK(tableRPC[strMethod]);\n+    FAST_CHECK(tableRPC[strMethod]);\n     rpcfn_type method = tableRPC[strMethod]->actor;\n     try {\n         UniValue result = (*method)(params, false);\n@@ -44,41 +44,41 @@ BOOST_AUTO_TEST_CASE(rpc_rawparams)\n     // Test raw transaction API argument handling\n     UniValue r;\n \n-    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction not_hex\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed not_int\"), runtime_error);\n-\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction null null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction not_array\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] []\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction {} {}\"), runtime_error);\n-    BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [] {}\"));\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] {} extra\"), runtime_error);\n-\n-    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction DEADBEEF\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"getrawtransaction\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"getrawtransaction not_hex\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"getrawtransaction a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed not_int\"), runtime_error);\n+\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction null null\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction not_array\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction [] []\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction {} {}\"), runtime_error);\n+    FAST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [] {}\"));\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction [] {} extra\"), runtime_error);\n+\n+    FAST_CHECK_THROW(CallRPC(\"decoderawtransaction\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"decoderawtransaction null\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"decoderawtransaction DEADBEEF\"), runtime_error);\n     string rawtx = \"0100000001a15d57094aa7a21a28cb20b59aab8fc7d1149a3bdbcddba9c622e4f5f6a99ece010000006c493046022100f93bb0e7d8db7bd46e40132d1f8242026e045f03a0efe71bbb8e3f475e970d790221009337cd7f1f929f00cc6ff01f03729b069a7c21b59b1736ddfee5db5946c5da8c0121033b9b137ee87d5a812d6f506efdd37f0affa7ffc310711c06c7f3e097c9447c52ffffffff0100e1f505000000001976a9140389035a9225b3839e2bbf32d826a1e222031fd888ac00000000\";\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx));\n-    BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"size\").get_int(), 193);\n-    BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"version\").get_int(), 1);\n-    BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"locktime\").get_int(), 0);\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx+\" extra\"), runtime_error);\n-\n-    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction ff00\"), runtime_error);\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx));\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null NONE|ANYONECANPAY\"));\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" [] [] NONE|ANYONECANPAY\"));\n-    BOOST_CHECK_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null badenum\"), runtime_error);\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx));\n+    FAST_CHECK_EQUAL(find_value(r.get_obj(), \"size\").get_int(), 193);\n+    FAST_CHECK_EQUAL(find_value(r.get_obj(), \"version\").get_int(), 1);\n+    FAST_CHECK_EQUAL(find_value(r.get_obj(), \"locktime\").get_int(), 0);\n+    FAST_CHECK_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx+\" extra\"), runtime_error);\n+\n+    FAST_CHECK_THROW(CallRPC(\"signrawtransaction\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"signrawtransaction null\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"signrawtransaction ff00\"), runtime_error);\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null NONE|ANYONECANPAY\"));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" [] [] NONE|ANYONECANPAY\"));\n+    FAST_CHECK_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null badenum\"), runtime_error);\n \n     // Only check failure cases for sendrawtransaction, there's no network to send to...\n-    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction DEADBEEF\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(string(\"sendrawtransaction \")+rawtx+\" extra\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"sendrawtransaction\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"sendrawtransaction null\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"sendrawtransaction DEADBEEF\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(string(\"sendrawtransaction \")+rawtx+\" extra\"), runtime_error);\n }\n \n BOOST_AUTO_TEST_CASE(rpc_rawsign)\n@@ -95,229 +95,229 @@ BOOST_AUTO_TEST_CASE(rpc_rawsign)\n     string privkey1 = \"\\\"KzsXybp9jX64P5ekX1KUxRQ79Jht9uzW7LorgwE65i5rWACL6LQe\\\"\";\n     string privkey2 = \"\\\"Kyhdf5LuKTRx4ge69ybABsiUAWjVRK4XGxAKk2FQLp2HjGMy87Z4\\\"\";\n     r = CallRPC(string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[]\");\n-    BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == false);\n+    FAST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == false);\n     r = CallRPC(string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[\"+privkey1+\",\"+privkey2+\"]\");\n-    BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == true);\n+    FAST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == true);\n }\n \n BOOST_AUTO_TEST_CASE(rpc_createraw_op_return)\n {\n-    BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n+    FAST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n \n     // Allow more than one data transaction output\n-    BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\",\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n+    FAST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\",\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n \n     // Key not \"data\" (bad address)\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"somedata\\\":\\\"68656c6c6f776f726c64\\\"}\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"somedata\\\":\\\"68656c6c6f776f726c64\\\"}\"), runtime_error);\n \n     // Bad hex encoding of data output\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345\\\"}\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345g\\\"}\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345\\\"}\"), runtime_error);\n+    FAST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345g\\\"}\"), runtime_error);\n \n     // Data 81 bytes long\n-    BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\\\"}\"));\n+    FAST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\\\"}\"));\n }\n \n BOOST_AUTO_TEST_CASE(rpc_format_monetary_values)\n {\n-    BOOST_CHECK(ValueFromAmount(0LL).write() == \"0.00000000\");\n-    BOOST_CHECK(ValueFromAmount(1LL).write() == \"0.00000001\");\n-    BOOST_CHECK(ValueFromAmount(17622195LL).write() == \"0.17622195\");\n-    BOOST_CHECK(ValueFromAmount(50000000LL).write() == \"0.50000000\");\n-    BOOST_CHECK(ValueFromAmount(89898989LL).write() == \"0.89898989\");\n-    BOOST_CHECK(ValueFromAmount(100000000LL).write() == \"1.00000000\");\n-    BOOST_CHECK(ValueFromAmount(2099999999999990LL).write() == \"20999999.99999990\");\n-    BOOST_CHECK(ValueFromAmount(2099999999999999LL).write() == \"20999999.99999999\");\n-\n-    BOOST_CHECK_EQUAL(ValueFromAmount(0).write(), \"0.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount((COIN/10000)*123456789).write(), \"12345.67890000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(-COIN).write(), \"-1.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(-COIN/10).write(), \"-0.10000000\");\n-\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*100000000).write(), \"100000000.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*10000000).write(), \"10000000.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*1000000).write(), \"1000000.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*100000).write(), \"100000.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*10000).write(), \"10000.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*1000).write(), \"1000.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*100).write(), \"100.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN*10).write(), \"10.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN).write(), \"1.00000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/10).write(), \"0.10000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/100).write(), \"0.01000000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/1000).write(), \"0.00100000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/10000).write(), \"0.00010000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/100000).write(), \"0.00001000\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/1000000).write(), \"0.00000100\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/10000000).write(), \"0.00000010\");\n-    BOOST_CHECK_EQUAL(ValueFromAmount(COIN/100000000).write(), \"0.00000001\");\n+    FAST_CHECK(ValueFromAmount(0LL).write() == \"0.00000000\");\n+    FAST_CHECK(ValueFromAmount(1LL).write() == \"0.00000001\");\n+    FAST_CHECK(ValueFromAmount(17622195LL).write() == \"0.17622195\");\n+    FAST_CHECK(ValueFromAmount(50000000LL).write() == \"0.50000000\");\n+    FAST_CHECK(ValueFromAmount(89898989LL).write() == \"0.89898989\");\n+    FAST_CHECK(ValueFromAmount(100000000LL).write() == \"1.00000000\");\n+    FAST_CHECK(ValueFromAmount(2099999999999990LL).write() == \"20999999.99999990\");\n+    FAST_CHECK(ValueFromAmount(2099999999999999LL).write() == \"20999999.99999999\");\n+\n+    FAST_CHECK_EQUAL(ValueFromAmount(0).write(), \"0.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount((COIN/10000)*123456789).write(), \"12345.67890000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(-COIN).write(), \"-1.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(-COIN/10).write(), \"-0.10000000\");\n+\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*100000000).write(), \"100000000.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*10000000).write(), \"10000000.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*1000000).write(), \"1000000.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*100000).write(), \"100000.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*10000).write(), \"10000.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*1000).write(), \"1000.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*100).write(), \"100.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN*10).write(), \"10.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN).write(), \"1.00000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/10).write(), \"0.10000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/100).write(), \"0.01000000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/1000).write(), \"0.00100000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/10000).write(), \"0.00010000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/100000).write(), \"0.00001000\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/1000000).write(), \"0.00000100\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/10000000).write(), \"0.00000010\");\n+    FAST_CHECK_EQUAL(ValueFromAmount(COIN/100000000).write(), \"0.00000001\");\n }\n \n static UniValue ValueFromString(const std::string &str)\n {\n     UniValue value;\n-    BOOST_CHECK(value.setNumStr(str));\n+    FAST_CHECK(value.setNumStr(str));\n     return value;\n }\n \n BOOST_AUTO_TEST_CASE(rpc_parse_monetary_values)\n {\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"-0.00000001\")), UniValue);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0\")), 0LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.00000000\")), 0LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.00000001\")), 1LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.17622195\")), 17622195LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.5\")), 50000000LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.50000000\")), 50000000LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.89898989\")), 89898989LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"1.00000000\")), 100000000LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"20999999.9999999\")), 2099999999999990LL);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"20999999.99999999\")), 2099999999999999LL);\n-\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"1e-8\")), COIN/100000000);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.1e-7\")), COIN/100000000);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.01e-6\")), COIN/100000000);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.0000000000000000000000000000000000000000000000000000000000000000000000000001e+68\")), COIN/100000000);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"10000000000000000000000000000000000000000000000000000000000000000e-64\")), COIN);\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000e64\")), COIN);\n-\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"1e-9\")), UniValue); //should fail\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"0.000000019\")), UniValue); //should fail\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.00000001000000\")), 1LL); //should pass, cut trailing 0\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"19e-9\")), UniValue); //should fail\n-    BOOST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.19e-6\")), 19); //should pass, leading 0 is present\n-\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"92233720368.54775808\")), UniValue); //overflow error\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"1e+11\")), UniValue); //overflow error\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"1e11\")), UniValue); //overflow error signless\n-    BOOST_CHECK_THROW(AmountFromValue(ValueFromString(\"93e+9\")), UniValue); //overflow error\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"-0.00000001\")), UniValue);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0\")), 0LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.00000000\")), 0LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.00000001\")), 1LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.17622195\")), 17622195LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.5\")), 50000000LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.50000000\")), 50000000LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.89898989\")), 89898989LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"1.00000000\")), 100000000LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"20999999.9999999\")), 2099999999999990LL);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"20999999.99999999\")), 2099999999999999LL);\n+\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"1e-8\")), COIN/100000000);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.1e-7\")), COIN/100000000);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.01e-6\")), COIN/100000000);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.0000000000000000000000000000000000000000000000000000000000000000000000000001e+68\")), COIN/100000000);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"10000000000000000000000000000000000000000000000000000000000000000e-64\")), COIN);\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000e64\")), COIN);\n+\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"1e-9\")), UniValue); //should fail\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"0.000000019\")), UniValue); //should fail\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.00000001000000\")), 1LL); //should pass, cut trailing 0\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"19e-9\")), UniValue); //should fail\n+    FAST_CHECK_EQUAL(AmountFromValue(ValueFromString(\"0.19e-6\")), 19); //should pass, leading 0 is present\n+\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"92233720368.54775808\")), UniValue); //overflow error\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"1e+11\")), UniValue); //overflow error\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"1e11\")), UniValue); //overflow error signless\n+    FAST_CHECK_THROW(AmountFromValue(ValueFromString(\"93e+9\")), UniValue); //overflow error\n }\n \n BOOST_AUTO_TEST_CASE(json_parse_errors)\n {\n     // Valid\n-    BOOST_CHECK_EQUAL(ParseNonRFCJSONValue(\"1.0\").get_real(), 1.0);\n+    FAST_CHECK_EQUAL(ParseNonRFCJSONValue(\"1.0\").get_real(), 1.0);\n     // Valid, with leading or trailing whitespace\n-    BOOST_CHECK_EQUAL(ParseNonRFCJSONValue(\" 1.0\").get_real(), 1.0);\n-    BOOST_CHECK_EQUAL(ParseNonRFCJSONValue(\"1.0 \").get_real(), 1.0);\n+    FAST_CHECK_EQUAL(ParseNonRFCJSONValue(\" 1.0\").get_real(), 1.0);\n+    FAST_CHECK_EQUAL(ParseNonRFCJSONValue(\"1.0 \").get_real(), 1.0);\n \n-    BOOST_CHECK_THROW(AmountFromValue(ParseNonRFCJSONValue(\".19e-6\")), std::runtime_error); //should fail, missing leading 0, therefore invalid JSON\n-    BOOST_CHECK_EQUAL(AmountFromValue(ParseNonRFCJSONValue(\"0.00000000000000000000000000000000000001e+30 \")), 1);\n+    FAST_CHECK_THROW(AmountFromValue(ParseNonRFCJSONValue(\".19e-6\")), std::runtime_error); //should fail, missing leading 0, therefore invalid JSON\n+    FAST_CHECK_EQUAL(AmountFromValue(ParseNonRFCJSONValue(\"0.00000000000000000000000000000000000001e+30 \")), 1);\n     // Invalid, initial garbage\n-    BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"[1.0\"), std::runtime_error);\n-    BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"a1.0\"), std::runtime_error);\n+    FAST_CHECK_THROW(ParseNonRFCJSONValue(\"[1.0\"), std::runtime_error);\n+    FAST_CHECK_THROW(ParseNonRFCJSONValue(\"a1.0\"), std::runtime_error);\n     // Invalid, trailing garbage\n-    BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"1.0sds\"), std::runtime_error);\n-    BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"1.0]\"), std::runtime_error);\n+    FAST_CHECK_THROW(ParseNonRFCJSONValue(\"1.0sds\"), std::runtime_error);\n+    FAST_CHECK_THROW(ParseNonRFCJSONValue(\"1.0]\"), std::runtime_error);\n     // BTC addresses should fail parsing\n-    BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\"), std::runtime_error);\n-    BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"3J98t1WpEZ73CNmQviecrnyiWrnqRhWNL\"), std::runtime_error);\n+    FAST_CHECK_THROW(ParseNonRFCJSONValue(\"175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\"), std::runtime_error);\n+    FAST_CHECK_THROW(ParseNonRFCJSONValue(\"3J98t1WpEZ73CNmQviecrnyiWrnqRhWNL\"), std::runtime_error);\n }\n \n BOOST_AUTO_TEST_CASE(rpc_ban)\n {\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n     \n     UniValue r;\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0 add\")));\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.0.0:8334\")), runtime_error); //portnumber for setban not allowed\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0 add\")));\n+    FAST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.0.0:8334\")), runtime_error); //portnumber for setban not allowed\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     UniValue ar = r.get_array();\n     UniValue o1 = ar[0].get_obj();\n     UniValue adr = find_value(o1, \"address\");\n-    BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/32\");\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"setban 127.0.0.0 remove\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/32\");\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"setban 127.0.0.0 remove\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n-    BOOST_CHECK_EQUAL(ar.size(), 0);\n+    FAST_CHECK_EQUAL(ar.size(), 0);\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/24 add 1607731200 true\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/24 add 1607731200 true\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n     UniValue banned_until = find_value(o1, \"banned_until\");\n-    BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n-    BOOST_CHECK_EQUAL(banned_until.get_int64(), 1607731200); // absolute time check\n+    FAST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n+    FAST_CHECK_EQUAL(banned_until.get_int64(), 1607731200); // absolute time check\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/24 add 200\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/24 add 200\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n     banned_until = find_value(o1, \"banned_until\");\n-    BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n+    FAST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n     int64_t now = GetTime();\n-    BOOST_CHECK(banned_until.get_int64() > now);\n-    BOOST_CHECK(banned_until.get_int64()-now <= 200);\n+    FAST_CHECK(banned_until.get_int64() > now);\n+    FAST_CHECK(banned_until.get_int64()-now <= 200);\n \n     // must throw an exception because 127.0.0.1 is in already banned suubnet range\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.0.1 add\")), runtime_error);\n+    FAST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.0.1 add\")), runtime_error);\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"setban 127.0.0.0/24 remove\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"setban 127.0.0.0/24 remove\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n-    BOOST_CHECK_EQUAL(ar.size(), 0);\n+    FAST_CHECK_EQUAL(ar.size(), 0);\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/255.255.0.0 add\")));\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.1.1 add\")), runtime_error);\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/255.255.0.0 add\")));\n+    FAST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.1.1 add\")), runtime_error);\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n-    BOOST_CHECK_EQUAL(ar.size(), 0);\n+    FAST_CHECK_EQUAL(ar.size(), 0);\n \n \n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban test add\")), runtime_error); //invalid IP\n+    FAST_CHECK_THROW(r = CallRPC(string(\"setban test add\")), runtime_error); //invalid IP\n \n     //IPv6 tests\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban FE80:0000:0000:0000:0202:B3FF:FE1E:8329 add\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban FE80:0000:0000:0000:0202:B3FF:FE1E:8329 add\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n-    BOOST_CHECK_EQUAL(adr.get_str(), \"fe80::202:b3ff:fe1e:8329/128\");\n+    FAST_CHECK_EQUAL(adr.get_str(), \"fe80::202:b3ff:fe1e:8329/128\");\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 2001:db8::/ffff:fffc:0:0:0:0:0:0 add\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban 2001:db8::/ffff:fffc:0:0:0:0:0:0 add\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n-    BOOST_CHECK_EQUAL(adr.get_str(), \"2001:db8::/30\");\n+    FAST_CHECK_EQUAL(adr.get_str(), \"2001:db8::/30\");\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/128 add\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    FAST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"setban 2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/128 add\")));\n+    FAST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n-    BOOST_CHECK_EQUAL(adr.get_str(), \"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/128\");\n+    FAST_CHECK_EQUAL(adr.get_str(), \"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/128\");\n }\n \n BOOST_AUTO_TEST_CASE(rpc_convert_values_generatetoaddress)\n {\n     UniValue result;\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"101\")(\"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\")));\n-    BOOST_CHECK_EQUAL(result[0].get_int(), 101);\n-    BOOST_CHECK_EQUAL(result[1].get_str(), \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\");\n+    FAST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"101\")(\"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\")));\n+    FAST_CHECK_EQUAL(result[0].get_int(), 101);\n+    FAST_CHECK_EQUAL(result[1].get_str(), \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\");\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"101\")(\"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\")));\n-    BOOST_CHECK_EQUAL(result[0].get_int(), 101);\n-    BOOST_CHECK_EQUAL(result[1].get_str(), \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\");\n+    FAST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"101\")(\"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\")));\n+    FAST_CHECK_EQUAL(result[0].get_int(), 101);\n+    FAST_CHECK_EQUAL(result[1].get_str(), \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\");\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"1\")(\"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\")(\"9\")));\n-    BOOST_CHECK_EQUAL(result[0].get_int(), 1);\n-    BOOST_CHECK_EQUAL(result[1].get_str(), \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\");\n-    BOOST_CHECK_EQUAL(result[2].get_int(), 9);\n+    FAST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"1\")(\"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\")(\"9\")));\n+    FAST_CHECK_EQUAL(result[0].get_int(), 1);\n+    FAST_CHECK_EQUAL(result[1].get_str(), \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\");\n+    FAST_CHECK_EQUAL(result[2].get_int(), 9);\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"1\")(\"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\")(\"9\")));\n-    BOOST_CHECK_EQUAL(result[0].get_int(), 1);\n-    BOOST_CHECK_EQUAL(result[1].get_str(), \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\");\n-    BOOST_CHECK_EQUAL(result[2].get_int(), 9);\n+    FAST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"1\")(\"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\")(\"9\")));\n+    FAST_CHECK_EQUAL(result[0].get_int(), 1);\n+    FAST_CHECK_EQUAL(result[1].get_str(), \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\");\n+    FAST_CHECK_EQUAL(result[2].get_int(), 9);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "4fdcc425301e482a1184dc39c8bcbf2ab601dbab",
        "filename": "src/test/scheduler_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/scheduler_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/scheduler_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scheduler_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -67,7 +67,7 @@ BOOST_AUTO_TEST_CASE(manythreads)\n     boost::chrono::system_clock::time_point now = start;\n     boost::chrono::system_clock::time_point first, last;\n     size_t nTasks = microTasks.getQueueInfo(first, last);\n-    BOOST_CHECK(nTasks == 0);\n+    FAST_CHECK(nTasks == 0);\n \n     for (int i = 0; i < 100; i++) {\n         boost::chrono::system_clock::time_point t = now + boost::chrono::microseconds(randomMsec(rng));\n@@ -79,9 +79,9 @@ BOOST_AUTO_TEST_CASE(manythreads)\n         microTasks.schedule(f, t);\n     }\n     nTasks = microTasks.getQueueInfo(first, last);\n-    BOOST_CHECK(nTasks == 100);\n-    BOOST_CHECK(first < last);\n-    BOOST_CHECK(last > now);\n+    FAST_CHECK(nTasks == 100);\n+    FAST_CHECK(first < last);\n+    FAST_CHECK(last > now);\n \n     // As soon as these are created they will start running and servicing the queue\n     boost::thread_group microThreads;\n@@ -110,10 +110,10 @@ BOOST_AUTO_TEST_CASE(manythreads)\n \n     int counterSum = 0;\n     for (int i = 0; i < 10; i++) {\n-        BOOST_CHECK(counter[i] != 0);\n+        FAST_CHECK(counter[i] != 0);\n         counterSum += counter[i];\n     }\n-    BOOST_CHECK_EQUAL(counterSum, 200);\n+    FAST_CHECK_EQUAL(counterSum, 200);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "4d63a9405b6ba9632354e348d1e3a8e28fda6894",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -89,7 +89,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n         txFrom.vout[i+4].nValue = COIN;\n     }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n+    FAST_CHECK(IsStandardTx(txFrom, reason));\n \n     CMutableTransaction txTo[8]; // Spending transactions\n     for (int i = 0; i < 8; i++)\n@@ -135,7 +135,7 @@ BOOST_AUTO_TEST_CASE(norecurse)\n     scriptSig << Serialize(invalidAsScript);\n \n     // Should not verify, because it will try to execute OP_INVALIDOPCODE\n-    BOOST_CHECK(!Verify(scriptSig, p2sh, true, err));\n+    FAST_CHECK(!Verify(scriptSig, p2sh, true, err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_BAD_OPCODE, ScriptErrorString(err));\n \n     // Try to recur, and verification should succeed because\n@@ -144,7 +144,7 @@ BOOST_AUTO_TEST_CASE(norecurse)\n     CScript scriptSig2;\n     scriptSig2 << Serialize(invalidAsScript) << Serialize(p2sh);\n \n-    BOOST_CHECK(Verify(scriptSig2, p2sh2, true, err));\n+    FAST_CHECK(Verify(scriptSig2, p2sh2, true, err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n@@ -183,7 +183,7 @@ BOOST_AUTO_TEST_CASE(set)\n         txFrom.vout[i].scriptPubKey = outer[i];\n         txFrom.vout[i].nValue = CENT;\n     }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n+    FAST_CHECK(IsStandardTx(txFrom, reason));\n \n     CMutableTransaction txTo[4]; // Spending transactions\n     for (int i = 0; i < 4; i++)\n@@ -209,29 +209,29 @@ BOOST_AUTO_TEST_CASE(is)\n     uint160 dummy;\n     CScript p2sh;\n     p2sh << OP_HASH160 << ToByteVector(dummy) << OP_EQUAL;\n-    BOOST_CHECK(p2sh.IsPayToScriptHash());\n+    FAST_CHECK(p2sh.IsPayToScriptHash());\n \n     // Not considered pay-to-script-hash if using one of the OP_PUSHDATA opcodes:\n     static const unsigned char direct[] =    { OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToScriptHash());\n+    FAST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToScriptHash());\n     static const unsigned char pushdata1[] = { OP_HASH160, OP_PUSHDATA1, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata1, pushdata1+sizeof(pushdata1)).IsPayToScriptHash());\n+    FAST_CHECK(!CScript(pushdata1, pushdata1+sizeof(pushdata1)).IsPayToScriptHash());\n     static const unsigned char pushdata2[] = { OP_HASH160, OP_PUSHDATA2, 20,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata2, pushdata2+sizeof(pushdata2)).IsPayToScriptHash());\n+    FAST_CHECK(!CScript(pushdata2, pushdata2+sizeof(pushdata2)).IsPayToScriptHash());\n     static const unsigned char pushdata4[] = { OP_HASH160, OP_PUSHDATA4, 20,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata4, pushdata4+sizeof(pushdata4)).IsPayToScriptHash());\n+    FAST_CHECK(!CScript(pushdata4, pushdata4+sizeof(pushdata4)).IsPayToScriptHash());\n \n     CScript not_p2sh;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+    FAST_CHECK(!not_p2sh.IsPayToScriptHash());\n \n     not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << ToByteVector(dummy) << OP_EQUAL;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+    FAST_CHECK(!not_p2sh.IsPayToScriptHash());\n \n     not_p2sh.clear(); not_p2sh << OP_NOP << ToByteVector(dummy) << OP_EQUAL;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+    FAST_CHECK(!not_p2sh.IsPayToScriptHash());\n \n     not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << OP_CHECKSIG;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+    FAST_CHECK(!not_p2sh.IsPayToScriptHash());\n }\n \n BOOST_AUTO_TEST_CASE(switchover)\n@@ -247,10 +247,10 @@ BOOST_AUTO_TEST_CASE(switchover)\n \n \n     // Validation should succeed under old rules (hash is correct):\n-    BOOST_CHECK(Verify(scriptSig, fund, false, err));\n+    FAST_CHECK(Verify(scriptSig, fund, false, err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     // Fail under new:\n-    BOOST_CHECK(!Verify(scriptSig, fund, true, err));\n+    FAST_CHECK(!Verify(scriptSig, fund, true, err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EQUALVERIFY, ScriptErrorString(err));\n }\n \n@@ -327,18 +327,18 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n         txTo.vin[i].prevout.n = i;\n         txTo.vin[i].prevout.hash = txFrom.GetHash();\n     }\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL));\n+    FAST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL));\n+    FAST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL));\n+    FAST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL));\n     // SignSignature doesn't know how to sign these. We're\n     // not testing validating signatures, so just create\n     // dummy signatures that DO include the correct P2SH scripts:\n     txTo.vin[3].scriptSig << OP_11 << OP_11 << vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n     txTo.vin[4].scriptSig << vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n \n-    BOOST_CHECK(::AreInputsStandard(txTo, coins));\n+    FAST_CHECK(::AreInputsStandard(txTo, coins));\n     // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n+    FAST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n \n     CMutableTransaction txToNonStd1;\n     txToNonStd1.vout.resize(1);\n@@ -349,8 +349,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd1.vin[0].scriptSig << vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n \n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n+    FAST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n+    FAST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n \n     CMutableTransaction txToNonStd2;\n     txToNonStd2.vout.resize(1);\n@@ -361,8 +361,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd2.vin[0].scriptSig << vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n \n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\n+    FAST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n+    FAST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "28ffc9536c2e1be2c92f6ef2876d041f4d6f3758",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 97,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -908,22 +908,22 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n \n     ScriptError err;\n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    FAST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n-    BOOST_CHECK(pushdata1Stack == directStack);\n+    FAST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    FAST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n-    BOOST_CHECK(pushdata2Stack == directStack);\n+    FAST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    FAST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n-    BOOST_CHECK(pushdata4Stack == directStack);\n+    FAST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    FAST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n@@ -945,7 +945,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     BOOST_FOREACH(const CKey &key, keys)\n     {\n         vector<unsigned char> vchSig;\n-        BOOST_CHECK(key.Sign(hash, vchSig));\n+        FAST_CHECK(key.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         result << vchSig;\n     }\n@@ -974,18 +974,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    FAST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    FAST_CHECK(VerifyScript(goodsig2, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n \n@@ -1007,54 +1007,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(VerifyScript(goodsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(VerifyScript(goodsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(VerifyScript(goodsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig4, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig5, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    FAST_CHECK(!VerifyScript(badsig6, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n \n@@ -1081,61 +1081,61 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n \n     SignatureData empty;\n     SignatureData combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, empty);\n-    BOOST_CHECK(combined.scriptSig.empty());\n+    FAST_CHECK(combined.scriptSig.empty());\n \n     // Single signature case:\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL); // changes scriptSig\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n     CScript scriptSigCopy = scriptSig;\n     // Signing again will give a different, valid signature:\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n \n     // P2SH, single-signature case:\n     CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n     keystore.AddCScript(pkSingle);\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n     scriptSigCopy = scriptSig;\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n     // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n     scriptSigCopy = CScript() << OP_0 << std::vector<unsigned char>(pkSingle.begin(), pkSingle.end());\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), SignatureData(scriptSigCopy));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n     scriptPubKey = GetScriptForMultisig(2, pubkeys);\n     keystore.AddCScript(scriptPubKey);\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    FAST_CHECK(combined.scriptSig == scriptSig);\n \n     // A couple of partially-signed versions:\n     vector<unsigned char> sig1;\n     uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-    BOOST_CHECK(keys[0].Sign(hash1, sig1));\n+    FAST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n     vector<unsigned char> sig2;\n     uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n-    BOOST_CHECK(keys[1].Sign(hash2, sig2));\n+    FAST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n     vector<unsigned char> sig3;\n     uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n-    BOOST_CHECK(keys[2].Sign(hash3, sig3));\n+    FAST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n \n     // Not fussy about order (or even existence) of placeholders or signatures:\n@@ -1151,21 +1151,21 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n \n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1a), SignatureData(partial1b));\n-    BOOST_CHECK(combined.scriptSig == partial1a);\n+    FAST_CHECK(combined.scriptSig == partial1a);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1a), SignatureData(partial2a));\n-    BOOST_CHECK(combined.scriptSig == complete12);\n+    FAST_CHECK(combined.scriptSig == complete12);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial2a), SignatureData(partial1a));\n-    BOOST_CHECK(combined.scriptSig == complete12);\n+    FAST_CHECK(combined.scriptSig == complete12);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1b), SignatureData(partial2b));\n-    BOOST_CHECK(combined.scriptSig == complete12);\n+    FAST_CHECK(combined.scriptSig == complete12);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial1b));\n-    BOOST_CHECK(combined.scriptSig == complete13);\n+    FAST_CHECK(combined.scriptSig == complete13);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial2a), SignatureData(partial3a));\n-    BOOST_CHECK(combined.scriptSig == complete23);\n+    FAST_CHECK(combined.scriptSig == complete23);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial2b));\n-    BOOST_CHECK(combined.scriptSig == complete23);\n+    FAST_CHECK(combined.scriptSig == complete23);\n     combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial3a));\n-    BOOST_CHECK(combined.scriptSig == partial3c);\n+    FAST_CHECK(combined.scriptSig == partial3c);\n }\n \n BOOST_AUTO_TEST_CASE(script_standard_push)\n@@ -1197,37 +1197,37 @@ BOOST_AUTO_TEST_CASE(script_IsPushOnly_on_invalid_scripts)\n     // not be consensus critical as the P2SH evaluation would fail first due to\n     // the invalid push. Still, it doesn't hurt to test it explicitly.\n     static const unsigned char direct[] = { 1 };\n-    BOOST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n+    FAST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n }\n \n BOOST_AUTO_TEST_CASE(script_GetScriptAsm)\n {\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2, true));\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY, true));\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2));\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY));\n+    FAST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2, true));\n+    FAST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY, true));\n+    FAST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2));\n+    FAST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY));\n \n     string derSig(\"304502207fa7a6d1e0ee81132a269ad84e68d695483745cde8b541e3bf630749894e342a022100c1f7ab20e13e22fb95281a870f3dcf38d782e53023ee313d741ad0cfbc0c5090\");\n     string pubKey(\"03b0da749730dc9b4b1f4a14d6902877a92541f5368778853d9c4a0cb7802dcfb2\");\n     vector<unsigned char> vchPubKey = ToByteVector(ParseHex(pubKey));\n \n-    BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[ALL] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[NONE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[SINGLE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[ALL|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[NONE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[SINGLE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey, true));\n-\n-    BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"01 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"02 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"03 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"81 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"82 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"83 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"[ALL] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"[NONE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"[SINGLE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"[ALL|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"[NONE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey, true));\n+    FAST_CHECK_EQUAL(derSig + \"[SINGLE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey, true));\n+\n+    FAST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"01 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"02 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"03 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"81 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"82 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey));\n+    FAST_CHECK_EQUAL(derSig + \"83 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey));\n }\n \n static CScript\n@@ -1248,103 +1248,103 @@ BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n     s = CScript() << OP_1 << OP_2;\n     d = CScript(); // delete nothing should be a no-op\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    FAST_CHECK(s == expect);\n \n     s = CScript() << OP_1 << OP_2 << OP_3;\n     d = CScript() << OP_2;\n     expect = CScript() << OP_1 << OP_3;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n \n     s = CScript() << OP_3 << OP_1 << OP_3 << OP_3 << OP_4 << OP_3;\n     d = CScript() << OP_3;\n     expect = CScript() << OP_1 << OP_4;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 4);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 4);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff03\"); // PUSH 0x02ff03 onto stack\n     d = ScriptFromHex(\"0302ff03\");\n     expect = CScript();\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff030302ff03\"); // PUSH 0x2ff03 PUSH 0x2ff03\n     d = ScriptFromHex(\"0302ff03\");\n     expect = CScript();\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff030302ff03\");\n     d = ScriptFromHex(\"02\");\n     expect = s; // FindAndDelete matches entire opcodes\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff030302ff03\");\n     d = ScriptFromHex(\"ff\");\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    FAST_CHECK(s == expect);\n \n     // This is an odd edge case: strip of the push-three-bytes\n     // prefix, leaving 02ff03 which is push-two-bytes:\n     s = ScriptFromHex(\"0302ff030302ff03\");\n     d = ScriptFromHex(\"03\");\n     expect = CScript() << ParseHex(\"ff03\") << ParseHex(\"ff03\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n+    FAST_CHECK(s == expect);\n \n     // Byte sequence that spans multiple opcodes:\n     s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n     d = ScriptFromHex(\"feed51\");\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0); // doesn't match 'inside' opcodes\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 0); // doesn't match 'inside' opcodes\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n     d = ScriptFromHex(\"02feed51\");\n     expect = ScriptFromHex(\"69\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"516902feed5169\");\n     d = ScriptFromHex(\"feed51\");\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"516902feed5169\");\n     d = ScriptFromHex(\"02feed51\");\n     expect = ScriptFromHex(\"516969\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n \n     s = CScript() << OP_0 << OP_0 << OP_1 << OP_1;\n     d = CScript() << OP_0 << OP_1;\n     expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n \n     s = CScript() << OP_0 << OP_0 << OP_1 << OP_0 << OP_1 << OP_1;\n     d = CScript() << OP_0 << OP_1;\n     expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n+    FAST_CHECK(s == expect);\n \n     // Another weird edge case:\n     // End with invalid push (not enough data)...\n     s = ScriptFromHex(\"0003feed\");\n     d = ScriptFromHex(\"03feed\"); // ... can remove the invalid push\n     expect = ScriptFromHex(\"00\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0003feed\");\n     d = ScriptFromHex(\"00\");\n     expect = ScriptFromHex(\"03feed\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n-    BOOST_CHECK(s == expect);\n+    FAST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    FAST_CHECK(s == expect);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c24b7f0d43de7606607d7fe1eaf986782d52c3ab",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 43,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -25,28 +25,28 @@ static void CheckCreateVch(const int64_t& num)\n {\n     CScriptNum10 bignum(num);\n     CScriptNum scriptnum(num);\n-    BOOST_CHECK(verify(bignum, scriptnum));\n+    FAST_CHECK(verify(bignum, scriptnum));\n \n     std::vector<unsigned char> vch = bignum.getvch();\n \n     CScriptNum10 bignum2(bignum.getvch(), false);\n     vch = scriptnum.getvch();\n     CScriptNum scriptnum2(scriptnum.getvch(), false);\n-    BOOST_CHECK(verify(bignum2, scriptnum2));\n+    FAST_CHECK(verify(bignum2, scriptnum2));\n \n     CScriptNum10 bignum3(scriptnum2.getvch(), false);\n     CScriptNum scriptnum3(bignum2.getvch(), false);\n-    BOOST_CHECK(verify(bignum3, scriptnum3));\n+    FAST_CHECK(verify(bignum3, scriptnum3));\n }\n \n static void CheckCreateInt(const int64_t& num)\n {\n     CScriptNum10 bignum(num);\n     CScriptNum scriptnum(num);\n-    BOOST_CHECK(verify(bignum, scriptnum));\n-    BOOST_CHECK(verify(CScriptNum10(bignum.getint()), CScriptNum(scriptnum.getint())));\n-    BOOST_CHECK(verify(CScriptNum10(scriptnum.getint()), CScriptNum(bignum.getint())));\n-    BOOST_CHECK(verify(CScriptNum10(CScriptNum10(scriptnum.getint()).getint()), CScriptNum(CScriptNum(bignum.getint()).getint())));\n+    FAST_CHECK(verify(bignum, scriptnum));\n+    FAST_CHECK(verify(CScriptNum10(bignum.getint()), CScriptNum(scriptnum.getint())));\n+    FAST_CHECK(verify(CScriptNum10(scriptnum.getint()), CScriptNum(bignum.getint())));\n+    FAST_CHECK(verify(CScriptNum10(CScriptNum10(scriptnum.getint()).getint()), CScriptNum(CScriptNum(bignum.getint()).getint())));\n }\n \n \n@@ -66,9 +66,9 @@ static void CheckAdd(const int64_t& num1, const int64_t& num2)\n                     ((num2 < 0) && (num1 < (std::numeric_limits<int64_t>::min() - num2))));\n     if (!invalid)\n     {\n-        BOOST_CHECK(verify(bignum1 + bignum2, scriptnum1 + scriptnum2));\n-        BOOST_CHECK(verify(bignum1 + bignum2, scriptnum1 + num2));\n-        BOOST_CHECK(verify(bignum1 + bignum2, scriptnum2 + num1));\n+        FAST_CHECK(verify(bignum1 + bignum2, scriptnum1 + scriptnum2));\n+        FAST_CHECK(verify(bignum1 + bignum2, scriptnum1 + num2));\n+        FAST_CHECK(verify(bignum1 + bignum2, scriptnum2 + num1));\n     }\n }\n \n@@ -79,7 +79,7 @@ static void CheckNegate(const int64_t& num)\n \n     // -INT64_MIN is undefined\n     if (num != std::numeric_limits<int64_t>::min())\n-        BOOST_CHECK(verify(-bignum, -scriptnum));\n+        FAST_CHECK(verify(-bignum, -scriptnum));\n }\n \n static void CheckSubtract(const int64_t& num1, const int64_t& num2)\n@@ -95,16 +95,16 @@ static void CheckSubtract(const int64_t& num1, const int64_t& num2)\n                (num2 < 0 && num1 > std::numeric_limits<int64_t>::max() + num2));\n     if (!invalid)\n     {\n-        BOOST_CHECK(verify(bignum1 - bignum2, scriptnum1 - scriptnum2));\n-        BOOST_CHECK(verify(bignum1 - bignum2, scriptnum1 - num2));\n+        FAST_CHECK(verify(bignum1 - bignum2, scriptnum1 - scriptnum2));\n+        FAST_CHECK(verify(bignum1 - bignum2, scriptnum1 - num2));\n     }\n \n     invalid = ((num1 > 0 && num2 < std::numeric_limits<int64_t>::min() + num1) ||\n                (num1 < 0 && num2 > std::numeric_limits<int64_t>::max() + num1));\n     if (!invalid)\n     {\n-        BOOST_CHECK(verify(bignum2 - bignum1, scriptnum2 - scriptnum1));\n-        BOOST_CHECK(verify(bignum2 - bignum1, scriptnum2 - num1));\n+        FAST_CHECK(verify(bignum2 - bignum1, scriptnum2 - scriptnum1));\n+        FAST_CHECK(verify(bignum2 - bignum1, scriptnum2 - num1));\n     }\n }\n \n@@ -115,33 +115,33 @@ static void CheckCompare(const int64_t& num1, const int64_t& num2)\n     const CScriptNum scriptnum1(num1);\n     const CScriptNum scriptnum2(num2);\n \n-    BOOST_CHECK((bignum1 == bignum1) == (scriptnum1 == scriptnum1));\n-    BOOST_CHECK((bignum1 != bignum1) ==  (scriptnum1 != scriptnum1));\n-    BOOST_CHECK((bignum1 < bignum1) ==  (scriptnum1 < scriptnum1));\n-    BOOST_CHECK((bignum1 > bignum1) ==  (scriptnum1 > scriptnum1));\n-    BOOST_CHECK((bignum1 >= bignum1) ==  (scriptnum1 >= scriptnum1));\n-    BOOST_CHECK((bignum1 <= bignum1) ==  (scriptnum1 <= scriptnum1));\n-\n-    BOOST_CHECK((bignum1 == bignum1) == (scriptnum1 == num1));\n-    BOOST_CHECK((bignum1 != bignum1) ==  (scriptnum1 != num1));\n-    BOOST_CHECK((bignum1 < bignum1) ==  (scriptnum1 < num1));\n-    BOOST_CHECK((bignum1 > bignum1) ==  (scriptnum1 > num1));\n-    BOOST_CHECK((bignum1 >= bignum1) ==  (scriptnum1 >= num1));\n-    BOOST_CHECK((bignum1 <= bignum1) ==  (scriptnum1 <= num1));\n-\n-    BOOST_CHECK((bignum1 == bignum2) ==  (scriptnum1 == scriptnum2));\n-    BOOST_CHECK((bignum1 != bignum2) ==  (scriptnum1 != scriptnum2));\n-    BOOST_CHECK((bignum1 < bignum2) ==  (scriptnum1 < scriptnum2));\n-    BOOST_CHECK((bignum1 > bignum2) ==  (scriptnum1 > scriptnum2));\n-    BOOST_CHECK((bignum1 >= bignum2) ==  (scriptnum1 >= scriptnum2));\n-    BOOST_CHECK((bignum1 <= bignum2) ==  (scriptnum1 <= scriptnum2));\n-\n-    BOOST_CHECK((bignum1 == bignum2) ==  (scriptnum1 == num2));\n-    BOOST_CHECK((bignum1 != bignum2) ==  (scriptnum1 != num2));\n-    BOOST_CHECK((bignum1 < bignum2) ==  (scriptnum1 < num2));\n-    BOOST_CHECK((bignum1 > bignum2) ==  (scriptnum1 > num2));\n-    BOOST_CHECK((bignum1 >= bignum2) ==  (scriptnum1 >= num2));\n-    BOOST_CHECK((bignum1 <= bignum2) ==  (scriptnum1 <= num2));\n+    FAST_CHECK((bignum1 == bignum1) == (scriptnum1 == scriptnum1));\n+    FAST_CHECK((bignum1 != bignum1) ==  (scriptnum1 != scriptnum1));\n+    FAST_CHECK((bignum1 < bignum1) ==  (scriptnum1 < scriptnum1));\n+    FAST_CHECK((bignum1 > bignum1) ==  (scriptnum1 > scriptnum1));\n+    FAST_CHECK((bignum1 >= bignum1) ==  (scriptnum1 >= scriptnum1));\n+    FAST_CHECK((bignum1 <= bignum1) ==  (scriptnum1 <= scriptnum1));\n+\n+    FAST_CHECK((bignum1 == bignum1) == (scriptnum1 == num1));\n+    FAST_CHECK((bignum1 != bignum1) ==  (scriptnum1 != num1));\n+    FAST_CHECK((bignum1 < bignum1) ==  (scriptnum1 < num1));\n+    FAST_CHECK((bignum1 > bignum1) ==  (scriptnum1 > num1));\n+    FAST_CHECK((bignum1 >= bignum1) ==  (scriptnum1 >= num1));\n+    FAST_CHECK((bignum1 <= bignum1) ==  (scriptnum1 <= num1));\n+\n+    FAST_CHECK((bignum1 == bignum2) ==  (scriptnum1 == scriptnum2));\n+    FAST_CHECK((bignum1 != bignum2) ==  (scriptnum1 != scriptnum2));\n+    FAST_CHECK((bignum1 < bignum2) ==  (scriptnum1 < scriptnum2));\n+    FAST_CHECK((bignum1 > bignum2) ==  (scriptnum1 > scriptnum2));\n+    FAST_CHECK((bignum1 >= bignum2) ==  (scriptnum1 >= scriptnum2));\n+    FAST_CHECK((bignum1 <= bignum2) ==  (scriptnum1 <= scriptnum2));\n+\n+    FAST_CHECK((bignum1 == bignum2) ==  (scriptnum1 == num2));\n+    FAST_CHECK((bignum1 != bignum2) ==  (scriptnum1 != num2));\n+    FAST_CHECK((bignum1 < bignum2) ==  (scriptnum1 < num2));\n+    FAST_CHECK((bignum1 > bignum2) ==  (scriptnum1 > num2));\n+    FAST_CHECK((bignum1 >= bignum2) ==  (scriptnum1 >= num2));\n+    FAST_CHECK((bignum1 <= bignum2) ==  (scriptnum1 <= num2));\n }\n \n static void RunCreate(const int64_t& num)\n@@ -152,7 +152,7 @@ static void RunCreate(const int64_t& num)\n         CheckCreateVch(num);\n     else\n     {\n-        BOOST_CHECK_THROW (CheckCreateVch(num), scriptnum10_error);\n+        FAST_CHECK_THROW (CheckCreateVch(num), scriptnum10_error);\n     }\n }\n "
      },
      {
        "sha": "9210cbef391b7b9c60cb144da4be35ae33173995",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 97,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -17,71 +17,71 @@ BOOST_FIXTURE_TEST_SUITE(serialize_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(sizes)\n {\n-    BOOST_CHECK_EQUAL(sizeof(char), GetSerializeSize(char(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(int8_t), GetSerializeSize(int8_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(uint8_t), GetSerializeSize(uint8_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(int16_t), GetSerializeSize(int16_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(uint16_t), GetSerializeSize(uint16_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(int32_t), GetSerializeSize(int32_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(uint32_t), GetSerializeSize(uint32_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(int64_t), GetSerializeSize(int64_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(uint64_t), GetSerializeSize(uint64_t(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(float), GetSerializeSize(float(0), 0));\n-    BOOST_CHECK_EQUAL(sizeof(double), GetSerializeSize(double(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(char), GetSerializeSize(char(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(int8_t), GetSerializeSize(int8_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(uint8_t), GetSerializeSize(uint8_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(int16_t), GetSerializeSize(int16_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(uint16_t), GetSerializeSize(uint16_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(int32_t), GetSerializeSize(int32_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(uint32_t), GetSerializeSize(uint32_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(int64_t), GetSerializeSize(int64_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(uint64_t), GetSerializeSize(uint64_t(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(float), GetSerializeSize(float(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(double), GetSerializeSize(double(0), 0));\n     // Bool is serialized as char\n-    BOOST_CHECK_EQUAL(sizeof(char), GetSerializeSize(bool(0), 0));\n+    FAST_CHECK_EQUAL(sizeof(char), GetSerializeSize(bool(0), 0));\n \n     // Sanity-check GetSerializeSize and c++ type matching\n-    BOOST_CHECK_EQUAL(GetSerializeSize(char(0), 0), 1);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int8_t(0), 0), 1);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint8_t(0), 0), 1);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int16_t(0), 0), 2);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint16_t(0), 0), 2);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int32_t(0), 0), 4);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint32_t(0), 0), 4);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int64_t(0), 0), 8);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint64_t(0), 0), 8);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(float(0), 0), 4);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(double(0), 0), 8);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(bool(0), 0), 1);\n+    FAST_CHECK_EQUAL(GetSerializeSize(char(0), 0), 1);\n+    FAST_CHECK_EQUAL(GetSerializeSize(int8_t(0), 0), 1);\n+    FAST_CHECK_EQUAL(GetSerializeSize(uint8_t(0), 0), 1);\n+    FAST_CHECK_EQUAL(GetSerializeSize(int16_t(0), 0), 2);\n+    FAST_CHECK_EQUAL(GetSerializeSize(uint16_t(0), 0), 2);\n+    FAST_CHECK_EQUAL(GetSerializeSize(int32_t(0), 0), 4);\n+    FAST_CHECK_EQUAL(GetSerializeSize(uint32_t(0), 0), 4);\n+    FAST_CHECK_EQUAL(GetSerializeSize(int64_t(0), 0), 8);\n+    FAST_CHECK_EQUAL(GetSerializeSize(uint64_t(0), 0), 8);\n+    FAST_CHECK_EQUAL(GetSerializeSize(float(0), 0), 4);\n+    FAST_CHECK_EQUAL(GetSerializeSize(double(0), 0), 8);\n+    FAST_CHECK_EQUAL(GetSerializeSize(bool(0), 0), 1);\n }\n \n BOOST_AUTO_TEST_CASE(floats_conversion)\n {\n     // Choose values that map unambigiously to binary floating point to avoid\n     // rounding issues at the compiler side.\n-    BOOST_CHECK_EQUAL(ser_uint32_to_float(0x00000000), 0.0F);\n-    BOOST_CHECK_EQUAL(ser_uint32_to_float(0x3f000000), 0.5F);\n-    BOOST_CHECK_EQUAL(ser_uint32_to_float(0x3f800000), 1.0F);\n-    BOOST_CHECK_EQUAL(ser_uint32_to_float(0x40000000), 2.0F);\n-    BOOST_CHECK_EQUAL(ser_uint32_to_float(0x40800000), 4.0F);\n-    BOOST_CHECK_EQUAL(ser_uint32_to_float(0x44444444), 785.066650390625F);\n-\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(0.0F), 0x00000000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(0.5F), 0x3f000000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(1.0F), 0x3f800000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(2.0F), 0x40000000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(4.0F), 0x40800000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(785.066650390625F), 0x44444444);\n+    FAST_CHECK_EQUAL(ser_uint32_to_float(0x00000000), 0.0F);\n+    FAST_CHECK_EQUAL(ser_uint32_to_float(0x3f000000), 0.5F);\n+    FAST_CHECK_EQUAL(ser_uint32_to_float(0x3f800000), 1.0F);\n+    FAST_CHECK_EQUAL(ser_uint32_to_float(0x40000000), 2.0F);\n+    FAST_CHECK_EQUAL(ser_uint32_to_float(0x40800000), 4.0F);\n+    FAST_CHECK_EQUAL(ser_uint32_to_float(0x44444444), 785.066650390625F);\n+\n+    FAST_CHECK_EQUAL(ser_float_to_uint32(0.0F), 0x00000000);\n+    FAST_CHECK_EQUAL(ser_float_to_uint32(0.5F), 0x3f000000);\n+    FAST_CHECK_EQUAL(ser_float_to_uint32(1.0F), 0x3f800000);\n+    FAST_CHECK_EQUAL(ser_float_to_uint32(2.0F), 0x40000000);\n+    FAST_CHECK_EQUAL(ser_float_to_uint32(4.0F), 0x40800000);\n+    FAST_CHECK_EQUAL(ser_float_to_uint32(785.066650390625F), 0x44444444);\n }\n \n BOOST_AUTO_TEST_CASE(doubles_conversion)\n {\n     // Choose values that map unambigiously to binary floating point to avoid\n     // rounding issues at the compiler side.\n-    BOOST_CHECK_EQUAL(ser_uint64_to_double(0x0000000000000000ULL), 0.0);\n-    BOOST_CHECK_EQUAL(ser_uint64_to_double(0x3fe0000000000000ULL), 0.5);\n-    BOOST_CHECK_EQUAL(ser_uint64_to_double(0x3ff0000000000000ULL), 1.0);\n-    BOOST_CHECK_EQUAL(ser_uint64_to_double(0x4000000000000000ULL), 2.0);\n-    BOOST_CHECK_EQUAL(ser_uint64_to_double(0x4010000000000000ULL), 4.0);\n-    BOOST_CHECK_EQUAL(ser_uint64_to_double(0x4088888880000000ULL), 785.066650390625);\n-\n-    BOOST_CHECK_EQUAL(ser_double_to_uint64(0.0), 0x0000000000000000ULL);\n-    BOOST_CHECK_EQUAL(ser_double_to_uint64(0.5), 0x3fe0000000000000ULL);\n-    BOOST_CHECK_EQUAL(ser_double_to_uint64(1.0), 0x3ff0000000000000ULL);\n-    BOOST_CHECK_EQUAL(ser_double_to_uint64(2.0), 0x4000000000000000ULL);\n-    BOOST_CHECK_EQUAL(ser_double_to_uint64(4.0), 0x4010000000000000ULL);\n-    BOOST_CHECK_EQUAL(ser_double_to_uint64(785.066650390625), 0x4088888880000000ULL);\n+    FAST_CHECK_EQUAL(ser_uint64_to_double(0x0000000000000000ULL), 0.0);\n+    FAST_CHECK_EQUAL(ser_uint64_to_double(0x3fe0000000000000ULL), 0.5);\n+    FAST_CHECK_EQUAL(ser_uint64_to_double(0x3ff0000000000000ULL), 1.0);\n+    FAST_CHECK_EQUAL(ser_uint64_to_double(0x4000000000000000ULL), 2.0);\n+    FAST_CHECK_EQUAL(ser_uint64_to_double(0x4010000000000000ULL), 4.0);\n+    FAST_CHECK_EQUAL(ser_uint64_to_double(0x4088888880000000ULL), 785.066650390625);\n+\n+    FAST_CHECK_EQUAL(ser_double_to_uint64(0.0), 0x0000000000000000ULL);\n+    FAST_CHECK_EQUAL(ser_double_to_uint64(0.5), 0x3fe0000000000000ULL);\n+    FAST_CHECK_EQUAL(ser_double_to_uint64(1.0), 0x3ff0000000000000ULL);\n+    FAST_CHECK_EQUAL(ser_double_to_uint64(2.0), 0x4000000000000000ULL);\n+    FAST_CHECK_EQUAL(ser_double_to_uint64(4.0), 0x4010000000000000ULL);\n+    FAST_CHECK_EQUAL(ser_double_to_uint64(785.066650390625), 0x4088888880000000ULL);\n }\n /*\n Python code to generate the below hashes:\n@@ -101,7 +101,7 @@ BOOST_AUTO_TEST_CASE(floats)\n     for (int i = 0; i < 1000; i++) {\n         ss << float(i);\n     }\n-    BOOST_CHECK(Hash(ss.begin(), ss.end()) == uint256S(\"8e8b4cf3e4df8b332057e3e23af42ebc663b61e0495d5e7e32d85099d7f3fe0c\"));\n+    FAST_CHECK(Hash(ss.begin(), ss.end()) == uint256S(\"8e8b4cf3e4df8b332057e3e23af42ebc663b61e0495d5e7e32d85099d7f3fe0c\"));\n \n     // decode\n     for (int i = 0; i < 1000; i++) {\n@@ -118,7 +118,7 @@ BOOST_AUTO_TEST_CASE(doubles)\n     for (int i = 0; i < 1000; i++) {\n         ss << double(i);\n     }\n-    BOOST_CHECK(Hash(ss.begin(), ss.end()) == uint256S(\"43d0c82591953c4eafe114590d392676a01585d25b25d433557f0d7878b23f96\"));\n+    FAST_CHECK(Hash(ss.begin(), ss.end()) == uint256S(\"43d0c82591953c4eafe114590d392676a01585d25b25d433557f0d7878b23f96\"));\n \n     // decode\n     for (int i = 0; i < 1000; i++) {\n@@ -137,13 +137,13 @@ BOOST_AUTO_TEST_CASE(varints)\n     for (int i = 0; i < 100000; i++) {\n         ss << VARINT(i);\n         size += ::GetSerializeSize(VARINT(i), 0, 0);\n-        BOOST_CHECK(size == ss.size());\n+        FAST_CHECK(size == ss.size());\n     }\n \n     for (uint64_t i = 0;  i < 100000000000ULL; i += 999999937) {\n         ss << VARINT(i);\n         size += ::GetSerializeSize(VARINT(i), 0, 0);\n-        BOOST_CHECK(size == ss.size());\n+        FAST_CHECK(size == ss.size());\n     }\n \n     // decode\n@@ -163,22 +163,22 @@ BOOST_AUTO_TEST_CASE(varints)\n BOOST_AUTO_TEST_CASE(varints_bitpatterns)\n {\n     CDataStream ss(SER_DISK, 0);\n-    ss << VARINT(0); BOOST_CHECK_EQUAL(HexStr(ss), \"00\"); ss.clear();\n-    ss << VARINT(0x7f); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n-    ss << VARINT((int8_t)0x7f); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n-    ss << VARINT(0x80); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n-    ss << VARINT((uint8_t)0x80); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n-    ss << VARINT(0x1234); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n-    ss << VARINT((int16_t)0x1234); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n-    ss << VARINT(0xffff); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n-    ss << VARINT((uint16_t)0xffff); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n-    ss << VARINT(0x123456); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n-    ss << VARINT((int32_t)0x123456); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n-    ss << VARINT(0x80123456U); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n-    ss << VARINT((uint32_t)0x80123456U); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n-    ss << VARINT(0xffffffff); BOOST_CHECK_EQUAL(HexStr(ss), \"8efefefe7f\"); ss.clear();\n-    ss << VARINT(0x7fffffffffffffffLL); BOOST_CHECK_EQUAL(HexStr(ss), \"fefefefefefefefe7f\"); ss.clear();\n-    ss << VARINT(0xffffffffffffffffULL); BOOST_CHECK_EQUAL(HexStr(ss), \"80fefefefefefefefe7f\"); ss.clear();\n+    ss << VARINT(0); FAST_CHECK_EQUAL(HexStr(ss), \"00\"); ss.clear();\n+    ss << VARINT(0x7f); FAST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n+    ss << VARINT((int8_t)0x7f); FAST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n+    ss << VARINT(0x80); FAST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n+    ss << VARINT((uint8_t)0x80); FAST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n+    ss << VARINT(0x1234); FAST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n+    ss << VARINT((int16_t)0x1234); FAST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n+    ss << VARINT(0xffff); FAST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n+    ss << VARINT((uint16_t)0xffff); FAST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n+    ss << VARINT(0x123456); FAST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n+    ss << VARINT((int32_t)0x123456); FAST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n+    ss << VARINT(0x80123456U); FAST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n+    ss << VARINT((uint32_t)0x80123456U); FAST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n+    ss << VARINT(0xffffffff); FAST_CHECK_EQUAL(HexStr(ss), \"8efefefe7f\"); ss.clear();\n+    ss << VARINT(0x7fffffffffffffffLL); FAST_CHECK_EQUAL(HexStr(ss), \"fefefefefefefefe7f\"); ss.clear();\n+    ss << VARINT(0xffffffffffffffffULL); FAST_CHECK_EQUAL(HexStr(ss), \"80fefefefefefefefe7f\"); ss.clear();\n }\n \n BOOST_AUTO_TEST_CASE(compactsize)\n@@ -221,80 +221,80 @@ BOOST_AUTO_TEST_CASE(noncanonical)\n \n     // zero encoded with three bytes:\n     ss.write(\"\\xfd\\x00\\x00\", 3);\n-    BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n+    FAST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0xfc encoded with three bytes:\n     ss.write(\"\\xfd\\xfc\\x00\", 3);\n-    BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n+    FAST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0xfd encoded with three bytes is OK:\n     ss.write(\"\\xfd\\xfd\\x00\", 3);\n     n = ReadCompactSize(ss);\n-    BOOST_CHECK(n == 0xfd);\n+    FAST_CHECK(n == 0xfd);\n \n     // zero encoded with five bytes:\n     ss.write(\"\\xfe\\x00\\x00\\x00\\x00\", 5);\n-    BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n+    FAST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0xffff encoded with five bytes:\n     ss.write(\"\\xfe\\xff\\xff\\x00\\x00\", 5);\n-    BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n+    FAST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // zero encoded with nine bytes:\n     ss.write(\"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 9);\n-    BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n+    FAST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0x01ffffff encoded with nine bytes:\n     ss.write(\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\\x00\", 9);\n-    BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n+    FAST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n }\n \n BOOST_AUTO_TEST_CASE(insert_delete)\n {\n     // Test inserting/deleting bytes.\n     CDataStream ss(SER_DISK, 0);\n-    BOOST_CHECK_EQUAL(ss.size(), 0);\n+    FAST_CHECK_EQUAL(ss.size(), 0);\n \n     ss.write(\"\\x00\\x01\\x02\\xff\", 4);\n-    BOOST_CHECK_EQUAL(ss.size(), 4);\n+    FAST_CHECK_EQUAL(ss.size(), 4);\n \n     char c = (char)11;\n \n     // Inserting at beginning/end/middle:\n     ss.insert(ss.begin(), c);\n-    BOOST_CHECK_EQUAL(ss.size(), 5);\n-    BOOST_CHECK_EQUAL(ss[0], c);\n-    BOOST_CHECK_EQUAL(ss[1], 0);\n+    FAST_CHECK_EQUAL(ss.size(), 5);\n+    FAST_CHECK_EQUAL(ss[0], c);\n+    FAST_CHECK_EQUAL(ss[1], 0);\n \n     ss.insert(ss.end(), c);\n-    BOOST_CHECK_EQUAL(ss.size(), 6);\n-    BOOST_CHECK_EQUAL(ss[4], (char)0xff);\n-    BOOST_CHECK_EQUAL(ss[5], c);\n+    FAST_CHECK_EQUAL(ss.size(), 6);\n+    FAST_CHECK_EQUAL(ss[4], (char)0xff);\n+    FAST_CHECK_EQUAL(ss[5], c);\n \n     ss.insert(ss.begin()+2, c);\n-    BOOST_CHECK_EQUAL(ss.size(), 7);\n-    BOOST_CHECK_EQUAL(ss[2], c);\n+    FAST_CHECK_EQUAL(ss.size(), 7);\n+    FAST_CHECK_EQUAL(ss[2], c);\n \n     // Delete at beginning/end/middle\n     ss.erase(ss.begin());\n-    BOOST_CHECK_EQUAL(ss.size(), 6);\n-    BOOST_CHECK_EQUAL(ss[0], 0);\n+    FAST_CHECK_EQUAL(ss.size(), 6);\n+    FAST_CHECK_EQUAL(ss[0], 0);\n \n     ss.erase(ss.begin()+ss.size()-1);\n-    BOOST_CHECK_EQUAL(ss.size(), 5);\n-    BOOST_CHECK_EQUAL(ss[4], (char)0xff);\n+    FAST_CHECK_EQUAL(ss.size(), 5);\n+    FAST_CHECK_EQUAL(ss[4], (char)0xff);\n \n     ss.erase(ss.begin()+1);\n-    BOOST_CHECK_EQUAL(ss.size(), 4);\n-    BOOST_CHECK_EQUAL(ss[0], 0);\n-    BOOST_CHECK_EQUAL(ss[1], 1);\n-    BOOST_CHECK_EQUAL(ss[2], 2);\n-    BOOST_CHECK_EQUAL(ss[3], (char)0xff);\n+    FAST_CHECK_EQUAL(ss.size(), 4);\n+    FAST_CHECK_EQUAL(ss[0], 0);\n+    FAST_CHECK_EQUAL(ss[1], 1);\n+    FAST_CHECK_EQUAL(ss[2], 2);\n+    FAST_CHECK_EQUAL(ss[3], (char)0xff);\n \n     // Make sure GetAndClear does the right thing:\n     CSerializeData d;\n     ss.GetAndClear(d);\n-    BOOST_CHECK_EQUAL(ss.size(), 0);\n+    FAST_CHECK_EQUAL(ss.size(), 0);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7cdd0103f8eaeb16eb06edda228bd11232015aec",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -159,7 +159,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n         }\n         std::cout << \"\\n\";\n         #endif\n-        BOOST_CHECK(sh == sho);\n+        FAST_CHECK(sh == sho);\n     }\n     #if defined(PRINT_SIGHASH_JSON)\n     std::cout << \"]\\n\";\n@@ -200,7 +200,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n \n           CValidationState state;\n           BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n-          BOOST_CHECK(state.IsValid());\n+          FAST_CHECK(state.IsValid());\n \n           std::vector<unsigned char> raw = ParseHex(raw_script);\n           scriptCode.insert(scriptCode.end(), raw.begin(), raw.end());"
      },
      {
        "sha": "0401f21e7d3d09e2ac0d86bdada89c2544441f0b",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -31,20 +31,20 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n {\n     // Test CScript::GetSigOpCount()\n     CScript s1;\n-    BOOST_CHECK_EQUAL(s1.GetSigOpCount(false), 0U);\n-    BOOST_CHECK_EQUAL(s1.GetSigOpCount(true), 0U);\n+    FAST_CHECK_EQUAL(s1.GetSigOpCount(false), 0U);\n+    FAST_CHECK_EQUAL(s1.GetSigOpCount(true), 0U);\n \n     uint160 dummy;\n     s1 << OP_1 << ToByteVector(dummy) << ToByteVector(dummy) << OP_2 << OP_CHECKMULTISIG;\n-    BOOST_CHECK_EQUAL(s1.GetSigOpCount(true), 2U);\n+    FAST_CHECK_EQUAL(s1.GetSigOpCount(true), 2U);\n     s1 << OP_IF << OP_CHECKSIG << OP_ENDIF;\n-    BOOST_CHECK_EQUAL(s1.GetSigOpCount(true), 3U);\n-    BOOST_CHECK_EQUAL(s1.GetSigOpCount(false), 21U);\n+    FAST_CHECK_EQUAL(s1.GetSigOpCount(true), 3U);\n+    FAST_CHECK_EQUAL(s1.GetSigOpCount(false), 21U);\n \n     CScript p2sh = GetScriptForDestination(CScriptID(s1));\n     CScript scriptSig;\n     scriptSig << OP_0 << Serialize(s1);\n-    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig), 3U);\n+    FAST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig), 3U);\n \n     std::vector<CPubKey> keys;\n     for (int i = 0; i < 3; i++)\n@@ -54,15 +54,15 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n         keys.push_back(k.GetPubKey());\n     }\n     CScript s2 = GetScriptForMultisig(1, keys);\n-    BOOST_CHECK_EQUAL(s2.GetSigOpCount(true), 3U);\n-    BOOST_CHECK_EQUAL(s2.GetSigOpCount(false), 20U);\n+    FAST_CHECK_EQUAL(s2.GetSigOpCount(true), 3U);\n+    FAST_CHECK_EQUAL(s2.GetSigOpCount(false), 20U);\n \n     p2sh = GetScriptForDestination(CScriptID(s2));\n-    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(true), 0U);\n-    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(false), 0U);\n+    FAST_CHECK_EQUAL(p2sh.GetSigOpCount(true), 0U);\n+    FAST_CHECK_EQUAL(p2sh.GetSigOpCount(false), 0U);\n     CScript scriptSig2;\n     scriptSig2 << OP_1 << ToByteVector(dummy) << ToByteVector(dummy) << Serialize(s2);\n-    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig2), 3U);\n+    FAST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig2), 3U);\n }\n \n /**\n@@ -74,7 +74,7 @@ ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction\n     ScriptError error;\n     CTransaction inputi(input);\n     bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, inputi.wit.vtxinwit.size() > 0 ? &inputi.wit.vtxinwit[0].scriptWitness : NULL, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue), &error);\n-    BOOST_CHECK((ret == true) == (error == SCRIPT_ERR_OK));\n+    FAST_CHECK((ret == true) == (error == SCRIPT_ERR_OK));\n \n     return error;\n }"
      },
      {
        "sha": "8367cdda5c4b2ea5fd101a8515daac2132790e15",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -27,20 +27,20 @@ BOOST_AUTO_TEST_CASE(skiplist_test)\n \n     for (int i=0; i<SKIPLIST_LENGTH; i++) {\n         if (i > 0) {\n-            BOOST_CHECK(vIndex[i].pskip == &vIndex[vIndex[i].pskip->nHeight]);\n-            BOOST_CHECK(vIndex[i].pskip->nHeight < i);\n+            FAST_CHECK(vIndex[i].pskip == &vIndex[vIndex[i].pskip->nHeight]);\n+            FAST_CHECK(vIndex[i].pskip->nHeight < i);\n         } else {\n-            BOOST_CHECK(vIndex[i].pskip == NULL);\n+            FAST_CHECK(vIndex[i].pskip == NULL);\n         }\n     }\n \n     for (int i=0; i < 1000; i++) {\n         int from = insecure_rand() % (SKIPLIST_LENGTH - 1);\n         int to = insecure_rand() % (from + 1);\n \n-        BOOST_CHECK(vIndex[SKIPLIST_LENGTH - 1].GetAncestor(from) == &vIndex[from]);\n-        BOOST_CHECK(vIndex[from].GetAncestor(to) == &vIndex[to]);\n-        BOOST_CHECK(vIndex[from].GetAncestor(0) == &vIndex[0]);\n+        FAST_CHECK(vIndex[SKIPLIST_LENGTH - 1].GetAncestor(from) == &vIndex[from]);\n+        FAST_CHECK(vIndex[from].GetAncestor(to) == &vIndex[to]);\n+        FAST_CHECK(vIndex[from].GetAncestor(0) == &vIndex[0]);\n     }\n }\n \n@@ -55,8 +55,8 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : NULL;\n         vBlocksMain[i].phashBlock = &vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n-        BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksMain[i].GetBlockHash()).GetLow64(), vBlocksMain[i].nHeight);\n-        BOOST_CHECK(vBlocksMain[i].pprev == NULL || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n+        FAST_CHECK_EQUAL((int)UintToArith256(vBlocksMain[i].GetBlockHash()).GetLow64(), vBlocksMain[i].nHeight);\n+        FAST_CHECK(vBlocksMain[i].pprev == NULL || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n     }\n \n     // Build a branch that splits off at block 49999, 50000 blocks long.\n@@ -68,8 +68,8 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vBlocksSide[i].pprev = i ? &vBlocksSide[i - 1] : &vBlocksMain[49999];\n         vBlocksSide[i].phashBlock = &vHashSide[i];\n         vBlocksSide[i].BuildSkip();\n-        BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksSide[i].GetBlockHash()).GetLow64(), vBlocksSide[i].nHeight);\n-        BOOST_CHECK(vBlocksSide[i].pprev == NULL || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n+        FAST_CHECK_EQUAL((int)UintToArith256(vBlocksSide[i].GetBlockHash()).GetLow64(), vBlocksSide[i].nHeight);\n+        FAST_CHECK(vBlocksSide[i].pprev == NULL || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n     }\n \n     // Build a CChain for the main branch.\n@@ -83,18 +83,18 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         CBlockLocator locator = chain.GetLocator(tip);\n \n         // The first result must be the block itself, the last one must be genesis.\n-        BOOST_CHECK(locator.vHave.front() == tip->GetBlockHash());\n-        BOOST_CHECK(locator.vHave.back() == vBlocksMain[0].GetBlockHash());\n+        FAST_CHECK(locator.vHave.front() == tip->GetBlockHash());\n+        FAST_CHECK(locator.vHave.back() == vBlocksMain[0].GetBlockHash());\n \n         // Entries 1 through 11 (inclusive) go back one step each.\n         for (unsigned int i = 1; i < 12 && i < locator.vHave.size() - 1; i++) {\n-            BOOST_CHECK_EQUAL(UintToArith256(locator.vHave[i]).GetLow64(), tip->nHeight - i);\n+            FAST_CHECK_EQUAL(UintToArith256(locator.vHave[i]).GetLow64(), tip->nHeight - i);\n         }\n \n         // The further ones (excluding the last one) go back with exponential steps.\n         unsigned int dist = 2;\n         for (unsigned int i = 12; i < locator.vHave.size() - 1; i++) {\n-            BOOST_CHECK_EQUAL(UintToArith256(locator.vHave[i - 1]).GetLow64() - UintToArith256(locator.vHave[i]).GetLow64(), dist);\n+            FAST_CHECK_EQUAL(UintToArith256(locator.vHave[i - 1]).GetLow64() - UintToArith256(locator.vHave[i]).GetLow64(), dist);\n             dist *= 2;\n         }\n     }"
      },
      {
        "sha": "4f2683fc5121b02f10a216aa13a8a72f02db4f46",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -26,7 +26,7 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n     \n     key += '\\x00','\\x00';\n     ds.Xor(key);\n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n             std::string(expected_xor.begin(), expected_xor.end()), \n             std::string(ds.begin(), ds.end()));\n \n@@ -41,7 +41,7 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n \n     key += '\\xff';\n     ds.Xor(key);\n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n             std::string(expected_xor.begin(), expected_xor.end()), \n             std::string(ds.begin(), ds.end())); \n     \n@@ -59,7 +59,7 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n     key += '\\xff','\\x0f';\n \n     ds.Xor(key);\n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n             std::string(expected_xor.begin(), expected_xor.end()), \n             std::string(ds.begin(), ds.end()));  \n }         "
      },
      {
        "sha": "faa4b3b0ec193da3736e77a1328e2b8ae6265b5c",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -63,7 +63,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n         {\n             CValidationState state;\n             bool ok = ActivateBestChain(state, chainparams);\n-            BOOST_CHECK(ok);\n+            FAST_CHECK(ok);\n         }\n         nScriptCheckThreads = 3;\n         for (int i=0; i < nScriptCheckThreads-1; i++)"
      },
      {
        "sha": "d374869abb04d810e626fafc9ef527ee84a03cbf",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -14,6 +14,13 @@\n #include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n+#define FAST_CHECK(x) if (!(x)) { BOOST_CHECK_MESSAGE(false, #x); }\n+#define FAST_CHECK_EQUAL(x, y) if ((x)!=(y)) { BOOST_CHECK_MESSAGE(false, \"(\" #x \") != (\" #y \")\"); }\n+#define FAST_CHECK_THROW(expr, ex) try { expr; BOOST_CHECK_MESSAGE(false, \"( \" #expr \" ) did not throw ( \" #ex \" )\"); } catch( ex ) { }\n+#define FAST_CHECK_NO_THROW(expr) try { expr;  } catch( ... ) {BOOST_CHECK_MESSAGE(false, \"( \" #expr \" ) threw exception\"); }\n+#define FAST_CHECK_EXCEPTION(expr, ex, pred) try { expr; BOOST_CHECK_MESSAGE(false, \"( \" #expr \" ) did not throw ( \" #ex \" )\"); } catch( ex& a ) { if (!pred(a)) BOOST_CHECK_MESSAGE(false, \"( \" #expr \" ) did not throw ( \" #ex \" ) under ( \" #pred \" )\" ); }\n+#define FAST_CHECK_EQUAL_COLLECTIONS(l, r, l1, r1) BOOST_CHECK_EQUAL_COLLECTIONS(l, r, l1, r1) \n+\n /** Basic testing setup.\n  * This just configures logging and chain parameters.\n  */"
      },
      {
        "sha": "ed79ff172c07c1c97cbc70907b937983fca0beef",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -15,25 +15,25 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n {\n     CMedianFilter<int> filter(5, 15);\n \n-    BOOST_CHECK_EQUAL(filter.median(), 15);\n+    FAST_CHECK_EQUAL(filter.median(), 15);\n \n     filter.input(20); // [15 20]\n-    BOOST_CHECK_EQUAL(filter.median(), 17);\n+    FAST_CHECK_EQUAL(filter.median(), 17);\n \n     filter.input(30); // [15 20 30]\n-    BOOST_CHECK_EQUAL(filter.median(), 20);\n+    FAST_CHECK_EQUAL(filter.median(), 20);\n \n     filter.input(3); // [3 15 20 30]\n-    BOOST_CHECK_EQUAL(filter.median(), 17);\n+    FAST_CHECK_EQUAL(filter.median(), 17);\n \n     filter.input(7); // [3 7 15 20 30]\n-    BOOST_CHECK_EQUAL(filter.median(), 15);\n+    FAST_CHECK_EQUAL(filter.median(), 15);\n \n     filter.input(18); // [3 7 18 20 30]\n-    BOOST_CHECK_EQUAL(filter.median(), 18);\n+    FAST_CHECK_EQUAL(filter.median(), 18);\n \n     filter.input(0); // [0 3 7 18 30]\n-    BOOST_CHECK_EQUAL(filter.median(), 7);\n+    FAST_CHECK_EQUAL(filter.median(), 7);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2e8c27726237d6f5b936c85d62971b9379b3cc50",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -151,7 +151,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n \n             CValidationState state;\n             BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n-            BOOST_CHECK(state.IsValid());\n+            FAST_CHECK(state.IsValid());\n \n             for (unsigned int i = 0; i < tx.vin.size(); i++)\n             {\n@@ -336,8 +336,8 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     t1.vout[0].nValue = 90*CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n \n-    BOOST_CHECK(AreInputsStandard(t1, coins));\n-    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n+    FAST_CHECK(AreInputsStandard(t1, coins));\n+    FAST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n }\n \n void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransaction& output, CMutableTransaction& input, bool success = true)\n@@ -570,7 +570,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output1, input1, 0, false);\n     CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n     CheckWithFlag(output2, input2, 0, false);\n-    BOOST_CHECK(output1 == output2);\n+    FAST_CHECK(output1 == output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -581,7 +581,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(scriptMulti)), output2, input2, false);\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n-    BOOST_CHECK(output1 == output2);\n+    FAST_CHECK(output1 == output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n@@ -593,7 +593,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore2, GetScriptForWitness(scriptMulti), output2, input2, false);\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n-    BOOST_CHECK(output1 == output2);\n+    FAST_CHECK(output1 == output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n@@ -605,7 +605,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output2, input2, false);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n-    BOOST_CHECK(output1 == output2);\n+    FAST_CHECK(output1 == output2);\n     UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n@@ -631,75 +631,75 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n \n     string reason;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n \n     // Check dust with default relay fee:\n     CAmount nDustThreshold = 182 * minRelayTxFee.GetFeePerK()/1000 * 3;\n-    BOOST_CHECK_EQUAL(nDustThreshold, 546);\n+    FAST_CHECK_EQUAL(nDustThreshold, 546);\n     // dust:\n     t.vout[0].nValue = nDustThreshold - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n     // not dust:\n     t.vout[0].nValue = nDustThreshold;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n \n     // Check dust with odd relay fee to verify rounding:\n     // nDustThreshold = 182 * 1234 / 1000 * 3\n     minRelayTxFee = CFeeRate(1234);\n     // dust:\n     t.vout[0].nValue = 672 - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n     // not dust:\n     t.vout[0].nValue = 672;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n     minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n \n     t.vout[0].scriptPubKey = CScript() << OP_1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n \n     // MAX_OP_RETURN_RELAY-byte TX_NULL_DATA (standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\n+    FAST_CHECK(IsStandardTx(t, reason));\n \n     // MAX_OP_RETURN_RELAY+1-byte TX_NULL_DATA (non-standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\n-    BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\n+    FAST_CHECK(!IsStandardTx(t, reason));\n \n     // Data payload can be encoded in any way...\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"00\") << ParseHex(\"01\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n     // OP_RESERVED *is* considered to be a PUSHDATA type opcode by IsPushOnly()!\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RESERVED << -1 << 0 << ParseHex(\"01\") << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15 << 16;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << 0 << ParseHex(\"01\") << 2 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n \n     // ...so long as it only contains PUSHDATA's\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n \n     // TX_NULL_DATA w/o PUSHDATA\n     t.vout.resize(1);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    FAST_CHECK(IsStandardTx(t, reason));\n \n     // Only one TX_NULL_DATA permitted in all cases\n     t.vout.resize(2);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    FAST_CHECK(!IsStandardTx(t, reason));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "be6160293a79cbd411d04cddd8a49554a0a07642",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -49,7 +49,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n         // Sign:\n         std::vector<unsigned char> vchSig;\n         uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        FAST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         spends[i].vin[0].scriptSig << vchSig;\n     }\n@@ -58,29 +58,29 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n     // Test 1: block with both of those transactions should be rejected.\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n+    FAST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n \n     // Test 2: ... and should be rejected if spend1 is in the memory pool\n-    BOOST_CHECK(ToMemPool(spends[0]));\n+    FAST_CHECK(ToMemPool(spends[0]));\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n+    FAST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n     mempool.clear();\n \n     // Test 3: ... and should be rejected if spend2 is in the memory pool\n-    BOOST_CHECK(ToMemPool(spends[1]));\n+    FAST_CHECK(ToMemPool(spends[1]));\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n+    FAST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n     mempool.clear();\n \n     // Final sanity test: first spend in mempool, second in block, that's OK:\n     std::vector<CMutableTransaction> oneSpend;\n     oneSpend.push_back(spends[0]);\n-    BOOST_CHECK(ToMemPool(spends[1]));\n+    FAST_CHECK(ToMemPool(spends[1]));\n     block = CreateAndProcessBlock(oneSpend, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+    FAST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n     // spends[1] should have been removed from the mempool when the\n     // block with spends[0] is accepted:\n-    BOOST_CHECK_EQUAL(mempool.size(), 0);\n+    FAST_CHECK_EQUAL(mempool.size(), 0);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "339068d064eb56672065dfd97ddd4f7defd6a30f",
        "filename": "src/test/uint256_tests.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 129,
        "changes": 258,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/uint256_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -74,54 +74,54 @@ inline uint160 uint160S(const std::string& str)\n \n BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n {\n-    BOOST_CHECK(1 == 0+1);\n+    FAST_CHECK(1 == 0+1);\n     // constructor uint256(vector<char>):\n-    BOOST_CHECK(R1L.ToString() == ArrayToString(R1Array,32));\n-    BOOST_CHECK(R1S.ToString() == ArrayToString(R1Array,20));\n-    BOOST_CHECK(R2L.ToString() == ArrayToString(R2Array,32));\n-    BOOST_CHECK(R2S.ToString() == ArrayToString(R2Array,20));\n-    BOOST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray,32));\n-    BOOST_CHECK(ZeroS.ToString() == ArrayToString(ZeroArray,20));\n-    BOOST_CHECK(OneL.ToString() == ArrayToString(OneArray,32));\n-    BOOST_CHECK(OneS.ToString() == ArrayToString(OneArray,20));\n-    BOOST_CHECK(MaxL.ToString() == ArrayToString(MaxArray,32));\n-    BOOST_CHECK(MaxS.ToString() == ArrayToString(MaxArray,20));\n-    BOOST_CHECK(OneL.ToString() != ArrayToString(ZeroArray,32));\n-    BOOST_CHECK(OneS.ToString() != ArrayToString(ZeroArray,20));\n+    FAST_CHECK(R1L.ToString() == ArrayToString(R1Array,32));\n+    FAST_CHECK(R1S.ToString() == ArrayToString(R1Array,20));\n+    FAST_CHECK(R2L.ToString() == ArrayToString(R2Array,32));\n+    FAST_CHECK(R2S.ToString() == ArrayToString(R2Array,20));\n+    FAST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray,32));\n+    FAST_CHECK(ZeroS.ToString() == ArrayToString(ZeroArray,20));\n+    FAST_CHECK(OneL.ToString() == ArrayToString(OneArray,32));\n+    FAST_CHECK(OneS.ToString() == ArrayToString(OneArray,20));\n+    FAST_CHECK(MaxL.ToString() == ArrayToString(MaxArray,32));\n+    FAST_CHECK(MaxS.ToString() == ArrayToString(MaxArray,20));\n+    FAST_CHECK(OneL.ToString() != ArrayToString(ZeroArray,32));\n+    FAST_CHECK(OneS.ToString() != ArrayToString(ZeroArray,20));\n \n     // == and !=\n-    BOOST_CHECK(R1L != R2L && R1S != R2S);\n-    BOOST_CHECK(ZeroL != OneL && ZeroS != OneS);\n-    BOOST_CHECK(OneL != ZeroL && OneS != ZeroS);\n-    BOOST_CHECK(MaxL != ZeroL && MaxS != ZeroS);\n+    FAST_CHECK(R1L != R2L && R1S != R2S);\n+    FAST_CHECK(ZeroL != OneL && ZeroS != OneS);\n+    FAST_CHECK(OneL != ZeroL && OneS != ZeroS);\n+    FAST_CHECK(MaxL != ZeroL && MaxS != ZeroS);\n \n     // String Constructor and Copy Constructor\n-    BOOST_CHECK(uint256S(\"0x\"+R1L.ToString()) == R1L);\n-    BOOST_CHECK(uint256S(\"0x\"+R2L.ToString()) == R2L);\n-    BOOST_CHECK(uint256S(\"0x\"+ZeroL.ToString()) == ZeroL);\n-    BOOST_CHECK(uint256S(\"0x\"+OneL.ToString()) == OneL);\n-    BOOST_CHECK(uint256S(\"0x\"+MaxL.ToString()) == MaxL);\n-    BOOST_CHECK(uint256S(R1L.ToString()) == R1L);\n-    BOOST_CHECK(uint256S(\"   0x\"+R1L.ToString()+\"   \") == R1L);\n-    BOOST_CHECK(uint256S(\"\") == ZeroL);\n-    BOOST_CHECK(R1L == uint256S(R1ArrayHex));\n-    BOOST_CHECK(uint256(R1L) == R1L);\n-    BOOST_CHECK(uint256(ZeroL) == ZeroL);\n-    BOOST_CHECK(uint256(OneL) == OneL);\n+    FAST_CHECK(uint256S(\"0x\"+R1L.ToString()) == R1L);\n+    FAST_CHECK(uint256S(\"0x\"+R2L.ToString()) == R2L);\n+    FAST_CHECK(uint256S(\"0x\"+ZeroL.ToString()) == ZeroL);\n+    FAST_CHECK(uint256S(\"0x\"+OneL.ToString()) == OneL);\n+    FAST_CHECK(uint256S(\"0x\"+MaxL.ToString()) == MaxL);\n+    FAST_CHECK(uint256S(R1L.ToString()) == R1L);\n+    FAST_CHECK(uint256S(\"   0x\"+R1L.ToString()+\"   \") == R1L);\n+    FAST_CHECK(uint256S(\"\") == ZeroL);\n+    FAST_CHECK(R1L == uint256S(R1ArrayHex));\n+    FAST_CHECK(uint256(R1L) == R1L);\n+    FAST_CHECK(uint256(ZeroL) == ZeroL);\n+    FAST_CHECK(uint256(OneL) == OneL);\n \n-    BOOST_CHECK(uint160S(\"0x\"+R1S.ToString()) == R1S);\n-    BOOST_CHECK(uint160S(\"0x\"+R2S.ToString()) == R2S);\n-    BOOST_CHECK(uint160S(\"0x\"+ZeroS.ToString()) == ZeroS);\n-    BOOST_CHECK(uint160S(\"0x\"+OneS.ToString()) == OneS);\n-    BOOST_CHECK(uint160S(\"0x\"+MaxS.ToString()) == MaxS);\n-    BOOST_CHECK(uint160S(R1S.ToString()) == R1S);\n-    BOOST_CHECK(uint160S(\"   0x\"+R1S.ToString()+\"   \") == R1S);\n-    BOOST_CHECK(uint160S(\"\") == ZeroS);\n-    BOOST_CHECK(R1S == uint160S(R1ArrayHex));\n+    FAST_CHECK(uint160S(\"0x\"+R1S.ToString()) == R1S);\n+    FAST_CHECK(uint160S(\"0x\"+R2S.ToString()) == R2S);\n+    FAST_CHECK(uint160S(\"0x\"+ZeroS.ToString()) == ZeroS);\n+    FAST_CHECK(uint160S(\"0x\"+OneS.ToString()) == OneS);\n+    FAST_CHECK(uint160S(\"0x\"+MaxS.ToString()) == MaxS);\n+    FAST_CHECK(uint160S(R1S.ToString()) == R1S);\n+    FAST_CHECK(uint160S(\"   0x\"+R1S.ToString()+\"   \") == R1S);\n+    FAST_CHECK(uint160S(\"\") == ZeroS);\n+    FAST_CHECK(R1S == uint160S(R1ArrayHex));\n \n-    BOOST_CHECK(uint160(R1S) == R1S);\n-    BOOST_CHECK(uint160(ZeroS) == ZeroS);\n-    BOOST_CHECK(uint160(OneS) == OneS);\n+    FAST_CHECK(uint160(R1S) == R1S);\n+    FAST_CHECK(uint160(ZeroS) == ZeroS);\n+    FAST_CHECK(uint160(OneS) == OneS);\n }\n \n BOOST_AUTO_TEST_CASE( comparison ) // <= >= < >\n@@ -130,140 +130,140 @@ BOOST_AUTO_TEST_CASE( comparison ) // <= >= < >\n     for (int i = 255; i >= 0; --i) {\n         uint256 TmpL;\n         *(TmpL.begin() + (i>>3)) |= 1<<(7-(i&7));\n-        BOOST_CHECK( LastL < TmpL );\n+        FAST_CHECK( LastL < TmpL );\n         LastL = TmpL;\n     }\n \n-    BOOST_CHECK( ZeroL < R1L );\n-    BOOST_CHECK( R2L < R1L );\n-    BOOST_CHECK( ZeroL < OneL );\n-    BOOST_CHECK( OneL < MaxL );\n-    BOOST_CHECK( R1L < MaxL );\n-    BOOST_CHECK( R2L < MaxL );\n+    FAST_CHECK( ZeroL < R1L );\n+    FAST_CHECK( R2L < R1L );\n+    FAST_CHECK( ZeroL < OneL );\n+    FAST_CHECK( OneL < MaxL );\n+    FAST_CHECK( R1L < MaxL );\n+    FAST_CHECK( R2L < MaxL );\n \n     uint160 LastS;\n     for (int i = 159; i >= 0; --i) {\n         uint160 TmpS;\n         *(TmpS.begin() + (i>>3)) |= 1<<(7-(i&7));\n-        BOOST_CHECK( LastS < TmpS );\n+        FAST_CHECK( LastS < TmpS );\n         LastS = TmpS;\n     }\n-    BOOST_CHECK( ZeroS < R1S );\n-    BOOST_CHECK( R2S < R1S );\n-    BOOST_CHECK( ZeroS < OneS );\n-    BOOST_CHECK( OneS < MaxS );\n-    BOOST_CHECK( R1S < MaxS );\n-    BOOST_CHECK( R2S < MaxS );\n+    FAST_CHECK( ZeroS < R1S );\n+    FAST_CHECK( R2S < R1S );\n+    FAST_CHECK( ZeroS < OneS );\n+    FAST_CHECK( OneS < MaxS );\n+    FAST_CHECK( R1S < MaxS );\n+    FAST_CHECK( R2S < MaxS );\n }\n \n BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex begin() end() size() GetLow64 GetSerializeSize, Serialize, Unserialize\n {\n-    BOOST_CHECK(R1L.GetHex() == R1L.ToString());\n-    BOOST_CHECK(R2L.GetHex() == R2L.ToString());\n-    BOOST_CHECK(OneL.GetHex() == OneL.ToString());\n-    BOOST_CHECK(MaxL.GetHex() == MaxL.ToString());\n+    FAST_CHECK(R1L.GetHex() == R1L.ToString());\n+    FAST_CHECK(R2L.GetHex() == R2L.ToString());\n+    FAST_CHECK(OneL.GetHex() == OneL.ToString());\n+    FAST_CHECK(MaxL.GetHex() == MaxL.ToString());\n     uint256 TmpL(R1L);\n-    BOOST_CHECK(TmpL == R1L);\n-    TmpL.SetHex(R2L.ToString());   BOOST_CHECK(TmpL == R2L);\n-    TmpL.SetHex(ZeroL.ToString()); BOOST_CHECK(TmpL == uint256());\n+    FAST_CHECK(TmpL == R1L);\n+    TmpL.SetHex(R2L.ToString());   FAST_CHECK(TmpL == R2L);\n+    TmpL.SetHex(ZeroL.ToString()); FAST_CHECK(TmpL == uint256());\n \n     TmpL.SetHex(R1L.ToString());\n-    BOOST_CHECK(memcmp(R1L.begin(), R1Array, 32)==0);\n-    BOOST_CHECK(memcmp(TmpL.begin(), R1Array, 32)==0);\n-    BOOST_CHECK(memcmp(R2L.begin(), R2Array, 32)==0);\n-    BOOST_CHECK(memcmp(ZeroL.begin(), ZeroArray, 32)==0);\n-    BOOST_CHECK(memcmp(OneL.begin(), OneArray, 32)==0);\n-    BOOST_CHECK(R1L.size() == sizeof(R1L));\n-    BOOST_CHECK(sizeof(R1L) == 32);\n-    BOOST_CHECK(R1L.size() == 32);\n-    BOOST_CHECK(R2L.size() == 32);\n-    BOOST_CHECK(ZeroL.size() == 32);\n-    BOOST_CHECK(MaxL.size() == 32);\n-    BOOST_CHECK(R1L.begin() + 32 == R1L.end());\n-    BOOST_CHECK(R2L.begin() + 32 == R2L.end());\n-    BOOST_CHECK(OneL.begin() + 32 == OneL.end());\n-    BOOST_CHECK(MaxL.begin() + 32 == MaxL.end());\n-    BOOST_CHECK(TmpL.begin() + 32 == TmpL.end());\n-    BOOST_CHECK(R1L.GetSerializeSize(0,PROTOCOL_VERSION) == 32);\n-    BOOST_CHECK(ZeroL.GetSerializeSize(0,PROTOCOL_VERSION) == 32);\n+    FAST_CHECK(memcmp(R1L.begin(), R1Array, 32)==0);\n+    FAST_CHECK(memcmp(TmpL.begin(), R1Array, 32)==0);\n+    FAST_CHECK(memcmp(R2L.begin(), R2Array, 32)==0);\n+    FAST_CHECK(memcmp(ZeroL.begin(), ZeroArray, 32)==0);\n+    FAST_CHECK(memcmp(OneL.begin(), OneArray, 32)==0);\n+    FAST_CHECK(R1L.size() == sizeof(R1L));\n+    FAST_CHECK(sizeof(R1L) == 32);\n+    FAST_CHECK(R1L.size() == 32);\n+    FAST_CHECK(R2L.size() == 32);\n+    FAST_CHECK(ZeroL.size() == 32);\n+    FAST_CHECK(MaxL.size() == 32);\n+    FAST_CHECK(R1L.begin() + 32 == R1L.end());\n+    FAST_CHECK(R2L.begin() + 32 == R2L.end());\n+    FAST_CHECK(OneL.begin() + 32 == OneL.end());\n+    FAST_CHECK(MaxL.begin() + 32 == MaxL.end());\n+    FAST_CHECK(TmpL.begin() + 32 == TmpL.end());\n+    FAST_CHECK(R1L.GetSerializeSize(0,PROTOCOL_VERSION) == 32);\n+    FAST_CHECK(ZeroL.GetSerializeSize(0,PROTOCOL_VERSION) == 32);\n \n     std::stringstream ss;\n     R1L.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(R1Array,R1Array+32));\n+    FAST_CHECK(ss.str() == std::string(R1Array,R1Array+32));\n     TmpL.Unserialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(R1L == TmpL);\n+    FAST_CHECK(R1L == TmpL);\n     ss.str(\"\");\n     ZeroL.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(ZeroArray,ZeroArray+32));\n+    FAST_CHECK(ss.str() == std::string(ZeroArray,ZeroArray+32));\n     TmpL.Unserialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ZeroL == TmpL);\n+    FAST_CHECK(ZeroL == TmpL);\n     ss.str(\"\");\n     MaxL.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(MaxArray,MaxArray+32));\n+    FAST_CHECK(ss.str() == std::string(MaxArray,MaxArray+32));\n     TmpL.Unserialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(MaxL == TmpL);\n+    FAST_CHECK(MaxL == TmpL);\n     ss.str(\"\");\n \n-    BOOST_CHECK(R1S.GetHex() == R1S.ToString());\n-    BOOST_CHECK(R2S.GetHex() == R2S.ToString());\n-    BOOST_CHECK(OneS.GetHex() == OneS.ToString());\n-    BOOST_CHECK(MaxS.GetHex() == MaxS.ToString());\n+    FAST_CHECK(R1S.GetHex() == R1S.ToString());\n+    FAST_CHECK(R2S.GetHex() == R2S.ToString());\n+    FAST_CHECK(OneS.GetHex() == OneS.ToString());\n+    FAST_CHECK(MaxS.GetHex() == MaxS.ToString());\n     uint160 TmpS(R1S);\n-    BOOST_CHECK(TmpS == R1S);\n-    TmpS.SetHex(R2S.ToString());   BOOST_CHECK(TmpS == R2S);\n-    TmpS.SetHex(ZeroS.ToString()); BOOST_CHECK(TmpS == uint160());\n+    FAST_CHECK(TmpS == R1S);\n+    TmpS.SetHex(R2S.ToString());   FAST_CHECK(TmpS == R2S);\n+    TmpS.SetHex(ZeroS.ToString()); FAST_CHECK(TmpS == uint160());\n \n     TmpS.SetHex(R1S.ToString());\n-    BOOST_CHECK(memcmp(R1S.begin(), R1Array, 20)==0);\n-    BOOST_CHECK(memcmp(TmpS.begin(), R1Array, 20)==0);\n-    BOOST_CHECK(memcmp(R2S.begin(), R2Array, 20)==0);\n-    BOOST_CHECK(memcmp(ZeroS.begin(), ZeroArray, 20)==0);\n-    BOOST_CHECK(memcmp(OneS.begin(), OneArray, 20)==0);\n-    BOOST_CHECK(R1S.size() == sizeof(R1S));\n-    BOOST_CHECK(sizeof(R1S) == 20);\n-    BOOST_CHECK(R1S.size() == 20);\n-    BOOST_CHECK(R2S.size() == 20);\n-    BOOST_CHECK(ZeroS.size() == 20);\n-    BOOST_CHECK(MaxS.size() == 20);\n-    BOOST_CHECK(R1S.begin() + 20 == R1S.end());\n-    BOOST_CHECK(R2S.begin() + 20 == R2S.end());\n-    BOOST_CHECK(OneS.begin() + 20 == OneS.end());\n-    BOOST_CHECK(MaxS.begin() + 20 == MaxS.end());\n-    BOOST_CHECK(TmpS.begin() + 20 == TmpS.end());\n-    BOOST_CHECK(R1S.GetSerializeSize(0,PROTOCOL_VERSION) == 20);\n-    BOOST_CHECK(ZeroS.GetSerializeSize(0,PROTOCOL_VERSION) == 20);\n+    FAST_CHECK(memcmp(R1S.begin(), R1Array, 20)==0);\n+    FAST_CHECK(memcmp(TmpS.begin(), R1Array, 20)==0);\n+    FAST_CHECK(memcmp(R2S.begin(), R2Array, 20)==0);\n+    FAST_CHECK(memcmp(ZeroS.begin(), ZeroArray, 20)==0);\n+    FAST_CHECK(memcmp(OneS.begin(), OneArray, 20)==0);\n+    FAST_CHECK(R1S.size() == sizeof(R1S));\n+    FAST_CHECK(sizeof(R1S) == 20);\n+    FAST_CHECK(R1S.size() == 20);\n+    FAST_CHECK(R2S.size() == 20);\n+    FAST_CHECK(ZeroS.size() == 20);\n+    FAST_CHECK(MaxS.size() == 20);\n+    FAST_CHECK(R1S.begin() + 20 == R1S.end());\n+    FAST_CHECK(R2S.begin() + 20 == R2S.end());\n+    FAST_CHECK(OneS.begin() + 20 == OneS.end());\n+    FAST_CHECK(MaxS.begin() + 20 == MaxS.end());\n+    FAST_CHECK(TmpS.begin() + 20 == TmpS.end());\n+    FAST_CHECK(R1S.GetSerializeSize(0,PROTOCOL_VERSION) == 20);\n+    FAST_CHECK(ZeroS.GetSerializeSize(0,PROTOCOL_VERSION) == 20);\n \n     R1S.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(R1Array,R1Array+20));\n+    FAST_CHECK(ss.str() == std::string(R1Array,R1Array+20));\n     TmpS.Unserialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(R1S == TmpS);\n+    FAST_CHECK(R1S == TmpS);\n     ss.str(\"\");\n     ZeroS.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(ZeroArray,ZeroArray+20));\n+    FAST_CHECK(ss.str() == std::string(ZeroArray,ZeroArray+20));\n     TmpS.Unserialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ZeroS == TmpS);\n+    FAST_CHECK(ZeroS == TmpS);\n     ss.str(\"\");\n     MaxS.Serialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(ss.str() == std::string(MaxArray,MaxArray+20));\n+    FAST_CHECK(ss.str() == std::string(MaxArray,MaxArray+20));\n     TmpS.Unserialize(ss,0,PROTOCOL_VERSION);\n-    BOOST_CHECK(MaxS == TmpS);\n+    FAST_CHECK(MaxS == TmpS);\n     ss.str(\"\");\n }\n \n BOOST_AUTO_TEST_CASE( conversion )\n {\n-    BOOST_CHECK(ArithToUint256(UintToArith256(ZeroL)) == ZeroL);\n-    BOOST_CHECK(ArithToUint256(UintToArith256(OneL)) == OneL);\n-    BOOST_CHECK(ArithToUint256(UintToArith256(R1L)) == R1L);\n-    BOOST_CHECK(ArithToUint256(UintToArith256(R2L)) == R2L);\n-    BOOST_CHECK(UintToArith256(ZeroL) == 0);\n-    BOOST_CHECK(UintToArith256(OneL) == 1);\n-    BOOST_CHECK(ArithToUint256(0) == ZeroL);\n-    BOOST_CHECK(ArithToUint256(1) == OneL);\n-    BOOST_CHECK(arith_uint256(R1L.GetHex()) == UintToArith256(R1L));\n-    BOOST_CHECK(arith_uint256(R2L.GetHex()) == UintToArith256(R2L));\n-    BOOST_CHECK(R1L.GetHex() == UintToArith256(R1L).GetHex());\n-    BOOST_CHECK(R2L.GetHex() == UintToArith256(R2L).GetHex());\n+    FAST_CHECK(ArithToUint256(UintToArith256(ZeroL)) == ZeroL);\n+    FAST_CHECK(ArithToUint256(UintToArith256(OneL)) == OneL);\n+    FAST_CHECK(ArithToUint256(UintToArith256(R1L)) == R1L);\n+    FAST_CHECK(ArithToUint256(UintToArith256(R2L)) == R2L);\n+    FAST_CHECK(UintToArith256(ZeroL) == 0);\n+    FAST_CHECK(UintToArith256(OneL) == 1);\n+    FAST_CHECK(ArithToUint256(0) == ZeroL);\n+    FAST_CHECK(ArithToUint256(1) == OneL);\n+    FAST_CHECK(arith_uint256(R1L.GetHex()) == UintToArith256(R1L));\n+    FAST_CHECK(arith_uint256(R2L.GetHex()) == UintToArith256(R2L));\n+    FAST_CHECK(R1L.GetHex() == UintToArith256(R1L).GetHex());\n+    FAST_CHECK(R2L.GetHex() == UintToArith256(R2L).GetHex());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "35926747593277b4af68949f494564c7d4d89d3f",
        "filename": "src/test/univalue_tests.cpp",
        "status": "modified",
        "additions": 177,
        "deletions": 177,
        "changes": 354,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/univalue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/univalue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/univalue_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -19,164 +19,164 @@ BOOST_FIXTURE_TEST_SUITE(univalue_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(univalue_constructor)\n {\n     UniValue v1;\n-    BOOST_CHECK(v1.isNull());\n+    FAST_CHECK(v1.isNull());\n \n     UniValue v2(UniValue::VSTR);\n-    BOOST_CHECK(v2.isStr());\n+    FAST_CHECK(v2.isStr());\n \n     UniValue v3(UniValue::VSTR, \"foo\");\n-    BOOST_CHECK(v3.isStr());\n-    BOOST_CHECK_EQUAL(v3.getValStr(), \"foo\");\n+    FAST_CHECK(v3.isStr());\n+    FAST_CHECK_EQUAL(v3.getValStr(), \"foo\");\n \n     UniValue numTest;\n-    BOOST_CHECK(numTest.setNumStr(\"82\"));\n-    BOOST_CHECK(numTest.isNum());\n-    BOOST_CHECK_EQUAL(numTest.getValStr(), \"82\");\n+    FAST_CHECK(numTest.setNumStr(\"82\"));\n+    FAST_CHECK(numTest.isNum());\n+    FAST_CHECK_EQUAL(numTest.getValStr(), \"82\");\n \n     uint64_t vu64 = 82;\n     UniValue v4(vu64);\n-    BOOST_CHECK(v4.isNum());\n-    BOOST_CHECK_EQUAL(v4.getValStr(), \"82\");\n+    FAST_CHECK(v4.isNum());\n+    FAST_CHECK_EQUAL(v4.getValStr(), \"82\");\n \n     int64_t vi64 = -82;\n     UniValue v5(vi64);\n-    BOOST_CHECK(v5.isNum());\n-    BOOST_CHECK_EQUAL(v5.getValStr(), \"-82\");\n+    FAST_CHECK(v5.isNum());\n+    FAST_CHECK_EQUAL(v5.getValStr(), \"-82\");\n \n     int vi = -688;\n     UniValue v6(vi);\n-    BOOST_CHECK(v6.isNum());\n-    BOOST_CHECK_EQUAL(v6.getValStr(), \"-688\");\n+    FAST_CHECK(v6.isNum());\n+    FAST_CHECK_EQUAL(v6.getValStr(), \"-688\");\n \n     double vd = -7.21;\n     UniValue v7(vd);\n-    BOOST_CHECK(v7.isNum());\n-    BOOST_CHECK_EQUAL(v7.getValStr(), \"-7.21\");\n+    FAST_CHECK(v7.isNum());\n+    FAST_CHECK_EQUAL(v7.getValStr(), \"-7.21\");\n \n     string vs(\"yawn\");\n     UniValue v8(vs);\n-    BOOST_CHECK(v8.isStr());\n-    BOOST_CHECK_EQUAL(v8.getValStr(), \"yawn\");\n+    FAST_CHECK(v8.isStr());\n+    FAST_CHECK_EQUAL(v8.getValStr(), \"yawn\");\n \n     const char *vcs = \"zappa\";\n     UniValue v9(vcs);\n-    BOOST_CHECK(v9.isStr());\n-    BOOST_CHECK_EQUAL(v9.getValStr(), \"zappa\");\n+    FAST_CHECK(v9.isStr());\n+    FAST_CHECK_EQUAL(v9.getValStr(), \"zappa\");\n }\n \n BOOST_AUTO_TEST_CASE(univalue_typecheck)\n {\n     UniValue v1;\n-    BOOST_CHECK(v1.setNumStr(\"1\"));\n-    BOOST_CHECK(v1.isNum());\n-    BOOST_CHECK_THROW(v1.get_bool(), runtime_error);\n+    FAST_CHECK(v1.setNumStr(\"1\"));\n+    FAST_CHECK(v1.isNum());\n+    FAST_CHECK_THROW(v1.get_bool(), runtime_error);\n \n     UniValue v2;\n-    BOOST_CHECK(v2.setBool(true));\n-    BOOST_CHECK_EQUAL(v2.get_bool(), true);\n-    BOOST_CHECK_THROW(v2.get_int(), runtime_error);\n+    FAST_CHECK(v2.setBool(true));\n+    FAST_CHECK_EQUAL(v2.get_bool(), true);\n+    FAST_CHECK_THROW(v2.get_int(), runtime_error);\n \n     UniValue v3;\n-    BOOST_CHECK(v3.setNumStr(\"32482348723847471234\"));\n-    BOOST_CHECK_THROW(v3.get_int64(), runtime_error);\n-    BOOST_CHECK(v3.setNumStr(\"1000\"));\n-    BOOST_CHECK_EQUAL(v3.get_int64(), 1000);\n+    FAST_CHECK(v3.setNumStr(\"32482348723847471234\"));\n+    FAST_CHECK_THROW(v3.get_int64(), runtime_error);\n+    FAST_CHECK(v3.setNumStr(\"1000\"));\n+    FAST_CHECK_EQUAL(v3.get_int64(), 1000);\n \n     UniValue v4;\n-    BOOST_CHECK(v4.setNumStr(\"2147483648\"));\n-    BOOST_CHECK_EQUAL(v4.get_int64(), 2147483648);\n-    BOOST_CHECK_THROW(v4.get_int(), runtime_error);\n-    BOOST_CHECK(v4.setNumStr(\"1000\"));\n-    BOOST_CHECK_EQUAL(v4.get_int(), 1000);\n-    BOOST_CHECK_THROW(v4.get_str(), runtime_error);\n-    BOOST_CHECK_EQUAL(v4.get_real(), 1000);\n-    BOOST_CHECK_THROW(v4.get_array(), runtime_error);\n-    BOOST_CHECK_THROW(v4.getKeys(), runtime_error);\n-    BOOST_CHECK_THROW(v4.getValues(), runtime_error);\n-    BOOST_CHECK_THROW(v4.get_obj(), runtime_error);\n+    FAST_CHECK(v4.setNumStr(\"2147483648\"));\n+    FAST_CHECK_EQUAL(v4.get_int64(), 2147483648);\n+    FAST_CHECK_THROW(v4.get_int(), runtime_error);\n+    FAST_CHECK(v4.setNumStr(\"1000\"));\n+    FAST_CHECK_EQUAL(v4.get_int(), 1000);\n+    FAST_CHECK_THROW(v4.get_str(), runtime_error);\n+    FAST_CHECK_EQUAL(v4.get_real(), 1000);\n+    FAST_CHECK_THROW(v4.get_array(), runtime_error);\n+    FAST_CHECK_THROW(v4.getKeys(), runtime_error);\n+    FAST_CHECK_THROW(v4.getValues(), runtime_error);\n+    FAST_CHECK_THROW(v4.get_obj(), runtime_error);\n \n     UniValue v5;\n-    BOOST_CHECK(v5.read(\"[true, 10]\"));\n-    BOOST_CHECK_NO_THROW(v5.get_array());\n+    FAST_CHECK(v5.read(\"[true, 10]\"));\n+    FAST_CHECK_NO_THROW(v5.get_array());\n     std::vector<UniValue> vals = v5.getValues();\n-    BOOST_CHECK_THROW(vals[0].get_int(), runtime_error);\n-    BOOST_CHECK_EQUAL(vals[0].get_bool(), true);\n+    FAST_CHECK_THROW(vals[0].get_int(), runtime_error);\n+    FAST_CHECK_EQUAL(vals[0].get_bool(), true);\n \n-    BOOST_CHECK_EQUAL(vals[1].get_int(), 10);\n-    BOOST_CHECK_THROW(vals[1].get_bool(), runtime_error);\n+    FAST_CHECK_EQUAL(vals[1].get_int(), 10);\n+    FAST_CHECK_THROW(vals[1].get_bool(), runtime_error);\n }\n \n BOOST_AUTO_TEST_CASE(univalue_set)\n {\n     UniValue v(UniValue::VSTR, \"foo\");\n     v.clear();\n-    BOOST_CHECK(v.isNull());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"\");\n-\n-    BOOST_CHECK(v.setObject());\n-    BOOST_CHECK(v.isObject());\n-    BOOST_CHECK_EQUAL(v.size(), 0);\n-    BOOST_CHECK_EQUAL(v.getType(), UniValue::VOBJ);\n-    BOOST_CHECK(v.empty());\n-\n-    BOOST_CHECK(v.setArray());\n-    BOOST_CHECK(v.isArray());\n-    BOOST_CHECK_EQUAL(v.size(), 0);\n-\n-    BOOST_CHECK(v.setStr(\"zum\"));\n-    BOOST_CHECK(v.isStr());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"zum\");\n-\n-    BOOST_CHECK(v.setFloat(-1.01));\n-    BOOST_CHECK(v.isNum());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"-1.01\");\n-\n-    BOOST_CHECK(v.setInt((int)1023));\n-    BOOST_CHECK(v.isNum());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"1023\");\n-\n-    BOOST_CHECK(v.setInt((int64_t)-1023LL));\n-    BOOST_CHECK(v.isNum());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"-1023\");\n-\n-    BOOST_CHECK(v.setInt((uint64_t)1023ULL));\n-    BOOST_CHECK(v.isNum());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"1023\");\n-\n-    BOOST_CHECK(v.setNumStr(\"-688\"));\n-    BOOST_CHECK(v.isNum());\n-    BOOST_CHECK_EQUAL(v.getValStr(), \"-688\");\n-\n-    BOOST_CHECK(v.setBool(false));\n-    BOOST_CHECK_EQUAL(v.isBool(), true);\n-    BOOST_CHECK_EQUAL(v.isTrue(), false);\n-    BOOST_CHECK_EQUAL(v.isFalse(), true);\n-    BOOST_CHECK_EQUAL(v.getBool(), false);\n-\n-    BOOST_CHECK(v.setBool(true));\n-    BOOST_CHECK_EQUAL(v.isBool(), true);\n-    BOOST_CHECK_EQUAL(v.isTrue(), true);\n-    BOOST_CHECK_EQUAL(v.isFalse(), false);\n-    BOOST_CHECK_EQUAL(v.getBool(), true);\n-\n-    BOOST_CHECK(!v.setNumStr(\"zombocom\"));\n-\n-    BOOST_CHECK(v.setNull());\n-    BOOST_CHECK(v.isNull());\n+    FAST_CHECK(v.isNull());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"\");\n+\n+    FAST_CHECK(v.setObject());\n+    FAST_CHECK(v.isObject());\n+    FAST_CHECK_EQUAL(v.size(), 0);\n+    FAST_CHECK_EQUAL(v.getType(), UniValue::VOBJ);\n+    FAST_CHECK(v.empty());\n+\n+    FAST_CHECK(v.setArray());\n+    FAST_CHECK(v.isArray());\n+    FAST_CHECK_EQUAL(v.size(), 0);\n+\n+    FAST_CHECK(v.setStr(\"zum\"));\n+    FAST_CHECK(v.isStr());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"zum\");\n+\n+    FAST_CHECK(v.setFloat(-1.01));\n+    FAST_CHECK(v.isNum());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"-1.01\");\n+\n+    FAST_CHECK(v.setInt((int)1023));\n+    FAST_CHECK(v.isNum());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"1023\");\n+\n+    FAST_CHECK(v.setInt((int64_t)-1023LL));\n+    FAST_CHECK(v.isNum());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"-1023\");\n+\n+    FAST_CHECK(v.setInt((uint64_t)1023ULL));\n+    FAST_CHECK(v.isNum());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"1023\");\n+\n+    FAST_CHECK(v.setNumStr(\"-688\"));\n+    FAST_CHECK(v.isNum());\n+    FAST_CHECK_EQUAL(v.getValStr(), \"-688\");\n+\n+    FAST_CHECK(v.setBool(false));\n+    FAST_CHECK_EQUAL(v.isBool(), true);\n+    FAST_CHECK_EQUAL(v.isTrue(), false);\n+    FAST_CHECK_EQUAL(v.isFalse(), true);\n+    FAST_CHECK_EQUAL(v.getBool(), false);\n+\n+    FAST_CHECK(v.setBool(true));\n+    FAST_CHECK_EQUAL(v.isBool(), true);\n+    FAST_CHECK_EQUAL(v.isTrue(), true);\n+    FAST_CHECK_EQUAL(v.isFalse(), false);\n+    FAST_CHECK_EQUAL(v.getBool(), true);\n+\n+    FAST_CHECK(!v.setNumStr(\"zombocom\"));\n+\n+    FAST_CHECK(v.setNull());\n+    FAST_CHECK(v.isNull());\n }\n \n BOOST_AUTO_TEST_CASE(univalue_array)\n {\n     UniValue arr(UniValue::VARR);\n \n     UniValue v((int64_t)1023LL);\n-    BOOST_CHECK(arr.push_back(v));\n+    FAST_CHECK(arr.push_back(v));\n \n     string vStr(\"zippy\");\n-    BOOST_CHECK(arr.push_back(vStr));\n+    FAST_CHECK(arr.push_back(vStr));\n \n     const char *s = \"pippy\";\n-    BOOST_CHECK(arr.push_back(s));\n+    FAST_CHECK(arr.push_back(s));\n \n     vector<UniValue> vec;\n     v.setStr(\"boing\");\n@@ -185,22 +185,22 @@ BOOST_AUTO_TEST_CASE(univalue_array)\n     v.setStr(\"going\");\n     vec.push_back(v);\n \n-    BOOST_CHECK(arr.push_backV(vec));\n+    FAST_CHECK(arr.push_backV(vec));\n \n-    BOOST_CHECK_EQUAL(arr.empty(), false);\n-    BOOST_CHECK_EQUAL(arr.size(), 5);\n+    FAST_CHECK_EQUAL(arr.empty(), false);\n+    FAST_CHECK_EQUAL(arr.size(), 5);\n \n-    BOOST_CHECK_EQUAL(arr[0].getValStr(), \"1023\");\n-    BOOST_CHECK_EQUAL(arr[1].getValStr(), \"zippy\");\n-    BOOST_CHECK_EQUAL(arr[2].getValStr(), \"pippy\");\n-    BOOST_CHECK_EQUAL(arr[3].getValStr(), \"boing\");\n-    BOOST_CHECK_EQUAL(arr[4].getValStr(), \"going\");\n+    FAST_CHECK_EQUAL(arr[0].getValStr(), \"1023\");\n+    FAST_CHECK_EQUAL(arr[1].getValStr(), \"zippy\");\n+    FAST_CHECK_EQUAL(arr[2].getValStr(), \"pippy\");\n+    FAST_CHECK_EQUAL(arr[3].getValStr(), \"boing\");\n+    FAST_CHECK_EQUAL(arr[4].getValStr(), \"going\");\n \n-    BOOST_CHECK_EQUAL(arr[999].getValStr(), \"\");\n+    FAST_CHECK_EQUAL(arr[999].getValStr(), \"\");\n \n     arr.clear();\n-    BOOST_CHECK(arr.empty());\n-    BOOST_CHECK_EQUAL(arr.size(), 0);\n+    FAST_CHECK(arr.empty());\n+    FAST_CHECK_EQUAL(arr.size(), 0);\n }\n \n BOOST_AUTO_TEST_CASE(univalue_object)\n@@ -211,60 +211,60 @@ BOOST_AUTO_TEST_CASE(univalue_object)\n \n     strKey = \"age\";\n     v.setInt(100);\n-    BOOST_CHECK(obj.pushKV(strKey, v));\n+    FAST_CHECK(obj.pushKV(strKey, v));\n \n     strKey = \"first\";\n     strVal = \"John\";\n-    BOOST_CHECK(obj.pushKV(strKey, strVal));\n+    FAST_CHECK(obj.pushKV(strKey, strVal));\n \n     strKey = \"last\";\n     const char *cVal = \"Smith\";\n-    BOOST_CHECK(obj.pushKV(strKey, cVal));\n+    FAST_CHECK(obj.pushKV(strKey, cVal));\n \n     strKey = \"distance\";\n-    BOOST_CHECK(obj.pushKV(strKey, (int64_t) 25));\n+    FAST_CHECK(obj.pushKV(strKey, (int64_t) 25));\n \n     strKey = \"time\";\n-    BOOST_CHECK(obj.pushKV(strKey, (uint64_t) 3600));\n+    FAST_CHECK(obj.pushKV(strKey, (uint64_t) 3600));\n \n     strKey = \"calories\";\n-    BOOST_CHECK(obj.pushKV(strKey, (int) 12));\n+    FAST_CHECK(obj.pushKV(strKey, (int) 12));\n \n     strKey = \"temperature\";\n-    BOOST_CHECK(obj.pushKV(strKey, (double) 90.012));\n+    FAST_CHECK(obj.pushKV(strKey, (double) 90.012));\n \n     UniValue obj2(UniValue::VOBJ);\n-    BOOST_CHECK(obj2.pushKV(\"cat1\", 9000));\n-    BOOST_CHECK(obj2.pushKV(\"cat2\", 12345));\n-\n-    BOOST_CHECK(obj.pushKVs(obj2));\n-\n-    BOOST_CHECK_EQUAL(obj.empty(), false);\n-    BOOST_CHECK_EQUAL(obj.size(), 9);\n-\n-    BOOST_CHECK_EQUAL(obj[\"age\"].getValStr(), \"100\");\n-    BOOST_CHECK_EQUAL(obj[\"first\"].getValStr(), \"John\");\n-    BOOST_CHECK_EQUAL(obj[\"last\"].getValStr(), \"Smith\");\n-    BOOST_CHECK_EQUAL(obj[\"distance\"].getValStr(), \"25\");\n-    BOOST_CHECK_EQUAL(obj[\"time\"].getValStr(), \"3600\");\n-    BOOST_CHECK_EQUAL(obj[\"calories\"].getValStr(), \"12\");\n-    BOOST_CHECK_EQUAL(obj[\"temperature\"].getValStr(), \"90.012\");\n-    BOOST_CHECK_EQUAL(obj[\"cat1\"].getValStr(), \"9000\");\n-    BOOST_CHECK_EQUAL(obj[\"cat2\"].getValStr(), \"12345\");\n-\n-    BOOST_CHECK_EQUAL(obj[\"nyuknyuknyuk\"].getValStr(), \"\");\n-\n-    BOOST_CHECK(obj.exists(\"age\"));\n-    BOOST_CHECK(obj.exists(\"first\"));\n-    BOOST_CHECK(obj.exists(\"last\"));\n-    BOOST_CHECK(obj.exists(\"distance\"));\n-    BOOST_CHECK(obj.exists(\"time\"));\n-    BOOST_CHECK(obj.exists(\"calories\"));\n-    BOOST_CHECK(obj.exists(\"temperature\"));\n-    BOOST_CHECK(obj.exists(\"cat1\"));\n-    BOOST_CHECK(obj.exists(\"cat2\"));\n-\n-    BOOST_CHECK(!obj.exists(\"nyuknyuknyuk\"));\n+    FAST_CHECK(obj2.pushKV(\"cat1\", 9000));\n+    FAST_CHECK(obj2.pushKV(\"cat2\", 12345));\n+\n+    FAST_CHECK(obj.pushKVs(obj2));\n+\n+    FAST_CHECK_EQUAL(obj.empty(), false);\n+    FAST_CHECK_EQUAL(obj.size(), 9);\n+\n+    FAST_CHECK_EQUAL(obj[\"age\"].getValStr(), \"100\");\n+    FAST_CHECK_EQUAL(obj[\"first\"].getValStr(), \"John\");\n+    FAST_CHECK_EQUAL(obj[\"last\"].getValStr(), \"Smith\");\n+    FAST_CHECK_EQUAL(obj[\"distance\"].getValStr(), \"25\");\n+    FAST_CHECK_EQUAL(obj[\"time\"].getValStr(), \"3600\");\n+    FAST_CHECK_EQUAL(obj[\"calories\"].getValStr(), \"12\");\n+    FAST_CHECK_EQUAL(obj[\"temperature\"].getValStr(), \"90.012\");\n+    FAST_CHECK_EQUAL(obj[\"cat1\"].getValStr(), \"9000\");\n+    FAST_CHECK_EQUAL(obj[\"cat2\"].getValStr(), \"12345\");\n+\n+    FAST_CHECK_EQUAL(obj[\"nyuknyuknyuk\"].getValStr(), \"\");\n+\n+    FAST_CHECK(obj.exists(\"age\"));\n+    FAST_CHECK(obj.exists(\"first\"));\n+    FAST_CHECK(obj.exists(\"last\"));\n+    FAST_CHECK(obj.exists(\"distance\"));\n+    FAST_CHECK(obj.exists(\"time\"));\n+    FAST_CHECK(obj.exists(\"calories\"));\n+    FAST_CHECK(obj.exists(\"temperature\"));\n+    FAST_CHECK(obj.exists(\"cat1\"));\n+    FAST_CHECK(obj.exists(\"cat2\"));\n+\n+    FAST_CHECK(!obj.exists(\"nyuknyuknyuk\"));\n \n     map<string, UniValue::VType> objTypes;\n     objTypes[\"age\"] = UniValue::VNUM;\n@@ -276,14 +276,14 @@ BOOST_AUTO_TEST_CASE(univalue_object)\n     objTypes[\"temperature\"] = UniValue::VNUM;\n     objTypes[\"cat1\"] = UniValue::VNUM;\n     objTypes[\"cat2\"] = UniValue::VNUM;\n-    BOOST_CHECK(obj.checkObject(objTypes));\n+    FAST_CHECK(obj.checkObject(objTypes));\n \n     objTypes[\"cat2\"] = UniValue::VSTR;\n-    BOOST_CHECK(!obj.checkObject(objTypes));\n+    FAST_CHECK(!obj.checkObject(objTypes));\n \n     obj.clear();\n-    BOOST_CHECK(obj.empty());\n-    BOOST_CHECK_EQUAL(obj.size(), 0);\n+    FAST_CHECK(obj.empty());\n+    FAST_CHECK_EQUAL(obj.size(), 0);\n }\n \n static const char *json1 =\n@@ -292,44 +292,44 @@ static const char *json1 =\n BOOST_AUTO_TEST_CASE(univalue_readwrite)\n {\n     UniValue v;\n-    BOOST_CHECK(v.read(json1));\n+    FAST_CHECK(v.read(json1));\n \n     string strJson1(json1);\n-    BOOST_CHECK(v.read(strJson1));\n+    FAST_CHECK(v.read(strJson1));\n \n-    BOOST_CHECK(v.isArray());\n-    BOOST_CHECK_EQUAL(v.size(), 2);\n+    FAST_CHECK(v.isArray());\n+    FAST_CHECK_EQUAL(v.size(), 2);\n \n-    BOOST_CHECK_EQUAL(v[0].getValStr(), \"1.10000000\");\n+    FAST_CHECK_EQUAL(v[0].getValStr(), \"1.10000000\");\n \n     UniValue obj = v[1];\n-    BOOST_CHECK(obj.isObject());\n-    BOOST_CHECK_EQUAL(obj.size(), 3);\n+    FAST_CHECK(obj.isObject());\n+    FAST_CHECK_EQUAL(obj.size(), 3);\n \n-    BOOST_CHECK(obj[\"key1\"].isStr());\n+    FAST_CHECK(obj[\"key1\"].isStr());\n     std::string correctValue(\"str\");\n     correctValue.push_back('\\0');\n-    BOOST_CHECK_EQUAL(obj[\"key1\"].getValStr(), correctValue);\n-    BOOST_CHECK(obj[\"key2\"].isNum());\n-    BOOST_CHECK_EQUAL(obj[\"key2\"].getValStr(), \"800\");\n-    BOOST_CHECK(obj[\"key3\"].isObject());\n+    FAST_CHECK_EQUAL(obj[\"key1\"].getValStr(), correctValue);\n+    FAST_CHECK(obj[\"key2\"].isNum());\n+    FAST_CHECK_EQUAL(obj[\"key2\"].getValStr(), \"800\");\n+    FAST_CHECK(obj[\"key3\"].isObject());\n \n-    BOOST_CHECK_EQUAL(strJson1, v.write());\n+    FAST_CHECK_EQUAL(strJson1, v.write());\n \n     /* Check for (correctly reporting) a parsing error if the initial\n        JSON construct is followed by more stuff.  Note that whitespace\n        is, of course, exempt.  */\n \n-    BOOST_CHECK(v.read(\"  {}\\n  \"));\n-    BOOST_CHECK(v.isObject());\n-    BOOST_CHECK(v.read(\"  []\\n  \"));\n-    BOOST_CHECK(v.isArray());\n+    FAST_CHECK(v.read(\"  {}\\n  \"));\n+    FAST_CHECK(v.isObject());\n+    FAST_CHECK(v.read(\"  []\\n  \"));\n+    FAST_CHECK(v.isArray());\n \n-    BOOST_CHECK(!v.read(\"@{}\"));\n-    BOOST_CHECK(!v.read(\"{} garbage\"));\n-    BOOST_CHECK(!v.read(\"[]{}\"));\n-    BOOST_CHECK(!v.read(\"{}[]\"));\n-    BOOST_CHECK(!v.read(\"{} 42\"));\n+    FAST_CHECK(!v.read(\"@{}\"));\n+    FAST_CHECK(!v.read(\"{} garbage\"));\n+    FAST_CHECK(!v.read(\"[]{}\"));\n+    FAST_CHECK(!v.read(\"{}[]\"));\n+    FAST_CHECK(!v.read(\"{} 42\"));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "77cb7d47c35472106f106ced6b42c3fe84a07c5b",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 303,
        "deletions": 303,
        "changes": 606,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -54,74 +54,74 @@ BOOST_AUTO_TEST_CASE(util_ParseHex)\n     std::vector<unsigned char> expected(ParseHex_expected, ParseHex_expected + sizeof(ParseHex_expected));\n     // Basic test vector\n     result = ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n-    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n+    FAST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n \n     // Spaces between bytes must be supported\n     result = ParseHex(\"12 34 56 78\");\n-    BOOST_CHECK(result.size() == 4 && result[0] == 0x12 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n+    FAST_CHECK(result.size() == 4 && result[0] == 0x12 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n \n     // Leading space must be supported (used in CDBEnv::Salvage)\n     result = ParseHex(\" 89 34 56 78\");\n-    BOOST_CHECK(result.size() == 4 && result[0] == 0x89 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n+    FAST_CHECK(result.size() == 4 && result[0] == 0x89 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n \n     // Stop parsing at invalid value\n     result = ParseHex(\"1234 invalid 1234\");\n-    BOOST_CHECK(result.size() == 2 && result[0] == 0x12 && result[1] == 0x34);\n+    FAST_CHECK(result.size() == 2 && result[0] == 0x12 && result[1] == 0x34);\n }\n \n BOOST_AUTO_TEST_CASE(util_HexStr)\n {\n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n         HexStr(ParseHex_expected, ParseHex_expected + sizeof(ParseHex_expected)),\n         \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n \n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n         HexStr(ParseHex_expected, ParseHex_expected + 5, true),\n         \"04 67 8a fd b0\");\n \n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n         HexStr(ParseHex_expected, ParseHex_expected, true),\n         \"\");\n \n     std::vector<unsigned char> ParseHex_vec(ParseHex_expected, ParseHex_expected + 5);\n \n-    BOOST_CHECK_EQUAL(\n+    FAST_CHECK_EQUAL(\n         HexStr(ParseHex_vec, true),\n         \"04 67 8a fd b0\");\n }\n \n \n BOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n {\n-    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0), \"1970-01-01 00:00:00\");\n-    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0x7FFFFFFF), \"2038-01-19 03:14:07\");\n-    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 1317425777), \"2011-09-30 23:36:17\");\n-    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M\", 1317425777), \"2011-09-30 23:36\");\n-    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", 1317425777), \"Fri, 30 Sep 2011 23:36:17 +0000\");\n+    FAST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0), \"1970-01-01 00:00:00\");\n+    FAST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0x7FFFFFFF), \"2038-01-19 03:14:07\");\n+    FAST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 1317425777), \"2011-09-30 23:36:17\");\n+    FAST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M\", 1317425777), \"2011-09-30 23:36\");\n+    FAST_CHECK_EQUAL(DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", 1317425777), \"Fri, 30 Sep 2011 23:36:17 +0000\");\n }\n \n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n {\n     const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n \n     ParseParameters(0, (char**)argv_test);\n-    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n+    FAST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n \n     ParseParameters(1, (char**)argv_test);\n-    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n+    FAST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n \n     ParseParameters(5, (char**)argv_test);\n     // expectation: -ignored is ignored (program name argument),\n     // -a, -b and -ccc end up in map, -d ignored because it is after\n     // a non-option argument (non-GNU option parsing)\n-    BOOST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n-    BOOST_CHECK(mapArgs.count(\"-a\") && mapArgs.count(\"-b\") && mapArgs.count(\"-ccc\")\n+    FAST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n+    FAST_CHECK(mapArgs.count(\"-a\") && mapArgs.count(\"-b\") && mapArgs.count(\"-ccc\")\n                 && !mapArgs.count(\"f\") && !mapArgs.count(\"-d\"));\n-    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\")\n+    FAST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\")\n                 && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n \n-    BOOST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n-    BOOST_CHECK(mapMultiArgs[\"-ccc\"].size() == 2);\n+    FAST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n+    FAST_CHECK(mapMultiArgs[\"-ccc\"].size() == 2);\n }\n \n BOOST_AUTO_TEST_CASE(util_GetArg)\n@@ -137,108 +137,108 @@ BOOST_AUTO_TEST_CASE(util_GetArg)\n     mapArgs[\"booltest3\"] = \"0\";\n     mapArgs[\"booltest4\"] = \"1\";\n \n-    BOOST_CHECK_EQUAL(GetArg(\"strtest1\", \"default\"), \"string...\");\n-    BOOST_CHECK_EQUAL(GetArg(\"strtest2\", \"default\"), \"default\");\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest1\", -1), 12345);\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest2\", -1), 81985529216486895LL);\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest3\", -1), -1);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest1\", false), true);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest2\", false), false);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest3\", false), false);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest4\", false), true);\n+    FAST_CHECK_EQUAL(GetArg(\"strtest1\", \"default\"), \"string...\");\n+    FAST_CHECK_EQUAL(GetArg(\"strtest2\", \"default\"), \"default\");\n+    FAST_CHECK_EQUAL(GetArg(\"inttest1\", -1), 12345);\n+    FAST_CHECK_EQUAL(GetArg(\"inttest2\", -1), 81985529216486895LL);\n+    FAST_CHECK_EQUAL(GetArg(\"inttest3\", -1), -1);\n+    FAST_CHECK_EQUAL(GetBoolArg(\"booltest1\", false), true);\n+    FAST_CHECK_EQUAL(GetBoolArg(\"booltest2\", false), false);\n+    FAST_CHECK_EQUAL(GetBoolArg(\"booltest3\", false), false);\n+    FAST_CHECK_EQUAL(GetBoolArg(\"booltest4\", false), true);\n }\n \n BOOST_AUTO_TEST_CASE(util_FormatMoney)\n {\n-    BOOST_CHECK_EQUAL(FormatMoney(0), \"0.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney((COIN/10000)*123456789), \"12345.6789\");\n-    BOOST_CHECK_EQUAL(FormatMoney(-COIN), \"-1.00\");\n-\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000000), \"100000000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000000), \"10000000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000000), \"1000000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000), \"100000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000), \"10000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000), \"1000.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*100), \"100.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN*10), \"10.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN), \"1.00\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/10), \"0.10\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/100), \"0.01\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000), \"0.001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000), \"0.0001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000), \"0.00001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000000), \"0.000001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000000), \"0.0000001\");\n-    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000000), \"0.00000001\");\n+    FAST_CHECK_EQUAL(FormatMoney(0), \"0.00\");\n+    FAST_CHECK_EQUAL(FormatMoney((COIN/10000)*123456789), \"12345.6789\");\n+    FAST_CHECK_EQUAL(FormatMoney(-COIN), \"-1.00\");\n+\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*100000000), \"100000000.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*10000000), \"10000000.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*1000000), \"1000000.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*100000), \"100000.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*10000), \"10000.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*1000), \"1000.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*100), \"100.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN*10), \"10.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN), \"1.00\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/10), \"0.10\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/100), \"0.01\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/1000), \"0.001\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/10000), \"0.0001\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/100000), \"0.00001\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/1000000), \"0.000001\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/10000000), \"0.0000001\");\n+    FAST_CHECK_EQUAL(FormatMoney(COIN/100000000), \"0.00000001\");\n }\n \n BOOST_AUTO_TEST_CASE(util_ParseMoney)\n {\n     CAmount ret = 0;\n-    BOOST_CHECK(ParseMoney(\"0.0\", ret));\n-    BOOST_CHECK_EQUAL(ret, 0);\n-\n-    BOOST_CHECK(ParseMoney(\"12345.6789\", ret));\n-    BOOST_CHECK_EQUAL(ret, (COIN/10000)*123456789);\n-\n-    BOOST_CHECK(ParseMoney(\"100000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100000000);\n-    BOOST_CHECK(ParseMoney(\"10000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10000000);\n-    BOOST_CHECK(ParseMoney(\"1000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*1000000);\n-    BOOST_CHECK(ParseMoney(\"100000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100000);\n-    BOOST_CHECK(ParseMoney(\"10000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10000);\n-    BOOST_CHECK(ParseMoney(\"1000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*1000);\n-    BOOST_CHECK(ParseMoney(\"100.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100);\n-    BOOST_CHECK(ParseMoney(\"10.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10);\n-    BOOST_CHECK(ParseMoney(\"1.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"1\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"0.1\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10);\n-    BOOST_CHECK(ParseMoney(\"0.01\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100);\n-    BOOST_CHECK(ParseMoney(\"0.001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/1000);\n-    BOOST_CHECK(ParseMoney(\"0.0001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10000);\n-    BOOST_CHECK(ParseMoney(\"0.00001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000);\n-    BOOST_CHECK(ParseMoney(\"0.000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/1000000);\n-    BOOST_CHECK(ParseMoney(\"0.0000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10000000);\n-    BOOST_CHECK(ParseMoney(\"0.00000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n+    FAST_CHECK(ParseMoney(\"0.0\", ret));\n+    FAST_CHECK_EQUAL(ret, 0);\n+\n+    FAST_CHECK(ParseMoney(\"12345.6789\", ret));\n+    FAST_CHECK_EQUAL(ret, (COIN/10000)*123456789);\n+\n+    FAST_CHECK(ParseMoney(\"100000000.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*100000000);\n+    FAST_CHECK(ParseMoney(\"10000000.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*10000000);\n+    FAST_CHECK(ParseMoney(\"1000000.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*1000000);\n+    FAST_CHECK(ParseMoney(\"100000.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*100000);\n+    FAST_CHECK(ParseMoney(\"10000.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*10000);\n+    FAST_CHECK(ParseMoney(\"1000.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*1000);\n+    FAST_CHECK(ParseMoney(\"100.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*100);\n+    FAST_CHECK(ParseMoney(\"10.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN*10);\n+    FAST_CHECK(ParseMoney(\"1.00\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN);\n+    FAST_CHECK(ParseMoney(\"1\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN);\n+    FAST_CHECK(ParseMoney(\"0.1\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/10);\n+    FAST_CHECK(ParseMoney(\"0.01\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/100);\n+    FAST_CHECK(ParseMoney(\"0.001\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/1000);\n+    FAST_CHECK(ParseMoney(\"0.0001\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/10000);\n+    FAST_CHECK(ParseMoney(\"0.00001\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/100000);\n+    FAST_CHECK(ParseMoney(\"0.000001\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/1000000);\n+    FAST_CHECK(ParseMoney(\"0.0000001\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/10000000);\n+    FAST_CHECK(ParseMoney(\"0.00000001\", ret));\n+    FAST_CHECK_EQUAL(ret, COIN/100000000);\n \n     // Attempted 63 bit overflow should fail\n-    BOOST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n+    FAST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n \n     // Parsing negative amounts must fail\n-    BOOST_CHECK(!ParseMoney(\"-1\", ret));\n+    FAST_CHECK(!ParseMoney(\"-1\", ret));\n }\n \n BOOST_AUTO_TEST_CASE(util_IsHex)\n {\n-    BOOST_CHECK(IsHex(\"00\"));\n-    BOOST_CHECK(IsHex(\"00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n-    BOOST_CHECK(IsHex(\"ff\"));\n-    BOOST_CHECK(IsHex(\"FF\"));\n-\n-    BOOST_CHECK(!IsHex(\"\"));\n-    BOOST_CHECK(!IsHex(\"0\"));\n-    BOOST_CHECK(!IsHex(\"a\"));\n-    BOOST_CHECK(!IsHex(\"eleven\"));\n-    BOOST_CHECK(!IsHex(\"00xx00\"));\n-    BOOST_CHECK(!IsHex(\"0x0000\"));\n+    FAST_CHECK(IsHex(\"00\"));\n+    FAST_CHECK(IsHex(\"00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n+    FAST_CHECK(IsHex(\"ff\"));\n+    FAST_CHECK(IsHex(\"FF\"));\n+\n+    FAST_CHECK(!IsHex(\"\"));\n+    FAST_CHECK(!IsHex(\"0\"));\n+    FAST_CHECK(!IsHex(\"a\"));\n+    FAST_CHECK(!IsHex(\"eleven\"));\n+    FAST_CHECK(!IsHex(\"00xx00\"));\n+    FAST_CHECK(!IsHex(\"0x0000\"));\n }\n \n BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n@@ -261,20 +261,20 @@ BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n             }while(rval>=(uint32_t)mod);\n             count += rval==0;\n         }\n-        BOOST_CHECK(count<=10000/mod+err);\n-        BOOST_CHECK(count>=10000/mod-err);\n+        FAST_CHECK(count<=10000/mod+err);\n+        FAST_CHECK(count>=10000/mod-err);\n     }\n }\n \n BOOST_AUTO_TEST_CASE(util_TimingResistantEqual)\n {\n-    BOOST_CHECK(TimingResistantEqual(std::string(\"\"), std::string(\"\")));\n-    BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"\")));\n-    BOOST_CHECK(!TimingResistantEqual(std::string(\"\"), std::string(\"abc\")));\n-    BOOST_CHECK(!TimingResistantEqual(std::string(\"a\"), std::string(\"aa\")));\n-    BOOST_CHECK(!TimingResistantEqual(std::string(\"aa\"), std::string(\"a\")));\n-    BOOST_CHECK(TimingResistantEqual(std::string(\"abc\"), std::string(\"abc\")));\n-    BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"aba\")));\n+    FAST_CHECK(TimingResistantEqual(std::string(\"\"), std::string(\"\")));\n+    FAST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"\")));\n+    FAST_CHECK(!TimingResistantEqual(std::string(\"\"), std::string(\"abc\")));\n+    FAST_CHECK(!TimingResistantEqual(std::string(\"a\"), std::string(\"aa\")));\n+    FAST_CHECK(!TimingResistantEqual(std::string(\"aa\"), std::string(\"a\")));\n+    FAST_CHECK(TimingResistantEqual(std::string(\"abc\"), std::string(\"abc\")));\n+    FAST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"aba\")));\n }\n \n /* Test strprintf formatting directives.\n@@ -285,21 +285,21 @@ BOOST_AUTO_TEST_CASE(strprintf_numbers)\n {\n     int64_t s64t = -9223372036854775807LL; /* signed 64 bit test value */\n     uint64_t u64t = 18446744073709551615ULL; /* unsigned 64 bit test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, s64t, E) == B\" -9223372036854775807 \" E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, u64t, E) == B\" 18446744073709551615 \" E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, u64t, E) == B\" ffffffffffffffff \" E);\n+    FAST_CHECK(strprintf(\"%s %d %s\", B, s64t, E) == B\" -9223372036854775807 \" E);\n+    FAST_CHECK(strprintf(\"%s %u %s\", B, u64t, E) == B\" 18446744073709551615 \" E);\n+    FAST_CHECK(strprintf(\"%s %x %s\", B, u64t, E) == B\" ffffffffffffffff \" E);\n \n     size_t st = 12345678; /* unsigned size_t test value */\n     ssize_t sst = -12345678; /* signed size_t test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, sst, E) == B\" -12345678 \" E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, st, E) == B\" 12345678 \" E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, st, E) == B\" bc614e \" E);\n+    FAST_CHECK(strprintf(\"%s %d %s\", B, sst, E) == B\" -12345678 \" E);\n+    FAST_CHECK(strprintf(\"%s %u %s\", B, st, E) == B\" 12345678 \" E);\n+    FAST_CHECK(strprintf(\"%s %x %s\", B, st, E) == B\" bc614e \" E);\n \n     ptrdiff_t pt = 87654321; /* positive ptrdiff_t test value */\n     ptrdiff_t spt = -87654321; /* negative ptrdiff_t test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, spt, E) == B\" -87654321 \" E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, pt, E) == B\" 87654321 \" E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, pt, E) == B\" 5397fb1 \" E);\n+    FAST_CHECK(strprintf(\"%s %d %s\", B, spt, E) == B\" -87654321 \" E);\n+    FAST_CHECK(strprintf(\"%s %u %s\", B, pt, E) == B\" 87654321 \" E);\n+    FAST_CHECK(strprintf(\"%s %x %s\", B, pt, E) == B\" 5397fb1 \" E);\n }\n #undef B\n #undef E\n@@ -309,184 +309,184 @@ BOOST_AUTO_TEST_CASE(strprintf_numbers)\n  */\n BOOST_AUTO_TEST_CASE(gettime)\n {\n-    BOOST_CHECK((GetTime() & ~0xFFFFFFFFLL) == 0);\n+    FAST_CHECK((GetTime() & ~0xFFFFFFFFLL) == 0);\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseInt32)\n {\n     int32_t n;\n     // Valid values\n-    BOOST_CHECK(ParseInt32(\"1234\", NULL));\n-    BOOST_CHECK(ParseInt32(\"0\", &n) && n == 0);\n-    BOOST_CHECK(ParseInt32(\"1234\", &n) && n == 1234);\n-    BOOST_CHECK(ParseInt32(\"01234\", &n) && n == 1234); // no octal\n-    BOOST_CHECK(ParseInt32(\"2147483647\", &n) && n == 2147483647);\n-    BOOST_CHECK(ParseInt32(\"-2147483648\", &n) && n == -2147483648);\n-    BOOST_CHECK(ParseInt32(\"-1234\", &n) && n == -1234);\n+    FAST_CHECK(ParseInt32(\"1234\", NULL));\n+    FAST_CHECK(ParseInt32(\"0\", &n) && n == 0);\n+    FAST_CHECK(ParseInt32(\"1234\", &n) && n == 1234);\n+    FAST_CHECK(ParseInt32(\"01234\", &n) && n == 1234); // no octal\n+    FAST_CHECK(ParseInt32(\"2147483647\", &n) && n == 2147483647);\n+    FAST_CHECK(ParseInt32(\"-2147483648\", &n) && n == -2147483648);\n+    FAST_CHECK(ParseInt32(\"-1234\", &n) && n == -1234);\n     // Invalid values\n-    BOOST_CHECK(!ParseInt32(\"\", &n));\n-    BOOST_CHECK(!ParseInt32(\" 1\", &n)); // no padding inside\n-    BOOST_CHECK(!ParseInt32(\"1 \", &n));\n-    BOOST_CHECK(!ParseInt32(\"1a\", &n));\n-    BOOST_CHECK(!ParseInt32(\"aap\", &n));\n-    BOOST_CHECK(!ParseInt32(\"0x1\", &n)); // no hex\n-    BOOST_CHECK(!ParseInt32(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseInt32(\"\", &n));\n+    FAST_CHECK(!ParseInt32(\" 1\", &n)); // no padding inside\n+    FAST_CHECK(!ParseInt32(\"1 \", &n));\n+    FAST_CHECK(!ParseInt32(\"1a\", &n));\n+    FAST_CHECK(!ParseInt32(\"aap\", &n));\n+    FAST_CHECK(!ParseInt32(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseInt32(\"0x1\", &n)); // no hex\n     const char test_bytes[] = {'1', 0, '1'};\n     std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseInt32(teststr, &n)); // no embedded NULs\n+    FAST_CHECK(!ParseInt32(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseInt32(\"-2147483649\", NULL));\n-    BOOST_CHECK(!ParseInt32(\"2147483648\", NULL));\n-    BOOST_CHECK(!ParseInt32(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseInt32(\"32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseInt32(\"-2147483649\", NULL));\n+    FAST_CHECK(!ParseInt32(\"2147483648\", NULL));\n+    FAST_CHECK(!ParseInt32(\"-32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseInt32(\"32482348723847471234\", NULL));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseInt64)\n {\n     int64_t n;\n     // Valid values\n-    BOOST_CHECK(ParseInt64(\"1234\", NULL));\n-    BOOST_CHECK(ParseInt64(\"0\", &n) && n == 0LL);\n-    BOOST_CHECK(ParseInt64(\"1234\", &n) && n == 1234LL);\n-    BOOST_CHECK(ParseInt64(\"01234\", &n) && n == 1234LL); // no octal\n-    BOOST_CHECK(ParseInt64(\"2147483647\", &n) && n == 2147483647LL);\n-    BOOST_CHECK(ParseInt64(\"-2147483648\", &n) && n == -2147483648LL);\n-    BOOST_CHECK(ParseInt64(\"9223372036854775807\", &n) && n == (int64_t)9223372036854775807);\n-    BOOST_CHECK(ParseInt64(\"-9223372036854775808\", &n) && n == (int64_t)-9223372036854775807-1);\n-    BOOST_CHECK(ParseInt64(\"-1234\", &n) && n == -1234LL);\n+    FAST_CHECK(ParseInt64(\"1234\", NULL));\n+    FAST_CHECK(ParseInt64(\"0\", &n) && n == 0LL);\n+    FAST_CHECK(ParseInt64(\"1234\", &n) && n == 1234LL);\n+    FAST_CHECK(ParseInt64(\"01234\", &n) && n == 1234LL); // no octal\n+    FAST_CHECK(ParseInt64(\"2147483647\", &n) && n == 2147483647LL);\n+    FAST_CHECK(ParseInt64(\"-2147483648\", &n) && n == -2147483648LL);\n+    FAST_CHECK(ParseInt64(\"9223372036854775807\", &n) && n == (int64_t)9223372036854775807);\n+    FAST_CHECK(ParseInt64(\"-9223372036854775808\", &n) && n == (int64_t)-9223372036854775807-1);\n+    FAST_CHECK(ParseInt64(\"-1234\", &n) && n == -1234LL);\n     // Invalid values\n-    BOOST_CHECK(!ParseInt64(\"\", &n));\n-    BOOST_CHECK(!ParseInt64(\" 1\", &n)); // no padding inside\n-    BOOST_CHECK(!ParseInt64(\"1 \", &n));\n-    BOOST_CHECK(!ParseInt64(\"1a\", &n));\n-    BOOST_CHECK(!ParseInt64(\"aap\", &n));\n-    BOOST_CHECK(!ParseInt64(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseInt64(\"\", &n));\n+    FAST_CHECK(!ParseInt64(\" 1\", &n)); // no padding inside\n+    FAST_CHECK(!ParseInt64(\"1 \", &n));\n+    FAST_CHECK(!ParseInt64(\"1a\", &n));\n+    FAST_CHECK(!ParseInt64(\"aap\", &n));\n+    FAST_CHECK(!ParseInt64(\"0x1\", &n)); // no hex\n     const char test_bytes[] = {'1', 0, '1'};\n     std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseInt64(teststr, &n)); // no embedded NULs\n+    FAST_CHECK(!ParseInt64(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseInt64(\"-9223372036854775809\", NULL));\n-    BOOST_CHECK(!ParseInt64(\"9223372036854775808\", NULL));\n-    BOOST_CHECK(!ParseInt64(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseInt64(\"32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseInt64(\"-9223372036854775809\", NULL));\n+    FAST_CHECK(!ParseInt64(\"9223372036854775808\", NULL));\n+    FAST_CHECK(!ParseInt64(\"-32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseInt64(\"32482348723847471234\", NULL));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n {\n     uint32_t n;\n     // Valid values\n-    BOOST_CHECK(ParseUInt32(\"1234\", NULL));\n-    BOOST_CHECK(ParseUInt32(\"0\", &n) && n == 0);\n-    BOOST_CHECK(ParseUInt32(\"1234\", &n) && n == 1234);\n-    BOOST_CHECK(ParseUInt32(\"01234\", &n) && n == 1234); // no octal\n-    BOOST_CHECK(ParseUInt32(\"2147483647\", &n) && n == 2147483647);\n-    BOOST_CHECK(ParseUInt32(\"2147483648\", &n) && n == (uint32_t)2147483648);\n-    BOOST_CHECK(ParseUInt32(\"4294967295\", &n) && n == (uint32_t)4294967295);\n+    FAST_CHECK(ParseUInt32(\"1234\", NULL));\n+    FAST_CHECK(ParseUInt32(\"0\", &n) && n == 0);\n+    FAST_CHECK(ParseUInt32(\"1234\", &n) && n == 1234);\n+    FAST_CHECK(ParseUInt32(\"01234\", &n) && n == 1234); // no octal\n+    FAST_CHECK(ParseUInt32(\"2147483647\", &n) && n == 2147483647);\n+    FAST_CHECK(ParseUInt32(\"2147483648\", &n) && n == (uint32_t)2147483648);\n+    FAST_CHECK(ParseUInt32(\"4294967295\", &n) && n == (uint32_t)4294967295);\n     // Invalid values\n-    BOOST_CHECK(!ParseUInt32(\"\", &n));\n-    BOOST_CHECK(!ParseUInt32(\" 1\", &n)); // no padding inside\n-    BOOST_CHECK(!ParseUInt32(\" -1\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"1 \", &n));\n-    BOOST_CHECK(!ParseUInt32(\"1a\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"aap\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n-    BOOST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseUInt32(\"\", &n));\n+    FAST_CHECK(!ParseUInt32(\" 1\", &n)); // no padding inside\n+    FAST_CHECK(!ParseUInt32(\" -1\", &n));\n+    FAST_CHECK(!ParseUInt32(\"1 \", &n));\n+    FAST_CHECK(!ParseUInt32(\"1a\", &n));\n+    FAST_CHECK(!ParseUInt32(\"aap\", &n));\n+    FAST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n     const char test_bytes[] = {'1', 0, '1'};\n     std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseUInt32(teststr, &n)); // no embedded NULs\n+    FAST_CHECK(!ParseUInt32(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseUInt32(\"-2147483648\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"4294967296\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"-1234\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseUInt32(\"32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseUInt32(\"-2147483648\", &n));\n+    FAST_CHECK(!ParseUInt32(\"4294967296\", &n));\n+    FAST_CHECK(!ParseUInt32(\"-1234\", &n));\n+    FAST_CHECK(!ParseUInt32(\"-32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseUInt32(\"32482348723847471234\", NULL));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n {\n     uint64_t n;\n     // Valid values\n-    BOOST_CHECK(ParseUInt64(\"1234\", NULL));\n-    BOOST_CHECK(ParseUInt64(\"0\", &n) && n == 0LL);\n-    BOOST_CHECK(ParseUInt64(\"1234\", &n) && n == 1234LL);\n-    BOOST_CHECK(ParseUInt64(\"01234\", &n) && n == 1234LL); // no octal\n-    BOOST_CHECK(ParseUInt64(\"2147483647\", &n) && n == 2147483647LL);\n-    BOOST_CHECK(ParseUInt64(\"9223372036854775807\", &n) && n == 9223372036854775807ULL);\n-    BOOST_CHECK(ParseUInt64(\"9223372036854775808\", &n) && n == 9223372036854775808ULL);\n-    BOOST_CHECK(ParseUInt64(\"18446744073709551615\", &n) && n == 18446744073709551615ULL);\n+    FAST_CHECK(ParseUInt64(\"1234\", NULL));\n+    FAST_CHECK(ParseUInt64(\"0\", &n) && n == 0LL);\n+    FAST_CHECK(ParseUInt64(\"1234\", &n) && n == 1234LL);\n+    FAST_CHECK(ParseUInt64(\"01234\", &n) && n == 1234LL); // no octal\n+    FAST_CHECK(ParseUInt64(\"2147483647\", &n) && n == 2147483647LL);\n+    FAST_CHECK(ParseUInt64(\"9223372036854775807\", &n) && n == 9223372036854775807ULL);\n+    FAST_CHECK(ParseUInt64(\"9223372036854775808\", &n) && n == 9223372036854775808ULL);\n+    FAST_CHECK(ParseUInt64(\"18446744073709551615\", &n) && n == 18446744073709551615ULL);\n     // Invalid values\n-    BOOST_CHECK(!ParseUInt64(\"\", &n));\n-    BOOST_CHECK(!ParseUInt64(\" 1\", &n)); // no padding inside\n-    BOOST_CHECK(!ParseUInt64(\" -1\", &n));\n-    BOOST_CHECK(!ParseUInt64(\"1 \", &n));\n-    BOOST_CHECK(!ParseUInt64(\"1a\", &n));\n-    BOOST_CHECK(!ParseUInt64(\"aap\", &n));\n-    BOOST_CHECK(!ParseUInt64(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseUInt64(\"\", &n));\n+    FAST_CHECK(!ParseUInt64(\" 1\", &n)); // no padding inside\n+    FAST_CHECK(!ParseUInt64(\" -1\", &n));\n+    FAST_CHECK(!ParseUInt64(\"1 \", &n));\n+    FAST_CHECK(!ParseUInt64(\"1a\", &n));\n+    FAST_CHECK(!ParseUInt64(\"aap\", &n));\n+    FAST_CHECK(!ParseUInt64(\"0x1\", &n)); // no hex\n     const char test_bytes[] = {'1', 0, '1'};\n     std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseUInt64(teststr, &n)); // no embedded NULs\n+    FAST_CHECK(!ParseUInt64(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseUInt64(\"-9223372036854775809\", NULL));\n-    BOOST_CHECK(!ParseUInt64(\"18446744073709551616\", NULL));\n-    BOOST_CHECK(!ParseUInt64(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseUInt64(\"-2147483648\", &n));\n-    BOOST_CHECK(!ParseUInt64(\"-9223372036854775808\", &n));\n-    BOOST_CHECK(!ParseUInt64(\"-1234\", &n));\n+    FAST_CHECK(!ParseUInt64(\"-9223372036854775809\", NULL));\n+    FAST_CHECK(!ParseUInt64(\"18446744073709551616\", NULL));\n+    FAST_CHECK(!ParseUInt64(\"-32482348723847471234\", NULL));\n+    FAST_CHECK(!ParseUInt64(\"-2147483648\", &n));\n+    FAST_CHECK(!ParseUInt64(\"-9223372036854775808\", &n));\n+    FAST_CHECK(!ParseUInt64(\"-1234\", &n));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseDouble)\n {\n     double n;\n     // Valid values\n-    BOOST_CHECK(ParseDouble(\"1234\", NULL));\n-    BOOST_CHECK(ParseDouble(\"0\", &n) && n == 0.0);\n-    BOOST_CHECK(ParseDouble(\"1234\", &n) && n == 1234.0);\n-    BOOST_CHECK(ParseDouble(\"01234\", &n) && n == 1234.0); // no octal\n-    BOOST_CHECK(ParseDouble(\"2147483647\", &n) && n == 2147483647.0);\n-    BOOST_CHECK(ParseDouble(\"-2147483648\", &n) && n == -2147483648.0);\n-    BOOST_CHECK(ParseDouble(\"-1234\", &n) && n == -1234.0);\n-    BOOST_CHECK(ParseDouble(\"1e6\", &n) && n == 1e6);\n-    BOOST_CHECK(ParseDouble(\"-1e6\", &n) && n == -1e6);\n+    FAST_CHECK(ParseDouble(\"1234\", NULL));\n+    FAST_CHECK(ParseDouble(\"0\", &n) && n == 0.0);\n+    FAST_CHECK(ParseDouble(\"1234\", &n) && n == 1234.0);\n+    FAST_CHECK(ParseDouble(\"01234\", &n) && n == 1234.0); // no octal\n+    FAST_CHECK(ParseDouble(\"2147483647\", &n) && n == 2147483647.0);\n+    FAST_CHECK(ParseDouble(\"-2147483648\", &n) && n == -2147483648.0);\n+    FAST_CHECK(ParseDouble(\"-1234\", &n) && n == -1234.0);\n+    FAST_CHECK(ParseDouble(\"1e6\", &n) && n == 1e6);\n+    FAST_CHECK(ParseDouble(\"-1e6\", &n) && n == -1e6);\n     // Invalid values\n-    BOOST_CHECK(!ParseDouble(\"\", &n));\n-    BOOST_CHECK(!ParseDouble(\" 1\", &n)); // no padding inside\n-    BOOST_CHECK(!ParseDouble(\"1 \", &n));\n-    BOOST_CHECK(!ParseDouble(\"1a\", &n));\n-    BOOST_CHECK(!ParseDouble(\"aap\", &n));\n-    BOOST_CHECK(!ParseDouble(\"0x1\", &n)); // no hex\n+    FAST_CHECK(!ParseDouble(\"\", &n));\n+    FAST_CHECK(!ParseDouble(\" 1\", &n)); // no padding inside\n+    FAST_CHECK(!ParseDouble(\"1 \", &n));\n+    FAST_CHECK(!ParseDouble(\"1a\", &n));\n+    FAST_CHECK(!ParseDouble(\"aap\", &n));\n+    FAST_CHECK(!ParseDouble(\"0x1\", &n)); // no hex\n     const char test_bytes[] = {'1', 0, '1'};\n     std::string teststr(test_bytes, sizeof(test_bytes));\n-    BOOST_CHECK(!ParseDouble(teststr, &n)); // no embedded NULs\n+    FAST_CHECK(!ParseDouble(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseDouble(\"-1e10000\", NULL));\n-    BOOST_CHECK(!ParseDouble(\"1e10000\", NULL));\n+    FAST_CHECK(!ParseDouble(\"-1e10000\", NULL));\n+    FAST_CHECK(!ParseDouble(\"1e10000\", NULL));\n }\n \n BOOST_AUTO_TEST_CASE(test_FormatParagraph)\n {\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"\", 79, 0), \"\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"test\", 79, 0), \"test\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\" test\", 79, 0), \" test\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"test test\", 79, 0), \"test test\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"test test\", 4, 0), \"test\\ntest\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"testerde test\", 4, 0), \"testerde\\ntest\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"test test\", 4, 4), \"test\\n    test\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"\", 79, 0), \"\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"test\", 79, 0), \"test\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\" test\", 79, 0), \" test\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"test test\", 79, 0), \"test test\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"test test\", 4, 0), \"test\\ntest\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"testerde test\", 4, 0), \"testerde\\ntest\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"test test\", 4, 4), \"test\\n    test\");\n \n     // Make sure we don't indent a fully-new line following a too-long line ending\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"test test\\nabc\", 4, 4), \"test\\n    test\\nabc\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"test test\\nabc\", 4, 4), \"test\\n    test\\nabc\");\n \n-    BOOST_CHECK_EQUAL(FormatParagraph(\"This_is_a_very_long_test_string_without_any_spaces_so_it_should_just_get_returned_as_is_despite_the_length until it gets here\", 79), \"This_is_a_very_long_test_string_without_any_spaces_so_it_should_just_get_returned_as_is_despite_the_length\\nuntil it gets here\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"This_is_a_very_long_test_string_without_any_spaces_so_it_should_just_get_returned_as_is_despite_the_length until it gets here\", 79), \"This_is_a_very_long_test_string_without_any_spaces_so_it_should_just_get_returned_as_is_despite_the_length\\nuntil it gets here\");\n \n     // Test wrap length is exact\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p\", 79), \"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\\nf g h i j k l m n o p\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p\", 79), \"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\\nf g h i j k l m n o p\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p\", 79), \"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\\nf g h i j k l m n o p\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p\", 79), \"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\\nf g h i j k l m n o p\");\n     // Indent should be included in length of lines\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 a b c d e fg h i j k\", 79, 4), \"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\\n    f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 a b c d e fg\\n    h i j k\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 a b c d e fg h i j k\", 79, 4), \"x\\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\\n    f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 a b c d e fg\\n    h i j k\");\n \n-    BOOST_CHECK_EQUAL(FormatParagraph(\"This is a very long test string. This is a second sentence in the very long test string.\", 79), \"This is a very long test string. This is a second sentence in the very long\\ntest string.\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"This is a very long test string.\\nThis is a second sentence in the very long test string. This is a third sentence in the very long test string.\", 79), \"This is a very long test string.\\nThis is a second sentence in the very long test string. This is a third\\nsentence in the very long test string.\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"This is a very long test string.\\n\\nThis is a second sentence in the very long test string. This is a third sentence in the very long test string.\", 79), \"This is a very long test string.\\n\\nThis is a second sentence in the very long test string. This is a third\\nsentence in the very long test string.\");\n-    BOOST_CHECK_EQUAL(FormatParagraph(\"Testing that normal newlines do not get indented.\\nLike here.\", 79), \"Testing that normal newlines do not get indented.\\nLike here.\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"This is a very long test string. This is a second sentence in the very long test string.\", 79), \"This is a very long test string. This is a second sentence in the very long\\ntest string.\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"This is a very long test string.\\nThis is a second sentence in the very long test string. This is a third sentence in the very long test string.\", 79), \"This is a very long test string.\\nThis is a second sentence in the very long test string. This is a third\\nsentence in the very long test string.\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"This is a very long test string.\\n\\nThis is a second sentence in the very long test string. This is a third sentence in the very long test string.\", 79), \"This is a very long test string.\\n\\nThis is a second sentence in the very long test string. This is a third\\nsentence in the very long test string.\");\n+    FAST_CHECK_EQUAL(FormatParagraph(\"Testing that normal newlines do not get indented.\\nLike here.\", 79), \"Testing that normal newlines do not get indented.\\nLike here.\");\n }\n \n BOOST_AUTO_TEST_CASE(test_FormatSubVersion)\n@@ -496,74 +496,74 @@ BOOST_AUTO_TEST_CASE(test_FormatSubVersion)\n     std::vector<std::string> comments2;\n     comments2.push_back(std::string(\"comment1\"));\n     comments2.push_back(SanitizeString(std::string(\"Comment2; .,_?@-; !\\\"#$%&'()*+/<=>[]\\\\^`{|}~\"), SAFE_CHARS_UA_COMMENT)); // Semicolon is discouraged but not forbidden by BIP-0014\n-    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, std::vector<std::string>()),std::string(\"/Test:0.9.99/\"));\n-    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments),std::string(\"/Test:0.9.99(comment1)/\"));\n-    BOOST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments2),std::string(\"/Test:0.9.99(comment1; Comment2; .,_?@-; )/\"));\n+    FAST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, std::vector<std::string>()),std::string(\"/Test:0.9.99/\"));\n+    FAST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments),std::string(\"/Test:0.9.99(comment1)/\"));\n+    FAST_CHECK_EQUAL(FormatSubVersion(\"Test\", 99900, comments2),std::string(\"/Test:0.9.99(comment1; Comment2; .,_?@-; )/\"));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseFixedPoint)\n {\n     int64_t amount = 0;\n-    BOOST_CHECK(ParseFixedPoint(\"0\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 0LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 100000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"0.0\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 0LL);\n-    BOOST_CHECK(ParseFixedPoint(\"-0.1\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, -10000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1.1\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 110000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1.10000000000000000\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 110000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1.1e1\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 1100000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1.1e-1\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 11000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1000\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 100000000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"-1000\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, -100000000000LL);\n-    BOOST_CHECK(ParseFixedPoint(\"0.00000001\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 1LL);\n-    BOOST_CHECK(ParseFixedPoint(\"0.0000000100000000\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 1LL);\n-    BOOST_CHECK(ParseFixedPoint(\"-0.00000001\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, -1LL);\n-    BOOST_CHECK(ParseFixedPoint(\"1000000000.00000001\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 100000000000000001LL);\n-    BOOST_CHECK(ParseFixedPoint(\"9999999999.99999999\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, 999999999999999999LL);\n-    BOOST_CHECK(ParseFixedPoint(\"-9999999999.99999999\", 8, &amount));\n-    BOOST_CHECK_EQUAL(amount, -999999999999999999LL);\n-\n-    BOOST_CHECK(!ParseFixedPoint(\"\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"a-1000\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-a1000\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-1000a\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-01000\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"00.1\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\".1\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"--0.1\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"0.000000001\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-0.000000001\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"0.00000001000000001\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-10000000000.00000000\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"10000000000.00000000\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-10000000000.00000001\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"10000000000.00000001\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-10000000000.00000009\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"10000000000.00000009\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-99999999999.99999999\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"99999909999.09999999\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"92233720368.54775807\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"92233720368.54775808\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-92233720368.54775808\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"-92233720368.54775809\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"1.1e\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"1.1e-\", 8, &amount));\n-    BOOST_CHECK(!ParseFixedPoint(\"1.\", 8, &amount));\n+    FAST_CHECK(ParseFixedPoint(\"0\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 0LL);\n+    FAST_CHECK(ParseFixedPoint(\"1\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 100000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"0.0\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 0LL);\n+    FAST_CHECK(ParseFixedPoint(\"-0.1\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, -10000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"1.1\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 110000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"1.10000000000000000\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 110000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"1.1e1\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 1100000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"1.1e-1\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 11000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"1000\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 100000000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"-1000\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, -100000000000LL);\n+    FAST_CHECK(ParseFixedPoint(\"0.00000001\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 1LL);\n+    FAST_CHECK(ParseFixedPoint(\"0.0000000100000000\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 1LL);\n+    FAST_CHECK(ParseFixedPoint(\"-0.00000001\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, -1LL);\n+    FAST_CHECK(ParseFixedPoint(\"1000000000.00000001\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 100000000000000001LL);\n+    FAST_CHECK(ParseFixedPoint(\"9999999999.99999999\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, 999999999999999999LL);\n+    FAST_CHECK(ParseFixedPoint(\"-9999999999.99999999\", 8, &amount));\n+    FAST_CHECK_EQUAL(amount, -999999999999999999LL);\n+\n+    FAST_CHECK(!ParseFixedPoint(\"\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"a-1000\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-a1000\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-1000a\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-01000\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"00.1\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\".1\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"--0.1\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"0.000000001\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-0.000000001\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"0.00000001000000001\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-10000000000.00000000\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"10000000000.00000000\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-10000000000.00000001\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"10000000000.00000001\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-10000000000.00000009\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"10000000000.00000009\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-99999999999.99999999\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"99999909999.09999999\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"92233720368.54775807\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"92233720368.54775808\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-92233720368.54775808\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"-92233720368.54775809\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"1.1e\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"1.1e-\", 8, &amount));\n+    FAST_CHECK(!ParseFixedPoint(\"1.\", 8, &amount));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "47e548e38436f217d06bcf8c39698a7bb66a58f5",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af4697f8f6cb155d03044ce8c93a43613c75fd7/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=1af4697f8f6cb155d03044ce8c93a43613c75fd7",
        "patch": "@@ -191,7 +191,7 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n     for (int i=0; i<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n         uint32_t bitmask = VersionBitsMask(mainnetParams, (Consensus::DeploymentPos)i);\n         // Make sure that no deployment tries to set an invalid bit.\n-        BOOST_CHECK_EQUAL(bitmask & ~(uint32_t)VERSIONBITS_TOP_MASK, bitmask);\n+        FAST_CHECK_EQUAL(bitmask & ~(uint32_t)VERSIONBITS_TOP_MASK, bitmask);\n \n         // Verify that the deployment windows of different deployment using the\n         // same bit are disjoint.\n@@ -202,7 +202,7 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n         // overlap.)\n         for (int j=i+1; j<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; j++) {\n             if (VersionBitsMask(mainnetParams, (Consensus::DeploymentPos)j) == bitmask) {\n-                BOOST_CHECK(mainnetParams.vDeployments[j].nStartTime > mainnetParams.vDeployments[i].nTimeout ||\n+                FAST_CHECK(mainnetParams.vDeployments[j].nStartTime > mainnetParams.vDeployments[i].nTimeout ||\n                         mainnetParams.vDeployments[i].nStartTime > mainnetParams.vDeployments[j].nTimeout);\n             }\n         }\n@@ -234,29 +234,29 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n     // should not be set.\n     CBlockIndex *lastBlock = NULL;\n     lastBlock = firstChain.Mine(2016, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n+    FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n \n     // Mine 2011 more blocks at the old time, and check that CBV isn't setting the bit yet.\n     for (int i=1; i<2012; i++) {\n         lastBlock = firstChain.Mine(2016+i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n         // This works because VERSIONBITS_LAST_OLD_BLOCK_VERSION happens\n         // to be 4, and the bit we're testing happens to be bit 28.\n-        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n+        FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n     }\n     // Now mine 5 more blocks at the start time -- MTP should not have passed yet, so\n     // CBV should still not yet set the bit.\n     nTime = nStartTime;\n     for (int i=2012; i<=2016; i++) {\n         lastBlock = firstChain.Mine(2016+i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n+        FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n     }\n \n     // Advance to the next period and transition to STARTED,\n     lastBlock = firstChain.Mine(6048, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n     // so ComputeBlockVersion should now set the bit,\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    FAST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n     // and should also be using the VERSIONBITS_TOP_BITS.\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+    FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n \n     // Check that ComputeBlockVersion will set the bit until nTimeout\n     nTime += 600;\n@@ -265,8 +265,8 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n     // These blocks are all before nTimeout is reached.\n     while (nTime < nTimeout && blocksToMine > 0) {\n         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n-        BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+        FAST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+        FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n         blocksToMine--;\n         nTime += 600;\n         nHeight += 1;\n@@ -277,12 +277,12 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n     // the bit until the period transition.\n     for (int i=0; i<2015; i++) {\n         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+        FAST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n         nHeight += 1;\n     }\n     // The next block should trigger no longer setting the bit.\n     lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n+    FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n \n     // On a new chain:\n     // verify that the bit will be set after lock-in, and then stop being set\n@@ -292,24 +292,24 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n     // Mine one period worth of blocks, and check that the bit will be on for the\n     // next period.\n     lastBlock = secondChain.Mine(2016, nStartTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    FAST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n \n     // Mine another period worth of blocks, signaling the new bit.\n     lastBlock = secondChain.Mine(4032, nStartTime, VERSIONBITS_TOP_BITS | (1<<bit)).Tip();\n     // After one period of setting the bit on each block, it should have locked in.\n     // We keep setting the bit for one more period though, until activation.\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    FAST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n \n     // Now check that we keep mining the block until the end of this period, and\n     // then stop at the beginning of the next period.\n     lastBlock = secondChain.Mine(6047, nStartTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n+    FAST_CHECK((ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit)) != 0);\n     lastBlock = secondChain.Mine(6048, nStartTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n+    FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n \n     // Finally, verify that after a soft fork has activated, CBV no longer uses\n     // VERSIONBITS_LAST_OLD_BLOCK_VERSION.\n-    //BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+    //FAST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n }\n \n "
      }
    ]
  }
]