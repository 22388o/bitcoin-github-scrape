[
  {
    "sha": "610a8a8e39c1d94839dfb7e1c66c01f13f946657",
    "node_id": "C_kwDOABII59oAKDYxMGE4YThlMzljMWQ5NDgzOWRmYjdlMWM2NmMwMWYxM2Y5NDY2NTc",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-01T00:17:53Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-12T00:28:25Z"
      },
      "message": "test-*-check: Pass in *FLAGS and compile with them\n\nThese test-*-check scripts should compile \"test\" binaries in a way that\nis as close to what autotools would do, since the goal is to make sure\nthat if we run the *-check script, they can correctly detect flaws in\nbinaries which are compiled by our autotools-based system.\n\nTherefore, we should emulate what happens when the binary is linked in\nautotools, meaning that for C binaries, we need to supply the CFLAGS,\nCPPFLAGS, and LDFLAGS flags in that order.\n\nNote to future developers: perhaps it'd be nice to have these\ntest-*-check scripts be part of configure.ac to avoid having to manually\nreplicate autoconf-like behaviour every time we find a discrepancy. Of\ncourse, that would also mean you'd have to write more m4...",
      "tree": {
        "sha": "ff3b8a1c645c70989b7dc8160c617906cb0baeaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff3b8a1c645c70989b7dc8160c617906cb0baeaf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/610a8a8e39c1d94839dfb7e1c66c01f13f946657",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmFk1qkACgkQLuufXMCV\nJsH3ZQ/+Ln1Szg+UATF8Rwe+fro/0LNeuyuZGaKLpMGtMcQXdEyWJjH163QB6n6Y\na4i0dVZDRSEqrUtTRdHqmBOwEhTZFIU2Mp9NbgVVMj4i6h7MTWJd7D3+ZmyEy0lo\nqtq+Ndf5wgDNJV2Q9d4TD1/7BqglzD3AW6yytHdljfdTH5hwHctqQBzA2cCvMFj7\nNqyimu3ETV3pcMFQ2T6dFAU1oFJNnMVJ7t7W0Rwp0YMgZ4IA4/rM9xvTsniz2YFD\nbd8TjSeKpU7yQtSXFXLpm8Kn1MJZtGMuxiiHr6+DkMjA3REeXxOMdyz0FiRmB6pr\n1v2/ZBSe8mHKbcOx8FCf10PychNp0mpnX8UHfaXaE9Rts8DEne9eKa342IGdjAdC\nQRR7r4oKww8Oyl7galONb7f3aYbsceFM4RkYe4TYj0fMfqzaZ0M+vi8jRWcqvfVz\nvamUTmuDH7zQWLlgy50Tmh6ZgliXgatplpZSuCp/CzF0vyRKpBNXCEbUdftXJYoL\n4khIPosdkbXNMv7j48vpNMs5R3vpbMm1+XjaVfgEcL4CDuYwwZfAe3XsD5oewY6J\n77tQ9eZvJsCzPwaRwb20ZlsC061pjaZ6HOLC0QA+UJYq+nWT8+0+7244g/q6krL0\neLhYu2O+SVlgQ1AeMQ2sWOeVZ1mc3Zed8/SRwyI4PNoFG9VNxUQ=\n=t4px\n-----END PGP SIGNATURE-----",
        "payload": "tree ff3b8a1c645c70989b7dc8160c617906cb0baeaf\nparent 1790a8ddacae0d52135f5020894ef1ceef625cf9\nauthor Carl Dong <contact@carldong.me> 1633047473 -0400\ncommitter fanquake <fanquake@gmail.com> 1633998505 +0800\n\ntest-*-check: Pass in *FLAGS and compile with them\n\nThese test-*-check scripts should compile \"test\" binaries in a way that\nis as close to what autotools would do, since the goal is to make sure\nthat if we run the *-check script, they can correctly detect flaws in\nbinaries which are compiled by our autotools-based system.\n\nTherefore, we should emulate what happens when the binary is linked in\nautotools, meaning that for C binaries, we need to supply the CFLAGS,\nCPPFLAGS, and LDFLAGS flags in that order.\n\nNote to future developers: perhaps it'd be nice to have these\ntest-*-check scripts be part of configure.ac to avoid having to manually\nreplicate autoconf-like behaviour every time we find a discrepancy. Of\ncourse, that would also mean you'd have to write more m4...\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/610a8a8e39c1d94839dfb7e1c66c01f13f946657",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/610a8a8e39c1d94839dfb7e1c66c01f13f946657",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/610a8a8e39c1d94839dfb7e1c66c01f13f946657/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1790a8ddacae0d52135f5020894ef1ceef625cf9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1790a8ddacae0d52135f5020894ef1ceef625cf9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1790a8ddacae0d52135f5020894ef1ceef625cf9"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 27,
      "deletions": 8
    },
    "files": [
      {
        "sha": "348e343ffea3950045f8baa9096c3cc55cb2bb60",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/610a8a8e39c1d94839dfb7e1c66c01f13f946657/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/610a8a8e39c1d94839dfb7e1c66c01f13f946657/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=610a8a8e39c1d94839dfb7e1c66c01f13f946657",
        "patch": "@@ -367,14 +367,14 @@ clean-local: clean-docs\n \n test-security-check:\n if TARGET_DARWIN\n-\t$(AM_V_at) CC='$(CC)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_MACHO\n-\t$(AM_V_at) CC='$(CC)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_MACHO\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_MACHO\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_MACHO\n endif\n if TARGET_WINDOWS\n-\t$(AM_V_at) CC='$(CC)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_PE\n-\t$(AM_V_at) CC='$(CC)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_PE\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_PE\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_PE\n endif\n if TARGET_LINUX\n-\t$(AM_V_at) CC='$(CC)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_ELF\n-\t$(AM_V_at) CC='$(CC)' CPPFILT='$(CPPFILT)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_ELF\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_ELF\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' CPPFILT='$(CPPFILT)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_ELF\n endif"
      },
      {
        "sha": "0af7cdf5e688eae3fdaff256b42a25d261308157",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/610a8a8e39c1d94839dfb7e1c66c01f13f946657/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/610a8a8e39c1d94839dfb7e1c66c01f13f946657/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=610a8a8e39c1d94839dfb7e1c66c01f13f946657",
        "patch": "@@ -7,6 +7,7 @@\n '''\n import os\n import subprocess\n+from typing import List\n import unittest\n \n from utils import determine_wellknown_cmd\n@@ -27,7 +28,16 @@ def clean_files(source, executable):\n     os.remove(executable)\n \n def call_security_check(cc, source, executable, options):\n-    subprocess.run([*cc,source,'-o',executable] + options, check=True)\n+    # This should behave the same as AC_TRY_LINK, so arrange well-known flags\n+    # in the same order as autoconf would.\n+    #\n+    # See the definitions for ac_link in autoconf's lib/autoconf/c.m4 file for\n+    # reference.\n+    env_flags: List[str] = []\n+    for var in ['CFLAGS', 'CPPFLAGS', 'LDFLAGS']:\n+        env_flags += filter(None, os.environ.get(var, '').split(' '))\n+\n+    subprocess.run([*cc,source,'-o',executable] + env_flags + options, check=True)\n     p = subprocess.run(['./contrib/devtools/security-check.py',executable], stdout=subprocess.PIPE, universal_newlines=True)\n     return (p.returncode, p.stdout.rstrip())\n "
      },
      {
        "sha": "40143f9e2324d7466c3880ee5a0d9149ee537b38",
        "filename": "contrib/devtools/test-symbol-check.py",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/610a8a8e39c1d94839dfb7e1c66c01f13f946657/contrib/devtools/test-symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/610a8a8e39c1d94839dfb7e1c66c01f13f946657/contrib/devtools/test-symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-symbol-check.py?ref=610a8a8e39c1d94839dfb7e1c66c01f13f946657",
        "patch": "@@ -13,7 +13,16 @@\n from utils import determine_wellknown_cmd\n \n def call_symbol_check(cc: List[str], source, executable, options):\n-    subprocess.run([*cc,source,'-o',executable] + options, check=True)\n+    # This should behave the same as AC_TRY_LINK, so arrange well-known flags\n+    # in the same order as autoconf would.\n+    #\n+    # See the definitions for ac_link in autoconf's lib/autoconf/c.m4 file for\n+    # reference.\n+    env_flags: List[str] = []\n+    for var in ['CFLAGS', 'CPPFLAGS', 'LDFLAGS']:\n+        env_flags += filter(None, os.environ.get(var, '').split(' '))\n+\n+    subprocess.run([*cc,source,'-o',executable] + env_flags + options, check=True)\n     p = subprocess.run(['./contrib/devtools/symbol-check.py',executable], stdout=subprocess.PIPE, universal_newlines=True)\n     os.remove(source)\n     os.remove(executable)"
      }
    ]
  },
  {
    "sha": "309eac9019c224dfd79a78e381cfcb70fee190f3",
    "node_id": "C_kwDOABII59oAKDMwOWVhYzkwMTljMjI0ZGZkNzlhNzhlMzgxY2ZjYjcwZmVlMTkwZjM",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-07-02T06:22:04Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-12T00:36:15Z"
      },
      "message": "scripts: use LIEF for ELF checks in symbol-check.py\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "ac28e7425c940665d738c3a42320cf5cb1ad08ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac28e7425c940665d738c3a42320cf5cb1ad08ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/309eac9019c224dfd79a78e381cfcb70fee190f3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmFk2IEACgkQLuufXMCV\nJsFcHBAArpqqsXRvVdOxxQKwPzPXnILijPg19eIu08WuSzDjtK5rQIE9d4eqjEXs\nBC/PSsYcroAKB/oCNgbe0fxhKZZXBOMXCXX4+baiWfwLpjPCH1g0ClE8lfgcoc3C\nfLh122M6Qc7QjE4MJ6isjLAZHSdpn86HZF6/VQHgLtEnX/x8ntOJD/pgcgg8gZss\nxutIjvbh6XxHcyVv55Nu4H/0RD7lSvzqX5P9/TXDlqtr3ci2MIj8Rr54b/oHs/wF\nsSy2R1fonb+QDhjUw2QtL/EIaMK8cHyiI/UIVZyfNCntGbvRMO/aKJM/gbEEvne2\nEd74t1GuNgWPDrnbf9nHjozeKWycyEiXbwB1v3gi/fn/uhmBmWP67wTW6gQaAZxH\nEwPEe1HEMYQ2gz+1JL5LUssLp6TW1gOvwQDUtb+XB0/n51jy/z53/3JwdOQzKAXy\n5s0iCKAgLSTBoHJ1iN/52ZsWvzO+HGLz/nXvDMxAB4ygq5ttTneJKw7Ji4J2AcWU\n+lsKZ4LKR7DJ2ibzVdtRIXON/3w7CzIPyZ1VmjL5M/muf26j93mpKPuhCVMz8lFD\nRIGep6RXi0MYcCfVUv86tk4slLIYOPJiyby27Oyc+RBj1aUtuqrc6Cnocmovy5mZ\nUv8gIzmElVt0urWHzZieE23kbq9DY+2B6qcH/cm4BtRK8dcyp70=\n=LtnU\n-----END PGP SIGNATURE-----",
        "payload": "tree ac28e7425c940665d738c3a42320cf5cb1ad08ad\nparent 610a8a8e39c1d94839dfb7e1c66c01f13f946657\nauthor fanquake <fanquake@gmail.com> 1625206924 +0800\ncommitter fanquake <fanquake@gmail.com> 1633998975 +0800\n\nscripts: use LIEF for ELF checks in symbol-check.py\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309eac9019c224dfd79a78e381cfcb70fee190f3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/309eac9019c224dfd79a78e381cfcb70fee190f3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309eac9019c224dfd79a78e381cfcb70fee190f3/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "610a8a8e39c1d94839dfb7e1c66c01f13f946657",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/610a8a8e39c1d94839dfb7e1c66c01f13f946657",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/610a8a8e39c1d94839dfb7e1c66c01f13f946657"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 38,
      "deletions": 72
    },
    "files": [
      {
        "sha": "a495ad6209c32b2d787c13ef3b41e92d4adb8216",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309eac9019c224dfd79a78e381cfcb70fee190f3/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309eac9019c224dfd79a78e381cfcb70fee190f3/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=309eac9019c224dfd79a78e381cfcb70fee190f3",
        "patch": "@@ -376,5 +376,5 @@ if TARGET_WINDOWS\n endif\n if TARGET_LINUX\n \t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-security-check.py TestSecurityChecks.test_ELF\n-\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' CPPFILT='$(CPPFILT)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_ELF\n+\t$(AM_V_at) CC='$(CC)' CFLAGS='$(CFLAGS)' CPPFLAGS='$(CPPFLAGS)' LDFLAGS='$(LDFLAGS)' $(PYTHON) $(top_srcdir)/contrib/devtools/test-symbol-check.py TestSymbolChecks.test_ELF\n endif"
      },
      {
        "sha": "bd06a5aadac1e74965ef8da060a0129aeaed9129",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309eac9019c224dfd79a78e381cfcb70fee190f3/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309eac9019c224dfd79a78e381cfcb70fee190f3/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=309eac9019c224dfd79a78e381cfcb70fee190f3",
        "patch": "@@ -113,7 +113,6 @@ AC_PATH_PROG([GIT], [git])\n AC_PATH_PROG(CCACHE,ccache)\n AC_PATH_PROG(XGETTEXT,xgettext)\n AC_PATH_PROG(HEXDUMP,hexdump)\n-AC_PATH_TOOL(CPPFILT, c++filt)\n AC_PATH_TOOL(OBJCOPY, objcopy)\n AC_PATH_PROG(DOXYGEN, doxygen)\n AM_CONDITIONAL([HAVE_DOXYGEN], [test -n \"$DOXYGEN\"])"
      },
      {
        "sha": "36ac6faa81d6123eb52792691651fc6ffc8b38ee",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 34,
        "deletions": 55,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309eac9019c224dfd79a78e381cfcb70fee190f3/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309eac9019c224dfd79a78e381cfcb70fee190f3/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=309eac9019c224dfd79a78e381cfcb70fee190f3",
        "patch": "@@ -10,14 +10,14 @@\n \n     find ../path/to/binaries -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n '''\n-import subprocess\n import sys\n from typing import List, Optional\n \n import lief\n-import pixie\n \n-from utils import determine_wellknown_cmd\n+# temporary constant, to be replaced with lief.ELF.ARCH.RISCV\n+# https://github.com/lief-project/LIEF/pull/562\n+LIEF_ELF_ARCH_RISCV = lief.ELF.ARCH(243)\n \n # Debian 8 (Jessie) EOL: 2020. https://wiki.debian.org/DebianReleases#Production_Releases\n #\n@@ -43,12 +43,12 @@\n MAX_VERSIONS = {\n 'GCC':       (4,8,0),\n 'GLIBC': {\n-    pixie.EM_386:    (2,17),\n-    pixie.EM_X86_64: (2,17),\n-    pixie.EM_ARM:    (2,17),\n-    pixie.EM_AARCH64:(2,17),\n-    pixie.EM_PPC64:  (2,17),\n-    pixie.EM_RISCV:  (2,27),\n+    lief.ELF.ARCH.i386:   (2,17),\n+    lief.ELF.ARCH.x86_64: (2,17),\n+    lief.ELF.ARCH.ARM:    (2,17),\n+    lief.ELF.ARCH.AARCH64:(2,17),\n+    lief.ELF.ARCH.PPC64:  (2,17),\n+    LIEF_ELF_ARCH_RISCV:  (2,27),\n },\n 'LIBATOMIC': (1,0),\n 'V':         (0,5,0),  # xkb (bitcoin-qt only)\n@@ -58,7 +58,8 @@\n \n # Ignore symbols that are exported as part of every executable\n IGNORE_EXPORTS = {\n-'_edata', '_end', '__end__', '_init', '__bss_start', '__bss_start__', '_bss_end__', '__bss_end__', '_fini', '_IO_stdin_used', 'stdin', 'stdout', 'stderr',\n+'_edata', '_end', '__end__', '_init', '__bss_start', '__bss_start__', '_bss_end__',\n+'__bss_end__', '_fini', '_IO_stdin_used', 'stdin', 'stdout', 'stderr',\n 'environ', '_environ', '__environ',\n }\n \n@@ -133,31 +134,8 @@\n 'WTSAPI32.dll',\n }\n \n-class CPPFilt(object):\n-    '''\n-    Demangle C++ symbol names.\n-\n-    Use a pipe to the 'c++filt' command.\n-    '''\n-    def __init__(self):\n-        self.proc = subprocess.Popen(determine_wellknown_cmd('CPPFILT', 'c++filt'), stdin=subprocess.PIPE, stdout=subprocess.PIPE, universal_newlines=True)\n-\n-    def __call__(self, mangled):\n-        self.proc.stdin.write(mangled + '\\n')\n-        self.proc.stdin.flush()\n-        return self.proc.stdout.readline().rstrip()\n-\n-    def close(self):\n-        self.proc.stdin.close()\n-        self.proc.stdout.close()\n-        self.proc.wait()\n-\n def check_version(max_versions, version, arch) -> bool:\n-    if '_' in version:\n-        (lib, _, ver) = version.rpartition('_')\n-    else:\n-        lib = version\n-        ver = '0'\n+    (lib, _, ver) = version.rpartition('_')\n     ver = tuple([int(x) for x in ver.split('.')])\n     if not lib in max_versions:\n         return False\n@@ -167,41 +145,42 @@ def check_version(max_versions, version, arch) -> bool:\n         return ver <= max_versions[lib][arch]\n \n def check_imported_symbols(filename) -> bool:\n-    elf = pixie.load(filename)\n-    cppfilt = CPPFilt()\n     ok: bool = True\n+    binary = lief.parse(filename)\n \n-    for symbol in elf.dyn_symbols:\n-        if not symbol.is_import:\n+    for symbol in binary.imported_symbols:\n+        if not symbol.imported:\n             continue\n-        sym = symbol.name.decode()\n-        version = symbol.version.decode() if symbol.version is not None else None\n-        if version and not check_version(MAX_VERSIONS, version, elf.hdr.e_machine):\n-            print('{}: symbol {} from unsupported version {}'.format(filename, cppfilt(sym), version))\n-            ok = False\n+\n+        version = symbol.symbol_version if symbol.has_version else None\n+\n+        if version:\n+            aux_version = version.symbol_version_auxiliary.name if version.has_auxiliary_version else None\n+            if aux_version and not check_version(MAX_VERSIONS, aux_version, binary.header.machine_type):\n+                print(f'{filename}: symbol {symbol.name} from unsupported version {version}')\n+                ok = False\n     return ok\n \n def check_exported_symbols(filename) -> bool:\n-    elf = pixie.load(filename)\n-    cppfilt = CPPFilt()\n     ok: bool = True\n-    for symbol in elf.dyn_symbols:\n-        if not symbol.is_export:\n+    binary = lief.parse(filename)\n+\n+    for symbol in binary.dynamic_symbols:\n+        if not symbol.exported:\n             continue\n-        sym = symbol.name.decode()\n-        if elf.hdr.e_machine == pixie.EM_RISCV or sym in IGNORE_EXPORTS:\n+        name = symbol.name\n+        if binary.header.machine_type == LIEF_ELF_ARCH_RISCV or name in IGNORE_EXPORTS:\n             continue\n-        print('{}: export of symbol {} not allowed'.format(filename, cppfilt(sym)))\n+        print(f'{filename}: export of symbol {name} not allowed!')\n         ok = False\n     return ok\n \n def check_ELF_libraries(filename) -> bool:\n     ok: bool = True\n-    elf = pixie.load(filename)\n-    for library_name in elf.query_dyn_tags(pixie.DT_NEEDED):\n-        assert(isinstance(library_name, bytes))\n-        if library_name.decode() not in ELF_ALLOWED_LIBRARIES:\n-            print('{}: NEEDED library {} is not allowed'.format(filename, library_name.decode()))\n+    binary = lief.parse(filename)\n+    for library in binary.libraries:\n+        if library not in ELF_ALLOWED_LIBRARIES:\n+            print(f'{filename}: {library} is not in ALLOWED_LIBRARIES!')\n             ok = False\n     return ok\n "
      },
      {
        "sha": "5246375fe317e8a65a6bfa44d5927fcd34c6e9a2",
        "filename": "contrib/devtools/test-symbol-check.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309eac9019c224dfd79a78e381cfcb70fee190f3/contrib/devtools/test-symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309eac9019c224dfd79a78e381cfcb70fee190f3/contrib/devtools/test-symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-symbol-check.py?ref=309eac9019c224dfd79a78e381cfcb70fee190f3",
        "patch": "@@ -60,7 +60,7 @@ def test_ELF(self):\n         ''')\n \n         self.assertEqual(call_symbol_check(cc, source, executable, ['-lm']),\n-                (1, executable + ': symbol nextup from unsupported version GLIBC_2.24\\n' +\n+                (1, executable + ': symbol nextup from unsupported version GLIBC_2.24(3)\\n' +\n                     executable + ': failed IMPORTED_SYMBOLS'))\n \n         # -lutil is part of the libc6 package so a safe bet that it's installed\n@@ -79,7 +79,7 @@ def test_ELF(self):\n         ''')\n \n         self.assertEqual(call_symbol_check(cc, source, executable, ['-lutil']),\n-                (1, executable + ': NEEDED library libutil.so.1 is not allowed\\n' +\n+                (1, executable + ': libutil.so.1 is not in ALLOWED_LIBRARIES!\\n' +\n                     executable + ': failed LIBRARY_DEPENDENCIES'))\n \n         # finally, check a simple conforming binary"
      },
      {
        "sha": "9d15120b7243e9bb39de5d11b99b617d9fe1ccbf",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 13,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/309eac9019c224dfd79a78e381cfcb70fee190f3/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/309eac9019c224dfd79a78e381cfcb70fee190f3/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=309eac9019c224dfd79a78e381cfcb70fee190f3",
        "patch": "@@ -808,20 +808,8 @@ clean-local:\n \t$(AM_V_GEN) $(WINDRES) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(CPPFLAGS) -DWINDRES_PREPROC -i $< -o $@\n \n check-symbols: $(bin_PROGRAMS)\n-if TARGET_DARWIN\n-\t@echo \"Checking macOS dynamic libraries...\"\n+\t@echo \"Running symbol and dynamic library checks...\"\n \t$(AM_V_at) $(PYTHON) $(top_srcdir)/contrib/devtools/symbol-check.py $(bin_PROGRAMS)\n-endif\n-\n-if TARGET_WINDOWS\n-\t@echo \"Checking Windows dynamic libraries...\"\n-\t$(AM_V_at) $(PYTHON) $(top_srcdir)/contrib/devtools/symbol-check.py $(bin_PROGRAMS)\n-endif\n-\n-if TARGET_LINUX\n-\t@echo \"Checking glibc back compat...\"\n-\t$(AM_V_at) CPPFILT='$(CPPFILT)' $(PYTHON) $(top_srcdir)/contrib/devtools/symbol-check.py $(bin_PROGRAMS)\n-endif\n \n check-security: $(bin_PROGRAMS)\n if HARDEN"
      }
    ]
  },
  {
    "sha": "8242ae230e1ff362a4e16f1503e503317471c790",
    "node_id": "C_kwDOABII59oAKDgyNDJhZTIzMGUxZmYzNjJhNGUxNmYxNTAzZTUwMzMxNzQ3MWM3OTA",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-07-02T06:37:06Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-12T00:36:21Z"
      },
      "message": "scripts: only parse the binary once in symbol-check.py",
      "tree": {
        "sha": "7602eefa448f1ee81020d5727c7710ef1ead624a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7602eefa448f1ee81020d5727c7710ef1ead624a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8242ae230e1ff362a4e16f1503e503317471c790",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmFk2IUACgkQLuufXMCV\nJsH36g//XsuP4HRJflZeKH3GDTR2dc3X1cMUyoLDGLv9qfii/SrN6TFDBF0X1mrV\n4XprOJ3JjY53yESjom6PZ5Vd3RzQ1o1cxOjUbId3Rv7Ye1gGRO2i6i9lcbV0+Mcs\nGAjgArCyj4ptawY+BX1gNZmW52tfZqx9IgRWNiMwlLBIKGRGknBq1Dv24maniqna\nFqHJlQvzqz7QI6I55vHayFM1YOjY+rAA16doA4Ch3hPZB7lWgvj2iqiwFvp1/Uvf\ngp3ngjU/8Yo2EfK5FHjOjWagE7x3NU3RsXH2u55eeG0AlftNv2HELi9oyKJdTCqW\nMzVuC3iUrGqu7wi5E4ByyHkKWllpwqtOR5a8QWL+RhMaUro04Fd/6RNkRt0qDzvv\n/icoGPwwc7Qk00XH4QRqQDCXK/5XExTAoDLJXStSz0pX4pXSDVtur71Jo3Uj/8dU\n0cNYvJjgcgQ/s4U6js7DCTRwXWUJcZMcQWYnfSt67e9xxxYZ2HXtpfX8vEXZQaR4\nFc7x0DX3tpeOr1cch+SseXPPLBlvlJVhsRTJXY7/A9i1qILRmcOkLC7c2M5vCaQX\nSSFkHFq6mpd79vZnwBOcKA9Lds/XFReicBNaXfWlWtBkoCi8oSmt0rbde2c91b3o\n0hCpfyMPyp4w6O4IX23Fyc0cDtdIg1T30t2yvSPxTjDr9jKCu7I=\n=vRp3\n-----END PGP SIGNATURE-----",
        "payload": "tree 7602eefa448f1ee81020d5727c7710ef1ead624a\nparent 309eac9019c224dfd79a78e381cfcb70fee190f3\nauthor fanquake <fanquake@gmail.com> 1625207826 +0800\ncommitter fanquake <fanquake@gmail.com> 1633998981 +0800\n\nscripts: only parse the binary once in symbol-check.py\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8242ae230e1ff362a4e16f1503e503317471c790",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8242ae230e1ff362a4e16f1503e503317471c790",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8242ae230e1ff362a4e16f1503e503317471c790/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "309eac9019c224dfd79a78e381cfcb70fee190f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309eac9019c224dfd79a78e381cfcb70fee190f3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/309eac9019c224dfd79a78e381cfcb70fee190f3"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 15,
      "deletions": 33
    },
    "files": [
      {
        "sha": "c8703c53ba24fc4cbe12870d17680235c900d560",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 15,
        "deletions": 33,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8242ae230e1ff362a4e16f1503e503317471c790/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8242ae230e1ff362a4e16f1503e503317471c790/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=8242ae230e1ff362a4e16f1503e503317471c790",
        "patch": "@@ -11,7 +11,7 @@\n     find ../path/to/binaries -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n '''\n import sys\n-from typing import List, Optional\n+from typing import List\n \n import lief\n \n@@ -144,9 +144,8 @@ def check_version(max_versions, version, arch) -> bool:\n     else:\n         return ver <= max_versions[lib][arch]\n \n-def check_imported_symbols(filename) -> bool:\n+def check_imported_symbols(binary) -> bool:\n     ok: bool = True\n-    binary = lief.parse(filename)\n \n     for symbol in binary.imported_symbols:\n         if not symbol.imported:\n@@ -161,62 +160,55 @@ def check_imported_symbols(filename) -> bool:\n                 ok = False\n     return ok\n \n-def check_exported_symbols(filename) -> bool:\n+def check_exported_symbols(binary) -> bool:\n     ok: bool = True\n-    binary = lief.parse(filename)\n \n     for symbol in binary.dynamic_symbols:\n         if not symbol.exported:\n             continue\n         name = symbol.name\n         if binary.header.machine_type == LIEF_ELF_ARCH_RISCV or name in IGNORE_EXPORTS:\n             continue\n-        print(f'{filename}: export of symbol {name} not allowed!')\n+        print(f'{binary.name}: export of symbol {name} not allowed!')\n         ok = False\n     return ok\n \n-def check_ELF_libraries(filename) -> bool:\n+def check_ELF_libraries(binary) -> bool:\n     ok: bool = True\n-    binary = lief.parse(filename)\n     for library in binary.libraries:\n         if library not in ELF_ALLOWED_LIBRARIES:\n             print(f'{filename}: {library} is not in ALLOWED_LIBRARIES!')\n             ok = False\n     return ok\n \n-def check_MACHO_libraries(filename) -> bool:\n+def check_MACHO_libraries(binary) -> bool:\n     ok: bool = True\n-    binary = lief.parse(filename)\n     for dylib in binary.libraries:\n         split = dylib.name.split('/')\n         if split[-1] not in MACHO_ALLOWED_LIBRARIES:\n             print(f'{split[-1]} is not in ALLOWED_LIBRARIES!')\n             ok = False\n     return ok\n \n-def check_MACHO_min_os(filename) -> bool:\n-    binary = lief.parse(filename)\n+def check_MACHO_min_os(binary) -> bool:\n     if binary.build_version.minos == [10,15,0]:\n         return True\n     return False\n \n-def check_MACHO_sdk(filename) -> bool:\n-    binary = lief.parse(filename)\n+def check_MACHO_sdk(binary) -> bool:\n     if binary.build_version.sdk == [10, 15, 6]:\n         return True\n     return False\n \n-def check_PE_libraries(filename) -> bool:\n+def check_PE_libraries(binary) -> bool:\n     ok: bool = True\n-    binary = lief.parse(filename)\n     for dylib in binary.libraries:\n         if dylib not in PE_ALLOWED_LIBRARIES:\n             print(f'{dylib} is not in ALLOWED_LIBRARIES!')\n             ok = False\n     return ok\n \n-def check_PE_subsystem_version(filename) -> bool:\n-    binary = lief.parse(filename)\n+def check_PE_subsystem_version(binary) -> bool:\n     major: int = binary.optional_header.major_subsystem_version\n     minor: int = binary.optional_header.minor_subsystem_version\n     if major == 6 and minor == 1:\n@@ -240,30 +232,20 @@ def check_PE_subsystem_version(filename) -> bool:\n ]\n }\n \n-def identify_executable(executable) -> Optional[str]:\n-    with open(filename, 'rb') as f:\n-        magic = f.read(4)\n-    if magic.startswith(b'MZ'):\n-        return 'PE'\n-    elif magic.startswith(b'\\x7fELF'):\n-        return 'ELF'\n-    elif magic.startswith(b'\\xcf\\xfa'):\n-        return 'MACHO'\n-    return None\n-\n if __name__ == '__main__':\n     retval: int = 0\n     for filename in sys.argv[1:]:\n         try:\n-            etype = identify_executable(filename)\n-            if etype is None:\n-                print(f'{filename}: unknown format')\n+            binary = lief.parse(filename)\n+            etype = binary.format.name\n+            if etype == lief.EXE_FORMATS.UNKNOWN:\n+                print(f'{filename}: unknown executable format')\n                 retval = 1\n                 continue\n \n             failed: List[str] = []\n             for (name, func) in CHECKS[etype]:\n-                if not func(filename):\n+                if not func(binary):\n                     failed.append(name)\n             if failed:\n                 print(f'{filename}: failed {\" \".join(failed)}')"
      }
    ]
  },
  {
    "sha": "cad40a5b167c5300564bd7b4505cf6650780084b",
    "node_id": "C_kwDOABII59oAKGNhZDQwYTViMTY3YzUzMDA1NjRiZDdiNDUwNWNmNjY1MDc4MDA4NGI",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-07-02T11:53:33Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-12T00:36:21Z"
      },
      "message": "scripts: use LIEF for ELF checks in security-check.py",
      "tree": {
        "sha": "bdd5b39c7ac76ed0dc0f3c2b14820fe7792ddc77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bdd5b39c7ac76ed0dc0f3c2b14820fe7792ddc77"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cad40a5b167c5300564bd7b4505cf6650780084b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmFk2IUACgkQLuufXMCV\nJsGKTA//VwSsvBUhlMn8io9QVdA9esL7lHH+YujKBOHFKUFNoOsgR0SL7614ElDB\nAHaSWITATyM+NOMfu1YXFQ/BM4YAuGhC5yflczEz8vbO+pKIMNjB0LnJo9e+ZvZ7\nNpaT/t2yO7imSRvEQ/tLUhyWBLbzQ5ML2SgYi54fKIl/i9srS0yicYkCJDs617tK\nPo+nUTo9MeLNIEUT7jNodl1/M4WYPboD+gOZRcAimA3AQDdHeiU704uEiMsa3RCM\nHteMZR+NqXxII0zuc4qQj2MzY54fsd/kQ7zp4ZJyWOApXU+MTKY2JRzLrvqK4AsP\nJVYTJ2dl9TRENtOFq1Dsh1e97282dUrbtMWJpoChQJk3zW08Gs/0Tv29KR5Dtyns\nBe5SaW6TuDwBsiUiRe1lriRYN9mYOnHLSIt6PoZiQ+73i6DKI/Z7RdPcQWy3uTib\nZ0TuMSZAPV4P5SJLTrxrf2ZS6zKgLSQw5Wt0mgMEpr8dt9DEVh64EM5Q1mppIvSV\nBNIb+YasLhg+dqewUpc8CEvdNhVrpOnFIDMM6PsAmri/fGV850suuEEyQmSs+HEs\nNmZYbCuJfB586bSRsIUfYMdTeFVvtuX4RYGysv6jwjKVHjgx2isDb7x5684ql4C5\neB86D40VGx3RMhE9U6RERdtq9xz8kbXq1H0p28y5GInjryVmWeI=\n=dWsL\n-----END PGP SIGNATURE-----",
        "payload": "tree bdd5b39c7ac76ed0dc0f3c2b14820fe7792ddc77\nparent 8242ae230e1ff362a4e16f1503e503317471c790\nauthor fanquake <fanquake@gmail.com> 1625226813 +0800\ncommitter fanquake <fanquake@gmail.com> 1633998981 +0800\n\nscripts: use LIEF for ELF checks in security-check.py\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cad40a5b167c5300564bd7b4505cf6650780084b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cad40a5b167c5300564bd7b4505cf6650780084b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cad40a5b167c5300564bd7b4505cf6650780084b/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8242ae230e1ff362a4e16f1503e503317471c790",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8242ae230e1ff362a4e16f1503e503317471c790",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8242ae230e1ff362a4e16f1503e503317471c790"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 52,
      "deletions": 76
    },
    "files": [
      {
        "sha": "14c58729fbf7ce053a38069b774a3153673e581c",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 52,
        "deletions": 76,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad40a5b167c5300564bd7b4505cf6650780084b/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad40a5b167c5300564bd7b4505cf6650780084b/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=cad40a5b167c5300564bd7b4505cf6650780084b",
        "patch": "@@ -11,126 +11,102 @@\n from typing import List, Optional\n \n import lief\n-import pixie\n-\n-def check_ELF_PIE(executable) -> bool:\n-    '''\n-    Check for position independent executable (PIE), allowing for address space randomization.\n-    '''\n-    elf = pixie.load(executable)\n-    return elf.hdr.e_type == pixie.ET_DYN\n-\n-def check_ELF_NX(executable) -> bool:\n-    '''\n-    Check that no sections are writable and executable (including the stack)\n-    '''\n-    elf = pixie.load(executable)\n-    have_wx = False\n-    have_gnu_stack = False\n-    for ph in elf.program_headers:\n-        if ph.p_type == pixie.PT_GNU_STACK:\n-            have_gnu_stack = True\n-        if (ph.p_flags & pixie.PF_W) != 0 and (ph.p_flags & pixie.PF_X) != 0: # section is both writable and executable\n-            have_wx = True\n-    return have_gnu_stack and not have_wx\n \n def check_ELF_RELRO(executable) -> bool:\n     '''\n     Check for read-only relocations.\n     GNU_RELRO program header must exist\n     Dynamic section must have BIND_NOW flag\n     '''\n-    elf = pixie.load(executable)\n+    binary = lief.parse(executable)\n     have_gnu_relro = False\n-    for ph in elf.program_headers:\n+    for segment in binary.segments:\n         # Note: not checking p_flags == PF_R: here as linkers set the permission differently\n         # This does not affect security: the permission flags of the GNU_RELRO program\n         # header are ignored, the PT_LOAD header determines the effective permissions.\n         # However, the dynamic linker need to write to this area so these are RW.\n         # Glibc itself takes care of mprotecting this area R after relocations are finished.\n         # See also https://marc.info/?l=binutils&m=1498883354122353\n-        if ph.p_type == pixie.PT_GNU_RELRO:\n+        if segment.type == lief.ELF.SEGMENT_TYPES.GNU_RELRO:\n             have_gnu_relro = True\n \n     have_bindnow = False\n-    for flags in elf.query_dyn_tags(pixie.DT_FLAGS):\n-        assert isinstance(flags, int)\n-        if flags & pixie.DF_BIND_NOW:\n+    try:\n+        flags = binary.get(lief.ELF.DYNAMIC_TAGS.FLAGS)\n+        if flags.value & lief.ELF.DYNAMIC_FLAGS.BIND_NOW:\n             have_bindnow = True\n+    except:\n+        have_bindnow = False\n \n     return have_gnu_relro and have_bindnow\n \n def check_ELF_Canary(executable) -> bool:\n     '''\n     Check for use of stack canary\n     '''\n-    elf = pixie.load(executable)\n-    ok = False\n-    for symbol in elf.dyn_symbols:\n-        if symbol.name == b'__stack_chk_fail':\n-            ok = True\n-    return ok\n+    binary = lief.parse(executable)\n+    return binary.has_symbol('__stack_chk_fail')\n \n def check_ELF_separate_code(executable):\n     '''\n     Check that sections are appropriately separated in virtual memory,\n     based on their permissions. This checks for missing -Wl,-z,separate-code\n     and potentially other problems.\n     '''\n-    elf = pixie.load(executable)\n-    R = pixie.PF_R\n-    W = pixie.PF_W\n-    E = pixie.PF_X\n+    binary = lief.parse(executable)\n+    R = lief.ELF.SEGMENT_FLAGS.R\n+    W = lief.ELF.SEGMENT_FLAGS.W\n+    E = lief.ELF.SEGMENT_FLAGS.X\n     EXPECTED_FLAGS = {\n         # Read + execute\n-        b'.init': R | E,\n-        b'.plt': R | E,\n-        b'.plt.got': R | E,\n-        b'.plt.sec': R | E,\n-        b'.text': R | E,\n-        b'.fini': R | E,\n+        '.init': R | E,\n+        '.plt': R | E,\n+        '.plt.got': R | E,\n+        '.plt.sec': R | E,\n+        '.text': R | E,\n+        '.fini': R | E,\n         # Read-only data\n-        b'.interp': R,\n-        b'.note.gnu.property': R,\n-        b'.note.gnu.build-id': R,\n-        b'.note.ABI-tag': R,\n-        b'.gnu.hash': R,\n-        b'.dynsym': R,\n-        b'.dynstr': R,\n-        b'.gnu.version': R,\n-        b'.gnu.version_r': R,\n-        b'.rela.dyn': R,\n-        b'.rela.plt': R,\n-        b'.rodata': R,\n-        b'.eh_frame_hdr': R,\n-        b'.eh_frame': R,\n-        b'.qtmetadata': R,\n-        b'.gcc_except_table': R,\n-        b'.stapsdt.base': R,\n+        '.interp': R,\n+        '.note.gnu.property': R,\n+        '.note.gnu.build-id': R,\n+        '.note.ABI-tag': R,\n+        '.gnu.hash': R,\n+        '.dynsym': R,\n+        '.dynstr': R,\n+        '.gnu.version': R,\n+        '.gnu.version_r': R,\n+        '.rela.dyn': R,\n+        '.rela.plt': R,\n+        '.rodata': R,\n+        '.eh_frame_hdr': R,\n+        '.eh_frame': R,\n+        '.qtmetadata': R,\n+        '.gcc_except_table': R,\n+        '.stapsdt.base': R,\n         # Writable data\n-        b'.init_array': R | W,\n-        b'.fini_array': R | W,\n-        b'.dynamic': R | W,\n-        b'.got': R | W,\n-        b'.data': R | W,\n-        b'.bss': R | W,\n+        '.init_array': R | W,\n+        '.fini_array': R | W,\n+        '.dynamic': R | W,\n+        '.got': R | W,\n+        '.data': R | W,\n+        '.bss': R | W,\n     }\n-    if elf.hdr.e_machine == pixie.EM_PPC64:\n+    if binary.header.machine_type == lief.ELF.ARCH.PPC64:\n         # .plt is RW on ppc64 even with separate-code\n-        EXPECTED_FLAGS[b'.plt'] = R | W\n+        EXPECTED_FLAGS['.plt'] = R | W\n     # For all LOAD program headers get mapping to the list of sections,\n     # and for each section, remember the flags of the associated program header.\n     flags_per_section = {}\n-    for ph in elf.program_headers:\n-        if ph.p_type == pixie.PT_LOAD:\n-            for section in ph.sections:\n+    for segment in binary.segments:\n+        if segment.type ==  lief.ELF.SEGMENT_TYPES.LOAD:\n+            for section in segment.sections:\n                 assert(section.name not in flags_per_section)\n-                flags_per_section[section.name] = ph.p_flags\n+                flags_per_section[section.name] = segment.flags\n     # Spot-check ELF LOAD program header flags per section\n     # If these sections exist, check them against the expected R/W/E flags\n     for (section, flags) in flags_per_section.items():\n         if section in EXPECTED_FLAGS:\n-            if EXPECTED_FLAGS[section] != flags:\n+            if int(EXPECTED_FLAGS[section]) != int(flags):\n                 return False\n     return True\n \n@@ -203,8 +179,8 @@ def check_control_flow(executable) -> bool:\n \n CHECKS = {\n 'ELF': [\n-    ('PIE', check_ELF_PIE),\n-    ('NX', check_ELF_NX),\n+    ('PIE', check_PIE),\n+    ('NX', check_NX),\n     ('RELRO', check_ELF_RELRO),\n     ('Canary', check_ELF_Canary),\n     ('separate_code', check_ELF_separate_code),"
      }
    ]
  },
  {
    "sha": "00b85d0b13e419c1b48f47a90236cb4ed7fab491",
    "node_id": "C_kwDOABII59oAKDAwYjg1ZDBiMTNlNDE5YzFiNDhmNDdhOTAyMzZjYjRlZDdmYWI0OTE",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-07-09T02:35:13Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-12T00:36:21Z"
      },
      "message": "scripts: only parse the binary once in security-check.py",
      "tree": {
        "sha": "0e8f87cbea96ec5959963e140ae410cf3f5fae8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e8f87cbea96ec5959963e140ae410cf3f5fae8b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00b85d0b13e419c1b48f47a90236cb4ed7fab491",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmFk2IUACgkQLuufXMCV\nJsHP4Q/9FFaectjbuAmBCvnZDrFfrSOssIgJeQd/7kr6DYczq1fWpXdTVvcr8MjK\ncA7giv4vp4qUdBEUUrc8Yk0wz5mUAGBzLHFFEYGGWtdMaNC9dESJJSKc2C/K1NYt\ndz+fy6vohEcpWCbPo0gorAziKbLLNhF369ayHpz173Atex4vfl/vRik6QaKtlnNB\nwl/BgVq/kdi1XCUqNqn0gigs0L27BS2DxhupCnhmkK9kbyIDDlTcxWWehwMnL3vp\nOfVs5FX46edFKUUI52qX0/jECJJ33q/YjX585PbfLCniLrRM9PxmqYD9rcqU9/4z\ndeEPqM26/ieOUg5v8NL8Y+TSn+E+yVivQa5c4Ihsy5Vcf4ZwgY/vO6ZPCPbwN8/A\n7P7vUjZc9ADQOKvzpvl+xJfgpXWThXFCp6c+OORsI6Lit3Nbqsq/Dmw5m/GyzpWv\nBUVkwq42qFeV2lCjZXMSgHPYAbp6+6MWiszDWJYfF/hA6dZbE8iMUcezZc4NAslj\n2PVm9D5YfmBIjHRLfGI9BWqoW16WtmA9ycsfNxudaHDl1RzcU6NiWSQQdE3i6RG6\nB8SZIEA+74ucUvhO6B9YUJ4gyWxHevcRwyNIONVNpMPZJgUL+UZxwEotb16OrMS+\nm94AmiOpc/IEa1hQYbESdNW1jwGLhcn1Is2RkJ0CBa4xkSmZwU0=\n=xy5W\n-----END PGP SIGNATURE-----",
        "payload": "tree 0e8f87cbea96ec5959963e140ae410cf3f5fae8b\nparent cad40a5b167c5300564bd7b4505cf6650780084b\nauthor fanquake <fanquake@gmail.com> 1625798113 +0800\ncommitter fanquake <fanquake@gmail.com> 1633998981 +0800\n\nscripts: only parse the binary once in security-check.py\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00b85d0b13e419c1b48f47a90236cb4ed7fab491",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00b85d0b13e419c1b48f47a90236cb4ed7fab491",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00b85d0b13e419c1b48f47a90236cb4ed7fab491/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cad40a5b167c5300564bd7b4505cf6650780084b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cad40a5b167c5300564bd7b4505cf6650780084b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cad40a5b167c5300564bd7b4505cf6650780084b"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 18,
      "deletions": 41
    },
    "files": [
      {
        "sha": "c374de4b55aad5e6bf80840c3a2adeb2a040e0ca",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 18,
        "deletions": 41,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00b85d0b13e419c1b48f47a90236cb4ed7fab491/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00b85d0b13e419c1b48f47a90236cb4ed7fab491/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=00b85d0b13e419c1b48f47a90236cb4ed7fab491",
        "patch": "@@ -8,17 +8,16 @@\n Otherwise the exit status will be 1 and it will log which executables failed which checks.\n '''\n import sys\n-from typing import List, Optional\n+from typing import List\n \n import lief\n \n-def check_ELF_RELRO(executable) -> bool:\n+def check_ELF_RELRO(binary) -> bool:\n     '''\n     Check for read-only relocations.\n     GNU_RELRO program header must exist\n     Dynamic section must have BIND_NOW flag\n     '''\n-    binary = lief.parse(executable)\n     have_gnu_relro = False\n     for segment in binary.segments:\n         # Note: not checking p_flags == PF_R: here as linkers set the permission differently\n@@ -40,20 +39,18 @@ def check_ELF_RELRO(executable) -> bool:\n \n     return have_gnu_relro and have_bindnow\n \n-def check_ELF_Canary(executable) -> bool:\n+def check_ELF_Canary(binary) -> bool:\n     '''\n     Check for use of stack canary\n     '''\n-    binary = lief.parse(executable)\n     return binary.has_symbol('__stack_chk_fail')\n \n-def check_ELF_separate_code(executable):\n+def check_ELF_separate_code(binary):\n     '''\n     Check that sections are appropriately separated in virtual memory,\n     based on their permissions. This checks for missing -Wl,-z,separate-code\n     and potentially other problems.\n     '''\n-    binary = lief.parse(executable)\n     R = lief.ELF.SEGMENT_FLAGS.R\n     W = lief.ELF.SEGMENT_FLAGS.W\n     E = lief.ELF.SEGMENT_FLAGS.X\n@@ -110,66 +107,56 @@ def check_ELF_separate_code(executable):\n                 return False\n     return True\n \n-def check_PE_DYNAMIC_BASE(executable) -> bool:\n+def check_PE_DYNAMIC_BASE(binary) -> bool:\n     '''PIE: DllCharacteristics bit 0x40 signifies dynamicbase (ASLR)'''\n-    binary = lief.parse(executable)\n     return lief.PE.DLL_CHARACTERISTICS.DYNAMIC_BASE in binary.optional_header.dll_characteristics_lists\n \n # Must support high-entropy 64-bit address space layout randomization\n # in addition to DYNAMIC_BASE to have secure ASLR.\n-def check_PE_HIGH_ENTROPY_VA(executable) -> bool:\n+def check_PE_HIGH_ENTROPY_VA(binary) -> bool:\n     '''PIE: DllCharacteristics bit 0x20 signifies high-entropy ASLR'''\n-    binary = lief.parse(executable)\n     return lief.PE.DLL_CHARACTERISTICS.HIGH_ENTROPY_VA in binary.optional_header.dll_characteristics_lists\n \n-def check_PE_RELOC_SECTION(executable) -> bool:\n+def check_PE_RELOC_SECTION(binary) -> bool:\n     '''Check for a reloc section. This is required for functional ASLR.'''\n-    binary = lief.parse(executable)\n     return binary.has_relocations\n \n-def check_MACHO_NOUNDEFS(executable) -> bool:\n+def check_MACHO_NOUNDEFS(binary) -> bool:\n     '''\n     Check for no undefined references.\n     '''\n-    binary = lief.parse(executable)\n     return binary.header.has(lief.MachO.HEADER_FLAGS.NOUNDEFS)\n \n-def check_MACHO_LAZY_BINDINGS(executable) -> bool:\n+def check_MACHO_LAZY_BINDINGS(binary) -> bool:\n     '''\n     Check for no lazy bindings.\n     We don't use or check for MH_BINDATLOAD. See #18295.\n     '''\n-    binary = lief.parse(executable)\n     return binary.dyld_info.lazy_bind == (0,0)\n \n-def check_MACHO_Canary(executable) -> bool:\n+def check_MACHO_Canary(binary) -> bool:\n     '''\n     Check for use of stack canary\n     '''\n-    binary = lief.parse(executable)\n     return binary.has_symbol('___stack_chk_fail')\n \n-def check_PIE(executable) -> bool:\n+def check_PIE(binary) -> bool:\n     '''\n     Check for position independent executable (PIE),\n     allowing for address space randomization.\n     '''\n-    binary = lief.parse(executable)\n     return binary.is_pie\n \n-def check_NX(executable) -> bool:\n+def check_NX(binary) -> bool:\n     '''\n     Check for no stack execution\n     '''\n-    binary = lief.parse(executable)\n     return binary.has_nx\n \n-def check_control_flow(executable) -> bool:\n+def check_control_flow(binary) -> bool:\n     '''\n     Check for control flow instrumentation\n     '''\n-    binary = lief.parse(executable)\n-\n     content = binary.get_content_from_virtual_address(binary.entrypoint, 4, lief.Binary.VA_TYPES.AUTO)\n \n     if content == [243, 15, 30, 250]: # endbr64\n@@ -202,30 +189,20 @@ def check_control_flow(executable) -> bool:\n ]\n }\n \n-def identify_executable(executable) -> Optional[str]:\n-    with open(filename, 'rb') as f:\n-        magic = f.read(4)\n-    if magic.startswith(b'MZ'):\n-        return 'PE'\n-    elif magic.startswith(b'\\x7fELF'):\n-        return 'ELF'\n-    elif magic.startswith(b'\\xcf\\xfa'):\n-        return 'MACHO'\n-    return None\n-\n if __name__ == '__main__':\n     retval: int = 0\n     for filename in sys.argv[1:]:\n         try:\n-            etype = identify_executable(filename)\n-            if etype is None:\n-                print(f'{filename}: unknown format')\n+            binary = lief.parse(filename)\n+            etype = binary.format.name\n+            if etype == lief.EXE_FORMATS.UNKNOWN:\n+                print(f'{filename}: unknown executable format')\n                 retval = 1\n                 continue\n \n             failed: List[str] = []\n             for (name, func) in CHECKS[etype]:\n-                if not func(filename):\n+                if not func(binary):\n                     failed.append(name)\n             if failed:\n                 print(f'{filename}: failed {\" \".join(failed)}')"
      }
    ]
  },
  {
    "sha": "ce69e18947dd917d54eb036e732ac7f7bceede76",
    "node_id": "C_kwDOABII59oAKGNlNjllMTg5NDdkZDkxN2Q1NGViMDM2ZTczMmFjN2Y3YmNlZWRlNzY",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-07-09T02:35:30Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-12T00:36:21Z"
      },
      "message": "scripts: remove pixie.py",
      "tree": {
        "sha": "65272f313417ca496874ab3d51444e6a45783f10",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65272f313417ca496874ab3d51444e6a45783f10"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce69e18947dd917d54eb036e732ac7f7bceede76",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmFk2IUACgkQLuufXMCV\nJsFAbxAAlKd5YroMqM7n63LmuJfh3H9iMcgdp9oX825iH5kpClkePy3Kc123l7sU\nji1H/uQF86MLUf5WR4q1V3+EmNIpFL7S0jxk6TAnFa71tmJqi0Jbox3gK7eDCov0\nX8qg5ETwejlDbKoL+PsnV4+erDXlR59hBr06plRmTtDvfdLe0MERjMPh5T1FU1Is\n82ZT/q3cURwjcunsbjx730G5NN7SBoRUUlUVH8YXObocQgBVkLoGavXfc7J9FmX8\nsCMiZcmbSODDm04LAK/ep9BR5hN8XpMOYYYgfiAOSGrYgGjEDO/RcsUZBeXYQALm\nLDEFNla00iF1JvzwJv2X8epxqNHJc/dES/HdYLlgiIKk9em4rV4J90V9AULji2ME\nLvp7OvkfFz8Xs4y6uZlKmRkLLYvjBypDXqn1XsKTWoXwg539DXUypC8a6KFJj1ek\nBo0LJV24w//rwFJXsNsHe/PtXGH1We5yVhMT4WpIcnq5XkwQexFC6bgINw6mHs/n\n71DdrGarDvWOeABJA4hxEqCLtPTJiy2nosiVOW2ANrGo0H5kqy5RakPietQxLgNl\nxUce64dsqlfnsZVDWJBrlF4U83ylKnnnjkrjFe9zw7wKXdm6TbygvzpLGTyOnKFY\nLr7UvlFrbYeigHHoWrI+AJfOfAmDwG/S6jJm6lKpsHGeKUipF/o=\n=MIu9\n-----END PGP SIGNATURE-----",
        "payload": "tree 65272f313417ca496874ab3d51444e6a45783f10\nparent 00b85d0b13e419c1b48f47a90236cb4ed7fab491\nauthor fanquake <fanquake@gmail.com> 1625798130 +0800\ncommitter fanquake <fanquake@gmail.com> 1633998981 +0800\n\nscripts: remove pixie.py\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce69e18947dd917d54eb036e732ac7f7bceede76",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce69e18947dd917d54eb036e732ac7f7bceede76",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce69e18947dd917d54eb036e732ac7f7bceede76/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00b85d0b13e419c1b48f47a90236cb4ed7fab491",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00b85d0b13e419c1b48f47a90236cb4ed7fab491",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00b85d0b13e419c1b48f47a90236cb4ed7fab491"
      }
    ],
    "stats": {
      "total": 326,
      "additions": 1,
      "deletions": 325
    },
    "files": [
      {
        "sha": "af63cf0cbbc2b171352d276f3983a77ef5e8df21",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce69e18947dd917d54eb036e732ac7f7bceede76/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce69e18947dd917d54eb036e732ac7f7bceede76/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=ce69e18947dd917d54eb036e732ac7f7bceede76",
        "patch": "@@ -58,8 +58,7 @@ DIST_SHARE = \\\n \n BIN_CHECKS=$(top_srcdir)/contrib/devtools/symbol-check.py \\\n            $(top_srcdir)/contrib/devtools/security-check.py \\\n-           $(top_srcdir)/contrib/devtools/utils.py \\\n-           $(top_srcdir)/contrib/devtools/pixie.py\n+           $(top_srcdir)/contrib/devtools/utils.py\n \n WINDOWS_PACKAGING = $(top_srcdir)/share/pixmaps/bitcoin.ico \\\n   $(top_srcdir)/share/pixmaps/nsis-header.bmp \\"
      },
      {
        "sha": "64660968ad255886df97501115de636ae8873a73",
        "filename": "contrib/devtools/pixie.py",
        "status": "removed",
        "additions": 0,
        "deletions": 323,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00b85d0b13e419c1b48f47a90236cb4ed7fab491/contrib/devtools/pixie.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00b85d0b13e419c1b48f47a90236cb4ed7fab491/contrib/devtools/pixie.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/pixie.py?ref=00b85d0b13e419c1b48f47a90236cb4ed7fab491",
        "patch": "@@ -1,323 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2020 Wladimir J. van der Laan\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-'''\n-Compact, self-contained ELF implementation for bitcoin-core security checks.\n-'''\n-import struct\n-import types\n-from typing import Dict, List, Optional, Union, Tuple\n-\n-# you can find all these values in elf.h\n-EI_NIDENT = 16\n-\n-# Byte indices in e_ident\n-EI_CLASS = 4 # ELFCLASSxx\n-EI_DATA = 5  # ELFDATAxxxx\n-\n-ELFCLASS32 = 1 # 32-bit\n-ELFCLASS64 = 2 # 64-bit\n-\n-ELFDATA2LSB = 1 # little endian\n-ELFDATA2MSB = 2 # big endian\n-\n-# relevant values for e_machine\n-EM_386 = 3\n-EM_PPC64 = 21\n-EM_ARM = 40\n-EM_AARCH64 = 183\n-EM_X86_64 = 62\n-EM_RISCV = 243\n-\n-# relevant values for e_type\n-ET_DYN = 3\n-\n-# relevant values for sh_type\n-SHT_PROGBITS = 1\n-SHT_STRTAB = 3\n-SHT_DYNAMIC = 6\n-SHT_DYNSYM = 11\n-SHT_GNU_verneed = 0x6ffffffe\n-SHT_GNU_versym = 0x6fffffff\n-\n-# relevant values for p_type\n-PT_LOAD = 1\n-PT_GNU_STACK = 0x6474e551\n-PT_GNU_RELRO = 0x6474e552\n-\n-# relevant values for p_flags\n-PF_X = (1 << 0)\n-PF_W = (1 << 1)\n-PF_R = (1 << 2)\n-\n-# relevant values for d_tag\n-DT_NEEDED = 1\n-DT_FLAGS = 30\n-\n-# relevant values of `d_un.d_val' in the DT_FLAGS entry\n-DF_BIND_NOW = 0x00000008\n-\n-# relevant d_tags with string payload\n-STRING_TAGS = {DT_NEEDED}\n-\n-# rrlevant values for ST_BIND subfield of st_info (symbol binding)\n-STB_LOCAL = 0\n-\n-class ELFRecord(types.SimpleNamespace):\n-    '''Unified parsing for ELF records.'''\n-    def __init__(self, data: bytes, offset: int, eh: 'ELFHeader', total_size: Optional[int]) -> None:\n-        hdr_struct = self.STRUCT[eh.ei_class][0][eh.ei_data]\n-        if total_size is not None and hdr_struct.size > total_size:\n-            raise ValueError(f'{self.__class__.__name__} header size too small ({total_size} < {hdr_struct.size})')\n-        for field, value in zip(self.STRUCT[eh.ei_class][1], hdr_struct.unpack(data[offset:offset + hdr_struct.size])):\n-            setattr(self, field, value)\n-\n-def BiStruct(chars: str) -> Dict[int, struct.Struct]:\n-    '''Compile a struct parser for both endians.'''\n-    return {\n-        ELFDATA2LSB: struct.Struct('<' + chars),\n-        ELFDATA2MSB: struct.Struct('>' + chars),\n-    }\n-\n-class ELFHeader(ELFRecord):\n-    FIELDS = ['e_type', 'e_machine', 'e_version', 'e_entry', 'e_phoff', 'e_shoff', 'e_flags', 'e_ehsize', 'e_phentsize', 'e_phnum', 'e_shentsize', 'e_shnum', 'e_shstrndx']\n-    STRUCT = {\n-        ELFCLASS32: (BiStruct('HHIIIIIHHHHHH'), FIELDS),\n-        ELFCLASS64: (BiStruct('HHIQQQIHHHHHH'), FIELDS),\n-    }\n-\n-    def __init__(self, data: bytes, offset: int) -> None:\n-        self.e_ident = data[offset:offset + EI_NIDENT]\n-        if self.e_ident[0:4] != b'\\x7fELF':\n-            raise ValueError('invalid ELF magic')\n-        self.ei_class = self.e_ident[EI_CLASS]\n-        self.ei_data = self.e_ident[EI_DATA]\n-\n-        super().__init__(data, offset + EI_NIDENT, self, None)\n-\n-    def __repr__(self) -> str:\n-        return f'Header(e_ident={self.e_ident!r}, e_type={self.e_type}, e_machine={self.e_machine}, e_version={self.e_version}, e_entry={self.e_entry}, e_phoff={self.e_phoff}, e_shoff={self.e_shoff}, e_flags={self.e_flags}, e_ehsize={self.e_ehsize}, e_phentsize={self.e_phentsize}, e_phnum={self.e_phnum}, e_shentsize={self.e_shentsize}, e_shnum={self.e_shnum}, e_shstrndx={self.e_shstrndx})'\n-\n-class Section(ELFRecord):\n-    name: Optional[bytes] = None\n-    FIELDS = ['sh_name', 'sh_type', 'sh_flags', 'sh_addr', 'sh_offset', 'sh_size', 'sh_link', 'sh_info', 'sh_addralign', 'sh_entsize']\n-    STRUCT = {\n-        ELFCLASS32: (BiStruct('IIIIIIIIII'), FIELDS),\n-        ELFCLASS64: (BiStruct('IIQQQQIIQQ'), FIELDS),\n-    }\n-\n-    def __init__(self, data: bytes, offset: int, eh: ELFHeader) -> None:\n-        super().__init__(data, offset, eh, eh.e_shentsize)\n-        self._data = data\n-\n-    def __repr__(self) -> str:\n-        return f'Section(sh_name={self.sh_name}({self.name!r}), sh_type=0x{self.sh_type:x}, sh_flags={self.sh_flags}, sh_addr=0x{self.sh_addr:x}, sh_offset=0x{self.sh_offset:x}, sh_size={self.sh_size}, sh_link={self.sh_link}, sh_info={self.sh_info}, sh_addralign={self.sh_addralign}, sh_entsize={self.sh_entsize})'\n-\n-    def contents(self) -> bytes:\n-        '''Return section contents.'''\n-        return self._data[self.sh_offset:self.sh_offset + self.sh_size]\n-\n-class ProgramHeader(ELFRecord):\n-    STRUCT = {\n-        # different ELF classes have the same fields, but in a different order to optimize space versus alignment\n-        ELFCLASS32: (BiStruct('IIIIIIII'), ['p_type', 'p_offset', 'p_vaddr', 'p_paddr', 'p_filesz', 'p_memsz', 'p_flags', 'p_align']),\n-        ELFCLASS64: (BiStruct('IIQQQQQQ'), ['p_type', 'p_flags', 'p_offset', 'p_vaddr', 'p_paddr', 'p_filesz', 'p_memsz', 'p_align']),\n-    }\n-\n-    def __init__(self, data: bytes, offset: int, eh: ELFHeader) -> None:\n-        super().__init__(data, offset, eh, eh.e_phentsize)\n-\n-    def __repr__(self) -> str:\n-        return f'ProgramHeader(p_type={self.p_type}, p_offset={self.p_offset}, p_vaddr={self.p_vaddr}, p_paddr={self.p_paddr}, p_filesz={self.p_filesz}, p_memsz={self.p_memsz}, p_flags={self.p_flags}, p_align={self.p_align})'\n-\n-class Symbol(ELFRecord):\n-    STRUCT = {\n-        # different ELF classes have the same fields, but in a different order to optimize space versus alignment\n-        ELFCLASS32: (BiStruct('IIIBBH'), ['st_name', 'st_value', 'st_size', 'st_info', 'st_other', 'st_shndx']),\n-        ELFCLASS64: (BiStruct('IBBHQQ'), ['st_name', 'st_info', 'st_other', 'st_shndx', 'st_value', 'st_size']),\n-    }\n-\n-    def __init__(self, data: bytes, offset: int, eh: ELFHeader, symtab: Section, strings: bytes, version: Optional[bytes]) -> None:\n-        super().__init__(data, offset, eh, symtab.sh_entsize)\n-        self.name = _lookup_string(strings, self.st_name)\n-        self.version = version\n-\n-    def __repr__(self) -> str:\n-        return f'Symbol(st_name={self.st_name}({self.name!r}), st_value={self.st_value}, st_size={self.st_size}, st_info={self.st_info}, st_other={self.st_other}, st_shndx={self.st_shndx}, version={self.version!r})'\n-\n-    @property\n-    def is_import(self) -> bool:\n-        '''Returns whether the symbol is an imported symbol.'''\n-        return self.st_bind != STB_LOCAL and self.st_shndx == 0\n-\n-    @property\n-    def is_export(self) -> bool:\n-        '''Returns whether the symbol is an exported symbol.'''\n-        return self.st_bind != STB_LOCAL and self.st_shndx != 0\n-\n-    @property\n-    def st_bind(self) -> int:\n-        '''Returns STB_*.'''\n-        return self.st_info >> 4\n-\n-class Verneed(ELFRecord):\n-    DEF = (BiStruct('HHIII'), ['vn_version', 'vn_cnt', 'vn_file', 'vn_aux', 'vn_next'])\n-    STRUCT = { ELFCLASS32: DEF, ELFCLASS64: DEF }\n-\n-    def __init__(self, data: bytes, offset: int, eh: ELFHeader) -> None:\n-        super().__init__(data, offset, eh, None)\n-\n-    def __repr__(self) -> str:\n-        return f'Verneed(vn_version={self.vn_version}, vn_cnt={self.vn_cnt}, vn_file={self.vn_file}, vn_aux={self.vn_aux}, vn_next={self.vn_next})'\n-\n-class Vernaux(ELFRecord):\n-    DEF = (BiStruct('IHHII'), ['vna_hash', 'vna_flags', 'vna_other', 'vna_name', 'vna_next'])\n-    STRUCT = { ELFCLASS32: DEF, ELFCLASS64: DEF }\n-\n-    def __init__(self, data: bytes, offset: int, eh: ELFHeader, strings: bytes) -> None:\n-        super().__init__(data, offset, eh, None)\n-        self.name = _lookup_string(strings, self.vna_name)\n-\n-    def __repr__(self) -> str:\n-        return f'Veraux(vna_hash={self.vna_hash}, vna_flags={self.vna_flags}, vna_other={self.vna_other}, vna_name={self.vna_name}({self.name!r}), vna_next={self.vna_next})'\n-\n-class DynTag(ELFRecord):\n-    STRUCT = {\n-        ELFCLASS32: (BiStruct('II'), ['d_tag', 'd_val']),\n-        ELFCLASS64: (BiStruct('QQ'), ['d_tag', 'd_val']),\n-    }\n-\n-    def __init__(self, data: bytes, offset: int, eh: ELFHeader, section: Section) -> None:\n-        super().__init__(data, offset, eh, section.sh_entsize)\n-\n-    def __repr__(self) -> str:\n-        return f'DynTag(d_tag={self.d_tag}, d_val={self.d_val})'\n-\n-def _lookup_string(data: bytes, index: int) -> bytes:\n-    '''Look up string by offset in ELF string table.'''\n-    endx = data.find(b'\\x00', index)\n-    assert endx != -1\n-    return data[index:endx]\n-\n-VERSYM_S = BiStruct('H') # .gnu_version section has a single 16-bit integer per symbol in the linked section\n-def _parse_symbol_table(section: Section, strings: bytes, eh: ELFHeader, versym: bytes, verneed: Dict[int, bytes]) -> List[Symbol]:\n-    '''Parse symbol table, return a list of symbols.'''\n-    data = section.contents()\n-    symbols = []\n-    versym_iter = (verneed.get(v[0]) for v in VERSYM_S[eh.ei_data].iter_unpack(versym))\n-    for ofs, version in zip(range(0, len(data), section.sh_entsize), versym_iter):\n-        symbols.append(Symbol(data, ofs, eh, section, strings, version))\n-    return symbols\n-\n-def _parse_verneed(section: Section, strings: bytes, eh: ELFHeader) -> Dict[int, bytes]:\n-    '''Parse .gnu.version_r section, return a dictionary of {versym: 'GLIBC_...'}.'''\n-    data = section.contents()\n-    ofs = 0\n-    result = {}\n-    while True:\n-        verneed = Verneed(data, ofs, eh)\n-        aofs = ofs + verneed.vn_aux\n-        while True:\n-            vernaux = Vernaux(data, aofs, eh, strings)\n-            result[vernaux.vna_other] = vernaux.name\n-            if not vernaux.vna_next:\n-                break\n-            aofs += vernaux.vna_next\n-\n-        if not verneed.vn_next:\n-            break\n-        ofs += verneed.vn_next\n-\n-    return result\n-\n-def _parse_dyn_tags(section: Section, strings: bytes, eh: ELFHeader) -> List[Tuple[int, Union[bytes, int]]]:\n-    '''Parse dynamic tags. Return array of tuples.'''\n-    data = section.contents()\n-    ofs = 0\n-    result = []\n-    for ofs in range(0, len(data), section.sh_entsize):\n-        tag = DynTag(data, ofs, eh, section)\n-        val = _lookup_string(strings, tag.d_val) if tag.d_tag in STRING_TAGS else tag.d_val\n-        result.append((tag.d_tag, val))\n-\n-    return result\n-\n-class ELFFile:\n-    sections: List[Section]\n-    program_headers: List[ProgramHeader]\n-    dyn_symbols: List[Symbol]\n-    dyn_tags: List[Tuple[int, Union[bytes, int]]]\n-\n-    def __init__(self, data: bytes) -> None:\n-        self.data = data\n-        self.hdr = ELFHeader(self.data, 0)\n-        self._load_sections()\n-        self._load_program_headers()\n-        self._load_dyn_symbols()\n-        self._load_dyn_tags()\n-        self._section_to_segment_mapping()\n-\n-    def _load_sections(self) -> None:\n-        self.sections = []\n-        for idx in range(self.hdr.e_shnum):\n-            offset = self.hdr.e_shoff + idx * self.hdr.e_shentsize\n-            self.sections.append(Section(self.data, offset, self.hdr))\n-\n-        shstr = self.sections[self.hdr.e_shstrndx].contents()\n-        for section in self.sections:\n-            section.name = _lookup_string(shstr, section.sh_name)\n-\n-    def _load_program_headers(self) -> None:\n-        self.program_headers = []\n-        for idx in range(self.hdr.e_phnum):\n-            offset = self.hdr.e_phoff + idx * self.hdr.e_phentsize\n-            self.program_headers.append(ProgramHeader(self.data, offset, self.hdr))\n-\n-    def _load_dyn_symbols(self) -> None:\n-        # first, load 'verneed' section\n-        verneed = None\n-        for section in self.sections:\n-            if section.sh_type == SHT_GNU_verneed:\n-                strtab = self.sections[section.sh_link].contents() # associated string table\n-                assert verneed is None # only one section of this kind please\n-                verneed = _parse_verneed(section, strtab, self.hdr)\n-        assert verneed is not None\n-\n-        # then, correlate GNU versym sections with dynamic symbol sections\n-        versym = {}\n-        for section in self.sections:\n-            if section.sh_type == SHT_GNU_versym:\n-                versym[section.sh_link] = section\n-\n-        # finally, load dynsym sections\n-        self.dyn_symbols = []\n-        for idx, section in enumerate(self.sections):\n-            if section.sh_type == SHT_DYNSYM: # find dynamic symbol tables\n-                strtab_data = self.sections[section.sh_link].contents() # associated string table\n-                versym_data = versym[idx].contents() # associated symbol version table\n-                self.dyn_symbols += _parse_symbol_table(section, strtab_data, self.hdr, versym_data, verneed)\n-\n-    def _load_dyn_tags(self) -> None:\n-        self.dyn_tags = []\n-        for idx, section in enumerate(self.sections):\n-            if section.sh_type == SHT_DYNAMIC: # find dynamic tag tables\n-                strtab = self.sections[section.sh_link].contents() # associated string table\n-                self.dyn_tags += _parse_dyn_tags(section, strtab, self.hdr)\n-\n-    def _section_to_segment_mapping(self) -> None:\n-        for ph in self.program_headers:\n-            ph.sections = []\n-            for section in self.sections:\n-                if ph.p_vaddr <= section.sh_addr < (ph.p_vaddr + ph.p_memsz):\n-                    ph.sections.append(section)\n-\n-    def query_dyn_tags(self, tag_in: int) -> List[Union[int, bytes]]:\n-        '''Return the values of all dyn tags with the specified tag.'''\n-        return [val for (tag, val) in self.dyn_tags if tag == tag_in]\n-\n-\n-def load(filename: str) -> ELFFile:\n-    with open(filename, 'rb') as f:\n-        data = f.read()\n-    return ELFFile(data)"
      }
    ]
  }
]