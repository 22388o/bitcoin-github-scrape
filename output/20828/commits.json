[
  {
    "sha": "fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTc1ZDQwZWY4NjZlZjlmZjhkYzExNWUyMzljYTY3NjNhYTIzYjA2",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-02T12:38:14Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-11T09:37:16Z"
      },
      "message": "fuzz: Introduce CallOneOf helper to replace switch-case\n\nCan be reviewed with --ignore-all-space",
      "tree": {
        "sha": "3d96b7ca06ee370ce510ce8ca4e3ce2b4a0c35ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d96b7ca06ee370ce510ce8ca4e3ce2b4a0c35ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgZIwv+P05nxQAi5xMz+drKztTpHpy/1/oyO0paCjnwKEKyxKVHfOrc0O2UkN5y\nqqoOJYI3W/Ijckq2z/FBWWa+o/F11WwZ5H5Lw0xiKj3lWg+X/03FnPrBD9RuThvl\nuUJ752BpVcWMPv9+PLFTn7QNLQeHPGz+xgD5SFk542Bprv1LT+zVvKp2zIY1CsZU\nzEINUa6apVfvnuFX15K4T82nFokVNLHrXKPvuTQ61UxmFtu//yL0bhLt2+3FP3vm\n8mPmhC0e8WgviCG81InpG1WtJni9IXA/FWARRSj0rGDYAxHZg4CEwCRJpHL9atno\nXS8IE+jRui6zeoy+CUZDNEvDTx5vbNoA6bqHOF0D3fxXwgn8GWVk4VwjfriJXoFZ\nJqwmtstO3Z9OffClgcYdrfllPDbcvvbX1UjdMmyJskTgaiSzrqYdJW0fkjV4uJ7c\n8fzvmonwZEGg7DJkXUGi6Li1Zq97hezF/e9PeH/6I3wxgc/JiZdjnO4yQ05rkIE6\n33GcTjet\n=eHb4\n-----END PGP SIGNATURE-----",
        "payload": "tree 3d96b7ca06ee370ce510ce8ca4e3ce2b4a0c35ba\nparent 9c0b76c709c1d197c4097f654de5f4e8dcef4ac6\nauthor MarcoFalke <falke.marco@gmail.com> 1609591094 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1610357836 +0100\n\nfuzz: Introduce CallOneOf helper to replace switch-case\n\nCan be reviewed with --ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c0b76c709c1d197c4097f654de5f4e8dcef4ac6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c0b76c709c1d197c4097f654de5f4e8dcef4ac6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c0b76c709c1d197c4097f654de5f4e8dcef4ac6"
      }
    ],
    "stats": {
      "total": 2308,
      "additions": 1094,
      "deletions": 1214
    },
    "files": [
      {
        "sha": "1ea6b3d01d8bcc9f84dfb8fa57916d8a435bd433",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 75,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -45,83 +45,71 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         }\n     }\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 11)) {\n-        case 0: {\n-            addr_man.Clear();\n-            break;\n-        }\n-        case 1: {\n-            addr_man.ResolveCollisions();\n-            break;\n-        }\n-        case 2: {\n-            (void)addr_man.SelectTriedCollision();\n-            break;\n-        }\n-        case 3: {\n-            (void)addr_man.Select(fuzzed_data_provider.ConsumeBool());\n-            break;\n-        }\n-        case 4: {\n-            (void)addr_man.GetAddr(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-            break;\n-        }\n-        case 5: {\n-            const std::optional<CAddress> opt_address = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n-            const std::optional<CNetAddr> opt_net_addr = ConsumeDeserializable<CNetAddr>(fuzzed_data_provider);\n-            if (opt_address && opt_net_addr) {\n-                addr_man.Add(*opt_address, *opt_net_addr, fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 100000000));\n-            }\n-            break;\n-        }\n-        case 6: {\n-            std::vector<CAddress> addresses;\n-            while (fuzzed_data_provider.ConsumeBool()) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                addr_man.Clear();\n+            },\n+            [&] {\n+                addr_man.ResolveCollisions();\n+            },\n+            [&] {\n+                (void)addr_man.SelectTriedCollision();\n+            },\n+            [&] {\n+                (void)addr_man.Select(fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                (void)addr_man.GetAddr(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+            },\n+            [&] {\n                 const std::optional<CAddress> opt_address = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n-                if (!opt_address) {\n-                    break;\n+                const std::optional<CNetAddr> opt_net_addr = ConsumeDeserializable<CNetAddr>(fuzzed_data_provider);\n+                if (opt_address && opt_net_addr) {\n+                    addr_man.Add(*opt_address, *opt_net_addr, fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 100000000));\n                 }\n-                addresses.push_back(*opt_address);\n-            }\n-            const std::optional<CNetAddr> opt_net_addr = ConsumeDeserializable<CNetAddr>(fuzzed_data_provider);\n-            if (opt_net_addr) {\n-                addr_man.Add(addresses, *opt_net_addr, fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 100000000));\n-            }\n-            break;\n-        }\n-        case 7: {\n-            const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n-            if (opt_service) {\n-                addr_man.Good(*opt_service, fuzzed_data_provider.ConsumeBool(), ConsumeTime(fuzzed_data_provider));\n-            }\n-            break;\n-        }\n-        case 8: {\n-            const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n-            if (opt_service) {\n-                addr_man.Attempt(*opt_service, fuzzed_data_provider.ConsumeBool(), ConsumeTime(fuzzed_data_provider));\n-            }\n-            break;\n-        }\n-        case 9: {\n-            const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n-            if (opt_service) {\n-                addr_man.Connected(*opt_service, ConsumeTime(fuzzed_data_provider));\n-            }\n-            break;\n-        }\n-        case 10: {\n-            const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n-            if (opt_service) {\n-                addr_man.SetServices(*opt_service, ServiceFlags{fuzzed_data_provider.ConsumeIntegral<uint64_t>()});\n-            }\n-            break;\n-        }\n-        case 11: {\n-            (void)addr_man.Check();\n-            break;\n-        }\n-        }\n+            },\n+            [&] {\n+                std::vector<CAddress> addresses;\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    const std::optional<CAddress> opt_address = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n+                    if (!opt_address) {\n+                        break;\n+                    }\n+                    addresses.push_back(*opt_address);\n+                }\n+                const std::optional<CNetAddr> opt_net_addr = ConsumeDeserializable<CNetAddr>(fuzzed_data_provider);\n+                if (opt_net_addr) {\n+                    addr_man.Add(addresses, *opt_net_addr, fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 100000000));\n+                }\n+            },\n+            [&] {\n+                const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n+                if (opt_service) {\n+                    addr_man.Good(*opt_service, fuzzed_data_provider.ConsumeBool(), ConsumeTime(fuzzed_data_provider));\n+                }\n+            },\n+            [&] {\n+                const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n+                if (opt_service) {\n+                    addr_man.Attempt(*opt_service, fuzzed_data_provider.ConsumeBool(), ConsumeTime(fuzzed_data_provider));\n+                }\n+            },\n+            [&] {\n+                const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n+                if (opt_service) {\n+                    addr_man.Connected(*opt_service, ConsumeTime(fuzzed_data_provider));\n+                }\n+            },\n+            [&] {\n+                const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n+                if (opt_service) {\n+                    addr_man.SetServices(*opt_service, ServiceFlags{fuzzed_data_provider.ConsumeIntegral<uint64_t>()});\n+                }\n+            },\n+            [&] {\n+                (void)addr_man.Check();\n+            });\n     }\n     (void)addr_man.size();\n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "9ecd172e19c9a8cdc01ed6f5ea678a4b12598658",
        "filename": "src/test/fuzz/autofile.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 37,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/autofile.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/autofile.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/autofile.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -21,43 +21,37 @@ FUZZ_TARGET(autofile)\n     FuzzedAutoFileProvider fuzzed_auto_file_provider = ConsumeAutoFile(fuzzed_data_provider);\n     CAutoFile auto_file = fuzzed_auto_file_provider.open();\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 5)) {\n-        case 0: {\n-            std::array<uint8_t, 4096> arr{};\n-            try {\n-                auto_file.read((char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-            } catch (const std::ios_base::failure&) {\n-            }\n-            break;\n-        }\n-        case 1: {\n-            const std::array<uint8_t, 4096> arr{};\n-            try {\n-                auto_file.write((const char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-            } catch (const std::ios_base::failure&) {\n-            }\n-            break;\n-        }\n-        case 2: {\n-            try {\n-                auto_file.ignore(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-            } catch (const std::ios_base::failure&) {\n-            }\n-            break;\n-        }\n-        case 3: {\n-            auto_file.fclose();\n-            break;\n-        }\n-        case 4: {\n-            ReadFromStream(fuzzed_data_provider, auto_file);\n-            break;\n-        }\n-        case 5: {\n-            WriteToStream(fuzzed_data_provider, auto_file);\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                std::array<uint8_t, 4096> arr{};\n+                try {\n+                    auto_file.read((char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                } catch (const std::ios_base::failure&) {\n+                }\n+            },\n+            [&] {\n+                const std::array<uint8_t, 4096> arr{};\n+                try {\n+                    auto_file.write((const char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                } catch (const std::ios_base::failure&) {\n+                }\n+            },\n+            [&] {\n+                try {\n+                    auto_file.ignore(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                } catch (const std::ios_base::failure&) {\n+                }\n+            },\n+            [&] {\n+                auto_file.fclose();\n+            },\n+            [&] {\n+                ReadFromStream(fuzzed_data_provider, auto_file);\n+            },\n+            [&] {\n+                WriteToStream(fuzzed_data_provider, auto_file);\n+            });\n     }\n     (void)auto_file.Get();\n     (void)auto_file.GetType();"
      },
      {
        "sha": "e703fa39c1b98f68317775af8e9294067ca8c282",
        "filename": "src/test/fuzz/banman.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 45,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/banman.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -38,51 +38,43 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n     {\n         BanMan ban_man{banlist_file, nullptr, ConsumeBanTimeOffset(fuzzed_data_provider)};\n         while (fuzzed_data_provider.ConsumeBool()) {\n-            switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 11)) {\n-            case 0: {\n-                ban_man.Ban(ConsumeNetAddr(fuzzed_data_provider),\n-                    ConsumeBanTimeOffset(fuzzed_data_provider), fuzzed_data_provider.ConsumeBool());\n-                break;\n-            }\n-            case 1: {\n-                ban_man.Ban(ConsumeSubNet(fuzzed_data_provider),\n-                    ConsumeBanTimeOffset(fuzzed_data_provider), fuzzed_data_provider.ConsumeBool());\n-                break;\n-            }\n-            case 2: {\n-                ban_man.ClearBanned();\n-                break;\n-            }\n-            case 4: {\n-                ban_man.IsBanned(ConsumeNetAddr(fuzzed_data_provider));\n-                break;\n-            }\n-            case 5: {\n-                ban_man.IsBanned(ConsumeSubNet(fuzzed_data_provider));\n-                break;\n-            }\n-            case 6: {\n-                ban_man.Unban(ConsumeNetAddr(fuzzed_data_provider));\n-                break;\n-            }\n-            case 7: {\n-                ban_man.Unban(ConsumeSubNet(fuzzed_data_provider));\n-                break;\n-            }\n-            case 8: {\n-                banmap_t banmap;\n-                ban_man.GetBanned(banmap);\n-                break;\n-            }\n-            case 9: {\n-                ban_man.DumpBanlist();\n-                break;\n-            }\n-            case 11: {\n-                ban_man.Discourage(ConsumeNetAddr(fuzzed_data_provider));\n-                break;\n-            }\n-            }\n+            CallOneOf(\n+                fuzzed_data_provider,\n+                [&] {\n+                    ban_man.Ban(ConsumeNetAddr(fuzzed_data_provider),\n+                                ConsumeBanTimeOffset(fuzzed_data_provider), fuzzed_data_provider.ConsumeBool());\n+                },\n+                [&] {\n+                    ban_man.Ban(ConsumeSubNet(fuzzed_data_provider),\n+                                ConsumeBanTimeOffset(fuzzed_data_provider), fuzzed_data_provider.ConsumeBool());\n+                },\n+                [&] {\n+                    ban_man.ClearBanned();\n+                },\n+                [] {},\n+                [&] {\n+                    ban_man.IsBanned(ConsumeNetAddr(fuzzed_data_provider));\n+                },\n+                [&] {\n+                    ban_man.IsBanned(ConsumeSubNet(fuzzed_data_provider));\n+                },\n+                [&] {\n+                    ban_man.Unban(ConsumeNetAddr(fuzzed_data_provider));\n+                },\n+                [&] {\n+                    ban_man.Unban(ConsumeSubNet(fuzzed_data_provider));\n+                },\n+                [&] {\n+                    banmap_t banmap;\n+                    ban_man.GetBanned(banmap);\n+                },\n+                [&] {\n+                    ban_man.DumpBanlist();\n+                },\n+                [] {},\n+                [&] {\n+                    ban_man.Discourage(ConsumeNetAddr(fuzzed_data_provider));\n+                });\n         }\n     }\n     fs::remove(banlist_file);"
      },
      {
        "sha": "d43c182644bb515de106af71e9e738d4c4a7a02a",
        "filename": "src/test/fuzz/bloom_filter.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 41,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/bloom_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/bloom_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/bloom_filter.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -25,47 +25,43 @@ FUZZ_TARGET(bloom_filter)\n         fuzzed_data_provider.ConsumeIntegral<unsigned int>(),\n         static_cast<unsigned char>(fuzzed_data_provider.PickValueInArray({BLOOM_UPDATE_NONE, BLOOM_UPDATE_ALL, BLOOM_UPDATE_P2PUBKEY_ONLY, BLOOM_UPDATE_MASK}))};\n     while (fuzzed_data_provider.remaining_bytes() > 0) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 3)) {\n-        case 0: {\n-            const std::vector<unsigned char> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-            (void)bloom_filter.contains(b);\n-            bloom_filter.insert(b);\n-            const bool present = bloom_filter.contains(b);\n-            assert(present);\n-            break;\n-        }\n-        case 1: {\n-            const std::optional<COutPoint> out_point = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n-            if (!out_point) {\n-                break;\n-            }\n-            (void)bloom_filter.contains(*out_point);\n-            bloom_filter.insert(*out_point);\n-            const bool present = bloom_filter.contains(*out_point);\n-            assert(present);\n-            break;\n-        }\n-        case 2: {\n-            const std::optional<uint256> u256 = ConsumeDeserializable<uint256>(fuzzed_data_provider);\n-            if (!u256) {\n-                break;\n-            }\n-            (void)bloom_filter.contains(*u256);\n-            bloom_filter.insert(*u256);\n-            const bool present = bloom_filter.contains(*u256);\n-            assert(present);\n-            break;\n-        }\n-        case 3: {\n-            const std::optional<CMutableTransaction> mut_tx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n-            if (!mut_tx) {\n-                break;\n-            }\n-            const CTransaction tx{*mut_tx};\n-            (void)bloom_filter.IsRelevantAndUpdate(tx);\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+                (void)bloom_filter.contains(b);\n+                bloom_filter.insert(b);\n+                const bool present = bloom_filter.contains(b);\n+                assert(present);\n+            },\n+            [&] {\n+                const std::optional<COutPoint> out_point = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!out_point) {\n+                    return;\n+                }\n+                (void)bloom_filter.contains(*out_point);\n+                bloom_filter.insert(*out_point);\n+                const bool present = bloom_filter.contains(*out_point);\n+                assert(present);\n+            },\n+            [&] {\n+                const std::optional<uint256> u256 = ConsumeDeserializable<uint256>(fuzzed_data_provider);\n+                if (!u256) {\n+                    return;\n+                }\n+                (void)bloom_filter.contains(*u256);\n+                bloom_filter.insert(*u256);\n+                const bool present = bloom_filter.contains(*u256);\n+                assert(present);\n+            },\n+            [&] {\n+                const std::optional<CMutableTransaction> mut_tx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+                if (!mut_tx) {\n+                    return;\n+                }\n+                const CTransaction tx{*mut_tx};\n+                (void)bloom_filter.IsRelevantAndUpdate(tx);\n+            });\n         (void)bloom_filter.IsWithinSizeConstraints();\n     }\n }"
      },
      {
        "sha": "3a1b2dbbe71b422e39f005a8486bc6475b145286",
        "filename": "src/test/fuzz/buffered_file.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 35,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/buffered_file.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/buffered_file.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/buffered_file.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -31,41 +31,36 @@ FUZZ_TARGET(buffered_file)\n     if (opt_buffered_file && fuzzed_file != nullptr) {\n         bool setpos_fail = false;\n         while (fuzzed_data_provider.ConsumeBool()) {\n-            switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 4)) {\n-            case 0: {\n-                std::array<uint8_t, 4096> arr{};\n-                try {\n-                    opt_buffered_file->read((char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-                } catch (const std::ios_base::failure&) {\n-                }\n-                break;\n-            }\n-            case 1: {\n-                opt_buffered_file->SetLimit(fuzzed_data_provider.ConsumeIntegralInRange<uint64_t>(0, 4096));\n-                break;\n-            }\n-            case 2: {\n-                if (!opt_buffered_file->SetPos(fuzzed_data_provider.ConsumeIntegralInRange<uint64_t>(0, 4096))) {\n-                    setpos_fail = true;\n-                }\n-                break;\n-            }\n-            case 3: {\n-                if (setpos_fail) {\n-                    // Calling FindByte(...) after a failed SetPos(...) call may result in an infinite loop.\n-                    break;\n-                }\n-                try {\n-                    opt_buffered_file->FindByte(fuzzed_data_provider.ConsumeIntegral<char>());\n-                } catch (const std::ios_base::failure&) {\n-                }\n-                break;\n-            }\n-            case 4: {\n-                ReadFromStream(fuzzed_data_provider, *opt_buffered_file);\n-                break;\n-            }\n-            }\n+            CallOneOf(\n+                fuzzed_data_provider,\n+                [&] {\n+                    std::array<uint8_t, 4096> arr{};\n+                    try {\n+                        opt_buffered_file->read((char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                    } catch (const std::ios_base::failure&) {\n+                    }\n+                },\n+                [&] {\n+                    opt_buffered_file->SetLimit(fuzzed_data_provider.ConsumeIntegralInRange<uint64_t>(0, 4096));\n+                },\n+                [&] {\n+                    if (!opt_buffered_file->SetPos(fuzzed_data_provider.ConsumeIntegralInRange<uint64_t>(0, 4096))) {\n+                        setpos_fail = true;\n+                    }\n+                },\n+                [&] {\n+                    if (setpos_fail) {\n+                        // Calling FindByte(...) after a failed SetPos(...) call may result in an infinite loop.\n+                        return;\n+                    }\n+                    try {\n+                        opt_buffered_file->FindByte(fuzzed_data_provider.ConsumeIntegral<char>());\n+                    } catch (const std::ios_base::failure&) {\n+                    }\n+                },\n+                [&] {\n+                    ReadFromStream(fuzzed_data_provider, *opt_buffered_file);\n+                });\n         }\n         opt_buffered_file->GetPos();\n         opt_buffered_file->GetType();"
      },
      {
        "sha": "12ef4b203fd9365f4f3704591c6f963cd1595d55",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 162,
        "deletions": 179,
        "changes": 341,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -50,103 +50,93 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n     Coin random_coin;\n     CMutableTransaction random_mutable_transaction;\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 9)) {\n-        case 0: {\n-            if (random_coin.IsSpent()) {\n-                break;\n-            }\n-            Coin coin = random_coin;\n-            bool expected_code_path = false;\n-            const bool possible_overwrite = fuzzed_data_provider.ConsumeBool();\n-            try {\n-                coins_view_cache.AddCoin(random_out_point, std::move(coin), possible_overwrite);\n-                expected_code_path = true;\n-            } catch (const std::logic_error& e) {\n-                if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n-                    assert(!possible_overwrite);\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                if (random_coin.IsSpent()) {\n+                    return;\n+                }\n+                Coin coin = random_coin;\n+                bool expected_code_path = false;\n+                const bool possible_overwrite = fuzzed_data_provider.ConsumeBool();\n+                try {\n+                    coins_view_cache.AddCoin(random_out_point, std::move(coin), possible_overwrite);\n                     expected_code_path = true;\n+                } catch (const std::logic_error& e) {\n+                    if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n+                        assert(!possible_overwrite);\n+                        expected_code_path = true;\n+                    }\n                 }\n-            }\n-            assert(expected_code_path);\n-            break;\n-        }\n-        case 1: {\n-            (void)coins_view_cache.Flush();\n-            break;\n-        }\n-        case 2: {\n-            coins_view_cache.SetBestBlock(ConsumeUInt256(fuzzed_data_provider));\n-            break;\n-        }\n-        case 3: {\n-            Coin move_to;\n-            (void)coins_view_cache.SpendCoin(random_out_point, fuzzed_data_provider.ConsumeBool() ? &move_to : nullptr);\n-            break;\n-        }\n-        case 4: {\n-            coins_view_cache.Uncache(random_out_point);\n-            break;\n-        }\n-        case 5: {\n-            if (fuzzed_data_provider.ConsumeBool()) {\n-                backend_coins_view = CCoinsView{};\n-            }\n-            coins_view_cache.SetBackend(backend_coins_view);\n-            break;\n-        }\n-        case 6: {\n-            const std::optional<COutPoint> opt_out_point = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n-            if (!opt_out_point) {\n-                break;\n-            }\n-            random_out_point = *opt_out_point;\n-            break;\n-        }\n-        case 7: {\n-            const std::optional<Coin> opt_coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n-            if (!opt_coin) {\n-                break;\n-            }\n-            random_coin = *opt_coin;\n-            break;\n-        }\n-        case 8: {\n-            const std::optional<CMutableTransaction> opt_mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n-            if (!opt_mutable_transaction) {\n-                break;\n-            }\n-            random_mutable_transaction = *opt_mutable_transaction;\n-            break;\n-        }\n-        case 9: {\n-            CCoinsMap coins_map;\n-            while (fuzzed_data_provider.ConsumeBool()) {\n-                CCoinsCacheEntry coins_cache_entry;\n-                coins_cache_entry.flags = fuzzed_data_provider.ConsumeIntegral<unsigned char>();\n+                assert(expected_code_path);\n+            },\n+            [&] {\n+                (void)coins_view_cache.Flush();\n+            },\n+            [&] {\n+                coins_view_cache.SetBestBlock(ConsumeUInt256(fuzzed_data_provider));\n+            },\n+            [&] {\n+                Coin move_to;\n+                (void)coins_view_cache.SpendCoin(random_out_point, fuzzed_data_provider.ConsumeBool() ? &move_to : nullptr);\n+            },\n+            [&] {\n+                coins_view_cache.Uncache(random_out_point);\n+            },\n+            [&] {\n                 if (fuzzed_data_provider.ConsumeBool()) {\n-                    coins_cache_entry.coin = random_coin;\n-                } else {\n-                    const std::optional<Coin> opt_coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n-                    if (!opt_coin) {\n-                        break;\n+                    backend_coins_view = CCoinsView{};\n+                }\n+                coins_view_cache.SetBackend(backend_coins_view);\n+            },\n+            [&] {\n+                const std::optional<COutPoint> opt_out_point = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!opt_out_point) {\n+                    return;\n+                }\n+                random_out_point = *opt_out_point;\n+            },\n+            [&] {\n+                const std::optional<Coin> opt_coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!opt_coin) {\n+                    return;\n+                }\n+                random_coin = *opt_coin;\n+            },\n+            [&] {\n+                const std::optional<CMutableTransaction> opt_mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+                if (!opt_mutable_transaction) {\n+                    return;\n+                }\n+                random_mutable_transaction = *opt_mutable_transaction;\n+            },\n+            [&] {\n+                CCoinsMap coins_map;\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    CCoinsCacheEntry coins_cache_entry;\n+                    coins_cache_entry.flags = fuzzed_data_provider.ConsumeIntegral<unsigned char>();\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        coins_cache_entry.coin = random_coin;\n+                    } else {\n+                        const std::optional<Coin> opt_coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                        if (!opt_coin) {\n+                            return;\n+                        }\n+                        coins_cache_entry.coin = *opt_coin;\n                     }\n-                    coins_cache_entry.coin = *opt_coin;\n+                    coins_map.emplace(random_out_point, std::move(coins_cache_entry));\n                 }\n-                coins_map.emplace(random_out_point, std::move(coins_cache_entry));\n-            }\n-            bool expected_code_path = false;\n-            try {\n-                coins_view_cache.BatchWrite(coins_map, fuzzed_data_provider.ConsumeBool() ? ConsumeUInt256(fuzzed_data_provider) : coins_view_cache.GetBestBlock());\n-                expected_code_path = true;\n-            } catch (const std::logic_error& e) {\n-                if (e.what() == std::string{\"FRESH flag misapplied to coin that exists in parent cache\"}) {\n+                bool expected_code_path = false;\n+                try {\n+                    coins_view_cache.BatchWrite(coins_map, fuzzed_data_provider.ConsumeBool() ? ConsumeUInt256(fuzzed_data_provider) : coins_view_cache.GetBestBlock());\n                     expected_code_path = true;\n+                } catch (const std::logic_error& e) {\n+                    if (e.what() == std::string{\"FRESH flag misapplied to coin that exists in parent cache\"}) {\n+                        expected_code_path = true;\n+                    }\n                 }\n-            }\n-            assert(expected_code_path);\n-            break;\n-        }\n-        }\n+                assert(expected_code_path);\n+            });\n     }\n \n     {\n@@ -199,97 +189,90 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n     }\n \n     if (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 6)) {\n-        case 0: {\n-            const CTransaction transaction{random_mutable_transaction};\n-            bool is_spent = false;\n-            for (const CTxOut& tx_out : transaction.vout) {\n-                if (Coin{tx_out, 0, transaction.IsCoinBase()}.IsSpent()) {\n-                    is_spent = true;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const CTransaction transaction{random_mutable_transaction};\n+                bool is_spent = false;\n+                for (const CTxOut& tx_out : transaction.vout) {\n+                    if (Coin{tx_out, 0, transaction.IsCoinBase()}.IsSpent()) {\n+                        is_spent = true;\n+                    }\n+                }\n+                if (is_spent) {\n+                    // Avoid:\n+                    // coins.cpp:69: void CCoinsViewCache::AddCoin(const COutPoint &, Coin &&, bool): Assertion `!coin.IsSpent()' failed.\n+                    return;\n                 }\n-            }\n-            if (is_spent) {\n-                // Avoid:\n-                // coins.cpp:69: void CCoinsViewCache::AddCoin(const COutPoint &, Coin &&, bool): Assertion `!coin.IsSpent()' failed.\n-                break;\n-            }\n-            bool expected_code_path = false;\n-            const int height = fuzzed_data_provider.ConsumeIntegral<int>();\n-            const bool possible_overwrite = fuzzed_data_provider.ConsumeBool();\n-            try {\n-                AddCoins(coins_view_cache, transaction, height, possible_overwrite);\n-                expected_code_path = true;\n-            } catch (const std::logic_error& e) {\n-                if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n-                    assert(!possible_overwrite);\n+                bool expected_code_path = false;\n+                const int height = fuzzed_data_provider.ConsumeIntegral<int>();\n+                const bool possible_overwrite = fuzzed_data_provider.ConsumeBool();\n+                try {\n+                    AddCoins(coins_view_cache, transaction, height, possible_overwrite);\n                     expected_code_path = true;\n+                } catch (const std::logic_error& e) {\n+                    if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n+                        assert(!possible_overwrite);\n+                        expected_code_path = true;\n+                    }\n                 }\n-            }\n-            assert(expected_code_path);\n-            break;\n-        }\n-        case 1: {\n-            (void)AreInputsStandard(CTransaction{random_mutable_transaction}, coins_view_cache, false);\n-            (void)AreInputsStandard(CTransaction{random_mutable_transaction}, coins_view_cache, true);\n-            break;\n-        }\n-        case 2: {\n-            TxValidationState state;\n-            CAmount tx_fee_out;\n-            const CTransaction transaction{random_mutable_transaction};\n-            if (ContainsSpentInput(transaction, coins_view_cache)) {\n-                // Avoid:\n-                // consensus/tx_verify.cpp:171: bool Consensus::CheckTxInputs(const CTransaction &, TxValidationState &, const CCoinsViewCache &, int, CAmount &): Assertion `!coin.IsSpent()' failed.\n-                break;\n-            }\n-            try {\n-                (void)Consensus::CheckTxInputs(transaction, state, coins_view_cache, fuzzed_data_provider.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max()), tx_fee_out);\n-                assert(MoneyRange(tx_fee_out));\n-            } catch (const std::runtime_error&) {\n-            }\n-            break;\n-        }\n-        case 3: {\n-            const CTransaction transaction{random_mutable_transaction};\n-            if (ContainsSpentInput(transaction, coins_view_cache)) {\n-                // Avoid:\n-                // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n-                break;\n-            }\n-            (void)GetP2SHSigOpCount(transaction, coins_view_cache);\n-            break;\n-        }\n-        case 4: {\n-            const CTransaction transaction{random_mutable_transaction};\n-            if (ContainsSpentInput(transaction, coins_view_cache)) {\n-                // Avoid:\n-                // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n-                break;\n-            }\n-            const int flags = fuzzed_data_provider.ConsumeIntegral<int>();\n-            if (!transaction.vin.empty() && (flags & SCRIPT_VERIFY_WITNESS) != 0 && (flags & SCRIPT_VERIFY_P2SH) == 0) {\n-                // Avoid:\n-                // script/interpreter.cpp:1705: size_t CountWitnessSigOps(const CScript &, const CScript &, const CScriptWitness *, unsigned int): Assertion `(flags & SCRIPT_VERIFY_P2SH) != 0' failed.\n-                break;\n-            }\n-            (void)GetTransactionSigOpCost(transaction, coins_view_cache, flags);\n-            break;\n-        }\n-        case 5: {\n-            CCoinsStats stats;\n-            bool expected_code_path = false;\n-            try {\n-                (void)GetUTXOStats(&coins_view_cache, stats, CoinStatsHashType::HASH_SERIALIZED);\n-            } catch (const std::logic_error&) {\n-                expected_code_path = true;\n-            }\n-            assert(expected_code_path);\n-            break;\n-        }\n-        case 6: {\n-            (void)IsWitnessStandard(CTransaction{random_mutable_transaction}, coins_view_cache);\n-            break;\n-        }\n-        }\n+                assert(expected_code_path);\n+            },\n+            [&] {\n+                (void)AreInputsStandard(CTransaction{random_mutable_transaction}, coins_view_cache, false);\n+                (void)AreInputsStandard(CTransaction{random_mutable_transaction}, coins_view_cache, true);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                CAmount tx_fee_out;\n+                const CTransaction transaction{random_mutable_transaction};\n+                if (ContainsSpentInput(transaction, coins_view_cache)) {\n+                    // Avoid:\n+                    // consensus/tx_verify.cpp:171: bool Consensus::CheckTxInputs(const CTransaction &, TxValidationState &, const CCoinsViewCache &, int, CAmount &): Assertion `!coin.IsSpent()' failed.\n+                    return;\n+                }\n+                try {\n+                    (void)Consensus::CheckTxInputs(transaction, state, coins_view_cache, fuzzed_data_provider.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max()), tx_fee_out);\n+                    assert(MoneyRange(tx_fee_out));\n+                } catch (const std::runtime_error&) {\n+                }\n+            },\n+            [&] {\n+                const CTransaction transaction{random_mutable_transaction};\n+                if (ContainsSpentInput(transaction, coins_view_cache)) {\n+                    // Avoid:\n+                    // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n+                    return;\n+                }\n+                (void)GetP2SHSigOpCount(transaction, coins_view_cache);\n+            },\n+            [&] {\n+                const CTransaction transaction{random_mutable_transaction};\n+                if (ContainsSpentInput(transaction, coins_view_cache)) {\n+                    // Avoid:\n+                    // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n+                    return;\n+                }\n+                const int flags = fuzzed_data_provider.ConsumeIntegral<int>();\n+                if (!transaction.vin.empty() && (flags & SCRIPT_VERIFY_WITNESS) != 0 && (flags & SCRIPT_VERIFY_P2SH) == 0) {\n+                    // Avoid:\n+                    // script/interpreter.cpp:1705: size_t CountWitnessSigOps(const CScript &, const CScript &, const CScriptWitness *, unsigned int): Assertion `(flags & SCRIPT_VERIFY_P2SH) != 0' failed.\n+                    return;\n+                }\n+                (void)GetTransactionSigOpCost(transaction, coins_view_cache, flags);\n+            },\n+            [&] {\n+                CCoinsStats stats;\n+                bool expected_code_path = false;\n+                try {\n+                    (void)GetUTXOStats(&coins_view_cache, stats, CoinStatsHashType::HASH_SERIALIZED);\n+                } catch (const std::logic_error&) {\n+                    expected_code_path = true;\n+                }\n+                assert(expected_code_path);\n+            },\n+            [&] {\n+                (void)IsWitnessStandard(CTransaction{random_mutable_transaction}, coins_view_cache);\n+            });\n     }\n }"
      },
      {
        "sha": "7950213bd5e007c3050cd795d02bdc38b113aa1e",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 98,
        "deletions": 102,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -32,108 +32,104 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n     CSubNet random_subnet;\n     std::string random_string;\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 27)) {\n-        case 0:\n-            random_address = ConsumeAddress(fuzzed_data_provider);\n-            break;\n-        case 1:\n-            random_netaddr = ConsumeNetAddr(fuzzed_data_provider);\n-            break;\n-        case 2:\n-            random_service = ConsumeService(fuzzed_data_provider);\n-            break;\n-        case 3:\n-            random_subnet = ConsumeSubNet(fuzzed_data_provider);\n-            break;\n-        case 4:\n-            random_string = fuzzed_data_provider.ConsumeRandomLengthString(64);\n-            break;\n-        case 5: {\n-            std::vector<CAddress> addresses;\n-            while (fuzzed_data_provider.ConsumeBool()) {\n-                addresses.push_back(ConsumeAddress(fuzzed_data_provider));\n-            }\n-            // Limit nTimePenalty to int32_t to avoid signed integer overflow\n-            (void)connman.AddNewAddresses(addresses, ConsumeAddress(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int32_t>());\n-            break;\n-        }\n-        case 6:\n-            connman.AddNode(random_string);\n-            break;\n-        case 7:\n-            connman.CheckIncomingNonce(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n-            break;\n-        case 8:\n-            connman.DisconnectNode(fuzzed_data_provider.ConsumeIntegral<NodeId>());\n-            break;\n-        case 9:\n-            connman.DisconnectNode(random_netaddr);\n-            break;\n-        case 10:\n-            connman.DisconnectNode(random_string);\n-            break;\n-        case 11:\n-            connman.DisconnectNode(random_subnet);\n-            break;\n-        case 12:\n-            connman.ForEachNode([](auto) {});\n-            break;\n-        case 13:\n-            connman.ForEachNodeThen([](auto) {}, []() {});\n-            break;\n-        case 14:\n-            (void)connman.ForNode(fuzzed_data_provider.ConsumeIntegral<NodeId>(), [&](auto) { return fuzzed_data_provider.ConsumeBool(); });\n-            break;\n-        case 15:\n-            (void)connman.GetAddresses(fuzzed_data_provider.ConsumeIntegral<size_t>(), fuzzed_data_provider.ConsumeIntegral<size_t>());\n-            break;\n-        case 16: {\n-            (void)connman.GetAddresses(random_node, fuzzed_data_provider.ConsumeIntegral<size_t>(), fuzzed_data_provider.ConsumeIntegral<size_t>());\n-            break;\n-        }\n-        case 17:\n-            (void)connman.GetDeterministicRandomizer(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n-            break;\n-        case 18:\n-            (void)connman.GetNodeCount(fuzzed_data_provider.PickValueInArray({CConnman::CONNECTIONS_NONE, CConnman::CONNECTIONS_IN, CConnman::CONNECTIONS_OUT, CConnman::CONNECTIONS_ALL}));\n-            break;\n-        case 19:\n-            connman.MarkAddressGood(random_address);\n-            break;\n-        case 20:\n-            (void)connman.OutboundTargetReached(fuzzed_data_provider.ConsumeBool());\n-            break;\n-        case 21:\n-            // Limit now to int32_t to avoid signed integer overflow\n-            (void)connman.PoissonNextSendInbound(fuzzed_data_provider.ConsumeIntegral<int32_t>(), fuzzed_data_provider.ConsumeIntegral<int>());\n-            break;\n-        case 22: {\n-            CSerializedNetMsg serialized_net_msg;\n-            serialized_net_msg.m_type = fuzzed_data_provider.ConsumeRandomLengthString(CMessageHeader::COMMAND_SIZE);\n-            serialized_net_msg.data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-            connman.PushMessage(&random_node, std::move(serialized_net_msg));\n-            break;\n-        }\n-        case 23:\n-            connman.RemoveAddedNode(random_string);\n-            break;\n-        case 24: {\n-            const std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-            if (SanityCheckASMap(asmap)) {\n-                connman.SetAsmap(asmap);\n-            }\n-            break;\n-        }\n-        case 25:\n-            connman.SetNetworkActive(fuzzed_data_provider.ConsumeBool());\n-            break;\n-        case 26:\n-            connman.SetServices(random_service, ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS));\n-            break;\n-        case 27:\n-            connman.SetTryNewOutboundPeer(fuzzed_data_provider.ConsumeBool());\n-            break;\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                random_address = ConsumeAddress(fuzzed_data_provider);\n+            },\n+            [&] {\n+                random_netaddr = ConsumeNetAddr(fuzzed_data_provider);\n+            },\n+            [&] {\n+                random_service = ConsumeService(fuzzed_data_provider);\n+            },\n+            [&] {\n+                random_subnet = ConsumeSubNet(fuzzed_data_provider);\n+            },\n+            [&] {\n+                random_string = fuzzed_data_provider.ConsumeRandomLengthString(64);\n+            },\n+            [&] {\n+                std::vector<CAddress> addresses;\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    addresses.push_back(ConsumeAddress(fuzzed_data_provider));\n+                }\n+                // Limit nTimePenalty to int32_t to avoid signed integer overflow\n+                (void)connman.AddNewAddresses(addresses, ConsumeAddress(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int32_t>());\n+            },\n+            [&] {\n+                connman.AddNode(random_string);\n+            },\n+            [&] {\n+                connman.CheckIncomingNonce(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+            },\n+            [&] {\n+                connman.DisconnectNode(fuzzed_data_provider.ConsumeIntegral<NodeId>());\n+            },\n+            [&] {\n+                connman.DisconnectNode(random_netaddr);\n+            },\n+            [&] {\n+                connman.DisconnectNode(random_string);\n+            },\n+            [&] {\n+                connman.DisconnectNode(random_subnet);\n+            },\n+            [&] {\n+                connman.ForEachNode([](auto) {});\n+            },\n+            [&] {\n+                connman.ForEachNodeThen([](auto) {}, []() {});\n+            },\n+            [&] {\n+                (void)connman.ForNode(fuzzed_data_provider.ConsumeIntegral<NodeId>(), [&](auto) { return fuzzed_data_provider.ConsumeBool(); });\n+            },\n+            [&] {\n+                (void)connman.GetAddresses(fuzzed_data_provider.ConsumeIntegral<size_t>(), fuzzed_data_provider.ConsumeIntegral<size_t>());\n+            },\n+            [&] {\n+                (void)connman.GetAddresses(random_node, fuzzed_data_provider.ConsumeIntegral<size_t>(), fuzzed_data_provider.ConsumeIntegral<size_t>());\n+            },\n+            [&] {\n+                (void)connman.GetDeterministicRandomizer(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+            },\n+            [&] {\n+                (void)connman.GetNodeCount(fuzzed_data_provider.PickValueInArray({CConnman::CONNECTIONS_NONE, CConnman::CONNECTIONS_IN, CConnman::CONNECTIONS_OUT, CConnman::CONNECTIONS_ALL}));\n+            },\n+            [&] {\n+                connman.MarkAddressGood(random_address);\n+            },\n+            [&] {\n+                (void)connman.OutboundTargetReached(fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                // Limit now to int32_t to avoid signed integer overflow\n+                (void)connman.PoissonNextSendInbound(fuzzed_data_provider.ConsumeIntegral<int32_t>(), fuzzed_data_provider.ConsumeIntegral<int>());\n+            },\n+            [&] {\n+                CSerializedNetMsg serialized_net_msg;\n+                serialized_net_msg.m_type = fuzzed_data_provider.ConsumeRandomLengthString(CMessageHeader::COMMAND_SIZE);\n+                serialized_net_msg.data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+                connman.PushMessage(&random_node, std::move(serialized_net_msg));\n+            },\n+            [&] {\n+                connman.RemoveAddedNode(random_string);\n+            },\n+            [&] {\n+                const std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n+                if (SanityCheckASMap(asmap)) {\n+                    connman.SetAsmap(asmap);\n+                }\n+            },\n+            [&] {\n+                connman.SetNetworkActive(fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                connman.SetServices(random_service, ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS));\n+            },\n+            [&] {\n+                connman.SetTryNewOutboundPeer(fuzzed_data_provider.ConsumeBool());\n+            });\n     }\n     (void)connman.GetAddedNodeInfo();\n     (void)connman.GetExtraFullOutboundCount();"
      },
      {
        "sha": "c2bb3a1a4ea0afb48f4b383df171e6c94651ce3d",
        "filename": "src/test/fuzz/crypto.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 99,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/crypto.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/crypto.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -39,109 +39,95 @@ FUZZ_TARGET(crypto)\n     MuHash3072 muhash;\n \n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 2)) {\n-        case 0: {\n-            if (fuzzed_data_provider.ConsumeBool()) {\n-                data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-                if (data.empty()) {\n-                    data.resize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 4096), fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+                    if (data.empty()) {\n+                        data.resize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 4096), fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+                    }\n                 }\n-            }\n \n-            (void)hash160.Write(data);\n-            (void)hash256.Write(data);\n-            (void)hmac_sha256.Write(data.data(), data.size());\n-            (void)hmac_sha512.Write(data.data(), data.size());\n-            (void)ripemd160.Write(data.data(), data.size());\n-            (void)sha1.Write(data.data(), data.size());\n-            (void)sha256.Write(data.data(), data.size());\n-            (void)sha3.Write(data);\n-            (void)sha512.Write(data.data(), data.size());\n-            (void)sip_hasher.Write(data.data(), data.size());\n+                (void)hash160.Write(data);\n+                (void)hash256.Write(data);\n+                (void)hmac_sha256.Write(data.data(), data.size());\n+                (void)hmac_sha512.Write(data.data(), data.size());\n+                (void)ripemd160.Write(data.data(), data.size());\n+                (void)sha1.Write(data.data(), data.size());\n+                (void)sha256.Write(data.data(), data.size());\n+                (void)sha3.Write(data);\n+                (void)sha512.Write(data.data(), data.size());\n+                (void)sip_hasher.Write(data.data(), data.size());\n \n-            (void)Hash(data);\n-            (void)Hash160(data);\n-            (void)sha512.Size();\n+                (void)Hash(data);\n+                (void)Hash160(data);\n+                (void)sha512.Size();\n \n-            if (fuzzed_data_provider.ConsumeBool()) {\n-                muhash *= MuHash3072(data);\n-            } else {\n-                muhash /= MuHash3072(data);\n-            }\n-            break;\n-        }\n-        case 1: {\n-            (void)hash160.Reset();\n-            (void)hash256.Reset();\n-            (void)ripemd160.Reset();\n-            (void)sha1.Reset();\n-            (void)sha256.Reset();\n-            (void)sha3.Reset();\n-            (void)sha512.Reset();\n-            muhash = MuHash3072();\n-            break;\n-        }\n-        case 2: {\n-            switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 10)) {\n-            case 0: {\n-                data.resize(CHash160::OUTPUT_SIZE);\n-                hash160.Finalize(data);\n-                break;\n-            }\n-            case 1: {\n-                data.resize(CHash256::OUTPUT_SIZE);\n-                hash256.Finalize(data);\n-                break;\n-            }\n-            case 2: {\n-                data.resize(CHMAC_SHA256::OUTPUT_SIZE);\n-                hmac_sha256.Finalize(data.data());\n-                break;\n-            }\n-            case 3: {\n-                data.resize(CHMAC_SHA512::OUTPUT_SIZE);\n-                hmac_sha512.Finalize(data.data());\n-                break;\n-            }\n-            case 4: {\n-                data.resize(CRIPEMD160::OUTPUT_SIZE);\n-                ripemd160.Finalize(data.data());\n-                break;\n-            }\n-            case 5: {\n-                data.resize(CSHA1::OUTPUT_SIZE);\n-                sha1.Finalize(data.data());\n-                break;\n-            }\n-            case 6: {\n-                data.resize(CSHA256::OUTPUT_SIZE);\n-                sha256.Finalize(data.data());\n-                break;\n-            }\n-            case 7: {\n-                data.resize(CSHA512::OUTPUT_SIZE);\n-                sha512.Finalize(data.data());\n-                break;\n-            }\n-            case 8: {\n-                data.resize(1);\n-                data[0] = sip_hasher.Finalize() % 256;\n-                break;\n-            }\n-            case 9: {\n-                data.resize(SHA3_256::OUTPUT_SIZE);\n-                sha3.Finalize(data);\n-                break;\n-            }\n-            case 10: {\n-                uint256 out;\n-                muhash.Finalize(out);\n-                break;\n-            }\n-            }\n-            break;\n-        }\n-        }\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    muhash *= MuHash3072(data);\n+                } else {\n+                    muhash /= MuHash3072(data);\n+                }\n+            },\n+            [&] {\n+                (void)hash160.Reset();\n+                (void)hash256.Reset();\n+                (void)ripemd160.Reset();\n+                (void)sha1.Reset();\n+                (void)sha256.Reset();\n+                (void)sha3.Reset();\n+                (void)sha512.Reset();\n+                muhash = MuHash3072();\n+            },\n+            [&] {\n+                CallOneOf(\n+                    fuzzed_data_provider,\n+                    [&] {\n+                        data.resize(CHash160::OUTPUT_SIZE);\n+                        hash160.Finalize(data);\n+                    },\n+                    [&] {\n+                        data.resize(CHash256::OUTPUT_SIZE);\n+                        hash256.Finalize(data);\n+                    },\n+                    [&] {\n+                        data.resize(CHMAC_SHA256::OUTPUT_SIZE);\n+                        hmac_sha256.Finalize(data.data());\n+                    },\n+                    [&] {\n+                        data.resize(CHMAC_SHA512::OUTPUT_SIZE);\n+                        hmac_sha512.Finalize(data.data());\n+                    },\n+                    [&] {\n+                        data.resize(CRIPEMD160::OUTPUT_SIZE);\n+                        ripemd160.Finalize(data.data());\n+                    },\n+                    [&] {\n+                        data.resize(CSHA1::OUTPUT_SIZE);\n+                        sha1.Finalize(data.data());\n+                    },\n+                    [&] {\n+                        data.resize(CSHA256::OUTPUT_SIZE);\n+                        sha256.Finalize(data.data());\n+                    },\n+                    [&] {\n+                        data.resize(CSHA512::OUTPUT_SIZE);\n+                        sha512.Finalize(data.data());\n+                    },\n+                    [&] {\n+                        data.resize(1);\n+                        data[0] = sip_hasher.Finalize() % 256;\n+                    },\n+                    [&] {\n+                        data.resize(SHA3_256::OUTPUT_SIZE);\n+                        sha3.Finalize(data);\n+                    },\n+                    [&] {\n+                        uint256 out;\n+                        muhash.Finalize(out);\n+                    });\n+            });\n     }\n     if (fuzzed_data_provider.ConsumeBool()) {\n         uint64_t state[25];"
      },
      {
        "sha": "bb8dd4594ff9c5b8fb612376c3b35e73584fa32c",
        "filename": "src/test/fuzz/crypto_chacha20.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 26,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/crypto_chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/crypto_chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto_chacha20.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -20,31 +20,26 @@ FUZZ_TARGET(crypto_chacha20)\n         chacha20 = ChaCha20{key.data(), key.size()};\n     }\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 4)) {\n-        case 0: {\n-            const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n-            chacha20.SetKey(key.data(), key.size());\n-            break;\n-        }\n-        case 1: {\n-            chacha20.SetIV(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n-            break;\n-        }\n-        case 2: {\n-            chacha20.Seek(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n-            break;\n-        }\n-        case 3: {\n-            std::vector<uint8_t> output(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-            chacha20.Keystream(output.data(), output.size());\n-            break;\n-        }\n-        case 4: {\n-            std::vector<uint8_t> output(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n-            const std::vector<uint8_t> input = ConsumeFixedLengthByteVector(fuzzed_data_provider, output.size());\n-            chacha20.Crypt(input.data(), output.data(), input.size());\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+            },\n+            [&] {\n+                chacha20.SetIV(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+            },\n+            [&] {\n+                chacha20.Seek(fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+            },\n+            [&] {\n+                std::vector<uint8_t> output(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                chacha20.Keystream(output.data(), output.size());\n+            },\n+            [&] {\n+                std::vector<uint8_t> output(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                const std::vector<uint8_t> input = ConsumeFixedLengthByteVector(fuzzed_data_provider, output.size());\n+                chacha20.Crypt(input.data(), output.data(), input.size());\n+            });\n     }\n }"
      },
      {
        "sha": "1f122082b21d7aa47adf8c9c1e8b264e0f538e75",
        "filename": "src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 39,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -29,44 +29,37 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n     std::vector<uint8_t> out(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     bool is_encrypt = fuzzed_data_provider.ConsumeBool();\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 6)) {\n-        case 0: {\n-            buffer_size = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(64, 4096);\n-            in = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-            out = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-            break;\n-        }\n-        case 1: {\n-            (void)aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n-            break;\n-        }\n-        case 2: {\n-            uint32_t len = 0;\n-            const bool ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n-            assert(ok);\n-            break;\n-        }\n-        case 3: {\n-            seqnr_payload += 1;\n-            aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-            if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-                aad_pos = 0;\n-                seqnr_aad += 1;\n-            }\n-            break;\n-        }\n-        case 4: {\n-            seqnr_payload = fuzzed_data_provider.ConsumeIntegral<int>();\n-            break;\n-        }\n-        case 5: {\n-            seqnr_aad = fuzzed_data_provider.ConsumeIntegral<int>();\n-            break;\n-        }\n-        case 6: {\n-            is_encrypt = fuzzed_data_provider.ConsumeBool();\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                buffer_size = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(64, 4096);\n+                in = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n+                out = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n+            },\n+            [&] {\n+                (void)aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n+            },\n+            [&] {\n+                uint32_t len = 0;\n+                const bool ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n+                assert(ok);\n+            },\n+            [&] {\n+                seqnr_payload += 1;\n+                aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n+                if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n+                    aad_pos = 0;\n+                    seqnr_aad += 1;\n+                }\n+            },\n+            [&] {\n+                seqnr_payload = fuzzed_data_provider.ConsumeIntegral<int>();\n+            },\n+            [&] {\n+                seqnr_aad = fuzzed_data_provider.ConsumeIntegral<int>();\n+            },\n+            [&] {\n+                is_encrypt = fuzzed_data_provider.ConsumeBool();\n+            });\n     }\n }"
      },
      {
        "sha": "23e0baa56458c4c090663b7c976837bdb596e514",
        "filename": "src/test/fuzz/merkleblock.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 25,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/merkleblock.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -17,33 +17,31 @@ FUZZ_TARGET(merkleblock)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     CPartialMerkleTree partial_merkle_tree;\n-    switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 1)) {\n-    case 0: {\n-        const std::optional<CPartialMerkleTree> opt_partial_merkle_tree = ConsumeDeserializable<CPartialMerkleTree>(fuzzed_data_provider);\n-        if (opt_partial_merkle_tree) {\n-            partial_merkle_tree = *opt_partial_merkle_tree;\n-        }\n-        break;\n-    }\n-    case 1: {\n-        CMerkleBlock merkle_block;\n-        const std::optional<CBlock> opt_block = ConsumeDeserializable<CBlock>(fuzzed_data_provider);\n-        CBloomFilter bloom_filter;\n-        std::set<uint256> txids;\n-        if (opt_block && !opt_block->vtx.empty()) {\n-            if (fuzzed_data_provider.ConsumeBool()) {\n-                merkle_block = CMerkleBlock{*opt_block, bloom_filter};\n-            } else if (fuzzed_data_provider.ConsumeBool()) {\n-                while (fuzzed_data_provider.ConsumeBool()) {\n-                    txids.insert(ConsumeUInt256(fuzzed_data_provider));\n+    CallOneOf(\n+        fuzzed_data_provider,\n+        [&] {\n+            const std::optional<CPartialMerkleTree> opt_partial_merkle_tree = ConsumeDeserializable<CPartialMerkleTree>(fuzzed_data_provider);\n+            if (opt_partial_merkle_tree) {\n+                partial_merkle_tree = *opt_partial_merkle_tree;\n+            }\n+        },\n+        [&] {\n+            CMerkleBlock merkle_block;\n+            const std::optional<CBlock> opt_block = ConsumeDeserializable<CBlock>(fuzzed_data_provider);\n+            CBloomFilter bloom_filter;\n+            std::set<uint256> txids;\n+            if (opt_block && !opt_block->vtx.empty()) {\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    merkle_block = CMerkleBlock{*opt_block, bloom_filter};\n+                } else if (fuzzed_data_provider.ConsumeBool()) {\n+                    while (fuzzed_data_provider.ConsumeBool()) {\n+                        txids.insert(ConsumeUInt256(fuzzed_data_provider));\n+                    }\n+                    merkle_block = CMerkleBlock{*opt_block, txids};\n                 }\n-                merkle_block = CMerkleBlock{*opt_block, txids};\n             }\n-        }\n-        partial_merkle_tree = merkle_block.txn;\n-        break;\n-    }\n-    }\n+            partial_merkle_tree = merkle_block.txn;\n+        });\n     (void)partial_merkle_tree.GetNumTransactions();\n     std::vector<uint256> matches;\n     std::vector<unsigned int> indices;"
      },
      {
        "sha": "31b99600efc7c496ed026f5e70ff144ca0471d3b",
        "filename": "src/test/fuzz/net.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 79,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/net.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -32,85 +32,74 @@ FUZZ_TARGET_INIT(net, initialize_net)\n     CNode node{ConsumeNode(fuzzed_data_provider)};\n     node.SetCommonVersion(fuzzed_data_provider.ConsumeIntegral<int>());\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 10)) {\n-        case 0: {\n-            node.CloseSocketDisconnect();\n-            break;\n-        }\n-        case 1: {\n-            node.MaybeSetAddrName(fuzzed_data_provider.ConsumeRandomLengthString(32));\n-            break;\n-        }\n-        case 2: {\n-            const std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-            if (!SanityCheckASMap(asmap)) {\n-                break;\n-            }\n-            CNodeStats stats;\n-            node.copyStats(stats, asmap);\n-            break;\n-        }\n-        case 3: {\n-            const CNode* add_ref_node = node.AddRef();\n-            assert(add_ref_node == &node);\n-            break;\n-        }\n-        case 4: {\n-            if (node.GetRefCount() > 0) {\n-                node.Release();\n-            }\n-            break;\n-        }\n-        case 5: {\n-            if (node.m_addr_known == nullptr) {\n-                break;\n-            }\n-            const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n-            if (!addr_opt) {\n-                break;\n-            }\n-            node.AddAddressKnown(*addr_opt);\n-            break;\n-        }\n-        case 6: {\n-            if (node.m_addr_known == nullptr) {\n-                break;\n-            }\n-            const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n-            if (!addr_opt) {\n-                break;\n-            }\n-            FastRandomContext fast_random_context{ConsumeUInt256(fuzzed_data_provider)};\n-            node.PushAddress(*addr_opt, fast_random_context);\n-            break;\n-        }\n-        case 7: {\n-            const std::optional<CInv> inv_opt = ConsumeDeserializable<CInv>(fuzzed_data_provider);\n-            if (!inv_opt) {\n-                break;\n-            }\n-            node.AddKnownTx(inv_opt->hash);\n-            break;\n-        }\n-        case 8: {\n-            node.PushTxInventory(ConsumeUInt256(fuzzed_data_provider));\n-            break;\n-        }\n-        case 9: {\n-            const std::optional<CService> service_opt = ConsumeDeserializable<CService>(fuzzed_data_provider);\n-            if (!service_opt) {\n-                break;\n-            }\n-            node.SetAddrLocal(*service_opt);\n-            break;\n-        }\n-        case 10: {\n-            const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-            bool complete;\n-            node.ReceiveMsgBytes(b, complete);\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node.CloseSocketDisconnect();\n+            },\n+            [&] {\n+                node.MaybeSetAddrName(fuzzed_data_provider.ConsumeRandomLengthString(32));\n+            },\n+            [&] {\n+                const std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n+                if (!SanityCheckASMap(asmap)) {\n+                    return;\n+                }\n+                CNodeStats stats;\n+                node.copyStats(stats, asmap);\n+            },\n+            [&] {\n+                const CNode* add_ref_node = node.AddRef();\n+                assert(add_ref_node == &node);\n+            },\n+            [&] {\n+                if (node.GetRefCount() > 0) {\n+                    node.Release();\n+                }\n+            },\n+            [&] {\n+                if (node.m_addr_known == nullptr) {\n+                    return;\n+                }\n+                const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n+                if (!addr_opt) {\n+                    return;\n+                }\n+                node.AddAddressKnown(*addr_opt);\n+            },\n+            [&] {\n+                if (node.m_addr_known == nullptr) {\n+                    return;\n+                }\n+                const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n+                if (!addr_opt) {\n+                    return;\n+                }\n+                FastRandomContext fast_random_context{ConsumeUInt256(fuzzed_data_provider)};\n+                node.PushAddress(*addr_opt, fast_random_context);\n+            },\n+            [&] {\n+                const std::optional<CInv> inv_opt = ConsumeDeserializable<CInv>(fuzzed_data_provider);\n+                if (!inv_opt) {\n+                    return;\n+                }\n+                node.AddKnownTx(inv_opt->hash);\n+            },\n+            [&] {\n+                node.PushTxInventory(ConsumeUInt256(fuzzed_data_provider));\n+            },\n+            [&] {\n+                const std::optional<CService> service_opt = ConsumeDeserializable<CService>(fuzzed_data_provider);\n+                if (!service_opt) {\n+                    return;\n+                }\n+                node.SetAddrLocal(*service_opt);\n+            },\n+            [&] {\n+                const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+                bool complete;\n+                node.ReceiveMsgBytes(b, complete);\n+            });\n     }\n \n     (void)node.GetAddrLocal();"
      },
      {
        "sha": "409acfee106d1990c957dfdc5edfc0662a96a7dc",
        "filename": "src/test/fuzz/policy_estimator.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 36,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/policy_estimator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/policy_estimator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/policy_estimator.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -24,46 +24,42 @@ FUZZ_TARGET_INIT(policy_estimator, initialize_policy_estimator)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     CBlockPolicyEstimator block_policy_estimator;\n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 3)) {\n-        case 0: {\n-            const std::optional<CMutableTransaction> mtx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n-            if (!mtx) {\n-                break;\n-            }\n-            const CTransaction tx{*mtx};\n-            block_policy_estimator.processTransaction(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx), fuzzed_data_provider.ConsumeBool());\n-            if (fuzzed_data_provider.ConsumeBool()) {\n-                (void)block_policy_estimator.removeTx(tx.GetHash(), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n-            }\n-            break;\n-        }\n-        case 1: {\n-            std::vector<CTxMemPoolEntry> mempool_entries;\n-            while (fuzzed_data_provider.ConsumeBool()) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n                 const std::optional<CMutableTransaction> mtx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n                 if (!mtx) {\n-                    break;\n+                    return;\n                 }\n                 const CTransaction tx{*mtx};\n-                mempool_entries.push_back(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx));\n-            }\n-            std::vector<const CTxMemPoolEntry*> ptrs;\n-            ptrs.reserve(mempool_entries.size());\n-            for (const CTxMemPoolEntry& mempool_entry : mempool_entries) {\n-                ptrs.push_back(&mempool_entry);\n-            }\n-            block_policy_estimator.processBlock(fuzzed_data_provider.ConsumeIntegral<unsigned int>(), ptrs);\n-            break;\n-        }\n-        case 2: {\n-            (void)block_policy_estimator.removeTx(ConsumeUInt256(fuzzed_data_provider), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n-            break;\n-        }\n-        case 3: {\n-            block_policy_estimator.FlushUnconfirmed();\n-            break;\n-        }\n-        }\n+                block_policy_estimator.processTransaction(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx), fuzzed_data_provider.ConsumeBool());\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    (void)block_policy_estimator.removeTx(tx.GetHash(), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n+                }\n+            },\n+            [&] {\n+                std::vector<CTxMemPoolEntry> mempool_entries;\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    const std::optional<CMutableTransaction> mtx = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+                    if (!mtx) {\n+                        break;\n+                    }\n+                    const CTransaction tx{*mtx};\n+                    mempool_entries.push_back(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx));\n+                }\n+                std::vector<const CTxMemPoolEntry*> ptrs;\n+                ptrs.reserve(mempool_entries.size());\n+                for (const CTxMemPoolEntry& mempool_entry : mempool_entries) {\n+                    ptrs.push_back(&mempool_entry);\n+                }\n+                block_policy_estimator.processBlock(fuzzed_data_provider.ConsumeIntegral<unsigned int>(), ptrs);\n+            },\n+            [&] {\n+                (void)block_policy_estimator.removeTx(ConsumeUInt256(fuzzed_data_provider), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                block_policy_estimator.FlushUnconfirmed();\n+            });\n         (void)block_policy_estimator.estimateFee(fuzzed_data_provider.ConsumeIntegral<int>());\n         EstimationResult result;\n         (void)block_policy_estimator.estimateRawFee(fuzzed_data_provider.ConsumeIntegral<int>(), fuzzed_data_provider.ConsumeFloatingPoint<double>(), fuzzed_data_provider.PickValueInArray({FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}), fuzzed_data_provider.ConsumeBool() ? &result : nullptr);"
      },
      {
        "sha": "2a08b45aa3244028e500643beaf62bc4b8e3ecca",
        "filename": "src/test/fuzz/rolling_bloom_filter.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 24,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/rolling_bloom_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/rolling_bloom_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/rolling_bloom_filter.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -22,29 +22,27 @@ FUZZ_TARGET(rolling_bloom_filter)\n         fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(1, 1000),\n         0.999 / fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(1, std::numeric_limits<unsigned int>::max())};\n     while (fuzzed_data_provider.remaining_bytes() > 0) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 2)) {\n-        case 0: {\n-            const std::vector<unsigned char> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-            (void)rolling_bloom_filter.contains(b);\n-            rolling_bloom_filter.insert(b);\n-            const bool present = rolling_bloom_filter.contains(b);\n-            assert(present);\n-            break;\n-        }\n-        case 1: {\n-            const std::optional<uint256> u256 = ConsumeDeserializable<uint256>(fuzzed_data_provider);\n-            if (!u256) {\n-                break;\n-            }\n-            (void)rolling_bloom_filter.contains(*u256);\n-            rolling_bloom_filter.insert(*u256);\n-            const bool present = rolling_bloom_filter.contains(*u256);\n-            assert(present);\n-            break;\n-        }\n-        case 2:\n-            rolling_bloom_filter.reset();\n-            break;\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+                (void)rolling_bloom_filter.contains(b);\n+                rolling_bloom_filter.insert(b);\n+                const bool present = rolling_bloom_filter.contains(b);\n+                assert(present);\n+            },\n+            [&] {\n+                const std::optional<uint256> u256 = ConsumeDeserializable<uint256>(fuzzed_data_provider);\n+                if (!u256) {\n+                    return;\n+                }\n+                (void)rolling_bloom_filter.contains(*u256);\n+                rolling_bloom_filter.insert(*u256);\n+                const bool present = rolling_bloom_filter.contains(*u256);\n+                assert(present);\n+            },\n+            [&] {\n+                rolling_bloom_filter.reset();\n+            });\n     }\n }"
      },
      {
        "sha": "bdbfe817ff486d5cfc21b26fee17cede7925f5f5",
        "filename": "src/test/fuzz/script_ops.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 51,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/script_ops.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/script_ops.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_ops.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -16,56 +16,53 @@ FUZZ_TARGET(script_ops)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     CScript script = ConsumeScript(fuzzed_data_provider);\n     while (fuzzed_data_provider.remaining_bytes() > 0) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 7)) {\n-        case 0: {\n-            CScript s = ConsumeScript(fuzzed_data_provider);\n-            script = std::move(s);\n-            break;\n-        }\n-        case 1: {\n-            const CScript& s = ConsumeScript(fuzzed_data_provider);\n-            script = s;\n-            break;\n-        }\n-        case 2:\n-            script << fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            break;\n-        case 3:\n-            script << ConsumeOpcodeType(fuzzed_data_provider);\n-            break;\n-        case 4:\n-            script << ConsumeScriptNum(fuzzed_data_provider);\n-            break;\n-        case 5:\n-            script << ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-            break;\n-        case 6:\n-            script.clear();\n-            break;\n-        case 7: {\n-            (void)script.GetSigOpCount(false);\n-            (void)script.GetSigOpCount(true);\n-            (void)script.GetSigOpCount(script);\n-            (void)script.HasValidOps();\n-            (void)script.IsPayToScriptHash();\n-            (void)script.IsPayToWitnessScriptHash();\n-            (void)script.IsPushOnly();\n-            (void)script.IsUnspendable();\n-            {\n-                CScript::const_iterator pc = script.begin();\n-                opcodetype opcode;\n-                (void)script.GetOp(pc, opcode);\n-                std::vector<uint8_t> data;\n-                (void)script.GetOp(pc, opcode, data);\n-                (void)script.IsPushOnly(pc);\n-            }\n-            {\n-                int version;\n-                std::vector<uint8_t> program;\n-                (void)script.IsWitnessProgram(version, program);\n-            }\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                CScript s = ConsumeScript(fuzzed_data_provider);\n+                script = std::move(s);\n+            },\n+            [&] {\n+                const CScript& s = ConsumeScript(fuzzed_data_provider);\n+                script = s;\n+            },\n+            [&] {\n+                script << fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+            },\n+            [&] {\n+                script << ConsumeOpcodeType(fuzzed_data_provider);\n+            },\n+            [&] {\n+                script << ConsumeScriptNum(fuzzed_data_provider);\n+            },\n+            [&] {\n+                script << ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+            },\n+            [&] {\n+                script.clear();\n+            },\n+            [&] {\n+                (void)script.GetSigOpCount(false);\n+                (void)script.GetSigOpCount(true);\n+                (void)script.GetSigOpCount(script);\n+                (void)script.HasValidOps();\n+                (void)script.IsPayToScriptHash();\n+                (void)script.IsPayToWitnessScriptHash();\n+                (void)script.IsPushOnly();\n+                (void)script.IsUnspendable();\n+                {\n+                    CScript::const_iterator pc = script.begin();\n+                    opcodetype opcode;\n+                    (void)script.GetOp(pc, opcode);\n+                    std::vector<uint8_t> data;\n+                    (void)script.GetOp(pc, opcode, data);\n+                    (void)script.IsPushOnly(pc);\n+                }\n+                {\n+                    int version;\n+                    std::vector<uint8_t> program;\n+                    (void)script.IsWitnessProgram(version, program);\n+                }\n+            });\n     }\n }"
      },
      {
        "sha": "bc4867839c05f6f17ac4a25bc278415aa97d71ab",
        "filename": "src/test/fuzz/scriptnum_ops.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 99,
        "changes": 192,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/scriptnum_ops.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/scriptnum_ops.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/scriptnum_ops.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -29,105 +29,99 @@ FUZZ_TARGET(scriptnum_ops)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     CScriptNum script_num = ConsumeScriptNum(fuzzed_data_provider);\n     while (fuzzed_data_provider.remaining_bytes() > 0) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 11)) {\n-        case 0: {\n-            const int64_t i = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            assert((script_num == i) != (script_num != i));\n-            assert((script_num <= i) != (script_num > i));\n-            assert((script_num >= i) != (script_num < i));\n-            // Avoid signed integer overflow:\n-            // script/script.h:264:93: runtime error: signed integer overflow: -2261405121394637306 + -9223372036854775802 cannot be represented in type 'long'\n-            if (IsValidAddition(script_num, CScriptNum{i})) {\n-                assert((script_num + i) - i == script_num);\n-            }\n-            // Avoid signed integer overflow:\n-            // script/script.h:265:93: runtime error: signed integer overflow: 9223371895120855039 - -9223372036854710486 cannot be represented in type 'long'\n-            if (IsValidSubtraction(script_num, CScriptNum{i})) {\n-                assert((script_num - i) + i == script_num);\n-            }\n-            break;\n-        }\n-        case 1: {\n-            const CScriptNum random_script_num = ConsumeScriptNum(fuzzed_data_provider);\n-            assert((script_num == random_script_num) != (script_num != random_script_num));\n-            assert((script_num <= random_script_num) != (script_num > random_script_num));\n-            assert((script_num >= random_script_num) != (script_num < random_script_num));\n-            // Avoid signed integer overflow:\n-            // script/script.h:264:93: runtime error: signed integer overflow: -9223126527765971126 + -9223372036854756825 cannot be represented in type 'long'\n-            if (IsValidAddition(script_num, random_script_num)) {\n-                assert((script_num + random_script_num) - random_script_num == script_num);\n-            }\n-            // Avoid signed integer overflow:\n-            // script/script.h:265:93: runtime error: signed integer overflow: 6052837899185946624 - -9223372036854775808 cannot be represented in type 'long'\n-            if (IsValidSubtraction(script_num, random_script_num)) {\n-                assert((script_num - random_script_num) + random_script_num == script_num);\n-            }\n-            break;\n-        }\n-        case 2: {\n-            const CScriptNum random_script_num = ConsumeScriptNum(fuzzed_data_provider);\n-            if (!IsValidAddition(script_num, random_script_num)) {\n-                // Avoid assertion failure:\n-                // ./script/script.h:292: CScriptNum &CScriptNum::operator+=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) || (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs)' failed.\n-                break;\n-            }\n-            script_num += random_script_num;\n-            break;\n-        }\n-        case 3: {\n-            const CScriptNum random_script_num = ConsumeScriptNum(fuzzed_data_provider);\n-            if (!IsValidSubtraction(script_num, random_script_num)) {\n-                // Avoid assertion failure:\n-                // ./script/script.h:300: CScriptNum &CScriptNum::operator-=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) || (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs)' failed.\n-                break;\n-            }\n-            script_num -= random_script_num;\n-            break;\n-        }\n-        case 4:\n-            script_num = script_num & fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            break;\n-        case 5:\n-            script_num = script_num & ConsumeScriptNum(fuzzed_data_provider);\n-            break;\n-        case 6:\n-            script_num &= ConsumeScriptNum(fuzzed_data_provider);\n-            break;\n-        case 7:\n-            if (script_num == CScriptNum{std::numeric_limits<int64_t>::min()}) {\n-                // Avoid assertion failure:\n-                // ./script/script.h:279: CScriptNum CScriptNum::operator-() const: Assertion `m_value != std::numeric_limits<int64_t>::min()' failed.\n-                break;\n-            }\n-            script_num = -script_num;\n-            break;\n-        case 8:\n-            script_num = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            break;\n-        case 9: {\n-            const int64_t random_integer = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            if (!IsValidAddition(script_num, CScriptNum{random_integer})) {\n-                // Avoid assertion failure:\n-                // ./script/script.h:292: CScriptNum &CScriptNum::operator+=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) || (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs)' failed.\n-                break;\n-            }\n-            script_num += random_integer;\n-            break;\n-        }\n-        case 10: {\n-            const int64_t random_integer = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            if (!IsValidSubtraction(script_num, CScriptNum{random_integer})) {\n-                // Avoid assertion failure:\n-                // ./script/script.h:300: CScriptNum &CScriptNum::operator-=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) || (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs)' failed.\n-                break;\n-            }\n-            script_num -= random_integer;\n-            break;\n-        }\n-        case 11:\n-            script_num &= fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-            break;\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const int64_t i = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+                assert((script_num == i) != (script_num != i));\n+                assert((script_num <= i) != (script_num > i));\n+                assert((script_num >= i) != (script_num < i));\n+                // Avoid signed integer overflow:\n+                // script/script.h:264:93: runtime error: signed integer overflow: -2261405121394637306 + -9223372036854775802 cannot be represented in type 'long'\n+                if (IsValidAddition(script_num, CScriptNum{i})) {\n+                    assert((script_num + i) - i == script_num);\n+                }\n+                // Avoid signed integer overflow:\n+                // script/script.h:265:93: runtime error: signed integer overflow: 9223371895120855039 - -9223372036854710486 cannot be represented in type 'long'\n+                if (IsValidSubtraction(script_num, CScriptNum{i})) {\n+                    assert((script_num - i) + i == script_num);\n+                }\n+            },\n+            [&] {\n+                const CScriptNum random_script_num = ConsumeScriptNum(fuzzed_data_provider);\n+                assert((script_num == random_script_num) != (script_num != random_script_num));\n+                assert((script_num <= random_script_num) != (script_num > random_script_num));\n+                assert((script_num >= random_script_num) != (script_num < random_script_num));\n+                // Avoid signed integer overflow:\n+                // script/script.h:264:93: runtime error: signed integer overflow: -9223126527765971126 + -9223372036854756825 cannot be represented in type 'long'\n+                if (IsValidAddition(script_num, random_script_num)) {\n+                    assert((script_num + random_script_num) - random_script_num == script_num);\n+                }\n+                // Avoid signed integer overflow:\n+                // script/script.h:265:93: runtime error: signed integer overflow: 6052837899185946624 - -9223372036854775808 cannot be represented in type 'long'\n+                if (IsValidSubtraction(script_num, random_script_num)) {\n+                    assert((script_num - random_script_num) + random_script_num == script_num);\n+                }\n+            },\n+            [&] {\n+                const CScriptNum random_script_num = ConsumeScriptNum(fuzzed_data_provider);\n+                if (!IsValidAddition(script_num, random_script_num)) {\n+                    // Avoid assertion failure:\n+                    // ./script/script.h:292: CScriptNum &CScriptNum::operator+=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) || (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs)' failed.\n+                    return;\n+                }\n+                script_num += random_script_num;\n+            },\n+            [&] {\n+                const CScriptNum random_script_num = ConsumeScriptNum(fuzzed_data_provider);\n+                if (!IsValidSubtraction(script_num, random_script_num)) {\n+                    // Avoid assertion failure:\n+                    // ./script/script.h:300: CScriptNum &CScriptNum::operator-=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) || (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs)' failed.\n+                    return;\n+                }\n+                script_num -= random_script_num;\n+            },\n+            [&] {\n+                script_num = script_num & fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+            },\n+            [&] {\n+                script_num = script_num & ConsumeScriptNum(fuzzed_data_provider);\n+            },\n+            [&] {\n+                script_num &= ConsumeScriptNum(fuzzed_data_provider);\n+            },\n+            [&] {\n+                if (script_num == CScriptNum{std::numeric_limits<int64_t>::min()}) {\n+                    // Avoid assertion failure:\n+                    // ./script/script.h:279: CScriptNum CScriptNum::operator-() const: Assertion `m_value != std::numeric_limits<int64_t>::min()' failed.\n+                    return;\n+                }\n+                script_num = -script_num;\n+            },\n+            [&] {\n+                script_num = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+            },\n+            [&] {\n+                const int64_t random_integer = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+                if (!IsValidAddition(script_num, CScriptNum{random_integer})) {\n+                    // Avoid assertion failure:\n+                    // ./script/script.h:292: CScriptNum &CScriptNum::operator+=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) || (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs)' failed.\n+                    return;\n+                }\n+                script_num += random_integer;\n+            },\n+            [&] {\n+                const int64_t random_integer = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+                if (!IsValidSubtraction(script_num, CScriptNum{random_integer})) {\n+                    // Avoid assertion failure:\n+                    // ./script/script.h:300: CScriptNum &CScriptNum::operator-=(const int64_t &): Assertion `rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) || (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs)' failed.\n+                    return;\n+                }\n+                script_num -= random_integer;\n+            },\n+            [&] {\n+                script_num &= fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+            });\n         (void)script_num.getint();\n         (void)script_num.getvch();\n     }"
      },
      {
        "sha": "b66a7abfb3179a27b70cfdd564140a95e76dc549",
        "filename": "src/test/fuzz/strprintf.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 60,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/strprintf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/strprintf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/strprintf.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n #include <tinyformat.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n@@ -109,32 +110,32 @@ FUZZ_TARGET(str_printf)\n     }\n \n     try {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 5)) {\n-        case 0:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeRandomLengthString(32));\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeRandomLengthString(32));\n-            break;\n-        case 1:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeRandomLengthString(32).c_str());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeRandomLengthString(32).c_str());\n-            break;\n-        case 2:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<signed char>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<signed char>());\n-            break;\n-        case 3:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<unsigned char>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<unsigned char>());\n-            break;\n-        case 4:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<char>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<char>());\n-            break;\n-        case 5:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeBool());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeBool());\n-            break;\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeRandomLengthString(32));\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeRandomLengthString(32));\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeRandomLengthString(32).c_str());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeRandomLengthString(32).c_str());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<signed char>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<signed char>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<unsigned char>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<unsigned char>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<char>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<char>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeBool());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeBool());\n+            });\n     } catch (const tinyformat::format_error&) {\n     }\n \n@@ -155,40 +156,40 @@ FUZZ_TARGET(str_printf)\n     }\n \n     try {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange(0, 7)) {\n-        case 0:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeFloatingPoint<float>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeFloatingPoint<float>());\n-            break;\n-        case 1:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeFloatingPoint<double>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeFloatingPoint<double>());\n-            break;\n-        case 2:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<int16_t>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<int16_t>());\n-            break;\n-        case 3:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<uint16_t>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<uint16_t>());\n-            break;\n-        case 4:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<int32_t>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<int32_t>());\n-            break;\n-        case 5:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<uint32_t>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<uint32_t>());\n-            break;\n-        case 6:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<int64_t>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<int64_t>());\n-            break;\n-        case 7:\n-            (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n-            (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n-            break;\n-        }\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeFloatingPoint<float>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeFloatingPoint<float>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeFloatingPoint<double>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeFloatingPoint<double>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<int16_t>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<int16_t>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<uint16_t>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<uint16_t>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<int32_t>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<int32_t>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<uint32_t>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<uint32_t>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<int64_t>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<int64_t>());\n+            },\n+            [&] {\n+                (void)strprintf(format_string, fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+                (void)tinyformat::format(bilingual_string, fuzzed_data_provider.ConsumeIntegral<uint64_t>());\n+            });\n     } catch (const tinyformat::format_error&) {\n     }\n }"
      },
      {
        "sha": "47b38b6d23dc649d99d1282fd044b874bac7231d",
        "filename": "src/test/fuzz/system.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 63,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/system.cpp?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -32,71 +32,63 @@ FUZZ_TARGET(system)\n     }\n \n     while (fuzzed_data_provider.ConsumeBool()) {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 7)) {\n-        case 0: {\n-            args_manager.SelectConfigNetwork(fuzzed_data_provider.ConsumeRandomLengthString(16));\n-            break;\n-        }\n-        case 1: {\n-            args_manager.SoftSetArg(fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeRandomLengthString(16));\n-            break;\n-        }\n-        case 2: {\n-            args_manager.ForceSetArg(fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeRandomLengthString(16));\n-            break;\n-        }\n-        case 3: {\n-            args_manager.SoftSetBoolArg(fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeBool());\n-            break;\n-        }\n-        case 4: {\n-            const OptionsCategory options_category = fuzzed_data_provider.PickValueInArray<OptionsCategory>({OptionsCategory::OPTIONS, OptionsCategory::CONNECTION, OptionsCategory::WALLET, OptionsCategory::WALLET_DEBUG_TEST, OptionsCategory::ZMQ, OptionsCategory::DEBUG_TEST, OptionsCategory::CHAINPARAMS, OptionsCategory::NODE_RELAY, OptionsCategory::BLOCK_CREATION, OptionsCategory::RPC, OptionsCategory::GUI, OptionsCategory::COMMANDS, OptionsCategory::REGISTER_COMMANDS, OptionsCategory::HIDDEN});\n-            // Avoid hitting:\n-            // util/system.cpp:425: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\n-            const std::string argument_name = GetArgumentName(fuzzed_data_provider.ConsumeRandomLengthString(16));\n-            if (args_manager.GetArgFlags(argument_name) != nullopt) {\n-                break;\n-            }\n-            args_manager.AddArg(argument_name, fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeIntegral<unsigned int>(), options_category);\n-            break;\n-        }\n-        case 5: {\n-            // Avoid hitting:\n-            // util/system.cpp:425: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\n-            const std::vector<std::string> names = ConsumeRandomLengthStringVector(fuzzed_data_provider);\n-            std::vector<std::string> hidden_arguments;\n-            for (const std::string& name : names) {\n-                const std::string hidden_argument = GetArgumentName(name);\n-                if (args_manager.GetArgFlags(hidden_argument) != nullopt) {\n-                    continue;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                args_manager.SelectConfigNetwork(fuzzed_data_provider.ConsumeRandomLengthString(16));\n+            },\n+            [&] {\n+                args_manager.SoftSetArg(fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeRandomLengthString(16));\n+            },\n+            [&] {\n+                args_manager.ForceSetArg(fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeRandomLengthString(16));\n+            },\n+            [&] {\n+                args_manager.SoftSetBoolArg(fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const OptionsCategory options_category = fuzzed_data_provider.PickValueInArray<OptionsCategory>({OptionsCategory::OPTIONS, OptionsCategory::CONNECTION, OptionsCategory::WALLET, OptionsCategory::WALLET_DEBUG_TEST, OptionsCategory::ZMQ, OptionsCategory::DEBUG_TEST, OptionsCategory::CHAINPARAMS, OptionsCategory::NODE_RELAY, OptionsCategory::BLOCK_CREATION, OptionsCategory::RPC, OptionsCategory::GUI, OptionsCategory::COMMANDS, OptionsCategory::REGISTER_COMMANDS, OptionsCategory::HIDDEN});\n+                // Avoid hitting:\n+                // util/system.cpp:425: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\n+                const std::string argument_name = GetArgumentName(fuzzed_data_provider.ConsumeRandomLengthString(16));\n+                if (args_manager.GetArgFlags(argument_name) != nullopt) {\n+                    return;\n                 }\n-                if (std::find(hidden_arguments.begin(), hidden_arguments.end(), hidden_argument) != hidden_arguments.end()) {\n-                    continue;\n+                args_manager.AddArg(argument_name, fuzzed_data_provider.ConsumeRandomLengthString(16), fuzzed_data_provider.ConsumeIntegral<unsigned int>(), options_category);\n+            },\n+            [&] {\n+                // Avoid hitting:\n+                // util/system.cpp:425: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\n+                const std::vector<std::string> names = ConsumeRandomLengthStringVector(fuzzed_data_provider);\n+                std::vector<std::string> hidden_arguments;\n+                for (const std::string& name : names) {\n+                    const std::string hidden_argument = GetArgumentName(name);\n+                    if (args_manager.GetArgFlags(hidden_argument) != nullopt) {\n+                        continue;\n+                    }\n+                    if (std::find(hidden_arguments.begin(), hidden_arguments.end(), hidden_argument) != hidden_arguments.end()) {\n+                        continue;\n+                    }\n+                    hidden_arguments.push_back(hidden_argument);\n                 }\n-                hidden_arguments.push_back(hidden_argument);\n-            }\n-            args_manager.AddHiddenArgs(hidden_arguments);\n-            break;\n-        }\n-        case 6: {\n-            args_manager.ClearArgs();\n-            break;\n-        }\n-        case 7: {\n-            const std::vector<std::string> random_arguments = ConsumeRandomLengthStringVector(fuzzed_data_provider);\n-            std::vector<const char*> argv;\n-            argv.reserve(random_arguments.size());\n-            for (const std::string& random_argument : random_arguments) {\n-                argv.push_back(random_argument.c_str());\n-            }\n-            try {\n-                std::string error;\n-                (void)args_manager.ParseParameters(argv.size(), argv.data(), error);\n-            } catch (const std::logic_error&) {\n-            }\n-            break;\n-        }\n-        }\n+                args_manager.AddHiddenArgs(hidden_arguments);\n+            },\n+            [&] {\n+                args_manager.ClearArgs();\n+            },\n+            [&] {\n+                const std::vector<std::string> random_arguments = ConsumeRandomLengthStringVector(fuzzed_data_provider);\n+                std::vector<const char*> argv;\n+                argv.reserve(random_arguments.size());\n+                for (const std::string& random_argument : random_arguments) {\n+                    argv.push_back(random_argument.c_str());\n+                }\n+                try {\n+                    std::string error;\n+                    (void)args_manager.ParseParameters(argv.size(), argv.data(), error);\n+                } catch (const std::logic_error&) {\n+                }\n+            });\n     }\n \n     const std::string s1 = fuzzed_data_provider.ConsumeRandomLengthString(16);"
      },
      {
        "sha": "b7cf395e7686537a8a573d219dd5d88a79efbb3d",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 96,
        "deletions": 99,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa75d40ef866ef9ff8dc115e239ca6763aa23b06/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=fa75d40ef866ef9ff8dc115e239ca6763aa23b06",
        "patch": "@@ -36,6 +36,17 @@\n #include <string>\n #include <vector>\n \n+template <typename... Callables>\n+void CallOneOf(FuzzedDataProvider& fuzzed_data_provider, Callables... callables)\n+{\n+    constexpr size_t call_size{sizeof...(callables)};\n+    static_assert(call_size >= 1);\n+    const size_t call_index{fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, call_size - 1)};\n+\n+    size_t i{0};\n+    return ((i++ == call_index ? callables() : void()), ...);\n+}\n+\n [[nodiscard]] inline std::vector<uint8_t> ConsumeRandomLengthByteVector(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length = 4096) noexcept\n {\n     const std::string s = fuzzed_data_provider.ConsumeRandomLengthString(max_length);\n@@ -165,37 +176,31 @@ template <typename WeakEnumType, size_t size>\n [[nodiscard]] inline CTxDestination ConsumeTxDestination(FuzzedDataProvider& fuzzed_data_provider) noexcept\n {\n     CTxDestination tx_destination;\n-    switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 5)) {\n-    case 0: {\n-        tx_destination = CNoDestination{};\n-        break;\n-    }\n-    case 1: {\n-        tx_destination = PKHash{ConsumeUInt160(fuzzed_data_provider)};\n-        break;\n-    }\n-    case 2: {\n-        tx_destination = ScriptHash{ConsumeUInt160(fuzzed_data_provider)};\n-        break;\n-    }\n-    case 3: {\n-        tx_destination = WitnessV0ScriptHash{ConsumeUInt256(fuzzed_data_provider)};\n-        break;\n-    }\n-    case 4: {\n-        tx_destination = WitnessV0KeyHash{ConsumeUInt160(fuzzed_data_provider)};\n-        break;\n-    }\n-    case 5: {\n-        WitnessUnknown witness_unknown{};\n-        witness_unknown.version = fuzzed_data_provider.ConsumeIntegral<int>();\n-        const std::vector<uint8_t> witness_unknown_program_1 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n-        witness_unknown.length = witness_unknown_program_1.size();\n-        std::copy(witness_unknown_program_1.begin(), witness_unknown_program_1.end(), witness_unknown.program);\n-        tx_destination = witness_unknown;\n-        break;\n-    }\n-    }\n+    CallOneOf(\n+        fuzzed_data_provider,\n+        [&] {\n+            tx_destination = CNoDestination{};\n+        },\n+        [&] {\n+            tx_destination = PKHash{ConsumeUInt160(fuzzed_data_provider)};\n+        },\n+        [&] {\n+            tx_destination = ScriptHash{ConsumeUInt160(fuzzed_data_provider)};\n+        },\n+        [&] {\n+            tx_destination = WitnessV0ScriptHash{ConsumeUInt256(fuzzed_data_provider)};\n+        },\n+        [&] {\n+            tx_destination = WitnessV0KeyHash{ConsumeUInt160(fuzzed_data_provider)};\n+        },\n+        [&] {\n+            WitnessUnknown witness_unknown{};\n+            witness_unknown.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+            const std::vector<uint8_t> witness_unknown_program_1 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+            witness_unknown.length = witness_unknown_program_1.size();\n+            std::copy(witness_unknown_program_1.begin(), witness_unknown_program_1.end(), witness_unknown.program);\n+            tx_destination = witness_unknown;\n+        });\n     return tx_destination;\n }\n \n@@ -354,32 +359,26 @@ class FuzzedFileProvider\n             return nullptr;\n         }\n         std::string mode;\n-        switch (m_fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 5)) {\n-        case 0: {\n-            mode = \"r\";\n-            break;\n-        }\n-        case 1: {\n-            mode = \"r+\";\n-            break;\n-        }\n-        case 2: {\n-            mode = \"w\";\n-            break;\n-        }\n-        case 3: {\n-            mode = \"w+\";\n-            break;\n-        }\n-        case 4: {\n-            mode = \"a\";\n-            break;\n-        }\n-        case 5: {\n-            mode = \"a+\";\n-            break;\n-        }\n-        }\n+        CallOneOf(\n+            m_fuzzed_data_provider,\n+            [&] {\n+                mode = \"r\";\n+            },\n+            [&] {\n+                mode = \"r+\";\n+            },\n+            [&] {\n+                mode = \"w\";\n+            },\n+            [&] {\n+                mode = \"w+\";\n+            },\n+            [&] {\n+                mode = \"a\";\n+            },\n+            [&] {\n+                mode = \"a+\";\n+            });\n #ifdef _GNU_SOURCE\n         const cookie_io_functions_t io_hooks = {\n             FuzzedFileProvider::read,\n@@ -477,66 +476,64 @@ class FuzzedAutoFileProvider\n     return {fuzzed_data_provider};\n }\n \n-#define WRITE_TO_STREAM_CASE(id, type, consume) \\\n-    case id: {                                  \\\n-        type o = consume;                       \\\n-        stream << o;                            \\\n-        break;                                  \\\n+#define WRITE_TO_STREAM_CASE(type, consume) \\\n+    [&] {                                   \\\n+        type o = consume;                   \\\n+        stream << o;                        \\\n     }\n template <typename Stream>\n void WriteToStream(FuzzedDataProvider& fuzzed_data_provider, Stream& stream) noexcept\n {\n     while (fuzzed_data_provider.ConsumeBool()) {\n         try {\n-            switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 13)) {\n-                WRITE_TO_STREAM_CASE(0, bool, fuzzed_data_provider.ConsumeBool())\n-                WRITE_TO_STREAM_CASE(1, char, fuzzed_data_provider.ConsumeIntegral<char>())\n-                WRITE_TO_STREAM_CASE(2, int8_t, fuzzed_data_provider.ConsumeIntegral<int8_t>())\n-                WRITE_TO_STREAM_CASE(3, uint8_t, fuzzed_data_provider.ConsumeIntegral<uint8_t>())\n-                WRITE_TO_STREAM_CASE(4, int16_t, fuzzed_data_provider.ConsumeIntegral<int16_t>())\n-                WRITE_TO_STREAM_CASE(5, uint16_t, fuzzed_data_provider.ConsumeIntegral<uint16_t>())\n-                WRITE_TO_STREAM_CASE(6, int32_t, fuzzed_data_provider.ConsumeIntegral<int32_t>())\n-                WRITE_TO_STREAM_CASE(7, uint32_t, fuzzed_data_provider.ConsumeIntegral<uint32_t>())\n-                WRITE_TO_STREAM_CASE(8, int64_t, fuzzed_data_provider.ConsumeIntegral<int64_t>())\n-                WRITE_TO_STREAM_CASE(9, uint64_t, fuzzed_data_provider.ConsumeIntegral<uint64_t>())\n-                WRITE_TO_STREAM_CASE(10, float, fuzzed_data_provider.ConsumeFloatingPoint<float>())\n-                WRITE_TO_STREAM_CASE(11, double, fuzzed_data_provider.ConsumeFloatingPoint<double>())\n-                WRITE_TO_STREAM_CASE(12, std::string, fuzzed_data_provider.ConsumeRandomLengthString(32))\n-                WRITE_TO_STREAM_CASE(13, std::vector<char>, ConsumeRandomLengthIntegralVector<char>(fuzzed_data_provider))\n-            }\n+            CallOneOf(\n+                fuzzed_data_provider,\n+                WRITE_TO_STREAM_CASE(bool, fuzzed_data_provider.ConsumeBool()),\n+                WRITE_TO_STREAM_CASE(char, fuzzed_data_provider.ConsumeIntegral<char>()),\n+                WRITE_TO_STREAM_CASE(int8_t, fuzzed_data_provider.ConsumeIntegral<int8_t>()),\n+                WRITE_TO_STREAM_CASE(uint8_t, fuzzed_data_provider.ConsumeIntegral<uint8_t>()),\n+                WRITE_TO_STREAM_CASE(int16_t, fuzzed_data_provider.ConsumeIntegral<int16_t>()),\n+                WRITE_TO_STREAM_CASE(uint16_t, fuzzed_data_provider.ConsumeIntegral<uint16_t>()),\n+                WRITE_TO_STREAM_CASE(int32_t, fuzzed_data_provider.ConsumeIntegral<int32_t>()),\n+                WRITE_TO_STREAM_CASE(uint32_t, fuzzed_data_provider.ConsumeIntegral<uint32_t>()),\n+                WRITE_TO_STREAM_CASE(int64_t, fuzzed_data_provider.ConsumeIntegral<int64_t>()),\n+                WRITE_TO_STREAM_CASE(uint64_t, fuzzed_data_provider.ConsumeIntegral<uint64_t>()),\n+                WRITE_TO_STREAM_CASE(float, fuzzed_data_provider.ConsumeFloatingPoint<float>()),\n+                WRITE_TO_STREAM_CASE(double, fuzzed_data_provider.ConsumeFloatingPoint<double>()),\n+                WRITE_TO_STREAM_CASE(std::string, fuzzed_data_provider.ConsumeRandomLengthString(32)),\n+                WRITE_TO_STREAM_CASE(std::vector<char>, ConsumeRandomLengthIntegralVector<char>(fuzzed_data_provider)));\n         } catch (const std::ios_base::failure&) {\n             break;\n         }\n     }\n }\n \n-#define READ_FROM_STREAM_CASE(id, type) \\\n-    case id: {                          \\\n-        type o;                         \\\n-        stream >> o;                    \\\n-        break;                          \\\n+#define READ_FROM_STREAM_CASE(type) \\\n+    [&] {                           \\\n+        type o;                     \\\n+        stream >> o;                \\\n     }\n template <typename Stream>\n void ReadFromStream(FuzzedDataProvider& fuzzed_data_provider, Stream& stream) noexcept\n {\n     while (fuzzed_data_provider.ConsumeBool()) {\n         try {\n-            switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 13)) {\n-                READ_FROM_STREAM_CASE(0, bool)\n-                READ_FROM_STREAM_CASE(1, char)\n-                READ_FROM_STREAM_CASE(2, int8_t)\n-                READ_FROM_STREAM_CASE(3, uint8_t)\n-                READ_FROM_STREAM_CASE(4, int16_t)\n-                READ_FROM_STREAM_CASE(5, uint16_t)\n-                READ_FROM_STREAM_CASE(6, int32_t)\n-                READ_FROM_STREAM_CASE(7, uint32_t)\n-                READ_FROM_STREAM_CASE(8, int64_t)\n-                READ_FROM_STREAM_CASE(9, uint64_t)\n-                READ_FROM_STREAM_CASE(10, float)\n-                READ_FROM_STREAM_CASE(11, double)\n-                READ_FROM_STREAM_CASE(12, std::string)\n-                READ_FROM_STREAM_CASE(13, std::vector<char>)\n-            }\n+            CallOneOf(\n+                fuzzed_data_provider,\n+                READ_FROM_STREAM_CASE(bool),\n+                READ_FROM_STREAM_CASE(char),\n+                READ_FROM_STREAM_CASE(int8_t),\n+                READ_FROM_STREAM_CASE(uint8_t),\n+                READ_FROM_STREAM_CASE(int16_t),\n+                READ_FROM_STREAM_CASE(uint16_t),\n+                READ_FROM_STREAM_CASE(int32_t),\n+                READ_FROM_STREAM_CASE(uint32_t),\n+                READ_FROM_STREAM_CASE(int64_t),\n+                READ_FROM_STREAM_CASE(uint64_t),\n+                READ_FROM_STREAM_CASE(float),\n+                READ_FROM_STREAM_CASE(double),\n+                READ_FROM_STREAM_CASE(std::string),\n+                READ_FROM_STREAM_CASE(std::vector<char>));\n         } catch (const std::ios_base::failure&) {\n             break;\n         }"
      }
    ]
  }
]