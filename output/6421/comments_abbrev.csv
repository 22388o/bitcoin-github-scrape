jonasschnelli,2015-07-11T13:51:02Z,Needs rebase because #6410 is merged now.\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120622404,120622404,
jtimon,2015-07-11T16:04:54Z,Nits from #6331 rebased at https://github.com/sipa/bitcoin/compare/limitpool...jtimon:pr-6421-0.11.99 (will force push to jtimon/pr-6421-0.11.99 as this gets rebased).\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120635982,120635982,
sipa,2015-07-11T18:45:38Z,"@lapp0 You suggested using ""the new transaction's fees should pay for the size of the new plus removed transaction"". That doesn't help, as you can create a sequence of transactions that each replace the previous one, and each have enough fees to pay for both. This would give you infinite relay bandwidth at fixed cost.\n\nThe solution is perhaps to remember for each mempool transaction what the siz",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120652090,120652090,
sipa,2015-07-11T18:49:07Z,"@jtimon It's probably a bit more complicated than just a score function, I now realize. The mempool code is trying to optimize for fee/byte (currently), independently of what sorting is implemented by the index. I think we'll need a policy-controlled ""cost"" (as a generalization of size, perhaps corrected for UTXO differences) and policy-controlled ""revenue"" (as a generalization of fee). The reason",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120652225,120652225,
jonasschnelli,2015-07-11T18:57:24Z,"Slightly tested. Running this code (git commit tip 3c638fc0ba82a9d9c235f428d098a098fc0b6b16, not the latest tip) since some hours with `-maxmempool=100`. Since 1h i have a stable dynamic memory size of ~100MB. Graph: http://bitcoin.jonasschnelli.ch/charts/mempool6410/\n\nLog filtered after the ""stored orphan txs"": https://gist.githubusercontent.com/jonasschnelli/1f2e89d64887710f6c5b/raw/dba3d68d79",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120652531,120652531,
jtimon,2015-07-11T21:42:09Z,"@sipa answered in #6331: bike-shed the name of the variable, the getter and the comparator, but please don't make the type CFeeRate so that we have to fix it later. int64_t should work perfectly fine for these changes.\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120663063,120663063,
jtimon,2015-07-12T15:20:26Z,"I believe this could be much simpler (and the end result better) after #5709 (is 10 commits but ready to be squashed into the first one), but I doubt people want to read step by step to be sure behavior is not being changed. At least not more now than when it was opened...\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120730086,120730086,
sipa,2015-07-12T18:43:43Z,"@jtimon It's a bit more complicated. The replacement code needs to have a way to know whether replacing a set of transactions with another transaction is a good idea. Contrary to what I first thought, just having a score to compare is not enough - if the index order doesn't match the feerate well, its search for sets to remove will degrade or fail.\n\nOne way to generalize this to something policy",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120753654,120753654,
jtimon,2015-07-12T19:12:25Z,"Even in that case, both the ""general reward"" and the ""general cost"" indexes can use int64_t instead of CFeeRate  and size_t respectively. Can we agree on that first?\n\nI still don't understand why this needs transaction replacement. We can add it or not as normal and, after adding, trim to the desired size. with this, we could have a unified index that it's just reward/cost instead of two separat",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120754922,120754922,
sipa,2015-07-12T19:32:02Z,"@jtimon There is a DoS attack possible by mempool limiting, where someone sends a transaction that ends up at the bottom of the mempool, and then sends another transaction with slightly higher feerate, causing the previous one to be evicted later on. This leads to network broadcast bandwidth at much lower cost than the actual network relay fee, as discovered by @lapp0.\n\nThe solution is to treat ",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120755721,120755721,
dgenr8,2015-07-12T19:37:22Z,"@sipa You don't need to optimize a ratio, if you can represent both the rewards and costs in comparable units.  Then you could optimize the difference.  I wonder if unit costs could be represented in BTC/byte ...\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120755945,120755945,
sipa,2015-07-12T19:42:04Z,"@dgenr8 Optimizing feerate is what you expect miners to do in their mempool, as it maximizes income given a constrained (by rule or propagation economics) block size. \n\n@jtimon Yes, I agree that instead of feerate and size we can use int64_t. Or double even. But the logic is already complicated enough here. I really don't think it's wise to spend more mental power of maintainers and reviewers to",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120756145,120756145,
dgenr8,2015-07-12T19:55:21Z,"@sipa Miners don't care about relay cost, which you are now trying to include.\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120756823,120756823,
sipa,2015-07-12T20:04:36Z,"@dgenr8 Of course. This is DoS protection code for relaying nodes, not for miners. Its primary purpose is preventing people from being able to spam the network, in various ways. It aims to build a mempool which is as aligned with miner's incentives as possible, but is restricted to prevent network actors from causing too high memory consumption, get massive flooding bandwidth or consume too much C",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120758333,120758333,
sipa,2015-07-12T20:10:35Z,"Pushed a new version which tries more than just the bottom transactions and their dependencies in the mempool, is more efficient, and is better documented.\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120758848,120758848,
jtimon,2015-07-12T20:20:37Z,"> @jtimon Yes, I agree that instead of feerate and size we can use int64_t. Or double even. But the logic is already complicated enough here. I really don't think it's wise to spend more mental power of maintainers and reviewers to understand how this code will at some point generalize to a configurable policy.\n\nWhatever, If `CFeeRate(nFee, nTxSize)` is more readable than `nFee / nTxSize` and ht",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120759269,120759269,
sipa,2015-07-12T20:42:45Z,"@jtimon Making score be anything but feerate won't work, as the replacement code relies on that now. Making it generalizable will require more thinking than we should be doing right now, and calling it score when it can't just be anything is confusing IMHO - sorry for suggesting this before. But can we please keep the discussion and changes about how mempool policy will be introduced separate from",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120760638,120760638,
jgarzik,2015-07-12T20:43:59Z,Using CFeeRate is sufficient.  No need to over-engineer and over-complicate the matter.  +1 @sipa \n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120760699,120760699,
jtimon,2015-07-13T07:08:19Z,"@jtimon Making score be anything but feerate won't work, as the replacement code relies on that now. Making it generalizable will require more thinking than we should be doing right now, and calling it score when it can't just be anything is confusing IMHO - sorry for suggesting this before. But can we please keep the discussion and changes about how mempool policy will be introduced separate from",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120834071,120834071,
jtimon,2015-07-13T13:52:00Z,So here are some suggestions that could be incorporated to this or maybe left for later: https://github.com/sipa/bitcoin/compare/limitpool...jtimon:limitpool_nits\nHere's the same after further simplification and indentation: https://github.com/sipa/bitcoin/compare/limitpool...jtimon:post_limitpool\n\nBut let's focus on https://github.com/sipa/bitcoin/commit/c7ef38980ab48db7cc56a6ebdf1ca2c03ef2453,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120934575,120934575,
sipa,2015-07-13T13:57:07Z,"Added a commit that removes CFeeRate and the feerate variable, and replaces it by something more efficient.\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120936415,120936415,
sipa,2015-07-13T14:37:43Z,@jtimon The changes to the free transaction decision logic look good to me - much more readable than the combined ifs all the way. Would you care to rebase?\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-120951182,120951182,
laanwj,2015-07-14T11:03:37Z,Going to test.\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121201918,121201918,
mikehearn,2015-07-14T13:23:26Z,"Miner's incentives aren't quite to maximise fees gathered above all else. Miners need Bitcoin to actually work for regular users, even in the case where there is a DoS attack on the network that's based on paying high fees. Otherwise the utility of the coins they're mining and thus their profits go down. That's why the notion of priority was invented, and why there's a region of the block dedicate",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121236540,121236540,
jtimon,2015-07-14T16:04:33Z,"Rebased https://github.com/sipa/bitcoin/compare/limitpool...jtimon:post_limitpool again with some changes.\nIf we don't care about not limiting free transactions that don't pass AllowFree() check when the caller  specifies  fLimitFree=false, this change becomes really simple: https://github.com/sipa/bitcoin/commit/68f0129c29543d6e744a73f168627c733cd3d98e\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121291705,121291705,
jtimon,2015-07-14T21:05:48Z,What about https://github.com/sipa/bitcoin/commit/44d29ff871c409670e7b09cb030886d7719680f6 and https://github.com/sipa/bitcoin/commit/2604e37866d289cad862c9e956a62509e3417427\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121386738,121386738,
sipa,2015-07-14T22:13:02Z,"@morcos @sdaftuar Now every transaction is only tried with a 1/10 chance, and we bail out after 10 (actually tried) transactions, and after 20 failures even without finishing the current transaction.\n\nI tried with up to 32 failures, and it seems that 99% of succesful replacements happen with <=10 failures.\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121408086,121408086,
morcos,2015-07-15T13:04:34Z,"The main concern I have with this approach is finding the best set of ""packages"" (transactions and their dependents) to replace in the mempool is a knapsack problem, and it is hard to strike the right balance between doing too much work and rejecting a potential replacement transaction that intuitively should make it into the mempool.  Also any indeterminism could lead to an unfortunate feedback l",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121608691,121608691,
laanwj,2015-07-15T13:32:36Z,"@morcos I agree, though I do like this approach of having a hard cap in case any kind of fee-based soft limit is somehow bypassed. I think a goal should be to have all of bitcoin core's internal data structures capped.\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121618187,121618187,
dgenr8,2015-07-15T14:16:39Z,"@morcos A selfish node can just assign dependent transactions a higher cost than independent ones.  They require more space (since parents are required) and they can take longer to confirm than other txes with the same fee rate (since parents may have a lower fee rate).\n\nIt's impossible to guarantee that you have spender's whole ""package"" anyway, so the rules really need to work on individual tr",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121630158,121630158,
morcos,2015-07-15T15:02:36Z,"@dgenr8 If I understand your first paragraph, yes I think thats the fundamental problem.  But I'm not sure what you mean by rules working on an individual transaction level.  You have to kick out dependent transactions, and so if you don't take into account the fees those transactions paid, you make it easy for someone to get free relay bandwidth by sticking in a long chain and then replacing the ",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121644660,121644660,
dgenr8,2015-07-15T16:53:19Z,"@morcos In what I described, every child ""pays"" for its parents up-front in reduced mempool/relay attractiveness.  Multiple children pay again for the same parent, and there is a recursive effect.\n\nUnconfirmed chains are expensive to process, have huge DoS risk, and limited usefulness.  Replacement complicates everything.  I mentioned in a [mailing list post](http://lists.linuxfoundation.org/pip",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121677678,121677678,
jtimon,2015-07-16T10:19:53Z,"It seems everybody is happy with https://github.com/sipa/bitcoin/commit/8adacf100a36d92e263fe6295c767b087168aeaa \nCan we merge that first (after rebase) while we discuss the last commit?\n\n@morcos I'm not sure I understand your complains, but if the mempool is capped there must be some replacement criteria, even if it's the dumb ""never replace"" we have now (that's why I think the last commit wou",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121918988,121918988,
jtimon,2015-07-16T10:23:37Z,"Btw, there's slightly related optimizations in #6445. The most relevant parts for this PR being in AcceptToMemoryPool:\n- Don't calculate nValueOut 5 times \n- Don't calculate nValueIn 3 times\n- Don't call CCoinsViewCache::HaveInputs 3 times\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121920323,121920323,
jtimon,2015-07-16T12:11:47Z,Rebased version (with my suggestions on top) in https://github.com/jtimon/bitcoin/commits/post_limitpool\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121940451,121940451,
Diapolo,2015-07-16T12:30:55Z,"Can this be rebased, the Qt keyword pull sneaked in here ;).\n",https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-121943497,121943497,
sipa,2015-09-22T16:39:21Z,Superseded by a dozen other PRs.\n,https://github.com/bitcoin/bitcoin/pull/6421#issuecomment-142343500,142343500,
petertodd,2015-07-11T14:09:06Z,Need to update this error msg.\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34412933,34412933,src/main.cpp
ashleyholman,2015-07-11T14:09:34Z,"What happens if the lowest fee-rate transaction in the pool is a parent transaction to a chain of high fee transactions?  Wouldn't that prevent any eviction from happening, even though there may be other transactions that could be removed to make room?\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34412938,34412938,src/txmempool.cpp
sipa,2015-07-11T14:12:39Z,Yup. Fixing that is complicated and/or expensive.\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34412964,34412964,src/txmempool.cpp
petertodd,2015-07-11T14:13:09Z,Can you update this comment to clarify if we're talking about txs or ram?\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34412968,34412968,src/main.h
sipa,2015-07-11T14:14:24Z,"(Efficient) code that implements CPFP will likely fix this, as I expect that it will maintain caches of sizes/fees of children of transactions.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34412978,34412978,src/txmempool.cpp
sipa,2015-07-11T14:17:17Z,Suggestion?\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413002,34413002,src/main.cpp
sipa,2015-07-11T14:18:50Z,Fixed.\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413014,34413014,src/main.h
petertodd,2015-07-11T14:29:32Z,"Oh, actually I misread it; no changes needed.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413107,34413107,src/main.cpp
petertodd,2015-07-11T14:56:31Z,"CPFP could work with this by turning individual transactions into ""packages"" of transactions whenever a parent pays more fees/KB than a child+parent. Removal would then remove the whole ""package"" in one go; there would never be a situation where removal was blocked.\n\nThat said, I'd be inclined to merge this pull-req first, then work on the fixes for the edge cases second.\n\nOn 11 July 2015 10:1",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413313,34413313,src/txmempool.cpp
sipa,2015-07-11T15:10:12Z,Agree.\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413453,34413453,src/txmempool.cpp
ashleyholman,2015-07-11T15:13:39Z,"You could return to the outer loop and try again on the next tx, up until you hit one that has a feerate >= the one you are trying to add.  Although that does add a lot of extra work.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413490,34413490,src/txmempool.cpp
sipa,2015-07-11T15:20:45Z,That risks quadratic work...\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34413532,34413532,src/txmempool.cpp
petertodd,2015-07-13T03:52:17Z,"s/CompareTxMemPoolEntryByFee/CompareTxMemPoolEntryByFeeRate/\n\nMore verbose sure, but let's not confuse people.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34431947,34431947,src/txmempool.h
petertodd,2015-07-13T04:10:28Z,"If RemoveStaged() is kept as a separate function, we should document what it does.\n\nEqually, should it remain a separate function? The code using it could very well be more clear if it just does the removal itself.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34432344,34432344,src/txmempool.h
jtimon,2015-07-13T06:47:49Z,"If we're only having 1 comparator (and having more than one would be over-complicating this), simply CompareTxMemPoolEntry or TxMemPoolEntryComparator is enough.\nOf course, both suggestions are just bike-shedding. \n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34436620,34436620,src/txmempool.h
petertodd,2015-07-13T11:08:43Z,"It'd be better if we added the size of the new tx to the size limit, as right now the limit can be exceeded; I'm sure this is going to result in issues getting raised... GuessDynamicMemoryUsage() could be used for that if I understand its purpose correctly.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34452910,34452910,src/main.cpp
petertodd,2015-07-13T11:12:18Z,"Equally, maybe change StageTrimToSize() to take a CTransaction()/CTxMemPoolEntry() and figure out all that stuff itself?\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34453117,34453117,src/main.cpp
petertodd,2015-07-13T11:39:50Z,"The worst-case for this while() loop is that it traverses the entire mempool, setting iternow to the number of txs in the mempool; the fails/iternow check should probably be on the while loop instead.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34454760,34454760,src/txmempool.cpp
petertodd,2015-07-13T11:42:45Z,NACK\n\nAny comparator is ultimately going to be about profit-per-byte. (modulo radical design changes to how the Bitcoin protocol works)\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34454910,34454910,src/txmempool.h
petertodd,2015-07-13T12:08:57Z,"Change this to nFees < txMinFee + nFeesDeleted and correspondingly change the DoS error message to ""%d < %d + %d"" - right now we could get the left hand to be > than the right hand in the error message printout.\n\nThat said, a look in my debug.log indicates that this code never gets triggered with this patch, not sure why yet.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34456412,34456412,src/main.cpp
petertodd,2015-07-13T12:10:02Z,"Of course, another possibility is to change nFees to nDeltaFees = nFees - nFeesDeleted everywhere.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34456479,34456479,src/main.cpp
sipa,2015-07-13T13:59:52Z,"I've considered doing that, but that would prevent any removal of deep chains, effectively making those clog the mempool. However, we do add the fees of these transactions together, which are always of a higher feerate than the 'hash' being iterated. Once those accumulated fees exceed the total fees of the replacing transaction, we continue.\n\nPerhaps a iternow + fails > 100 safeguard is still us",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34464994,34464994,src/txmempool.cpp
sipa,2015-07-13T14:29:59Z,"I've renamed it to CompareTxMemPoolEntryByFeeRate, because that is what it currently does, and it can't be easily changed without breaking the limiter code.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34468166,34468166,src/txmempool.h
sipa,2015-07-13T14:31:20Z,"The rationale here is that I would want the staged set to become a separate class, which tracks statistics of what is being removed etc. That would make it also safe to not expose removeUnchecked (way faster than remove, because it already contains all dependencies), but a RemoveStaged method would need to remain.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34468321,34468321,src/txmempool.h
sipa,2015-07-13T14:31:34Z,Done.\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34468343,34468343,src/main.cpp
sipa,2015-07-13T14:32:10Z,"You don't want to use modified fees for the ""absurdly large fees"" check, I think.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34468396,34468396,src/main.cpp
jtimon,2015-07-13T14:58:21Z,Actually it does use the time too: https://github.com/bitcoin/bitcoin/pull/6421/files#diff-8304b3e94624036c3673f31eeb7e9de0R88\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34471449,34471449,src/txmempool.h
sdaftuar,2015-07-13T19:02:11Z,"I think we should be doing this check on each ""package"" (of parent and child transactions) separately.  Otherwise I think it's possible for us to remove a package that has a higher fee rate than the transaction we're evaluating, because we're averaging together with lower feerate packages.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34498887,34498887,src/txmempool.cpp
sipa,2015-07-13T19:23:54Z,"Nice catch, I agree. I'll move the check.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34501010,34501010,src/txmempool.cpp
sdaftuar,2015-07-13T20:06:01Z,"I think we should also compare the fee rate of each package of transactions to the feerate of this transaction + any unconfirmed parents of this transaction, to ensure that we're not removing a package that is economically preferable to the transaction we're considering.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34505227,34505227,src/txmempool.cpp
jtimon,2015-07-14T15:00:03Z,"Why this doesn't also require fLimitFree ? Why call AllowFree() when AcceptToMemoryPool's caller is specifying fLimitFree=false ?\nI know this is older than this PR, but I have only asked myself that now...\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34577450,34577450,src/main.cpp
morcos,2015-07-14T16:30:13Z,"Needs to be `(fails >= 20)` if iternow is the count of all the transactions in the package being considered.\n\nHowever, I'm not sure this is a great check, it still seems easy for the lowest fee transaction to be part of a package > 20 txs which fails at the end.  Then you'll never check any other starting transaction.  I'd rather have some variance in the starting transaction you check and put t",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34588467,34588467,src/txmempool.cpp
sdaftuar,2015-07-14T20:05:00Z,"Agree with @morcos -- I'm running various tests of this code, and I think a significant number of transactions are being rejected because of this issue with large transaction packages preventing new transactions from being accepted, even if the new transactions have a large fee.\n\nI'll try to quantify this more precisely and carefully as I test further, but as an example, I ran an analysis of thi",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34612750,34612750,src/txmempool.cpp
sipa,2015-07-14T20:06:35Z,"I'm testing a change in the code that skips entries randomly, to sample a\nlarger subset of transactions for replacement in the long term.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34612918,34612918,src/txmempool.cpp
jtimon,2015-07-16T15:06:21Z,Shouldn't this be `mapTx.erase(hash);` ?\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34797429,34797429,src/txmempool.cpp
jtimon,2015-07-16T15:07:06Z,This can be just `todo.push_back(hash);`\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34797526,34797526,src/txmempool.cpp
morcos,2015-07-17T01:24:58Z,This test is better placed after we've randomly skipped some entries below.  Otherwise we might end up evicting something that actually has a better fee rate than the tx being considered.\n,https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34855569,34855569,src/txmempool.cpp
sipa,2015-07-17T18:34:07Z,"Unless you're talking about an outer-loop transaction being hit which has an earlier (lower feerate) skipped transaction as dependency, I think the odds are small. But it won't hurt, both are very cheap checks.\n",https://github.com/bitcoin/bitcoin/pull/6421#discussion_r34918202,34918202,src/txmempool.cpp
