mb300sd,2019-11-19 23:12:13,Tested. Changes fixed the issue for me.,https://github.com/bitcoin/bitcoin/pull/17527#issuecomment-555759090,555759090,
fanquake,2019-11-19 23:21:15,"[IntelÂ® Processor Identification and the CPUID Instruction - Application Note 485](https://github.com/bitcoin/bitcoin/files/3866527/241618-038.pdf)\n",https://github.com/bitcoin/bitcoin/pull/17527#issuecomment-555761677,555761677,
laanwj,2019-11-20 08:27:26,Concept ACK. Thanks @mb300sd for catching this before a release.,https://github.com/bitcoin/bitcoin/pull/17527#issuecomment-555895238,555895238,
laanwj,2019-11-22 15:53:21,ACK f93fc61c65d605eae2d3e2c98bdd30ae587fcdab,https://github.com/bitcoin/bitcoin/pull/17527#issuecomment-557586413,557586413,
jonatack,2019-11-22 16:47:22,"ACK f93fc61c65d605eae2d3e2c98bdd30ae587fcdab code review, tested rebased on current master bb862d7 with Debian 4.19 x86_64",https://github.com/bitcoin/bitcoin/pull/17527#issuecomment-557606631,557606631,
mzumsande,2019-11-20 00:08:52,"I am not an expert on CPUID, but how about an emergency break after some number of subleaves - or was it a deliberate decision to construct the inner loop in a way that it can possibly run infinitely when certain assumptions are wrong, or might be in the future? ",https://github.com/bitcoin/bitcoin/pull/17527#discussion_r348233794,348233794,src/randomenv.cpp
sipa,2019-11-20 00:21:15,"I guess the question is whether we want to have any chance of catching weird systems that return non-compliant CPUID values. If we add an upper bound, we'll probably never ever see a bug report like this one.\n\n",https://github.com/bitcoin/bitcoin/pull/17527#discussion_r348236835,348236835,src/randomenv.cpp
mzumsande,2019-11-20 00:59:20,"True, I am not sure if catching those justifies the inconvenience for affected users who might not be able to run bitcoin on their system without waiting for a patch (considering that CPUID is just one of many static entropy sources).",https://github.com/bitcoin/bitcoin/pull/17527#discussion_r348246049,348246049,src/randomenv.cpp
laanwj,2019-11-20 08:22:05,"I think this depends on the chance that there actually CPUs out there, suitable for running nodes, that are not compliant with this. \n\nI feel slightly uneasy with potentially infinite loops over hardware registers like this, OTOH I understand @sipa's point.\n\n> I guess the question is whether we want to have any chance of catching weird systems that return non-compliant CPUID values.\n\nI",https://github.com/bitcoin/bitcoin/pull/17527#discussion_r348341867,348341867,src/randomenv.cpp
laanwj,2019-11-20 08:23:56,It's only a uint32_t. How long does a full wrap-around take?,https://github.com/bitcoin/bitcoin/pull/17527#discussion_r348342588,348342588,src/randomenv.cpp
sipa,2019-11-20 18:56:01,"@laanwj A full 32-bit wrap-around would mean SHA512 hashing 96 GiB of data. Too long, I'm sure.\n\nI've added a commit to limit the number of iterations.",https://github.com/bitcoin/bitcoin/pull/17527#discussion_r348686646,348686646,src/randomenv.cpp
mzumsande,2019-11-23 21:55:56,"Got slightly confused here because the intel pdf linked above recommends `eax=0` and `ebx=0` as break condition for leaf 11 (p.40), but checking `cx & 0xff00` should be equivalent according to [this](http://www.ftp.neutrino.es/x86InstructionSet/CPUID.html).",https://github.com/bitcoin/bitcoin/pull/17527#discussion_r349892034,349892034,src/randomenv.cpp
