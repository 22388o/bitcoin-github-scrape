[
  {
    "sha": "b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOWMxYTc2NDgxMzFjNWRlZWM5NzA0ZWU5YWNkMDBlYzE4MjBiOWNl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T19:44:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T19:44:08Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 2ed54da18a..8ab24e8dad\n\n8ab24e8dad Merge #558: Add schnorrsig module which implements BIP-340 compliant signatures\nf3733c5433 Merge #797: Fix Jacobi benchmarks and other benchmark improvements\ncb5524adc5 Add benchmark for secp256k1_ge_set_gej_var\n5c6af60ec5 Make jacobi benchmarks vary inputs\nd0fdd5f009 Randomize the Z coordinates in bench_internal\nc7a3424c5f Rename bench_internal variables\n875d68b95f Merge #699: Initialize field elements when resulting in infinity\n54caf2e74f Merge #799: Add fallback LE/BE for architectures with known endianness + SHA256 selftest\nf431b3f28a valgrind_ctime_test: Add schnorrsig_sign\n16ffa9d97c schnorrsig: Add taproot test case\n8dfd53ee3f schnorrsig: Add benchmark for sign and verify\n4e43520026 schnorrsig: Add BIP-340 compatible signing and verification\n7332d2db6b schnorrsig: Add BIP-340 nonce function\n7a703fd97d schnorrsig: Init empty experimental module\neabd9bc46a Allow initializing tagged sha256\n6fcb5b845d extrakeys: Add keypair_xonly_tweak_add\n58254463f9 extrakeys: Add keypair struct with create, pub and pub_xonly\nf0010349b8 Separate helper functions for pubkey_create and seckey_tweak_add\n910d9c284c extrakeys: Add xonly_pubkey_tweak_add & xonly_pubkey_tweak_add_test\n176bfb1110 Separate helper function for ec_pubkey_tweak_add\n4cd2ee474d extrakeys: Add xonly_pubkey with serialize, parse and from_pubkey\nf49c9896b0 Merge #806: Trivial: Add test logs to gitignore\naabf00c155 Merge #648: Prevent ints from wrapping around in scratch space functions\nf5adab16a9 Merge #805: Remove the extremely outdated TODO file.\nbceefd6547 Add test logs to gitignore\n1c325199d5 Remove the extremely outdated TODO file.\n47e6618e11 extrakeys: Init empty experimental module\n3e08b02e2a Make the secp256k1_declassify argument constant\n8bc6aeffa9 Add SHA256 selftest\n670cdd3f8b Merge #798: Check assumptions on integer implementation at compile time\n5e5fb28b4a Use additional system macros to figure out endianness\n7c068998ba Compile-time check assumptions on integer types\n02b6c87b52 Add support for (signed) __int128\n979961c506 Merge #787: Use preprocessor macros instead of autoconf to detect endianness\n887bd1f8b6 Merge #793: Make scalar/field choice depend on C-detected __int128 availability\n0dccf98a21 Use preprocessor macros instead of autoconf to detect endianness\nb2c8c42cf1 Merge #795: Avoid linking libcrypto in the valgrind ct test.\n57d3a3c64c Avoid linking libcrypto in the valgrind ct test.\n79f1f7a4f1 Autodetect __int128 availability on the C side\n0d7727f95e Add SECP256K1_FE_STORAGE_CONST_GET to 5x52 field\n805082de11 Merge #696: Run a Travis test on s390x (big endian)\n39295362cf Test travis s390x (big endian)\n6034a04fb1 Merge #778: secp256k1_gej_double_nonzero supports infinity\nf60915906d Merge #779: travis: Fix argument quoting for ./configure\n9e49a9b255 travis: Fix argument quoting for ./configure\n18d36327fd secp256k1_gej_double_nonzero supports infinity\n214cb3c321 Merge #772: Improve constant-timeness on PowerPC\n40412b1930 Merge #774: tests: Abort if malloc() fails during context cloning tests\n2e1b9e0458 tests: Abort if malloc() fails during context cloning tests\n67a429f31f Suppress a harmless variable-time optimization by clang in _int_cmov\n5b196338f0 Remove redundant \"? 1 : 0\" after comparisons in scalar code\n3e5cfc5c73 Merge #741: Remove unnecessary sign variable from wnaf_const\n66bb9320c0 Merge #773: Fix some compile problems on weird/old compilers.\n1309c03c45 Fix some compile problems on weird/old compilers.\n2309c7dd4a Merge #769: Undef HAVE___INT128 in basic-config.h to fix gen_context compilation\n22e578bb11 Undef HAVE___INT128 in basic-config.h to fix gen_context compilation\n3f4a5a10e4 Merge #765: remove dead store in ecdsa_signature_parse_der_lax\nf00d6575ca remove dead store in ecdsa_signature_parse_der_lax\ndbd41db16a Merge #759: Fix uninitialized variables in ecmult_multi test\n2e7fc5b537 Fix uninitialized variables in ecmult_multi test\n37dba329c6 Remove unnecessary sign variable from wnaf_const\n6bb0b77e15 Fix test_constant_wnaf for -1 and add a test for it.\n47a7b8382f Clear field elements when writing infinity\n61d1ecb028 Added test with additions resulting in infinity\n60f7f2de5d Don't assume that ALIGNMENT > 1 in tests\nada6361dec Use ROUND_TO_ALIGN in scratch_create\n8ecc6ce50e Add check preventing rounding to alignment from wrapping around in scratch_alloc\n4edaf06fb0 Add check preventing integer multiplication wrapping around in scratch_max_allocation\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 8ab24e8dad9d43fc6661842149899e3cc9213b24",
      "tree": {
        "sha": "1b2db0573d7c4f2f90589da7886816d0db73b8c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1b2db0573d7c4f2f90589da7886816d0db73b8c7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "67f232b5d874b501c114bced5d764db7f4f5ce99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67f232b5d874b501c114bced5d764db7f4f5ce99",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67f232b5d874b501c114bced5d764db7f4f5ce99"
      }
    ],
    "stats": {
      "total": 3212,
      "additions": 2928,
      "deletions": 284
    },
    "files": [
      {
        "sha": "ccdef02b29486e95257cb6c05fa1c1fa1101c2be",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -1,9 +1,9 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n-bench_schnorr_verify\n bench_recover\n bench_internal\n tests\n@@ -31,6 +31,8 @@ libtool\n *.lo\n *.o\n *~\n+*.log\n+*.trs\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h"
      },
      {
        "sha": "e1a88c40510a22ae86f3c8a46b80cc02ac912575",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 15,
        "deletions": 11,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -17,19 +17,19 @@ compiler:\n   - gcc\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n+    - WIDEMUL=auto  BIGNUM=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n-    - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n-    - SCALAR=64bit\n-    - FIELD=64bit     RECOVERY=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n-    - FIELD=64bit                       ASM=x86_64\n-    - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     ENDOMORPHISM=yes\n+    - WIDEMUL=int64   RECOVERY=yes\n+    - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int64   ENDOMORPHISM=yes\n+    - WIDEMUL=int128\n+    - WIDEMUL=int128  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int128                    ASM=x86_64\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ASM=x86_64\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck CTIMETEST= BENCH=\n     - CPPFLAGS=-DDETERMINISTIC\n@@ -83,6 +83,10 @@ matrix:\n             - valgrind\n             - libtool-bin\n             - libc6-dbg:i386\n+    # S390x build (big endian system)\n+    - compiler: gcc\n+      env: HOST=s390x-unknown-linux-gnu ECDH=yes RECOVERY=yes EXPERIMENTAL=yes CTIMETEST=\n+      arch: s390x\n \n # We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n # because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes."
      },
      {
        "sha": "023fa6067fbbaadf86e8653f5184ef89ad88de0e",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -34,9 +34,11 @@ noinst_HEADERS += src/field_5x52.h\n noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n+noinst_HEADERS += src/assumptions.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/scratch.h\n noinst_HEADERS += src/scratch_impl.h\n+noinst_HEADERS += src/selftest.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n noinst_HEADERS += src/hash.h\n@@ -99,7 +101,7 @@ if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n@@ -152,3 +154,11 @@ endif\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif\n+\n+if ENABLE_MODULE_EXTRAKEYS\n+include src/modules/extrakeys/Makefile.am.include\n+endif\n+\n+if ENABLE_MODULE_SCHNORRSIG\n+include src/modules/schnorrsig/Makefile.am.include\n+endif"
      },
      {
        "sha": "a300e1c5eb9b1376c82b1f5d557d56be5708546f",
        "filename": "TODO",
        "status": "removed",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/TODO",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/TODO",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/TODO?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -1,3 +0,0 @@\n-* Unit tests for fieldelem/groupelem, including ones intended to\n-  trigger fieldelem's boundary cases.\n-* Complete constant-time operations for signing/keygen"
      },
      {
        "sha": "57595f4499d8e10646e6cbb56417a831803786cd",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -1,8 +1,3 @@\n-dnl libsecp25k1 helper checks\n-AC_DEFUN([SECP_INT128_CHECK],[\n-has_int128=$ac_cv_type___int128\n-])\n-\n dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)"
      },
      {
        "sha": "6fe8984f4d87e620d1594a3d4511bf8c16e31e9d",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 48,
        "deletions": 87,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -136,20 +136,28 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(module_extrakeys,\n+    AS_HELP_STRING([--enable-module-extrakeys],[enable extrakeys module (experimental)]),\n+    [enable_module_extrakeys=$enableval],\n+    [enable_module_extrakeys=no])\n+\n+AC_ARG_ENABLE(module_schnorrsig,\n+    AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module (experimental)]),\n+    [enable_module_schnorrsig=$enableval],\n+    [enable_module_schnorrsig=no])\n+\n AC_ARG_ENABLE(external_default_callbacks,\n     AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n     [use_external_default_callbacks=$enableval],\n     [use_external_default_callbacks=no])\n \n-AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n+dnl Test-only override of the (autodetected by the C code) \"widemul\" setting.\n+dnl Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n+AC_ARG_WITH([test-override-wide-multiply], [] ,[set_widemul=$withval], [set_widemul=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n [bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n-AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n-\n AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n [assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n@@ -170,8 +178,6 @@ AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision\n )],\n [req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n-AC_CHECK_TYPES([__int128])\n-\n AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n@@ -265,63 +271,6 @@ else\n   esac\n fi\n \n-if test x\"$req_field\" = x\"auto\"; then\n-  if test x\"set_asm\" = x\"x86_64\"; then\n-    set_field=64bit\n-  fi\n-  if test x\"$set_field\" = x; then\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" = x\"yes\"; then\n-      set_field=64bit\n-    fi\n-  fi\n-  if test x\"$set_field\" = x; then\n-    set_field=32bit\n-  fi\n-else\n-  set_field=$req_field\n-  case $set_field in\n-  64bit)\n-    if test x\"$set_asm\" != x\"x86_64\"; then\n-      SECP_INT128_CHECK\n-      if test x\"$has_int128\" != x\"yes\"; then\n-        AC_MSG_ERROR([64bit field explicitly requested but neither __int128 support or x86_64 assembly available])\n-      fi\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid field implementation selection])\n-    ;;\n-  esac\n-fi\n-\n-if test x\"$req_scalar\" = x\"auto\"; then\n-  SECP_INT128_CHECK\n-  if test x\"$has_int128\" = x\"yes\"; then\n-    set_scalar=64bit\n-  fi\n-  if test x\"$set_scalar\" = x; then\n-    set_scalar=32bit\n-  fi\n-else\n-  set_scalar=$req_scalar\n-  case $set_scalar in\n-  64bit)\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" != x\"yes\"; then\n-      AC_MSG_ERROR([64bit scalar explicitly requested but __int128 support not available])\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid scalar implementation selected])\n-    ;;\n-  esac\n-fi\n-\n if test x\"$req_bignum\" = x\"auto\"; then\n   SECP_GMP_CHECK\n   if test x\"$has_gmp\" = x\"yes\"; then\n@@ -365,16 +314,18 @@ no)\n   ;;\n esac\n \n-# select field implementation\n-case $set_field in\n-64bit)\n-  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+# select wide multiplication implementation\n+case $set_widemul in\n+int128)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT128, 1, [Define this symbol to force the use of the (unsigned) __int128 based wide multiplication implementation])\n+  ;;\n+int64)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT64, 1, [Define this symbol to force the use of the (u)int64_t based wide multiplication implementation])\n   ;;\n-32bit)\n-  AC_DEFINE(USE_FIELD_10X26, 1, [Define this symbol to use the FIELD_10X26 implementation])\n+auto)\n   ;;\n *)\n-  AC_MSG_ERROR([invalid field implementation])\n+  AC_MSG_ERROR([invalid wide multiplication implementation])\n   ;;\n esac\n \n@@ -396,19 +347,6 @@ no)\n   ;;\n esac\n \n-#select scalar implementation\n-case $set_scalar in\n-64bit)\n-  AC_DEFINE(USE_SCALAR_4X64, 1, [Define this symbol to use the 4x64 scalar implementation])\n-  ;;\n-32bit)\n-  AC_DEFINE(USE_SCALAR_8X32, 1, [Define this symbol to use the 8x32 scalar implementation])\n-  ;;\n-*)\n-  AC_MSG_ERROR([invalid scalar implementation])\n-  ;;\n-esac\n-\n #set ecmult window size\n if test x\"$req_ecmult_window\" = x\"auto\"; then\n   set_ecmult_window=15\n@@ -493,7 +431,16 @@ if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n \n-AC_C_BIGENDIAN()\n+if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_SCHNORRSIG, 1, [Define this symbol to enable the schnorrsig module])\n+  enable_module_extrakeys=yes\n+fi\n+\n+# Test if extrakeys is set after the schnorrsig module to allow the schnorrsig\n+# module to set enable_module_extrakeys=yes\n+if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_EXTRAKEYS, 1, [Define this symbol to enable the extrakeys module])\n+fi\n \n if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n@@ -508,11 +455,19 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([WARNING: experimental build])\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building extrakeys module: $enable_module_extrakeys])\n+  AC_MSG_NOTICE([Building schnorrsig module: $enable_module_schnorrsig])\n   AC_MSG_NOTICE([******])\n else\n   if test x\"$enable_module_ecdh\" = x\"yes\"; then\n     AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n   fi\n+  if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n+    AC_MSG_ERROR([extrakeys module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+    AC_MSG_ERROR([schnorrsig module is experimental. Use --enable-experimental to allow.])\n+  fi\n   if test x\"$set_asm\" = x\"arm\"; then\n     AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -531,6 +486,8 @@ AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_EXTRAKEYS], [test x\"$enable_module_extrakeys\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -550,13 +507,17 @@ echo \"  with benchmarks         = $use_benchmark\"\n echo \"  with coverage           = $enable_coverage\"\n echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\"\n+echo \"  module extrakeys        = $enable_module_extrakeys\"\n+echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  bignum                  = $set_bignum\"\n-echo \"  field                   = $set_field\"\n-echo \"  scalar                  = $set_scalar\"\n echo \"  ecmult window size      = $set_ecmult_window\"\n echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n+dnl Hide test-only options unless they're used.\n+if test x\"$set_widemul\" != xauto; then\n+echo \"  wide multiplication     = $set_widemul\"\n+fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\""
      },
      {
        "sha": "f71db4b53524cc1254190cb915f810adf3113ad7",
        "filename": "contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -112,7 +112,6 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n         return 0;\n     }\n     spos = pos;\n-    pos += slen;\n \n     /* Ignore leading zeroes in R */\n     while (rlen > 0 && input[rpos] == 0) {"
      },
      {
        "sha": "b0b55b44b8d95de61aa0de4a063b9c21d82099e0",
        "filename": "contrib/travis.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/travis.sh?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -3,10 +3,6 @@\n set -e\n set -x\n \n-if [ -n \"$HOST\" ]\n-then\n-    export USE_HOST=\"--host=$HOST\"\n-fi\n if [ \"$HOST\" = \"i686-linux-gnu\" ]\n then\n     export CC=\"$CC -m32\"\n@@ -18,9 +14,11 @@ fi\n \n ./configure \\\n     --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n-    --with-field=\"$FIELD\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" --with-scalar=\"$SCALAR\" \\\n+    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n-    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \"$EXTRAFLAGS\" \"$USE_HOST\"\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n+    --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n+    --host=\"$HOST\" $EXTRAFLAGS\n \n if [ -n \"$BUILD\" ]\n then"
      },
      {
        "sha": "2178c8e2d6f1864b563f0087c829372804f2cd78",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -134,7 +134,7 @@ typedef int (*secp256k1_nonce_function)(\n #  else\n #   define SECP256K1_API\n #  endif\n-# elif defined(__GNUC__) && defined(SECP256K1_BUILD)\n+# elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(SECP256K1_BUILD)\n #  define SECP256K1_API __attribute__ ((visibility (\"default\")))\n # else\n #  define SECP256K1_API"
      },
      {
        "sha": "0c5dff2c942b6378a871c3cbaa3e2df5461ffbc7",
        "filename": "include/secp256k1_extrakeys.h",
        "status": "added",
        "additions": 236,
        "deletions": 0,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_extrakeys.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte sequence into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again with a different secret\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, it's set to an invalid value.\n+ *               (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n+ *               NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding tweak32 to the secret key and updating the public\n+ *  key accordingly.\n+ *\n+ *  Calling this function and then secp256k1_keypair_pub results in the same\n+ *  public key as calling secp256k1_keypair_xonly_pub and then\n+ *  secp256k1_xonly_pubkey_tweak_add.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting keypair would be\n+ *           invalid (only when the tweak is the negation of the keypair's\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:       ctx: pointer to a context object initialized for verification\n+ *                   (cannot be NULL)\n+ *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n+ *                   an invalid value if this function returns 0 (cannot be\n+ *                   NULL).\n+ *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n+ *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                   uniformly random 32-byte arrays the chance of being invalid\n+ *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_EXTRAKEYS_H */"
      },
      {
        "sha": "0150cd33953ed99fd5cfea3d380408856df74827",
        "filename": "include/secp256k1_schnorrsig.h",
        "status": "added",
        "additions": 111,
        "deletions": 0,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorrsig.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,111 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n+ *           return an error.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey, the algorithm description, and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP0340/nonce\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and\n+ *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_nonce_function_hardened noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_xonly_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_SCHNORRSIG_H */"
      },
      {
        "sha": "f9d4e8e7935168a358e3f8d49901db4b08f39360",
        "filename": "src/assumptions.h",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/assumptions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/assumptions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/assumptions.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,74 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_ASSUMPTIONS_H\n+#define SECP256K1_ASSUMPTIONS_H\n+\n+#include \"util.h\"\n+\n+/* This library, like most software, relies on a number of compiler implementation defined (but not undefined)\n+   behaviours. Although the behaviours we require are essentially universal we test them specifically here to\n+   reduce the odds of experiencing an unwelcome surprise.\n+*/\n+\n+struct secp256k1_assumption_checker {\n+    /* This uses a trick to implement a static assertion in C89: a type with an array of negative size is not\n+       allowed. */\n+    int dummy_array[(\n+        /* Bytes are 8 bits. */\n+        CHAR_BIT == 8 &&\n+\n+        /* Conversions from unsigned to signed outside of the bounds of the signed type are\n+           implementation-defined. Verify that they function as reinterpreting the lower\n+           bits of the input in two's complement notation. Do this for conversions:\n+           - from uint(N)_t to int(N)_t with negative result\n+           - from uint(2N)_t to int(N)_t with negative result\n+           - from int(2N)_t to int(N)_t with negative result\n+           - from int(2N)_t to int(N)_t with positive result */\n+\n+        /* To int8_t. */\n+        ((int8_t)(uint8_t)0xAB == (int8_t)-(int8_t)0x55) &&\n+        ((int8_t)(uint16_t)0xABCD == (int8_t)-(int8_t)0x33) &&\n+        ((int8_t)(int16_t)(uint16_t)0xCDEF == (int8_t)(uint8_t)0xEF) &&\n+        ((int8_t)(int16_t)(uint16_t)0x9234 == (int8_t)(uint8_t)0x34) &&\n+\n+        /* To int16_t. */\n+        ((int16_t)(uint16_t)0xBCDE == (int16_t)-(int16_t)0x4322) &&\n+        ((int16_t)(uint32_t)0xA1B2C3D4 == (int16_t)-(int16_t)0x3C2C) &&\n+        ((int16_t)(int32_t)(uint32_t)0xC1D2E3F4 == (int16_t)(uint16_t)0xE3F4) &&\n+        ((int16_t)(int32_t)(uint32_t)0x92345678 == (int16_t)(uint16_t)0x5678) &&\n+\n+        /* To int32_t. */\n+        ((int32_t)(uint32_t)0xB2C3D4E5 == (int32_t)-(int32_t)0x4D3C2B1B) &&\n+        ((int32_t)(uint64_t)0xA123B456C789D012ULL == (int32_t)-(int32_t)0x38762FEE) &&\n+        ((int32_t)(int64_t)(uint64_t)0xC1D2E3F4A5B6C7D8ULL == (int32_t)(uint32_t)0xA5B6C7D8) &&\n+        ((int32_t)(int64_t)(uint64_t)0xABCDEF0123456789ULL == (int32_t)(uint32_t)0x23456789) &&\n+\n+        /* To int64_t. */\n+        ((int64_t)(uint64_t)0xB123C456D789E012ULL == (int64_t)-(int64_t)0x4EDC3BA928761FEEULL) &&\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+        ((int64_t)(((uint128_t)0xA1234567B8901234ULL << 64) + 0xC5678901D2345678ULL) == (int64_t)-(int64_t)0x3A9876FE2DCBA988ULL) &&\n+        (((int64_t)(int128_t)(((uint128_t)0xB1C2D3E4F5A6B7C8ULL << 64) + 0xD9E0F1A2B3C4D5E6ULL)) == (int64_t)(uint64_t)0xD9E0F1A2B3C4D5E6ULL) &&\n+        (((int64_t)(int128_t)(((uint128_t)0xABCDEF0123456789ULL << 64) + 0x0123456789ABCDEFULL)) == (int64_t)(uint64_t)0x0123456789ABCDEFULL) &&\n+\n+        /* To int128_t. */\n+        ((int128_t)(((uint128_t)0xB1234567C8901234ULL << 64) + 0xD5678901E2345678ULL) == (int128_t)(-(int128_t)0x8E1648B3F50E80DCULL * 0x8E1648B3F50E80DDULL + 0x5EA688D5482F9464ULL)) &&\n+#endif\n+\n+        /* Right shift on negative signed values is implementation defined. Verify that it\n+           acts as a right shift in two's complement with sign extension (i.e duplicating\n+           the top bit into newly added bits). */\n+        ((((int8_t)0xE8) >> 2) == (int8_t)(uint8_t)0xFA) &&\n+        ((((int16_t)0xE9AC) >> 4) == (int16_t)(uint16_t)0xFE9A) &&\n+        ((((int32_t)0x937C918A) >> 9) == (int32_t)(uint32_t)0xFFC9BE48) &&\n+        ((((int64_t)0xA8B72231DF9CF4B9ULL) >> 19) == (int64_t)(uint64_t)0xFFFFF516E4463BF3ULL) &&\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+        ((((int128_t)(((uint128_t)0xCD833A65684A0DBCULL << 64) + 0xB349312F71EA7637ULL)) >> 39) == (int128_t)(((uint128_t)0xFFFFFFFFFF9B0674ULL << 64) + 0xCAD0941B79669262ULL)) &&\n+#endif\n+    1) * 2 - 1];\n+};\n+\n+#endif /* SECP256K1_ASSUMPTIONS_H */"
      },
      {
        "sha": "83dbe6f25b0e2fabef3537e476757ce3395536a7",
        "filename": "src/basic-config.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/basic-config.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -14,23 +14,20 @@\n #undef USE_ENDOMORPHISM\n #undef USE_EXTERNAL_ASM\n #undef USE_EXTERNAL_DEFAULT_CALLBACKS\n-#undef USE_FIELD_10X26\n-#undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n #undef USE_FIELD_INV_NUM\n #undef USE_NUM_GMP\n #undef USE_NUM_NONE\n-#undef USE_SCALAR_4X64\n-#undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef USE_FORCE_WIDEMUL_INT64\n+#undef USE_FORCE_WIDEMUL_INT128\n #undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n-#define USE_FIELD_10X26 1\n-#define USE_SCALAR_8X32 1\n+#define USE_WIDEMUL_64 1\n #define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */"
      },
      {
        "sha": "9687fe4482f543893a30466e1272ce6f60a1a56e",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 114,
        "deletions": 60,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -7,6 +7,7 @@\n \n #include \"include/secp256k1.h\"\n \n+#include \"assumptions.h\"\n #include \"util.h\"\n #include \"hash_impl.h\"\n #include \"num_impl.h\"\n@@ -19,49 +20,72 @@\n #include \"secp256k1.c\"\n \n typedef struct {\n-    secp256k1_scalar scalar_x, scalar_y;\n-    secp256k1_fe fe_x, fe_y;\n-    secp256k1_ge ge_x, ge_y;\n-    secp256k1_gej gej_x, gej_y;\n+    secp256k1_scalar scalar[2];\n+    secp256k1_fe fe[4];\n+    secp256k1_ge ge[2];\n+    secp256k1_gej gej[2];\n     unsigned char data[64];\n     int wnaf[256];\n } bench_inv;\n \n void bench_setup(void* arg) {\n     bench_inv *data = (bench_inv*)arg;\n \n-    static const unsigned char init_x[32] = {\n-        0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n-        0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n-        0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n-        0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n+    static const unsigned char init[4][32] = {\n+        /* Initializer for scalar[0], fe[0], first half of data, the X coordinate of ge[0],\n+           and the (implied affine) X coordinate of gej[0]. */\n+        {\n+            0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n+            0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n+            0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n+            0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n+        },\n+        /* Initializer for scalar[1], fe[1], first half of data, the X coordinate of ge[1],\n+           and the (implied affine) X coordinate of gej[1]. */\n+        {\n+            0x82, 0x83, 0x85, 0x87, 0x8b, 0x8d, 0x81, 0x83,\n+            0x97, 0xad, 0xaf, 0xb5, 0xb9, 0xbb, 0xbf, 0xc5,\n+            0xdb, 0xdd, 0xe3, 0xe7, 0xe9, 0xef, 0xf3, 0xf9,\n+            0x11, 0x15, 0x17, 0x1b, 0x1d, 0xb1, 0xbf, 0xd3\n+        },\n+        /* Initializer for fe[2] and the Z coordinate of gej[0]. */\n+        {\n+            0x3d, 0x2d, 0xef, 0xf4, 0x25, 0x98, 0x4f, 0x5d,\n+            0xe2, 0xca, 0x5f, 0x41, 0x3f, 0x3f, 0xce, 0x44,\n+            0xaa, 0x2c, 0x53, 0x8a, 0xc6, 0x59, 0x1f, 0x38,\n+            0x38, 0x23, 0xe4, 0x11, 0x27, 0xc6, 0xa0, 0xe7\n+        },\n+        /* Initializer for fe[3] and the Z coordinate of gej[1]. */\n+        {\n+            0xbd, 0x21, 0xa5, 0xe1, 0x13, 0x50, 0x73, 0x2e,\n+            0x52, 0x98, 0xc8, 0x9e, 0xab, 0x00, 0xa2, 0x68,\n+            0x43, 0xf5, 0xd7, 0x49, 0x80, 0x72, 0xa7, 0xf3,\n+            0xd7, 0x60, 0xe6, 0xab, 0x90, 0x92, 0xdf, 0xc5\n+        }\n     };\n \n-    static const unsigned char init_y[32] = {\n-        0x82, 0x83, 0x85, 0x87, 0x8b, 0x8d, 0x81, 0x83,\n-        0x97, 0xad, 0xaf, 0xb5, 0xb9, 0xbb, 0xbf, 0xc5,\n-        0xdb, 0xdd, 0xe3, 0xe7, 0xe9, 0xef, 0xf3, 0xf9,\n-        0x11, 0x15, 0x17, 0x1b, 0x1d, 0xb1, 0xbf, 0xd3\n-    };\n-\n-    secp256k1_scalar_set_b32(&data->scalar_x, init_x, NULL);\n-    secp256k1_scalar_set_b32(&data->scalar_y, init_y, NULL);\n-    secp256k1_fe_set_b32(&data->fe_x, init_x);\n-    secp256k1_fe_set_b32(&data->fe_y, init_y);\n-    CHECK(secp256k1_ge_set_xo_var(&data->ge_x, &data->fe_x, 0));\n-    CHECK(secp256k1_ge_set_xo_var(&data->ge_y, &data->fe_y, 1));\n-    secp256k1_gej_set_ge(&data->gej_x, &data->ge_x);\n-    secp256k1_gej_set_ge(&data->gej_y, &data->ge_y);\n-    memcpy(data->data, init_x, 32);\n-    memcpy(data->data + 32, init_y, 32);\n+    secp256k1_scalar_set_b32(&data->scalar[0], init[0], NULL);\n+    secp256k1_scalar_set_b32(&data->scalar[1], init[1], NULL);\n+    secp256k1_fe_set_b32(&data->fe[0], init[0]);\n+    secp256k1_fe_set_b32(&data->fe[1], init[1]);\n+    secp256k1_fe_set_b32(&data->fe[2], init[2]);\n+    secp256k1_fe_set_b32(&data->fe[3], init[3]);\n+    CHECK(secp256k1_ge_set_xo_var(&data->ge[0], &data->fe[0], 0));\n+    CHECK(secp256k1_ge_set_xo_var(&data->ge[1], &data->fe[1], 1));\n+    secp256k1_gej_set_ge(&data->gej[0], &data->ge[0]);\n+    secp256k1_gej_rescale(&data->gej[0], &data->fe[2]);\n+    secp256k1_gej_set_ge(&data->gej[1], &data->ge[1]);\n+    secp256k1_gej_rescale(&data->gej[1], &data->fe[3]);\n+    memcpy(data->data, init[0], 32);\n+    memcpy(data->data + 32, init[1], 32);\n }\n \n void bench_scalar_add(void* arg, int iters) {\n     int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -71,7 +95,7 @@ void bench_scalar_negate(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_negate(&data->scalar_x, &data->scalar_x);\n+        secp256k1_scalar_negate(&data->scalar[0], &data->scalar[0]);\n     }\n }\n \n@@ -80,7 +104,7 @@ void bench_scalar_sqr(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_sqr(&data->scalar_x, &data->scalar_x);\n+        secp256k1_scalar_sqr(&data->scalar[0], &data->scalar[0]);\n     }\n }\n \n@@ -89,7 +113,7 @@ void bench_scalar_mul(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_mul(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_mul(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n }\n \n@@ -99,8 +123,8 @@ void bench_scalar_split(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_split_lambda(&data->scalar_x, &data->scalar_y, &data->scalar_x);\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_split_lambda(&data->scalar[0], &data->scalar[1], &data->scalar[0]);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -111,8 +135,8 @@ void bench_scalar_inverse(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_inverse(&data->scalar_x, &data->scalar_x);\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_inverse(&data->scalar[0], &data->scalar[0]);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -122,8 +146,8 @@ void bench_scalar_inverse_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_inverse_var(&data->scalar_x, &data->scalar_x);\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_inverse_var(&data->scalar[0], &data->scalar[0]);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -133,7 +157,7 @@ void bench_field_normalize(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_normalize(&data->fe_x);\n+        secp256k1_fe_normalize(&data->fe[0]);\n     }\n }\n \n@@ -142,7 +166,7 @@ void bench_field_normalize_weak(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_normalize_weak(&data->fe_x);\n+        secp256k1_fe_normalize_weak(&data->fe[0]);\n     }\n }\n \n@@ -151,7 +175,7 @@ void bench_field_mul(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_mul(&data->fe_x, &data->fe_x, &data->fe_y);\n+        secp256k1_fe_mul(&data->fe[0], &data->fe[0], &data->fe[1]);\n     }\n }\n \n@@ -160,7 +184,7 @@ void bench_field_sqr(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_sqr(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqr(&data->fe[0], &data->fe[0]);\n     }\n }\n \n@@ -169,8 +193,8 @@ void bench_field_inverse(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_inv(&data->fe_x, &data->fe_x);\n-        secp256k1_fe_add(&data->fe_x, &data->fe_y);\n+        secp256k1_fe_inv(&data->fe[0], &data->fe[0]);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n     }\n }\n \n@@ -179,8 +203,8 @@ void bench_field_inverse_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_inv_var(&data->fe_x, &data->fe_x);\n-        secp256k1_fe_add(&data->fe_x, &data->fe_y);\n+        secp256k1_fe_inv_var(&data->fe[0], &data->fe[0]);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n     }\n }\n \n@@ -190,9 +214,9 @@ void bench_field_sqrt(void* arg, int iters) {\n     secp256k1_fe t;\n \n     for (i = 0; i < iters; i++) {\n-        t = data->fe_x;\n-        j += secp256k1_fe_sqrt(&data->fe_x, &t);\n-        secp256k1_fe_add(&data->fe_x, &data->fe_y);\n+        t = data->fe[0];\n+        j += secp256k1_fe_sqrt(&data->fe[0], &t);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -202,7 +226,7 @@ void bench_group_double_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_double_var(&data->gej_x, &data->gej_x, NULL);\n+        secp256k1_gej_double_var(&data->gej[0], &data->gej[0], NULL);\n     }\n }\n \n@@ -211,7 +235,7 @@ void bench_group_add_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_add_var(&data->gej_x, &data->gej_x, &data->gej_y, NULL);\n+        secp256k1_gej_add_var(&data->gej[0], &data->gej[0], &data->gej[1], NULL);\n     }\n }\n \n@@ -220,7 +244,7 @@ void bench_group_add_affine(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_add_ge(&data->gej_x, &data->gej_x, &data->ge_y);\n+        secp256k1_gej_add_ge(&data->gej[0], &data->gej[0], &data->ge[1]);\n     }\n }\n \n@@ -229,7 +253,7 @@ void bench_group_add_affine_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_add_ge_var(&data->gej_x, &data->gej_x, &data->ge_y, NULL);\n+        secp256k1_gej_add_ge_var(&data->gej[0], &data->gej[0], &data->ge[1], NULL);\n     }\n }\n \n@@ -238,18 +262,46 @@ void bench_group_jacobi_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        j += secp256k1_gej_has_quad_y_var(&data->gej_x);\n+        j += secp256k1_gej_has_quad_y_var(&data->gej[0]);\n+        /* Vary the Y and Z coordinates of the input (the X coordinate doesn't matter to\n+           secp256k1_gej_has_quad_y_var). Note that the resulting coordinates will\n+           generally not correspond to a point on the curve, but this is not a problem\n+           for the code being benchmarked here. Adding and normalizing have less\n+           overhead than EC operations (which could guarantee the point remains on the\n+           curve). */\n+        secp256k1_fe_add(&data->gej[0].y, &data->fe[1]);\n+        secp256k1_fe_add(&data->gej[0].z, &data->fe[2]);\n+        secp256k1_fe_normalize_var(&data->gej[0].y);\n+        secp256k1_fe_normalize_var(&data->gej[0].z);\n+    }\n+    CHECK(j <= iters);\n+}\n+\n+void bench_group_to_affine_var(void* arg, int iters) {\n+    int i;\n+    bench_inv *data = (bench_inv*)arg;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ge_set_gej_var(&data->ge[1], &data->gej[0]);\n+        /* Use the output affine X/Y coordinates to vary the input X/Y/Z coordinates.\n+           Similar to bench_group_jacobi_var, this approach does not result in\n+           coordinates of points on the curve. */\n+        secp256k1_fe_add(&data->gej[0].x, &data->ge[1].y);\n+        secp256k1_fe_add(&data->gej[0].y, &data->fe[2]);\n+        secp256k1_fe_add(&data->gej[0].z, &data->ge[1].x);\n+        secp256k1_fe_normalize_var(&data->gej[0].x);\n+        secp256k1_fe_normalize_var(&data->gej[0].y);\n+        secp256k1_fe_normalize_var(&data->gej[0].z);\n     }\n-    CHECK(j == iters);\n }\n \n void bench_ecmult_wnaf(void* arg, int iters) {\n     int i, bits = 0, overflow = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        bits += secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n-        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        bits += secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar[0], WINDOW_A);\n+        overflow += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(overflow >= 0);\n     CHECK(bits <= 256*iters);\n@@ -260,8 +312,8 @@ void bench_wnaf_const(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        bits += secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n-        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        bits += secp256k1_wnaf_const(data->wnaf, &data->scalar[0], WINDOW_A, 256);\n+        overflow += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(overflow >= 0);\n     CHECK(bits <= 256*iters);\n@@ -323,14 +375,15 @@ void bench_context_sign(void* arg, int iters) {\n void bench_num_jacobi(void* arg, int iters) {\n     int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n-    secp256k1_num nx, norder;\n+    secp256k1_num nx, na, norder;\n \n-    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_get_num(&nx, &data->scalar[0]);\n     secp256k1_scalar_order_get_num(&norder);\n-    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+    secp256k1_scalar_get_num(&na, &data->scalar[1]);\n \n     for (i = 0; i < iters; i++) {\n         j += secp256k1_num_jacobi(&nx, &norder);\n+        secp256k1_num_add(&nx, &nx, &na);\n     }\n     CHECK(j <= iters);\n }\n@@ -363,6 +416,7 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);"
      },
      {
        "sha": "315f5af28e70984272483612b32c6cab358e722a",
        "filename": "src/bench_schnorrsig.c",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_schnorrsig.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,102 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    int n;\n+\n+    const secp256k1_keypair **keypairs;\n+    const unsigned char **pk;\n+    const unsigned char **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char sig[64];\n+\n+    for (i = 0; i < iters; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; i++) {\n+        secp256k1_xonly_pubkey pk;\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+int main(void) {\n+    int i;\n+    bench_schnorrsig_data data;\n+    int iters = get_iters(10000);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.keypairs = (const secp256k1_keypair **)malloc(iters * sizeof(secp256k1_keypair *));\n+    data.pk = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n+    data.msgs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n+    data.sigs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = (unsigned char *)malloc(32);\n+        unsigned char *sig = (unsigned char *)malloc(64);\n+        secp256k1_keypair *keypair = (secp256k1_keypair *)malloc(sizeof(*keypair));\n+        unsigned char *pk_char = (unsigned char *)malloc(32);\n+        secp256k1_xonly_pubkey pk;\n+        msg[0] = sk[0] = i;\n+        msg[1] = sk[1] = i >> 8;\n+        msg[2] = sk[2] = i >> 16;\n+        msg[3] = sk[3] = i >> 24;\n+        memset(&msg[4], 'm', 28);\n+        memset(&sk[4], 's', 28);\n+\n+        data.keypairs[i] = keypair;\n+        data.pk[i] = pk_char;\n+        data.msgs[i] = msg;\n+        data.sigs[i] = sig;\n+\n+        CHECK(secp256k1_keypair_create(data.ctx, keypair, sk));\n+        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, keypair, NULL, NULL));\n+        CHECK(secp256k1_keypair_xonly_pub(data.ctx, &pk, NULL, keypair));\n+        CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n+    }\n+\n+    run_benchmark(\"schnorrsig_sign\", bench_schnorrsig_sign, NULL, NULL, (void *) &data, 10, iters);\n+    run_benchmark(\"schnorrsig_verify\", bench_schnorrsig_verify, NULL, NULL, (void *) &data, 10, iters);\n+\n+    for (i = 0; i < iters; i++) {\n+        free((void *)data.keypairs[i]);\n+        free((void *)data.pk[i]);\n+        free((void *)data.msgs[i]);\n+        free((void *)data.sigs[i]);\n+    }\n+    free(data.keypairs);\n+    free(data.pk);\n+    free(data.msgs);\n+    free(data.sigs);\n+\n+    secp256k1_context_destroy(data.ctx);\n+    return 0;\n+}"
      },
      {
        "sha": "55b61e49372cbc68d57464b4e59fd1cc72eacf6d",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -105,16 +105,22 @@ static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w\n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n     do {\n-        int sign;\n         int even;\n \n         /* 4.1 4.4 */\n         u = secp256k1_scalar_shr_int(&s, w);\n         /* 4.2 */\n         even = ((u & 1) == 0);\n-        sign = 2 * (u_last > 0) - 1;\n-        u += sign * even;\n-        u_last -= sign * even * (1 << w);\n+        /* In contrast to the original algorithm, u_last is always > 0 and\n+         * therefore we do not need to check its sign. In particular, it's easy\n+         * to see that u_last is never < 0 because u is never < 0. Moreover,\n+         * u_last is never = 0 because u is never even after a loop\n+         * iteration. The same holds analogously for the initial value of\n+         * u_last (in the first loop iteration). */\n+        VERIFY_CHECK(u_last > 0);\n+        VERIFY_CHECK((u_last & 1) == 1);\n+        u += even;\n+        u_last -= even * (1 << w);\n \n         /* 4.3, adapted for global sign change */\n         wnaf[word++] = u_last * global_sign;\n@@ -202,7 +208,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double_nonzero(r, r);\n+            secp256k1_gej_double(r, r);\n         }\n \n         n = wnaf_1[i];"
      },
      {
        "sha": "aca1fb72c5084e99b44056d5dd979d5252889743",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -22,16 +22,16 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26.h\"\n-#elif defined(USE_FIELD_5X52)\n+#include \"util.h\"\n+\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n-#include \"util.h\"\n-\n /** Normalize a field element. This brings the field element to a canonical representation, reduces\n  *  its magnitude to 1, and reduces it modulo field size `p`.\n  */"
      },
      {
        "sha": "6a068484c28a0d386fd62cfad107e3ca1b15ae02",
        "filename": "src/field_5x52.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -46,4 +46,10 @@ typedef struct {\n     (d6) | (((uint64_t)(d7)) << 32) \\\n }}\n \n+#define SECP256K1_FE_STORAGE_CONST_GET(d) \\\n+    (uint32_t)(d.n[3] >> 32), (uint32_t)d.n[3], \\\n+    (uint32_t)(d.n[2] >> 32), (uint32_t)d.n[2], \\\n+    (uint32_t)(d.n[1] >> 32), (uint32_t)d.n[1], \\\n+    (uint32_t)(d.n[0] >> 32), (uint32_t)d.n[0]\n+\n #endif /* SECP256K1_FIELD_REPR_H */"
      },
      {
        "sha": "18e4d2f30ea66450e9de4020d6e7a26d337e9985",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -14,12 +14,12 @@\n #include \"util.h\"\n #include \"num.h\"\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26_impl.h\"\n-#elif defined(USE_FIELD_5X52)\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52_impl.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26_impl.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {"
      },
      {
        "sha": "8b7729aee4c8d4c15f82fa8e2592a136d59cabad",
        "filename": "src/gen_context.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_context.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -13,6 +13,7 @@\n #include \"basic-config.h\"\n \n #include \"include/secp256k1.h\"\n+#include \"assumptions.h\"\n #include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\""
      },
      {
        "sha": "6185be052db065e4c42e085e1889dbae5aa10429",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -95,8 +95,8 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n /** Check whether a group element's y coordinate is a quadratic residue. */\n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n \n-/** Set r equal to the double of a, a cannot be infinity. Constant time. */\n-static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a);\n+/** Set r equal to the double of a. Constant time. */\n+static void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a);\n \n /** Set r equal to the double of a. If rzr is not-NULL this sets *rzr such that r->z == a->z * *rzr (where infinity means an implicit z = 0). */\n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "ccd93d3483ab6e464049889cc7b06b1239a0e1db",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -303,7 +303,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n-static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a) {\n+static SECP256K1_INLINE void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a) {\n     /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n      *\n      * Note that there is an implementation described at\n@@ -313,8 +313,7 @@ static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, cons\n      */\n     secp256k1_fe t1,t2,t3,t4;\n \n-    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n-    r->infinity = 0;\n+    r->infinity = a->infinity;\n \n     secp256k1_fe_mul(&r->z, &a->z, &a->y);\n     secp256k1_fe_mul_int(&r->z, 2);       /* Z' = 2*Y*Z (2) */\n@@ -363,7 +362,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n         secp256k1_fe_mul_int(rzr, 2);\n     }\n \n-    secp256k1_gej_double_nonzero(r, a);\n+    secp256k1_gej_double(r, a);\n }\n \n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {\n@@ -400,7 +399,7 @@ static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, cons\n             if (rzr != NULL) {\n                 secp256k1_fe_set_int(rzr, 0);\n             }\n-            r->infinity = 1;\n+            secp256k1_gej_set_infinity(r);\n         }\n         return;\n     }\n@@ -450,7 +449,7 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, c\n             if (rzr != NULL) {\n                 secp256k1_fe_set_int(rzr, 0);\n             }\n-            r->infinity = 1;\n+            secp256k1_gej_set_infinity(r);\n         }\n         return;\n     }\n@@ -509,7 +508,7 @@ static void secp256k1_gej_add_zinv_var(secp256k1_gej *r, const secp256k1_gej *a,\n         if (secp256k1_fe_normalizes_to_zero_var(&i)) {\n             secp256k1_gej_double_var(r, a, NULL);\n         } else {\n-            r->infinity = 1;\n+            secp256k1_gej_set_infinity(r);\n         }\n         return;\n     }"
      },
      {
        "sha": "409772587bebb3a88976e129508165fba18593c5",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_HASH_IMPL_H\n \n #include \"hash.h\"\n+#include \"util.h\"\n \n #include <stdlib.h>\n #include <stdint.h>\n@@ -27,9 +28,9 @@\n     (h) = t1 + t2; \\\n } while(0)\n \n-#ifdef WORDS_BIGENDIAN\n+#if defined(SECP256K1_BIG_ENDIAN)\n #define BE32(x) (x)\n-#else\n+#elif defined(SECP256K1_LITTLE_ENDIAN)\n #define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n #endif\n \n@@ -163,6 +164,19 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. */\n+static void secp256k1_sha256_initialize_tagged(secp256k1_sha256 *hash, const unsigned char *tag, size_t taglen) {\n+    unsigned char buf[32];\n+    secp256k1_sha256_initialize(hash);\n+    secp256k1_sha256_write(hash, tag, taglen);\n+    secp256k1_sha256_finalize(hash, buf);\n+\n+    secp256k1_sha256_initialize(hash);\n+    secp256k1_sha256_write(hash, buf, 32);\n+    secp256k1_sha256_write(hash, buf, 32);\n+}\n+\n static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256 *hash, const unsigned char *key, size_t keylen) {\n     size_t n;\n     unsigned char rkey[64];"
      },
      {
        "sha": "8515f92e7a072a54a10e2648d563bf2821ca16d3",
        "filename": "src/modules/extrakeys/Makefile.am.include",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/extrakeys/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/extrakeys/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/Makefile.am.include?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,3 @@\n+include_HEADERS += include/secp256k1_extrakeys.h\n+noinst_HEADERS += src/modules/extrakeys/tests_impl.h\n+noinst_HEADERS += src/modules/extrakeys/main_impl.h"
      },
      {
        "sha": "d3192153558c31cfec5b601d2edeb40eb3358cc2",
        "filename": "src/modules/extrakeys/main_impl.h",
        "status": "added",
        "additions": 248,
        "deletions": 0,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/main_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,248 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+/** Keeps a group element as is if it has an even Y and otherwise negates it.\n+ *  y_parity is set to 0 in the former case and to 1 in the latter case.\n+ *  Requires that the coordinates of r are normalized. */\n+static int secp256k1_extrakeys_ge_even_y(secp256k1_ge *r) {\n+    int y_parity = 0;\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(r));\n+\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+        y_parity = 1;\n+    }\n+    return y_parity;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *pk_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+    int tmp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    tmp = secp256k1_extrakeys_ge_even_y(&pk);\n+    if (pk_parity != NULL) {\n+        *pk_parity = tmp;\n+    }\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweaked_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, tweaked_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == tweaked_pk_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    ret = secp256k1_scalar_set_b32_seckey(sk, &keypair->data[0]);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return ret;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+    int tmp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    tmp = secp256k1_extrakeys_ge_even_y(&pk);\n+    if (pk_parity != NULL) {\n+        *pk_parity = tmp;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int y_parity;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    y_parity = secp256k1_extrakeys_ge_even_y(&pk);\n+    if (y_parity == 1) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);\n+\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_keypair_save(keypair, &sk, &pk);\n+    }\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+#endif"
      },
      {
        "sha": "fc9d40eda1141502b4983e08a03264bfb75eda0d",
        "filename": "src/modules/extrakeys/tests_impl.h",
        "status": "added",
        "additions": 524,
        "deletions": 0,
        "changes": 524,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,524 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n+#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+static secp256k1_context* api_test_context(int flags, int *ecount) {\n+    secp256k1_context *ctx0 = secp256k1_context_create(flags);\n+    secp256k1_context_set_error_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    secp256k1_context_set_illegal_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    return ctx0;\n+}\n+\n+void test_xonly_pubkey(void) {\n+    secp256k1_pubkey pk;\n+    secp256k1_xonly_pubkey xonly_pk, xonly_pk_tmp;\n+    secp256k1_ge pk1;\n+    secp256k1_ge pk2;\n+    secp256k1_fe y;\n+    unsigned char sk[32];\n+    unsigned char xy_sk[32];\n+    unsigned char buf32[32];\n+    unsigned char ones32[32];\n+    unsigned char zeros64[64] = { 0 };\n+    int pk_parity;\n+    int i;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    secp256k1_rand256(sk);\n+    memset(ones32, 0xFF, 32);\n+    secp256k1_rand256(xy_sk);\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+\n+    /* Test xonly_pubkey_from_pubkey */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(sign, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, NULL, &pk_parity, &pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, NULL) == 0);\n+    CHECK(ecount == 2);\n+    memset(&pk, 0, sizeof(pk));\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Choose a secret key such that the resulting pubkey and xonly_pubkey match. */\n+    memset(sk, 0, sizeof(sk));\n+    sk[0] = 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&pk, &xonly_pk, sizeof(pk)) == 0);\n+    CHECK(pk_parity == 0);\n+\n+    /* Choose a secret key such that pubkey and xonly_pubkey are each others\n+     * negation. */\n+    sk[0] = 2;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n+    CHECK(pk_parity == 1);\n+    secp256k1_pubkey_load(ctx, &pk1, &pk);\n+    secp256k1_pubkey_load(ctx, &pk2, (secp256k1_pubkey *) &xonly_pk);\n+    CHECK(secp256k1_fe_equal(&pk1.x, &pk2.x) == 1);\n+    secp256k1_fe_negate(&y, &pk2.y, 1);\n+    CHECK(secp256k1_fe_equal(&pk1.y, &y) == 1);\n+\n+    /* Test xonly_pubkey_serialize and xonly_pubkey_parse */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &xonly_pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n+    CHECK(memcmp(buf32, zeros64, 32) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n+         * special casing. */\n+        secp256k1_xonly_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp));\n+        CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk_tmp) == 0);\n+    }\n+    /* pubkey_load called illegal callback */\n+    CHECK(ecount == 3);\n+\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &xonly_pk) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_parse(none, NULL, buf32) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, NULL) == 0);\n+    CHECK(ecount == 2);\n+\n+    /* Serialization and parse roundtrip */\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, buf32) == 1);\n+    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n+\n+    /* Test parsing invalid field elements */\n+    memset(&xonly_pk, 1, sizeof(xonly_pk));\n+    /* Overflowing field element */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, ones32) == 0);\n+    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    memset(&xonly_pk, 1, sizeof(xonly_pk));\n+    /* There's no point with x-coordinate 0 on secp256k1 */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, zeros64) == 0);\n+    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    /* If a random 32-byte string can not be parsed with ec_pubkey_parse\n+     * (because interpreted as X coordinate it does not correspond to a point on\n+     * the curve) then xonly_pubkey_parse should fail as well. */\n+    for (i = 0; i < count; i++) {\n+        unsigned char rand33[33];\n+        secp256k1_rand256(&rand33[1]);\n+        rand33[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+        if (!secp256k1_ec_pubkey_parse(ctx, &pk, rand33, 33)) {\n+            memset(&xonly_pk, 1, sizeof(xonly_pk));\n+            CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 0);\n+            CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+        } else {\n+            CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 1);\n+        }\n+    }\n+    CHECK(ecount == 2);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void test_xonly_pubkey_tweak(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    int pk_parity;\n+    unsigned char tweak[32];\n+    int i;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    /* NULL internal_xonly_pk zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* NULL tweak zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+\n+    /* Invalid tweak zeroes the output_pk */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+\n+    /* A zero tweak is fine */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, zeros64) == 1);\n+\n+    /* Fails if the resulting key was infinity */\n+    for (i = 0; i < count; i++) {\n+        secp256k1_scalar scalar_tweak;\n+        /* Because sk may be negated before adding, we need to try with tweak =\n+         * sk as well as tweak = -sk. */\n+        secp256k1_scalar_set_b32(&scalar_tweak, sk, NULL);\n+        secp256k1_scalar_negate(&scalar_tweak, &scalar_tweak);\n+        secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n+        CHECK((secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, sk) == 0)\n+              || (secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0));\n+        CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    }\n+\n+    /* Invalid pk with a valid tweak */\n+    memset(&internal_xonly_pk, 0, sizeof(internal_xonly_pk));\n+    secp256k1_rand256(tweak);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void test_xonly_pubkey_tweak_check(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    secp256k1_xonly_pubkey output_xonly_pk;\n+    unsigned char output_pk32[32];\n+    unsigned char buf32[32];\n+    int pk_parity;\n+    unsigned char tweak[32];\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    /* invalid pk_parity value */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    memset(tweak, 1, sizeof(tweak));\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+\n+    /* Wrong pk_parity */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, !pk_parity, &internal_xonly_pk, tweak) == 0);\n+    /* Wrong public key */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &internal_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+\n+    /* Overflowing tweak not allowed */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(ecount == 5);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+/* Starts with an initial pubkey and recursively creates N_PUBKEYS - 1\n+ * additional pubkeys by calling tweak_add. Then verifies every tweak starting\n+ * from the last pubkey. */\n+#define N_PUBKEYS 32\n+void test_xonly_pubkey_tweak_recursive(void) {\n+    unsigned char sk[32];\n+    secp256k1_pubkey pk[N_PUBKEYS];\n+    unsigned char pk_serialized[32];\n+    unsigned char tweak[N_PUBKEYS - 1][32];\n+    int i;\n+\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk) == 1);\n+    /* Add tweaks */\n+    for (i = 0; i < N_PUBKEYS - 1; i++) {\n+        secp256k1_xonly_pubkey xonly_pk;\n+        memset(tweak[i], i + 1, sizeof(tweak[i]));\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, NULL, &pk[i]) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &pk[i + 1], &xonly_pk, tweak[i]) == 1);\n+    }\n+\n+    /* Verify tweaks */\n+    for (i = N_PUBKEYS - 1; i > 0; i--) {\n+        secp256k1_xonly_pubkey xonly_pk;\n+        int pk_parity;\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk[i]) == 1);\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, pk_serialized, &xonly_pk) == 1);\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, NULL, &pk[i - 1]) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, pk_serialized, pk_parity, &xonly_pk, tweak[i - 1]) == 1);\n+    }\n+}\n+#undef N_PUBKEYS\n+\n+void test_keypair(void) {\n+    unsigned char sk[32];\n+    unsigned char zeros96[96] = { 0 };\n+    unsigned char overflows[32];\n+    secp256k1_keypair keypair;\n+    secp256k1_pubkey pk, pk_tmp;\n+    secp256k1_xonly_pubkey xonly_pk, xonly_pk_tmp;\n+    int pk_parity, pk_parity_tmp;\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    CHECK(sizeof(zeros96) == sizeof(keypair));\n+    memset(overflows, 0xFF, sizeof(overflows));\n+\n+    /* Test keypair_create */\n+    ecount = 0;\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(none, &keypair, sk) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_create(verify, &keypair, sk) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_create(sign, NULL, sk) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, NULL) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(ecount == 4);\n+\n+    /* Invalid secret key */\n+    CHECK(secp256k1_keypair_create(sign, &keypair, zeros96) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, overflows) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+\n+    /* Test keypair_pub */\n+    ecount = 0;\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n+    CHECK(secp256k1_keypair_pub(none, NULL, &keypair) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_pub(none, &pk, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+\n+    /* Using an invalid keypair is fine for keypair_pub */\n+    memset(&keypair, 0, sizeof(keypair));\n+    CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n+    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+\n+    /* keypair holds the same pubkey as pubkey_create */\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_pub(none, &pk_tmp, &keypair) == 1);\n+    CHECK(memcmp(&pk, &pk_tmp, sizeof(pk)) == 0);\n+\n+    /** Test keypair_xonly_pub **/\n+    ecount = 0;\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, NULL, &pk_parity, &keypair) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, NULL, &keypair) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    /* Using an invalid keypair will set the xonly_pk to 0 (first reset\n+     * xonly_pk). */\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n+    memset(&keypair, 0, sizeof(keypair));\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 0);\n+    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    CHECK(ecount == 3);\n+\n+    /** keypair holds the same xonly pubkey as pubkey_create **/\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk_tmp, &pk_parity_tmp, &keypair) == 1);\n+    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n+    CHECK(pk_parity == pk_parity_tmp);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void test_keypair_add(void) {\n+    unsigned char sk[32];\n+    secp256k1_keypair keypair;\n+    unsigned char overflows[32];\n+    unsigned char zeros96[96] = { 0 };\n+    unsigned char tweak[32];\n+    int i;\n+    int ecount = 0;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    CHECK(sizeof(zeros96) == sizeof(keypair));\n+    secp256k1_rand256(sk);\n+    secp256k1_rand256(tweak);\n+    memset(overflows, 0xFF, 32);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, NULL, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n+    CHECK(ecount == 4);\n+    /* This does not set the keypair to zeroes */\n+    CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) != 0);\n+\n+    /* Invalid tweak zeroes the keypair */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, overflows) == 0);\n+    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+\n+    /* A zero tweak is fine */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, zeros96) == 1);\n+\n+    /* Fails if the resulting keypair was (sk=0, pk=infinity) */\n+    for (i = 0; i < count; i++) {\n+        secp256k1_scalar scalar_tweak;\n+        secp256k1_keypair keypair_tmp;\n+        secp256k1_rand256(sk);\n+        CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+        memcpy(&keypair_tmp, &keypair, sizeof(keypair));\n+        /* Because sk may be negated before adding, we need to try with tweak =\n+         * sk as well as tweak = -sk. */\n+        secp256k1_scalar_set_b32(&scalar_tweak, sk, NULL);\n+        secp256k1_scalar_negate(&scalar_tweak, &scalar_tweak);\n+        secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n+        CHECK((secp256k1_keypair_xonly_tweak_add(ctx, &keypair, sk) == 0)\n+              || (secp256k1_keypair_xonly_tweak_add(ctx, &keypair_tmp, tweak) == 0));\n+        CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) == 0\n+              || memcmp(&keypair_tmp, zeros96, sizeof(keypair_tmp)) == 0);\n+    }\n+\n+    /* Invalid keypair with a valid tweak */\n+    memset(&keypair, 0, sizeof(keypair));\n+    secp256k1_rand256(tweak);\n+    ecount = 0;\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+    /* Only seckey part of keypair invalid */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    memset(&keypair, 0, 32);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n+    CHECK(ecount == 2);\n+    /* Only pubkey part of keypair invalid */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    memset(&keypair.data[32], 0, 64);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Check that the keypair_tweak_add implementation is correct */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    for (i = 0; i < count; i++) {\n+        secp256k1_xonly_pubkey internal_pk;\n+        secp256k1_xonly_pubkey output_pk;\n+        secp256k1_pubkey output_pk_xy;\n+        secp256k1_pubkey output_pk_expected;\n+        unsigned char pk32[32];\n+        int pk_parity;\n+\n+        secp256k1_rand256(tweak);\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n+        CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, tweak) == 1);\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &output_pk, &pk_parity, &keypair) == 1);\n+\n+        /* Check that it passes xonly_pubkey_tweak_add_check */\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, pk32, &output_pk) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, pk32, pk_parity, &internal_pk, tweak) == 1);\n+\n+        /* Check that the resulting pubkey matches xonly_pubkey_tweak_add */\n+        CHECK(secp256k1_keypair_pub(ctx, &output_pk_xy, &keypair) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk_expected, &internal_pk, tweak) == 1);\n+        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+\n+        /* Check that the secret key in the keypair is tweaked correctly */\n+        CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, &keypair.data[0]) == 1);\n+        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+    }\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void run_extrakeys_tests(void) {\n+    /* xonly key test cases */\n+    test_xonly_pubkey();\n+    test_xonly_pubkey_tweak();\n+    test_xonly_pubkey_tweak_check();\n+    test_xonly_pubkey_tweak_recursive();\n+\n+    /* keypair tests */\n+    test_keypair();\n+    test_keypair_add();\n+}\n+\n+#endif"
      },
      {
        "sha": "a82bafe43fda64027b97a8e4d66dac35b4a3e96e",
        "filename": "src/modules/schnorrsig/Makefile.am.include",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/schnorrsig/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/schnorrsig/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/Makefile.am.include?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_schnorrsig.h\n+noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_schnorrsig\n+bench_schnorrsig_SOURCES = src/bench_schnorrsig.c\n+bench_schnorrsig_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif"
      },
      {
        "sha": "a0218f881aaaaa37eff1050b4e9d00c56a3430f2",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "added",
        "additions": 238,
        "deletions": 0,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);\n+    secp256k1_gej_set_ge(&pkj, &pk);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+\n+    secp256k1_ge_set_gej_var(&r, &rj);\n+    if (secp256k1_ge_is_infinity(&r)) {\n+        return 0;\n+    }\n+\n+    secp256k1_fe_normalize_var(&r.y);\n+    return !secp256k1_fe_is_odd(&r.y) &&\n+           secp256k1_fe_equal_var(&rx, &r.x);\n+}\n+\n+#endif"
      },
      {
        "sha": "88d8f5640403ed36efe2343c7e557a867f00da86",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "added",
        "additions": 806,
        "deletions": 0,
        "changes": 806,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,806 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+/* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n+ * bytes) changes the hash function\n+ */\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    unsigned char nonces[2][32];\n+    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    secp256k1_rand_flip(args[n_flip], n_bytes);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(memcmp(nonces[0], nonces[1], 32) != 0);\n+}\n+\n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2) {\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    CHECK(sha1->bytes == sha2->bytes);\n+    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+}\n+\n+void run_nonce_function_bip340_tests(void) {\n+    unsigned char tag[13] = \"BIP0340/nonce\";\n+    unsigned char aux_tag[11] = \"BIP0340/aux\";\n+    unsigned char algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256 sha_optimized;\n+    unsigned char nonce[32];\n+    unsigned char msg[32];\n+    unsigned char key[32];\n+    unsigned char pk[32];\n+    unsigned char aux_rand[32];\n+    unsigned char *args[5];\n+    int i;\n+\n+    /* Check that hash initialized by\n+     * secp256k1_nonce_function_bip340_sha256_tagged has the expected\n+     * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, tag, sizeof(tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+   /* Check that hash initialized by\n+    * secp256k1_nonce_function_bip340_sha256_tagged_aux has the expected\n+    * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, aux_tag, sizeof(aux_tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+    secp256k1_rand256(msg);\n+    secp256k1_rand256(key);\n+    secp256k1_rand256(pk);\n+    secp256k1_rand256(aux_rand);\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = msg;\n+    args[1] = key;\n+    args[2] = pk;\n+    args[3] = algo16;\n+    args[4] = aux_rand;\n+    for (i = 0; i < count; i++) {\n+        nonce_function_bip340_bitflip(args, 0, 32);\n+        nonce_function_bip340_bitflip(args, 1, 32);\n+        nonce_function_bip340_bitflip(args, 2, 32);\n+        /* Flip algo16 special case \"BIP0340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        /* Flip algo16 again */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        nonce_function_bip340_bitflip(args, 4, 32);\n+    }\n+\n+    /* NULL algo16 is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n+    /* Empty algo16 is fine */\n+    memset(algo16, 0x00, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* algo16 with terminating null bytes is fine */\n+    algo16[1] = 65;\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* Other algo16 is fine */\n+    memset(algo16, 0xFF, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+\n+    /* NULL aux_rand argument is allowed. */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+}\n+\n+void test_schnorrsig_api(void) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    secp256k1_keypair keypairs[3];\n+    secp256k1_keypair invalid_keypair = { 0 };\n+    secp256k1_xonly_pubkey pk[3];\n+    secp256k1_xonly_pubkey zero_pk;\n+    unsigned char sig[64];\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[0], sk1) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[1], sk2) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[2], sk3) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[0], NULL, &keypairs[0]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[1], NULL, &keypairs[1]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[2], NULL, &keypairs[2]) == 1);\n+    memset(&zero_pk, 0, sizeof(zero_pk));\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL, NULL) == 0);\n+    CHECK(ecount == 6);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Checks that hash initialized by secp256k1_schnorrsig_sha256_tagged has the\n+ * expected state. */\n+void test_schnorrsig_sha256_tagged(void) {\n+    char tag[17] = \"BIP0340/challenge\";\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256 sha_optimized;\n+\n+    secp256k1_sha256_initialize_tagged(&sha, (unsigned char *) tag, sizeof(tag));\n+    secp256k1_schnorrsig_sha256_tagged(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg, const unsigned char *expected_sig) {\n+    unsigned char sig[64];\n+    secp256k1_keypair keypair;\n+    secp256k1_xonly_pubkey pk, pk_expected;\n+\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n+    CHECK(memcmp(sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+    CHECK(memcmp(&pk, &pk_expected, sizeof(pk)) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch (TODO) return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig, int expected) {\n+    secp256k1_xonly_pubkey pk;\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk, pk_serialized));\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, &pk));\n+}\n+\n+/* Test vectors according to BIP-340 (\"Schnorr Signatures for secp256k1\"). See\n+ * https://github.com/bitcoin/bips/blob/master/bip-0340/test-vectors.csv. */\n+void test_schnorrsig_bip_vectors(void) {\n+    {\n+        /* Test vector 0 */\n+        const unsigned char sk[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        };\n+        const unsigned char pk[32] = {\n+            0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10,\n+            0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29,\n+            0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0,\n+            0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9\n+        };\n+        unsigned char aux_rand[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char msg[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig[64] = {\n+            0xE9, 0x07, 0x83, 0x1F, 0x80, 0x84, 0x8D, 0x10,\n+            0x69, 0xA5, 0x37, 0x1B, 0x40, 0x24, 0x10, 0x36,\n+            0x4B, 0xDF, 0x1C, 0x5F, 0x83, 0x07, 0xB0, 0x08,\n+            0x4C, 0x55, 0xF1, 0xCE, 0x2D, 0xCA, 0x82, 0x15,\n+            0x25, 0xF6, 0x6A, 0x4A, 0x85, 0xEA, 0x8B, 0x71,\n+            0xE4, 0x82, 0xA7, 0x4F, 0x38, 0x2D, 0x2C, 0xE5,\n+            0xEB, 0xEE, 0xE8, 0xFD, 0xB2, 0x17, 0x2F, 0x47,\n+            0x7D, 0xF4, 0x90, 0x0D, 0x31, 0x05, 0x36, 0xC0\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        unsigned char aux_rand[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x68, 0x96, 0xBD, 0x60, 0xEE, 0xAE, 0x29, 0x6D,\n+            0xB4, 0x8A, 0x22, 0x9F, 0xF7, 0x1D, 0xFE, 0x07,\n+            0x1B, 0xDE, 0x41, 0x3E, 0x6D, 0x43, 0xF9, 0x17,\n+            0xDC, 0x8D, 0xCF, 0x8C, 0x78, 0xDE, 0x33, 0x41,\n+            0x89, 0x06, 0xD1, 0x1A, 0xC9, 0x76, 0xAB, 0xCC,\n+            0xB2, 0x0B, 0x09, 0x12, 0x92, 0xBF, 0xF4, 0xEA,\n+            0x89, 0x7E, 0xFC, 0xB6, 0x39, 0xEA, 0x87, 0x1C,\n+            0xFA, 0x95, 0xF6, 0xDE, 0x33, 0x9E, 0x4B, 0x0A\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC9\n+        };\n+        const unsigned char pk[32] = {\n+            0xDD, 0x30, 0x8A, 0xFE, 0xC5, 0x77, 0x7E, 0x13,\n+            0x12, 0x1F, 0xA7, 0x2B, 0x9C, 0xC1, 0xB7, 0xCC,\n+            0x01, 0x39, 0x71, 0x53, 0x09, 0xB0, 0x86, 0xC9,\n+            0x60, 0xE1, 0x8F, 0xD9, 0x69, 0x77, 0x4E, 0xB8\n+        };\n+        unsigned char aux_rand[32] = {\n+            0xC8, 0x7A, 0xA5, 0x38, 0x24, 0xB4, 0xD7, 0xAE,\n+            0x2E, 0xB0, 0x35, 0xA2, 0xB5, 0xBB, 0xBC, 0xCC,\n+            0x08, 0x0E, 0x76, 0xCD, 0xC6, 0xD1, 0x69, 0x2C,\n+            0x4B, 0x0B, 0x62, 0xD7, 0x98, 0xE6, 0xD9, 0x06\n+        };\n+        const unsigned char msg[32] = {\n+            0x7E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig[64] = {\n+            0x58, 0x31, 0xAA, 0xEE, 0xD7, 0xB4, 0x4B, 0xB7,\n+            0x4E, 0x5E, 0xAB, 0x94, 0xBA, 0x9D, 0x42, 0x94,\n+            0xC4, 0x9B, 0xCF, 0x2A, 0x60, 0x72, 0x8D, 0x8B,\n+            0x4C, 0x20, 0x0F, 0x50, 0xDD, 0x31, 0x3C, 0x1B,\n+            0xAB, 0x74, 0x58, 0x79, 0xA5, 0xAD, 0x95, 0x4A,\n+            0x72, 0xC4, 0x5A, 0x91, 0xC3, 0xA5, 0x1D, 0x3C,\n+            0x7A, 0xDE, 0xA9, 0x8D, 0x82, 0xF8, 0x48, 0x1E,\n+            0x0E, 0x1E, 0x03, 0x67, 0x4A, 0x6F, 0x3F, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk[32] = {\n+            0x0B, 0x43, 0x2B, 0x26, 0x77, 0x93, 0x73, 0x81,\n+            0xAE, 0xF0, 0x5B, 0xB0, 0x2A, 0x66, 0xEC, 0xD0,\n+            0x12, 0x77, 0x30, 0x62, 0xCF, 0x3F, 0xA2, 0x54,\n+            0x9E, 0x44, 0xF5, 0x8E, 0xD2, 0x40, 0x17, 0x10\n+        };\n+        const unsigned char pk[32] = {\n+            0x25, 0xD1, 0xDF, 0xF9, 0x51, 0x05, 0xF5, 0x25,\n+            0x3C, 0x40, 0x22, 0xF6, 0x28, 0xA9, 0x96, 0xAD,\n+            0x3A, 0x0D, 0x95, 0xFB, 0xF2, 0x1D, 0x46, 0x8A,\n+            0x1B, 0x33, 0xF8, 0xC1, 0x60, 0xD8, 0xF5, 0x17\n+        };\n+        unsigned char aux_rand[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+        };\n+        const unsigned char msg[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+        };\n+        const unsigned char sig[64] = {\n+            0x7E, 0xB0, 0x50, 0x97, 0x57, 0xE2, 0x46, 0xF1,\n+            0x94, 0x49, 0x88, 0x56, 0x51, 0x61, 0x1C, 0xB9,\n+            0x65, 0xEC, 0xC1, 0xA1, 0x87, 0xDD, 0x51, 0xB6,\n+            0x4F, 0xDA, 0x1E, 0xDC, 0x96, 0x37, 0xD5, 0xEC,\n+            0x97, 0x58, 0x2B, 0x9C, 0xB1, 0x3D, 0xB3, 0x93,\n+            0x37, 0x05, 0xB3, 0x2B, 0xA9, 0x82, 0xAF, 0x5A,\n+            0xF2, 0x5F, 0xD7, 0x88, 0x81, 0xEB, 0xB3, 0x27,\n+            0x71, 0xFC, 0x59, 0x22, 0xEF, 0xC6, 0x6E, 0xA3\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk[32] = {\n+            0xD6, 0x9C, 0x35, 0x09, 0xBB, 0x99, 0xE4, 0x12,\n+            0xE6, 0x8B, 0x0F, 0xE8, 0x54, 0x4E, 0x72, 0x83,\n+            0x7D, 0xFA, 0x30, 0x74, 0x6D, 0x8B, 0xE2, 0xAA,\n+            0x65, 0x97, 0x5F, 0x29, 0xD2, 0x2D, 0xC7, 0xB9\n+        };\n+        const unsigned char msg[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x76, 0xAF, 0xB1, 0x54, 0x8A, 0xF6, 0x03, 0xB3,\n+            0xEB, 0x45, 0xC9, 0xF8, 0x20, 0x7D, 0xEE, 0x10,\n+            0x60, 0xCB, 0x71, 0xC0, 0x4E, 0x80, 0xF5, 0x93,\n+            0x06, 0x0B, 0x07, 0xD2, 0x83, 0x08, 0xD7, 0xF4\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk[32] = {\n+            0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77, 0x50,\n+            0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF, 0x21,\n+            0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76, 0x87,\n+            0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A, 0x34\n+        };\n+        secp256k1_xonly_pubkey pk_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_xonly_pubkey_parse(ctx, &pk_parsed, pk));\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0xFF, 0xF9, 0x7B, 0xD5, 0x75, 0x5E, 0xEE, 0xA4,\n+            0x20, 0x45, 0x3A, 0x14, 0x35, 0x52, 0x35, 0xD3,\n+            0x82, 0xF6, 0x47, 0x2F, 0x85, 0x68, 0xA1, 0x8B,\n+            0x2F, 0x05, 0x7A, 0x14, 0x60, 0x29, 0x75, 0x56,\n+            0x3C, 0xC2, 0x79, 0x44, 0x64, 0x0A, 0xC6, 0x07,\n+            0xCD, 0x10, 0x7A, 0xE1, 0x09, 0x23, 0xD9, 0xEF,\n+            0x7A, 0x73, 0xC6, 0x43, 0xE1, 0x66, 0xBE, 0x5E,\n+            0xBE, 0xAF, 0xA3, 0x4B, 0x1A, 0xC5, 0x53, 0xE2\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x1F, 0xA6, 0x2E, 0x33, 0x1E, 0xDB, 0xC2, 0x1C,\n+            0x39, 0x47, 0x92, 0xD2, 0xAB, 0x11, 0x00, 0xA7,\n+            0xB4, 0x32, 0xB0, 0x13, 0xDF, 0x3F, 0x6F, 0xF4,\n+            0xF9, 0x9F, 0xCB, 0x33, 0xE0, 0xE1, 0x51, 0x5F,\n+            0x28, 0x89, 0x0B, 0x3E, 0xDB, 0x6E, 0x71, 0x89,\n+            0xB6, 0x30, 0x44, 0x8B, 0x51, 0x5C, 0xE4, 0xF8,\n+            0x62, 0x2A, 0x95, 0x4C, 0xFE, 0x54, 0x57, 0x35,\n+            0xAA, 0xEA, 0x51, 0x34, 0xFC, 0xCD, 0xB2, 0xBD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x6C, 0xFF, 0x5C, 0x3B, 0xA8, 0x6C, 0x69, 0xEA,\n+            0x4B, 0x73, 0x76, 0xF3, 0x1A, 0x9B, 0xCB, 0x4F,\n+            0x74, 0xC1, 0x97, 0x60, 0x89, 0xB2, 0xD9, 0x96,\n+            0x3D, 0xA2, 0xE5, 0x54, 0x3E, 0x17, 0x77, 0x69,\n+            0x96, 0x17, 0x64, 0xB3, 0xAA, 0x9B, 0x2F, 0xFC,\n+            0xB6, 0xEF, 0x94, 0x7B, 0x68, 0x87, 0xA2, 0x26,\n+            0xE8, 0xD7, 0xC9, 0x3E, 0x00, 0xC5, 0xED, 0x0C,\n+            0x18, 0x34, 0xFF, 0x0D, 0x0C, 0x2E, 0x6D, 0xA6\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x12, 0x3D, 0xDA, 0x83, 0x28, 0xAF, 0x9C, 0x23,\n+            0xA9, 0x4C, 0x1F, 0xEE, 0xCF, 0xD1, 0x23, 0xBA,\n+            0x4F, 0xB7, 0x34, 0x76, 0xF0, 0xD5, 0x94, 0xDC,\n+            0xB6, 0x5C, 0x64, 0x25, 0xBD, 0x18, 0x60, 0x51\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x76, 0x15, 0xFB, 0xAF, 0x5A, 0xE2, 0x88, 0x64,\n+            0x01, 0x3C, 0x09, 0x97, 0x42, 0xDE, 0xAD, 0xB4,\n+            0xDB, 0xA8, 0x7F, 0x11, 0xAC, 0x67, 0x54, 0xF9,\n+            0x37, 0x80, 0xD5, 0xA1, 0x83, 0x7C, 0xF1, 0x97\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x69, 0xE8, 0x9B, 0x4C, 0x55, 0x64, 0xD0, 0x03,\n+            0x49, 0x10, 0x6B, 0x84, 0x97, 0x78, 0x5D, 0xD7,\n+            0xD1, 0xD7, 0x13, 0xA8, 0xAE, 0x82, 0xB3, 0x2F,\n+            0xA7, 0x9D, 0x5F, 0x7F, 0xC4, 0x07, 0xD3, 0x9B\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x69, 0xE8, 0x9B, 0x4C, 0x55, 0x64, 0xD0, 0x03,\n+            0x49, 0x10, 0x6B, 0x84, 0x97, 0x78, 0x5D, 0xD7,\n+            0xD1, 0xD7, 0x13, 0xA8, 0xAE, 0x82, 0xB3, 0x2F,\n+            0xA7, 0x9D, 0x5F, 0x7F, 0xC4, 0x07, 0xD3, 0x9B\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x6C, 0xFF, 0x5C, 0x3B, 0xA8, 0x6C, 0x69, 0xEA,\n+            0x4B, 0x73, 0x76, 0xF3, 0x1A, 0x9B, 0xCB, 0x4F,\n+            0x74, 0xC1, 0x97, 0x60, 0x89, 0xB2, 0xD9, 0x96,\n+            0x3D, 0xA2, 0xE5, 0x54, 0x3E, 0x17, 0x77, 0x69,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 14 */\n+        const unsigned char pk[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30\n+        };\n+        secp256k1_xonly_pubkey pk_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_xonly_pubkey_parse(ctx, &pk_parsed, pk));\n+    }\n+}\n+\n+/* Nonce function that returns constant 0 */\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) xonly_pk32;\n+    (void) algo16;\n+    (void) data;\n+    (void) nonce32;\n+    return 0;\n+}\n+\n+/* Nonce function that sets nonce to 0 */\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) xonly_pk32;\n+    (void) algo16;\n+    (void) data;\n+\n+    memset(nonce32, 0, 32);\n+    return 1;\n+}\n+\n+/* Nonce function that sets nonce to 0xFF...0xFF */\n+static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) xonly_pk32;\n+    (void) algo16;\n+    (void) data;\n+\n+    memset(nonce32, 0xFF, 32);\n+    return 1;\n+}\n+\n+void test_schnorrsig_sign(void) {\n+    unsigned char sk[32];\n+    secp256k1_keypair keypair;\n+    const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n+    unsigned char sig[64];\n+    unsigned char zeros64[64] = { 0 };\n+\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+\n+    /* Test different nonce functions */\n+    memset(sig, 1, sizeof(sig));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n+    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    memset(&sig, 1, sizeof(sig));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n+    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n+    CHECK(memcmp(sig, zeros64, sizeof(sig)) != 0);\n+}\n+\n+#define N_SIGS 3\n+/* Creates N_SIGS valid signatures and verifies them with verify and\n+ * verify_batch (TODO). Then flips some bits and checks that verification now\n+ * fails. */\n+void test_schnorrsig_sign_verify(void) {\n+    unsigned char sk[32];\n+    unsigned char msg[N_SIGS][32];\n+    unsigned char sig[N_SIGS][64];\n+    size_t i;\n+    secp256k1_keypair keypair;\n+    secp256k1_xonly_pubkey pk;\n+    secp256k1_scalar s;\n+\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+\n+    for (i = 0; i < N_SIGS; i++) {\n+        secp256k1_rand256(msg[i]);\n+        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n+    }\n+\n+    {\n+        /* Flip a few bits in the signature and in the message and check that\n+         * verify and verify_batch (TODO) fail */\n+        size_t sig_idx = secp256k1_rand_int(N_SIGS);\n+        size_t byte_idx = secp256k1_rand_int(32);\n+        unsigned char xorbyte = secp256k1_rand_int(254)+1;\n+        sig[sig_idx][byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        sig[sig_idx][byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        sig[sig_idx][32+byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        sig[sig_idx][32+byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+\n+        /* Check that above bitflips have been reversed correctly */\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+    }\n+\n+    /* Test overflowing s */\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    memset(&sig[0][32], 0xFF, 32);\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+\n+    /* Test negative s */\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    secp256k1_scalar_set_b32(&s, &sig[0][32], NULL);\n+    secp256k1_scalar_negate(&s, &s);\n+    secp256k1_scalar_get_b32(&sig[0][32], &s);\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+}\n+#undef N_SIGS\n+\n+void test_schnorrsig_taproot(void) {\n+    unsigned char sk[32];\n+    secp256k1_keypair keypair;\n+    secp256k1_xonly_pubkey internal_pk;\n+    unsigned char internal_pk_bytes[32];\n+    secp256k1_xonly_pubkey output_pk;\n+    unsigned char output_pk_bytes[32];\n+    unsigned char tweak[32];\n+    int pk_parity;\n+    unsigned char msg[32];\n+    unsigned char sig[64];\n+\n+    /* Create output key */\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n+    /* In actual taproot the tweak would be hash of internal_pk */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, tweak, &internal_pk) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, tweak) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &output_pk, &pk_parity, &keypair) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk_bytes, &output_pk) == 1);\n+\n+    /* Key spend */\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    /* Verify key spend */\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &output_pk) == 1);\n+\n+    /* Script spend */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, internal_pk_bytes, &internal_pk) == 1);\n+    /* Verify script spend */\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &internal_pk, internal_pk_bytes) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk_bytes, pk_parity, &internal_pk, tweak) == 1);\n+}\n+\n+void run_schnorrsig_tests(void) {\n+    int i;\n+    run_nonce_function_bip340_tests();\n+\n+    test_schnorrsig_api();\n+    test_schnorrsig_sha256_tagged();\n+    test_schnorrsig_bip_vectors();\n+    for (i = 0; i < count; i++) {\n+        test_schnorrsig_sign();\n+        test_schnorrsig_sign_verify();\n+    }\n+    test_schnorrsig_taproot();\n+}\n+\n+#endif"
      },
      {
        "sha": "95d3e326c9c6f0f6959b90b30f191de988b509eb",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -8,19 +8,20 @@\n #define SECP256K1_SCALAR_H\n \n #include \"num.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n #endif\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n /** Clear a scalar to prevent the leak of sensitive data. */"
      },
      {
        "sha": "7f3992786101cf0f603aa447deb673afcdde125f",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -192,9 +192,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -207,7 +207,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -221,32 +221,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a));         \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "f8c7fa7efaba92980d6f74599c93b877887504be",
        "filename": "src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -271,9 +271,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -286,7 +286,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -300,32 +300,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a)); \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "2ec04b1ae9aa27c26ee1a6483a90ce3b292b2a16",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -16,12 +16,12 @@\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low_impl.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64_impl.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32_impl.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);"
      },
      {
        "sha": "b205620224b6bb339b09ee79e6347e5303aefee3",
        "filename": "src/scratch_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -11,7 +11,7 @@\n #include \"scratch.h\"\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n-    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    const size_t base_alloc = ROUND_TO_ALIGN(sizeof(secp256k1_scratch));\n     void *alloc = checked_malloc(error_callback, base_alloc + size);\n     secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n@@ -60,6 +60,10 @@ static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_c\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n+    /* Ensure that multiplication will not wrap around */\n+    if (ALIGNMENT > 1 && objects > SIZE_MAX/(ALIGNMENT - 1)) {\n+        return 0;\n+    }\n     if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n         return 0;\n     }\n@@ -68,7 +72,14 @@ static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_c\n \n static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size = ROUND_TO_ALIGN(size);\n+    size_t rounded_size;\n+\n+    rounded_size = ROUND_TO_ALIGN(size);\n+    /* Check that rounding did not wrap around */\n+    if (rounded_size < size) {\n+        return NULL;\n+    }\n+    size = rounded_size;\n \n     if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");"
      },
      {
        "sha": "eaafb3a21d4f8494f77a489f4d37ca5292bc653f",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 53,
        "deletions": 25,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -7,6 +7,7 @@\n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_preallocated.h\"\n \n+#include \"assumptions.h\"\n #include \"util.h\"\n #include \"num_impl.h\"\n #include \"field_impl.h\"\n@@ -19,6 +20,7 @@\n #include \"eckey_impl.h\"\n #include \"hash_impl.h\"\n #include \"scratch_impl.h\"\n+#include \"selftest.h\"\n \n #if defined(VALGRIND)\n # include <valgrind/memcheck.h>\n@@ -117,6 +119,9 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     size_t prealloc_size;\n     secp256k1_context* ret;\n \n+    if (!secp256k1_selftest()) {\n+        secp256k1_callback_call(&default_error_callback, \"self test failed\");\n+    }\n     VERIFY_CHECK(prealloc != NULL);\n     prealloc_size = secp256k1_context_preallocated_size(flags);\n     ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n@@ -226,7 +231,7 @@ void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scr\n  *  of the software. This is setup for use with valgrind but could be substituted with\n  *  the appropriate instrumentation for other analysis tools.\n  */\n-static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, void *p, size_t len) {\n+static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, const void *p, size_t len) {\n #if defined(VALGRIND)\n     if (EXPECT(ctx->declassify,0)) VALGRIND_MAKE_MEM_DEFINED(p, len);\n #else\n@@ -291,7 +296,7 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n \n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n-    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n+    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33u : 65u));\n     len = *outputlen;\n     *outputlen = 0;\n     ARG_CHECK(output != NULL);\n@@ -548,26 +553,33 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey) {\n+static int secp256k1_ec_pubkey_create_helper(const secp256k1_ecmult_gen_context *ecmult_gen_ctx, secp256k1_scalar *seckey_scalar, secp256k1_ge *p, const unsigned char *seckey) {\n     secp256k1_gej pj;\n+    int ret;\n+\n+    ret = secp256k1_scalar_set_b32_seckey(seckey_scalar, seckey);\n+    secp256k1_scalar_cmov(seckey_scalar, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(ecmult_gen_ctx, &pj, seckey_scalar);\n+    secp256k1_ge_set_gej(p, &pj);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey) {\n     secp256k1_ge p;\n-    secp256k1_scalar sec;\n+    secp256k1_scalar seckey_scalar;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(seckey != NULL);\n \n-    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_one, !ret);\n-\n-    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n-    secp256k1_ge_set_gej(&p, &pj);\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey);\n     secp256k1_pubkey_save(pubkey, &p);\n     memczero(pubkey, sizeof(*pubkey), !ret);\n \n-    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_clear(&seckey_scalar);\n     return ret;\n }\n \n@@ -605,50 +617,58 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n     secp256k1_scalar term;\n+    int overflow = 0;\n+    int ret = 0;\n+\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar sec;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-\n-    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n-    secp256k1_scalar_clear(&term);\n     return ret;\n }\n \n int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak);\n }\n \n+static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak) {\n+    secp256k1_scalar term;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n+}\n+\n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n     secp256k1_ge p;\n-    secp256k1_scalar term;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n-    ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n+    ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak);\n     if (ret) {\n-        if (secp256k1_eckey_pubkey_tweak_add(&ctx->ecmult_ctx, &p, &term)) {\n-            secp256k1_pubkey_save(pubkey, &p);\n-        } else {\n-            ret = 0;\n-        }\n+        secp256k1_pubkey_save(pubkey, &p);\n     }\n \n     return ret;\n@@ -741,3 +761,11 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif\n+\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+# include \"modules/extrakeys/main_impl.h\"\n+#endif\n+\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/main_impl.h\"\n+#endif"
      },
      {
        "sha": "885983aa209997e47dd1ad92303b2d48ae182d64",
        "filename": "src/selftest.h",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/selftest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/selftest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/selftest.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -0,0 +1,32 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_SELFTEST_H\n+#define SECP256K1_SELFTEST_H\n+\n+#include \"hash.h\"\n+\n+#include <string.h>\n+\n+static int secp256k1_selftest_sha256(void) {\n+    static const char *input63 = \"For this sample, this 63-byte string will be used as input data\";\n+    static const unsigned char output32[32] = {\n+        0xf0, 0x8a, 0x78, 0xcb, 0xba, 0xee, 0x08, 0x2b, 0x05, 0x2a, 0xe0, 0x70, 0x8f, 0x32, 0xfa, 0x1e,\n+        0x50, 0xc5, 0xc4, 0x21, 0xaa, 0x77, 0x2b, 0xa5, 0xdb, 0xb4, 0x06, 0xa2, 0xea, 0x6b, 0xe3, 0x42,\n+    };\n+    unsigned char out[32];\n+    secp256k1_sha256 hasher;\n+    secp256k1_sha256_initialize(&hasher);\n+    secp256k1_sha256_write(&hasher, (const unsigned char*)input63, 63);\n+    secp256k1_sha256_finalize(&hasher, out);\n+    return memcmp(out, output32, 32) == 0;\n+}\n+\n+static int secp256k1_selftest(void) {\n+    return secp256k1_selftest_sha256();\n+}\n+\n+#endif /* SECP256K1_SELFTEST_H */"
      },
      {
        "sha": "bcbe15a6f1f1cd2bb5e12aa69e46a2238bc7116e",
        "filename": "src/testrand.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/testrand.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/testrand.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -35,4 +35,7 @@ static void secp256k1_rand256_test(unsigned char *b32);\n /** Generate pseudorandom bytes with long sequences of zero and one bits. */\n static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len);\n \n+/** Flip a single random bit in a byte array */\n+static void secp256k1_rand_flip(unsigned char *b, size_t len);\n+\n #endif /* SECP256K1_TESTRAND_H */"
      },
      {
        "sha": "dfb658d9c6451a18f1fe895a400a26231f5b1c03",
        "filename": "src/testrand_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand_impl.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -107,4 +107,8 @@ static void secp256k1_rand256_test(unsigned char *b32) {\n     secp256k1_rand_bytes_test(b32, 32);\n }\n \n+static void secp256k1_rand_flip(unsigned char *b, size_t len) {\n+    b[secp256k1_rand_int(len)] ^= (1 << secp256k1_rand_int(8));\n+}\n+\n #endif /* SECP256K1_TESTRAND_IMPL_H */"
      },
      {
        "sha": "4780e9319bd343423affbe68883c20f735b26023",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 102,
        "deletions": 11,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -182,8 +182,10 @@ void run_context_tests(int use_prealloc) {\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n     secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount2);\n-    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    /* set error callback (to a function that still aborts in case malloc() fails in secp256k1_context_clone() below) */\n+    secp256k1_context_set_error_callback(sign, secp256k1_default_illegal_callback_fn, NULL);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n \n     /* check if sizes for cloning are consistent */\n     CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n@@ -239,7 +241,8 @@ void run_context_tests(int use_prealloc) {\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n     /* And that it resets back to default. */\n     secp256k1_context_set_error_callback(sign, NULL, NULL);\n     CHECK(vrfy->error_callback.fn == sign->error_callback.fn);\n@@ -361,8 +364,8 @@ void run_scratch_tests(void) {\n     CHECK(scratch->alloc_size != 0);\n     CHECK(scratch->alloc_size % ALIGNMENT == 0);\n \n-    /* Allocating another 500 bytes fails */\n-    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    /* Allocating another 501 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 501) == NULL);\n     CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n     CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n     CHECK(scratch->alloc_size != 0);\n@@ -395,6 +398,18 @@ void run_scratch_tests(void) {\n     secp256k1_scratch_space_destroy(none, scratch);\n     CHECK(ecount == 5);\n \n+    /* Test that large integers do not wrap around in a bad way */\n+    scratch = secp256k1_scratch_space_create(none, 1000);\n+    /* Try max allocation with a large number of objects. Only makes sense if\n+     * ALIGNMENT is greater than 1 because otherwise the objects take no extra\n+     * space. */\n+    CHECK(ALIGNMENT <= 1 || !secp256k1_scratch_max_allocation(&none->error_callback, scratch, (SIZE_MAX / (ALIGNMENT - 1)) + 1));\n+    /* Try allocating SIZE_MAX to test wrap around which only happens if\n+     * ALIGNMENT > 1, otherwise it returns NULL anyway because the scratch\n+     * space is too small. */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, SIZE_MAX) == NULL);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+\n     /* cleanup */\n     secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n@@ -2215,6 +2230,9 @@ void test_ge(void) {\n                 /* Normal doubling. */\n                 secp256k1_gej_double_var(&resj, &gej[i2], NULL);\n                 ge_equals_gej(&ref, &resj);\n+                /* Constant-time doubling. */\n+                secp256k1_gej_double(&resj, &gej[i2]);\n+                ge_equals_gej(&ref, &resj);\n             }\n \n             /* Test adding opposites. */\n@@ -2300,6 +2318,39 @@ void test_ge(void) {\n     free(zinv);\n }\n \n+\n+void test_intialized_inf(void) {\n+    secp256k1_ge p;\n+    secp256k1_gej pj, npj, infj1, infj2, infj3;\n+    secp256k1_fe zinv;\n+\n+    /* Test that adding P+(-P) results in a fully initalized infinity*/\n+    random_group_element_test(&p);\n+    secp256k1_gej_set_ge(&pj, &p);\n+    secp256k1_gej_neg(&npj, &pj);\n+\n+    secp256k1_gej_add_var(&infj1, &pj, &npj, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&infj1));\n+    CHECK(secp256k1_fe_is_zero(&infj1.x));\n+    CHECK(secp256k1_fe_is_zero(&infj1.y));\n+    CHECK(secp256k1_fe_is_zero(&infj1.z));\n+\n+    secp256k1_gej_add_ge_var(&infj2, &npj, &p, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&infj2));\n+    CHECK(secp256k1_fe_is_zero(&infj2.x));\n+    CHECK(secp256k1_fe_is_zero(&infj2.y));\n+    CHECK(secp256k1_fe_is_zero(&infj2.z));\n+\n+    secp256k1_fe_set_int(&zinv, 1);\n+    secp256k1_gej_add_zinv_var(&infj3, &npj, &p, &zinv);\n+    CHECK(secp256k1_gej_is_infinity(&infj3));\n+    CHECK(secp256k1_fe_is_zero(&infj3.x));\n+    CHECK(secp256k1_fe_is_zero(&infj3.y));\n+    CHECK(secp256k1_fe_is_zero(&infj3.z));\n+\n+\n+}\n+\n void test_add_neg_y_diff_x(void) {\n     /* The point of this test is to check that we can add two points\n      * whose y-coordinates are negatives of each other but whose x\n@@ -2373,6 +2424,7 @@ void run_ge(void) {\n         test_ge();\n     }\n     test_add_neg_y_diff_x();\n+    test_intialized_inf();\n }\n \n void test_ec_combine(void) {\n@@ -2967,14 +3019,16 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n     secp256k1_scalar szero;\n-    secp256k1_scalar sc[32];\n-    secp256k1_ge pt[32];\n+    secp256k1_scalar sc;\n+    secp256k1_ge pt;\n     secp256k1_gej r;\n     ecmult_multi_data data;\n     secp256k1_scratch *scratch_empty;\n \n-    data.sc = sc;\n-    data.pt = pt;\n+    random_group_element_test(&pt);\n+    random_scalar_order(&sc);\n+    data.sc = &sc;\n+    data.pt = &pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n@@ -3232,6 +3286,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     int skew;\n     int bits = 256;\n     secp256k1_scalar num = *number;\n+    secp256k1_scalar scalar_skew;\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n@@ -3262,7 +3317,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n     /* Skew num because when encoding numbers as odd we use an offset */\n-    secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n+    secp256k1_scalar_set_int(&scalar_skew, 1 << (skew == 2));\n+    secp256k1_scalar_add(&num, &num, &scalar_skew);\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3374,13 +3430,32 @@ void run_wnaf(void) {\n     int i;\n     secp256k1_scalar n = {{0}};\n \n+    test_constant_wnaf(&n, 4);\n     /* Sanity check: 1 and 2 are the smallest odd and even numbers and should\n      *               have easier-to-diagnose failure modes  */\n     n.d[0] = 1;\n     test_constant_wnaf(&n, 4);\n     n.d[0] = 2;\n     test_constant_wnaf(&n, 4);\n-    /* Test 0 */\n+    /* Test -1, because it's a special case in wnaf_const */\n+    n = secp256k1_scalar_one;\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test -2, which may not lead to overflows in wnaf_const */\n+    secp256k1_scalar_add(&n, &secp256k1_scalar_one, &secp256k1_scalar_one);\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test (1/2) - 1 = 1/-2 and 1/2 = (1/-2) + 1\n+       as corner cases of negation handling in wnaf_const */\n+    secp256k1_scalar_inverse(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    secp256k1_scalar_add(&n, &n, &secp256k1_scalar_one);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test 0 for fixed wnaf */\n     test_fixed_wnaf_small();\n     /* Random tests */\n     for (i = 0; i < count; i++) {\n@@ -5277,6 +5352,14 @@ void run_ecdsa_openssl(void) {\n # include \"modules/recovery/tests_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+# include \"modules/extrakeys/tests_impl.h\"\n+#endif\n+\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/tests_impl.h\"\n+#endif\n+\n void run_memczero_test(void) {\n     unsigned char buf1[6] = {1, 2, 3, 4, 5, 6};\n     unsigned char buf2[sizeof(buf1)];\n@@ -5583,6 +5666,14 @@ int main(int argc, char **argv) {\n     run_recovery_tests();\n #endif\n \n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+    run_extrakeys_tests();\n+#endif\n+\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+    run_schnorrsig_tests();\n+#endif\n+\n     /* util tests */\n     run_memczero_test();\n "
      },
      {
        "sha": "681ed80bd0bc4ef2108313195ad89a3dd54e46b5",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -22,6 +22,7 @@\n #endif\n \n #include \"include/secp256k1.h\"\n+#include \"assumptions.h\"\n #include \"group.h\"\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n@@ -141,10 +142,8 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     /* Check doubling */\n     for (i = 0; i < order; i++) {\n         secp256k1_gej tmp;\n-        if (i > 0) {\n-            secp256k1_gej_double_nonzero(&tmp, &groupj[i]);\n-            ge_equals_gej(&group[(2 * i) % order], &tmp);\n-        }\n+        secp256k1_gej_double(&tmp, &groupj[i]);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n         ge_equals_gej(&group[(2 * i) % order], &tmp);\n     }"
      },
      {
        "sha": "a5cbe03ef52198544e5448888978a6bab772106a",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 51,
        "deletions": 7,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -170,13 +170,35 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n # define I64uFORMAT \"llu\"\n #endif\n \n-#if defined(HAVE___INT128)\n-# if defined(__GNUC__)\n-#  define SECP256K1_GNUC_EXT __extension__\n-# else\n-#  define SECP256K1_GNUC_EXT\n+#if defined(__GNUC__)\n+# define SECP256K1_GNUC_EXT __extension__\n+#else\n+# define SECP256K1_GNUC_EXT\n+#endif\n+\n+/* If SECP256K1_{LITTLE,BIG}_ENDIAN is not explicitly provided, infer from various other system macros. */\n+#if !defined(SECP256K1_LITTLE_ENDIAN) && !defined(SECP256K1_BIG_ENDIAN)\n+/* Inspired by https://github.com/rofl0r/endianness.h/blob/9853923246b065a3b52d2c43835f3819a62c7199/endianness.h#L52L73 */\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \\\n+     defined(_X86_) || defined(__x86_64__) || defined(__i386__) || \\\n+     defined(__i486__) || defined(__i586__) || defined(__i686__) || \\\n+     defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL) || \\\n+     defined(__ARMEL__) || defined(__AARCH64EL__) || \\\n+     (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__ == 1) || \\\n+     (defined(_LITTLE_ENDIAN) && _LITTLE_ENDIAN == 1) || \\\n+     defined(_M_IX86) || defined(_M_AMD64) || defined(_M_ARM) /* MSVC */\n+#  define SECP256K1_LITTLE_ENDIAN\n # endif\n-SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \\\n+     defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB) || \\\n+     defined(__MICROBLAZEEB__) || defined(__ARMEB__) || defined(__AARCH64EB__) || \\\n+     (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__ == 1) || \\\n+     (defined(_BIG_ENDIAN) && _BIG_ENDIAN == 1)\n+#  define SECP256K1_BIG_ENDIAN\n+# endif\n+#endif\n+#if defined(SECP256K1_LITTLE_ENDIAN) == defined(SECP256K1_BIG_ENDIAN)\n+# error Please make sure that either SECP256K1_LITTLE_ENDIAN or SECP256K1_BIG_ENDIAN is set, see src/util.h.\n #endif\n \n /* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n@@ -197,15 +219,37 @@ static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n     unsigned int mask0, mask1, r_masked, a_masked;\n+    /* Access flag with a volatile-qualified lvalue.\n+       This prevents clang from figuring out (after inlining) that flag can\n+       take only be 0 or 1, which leads to variable time code. */\n+    volatile int vflag = flag;\n+\n     /* Casting a negative int to unsigned and back to int is implementation defined behavior */\n     VERIFY_CHECK(*r >= 0 && *a >= 0);\n \n-    mask0 = (unsigned int)flag + ~0u;\n+    mask0 = (unsigned int)vflag + ~0u;\n     mask1 = ~mask0;\n     r_masked = ((unsigned int)*r & mask0);\n     a_masked = ((unsigned int)*a & mask1);\n \n     *r = (int)(r_masked | a_masked);\n }\n \n+/* If USE_FORCE_WIDEMUL_{INT128,INT64} is set, use that wide multiplication implementation.\n+ * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n+ */\n+#if defined(USE_FORCE_WIDEMUL_INT128)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#elif defined(USE_FORCE_WIDEMUL_INT64)\n+# define SECP256K1_WIDEMUL_INT64 1\n+#elif defined(__SIZEOF_INT128__)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#else\n+# define SECP256K1_WIDEMUL_INT64 1\n+#endif\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+SECP256K1_GNUC_EXT typedef __int128 int128_t;\n+#endif\n+\n #endif /* SECP256K1_UTIL_H */"
      },
      {
        "sha": "e676a8326cdfea98dd9457eeb874172694e827e2",
        "filename": "src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c1a7648131c5deec9704ee9acd00ec1820b9ce/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/valgrind_ctime_test.c?ref=b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <valgrind/memcheck.h>\n #include \"include/secp256k1.h\"\n+#include \"assumptions.h\"\n #include \"util.h\"\n \n #if ENABLE_MODULE_ECDH\n@@ -16,6 +17,14 @@\n # include \"include/secp256k1_recovery.h\"\n #endif\n \n+#if ENABLE_MODULE_EXTRAKEYS\n+# include \"include/secp256k1_extrakeys.h\"\n+#endif\n+\n+#if ENABLE_MODULE_SCHNORRSIG\n+#include \"include/secp256k1_schnorrsig.h\"\n+#endif\n+\n int main(void) {\n     secp256k1_context* ctx;\n     secp256k1_ecdsa_signature signature;\n@@ -32,6 +41,9 @@ int main(void) {\n     secp256k1_ecdsa_recoverable_signature recoverable_signature;\n     int recid;\n #endif\n+#if ENABLE_MODULE_EXTRAKEYS\n+    secp256k1_keypair keypair;\n+#endif\n \n     if (!RUNNING_ON_VALGRIND) {\n         fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n@@ -49,7 +61,9 @@ int main(void) {\n         msg[i] = i + 1;\n     }\n \n-    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_DECLASSIFY);\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN\n+                                   | SECP256K1_CONTEXT_VERIFY\n+                                   | SECP256K1_CONTEXT_DECLASSIFY);\n \n     /* Test keygen. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n@@ -114,6 +128,30 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret);\n \n+    /* Test keypair_create and keypair_xonly_tweak_add. */\n+#if ENABLE_MODULE_EXTRAKEYS\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* The tweak is not treated as a secret in keypair_tweak_add */\n+    VALGRIND_MAKE_MEM_DEFINED(msg, 32);\n+    ret = secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n+#if ENABLE_MODULE_SCHNORRSIG\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n     secp256k1_context_destroy(ctx);\n     return 0;\n }"
      }
    ]
  },
  {
    "sha": "894fb33f4c1b24667891f7d2aff9f486177b1173",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTRmYjMzZjRjMWIyNDY2Nzg5MWY3ZDJhZmY5ZjQ4NjE3N2IxMTcz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T19:44:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T19:44:08Z"
      },
      "message": "Update src/secp256k1 subtree to upstream libsecp256k1",
      "tree": {
        "sha": "d40b6f9b501a4a387eb07a630d61712bb9193cef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d40b6f9b501a4a387eb07a630d61712bb9193cef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/894fb33f4c1b24667891f7d2aff9f486177b1173",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/894fb33f4c1b24667891f7d2aff9f486177b1173",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/894fb33f4c1b24667891f7d2aff9f486177b1173",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/894fb33f4c1b24667891f7d2aff9f486177b1173/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f2d9934381bf89f1746f13cc5f86ae199eaa52bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2d9934381bf89f1746f13cc5f86ae199eaa52bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f2d9934381bf89f1746f13cc5f86ae199eaa52bb"
      },
      {
        "sha": "b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9c1a7648131c5deec9704ee9acd00ec1820b9ce"
      }
    ],
    "stats": {
      "total": 3212,
      "additions": 2928,
      "deletions": 284
    },
    "files": [
      {
        "sha": "ccdef02b29486e95257cb6c05fa1c1fa1101c2be",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -1,9 +1,9 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n-bench_schnorr_verify\n bench_recover\n bench_internal\n tests\n@@ -31,6 +31,8 @@ libtool\n *.lo\n *.o\n *~\n+*.log\n+*.trs\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h"
      },
      {
        "sha": "e1a88c40510a22ae86f3c8a46b80cc02ac912575",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 15,
        "deletions": 11,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -17,19 +17,19 @@ compiler:\n   - gcc\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n+    - WIDEMUL=auto  BIGNUM=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n-    - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n-    - SCALAR=64bit\n-    - FIELD=64bit     RECOVERY=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n-    - FIELD=64bit                       ASM=x86_64\n-    - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     ENDOMORPHISM=yes\n+    - WIDEMUL=int64   RECOVERY=yes\n+    - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int64   ENDOMORPHISM=yes\n+    - WIDEMUL=int128\n+    - WIDEMUL=int128  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int128                    ASM=x86_64\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ASM=x86_64\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck CTIMETEST= BENCH=\n     - CPPFLAGS=-DDETERMINISTIC\n@@ -83,6 +83,10 @@ matrix:\n             - valgrind\n             - libtool-bin\n             - libc6-dbg:i386\n+    # S390x build (big endian system)\n+    - compiler: gcc\n+      env: HOST=s390x-unknown-linux-gnu ECDH=yes RECOVERY=yes EXPERIMENTAL=yes CTIMETEST=\n+      arch: s390x\n \n # We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n # because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes."
      },
      {
        "sha": "023fa6067fbbaadf86e8653f5184ef89ad88de0e",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -34,9 +34,11 @@ noinst_HEADERS += src/field_5x52.h\n noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n+noinst_HEADERS += src/assumptions.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/scratch.h\n noinst_HEADERS += src/scratch_impl.h\n+noinst_HEADERS += src/selftest.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n noinst_HEADERS += src/hash.h\n@@ -99,7 +101,7 @@ if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n@@ -152,3 +154,11 @@ endif\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif\n+\n+if ENABLE_MODULE_EXTRAKEYS\n+include src/modules/extrakeys/Makefile.am.include\n+endif\n+\n+if ENABLE_MODULE_SCHNORRSIG\n+include src/modules/schnorrsig/Makefile.am.include\n+endif"
      },
      {
        "sha": "a300e1c5eb9b1376c82b1f5d557d56be5708546f",
        "filename": "src/secp256k1/TODO",
        "status": "removed",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f2d9934381bf89f1746f13cc5f86ae199eaa52bb/src/secp256k1/TODO",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f2d9934381bf89f1746f13cc5f86ae199eaa52bb/src/secp256k1/TODO",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/TODO?ref=f2d9934381bf89f1746f13cc5f86ae199eaa52bb",
        "patch": "@@ -1,3 +0,0 @@\n-* Unit tests for fieldelem/groupelem, including ones intended to\n-  trigger fieldelem's boundary cases.\n-* Complete constant-time operations for signing/keygen"
      },
      {
        "sha": "57595f4499d8e10646e6cbb56417a831803786cd",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -1,8 +1,3 @@\n-dnl libsecp25k1 helper checks\n-AC_DEFUN([SECP_INT128_CHECK],[\n-has_int128=$ac_cv_type___int128\n-])\n-\n dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)"
      },
      {
        "sha": "6fe8984f4d87e620d1594a3d4511bf8c16e31e9d",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 48,
        "deletions": 87,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -136,20 +136,28 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(module_extrakeys,\n+    AS_HELP_STRING([--enable-module-extrakeys],[enable extrakeys module (experimental)]),\n+    [enable_module_extrakeys=$enableval],\n+    [enable_module_extrakeys=no])\n+\n+AC_ARG_ENABLE(module_schnorrsig,\n+    AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module (experimental)]),\n+    [enable_module_schnorrsig=$enableval],\n+    [enable_module_schnorrsig=no])\n+\n AC_ARG_ENABLE(external_default_callbacks,\n     AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n     [use_external_default_callbacks=$enableval],\n     [use_external_default_callbacks=no])\n \n-AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n+dnl Test-only override of the (autodetected by the C code) \"widemul\" setting.\n+dnl Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n+AC_ARG_WITH([test-override-wide-multiply], [] ,[set_widemul=$withval], [set_widemul=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n [bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n-AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n-\n AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n [assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n@@ -170,8 +178,6 @@ AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision\n )],\n [req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n-AC_CHECK_TYPES([__int128])\n-\n AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n@@ -265,63 +271,6 @@ else\n   esac\n fi\n \n-if test x\"$req_field\" = x\"auto\"; then\n-  if test x\"set_asm\" = x\"x86_64\"; then\n-    set_field=64bit\n-  fi\n-  if test x\"$set_field\" = x; then\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" = x\"yes\"; then\n-      set_field=64bit\n-    fi\n-  fi\n-  if test x\"$set_field\" = x; then\n-    set_field=32bit\n-  fi\n-else\n-  set_field=$req_field\n-  case $set_field in\n-  64bit)\n-    if test x\"$set_asm\" != x\"x86_64\"; then\n-      SECP_INT128_CHECK\n-      if test x\"$has_int128\" != x\"yes\"; then\n-        AC_MSG_ERROR([64bit field explicitly requested but neither __int128 support or x86_64 assembly available])\n-      fi\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid field implementation selection])\n-    ;;\n-  esac\n-fi\n-\n-if test x\"$req_scalar\" = x\"auto\"; then\n-  SECP_INT128_CHECK\n-  if test x\"$has_int128\" = x\"yes\"; then\n-    set_scalar=64bit\n-  fi\n-  if test x\"$set_scalar\" = x; then\n-    set_scalar=32bit\n-  fi\n-else\n-  set_scalar=$req_scalar\n-  case $set_scalar in\n-  64bit)\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" != x\"yes\"; then\n-      AC_MSG_ERROR([64bit scalar explicitly requested but __int128 support not available])\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid scalar implementation selected])\n-    ;;\n-  esac\n-fi\n-\n if test x\"$req_bignum\" = x\"auto\"; then\n   SECP_GMP_CHECK\n   if test x\"$has_gmp\" = x\"yes\"; then\n@@ -365,16 +314,18 @@ no)\n   ;;\n esac\n \n-# select field implementation\n-case $set_field in\n-64bit)\n-  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+# select wide multiplication implementation\n+case $set_widemul in\n+int128)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT128, 1, [Define this symbol to force the use of the (unsigned) __int128 based wide multiplication implementation])\n+  ;;\n+int64)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT64, 1, [Define this symbol to force the use of the (u)int64_t based wide multiplication implementation])\n   ;;\n-32bit)\n-  AC_DEFINE(USE_FIELD_10X26, 1, [Define this symbol to use the FIELD_10X26 implementation])\n+auto)\n   ;;\n *)\n-  AC_MSG_ERROR([invalid field implementation])\n+  AC_MSG_ERROR([invalid wide multiplication implementation])\n   ;;\n esac\n \n@@ -396,19 +347,6 @@ no)\n   ;;\n esac\n \n-#select scalar implementation\n-case $set_scalar in\n-64bit)\n-  AC_DEFINE(USE_SCALAR_4X64, 1, [Define this symbol to use the 4x64 scalar implementation])\n-  ;;\n-32bit)\n-  AC_DEFINE(USE_SCALAR_8X32, 1, [Define this symbol to use the 8x32 scalar implementation])\n-  ;;\n-*)\n-  AC_MSG_ERROR([invalid scalar implementation])\n-  ;;\n-esac\n-\n #set ecmult window size\n if test x\"$req_ecmult_window\" = x\"auto\"; then\n   set_ecmult_window=15\n@@ -493,7 +431,16 @@ if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n \n-AC_C_BIGENDIAN()\n+if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_SCHNORRSIG, 1, [Define this symbol to enable the schnorrsig module])\n+  enable_module_extrakeys=yes\n+fi\n+\n+# Test if extrakeys is set after the schnorrsig module to allow the schnorrsig\n+# module to set enable_module_extrakeys=yes\n+if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_EXTRAKEYS, 1, [Define this symbol to enable the extrakeys module])\n+fi\n \n if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n@@ -508,11 +455,19 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([WARNING: experimental build])\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building extrakeys module: $enable_module_extrakeys])\n+  AC_MSG_NOTICE([Building schnorrsig module: $enable_module_schnorrsig])\n   AC_MSG_NOTICE([******])\n else\n   if test x\"$enable_module_ecdh\" = x\"yes\"; then\n     AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n   fi\n+  if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n+    AC_MSG_ERROR([extrakeys module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+    AC_MSG_ERROR([schnorrsig module is experimental. Use --enable-experimental to allow.])\n+  fi\n   if test x\"$set_asm\" = x\"arm\"; then\n     AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -531,6 +486,8 @@ AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_EXTRAKEYS], [test x\"$enable_module_extrakeys\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -550,13 +507,17 @@ echo \"  with benchmarks         = $use_benchmark\"\n echo \"  with coverage           = $enable_coverage\"\n echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\"\n+echo \"  module extrakeys        = $enable_module_extrakeys\"\n+echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  bignum                  = $set_bignum\"\n-echo \"  field                   = $set_field\"\n-echo \"  scalar                  = $set_scalar\"\n echo \"  ecmult window size      = $set_ecmult_window\"\n echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n+dnl Hide test-only options unless they're used.\n+if test x\"$set_widemul\" != xauto; then\n+echo \"  wide multiplication     = $set_widemul\"\n+fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\""
      },
      {
        "sha": "f71db4b53524cc1254190cb915f810adf3113ad7",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -112,7 +112,6 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n         return 0;\n     }\n     spos = pos;\n-    pos += slen;\n \n     /* Ignore leading zeroes in R */\n     while (rlen > 0 && input[rpos] == 0) {"
      },
      {
        "sha": "b0b55b44b8d95de61aa0de4a063b9c21d82099e0",
        "filename": "src/secp256k1/contrib/travis.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/travis.sh?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -3,10 +3,6 @@\n set -e\n set -x\n \n-if [ -n \"$HOST\" ]\n-then\n-    export USE_HOST=\"--host=$HOST\"\n-fi\n if [ \"$HOST\" = \"i686-linux-gnu\" ]\n then\n     export CC=\"$CC -m32\"\n@@ -18,9 +14,11 @@ fi\n \n ./configure \\\n     --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n-    --with-field=\"$FIELD\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" --with-scalar=\"$SCALAR\" \\\n+    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n-    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \"$EXTRAFLAGS\" \"$USE_HOST\"\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n+    --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n+    --host=\"$HOST\" $EXTRAFLAGS\n \n if [ -n \"$BUILD\" ]\n then"
      },
      {
        "sha": "2178c8e2d6f1864b563f0087c829372804f2cd78",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -134,7 +134,7 @@ typedef int (*secp256k1_nonce_function)(\n #  else\n #   define SECP256K1_API\n #  endif\n-# elif defined(__GNUC__) && defined(SECP256K1_BUILD)\n+# elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(SECP256K1_BUILD)\n #  define SECP256K1_API __attribute__ ((visibility (\"default\")))\n # else\n #  define SECP256K1_API"
      },
      {
        "sha": "0c5dff2c942b6378a871c3cbaa3e2df5461ffbc7",
        "filename": "src/secp256k1/include/secp256k1_extrakeys.h",
        "status": "added",
        "additions": 236,
        "deletions": 0,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_extrakeys.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte sequence into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again with a different secret\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, it's set to an invalid value.\n+ *               (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n+ *               NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding tweak32 to the secret key and updating the public\n+ *  key accordingly.\n+ *\n+ *  Calling this function and then secp256k1_keypair_pub results in the same\n+ *  public key as calling secp256k1_keypair_xonly_pub and then\n+ *  secp256k1_xonly_pubkey_tweak_add.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting keypair would be\n+ *           invalid (only when the tweak is the negation of the keypair's\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:       ctx: pointer to a context object initialized for verification\n+ *                   (cannot be NULL)\n+ *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n+ *                   an invalid value if this function returns 0 (cannot be\n+ *                   NULL).\n+ *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n+ *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                   uniformly random 32-byte arrays the chance of being invalid\n+ *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_EXTRAKEYS_H */"
      },
      {
        "sha": "0150cd33953ed99fd5cfea3d380408856df74827",
        "filename": "src/secp256k1/include/secp256k1_schnorrsig.h",
        "status": "added",
        "additions": 111,
        "deletions": 0,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorrsig.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,111 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n+ *           return an error.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey, the algorithm description, and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP0340/nonce\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and\n+ *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_nonce_function_hardened noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_xonly_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_SCHNORRSIG_H */"
      },
      {
        "sha": "f9d4e8e7935168a358e3f8d49901db4b08f39360",
        "filename": "src/secp256k1/src/assumptions.h",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/assumptions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/assumptions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/assumptions.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,74 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_ASSUMPTIONS_H\n+#define SECP256K1_ASSUMPTIONS_H\n+\n+#include \"util.h\"\n+\n+/* This library, like most software, relies on a number of compiler implementation defined (but not undefined)\n+   behaviours. Although the behaviours we require are essentially universal we test them specifically here to\n+   reduce the odds of experiencing an unwelcome surprise.\n+*/\n+\n+struct secp256k1_assumption_checker {\n+    /* This uses a trick to implement a static assertion in C89: a type with an array of negative size is not\n+       allowed. */\n+    int dummy_array[(\n+        /* Bytes are 8 bits. */\n+        CHAR_BIT == 8 &&\n+\n+        /* Conversions from unsigned to signed outside of the bounds of the signed type are\n+           implementation-defined. Verify that they function as reinterpreting the lower\n+           bits of the input in two's complement notation. Do this for conversions:\n+           - from uint(N)_t to int(N)_t with negative result\n+           - from uint(2N)_t to int(N)_t with negative result\n+           - from int(2N)_t to int(N)_t with negative result\n+           - from int(2N)_t to int(N)_t with positive result */\n+\n+        /* To int8_t. */\n+        ((int8_t)(uint8_t)0xAB == (int8_t)-(int8_t)0x55) &&\n+        ((int8_t)(uint16_t)0xABCD == (int8_t)-(int8_t)0x33) &&\n+        ((int8_t)(int16_t)(uint16_t)0xCDEF == (int8_t)(uint8_t)0xEF) &&\n+        ((int8_t)(int16_t)(uint16_t)0x9234 == (int8_t)(uint8_t)0x34) &&\n+\n+        /* To int16_t. */\n+        ((int16_t)(uint16_t)0xBCDE == (int16_t)-(int16_t)0x4322) &&\n+        ((int16_t)(uint32_t)0xA1B2C3D4 == (int16_t)-(int16_t)0x3C2C) &&\n+        ((int16_t)(int32_t)(uint32_t)0xC1D2E3F4 == (int16_t)(uint16_t)0xE3F4) &&\n+        ((int16_t)(int32_t)(uint32_t)0x92345678 == (int16_t)(uint16_t)0x5678) &&\n+\n+        /* To int32_t. */\n+        ((int32_t)(uint32_t)0xB2C3D4E5 == (int32_t)-(int32_t)0x4D3C2B1B) &&\n+        ((int32_t)(uint64_t)0xA123B456C789D012ULL == (int32_t)-(int32_t)0x38762FEE) &&\n+        ((int32_t)(int64_t)(uint64_t)0xC1D2E3F4A5B6C7D8ULL == (int32_t)(uint32_t)0xA5B6C7D8) &&\n+        ((int32_t)(int64_t)(uint64_t)0xABCDEF0123456789ULL == (int32_t)(uint32_t)0x23456789) &&\n+\n+        /* To int64_t. */\n+        ((int64_t)(uint64_t)0xB123C456D789E012ULL == (int64_t)-(int64_t)0x4EDC3BA928761FEEULL) &&\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+        ((int64_t)(((uint128_t)0xA1234567B8901234ULL << 64) + 0xC5678901D2345678ULL) == (int64_t)-(int64_t)0x3A9876FE2DCBA988ULL) &&\n+        (((int64_t)(int128_t)(((uint128_t)0xB1C2D3E4F5A6B7C8ULL << 64) + 0xD9E0F1A2B3C4D5E6ULL)) == (int64_t)(uint64_t)0xD9E0F1A2B3C4D5E6ULL) &&\n+        (((int64_t)(int128_t)(((uint128_t)0xABCDEF0123456789ULL << 64) + 0x0123456789ABCDEFULL)) == (int64_t)(uint64_t)0x0123456789ABCDEFULL) &&\n+\n+        /* To int128_t. */\n+        ((int128_t)(((uint128_t)0xB1234567C8901234ULL << 64) + 0xD5678901E2345678ULL) == (int128_t)(-(int128_t)0x8E1648B3F50E80DCULL * 0x8E1648B3F50E80DDULL + 0x5EA688D5482F9464ULL)) &&\n+#endif\n+\n+        /* Right shift on negative signed values is implementation defined. Verify that it\n+           acts as a right shift in two's complement with sign extension (i.e duplicating\n+           the top bit into newly added bits). */\n+        ((((int8_t)0xE8) >> 2) == (int8_t)(uint8_t)0xFA) &&\n+        ((((int16_t)0xE9AC) >> 4) == (int16_t)(uint16_t)0xFE9A) &&\n+        ((((int32_t)0x937C918A) >> 9) == (int32_t)(uint32_t)0xFFC9BE48) &&\n+        ((((int64_t)0xA8B72231DF9CF4B9ULL) >> 19) == (int64_t)(uint64_t)0xFFFFF516E4463BF3ULL) &&\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+        ((((int128_t)(((uint128_t)0xCD833A65684A0DBCULL << 64) + 0xB349312F71EA7637ULL)) >> 39) == (int128_t)(((uint128_t)0xFFFFFFFFFF9B0674ULL << 64) + 0xCAD0941B79669262ULL)) &&\n+#endif\n+    1) * 2 - 1];\n+};\n+\n+#endif /* SECP256K1_ASSUMPTIONS_H */"
      },
      {
        "sha": "83dbe6f25b0e2fabef3537e476757ce3395536a7",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -14,23 +14,20 @@\n #undef USE_ENDOMORPHISM\n #undef USE_EXTERNAL_ASM\n #undef USE_EXTERNAL_DEFAULT_CALLBACKS\n-#undef USE_FIELD_10X26\n-#undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n #undef USE_FIELD_INV_NUM\n #undef USE_NUM_GMP\n #undef USE_NUM_NONE\n-#undef USE_SCALAR_4X64\n-#undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef USE_FORCE_WIDEMUL_INT64\n+#undef USE_FORCE_WIDEMUL_INT128\n #undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n-#define USE_FIELD_10X26 1\n-#define USE_SCALAR_8X32 1\n+#define USE_WIDEMUL_64 1\n #define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */"
      },
      {
        "sha": "9687fe4482f543893a30466e1272ce6f60a1a56e",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 114,
        "deletions": 60,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -7,6 +7,7 @@\n \n #include \"include/secp256k1.h\"\n \n+#include \"assumptions.h\"\n #include \"util.h\"\n #include \"hash_impl.h\"\n #include \"num_impl.h\"\n@@ -19,49 +20,72 @@\n #include \"secp256k1.c\"\n \n typedef struct {\n-    secp256k1_scalar scalar_x, scalar_y;\n-    secp256k1_fe fe_x, fe_y;\n-    secp256k1_ge ge_x, ge_y;\n-    secp256k1_gej gej_x, gej_y;\n+    secp256k1_scalar scalar[2];\n+    secp256k1_fe fe[4];\n+    secp256k1_ge ge[2];\n+    secp256k1_gej gej[2];\n     unsigned char data[64];\n     int wnaf[256];\n } bench_inv;\n \n void bench_setup(void* arg) {\n     bench_inv *data = (bench_inv*)arg;\n \n-    static const unsigned char init_x[32] = {\n-        0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n-        0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n-        0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n-        0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n+    static const unsigned char init[4][32] = {\n+        /* Initializer for scalar[0], fe[0], first half of data, the X coordinate of ge[0],\n+           and the (implied affine) X coordinate of gej[0]. */\n+        {\n+            0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n+            0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n+            0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n+            0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n+        },\n+        /* Initializer for scalar[1], fe[1], first half of data, the X coordinate of ge[1],\n+           and the (implied affine) X coordinate of gej[1]. */\n+        {\n+            0x82, 0x83, 0x85, 0x87, 0x8b, 0x8d, 0x81, 0x83,\n+            0x97, 0xad, 0xaf, 0xb5, 0xb9, 0xbb, 0xbf, 0xc5,\n+            0xdb, 0xdd, 0xe3, 0xe7, 0xe9, 0xef, 0xf3, 0xf9,\n+            0x11, 0x15, 0x17, 0x1b, 0x1d, 0xb1, 0xbf, 0xd3\n+        },\n+        /* Initializer for fe[2] and the Z coordinate of gej[0]. */\n+        {\n+            0x3d, 0x2d, 0xef, 0xf4, 0x25, 0x98, 0x4f, 0x5d,\n+            0xe2, 0xca, 0x5f, 0x41, 0x3f, 0x3f, 0xce, 0x44,\n+            0xaa, 0x2c, 0x53, 0x8a, 0xc6, 0x59, 0x1f, 0x38,\n+            0x38, 0x23, 0xe4, 0x11, 0x27, 0xc6, 0xa0, 0xe7\n+        },\n+        /* Initializer for fe[3] and the Z coordinate of gej[1]. */\n+        {\n+            0xbd, 0x21, 0xa5, 0xe1, 0x13, 0x50, 0x73, 0x2e,\n+            0x52, 0x98, 0xc8, 0x9e, 0xab, 0x00, 0xa2, 0x68,\n+            0x43, 0xf5, 0xd7, 0x49, 0x80, 0x72, 0xa7, 0xf3,\n+            0xd7, 0x60, 0xe6, 0xab, 0x90, 0x92, 0xdf, 0xc5\n+        }\n     };\n \n-    static const unsigned char init_y[32] = {\n-        0x82, 0x83, 0x85, 0x87, 0x8b, 0x8d, 0x81, 0x83,\n-        0x97, 0xad, 0xaf, 0xb5, 0xb9, 0xbb, 0xbf, 0xc5,\n-        0xdb, 0xdd, 0xe3, 0xe7, 0xe9, 0xef, 0xf3, 0xf9,\n-        0x11, 0x15, 0x17, 0x1b, 0x1d, 0xb1, 0xbf, 0xd3\n-    };\n-\n-    secp256k1_scalar_set_b32(&data->scalar_x, init_x, NULL);\n-    secp256k1_scalar_set_b32(&data->scalar_y, init_y, NULL);\n-    secp256k1_fe_set_b32(&data->fe_x, init_x);\n-    secp256k1_fe_set_b32(&data->fe_y, init_y);\n-    CHECK(secp256k1_ge_set_xo_var(&data->ge_x, &data->fe_x, 0));\n-    CHECK(secp256k1_ge_set_xo_var(&data->ge_y, &data->fe_y, 1));\n-    secp256k1_gej_set_ge(&data->gej_x, &data->ge_x);\n-    secp256k1_gej_set_ge(&data->gej_y, &data->ge_y);\n-    memcpy(data->data, init_x, 32);\n-    memcpy(data->data + 32, init_y, 32);\n+    secp256k1_scalar_set_b32(&data->scalar[0], init[0], NULL);\n+    secp256k1_scalar_set_b32(&data->scalar[1], init[1], NULL);\n+    secp256k1_fe_set_b32(&data->fe[0], init[0]);\n+    secp256k1_fe_set_b32(&data->fe[1], init[1]);\n+    secp256k1_fe_set_b32(&data->fe[2], init[2]);\n+    secp256k1_fe_set_b32(&data->fe[3], init[3]);\n+    CHECK(secp256k1_ge_set_xo_var(&data->ge[0], &data->fe[0], 0));\n+    CHECK(secp256k1_ge_set_xo_var(&data->ge[1], &data->fe[1], 1));\n+    secp256k1_gej_set_ge(&data->gej[0], &data->ge[0]);\n+    secp256k1_gej_rescale(&data->gej[0], &data->fe[2]);\n+    secp256k1_gej_set_ge(&data->gej[1], &data->ge[1]);\n+    secp256k1_gej_rescale(&data->gej[1], &data->fe[3]);\n+    memcpy(data->data, init[0], 32);\n+    memcpy(data->data + 32, init[1], 32);\n }\n \n void bench_scalar_add(void* arg, int iters) {\n     int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -71,7 +95,7 @@ void bench_scalar_negate(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_negate(&data->scalar_x, &data->scalar_x);\n+        secp256k1_scalar_negate(&data->scalar[0], &data->scalar[0]);\n     }\n }\n \n@@ -80,7 +104,7 @@ void bench_scalar_sqr(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_sqr(&data->scalar_x, &data->scalar_x);\n+        secp256k1_scalar_sqr(&data->scalar[0], &data->scalar[0]);\n     }\n }\n \n@@ -89,7 +113,7 @@ void bench_scalar_mul(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_mul(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_mul(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n }\n \n@@ -99,8 +123,8 @@ void bench_scalar_split(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_split_lambda(&data->scalar_x, &data->scalar_y, &data->scalar_x);\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_split_lambda(&data->scalar[0], &data->scalar[1], &data->scalar[0]);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -111,8 +135,8 @@ void bench_scalar_inverse(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_inverse(&data->scalar_x, &data->scalar_x);\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_inverse(&data->scalar[0], &data->scalar[0]);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -122,8 +146,8 @@ void bench_scalar_inverse_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_inverse_var(&data->scalar_x, &data->scalar_x);\n-        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        secp256k1_scalar_inverse_var(&data->scalar[0], &data->scalar[0]);\n+        j += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -133,7 +157,7 @@ void bench_field_normalize(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_normalize(&data->fe_x);\n+        secp256k1_fe_normalize(&data->fe[0]);\n     }\n }\n \n@@ -142,7 +166,7 @@ void bench_field_normalize_weak(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_normalize_weak(&data->fe_x);\n+        secp256k1_fe_normalize_weak(&data->fe[0]);\n     }\n }\n \n@@ -151,7 +175,7 @@ void bench_field_mul(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_mul(&data->fe_x, &data->fe_x, &data->fe_y);\n+        secp256k1_fe_mul(&data->fe[0], &data->fe[0], &data->fe[1]);\n     }\n }\n \n@@ -160,7 +184,7 @@ void bench_field_sqr(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_sqr(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqr(&data->fe[0], &data->fe[0]);\n     }\n }\n \n@@ -169,8 +193,8 @@ void bench_field_inverse(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_inv(&data->fe_x, &data->fe_x);\n-        secp256k1_fe_add(&data->fe_x, &data->fe_y);\n+        secp256k1_fe_inv(&data->fe[0], &data->fe[0]);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n     }\n }\n \n@@ -179,8 +203,8 @@ void bench_field_inverse_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_fe_inv_var(&data->fe_x, &data->fe_x);\n-        secp256k1_fe_add(&data->fe_x, &data->fe_y);\n+        secp256k1_fe_inv_var(&data->fe[0], &data->fe[0]);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n     }\n }\n \n@@ -190,9 +214,9 @@ void bench_field_sqrt(void* arg, int iters) {\n     secp256k1_fe t;\n \n     for (i = 0; i < iters; i++) {\n-        t = data->fe_x;\n-        j += secp256k1_fe_sqrt(&data->fe_x, &t);\n-        secp256k1_fe_add(&data->fe_x, &data->fe_y);\n+        t = data->fe[0];\n+        j += secp256k1_fe_sqrt(&data->fe[0], &t);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n     }\n     CHECK(j <= iters);\n }\n@@ -202,7 +226,7 @@ void bench_group_double_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_double_var(&data->gej_x, &data->gej_x, NULL);\n+        secp256k1_gej_double_var(&data->gej[0], &data->gej[0], NULL);\n     }\n }\n \n@@ -211,7 +235,7 @@ void bench_group_add_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_add_var(&data->gej_x, &data->gej_x, &data->gej_y, NULL);\n+        secp256k1_gej_add_var(&data->gej[0], &data->gej[0], &data->gej[1], NULL);\n     }\n }\n \n@@ -220,7 +244,7 @@ void bench_group_add_affine(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_add_ge(&data->gej_x, &data->gej_x, &data->ge_y);\n+        secp256k1_gej_add_ge(&data->gej[0], &data->gej[0], &data->ge[1]);\n     }\n }\n \n@@ -229,7 +253,7 @@ void bench_group_add_affine_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        secp256k1_gej_add_ge_var(&data->gej_x, &data->gej_x, &data->ge_y, NULL);\n+        secp256k1_gej_add_ge_var(&data->gej[0], &data->gej[0], &data->ge[1], NULL);\n     }\n }\n \n@@ -238,18 +262,46 @@ void bench_group_jacobi_var(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        j += secp256k1_gej_has_quad_y_var(&data->gej_x);\n+        j += secp256k1_gej_has_quad_y_var(&data->gej[0]);\n+        /* Vary the Y and Z coordinates of the input (the X coordinate doesn't matter to\n+           secp256k1_gej_has_quad_y_var). Note that the resulting coordinates will\n+           generally not correspond to a point on the curve, but this is not a problem\n+           for the code being benchmarked here. Adding and normalizing have less\n+           overhead than EC operations (which could guarantee the point remains on the\n+           curve). */\n+        secp256k1_fe_add(&data->gej[0].y, &data->fe[1]);\n+        secp256k1_fe_add(&data->gej[0].z, &data->fe[2]);\n+        secp256k1_fe_normalize_var(&data->gej[0].y);\n+        secp256k1_fe_normalize_var(&data->gej[0].z);\n+    }\n+    CHECK(j <= iters);\n+}\n+\n+void bench_group_to_affine_var(void* arg, int iters) {\n+    int i;\n+    bench_inv *data = (bench_inv*)arg;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ge_set_gej_var(&data->ge[1], &data->gej[0]);\n+        /* Use the output affine X/Y coordinates to vary the input X/Y/Z coordinates.\n+           Similar to bench_group_jacobi_var, this approach does not result in\n+           coordinates of points on the curve. */\n+        secp256k1_fe_add(&data->gej[0].x, &data->ge[1].y);\n+        secp256k1_fe_add(&data->gej[0].y, &data->fe[2]);\n+        secp256k1_fe_add(&data->gej[0].z, &data->ge[1].x);\n+        secp256k1_fe_normalize_var(&data->gej[0].x);\n+        secp256k1_fe_normalize_var(&data->gej[0].y);\n+        secp256k1_fe_normalize_var(&data->gej[0].z);\n     }\n-    CHECK(j == iters);\n }\n \n void bench_ecmult_wnaf(void* arg, int iters) {\n     int i, bits = 0, overflow = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        bits += secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n-        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        bits += secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar[0], WINDOW_A);\n+        overflow += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(overflow >= 0);\n     CHECK(bits <= 256*iters);\n@@ -260,8 +312,8 @@ void bench_wnaf_const(void* arg, int iters) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; i++) {\n-        bits += secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n-        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        bits += secp256k1_wnaf_const(data->wnaf, &data->scalar[0], WINDOW_A, 256);\n+        overflow += secp256k1_scalar_add(&data->scalar[0], &data->scalar[0], &data->scalar[1]);\n     }\n     CHECK(overflow >= 0);\n     CHECK(bits <= 256*iters);\n@@ -323,14 +375,15 @@ void bench_context_sign(void* arg, int iters) {\n void bench_num_jacobi(void* arg, int iters) {\n     int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n-    secp256k1_num nx, norder;\n+    secp256k1_num nx, na, norder;\n \n-    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_get_num(&nx, &data->scalar[0]);\n     secp256k1_scalar_order_get_num(&norder);\n-    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+    secp256k1_scalar_get_num(&na, &data->scalar[1]);\n \n     for (i = 0; i < iters; i++) {\n         j += secp256k1_num_jacobi(&nx, &norder);\n+        secp256k1_num_add(&nx, &nx, &na);\n     }\n     CHECK(j <= iters);\n }\n@@ -363,6 +416,7 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);"
      },
      {
        "sha": "315f5af28e70984272483612b32c6cab358e722a",
        "filename": "src/secp256k1/src/bench_schnorrsig.c",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorrsig.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,102 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    int n;\n+\n+    const secp256k1_keypair **keypairs;\n+    const unsigned char **pk;\n+    const unsigned char **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char sig[64];\n+\n+    for (i = 0; i < iters; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; i++) {\n+        secp256k1_xonly_pubkey pk;\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+int main(void) {\n+    int i;\n+    bench_schnorrsig_data data;\n+    int iters = get_iters(10000);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.keypairs = (const secp256k1_keypair **)malloc(iters * sizeof(secp256k1_keypair *));\n+    data.pk = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n+    data.msgs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n+    data.sigs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = (unsigned char *)malloc(32);\n+        unsigned char *sig = (unsigned char *)malloc(64);\n+        secp256k1_keypair *keypair = (secp256k1_keypair *)malloc(sizeof(*keypair));\n+        unsigned char *pk_char = (unsigned char *)malloc(32);\n+        secp256k1_xonly_pubkey pk;\n+        msg[0] = sk[0] = i;\n+        msg[1] = sk[1] = i >> 8;\n+        msg[2] = sk[2] = i >> 16;\n+        msg[3] = sk[3] = i >> 24;\n+        memset(&msg[4], 'm', 28);\n+        memset(&sk[4], 's', 28);\n+\n+        data.keypairs[i] = keypair;\n+        data.pk[i] = pk_char;\n+        data.msgs[i] = msg;\n+        data.sigs[i] = sig;\n+\n+        CHECK(secp256k1_keypair_create(data.ctx, keypair, sk));\n+        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, keypair, NULL, NULL));\n+        CHECK(secp256k1_keypair_xonly_pub(data.ctx, &pk, NULL, keypair));\n+        CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n+    }\n+\n+    run_benchmark(\"schnorrsig_sign\", bench_schnorrsig_sign, NULL, NULL, (void *) &data, 10, iters);\n+    run_benchmark(\"schnorrsig_verify\", bench_schnorrsig_verify, NULL, NULL, (void *) &data, 10, iters);\n+\n+    for (i = 0; i < iters; i++) {\n+        free((void *)data.keypairs[i]);\n+        free((void *)data.pk[i]);\n+        free((void *)data.msgs[i]);\n+        free((void *)data.sigs[i]);\n+    }\n+    free(data.keypairs);\n+    free(data.pk);\n+    free(data.msgs);\n+    free(data.sigs);\n+\n+    secp256k1_context_destroy(data.ctx);\n+    return 0;\n+}"
      },
      {
        "sha": "55b61e49372cbc68d57464b4e59fd1cc72eacf6d",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -105,16 +105,22 @@ static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w\n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n     do {\n-        int sign;\n         int even;\n \n         /* 4.1 4.4 */\n         u = secp256k1_scalar_shr_int(&s, w);\n         /* 4.2 */\n         even = ((u & 1) == 0);\n-        sign = 2 * (u_last > 0) - 1;\n-        u += sign * even;\n-        u_last -= sign * even * (1 << w);\n+        /* In contrast to the original algorithm, u_last is always > 0 and\n+         * therefore we do not need to check its sign. In particular, it's easy\n+         * to see that u_last is never < 0 because u is never < 0. Moreover,\n+         * u_last is never = 0 because u is never even after a loop\n+         * iteration. The same holds analogously for the initial value of\n+         * u_last (in the first loop iteration). */\n+        VERIFY_CHECK(u_last > 0);\n+        VERIFY_CHECK((u_last & 1) == 1);\n+        u += even;\n+        u_last -= even * (1 << w);\n \n         /* 4.3, adapted for global sign change */\n         wnaf[word++] = u_last * global_sign;\n@@ -202,7 +208,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double_nonzero(r, r);\n+            secp256k1_gej_double(r, r);\n         }\n \n         n = wnaf_1[i];"
      },
      {
        "sha": "aca1fb72c5084e99b44056d5dd979d5252889743",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -22,16 +22,16 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26.h\"\n-#elif defined(USE_FIELD_5X52)\n+#include \"util.h\"\n+\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n-#include \"util.h\"\n-\n /** Normalize a field element. This brings the field element to a canonical representation, reduces\n  *  its magnitude to 1, and reduces it modulo field size `p`.\n  */"
      },
      {
        "sha": "6a068484c28a0d386fd62cfad107e3ca1b15ae02",
        "filename": "src/secp256k1/src/field_5x52.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -46,4 +46,10 @@ typedef struct {\n     (d6) | (((uint64_t)(d7)) << 32) \\\n }}\n \n+#define SECP256K1_FE_STORAGE_CONST_GET(d) \\\n+    (uint32_t)(d.n[3] >> 32), (uint32_t)d.n[3], \\\n+    (uint32_t)(d.n[2] >> 32), (uint32_t)d.n[2], \\\n+    (uint32_t)(d.n[1] >> 32), (uint32_t)d.n[1], \\\n+    (uint32_t)(d.n[0] >> 32), (uint32_t)d.n[0]\n+\n #endif /* SECP256K1_FIELD_REPR_H */"
      },
      {
        "sha": "18e4d2f30ea66450e9de4020d6e7a26d337e9985",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -14,12 +14,12 @@\n #include \"util.h\"\n #include \"num.h\"\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26_impl.h\"\n-#elif defined(USE_FIELD_5X52)\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52_impl.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26_impl.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {"
      },
      {
        "sha": "8b7729aee4c8d4c15f82fa8e2592a136d59cabad",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -13,6 +13,7 @@\n #include \"basic-config.h\"\n \n #include \"include/secp256k1.h\"\n+#include \"assumptions.h\"\n #include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\""
      },
      {
        "sha": "6185be052db065e4c42e085e1889dbae5aa10429",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -95,8 +95,8 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n /** Check whether a group element's y coordinate is a quadratic residue. */\n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n \n-/** Set r equal to the double of a, a cannot be infinity. Constant time. */\n-static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a);\n+/** Set r equal to the double of a. Constant time. */\n+static void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a);\n \n /** Set r equal to the double of a. If rzr is not-NULL this sets *rzr such that r->z == a->z * *rzr (where infinity means an implicit z = 0). */\n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "ccd93d3483ab6e464049889cc7b06b1239a0e1db",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -303,7 +303,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n-static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a) {\n+static SECP256K1_INLINE void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a) {\n     /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n      *\n      * Note that there is an implementation described at\n@@ -313,8 +313,7 @@ static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, cons\n      */\n     secp256k1_fe t1,t2,t3,t4;\n \n-    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n-    r->infinity = 0;\n+    r->infinity = a->infinity;\n \n     secp256k1_fe_mul(&r->z, &a->z, &a->y);\n     secp256k1_fe_mul_int(&r->z, 2);       /* Z' = 2*Y*Z (2) */\n@@ -363,7 +362,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n         secp256k1_fe_mul_int(rzr, 2);\n     }\n \n-    secp256k1_gej_double_nonzero(r, a);\n+    secp256k1_gej_double(r, a);\n }\n \n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {\n@@ -400,7 +399,7 @@ static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, cons\n             if (rzr != NULL) {\n                 secp256k1_fe_set_int(rzr, 0);\n             }\n-            r->infinity = 1;\n+            secp256k1_gej_set_infinity(r);\n         }\n         return;\n     }\n@@ -450,7 +449,7 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, c\n             if (rzr != NULL) {\n                 secp256k1_fe_set_int(rzr, 0);\n             }\n-            r->infinity = 1;\n+            secp256k1_gej_set_infinity(r);\n         }\n         return;\n     }\n@@ -509,7 +508,7 @@ static void secp256k1_gej_add_zinv_var(secp256k1_gej *r, const secp256k1_gej *a,\n         if (secp256k1_fe_normalizes_to_zero_var(&i)) {\n             secp256k1_gej_double_var(r, a, NULL);\n         } else {\n-            r->infinity = 1;\n+            secp256k1_gej_set_infinity(r);\n         }\n         return;\n     }"
      },
      {
        "sha": "409772587bebb3a88976e129508165fba18593c5",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_HASH_IMPL_H\n \n #include \"hash.h\"\n+#include \"util.h\"\n \n #include <stdlib.h>\n #include <stdint.h>\n@@ -27,9 +28,9 @@\n     (h) = t1 + t2; \\\n } while(0)\n \n-#ifdef WORDS_BIGENDIAN\n+#if defined(SECP256K1_BIG_ENDIAN)\n #define BE32(x) (x)\n-#else\n+#elif defined(SECP256K1_LITTLE_ENDIAN)\n #define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n #endif\n \n@@ -163,6 +164,19 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. */\n+static void secp256k1_sha256_initialize_tagged(secp256k1_sha256 *hash, const unsigned char *tag, size_t taglen) {\n+    unsigned char buf[32];\n+    secp256k1_sha256_initialize(hash);\n+    secp256k1_sha256_write(hash, tag, taglen);\n+    secp256k1_sha256_finalize(hash, buf);\n+\n+    secp256k1_sha256_initialize(hash);\n+    secp256k1_sha256_write(hash, buf, 32);\n+    secp256k1_sha256_write(hash, buf, 32);\n+}\n+\n static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256 *hash, const unsigned char *key, size_t keylen) {\n     size_t n;\n     unsigned char rkey[64];"
      },
      {
        "sha": "8515f92e7a072a54a10e2648d563bf2821ca16d3",
        "filename": "src/secp256k1/src/modules/extrakeys/Makefile.am.include",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/extrakeys/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/extrakeys/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/Makefile.am.include?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,3 @@\n+include_HEADERS += include/secp256k1_extrakeys.h\n+noinst_HEADERS += src/modules/extrakeys/tests_impl.h\n+noinst_HEADERS += src/modules/extrakeys/main_impl.h"
      },
      {
        "sha": "d3192153558c31cfec5b601d2edeb40eb3358cc2",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "added",
        "additions": 248,
        "deletions": 0,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,248 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+/** Keeps a group element as is if it has an even Y and otherwise negates it.\n+ *  y_parity is set to 0 in the former case and to 1 in the latter case.\n+ *  Requires that the coordinates of r are normalized. */\n+static int secp256k1_extrakeys_ge_even_y(secp256k1_ge *r) {\n+    int y_parity = 0;\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(r));\n+\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+        y_parity = 1;\n+    }\n+    return y_parity;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *pk_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+    int tmp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    tmp = secp256k1_extrakeys_ge_even_y(&pk);\n+    if (pk_parity != NULL) {\n+        *pk_parity = tmp;\n+    }\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweaked_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, tweaked_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == tweaked_pk_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    ret = secp256k1_scalar_set_b32_seckey(sk, &keypair->data[0]);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return ret;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+    int tmp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    tmp = secp256k1_extrakeys_ge_even_y(&pk);\n+    if (pk_parity != NULL) {\n+        *pk_parity = tmp;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int y_parity;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    y_parity = secp256k1_extrakeys_ge_even_y(&pk);\n+    if (y_parity == 1) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);\n+\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_keypair_save(keypair, &sk, &pk);\n+    }\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+#endif"
      },
      {
        "sha": "fc9d40eda1141502b4983e08a03264bfb75eda0d",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "added",
        "additions": 524,
        "deletions": 0,
        "changes": 524,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,524 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n+#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+static secp256k1_context* api_test_context(int flags, int *ecount) {\n+    secp256k1_context *ctx0 = secp256k1_context_create(flags);\n+    secp256k1_context_set_error_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    secp256k1_context_set_illegal_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    return ctx0;\n+}\n+\n+void test_xonly_pubkey(void) {\n+    secp256k1_pubkey pk;\n+    secp256k1_xonly_pubkey xonly_pk, xonly_pk_tmp;\n+    secp256k1_ge pk1;\n+    secp256k1_ge pk2;\n+    secp256k1_fe y;\n+    unsigned char sk[32];\n+    unsigned char xy_sk[32];\n+    unsigned char buf32[32];\n+    unsigned char ones32[32];\n+    unsigned char zeros64[64] = { 0 };\n+    int pk_parity;\n+    int i;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    secp256k1_rand256(sk);\n+    memset(ones32, 0xFF, 32);\n+    secp256k1_rand256(xy_sk);\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+\n+    /* Test xonly_pubkey_from_pubkey */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(sign, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, NULL, &pk_parity, &pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, NULL) == 0);\n+    CHECK(ecount == 2);\n+    memset(&pk, 0, sizeof(pk));\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Choose a secret key such that the resulting pubkey and xonly_pubkey match. */\n+    memset(sk, 0, sizeof(sk));\n+    sk[0] = 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&pk, &xonly_pk, sizeof(pk)) == 0);\n+    CHECK(pk_parity == 0);\n+\n+    /* Choose a secret key such that pubkey and xonly_pubkey are each others\n+     * negation. */\n+    sk[0] = 2;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n+    CHECK(pk_parity == 1);\n+    secp256k1_pubkey_load(ctx, &pk1, &pk);\n+    secp256k1_pubkey_load(ctx, &pk2, (secp256k1_pubkey *) &xonly_pk);\n+    CHECK(secp256k1_fe_equal(&pk1.x, &pk2.x) == 1);\n+    secp256k1_fe_negate(&y, &pk2.y, 1);\n+    CHECK(secp256k1_fe_equal(&pk1.y, &y) == 1);\n+\n+    /* Test xonly_pubkey_serialize and xonly_pubkey_parse */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &xonly_pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n+    CHECK(memcmp(buf32, zeros64, 32) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n+         * special casing. */\n+        secp256k1_xonly_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp));\n+        CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk_tmp) == 0);\n+    }\n+    /* pubkey_load called illegal callback */\n+    CHECK(ecount == 3);\n+\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &xonly_pk) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_parse(none, NULL, buf32) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, NULL) == 0);\n+    CHECK(ecount == 2);\n+\n+    /* Serialization and parse roundtrip */\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, buf32) == 1);\n+    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n+\n+    /* Test parsing invalid field elements */\n+    memset(&xonly_pk, 1, sizeof(xonly_pk));\n+    /* Overflowing field element */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, ones32) == 0);\n+    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    memset(&xonly_pk, 1, sizeof(xonly_pk));\n+    /* There's no point with x-coordinate 0 on secp256k1 */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, zeros64) == 0);\n+    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    /* If a random 32-byte string can not be parsed with ec_pubkey_parse\n+     * (because interpreted as X coordinate it does not correspond to a point on\n+     * the curve) then xonly_pubkey_parse should fail as well. */\n+    for (i = 0; i < count; i++) {\n+        unsigned char rand33[33];\n+        secp256k1_rand256(&rand33[1]);\n+        rand33[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+        if (!secp256k1_ec_pubkey_parse(ctx, &pk, rand33, 33)) {\n+            memset(&xonly_pk, 1, sizeof(xonly_pk));\n+            CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 0);\n+            CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+        } else {\n+            CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 1);\n+        }\n+    }\n+    CHECK(ecount == 2);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void test_xonly_pubkey_tweak(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    int pk_parity;\n+    unsigned char tweak[32];\n+    int i;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    /* NULL internal_xonly_pk zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* NULL tweak zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+\n+    /* Invalid tweak zeroes the output_pk */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+\n+    /* A zero tweak is fine */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, zeros64) == 1);\n+\n+    /* Fails if the resulting key was infinity */\n+    for (i = 0; i < count; i++) {\n+        secp256k1_scalar scalar_tweak;\n+        /* Because sk may be negated before adding, we need to try with tweak =\n+         * sk as well as tweak = -sk. */\n+        secp256k1_scalar_set_b32(&scalar_tweak, sk, NULL);\n+        secp256k1_scalar_negate(&scalar_tweak, &scalar_tweak);\n+        secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n+        CHECK((secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, sk) == 0)\n+              || (secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0));\n+        CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    }\n+\n+    /* Invalid pk with a valid tweak */\n+    memset(&internal_xonly_pk, 0, sizeof(internal_xonly_pk));\n+    secp256k1_rand256(tweak);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void test_xonly_pubkey_tweak_check(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    secp256k1_xonly_pubkey output_xonly_pk;\n+    unsigned char output_pk32[32];\n+    unsigned char buf32[32];\n+    int pk_parity;\n+    unsigned char tweak[32];\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    /* invalid pk_parity value */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    memset(tweak, 1, sizeof(tweak));\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+\n+    /* Wrong pk_parity */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, !pk_parity, &internal_xonly_pk, tweak) == 0);\n+    /* Wrong public key */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &internal_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+\n+    /* Overflowing tweak not allowed */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(ecount == 5);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+/* Starts with an initial pubkey and recursively creates N_PUBKEYS - 1\n+ * additional pubkeys by calling tweak_add. Then verifies every tweak starting\n+ * from the last pubkey. */\n+#define N_PUBKEYS 32\n+void test_xonly_pubkey_tweak_recursive(void) {\n+    unsigned char sk[32];\n+    secp256k1_pubkey pk[N_PUBKEYS];\n+    unsigned char pk_serialized[32];\n+    unsigned char tweak[N_PUBKEYS - 1][32];\n+    int i;\n+\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk) == 1);\n+    /* Add tweaks */\n+    for (i = 0; i < N_PUBKEYS - 1; i++) {\n+        secp256k1_xonly_pubkey xonly_pk;\n+        memset(tweak[i], i + 1, sizeof(tweak[i]));\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, NULL, &pk[i]) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &pk[i + 1], &xonly_pk, tweak[i]) == 1);\n+    }\n+\n+    /* Verify tweaks */\n+    for (i = N_PUBKEYS - 1; i > 0; i--) {\n+        secp256k1_xonly_pubkey xonly_pk;\n+        int pk_parity;\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk[i]) == 1);\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, pk_serialized, &xonly_pk) == 1);\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, NULL, &pk[i - 1]) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, pk_serialized, pk_parity, &xonly_pk, tweak[i - 1]) == 1);\n+    }\n+}\n+#undef N_PUBKEYS\n+\n+void test_keypair(void) {\n+    unsigned char sk[32];\n+    unsigned char zeros96[96] = { 0 };\n+    unsigned char overflows[32];\n+    secp256k1_keypair keypair;\n+    secp256k1_pubkey pk, pk_tmp;\n+    secp256k1_xonly_pubkey xonly_pk, xonly_pk_tmp;\n+    int pk_parity, pk_parity_tmp;\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    CHECK(sizeof(zeros96) == sizeof(keypair));\n+    memset(overflows, 0xFF, sizeof(overflows));\n+\n+    /* Test keypair_create */\n+    ecount = 0;\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(none, &keypair, sk) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_create(verify, &keypair, sk) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_create(sign, NULL, sk) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, NULL) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(ecount == 4);\n+\n+    /* Invalid secret key */\n+    CHECK(secp256k1_keypair_create(sign, &keypair, zeros96) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, overflows) == 0);\n+    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+\n+    /* Test keypair_pub */\n+    ecount = 0;\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n+    CHECK(secp256k1_keypair_pub(none, NULL, &keypair) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_pub(none, &pk, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+\n+    /* Using an invalid keypair is fine for keypair_pub */\n+    memset(&keypair, 0, sizeof(keypair));\n+    CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n+    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+\n+    /* keypair holds the same pubkey as pubkey_create */\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_pub(none, &pk_tmp, &keypair) == 1);\n+    CHECK(memcmp(&pk, &pk_tmp, sizeof(pk)) == 0);\n+\n+    /** Test keypair_xonly_pub **/\n+    ecount = 0;\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, NULL, &pk_parity, &keypair) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, NULL, &keypair) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    /* Using an invalid keypair will set the xonly_pk to 0 (first reset\n+     * xonly_pk). */\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n+    memset(&keypair, 0, sizeof(keypair));\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 0);\n+    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    CHECK(ecount == 3);\n+\n+    /** keypair holds the same xonly pubkey as pubkey_create **/\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk_tmp, &pk_parity_tmp, &keypair) == 1);\n+    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n+    CHECK(pk_parity == pk_parity_tmp);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void test_keypair_add(void) {\n+    unsigned char sk[32];\n+    secp256k1_keypair keypair;\n+    unsigned char overflows[32];\n+    unsigned char zeros96[96] = { 0 };\n+    unsigned char tweak[32];\n+    int i;\n+    int ecount = 0;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    CHECK(sizeof(zeros96) == sizeof(keypair));\n+    secp256k1_rand256(sk);\n+    secp256k1_rand256(tweak);\n+    memset(overflows, 0xFF, 32);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, NULL, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n+    CHECK(ecount == 4);\n+    /* This does not set the keypair to zeroes */\n+    CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) != 0);\n+\n+    /* Invalid tweak zeroes the keypair */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, overflows) == 0);\n+    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+\n+    /* A zero tweak is fine */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, zeros96) == 1);\n+\n+    /* Fails if the resulting keypair was (sk=0, pk=infinity) */\n+    for (i = 0; i < count; i++) {\n+        secp256k1_scalar scalar_tweak;\n+        secp256k1_keypair keypair_tmp;\n+        secp256k1_rand256(sk);\n+        CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+        memcpy(&keypair_tmp, &keypair, sizeof(keypair));\n+        /* Because sk may be negated before adding, we need to try with tweak =\n+         * sk as well as tweak = -sk. */\n+        secp256k1_scalar_set_b32(&scalar_tweak, sk, NULL);\n+        secp256k1_scalar_negate(&scalar_tweak, &scalar_tweak);\n+        secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n+        CHECK((secp256k1_keypair_xonly_tweak_add(ctx, &keypair, sk) == 0)\n+              || (secp256k1_keypair_xonly_tweak_add(ctx, &keypair_tmp, tweak) == 0));\n+        CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) == 0\n+              || memcmp(&keypair_tmp, zeros96, sizeof(keypair_tmp)) == 0);\n+    }\n+\n+    /* Invalid keypair with a valid tweak */\n+    memset(&keypair, 0, sizeof(keypair));\n+    secp256k1_rand256(tweak);\n+    ecount = 0;\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+    /* Only seckey part of keypair invalid */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    memset(&keypair, 0, 32);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n+    CHECK(ecount == 2);\n+    /* Only pubkey part of keypair invalid */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    memset(&keypair.data[32], 0, 64);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Check that the keypair_tweak_add implementation is correct */\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    for (i = 0; i < count; i++) {\n+        secp256k1_xonly_pubkey internal_pk;\n+        secp256k1_xonly_pubkey output_pk;\n+        secp256k1_pubkey output_pk_xy;\n+        secp256k1_pubkey output_pk_expected;\n+        unsigned char pk32[32];\n+        int pk_parity;\n+\n+        secp256k1_rand256(tweak);\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n+        CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, tweak) == 1);\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &output_pk, &pk_parity, &keypair) == 1);\n+\n+        /* Check that it passes xonly_pubkey_tweak_add_check */\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, pk32, &output_pk) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, pk32, pk_parity, &internal_pk, tweak) == 1);\n+\n+        /* Check that the resulting pubkey matches xonly_pubkey_tweak_add */\n+        CHECK(secp256k1_keypair_pub(ctx, &output_pk_xy, &keypair) == 1);\n+        CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk_expected, &internal_pk, tweak) == 1);\n+        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+\n+        /* Check that the secret key in the keypair is tweaked correctly */\n+        CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, &keypair.data[0]) == 1);\n+        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+    }\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(verify);\n+}\n+\n+void run_extrakeys_tests(void) {\n+    /* xonly key test cases */\n+    test_xonly_pubkey();\n+    test_xonly_pubkey_tweak();\n+    test_xonly_pubkey_tweak_check();\n+    test_xonly_pubkey_tweak_recursive();\n+\n+    /* keypair tests */\n+    test_keypair();\n+    test_keypair_add();\n+}\n+\n+#endif"
      },
      {
        "sha": "a82bafe43fda64027b97a8e4d66dac35b4a3e96e",
        "filename": "src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/Makefile.am.include?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_schnorrsig.h\n+noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_schnorrsig\n+bench_schnorrsig_SOURCES = src/bench_schnorrsig.c\n+bench_schnorrsig_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif"
      },
      {
        "sha": "a0218f881aaaaa37eff1050b4e9d00c56a3430f2",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "added",
        "additions": 238,
        "deletions": 0,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);\n+    secp256k1_gej_set_ge(&pkj, &pk);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+\n+    secp256k1_ge_set_gej_var(&r, &rj);\n+    if (secp256k1_ge_is_infinity(&r)) {\n+        return 0;\n+    }\n+\n+    secp256k1_fe_normalize_var(&r.y);\n+    return !secp256k1_fe_is_odd(&r.y) &&\n+           secp256k1_fe_equal_var(&rx, &r.x);\n+}\n+\n+#endif"
      },
      {
        "sha": "88d8f5640403ed36efe2343c7e557a867f00da86",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "added",
        "additions": 806,
        "deletions": 0,
        "changes": 806,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,806 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+/* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n+ * bytes) changes the hash function\n+ */\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    unsigned char nonces[2][32];\n+    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    secp256k1_rand_flip(args[n_flip], n_bytes);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(memcmp(nonces[0], nonces[1], 32) != 0);\n+}\n+\n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2) {\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    CHECK(sha1->bytes == sha2->bytes);\n+    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+}\n+\n+void run_nonce_function_bip340_tests(void) {\n+    unsigned char tag[13] = \"BIP0340/nonce\";\n+    unsigned char aux_tag[11] = \"BIP0340/aux\";\n+    unsigned char algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256 sha_optimized;\n+    unsigned char nonce[32];\n+    unsigned char msg[32];\n+    unsigned char key[32];\n+    unsigned char pk[32];\n+    unsigned char aux_rand[32];\n+    unsigned char *args[5];\n+    int i;\n+\n+    /* Check that hash initialized by\n+     * secp256k1_nonce_function_bip340_sha256_tagged has the expected\n+     * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, tag, sizeof(tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+   /* Check that hash initialized by\n+    * secp256k1_nonce_function_bip340_sha256_tagged_aux has the expected\n+    * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, aux_tag, sizeof(aux_tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+    secp256k1_rand256(msg);\n+    secp256k1_rand256(key);\n+    secp256k1_rand256(pk);\n+    secp256k1_rand256(aux_rand);\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = msg;\n+    args[1] = key;\n+    args[2] = pk;\n+    args[3] = algo16;\n+    args[4] = aux_rand;\n+    for (i = 0; i < count; i++) {\n+        nonce_function_bip340_bitflip(args, 0, 32);\n+        nonce_function_bip340_bitflip(args, 1, 32);\n+        nonce_function_bip340_bitflip(args, 2, 32);\n+        /* Flip algo16 special case \"BIP0340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        /* Flip algo16 again */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        nonce_function_bip340_bitflip(args, 4, 32);\n+    }\n+\n+    /* NULL algo16 is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n+    /* Empty algo16 is fine */\n+    memset(algo16, 0x00, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* algo16 with terminating null bytes is fine */\n+    algo16[1] = 65;\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* Other algo16 is fine */\n+    memset(algo16, 0xFF, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+\n+    /* NULL aux_rand argument is allowed. */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+}\n+\n+void test_schnorrsig_api(void) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    secp256k1_keypair keypairs[3];\n+    secp256k1_keypair invalid_keypair = { 0 };\n+    secp256k1_xonly_pubkey pk[3];\n+    secp256k1_xonly_pubkey zero_pk;\n+    unsigned char sig[64];\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[0], sk1) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[1], sk2) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[2], sk3) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[0], NULL, &keypairs[0]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[1], NULL, &keypairs[1]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[2], NULL, &keypairs[2]) == 1);\n+    memset(&zero_pk, 0, sizeof(zero_pk));\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL, NULL) == 0);\n+    CHECK(ecount == 6);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Checks that hash initialized by secp256k1_schnorrsig_sha256_tagged has the\n+ * expected state. */\n+void test_schnorrsig_sha256_tagged(void) {\n+    char tag[17] = \"BIP0340/challenge\";\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256 sha_optimized;\n+\n+    secp256k1_sha256_initialize_tagged(&sha, (unsigned char *) tag, sizeof(tag));\n+    secp256k1_schnorrsig_sha256_tagged(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg, const unsigned char *expected_sig) {\n+    unsigned char sig[64];\n+    secp256k1_keypair keypair;\n+    secp256k1_xonly_pubkey pk, pk_expected;\n+\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n+    CHECK(memcmp(sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+    CHECK(memcmp(&pk, &pk_expected, sizeof(pk)) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch (TODO) return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig, int expected) {\n+    secp256k1_xonly_pubkey pk;\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk, pk_serialized));\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, &pk));\n+}\n+\n+/* Test vectors according to BIP-340 (\"Schnorr Signatures for secp256k1\"). See\n+ * https://github.com/bitcoin/bips/blob/master/bip-0340/test-vectors.csv. */\n+void test_schnorrsig_bip_vectors(void) {\n+    {\n+        /* Test vector 0 */\n+        const unsigned char sk[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        };\n+        const unsigned char pk[32] = {\n+            0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10,\n+            0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29,\n+            0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0,\n+            0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9\n+        };\n+        unsigned char aux_rand[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char msg[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig[64] = {\n+            0xE9, 0x07, 0x83, 0x1F, 0x80, 0x84, 0x8D, 0x10,\n+            0x69, 0xA5, 0x37, 0x1B, 0x40, 0x24, 0x10, 0x36,\n+            0x4B, 0xDF, 0x1C, 0x5F, 0x83, 0x07, 0xB0, 0x08,\n+            0x4C, 0x55, 0xF1, 0xCE, 0x2D, 0xCA, 0x82, 0x15,\n+            0x25, 0xF6, 0x6A, 0x4A, 0x85, 0xEA, 0x8B, 0x71,\n+            0xE4, 0x82, 0xA7, 0x4F, 0x38, 0x2D, 0x2C, 0xE5,\n+            0xEB, 0xEE, 0xE8, 0xFD, 0xB2, 0x17, 0x2F, 0x47,\n+            0x7D, 0xF4, 0x90, 0x0D, 0x31, 0x05, 0x36, 0xC0\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        unsigned char aux_rand[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x68, 0x96, 0xBD, 0x60, 0xEE, 0xAE, 0x29, 0x6D,\n+            0xB4, 0x8A, 0x22, 0x9F, 0xF7, 0x1D, 0xFE, 0x07,\n+            0x1B, 0xDE, 0x41, 0x3E, 0x6D, 0x43, 0xF9, 0x17,\n+            0xDC, 0x8D, 0xCF, 0x8C, 0x78, 0xDE, 0x33, 0x41,\n+            0x89, 0x06, 0xD1, 0x1A, 0xC9, 0x76, 0xAB, 0xCC,\n+            0xB2, 0x0B, 0x09, 0x12, 0x92, 0xBF, 0xF4, 0xEA,\n+            0x89, 0x7E, 0xFC, 0xB6, 0x39, 0xEA, 0x87, 0x1C,\n+            0xFA, 0x95, 0xF6, 0xDE, 0x33, 0x9E, 0x4B, 0x0A\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC9\n+        };\n+        const unsigned char pk[32] = {\n+            0xDD, 0x30, 0x8A, 0xFE, 0xC5, 0x77, 0x7E, 0x13,\n+            0x12, 0x1F, 0xA7, 0x2B, 0x9C, 0xC1, 0xB7, 0xCC,\n+            0x01, 0x39, 0x71, 0x53, 0x09, 0xB0, 0x86, 0xC9,\n+            0x60, 0xE1, 0x8F, 0xD9, 0x69, 0x77, 0x4E, 0xB8\n+        };\n+        unsigned char aux_rand[32] = {\n+            0xC8, 0x7A, 0xA5, 0x38, 0x24, 0xB4, 0xD7, 0xAE,\n+            0x2E, 0xB0, 0x35, 0xA2, 0xB5, 0xBB, 0xBC, 0xCC,\n+            0x08, 0x0E, 0x76, 0xCD, 0xC6, 0xD1, 0x69, 0x2C,\n+            0x4B, 0x0B, 0x62, 0xD7, 0x98, 0xE6, 0xD9, 0x06\n+        };\n+        const unsigned char msg[32] = {\n+            0x7E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig[64] = {\n+            0x58, 0x31, 0xAA, 0xEE, 0xD7, 0xB4, 0x4B, 0xB7,\n+            0x4E, 0x5E, 0xAB, 0x94, 0xBA, 0x9D, 0x42, 0x94,\n+            0xC4, 0x9B, 0xCF, 0x2A, 0x60, 0x72, 0x8D, 0x8B,\n+            0x4C, 0x20, 0x0F, 0x50, 0xDD, 0x31, 0x3C, 0x1B,\n+            0xAB, 0x74, 0x58, 0x79, 0xA5, 0xAD, 0x95, 0x4A,\n+            0x72, 0xC4, 0x5A, 0x91, 0xC3, 0xA5, 0x1D, 0x3C,\n+            0x7A, 0xDE, 0xA9, 0x8D, 0x82, 0xF8, 0x48, 0x1E,\n+            0x0E, 0x1E, 0x03, 0x67, 0x4A, 0x6F, 0x3F, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk[32] = {\n+            0x0B, 0x43, 0x2B, 0x26, 0x77, 0x93, 0x73, 0x81,\n+            0xAE, 0xF0, 0x5B, 0xB0, 0x2A, 0x66, 0xEC, 0xD0,\n+            0x12, 0x77, 0x30, 0x62, 0xCF, 0x3F, 0xA2, 0x54,\n+            0x9E, 0x44, 0xF5, 0x8E, 0xD2, 0x40, 0x17, 0x10\n+        };\n+        const unsigned char pk[32] = {\n+            0x25, 0xD1, 0xDF, 0xF9, 0x51, 0x05, 0xF5, 0x25,\n+            0x3C, 0x40, 0x22, 0xF6, 0x28, 0xA9, 0x96, 0xAD,\n+            0x3A, 0x0D, 0x95, 0xFB, 0xF2, 0x1D, 0x46, 0x8A,\n+            0x1B, 0x33, 0xF8, 0xC1, 0x60, 0xD8, 0xF5, 0x17\n+        };\n+        unsigned char aux_rand[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+        };\n+        const unsigned char msg[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+        };\n+        const unsigned char sig[64] = {\n+            0x7E, 0xB0, 0x50, 0x97, 0x57, 0xE2, 0x46, 0xF1,\n+            0x94, 0x49, 0x88, 0x56, 0x51, 0x61, 0x1C, 0xB9,\n+            0x65, 0xEC, 0xC1, 0xA1, 0x87, 0xDD, 0x51, 0xB6,\n+            0x4F, 0xDA, 0x1E, 0xDC, 0x96, 0x37, 0xD5, 0xEC,\n+            0x97, 0x58, 0x2B, 0x9C, 0xB1, 0x3D, 0xB3, 0x93,\n+            0x37, 0x05, 0xB3, 0x2B, 0xA9, 0x82, 0xAF, 0x5A,\n+            0xF2, 0x5F, 0xD7, 0x88, 0x81, 0xEB, 0xB3, 0x27,\n+            0x71, 0xFC, 0x59, 0x22, 0xEF, 0xC6, 0x6E, 0xA3\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk, pk, aux_rand, msg, sig);\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk[32] = {\n+            0xD6, 0x9C, 0x35, 0x09, 0xBB, 0x99, 0xE4, 0x12,\n+            0xE6, 0x8B, 0x0F, 0xE8, 0x54, 0x4E, 0x72, 0x83,\n+            0x7D, 0xFA, 0x30, 0x74, 0x6D, 0x8B, 0xE2, 0xAA,\n+            0x65, 0x97, 0x5F, 0x29, 0xD2, 0x2D, 0xC7, 0xB9\n+        };\n+        const unsigned char msg[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x76, 0xAF, 0xB1, 0x54, 0x8A, 0xF6, 0x03, 0xB3,\n+            0xEB, 0x45, 0xC9, 0xF8, 0x20, 0x7D, 0xEE, 0x10,\n+            0x60, 0xCB, 0x71, 0xC0, 0x4E, 0x80, 0xF5, 0x93,\n+            0x06, 0x0B, 0x07, 0xD2, 0x83, 0x08, 0xD7, 0xF4\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk[32] = {\n+            0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77, 0x50,\n+            0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF, 0x21,\n+            0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76, 0x87,\n+            0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A, 0x34\n+        };\n+        secp256k1_xonly_pubkey pk_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_xonly_pubkey_parse(ctx, &pk_parsed, pk));\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0xFF, 0xF9, 0x7B, 0xD5, 0x75, 0x5E, 0xEE, 0xA4,\n+            0x20, 0x45, 0x3A, 0x14, 0x35, 0x52, 0x35, 0xD3,\n+            0x82, 0xF6, 0x47, 0x2F, 0x85, 0x68, 0xA1, 0x8B,\n+            0x2F, 0x05, 0x7A, 0x14, 0x60, 0x29, 0x75, 0x56,\n+            0x3C, 0xC2, 0x79, 0x44, 0x64, 0x0A, 0xC6, 0x07,\n+            0xCD, 0x10, 0x7A, 0xE1, 0x09, 0x23, 0xD9, 0xEF,\n+            0x7A, 0x73, 0xC6, 0x43, 0xE1, 0x66, 0xBE, 0x5E,\n+            0xBE, 0xAF, 0xA3, 0x4B, 0x1A, 0xC5, 0x53, 0xE2\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x1F, 0xA6, 0x2E, 0x33, 0x1E, 0xDB, 0xC2, 0x1C,\n+            0x39, 0x47, 0x92, 0xD2, 0xAB, 0x11, 0x00, 0xA7,\n+            0xB4, 0x32, 0xB0, 0x13, 0xDF, 0x3F, 0x6F, 0xF4,\n+            0xF9, 0x9F, 0xCB, 0x33, 0xE0, 0xE1, 0x51, 0x5F,\n+            0x28, 0x89, 0x0B, 0x3E, 0xDB, 0x6E, 0x71, 0x89,\n+            0xB6, 0x30, 0x44, 0x8B, 0x51, 0x5C, 0xE4, 0xF8,\n+            0x62, 0x2A, 0x95, 0x4C, 0xFE, 0x54, 0x57, 0x35,\n+            0xAA, 0xEA, 0x51, 0x34, 0xFC, 0xCD, 0xB2, 0xBD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x6C, 0xFF, 0x5C, 0x3B, 0xA8, 0x6C, 0x69, 0xEA,\n+            0x4B, 0x73, 0x76, 0xF3, 0x1A, 0x9B, 0xCB, 0x4F,\n+            0x74, 0xC1, 0x97, 0x60, 0x89, 0xB2, 0xD9, 0x96,\n+            0x3D, 0xA2, 0xE5, 0x54, 0x3E, 0x17, 0x77, 0x69,\n+            0x96, 0x17, 0x64, 0xB3, 0xAA, 0x9B, 0x2F, 0xFC,\n+            0xB6, 0xEF, 0x94, 0x7B, 0x68, 0x87, 0xA2, 0x26,\n+            0xE8, 0xD7, 0xC9, 0x3E, 0x00, 0xC5, 0xED, 0x0C,\n+            0x18, 0x34, 0xFF, 0x0D, 0x0C, 0x2E, 0x6D, 0xA6\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x12, 0x3D, 0xDA, 0x83, 0x28, 0xAF, 0x9C, 0x23,\n+            0xA9, 0x4C, 0x1F, 0xEE, 0xCF, 0xD1, 0x23, 0xBA,\n+            0x4F, 0xB7, 0x34, 0x76, 0xF0, 0xD5, 0x94, 0xDC,\n+            0xB6, 0x5C, 0x64, 0x25, 0xBD, 0x18, 0x60, 0x51\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x76, 0x15, 0xFB, 0xAF, 0x5A, 0xE2, 0x88, 0x64,\n+            0x01, 0x3C, 0x09, 0x97, 0x42, 0xDE, 0xAD, 0xB4,\n+            0xDB, 0xA8, 0x7F, 0x11, 0xAC, 0x67, 0x54, 0xF9,\n+            0x37, 0x80, 0xD5, 0xA1, 0x83, 0x7C, 0xF1, 0x97\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x69, 0xE8, 0x9B, 0x4C, 0x55, 0x64, 0xD0, 0x03,\n+            0x49, 0x10, 0x6B, 0x84, 0x97, 0x78, 0x5D, 0xD7,\n+            0xD1, 0xD7, 0x13, 0xA8, 0xAE, 0x82, 0xB3, 0x2F,\n+            0xA7, 0x9D, 0x5F, 0x7F, 0xC4, 0x07, 0xD3, 0x9B\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x69, 0xE8, 0x9B, 0x4C, 0x55, 0x64, 0xD0, 0x03,\n+            0x49, 0x10, 0x6B, 0x84, 0x97, 0x78, 0x5D, 0xD7,\n+            0xD1, 0xD7, 0x13, 0xA8, 0xAE, 0x82, 0xB3, 0x2F,\n+            0xA7, 0x9D, 0x5F, 0x7F, 0xC4, 0x07, 0xD3, 0x9B\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk[32] = {\n+            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,\n+            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,\n+            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,\n+            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59\n+        };\n+        const unsigned char msg[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig[64] = {\n+            0x6C, 0xFF, 0x5C, 0x3B, 0xA8, 0x6C, 0x69, 0xEA,\n+            0x4B, 0x73, 0x76, 0xF3, 0x1A, 0x9B, 0xCB, 0x4F,\n+            0x74, 0xC1, 0x97, 0x60, 0x89, 0xB2, 0xD9, 0x96,\n+            0x3D, 0xA2, 0xE5, 0x54, 0x3E, 0x17, 0x77, 0x69,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(pk, msg, sig, 0);\n+    }\n+    {\n+        /* Test vector 14 */\n+        const unsigned char pk[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30\n+        };\n+        secp256k1_xonly_pubkey pk_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_xonly_pubkey_parse(ctx, &pk_parsed, pk));\n+    }\n+}\n+\n+/* Nonce function that returns constant 0 */\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) xonly_pk32;\n+    (void) algo16;\n+    (void) data;\n+    (void) nonce32;\n+    return 0;\n+}\n+\n+/* Nonce function that sets nonce to 0 */\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) xonly_pk32;\n+    (void) algo16;\n+    (void) data;\n+\n+    memset(nonce32, 0, 32);\n+    return 1;\n+}\n+\n+/* Nonce function that sets nonce to 0xFF...0xFF */\n+static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) xonly_pk32;\n+    (void) algo16;\n+    (void) data;\n+\n+    memset(nonce32, 0xFF, 32);\n+    return 1;\n+}\n+\n+void test_schnorrsig_sign(void) {\n+    unsigned char sk[32];\n+    secp256k1_keypair keypair;\n+    const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n+    unsigned char sig[64];\n+    unsigned char zeros64[64] = { 0 };\n+\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+\n+    /* Test different nonce functions */\n+    memset(sig, 1, sizeof(sig));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n+    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    memset(&sig, 1, sizeof(sig));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n+    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n+    CHECK(memcmp(sig, zeros64, sizeof(sig)) != 0);\n+}\n+\n+#define N_SIGS 3\n+/* Creates N_SIGS valid signatures and verifies them with verify and\n+ * verify_batch (TODO). Then flips some bits and checks that verification now\n+ * fails. */\n+void test_schnorrsig_sign_verify(void) {\n+    unsigned char sk[32];\n+    unsigned char msg[N_SIGS][32];\n+    unsigned char sig[N_SIGS][64];\n+    size_t i;\n+    secp256k1_keypair keypair;\n+    secp256k1_xonly_pubkey pk;\n+    secp256k1_scalar s;\n+\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+\n+    for (i = 0; i < N_SIGS; i++) {\n+        secp256k1_rand256(msg[i]);\n+        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n+    }\n+\n+    {\n+        /* Flip a few bits in the signature and in the message and check that\n+         * verify and verify_batch (TODO) fail */\n+        size_t sig_idx = secp256k1_rand_int(N_SIGS);\n+        size_t byte_idx = secp256k1_rand_int(32);\n+        unsigned char xorbyte = secp256k1_rand_int(254)+1;\n+        sig[sig_idx][byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        sig[sig_idx][byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        sig[sig_idx][32+byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        sig[sig_idx][32+byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+\n+        /* Check that above bitflips have been reversed correctly */\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+    }\n+\n+    /* Test overflowing s */\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    memset(&sig[0][32], 0xFF, 32);\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+\n+    /* Test negative s */\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    secp256k1_scalar_set_b32(&s, &sig[0][32], NULL);\n+    secp256k1_scalar_negate(&s, &s);\n+    secp256k1_scalar_get_b32(&sig[0][32], &s);\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+}\n+#undef N_SIGS\n+\n+void test_schnorrsig_taproot(void) {\n+    unsigned char sk[32];\n+    secp256k1_keypair keypair;\n+    secp256k1_xonly_pubkey internal_pk;\n+    unsigned char internal_pk_bytes[32];\n+    secp256k1_xonly_pubkey output_pk;\n+    unsigned char output_pk_bytes[32];\n+    unsigned char tweak[32];\n+    int pk_parity;\n+    unsigned char msg[32];\n+    unsigned char sig[64];\n+\n+    /* Create output key */\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n+    /* In actual taproot the tweak would be hash of internal_pk */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, tweak, &internal_pk) == 1);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, tweak) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &output_pk, &pk_parity, &keypair) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk_bytes, &output_pk) == 1);\n+\n+    /* Key spend */\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    /* Verify key spend */\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &output_pk) == 1);\n+\n+    /* Script spend */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, internal_pk_bytes, &internal_pk) == 1);\n+    /* Verify script spend */\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &internal_pk, internal_pk_bytes) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk_bytes, pk_parity, &internal_pk, tweak) == 1);\n+}\n+\n+void run_schnorrsig_tests(void) {\n+    int i;\n+    run_nonce_function_bip340_tests();\n+\n+    test_schnorrsig_api();\n+    test_schnorrsig_sha256_tagged();\n+    test_schnorrsig_bip_vectors();\n+    for (i = 0; i < count; i++) {\n+        test_schnorrsig_sign();\n+        test_schnorrsig_sign_verify();\n+    }\n+    test_schnorrsig_taproot();\n+}\n+\n+#endif"
      },
      {
        "sha": "95d3e326c9c6f0f6959b90b30f191de988b509eb",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -8,19 +8,20 @@\n #define SECP256K1_SCALAR_H\n \n #include \"num.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n #endif\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n /** Clear a scalar to prevent the leak of sensitive data. */"
      },
      {
        "sha": "7f3992786101cf0f603aa447deb673afcdde125f",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -192,9 +192,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -207,7 +207,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -221,32 +221,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a));         \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "f8c7fa7efaba92980d6f74599c93b877887504be",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -271,9 +271,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -286,7 +286,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -300,32 +300,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a)); \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "2ec04b1ae9aa27c26ee1a6483a90ce3b292b2a16",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -16,12 +16,12 @@\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low_impl.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64_impl.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32_impl.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);"
      },
      {
        "sha": "b205620224b6bb339b09ee79e6347e5303aefee3",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -11,7 +11,7 @@\n #include \"scratch.h\"\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n-    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    const size_t base_alloc = ROUND_TO_ALIGN(sizeof(secp256k1_scratch));\n     void *alloc = checked_malloc(error_callback, base_alloc + size);\n     secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n@@ -60,6 +60,10 @@ static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_c\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n+    /* Ensure that multiplication will not wrap around */\n+    if (ALIGNMENT > 1 && objects > SIZE_MAX/(ALIGNMENT - 1)) {\n+        return 0;\n+    }\n     if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n         return 0;\n     }\n@@ -68,7 +72,14 @@ static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_c\n \n static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size = ROUND_TO_ALIGN(size);\n+    size_t rounded_size;\n+\n+    rounded_size = ROUND_TO_ALIGN(size);\n+    /* Check that rounding did not wrap around */\n+    if (rounded_size < size) {\n+        return NULL;\n+    }\n+    size = rounded_size;\n \n     if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");"
      },
      {
        "sha": "eaafb3a21d4f8494f77a489f4d37ca5292bc653f",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 53,
        "deletions": 25,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -7,6 +7,7 @@\n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_preallocated.h\"\n \n+#include \"assumptions.h\"\n #include \"util.h\"\n #include \"num_impl.h\"\n #include \"field_impl.h\"\n@@ -19,6 +20,7 @@\n #include \"eckey_impl.h\"\n #include \"hash_impl.h\"\n #include \"scratch_impl.h\"\n+#include \"selftest.h\"\n \n #if defined(VALGRIND)\n # include <valgrind/memcheck.h>\n@@ -117,6 +119,9 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     size_t prealloc_size;\n     secp256k1_context* ret;\n \n+    if (!secp256k1_selftest()) {\n+        secp256k1_callback_call(&default_error_callback, \"self test failed\");\n+    }\n     VERIFY_CHECK(prealloc != NULL);\n     prealloc_size = secp256k1_context_preallocated_size(flags);\n     ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n@@ -226,7 +231,7 @@ void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scr\n  *  of the software. This is setup for use with valgrind but could be substituted with\n  *  the appropriate instrumentation for other analysis tools.\n  */\n-static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, void *p, size_t len) {\n+static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, const void *p, size_t len) {\n #if defined(VALGRIND)\n     if (EXPECT(ctx->declassify,0)) VALGRIND_MAKE_MEM_DEFINED(p, len);\n #else\n@@ -291,7 +296,7 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n \n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n-    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n+    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33u : 65u));\n     len = *outputlen;\n     *outputlen = 0;\n     ARG_CHECK(output != NULL);\n@@ -548,26 +553,33 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey) {\n+static int secp256k1_ec_pubkey_create_helper(const secp256k1_ecmult_gen_context *ecmult_gen_ctx, secp256k1_scalar *seckey_scalar, secp256k1_ge *p, const unsigned char *seckey) {\n     secp256k1_gej pj;\n+    int ret;\n+\n+    ret = secp256k1_scalar_set_b32_seckey(seckey_scalar, seckey);\n+    secp256k1_scalar_cmov(seckey_scalar, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(ecmult_gen_ctx, &pj, seckey_scalar);\n+    secp256k1_ge_set_gej(p, &pj);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey) {\n     secp256k1_ge p;\n-    secp256k1_scalar sec;\n+    secp256k1_scalar seckey_scalar;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(seckey != NULL);\n \n-    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_one, !ret);\n-\n-    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n-    secp256k1_ge_set_gej(&p, &pj);\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey);\n     secp256k1_pubkey_save(pubkey, &p);\n     memczero(pubkey, sizeof(*pubkey), !ret);\n \n-    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_clear(&seckey_scalar);\n     return ret;\n }\n \n@@ -605,50 +617,58 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n     secp256k1_scalar term;\n+    int overflow = 0;\n+    int ret = 0;\n+\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar sec;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-\n-    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n-    secp256k1_scalar_clear(&term);\n     return ret;\n }\n \n int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak);\n }\n \n+static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak) {\n+    secp256k1_scalar term;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n+}\n+\n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n     secp256k1_ge p;\n-    secp256k1_scalar term;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n-    ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n+    ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak);\n     if (ret) {\n-        if (secp256k1_eckey_pubkey_tweak_add(&ctx->ecmult_ctx, &p, &term)) {\n-            secp256k1_pubkey_save(pubkey, &p);\n-        } else {\n-            ret = 0;\n-        }\n+        secp256k1_pubkey_save(pubkey, &p);\n     }\n \n     return ret;\n@@ -741,3 +761,11 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif\n+\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+# include \"modules/extrakeys/main_impl.h\"\n+#endif\n+\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/main_impl.h\"\n+#endif"
      },
      {
        "sha": "885983aa209997e47dd1ad92303b2d48ae182d64",
        "filename": "src/secp256k1/src/selftest.h",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/selftest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/selftest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/selftest.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -0,0 +1,32 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_SELFTEST_H\n+#define SECP256K1_SELFTEST_H\n+\n+#include \"hash.h\"\n+\n+#include <string.h>\n+\n+static int secp256k1_selftest_sha256(void) {\n+    static const char *input63 = \"For this sample, this 63-byte string will be used as input data\";\n+    static const unsigned char output32[32] = {\n+        0xf0, 0x8a, 0x78, 0xcb, 0xba, 0xee, 0x08, 0x2b, 0x05, 0x2a, 0xe0, 0x70, 0x8f, 0x32, 0xfa, 0x1e,\n+        0x50, 0xc5, 0xc4, 0x21, 0xaa, 0x77, 0x2b, 0xa5, 0xdb, 0xb4, 0x06, 0xa2, 0xea, 0x6b, 0xe3, 0x42,\n+    };\n+    unsigned char out[32];\n+    secp256k1_sha256 hasher;\n+    secp256k1_sha256_initialize(&hasher);\n+    secp256k1_sha256_write(&hasher, (const unsigned char*)input63, 63);\n+    secp256k1_sha256_finalize(&hasher, out);\n+    return memcmp(out, output32, 32) == 0;\n+}\n+\n+static int secp256k1_selftest(void) {\n+    return secp256k1_selftest_sha256();\n+}\n+\n+#endif /* SECP256K1_SELFTEST_H */"
      },
      {
        "sha": "bcbe15a6f1f1cd2bb5e12aa69e46a2238bc7116e",
        "filename": "src/secp256k1/src/testrand.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/testrand.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/testrand.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -35,4 +35,7 @@ static void secp256k1_rand256_test(unsigned char *b32);\n /** Generate pseudorandom bytes with long sequences of zero and one bits. */\n static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len);\n \n+/** Flip a single random bit in a byte array */\n+static void secp256k1_rand_flip(unsigned char *b, size_t len);\n+\n #endif /* SECP256K1_TESTRAND_H */"
      },
      {
        "sha": "dfb658d9c6451a18f1fe895a400a26231f5b1c03",
        "filename": "src/secp256k1/src/testrand_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand_impl.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -107,4 +107,8 @@ static void secp256k1_rand256_test(unsigned char *b32) {\n     secp256k1_rand_bytes_test(b32, 32);\n }\n \n+static void secp256k1_rand_flip(unsigned char *b, size_t len) {\n+    b[secp256k1_rand_int(len)] ^= (1 << secp256k1_rand_int(8));\n+}\n+\n #endif /* SECP256K1_TESTRAND_IMPL_H */"
      },
      {
        "sha": "4780e9319bd343423affbe68883c20f735b26023",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 102,
        "deletions": 11,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -182,8 +182,10 @@ void run_context_tests(int use_prealloc) {\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n     secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount2);\n-    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    /* set error callback (to a function that still aborts in case malloc() fails in secp256k1_context_clone() below) */\n+    secp256k1_context_set_error_callback(sign, secp256k1_default_illegal_callback_fn, NULL);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n \n     /* check if sizes for cloning are consistent */\n     CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n@@ -239,7 +241,8 @@ void run_context_tests(int use_prealloc) {\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n     /* And that it resets back to default. */\n     secp256k1_context_set_error_callback(sign, NULL, NULL);\n     CHECK(vrfy->error_callback.fn == sign->error_callback.fn);\n@@ -361,8 +364,8 @@ void run_scratch_tests(void) {\n     CHECK(scratch->alloc_size != 0);\n     CHECK(scratch->alloc_size % ALIGNMENT == 0);\n \n-    /* Allocating another 500 bytes fails */\n-    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    /* Allocating another 501 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 501) == NULL);\n     CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n     CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n     CHECK(scratch->alloc_size != 0);\n@@ -395,6 +398,18 @@ void run_scratch_tests(void) {\n     secp256k1_scratch_space_destroy(none, scratch);\n     CHECK(ecount == 5);\n \n+    /* Test that large integers do not wrap around in a bad way */\n+    scratch = secp256k1_scratch_space_create(none, 1000);\n+    /* Try max allocation with a large number of objects. Only makes sense if\n+     * ALIGNMENT is greater than 1 because otherwise the objects take no extra\n+     * space. */\n+    CHECK(ALIGNMENT <= 1 || !secp256k1_scratch_max_allocation(&none->error_callback, scratch, (SIZE_MAX / (ALIGNMENT - 1)) + 1));\n+    /* Try allocating SIZE_MAX to test wrap around which only happens if\n+     * ALIGNMENT > 1, otherwise it returns NULL anyway because the scratch\n+     * space is too small. */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, SIZE_MAX) == NULL);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+\n     /* cleanup */\n     secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n@@ -2215,6 +2230,9 @@ void test_ge(void) {\n                 /* Normal doubling. */\n                 secp256k1_gej_double_var(&resj, &gej[i2], NULL);\n                 ge_equals_gej(&ref, &resj);\n+                /* Constant-time doubling. */\n+                secp256k1_gej_double(&resj, &gej[i2]);\n+                ge_equals_gej(&ref, &resj);\n             }\n \n             /* Test adding opposites. */\n@@ -2300,6 +2318,39 @@ void test_ge(void) {\n     free(zinv);\n }\n \n+\n+void test_intialized_inf(void) {\n+    secp256k1_ge p;\n+    secp256k1_gej pj, npj, infj1, infj2, infj3;\n+    secp256k1_fe zinv;\n+\n+    /* Test that adding P+(-P) results in a fully initalized infinity*/\n+    random_group_element_test(&p);\n+    secp256k1_gej_set_ge(&pj, &p);\n+    secp256k1_gej_neg(&npj, &pj);\n+\n+    secp256k1_gej_add_var(&infj1, &pj, &npj, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&infj1));\n+    CHECK(secp256k1_fe_is_zero(&infj1.x));\n+    CHECK(secp256k1_fe_is_zero(&infj1.y));\n+    CHECK(secp256k1_fe_is_zero(&infj1.z));\n+\n+    secp256k1_gej_add_ge_var(&infj2, &npj, &p, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&infj2));\n+    CHECK(secp256k1_fe_is_zero(&infj2.x));\n+    CHECK(secp256k1_fe_is_zero(&infj2.y));\n+    CHECK(secp256k1_fe_is_zero(&infj2.z));\n+\n+    secp256k1_fe_set_int(&zinv, 1);\n+    secp256k1_gej_add_zinv_var(&infj3, &npj, &p, &zinv);\n+    CHECK(secp256k1_gej_is_infinity(&infj3));\n+    CHECK(secp256k1_fe_is_zero(&infj3.x));\n+    CHECK(secp256k1_fe_is_zero(&infj3.y));\n+    CHECK(secp256k1_fe_is_zero(&infj3.z));\n+\n+\n+}\n+\n void test_add_neg_y_diff_x(void) {\n     /* The point of this test is to check that we can add two points\n      * whose y-coordinates are negatives of each other but whose x\n@@ -2373,6 +2424,7 @@ void run_ge(void) {\n         test_ge();\n     }\n     test_add_neg_y_diff_x();\n+    test_intialized_inf();\n }\n \n void test_ec_combine(void) {\n@@ -2967,14 +3019,16 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n     secp256k1_scalar szero;\n-    secp256k1_scalar sc[32];\n-    secp256k1_ge pt[32];\n+    secp256k1_scalar sc;\n+    secp256k1_ge pt;\n     secp256k1_gej r;\n     ecmult_multi_data data;\n     secp256k1_scratch *scratch_empty;\n \n-    data.sc = sc;\n-    data.pt = pt;\n+    random_group_element_test(&pt);\n+    random_scalar_order(&sc);\n+    data.sc = &sc;\n+    data.pt = &pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n@@ -3232,6 +3286,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     int skew;\n     int bits = 256;\n     secp256k1_scalar num = *number;\n+    secp256k1_scalar scalar_skew;\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n@@ -3262,7 +3317,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n     /* Skew num because when encoding numbers as odd we use an offset */\n-    secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n+    secp256k1_scalar_set_int(&scalar_skew, 1 << (skew == 2));\n+    secp256k1_scalar_add(&num, &num, &scalar_skew);\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3374,13 +3430,32 @@ void run_wnaf(void) {\n     int i;\n     secp256k1_scalar n = {{0}};\n \n+    test_constant_wnaf(&n, 4);\n     /* Sanity check: 1 and 2 are the smallest odd and even numbers and should\n      *               have easier-to-diagnose failure modes  */\n     n.d[0] = 1;\n     test_constant_wnaf(&n, 4);\n     n.d[0] = 2;\n     test_constant_wnaf(&n, 4);\n-    /* Test 0 */\n+    /* Test -1, because it's a special case in wnaf_const */\n+    n = secp256k1_scalar_one;\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test -2, which may not lead to overflows in wnaf_const */\n+    secp256k1_scalar_add(&n, &secp256k1_scalar_one, &secp256k1_scalar_one);\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test (1/2) - 1 = 1/-2 and 1/2 = (1/-2) + 1\n+       as corner cases of negation handling in wnaf_const */\n+    secp256k1_scalar_inverse(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    secp256k1_scalar_add(&n, &n, &secp256k1_scalar_one);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test 0 for fixed wnaf */\n     test_fixed_wnaf_small();\n     /* Random tests */\n     for (i = 0; i < count; i++) {\n@@ -5277,6 +5352,14 @@ void run_ecdsa_openssl(void) {\n # include \"modules/recovery/tests_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+# include \"modules/extrakeys/tests_impl.h\"\n+#endif\n+\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/tests_impl.h\"\n+#endif\n+\n void run_memczero_test(void) {\n     unsigned char buf1[6] = {1, 2, 3, 4, 5, 6};\n     unsigned char buf2[sizeof(buf1)];\n@@ -5583,6 +5666,14 @@ int main(int argc, char **argv) {\n     run_recovery_tests();\n #endif\n \n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+    run_extrakeys_tests();\n+#endif\n+\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+    run_schnorrsig_tests();\n+#endif\n+\n     /* util tests */\n     run_memczero_test();\n "
      },
      {
        "sha": "681ed80bd0bc4ef2108313195ad89a3dd54e46b5",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -22,6 +22,7 @@\n #endif\n \n #include \"include/secp256k1.h\"\n+#include \"assumptions.h\"\n #include \"group.h\"\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n@@ -141,10 +142,8 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     /* Check doubling */\n     for (i = 0; i < order; i++) {\n         secp256k1_gej tmp;\n-        if (i > 0) {\n-            secp256k1_gej_double_nonzero(&tmp, &groupj[i]);\n-            ge_equals_gej(&group[(2 * i) % order], &tmp);\n-        }\n+        secp256k1_gej_double(&tmp, &groupj[i]);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n         ge_equals_gej(&group[(2 * i) % order], &tmp);\n     }"
      },
      {
        "sha": "a5cbe03ef52198544e5448888978a6bab772106a",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 51,
        "deletions": 7,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -170,13 +170,35 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n # define I64uFORMAT \"llu\"\n #endif\n \n-#if defined(HAVE___INT128)\n-# if defined(__GNUC__)\n-#  define SECP256K1_GNUC_EXT __extension__\n-# else\n-#  define SECP256K1_GNUC_EXT\n+#if defined(__GNUC__)\n+# define SECP256K1_GNUC_EXT __extension__\n+#else\n+# define SECP256K1_GNUC_EXT\n+#endif\n+\n+/* If SECP256K1_{LITTLE,BIG}_ENDIAN is not explicitly provided, infer from various other system macros. */\n+#if !defined(SECP256K1_LITTLE_ENDIAN) && !defined(SECP256K1_BIG_ENDIAN)\n+/* Inspired by https://github.com/rofl0r/endianness.h/blob/9853923246b065a3b52d2c43835f3819a62c7199/endianness.h#L52L73 */\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \\\n+     defined(_X86_) || defined(__x86_64__) || defined(__i386__) || \\\n+     defined(__i486__) || defined(__i586__) || defined(__i686__) || \\\n+     defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL) || \\\n+     defined(__ARMEL__) || defined(__AARCH64EL__) || \\\n+     (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__ == 1) || \\\n+     (defined(_LITTLE_ENDIAN) && _LITTLE_ENDIAN == 1) || \\\n+     defined(_M_IX86) || defined(_M_AMD64) || defined(_M_ARM) /* MSVC */\n+#  define SECP256K1_LITTLE_ENDIAN\n # endif\n-SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \\\n+     defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB) || \\\n+     defined(__MICROBLAZEEB__) || defined(__ARMEB__) || defined(__AARCH64EB__) || \\\n+     (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__ == 1) || \\\n+     (defined(_BIG_ENDIAN) && _BIG_ENDIAN == 1)\n+#  define SECP256K1_BIG_ENDIAN\n+# endif\n+#endif\n+#if defined(SECP256K1_LITTLE_ENDIAN) == defined(SECP256K1_BIG_ENDIAN)\n+# error Please make sure that either SECP256K1_LITTLE_ENDIAN or SECP256K1_BIG_ENDIAN is set, see src/util.h.\n #endif\n \n /* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n@@ -197,15 +219,37 @@ static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n     unsigned int mask0, mask1, r_masked, a_masked;\n+    /* Access flag with a volatile-qualified lvalue.\n+       This prevents clang from figuring out (after inlining) that flag can\n+       take only be 0 or 1, which leads to variable time code. */\n+    volatile int vflag = flag;\n+\n     /* Casting a negative int to unsigned and back to int is implementation defined behavior */\n     VERIFY_CHECK(*r >= 0 && *a >= 0);\n \n-    mask0 = (unsigned int)flag + ~0u;\n+    mask0 = (unsigned int)vflag + ~0u;\n     mask1 = ~mask0;\n     r_masked = ((unsigned int)*r & mask0);\n     a_masked = ((unsigned int)*a & mask1);\n \n     *r = (int)(r_masked | a_masked);\n }\n \n+/* If USE_FORCE_WIDEMUL_{INT128,INT64} is set, use that wide multiplication implementation.\n+ * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n+ */\n+#if defined(USE_FORCE_WIDEMUL_INT128)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#elif defined(USE_FORCE_WIDEMUL_INT64)\n+# define SECP256K1_WIDEMUL_INT64 1\n+#elif defined(__SIZEOF_INT128__)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#else\n+# define SECP256K1_WIDEMUL_INT64 1\n+#endif\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+SECP256K1_GNUC_EXT typedef __int128 int128_t;\n+#endif\n+\n #endif /* SECP256K1_UTIL_H */"
      },
      {
        "sha": "e676a8326cdfea98dd9457eeb874172694e827e2",
        "filename": "src/secp256k1/src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/894fb33f4c1b24667891f7d2aff9f486177b1173/src/secp256k1/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/valgrind_ctime_test.c?ref=894fb33f4c1b24667891f7d2aff9f486177b1173",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <valgrind/memcheck.h>\n #include \"include/secp256k1.h\"\n+#include \"assumptions.h\"\n #include \"util.h\"\n \n #if ENABLE_MODULE_ECDH\n@@ -16,6 +17,14 @@\n # include \"include/secp256k1_recovery.h\"\n #endif\n \n+#if ENABLE_MODULE_EXTRAKEYS\n+# include \"include/secp256k1_extrakeys.h\"\n+#endif\n+\n+#if ENABLE_MODULE_SCHNORRSIG\n+#include \"include/secp256k1_schnorrsig.h\"\n+#endif\n+\n int main(void) {\n     secp256k1_context* ctx;\n     secp256k1_ecdsa_signature signature;\n@@ -32,6 +41,9 @@ int main(void) {\n     secp256k1_ecdsa_recoverable_signature recoverable_signature;\n     int recid;\n #endif\n+#if ENABLE_MODULE_EXTRAKEYS\n+    secp256k1_keypair keypair;\n+#endif\n \n     if (!RUNNING_ON_VALGRIND) {\n         fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n@@ -49,7 +61,9 @@ int main(void) {\n         msg[i] = i + 1;\n     }\n \n-    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_DECLASSIFY);\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN\n+                                   | SECP256K1_CONTEXT_VERIFY\n+                                   | SECP256K1_CONTEXT_DECLASSIFY);\n \n     /* Test keygen. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n@@ -114,6 +128,30 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret);\n \n+    /* Test keypair_create and keypair_xonly_tweak_add. */\n+#if ENABLE_MODULE_EXTRAKEYS\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* The tweak is not treated as a secret in keypair_tweak_add */\n+    VALGRIND_MAKE_MEM_DEFINED(msg, 32);\n+    ret = secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n+#if ENABLE_MODULE_SCHNORRSIG\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n     secp256k1_context_destroy(ctx);\n     return 0;\n }"
      }
    ]
  }
]