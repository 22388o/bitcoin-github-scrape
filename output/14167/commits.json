[
  {
    "sha": "af69cb2d70ded43576e2e56f9032fa3461055b53",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjY5Y2IyZDcwZGVkNDM1NzZlMmU1NmY5MDMyZmEzNDYxMDU1YjUz",
    "commit": {
      "author": {
        "name": "Emanuele Cisbani",
        "email": "emanuele.cisbani@gmail.com",
        "date": "2018-08-22T06:00:45Z"
      },
      "committer": {
        "name": "Emanuele Cisbani",
        "email": "emanuele.cisbani@gmail.com",
        "date": "2018-09-06T16:07:34Z"
      },
      "message": "docs: improve linux tar packages\n\n    - README.md main file placed inside share/doc/bitcoin lsb directory\n    - Updated README.md to include link to repo, files list and description\n    - Added example bitcoin.conf, init files for daemon, RPCAuth Tool\n\n    This fixes #8160 (partially), fixes #8161, see also PR #11971 and #14022",
      "tree": {
        "sha": "118ee926b33060d751705183efb496860f01bf05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/118ee926b33060d751705183efb496860f01bf05"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af69cb2d70ded43576e2e56f9032fa3461055b53",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af69cb2d70ded43576e2e56f9032fa3461055b53",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af69cb2d70ded43576e2e56f9032fa3461055b53",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af69cb2d70ded43576e2e56f9032fa3461055b53/comments",
    "author": {
      "login": "cisba",
      "id": 2389559,
      "node_id": "MDQ6VXNlcjIzODk1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2389559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cisba",
      "html_url": "https://github.com/cisba",
      "followers_url": "https://api.github.com/users/cisba/followers",
      "following_url": "https://api.github.com/users/cisba/following{/other_user}",
      "gists_url": "https://api.github.com/users/cisba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cisba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cisba/subscriptions",
      "organizations_url": "https://api.github.com/users/cisba/orgs",
      "repos_url": "https://api.github.com/users/cisba/repos",
      "events_url": "https://api.github.com/users/cisba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cisba/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cisba",
      "id": 2389559,
      "node_id": "MDQ6VXNlcjIzODk1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2389559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cisba",
      "html_url": "https://github.com/cisba",
      "followers_url": "https://api.github.com/users/cisba/followers",
      "following_url": "https://api.github.com/users/cisba/following{/other_user}",
      "gists_url": "https://api.github.com/users/cisba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cisba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cisba/subscriptions",
      "organizations_url": "https://api.github.com/users/cisba/orgs",
      "repos_url": "https://api.github.com/users/cisba/repos",
      "events_url": "https://api.github.com/users/cisba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cisba/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f7ae35ce8cf5d681de8e41a2f7c0f623fa71fc5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f7ae35ce8cf5d681de8e41a2f7c0f623fa71fc5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f7ae35ce8cf5d681de8e41a2f7c0f623fa71fc5"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 24,
      "deletions": 2
    },
    "files": [
      {
        "sha": "ae132aacc74248cde0ad1ecaa34fc3c353fe7ef0",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af69cb2d70ded43576e2e56f9032fa3461055b53/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af69cb2d70ded43576e2e56f9032fa3461055b53/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=af69cb2d70ded43576e2e56f9032fa3461055b53",
        "patch": "@@ -181,9 +181,15 @@ script: |\n     rm -rf ${DISTNAME}/lib/pkgconfig\n     find ${DISTNAME}/bin -type f -executable -exec ../contrib/devtools/split-debug.sh {} {} {}.dbg \\;\n     find ${DISTNAME}/lib -type f -exec ../contrib/devtools/split-debug.sh {} {} {}.dbg \\;\n-    cp ../doc/README.md ${DISTNAME}/\n     find ${DISTNAME} -not -name \"*.dbg\" | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n     find ${DISTNAME} -name \"*.dbg\" | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}-debug.tar.gz\n+    DOCDISTNAME=\"${DISTNAME}/share/doc/bitcoin\"\n+    mkdir -p ${DOCDISTNAME}/init\n+    cp ../doc/README.md ${DOCDISTNAME}\n+    cp -r ../share/examples ${DOCDISTNAME}\n+    cp -r ../share/rpcauth ${DOCDISTNAME}\n+    cp ../contrib/init/bitcoind.* ${DOCDISTNAME}/init/\n+    cp ../contrib/init/README.md ${DOCDISTNAME}/init/\n     cd ../../\n     rm -rf distsrc-${i}\n   done"
      },
      {
        "sha": "87672e34047a2230f42a3c1b39a6d177828a1107",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af69cb2d70ded43576e2e56f9032fa3461055b53/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af69cb2d70ded43576e2e56f9032fa3461055b53/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=af69cb2d70ded43576e2e56f9032fa3461055b53",
        "patch": "@@ -7,6 +7,8 @@ Bitcoin Core is the original Bitcoin client and it builds the backbone of the ne\n \n To download Bitcoin Core, visit [bitcoincore.org](https://bitcoincore.org/en/releases/).\n \n+The main source code repository is [hosted on GitHub](https://github.com/bitcoin/bitcoin/).\n+\n Running\n ---------------------\n The following are some helpful notes on how to run Bitcoin Core on your native platform.\n@@ -20,12 +22,26 @@ Unpack the files into a directory and run:\n \n ### Windows\n \n-Unpack the files into a directory, and then run bitcoin-qt.exe.\n+Unpack the files into a directory, and then run:\n+\n+- `bitcoin-qt.exe`\n \n ### macOS\n \n Drag Bitcoin Core to your applications folder, and then run Bitcoin Core.\n \n+### Files\n+\n+* `./bin/bitcoin-cli` (Command Line Interface)\n+* `./bin/bitcoind` (headless daemon)\n+* `./bin/bitcoin-qt` (GUI)\n+* `./bin/bitcoin-tx` (hex-encoded transaction tool)\n+* `./bin/test_bitcoin` (runs the unit tests)\n+* `./include/bitcoinconsensus.h` (lib header)\n+* `./lib/libbitcoinconsensus.so.0.0.0` (shared lib)\n+* `./share/man/man1/` (man pages)\n+* `./share/doc/` (documentation)\n+\n ### Need Help?\n \n * See the documentation at the [Bitcoin Wiki](https://en.bitcoin.it/wiki/Main_Page)"
      }
    ]
  },
  {
    "sha": "69eca482e804cb72cdabcbcaa4581362fe573fd3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OWVjYTQ4MmU4MDRjYjcyY2RhYmNiY2FhNDU4MTM2MmZlNTczZmQz",
    "commit": {
      "author": {
        "name": "Emanuele Cisbani",
        "email": "emanuele.cisbani@gmail.com",
        "date": "2018-10-02T21:41:06Z"
      },
      "committer": {
        "name": "Emanuele Cisbani",
        "email": "emanuele.cisbani@gmail.com",
        "date": "2018-10-02T21:41:06Z"
      },
      "message": "Merge branch 'master' into fix-10746",
      "tree": {
        "sha": "e713554ae4bde4903b7b64ecaffe3b369a2d1d67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e713554ae4bde4903b7b64ecaffe3b369a2d1d67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69eca482e804cb72cdabcbcaa4581362fe573fd3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69eca482e804cb72cdabcbcaa4581362fe573fd3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/69eca482e804cb72cdabcbcaa4581362fe573fd3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69eca482e804cb72cdabcbcaa4581362fe573fd3/comments",
    "author": {
      "login": "cisba",
      "id": 2389559,
      "node_id": "MDQ6VXNlcjIzODk1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2389559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cisba",
      "html_url": "https://github.com/cisba",
      "followers_url": "https://api.github.com/users/cisba/followers",
      "following_url": "https://api.github.com/users/cisba/following{/other_user}",
      "gists_url": "https://api.github.com/users/cisba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cisba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cisba/subscriptions",
      "organizations_url": "https://api.github.com/users/cisba/orgs",
      "repos_url": "https://api.github.com/users/cisba/repos",
      "events_url": "https://api.github.com/users/cisba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cisba/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cisba",
      "id": 2389559,
      "node_id": "MDQ6VXNlcjIzODk1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2389559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cisba",
      "html_url": "https://github.com/cisba",
      "followers_url": "https://api.github.com/users/cisba/followers",
      "following_url": "https://api.github.com/users/cisba/following{/other_user}",
      "gists_url": "https://api.github.com/users/cisba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cisba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cisba/subscriptions",
      "organizations_url": "https://api.github.com/users/cisba/orgs",
      "repos_url": "https://api.github.com/users/cisba/repos",
      "events_url": "https://api.github.com/users/cisba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cisba/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af69cb2d70ded43576e2e56f9032fa3461055b53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af69cb2d70ded43576e2e56f9032fa3461055b53",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af69cb2d70ded43576e2e56f9032fa3461055b53"
      },
      {
        "sha": "cb25cd6aa18c69918176d68e36e26f7e373aa48c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb25cd6aa18c69918176d68e36e26f7e373aa48c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb25cd6aa18c69918176d68e36e26f7e373aa48c"
      }
    ],
    "stats": {
      "total": 711,
      "additions": 365,
      "deletions": 346
    },
    "files": [
      {
        "sha": "0b96e15b9e221bfab531697213ab5ede718fcb58",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -130,6 +130,12 @@ AC_ARG_ENABLE(gui-tests,\n     [use_gui_tests=$enableval],\n     [use_gui_tests=$use_tests])\n \n+AC_ARG_WITH([rapidcheck],\n+  [AS_HELP_STRING([--with-rapidcheck],\n+  [enable RapidCheck property based tests (default is yes if librapidcheck is found)])],\n+  [use_rapidcheck=$withval],\n+  [use_rapidcheck=auto])\n+\n AC_ARG_ENABLE(bench,\n     AS_HELP_STRING([--disable-bench],[do not compile benchmarks (default is to compile)]),\n     [use_bench=$enableval],\n@@ -1134,6 +1140,22 @@ AC_CHECK_DECLS([EVP_MD_CTX_new],,,[AC_INCLUDES_DEFAULT\n ])\n CXXFLAGS=\"${save_CXXFLAGS}\"\n \n+dnl RapidCheck Property Based Testing\n+\n+enable_property_tests=no\n+if test \"x$use_rapidcheck\" = xauto; then\n+    AC_CHECK_HEADERS([rapidcheck.h], [enable_property_tests=yes])\n+elif test \"x$use_rapidcheck\" != xno; then\n+    enable_property_tests=yes\n+fi\n+\n+RAPIDCHECK_LIBS=\n+if test \"x$enable_property_tests\" = xyes; then\n+   RAPIDCHECK_LIBS=-lrapidcheck\n+fi\n+AC_SUBST(RAPIDCHECK_LIBS)\n+AM_CONDITIONAL([ENABLE_PROPERTY_TESTS], [test x$enable_property_tests = xyes])\n+\n dnl univalue check\n \n need_bundled_univalue=yes"
      },
      {
        "sha": "da81c4c7eeb6f8ff50e73fe99007ad272ef904c9",
        "filename": "depends/Makefile",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/Makefile?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -5,6 +5,7 @@ WORK_PATH = $(BASEDIR)/work\n BASE_CACHE ?= $(BASEDIR)/built\n SDK_PATH ?= $(BASEDIR)/SDKs\n NO_QT ?=\n+RAPIDCHECK ?=\n NO_WALLET ?=\n NO_UPNP ?=\n FALLBACK_DOWNLOAD_PATH ?= https://bitcoincore.org/depends-sources\n@@ -93,13 +94,19 @@ qt_packages_$(NO_QT) = $(qt_packages) $(qt_$(host_os)_packages) $(qt_$(host_arch\n wallet_packages_$(NO_WALLET) = $(wallet_packages)\n upnp_packages_$(NO_UPNP) = $(upnp_packages)\n \n+rapidcheck_packages_$(RAPIDCHECK) = $(rapidcheck_packages)\n+\n packages += $($(host_arch)_$(host_os)_packages) $($(host_os)_packages) $(qt_packages_) $(wallet_packages_) $(upnp_packages_)\n native_packages += $($(host_arch)_$(host_os)_native_packages) $($(host_os)_native_packages)\n \n ifneq ($(qt_packages_),)\n native_packages += $(qt_native_packages)\n endif\n \n+ifeq ($(rapidcheck_packages_),)\n+packages += $(rapidcheck_packages)\n+endif\n+\n all_packages = $(packages) $(native_packages)\n \n meta_depends = Makefile funcs.mk builders/default.mk hosts/default.mk hosts/$(host_os).mk builders/$(build_os).mk"
      },
      {
        "sha": "73bfc8b726fc2dba22aba640953ba39d98e9d9f3",
        "filename": "depends/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -63,6 +63,7 @@ The following can be set when running make: make FOO=bar\n     NO_WALLET: Don't download/build/cache libs needed to enable the wallet\n     NO_UPNP: Don't download/build/cache packages needed for enabling upnp\n     DEBUG: disable some optimizations and enable more runtime checking\n+    RAPIDCHECK: build rapidcheck (experimental)\n     HOST_ID_SALT: Optional salt to use when generating host package ids\n     BUILD_ID_SALT: Optional salt to use when generating build package ids\n "
      },
      {
        "sha": "38329d16d736544a32b4f3279584be1da3a4cea7",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -5,6 +5,8 @@ qt_packages = qrencode protobuf zlib\n \n qt_linux_packages:=qt expat dbus libxcb xcb_proto libXau xproto freetype fontconfig libX11 xextproto libXext xtrans\n \n+rapidcheck_packages = rapidcheck\n+\n qt_darwin_packages=qt\n qt_mingw32_packages=qt\n "
      },
      {
        "sha": "19cf1cae2ec83e95b7a1d00b33476346c9ff199f",
        "filename": "depends/packages/rapidcheck.mk",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/packages/rapidcheck.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/depends/packages/rapidcheck.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/rapidcheck.mk?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -0,0 +1,18 @@\n+package=rapidcheck\n+$(package)_version=10fc0cb\n+$(package)_download_path=https://github.com/MarcoFalke/rapidcheck/archive\n+$(package)_file_name=$(package)-$($(package)_version).tar.gz\n+$(package)_sha256_hash=9640926223c00af45bce4c7df8b756b5458a89b2ba74cfe3e404467f13ce26df\n+\n+define $(package)_config_cmds\n+  cmake -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=true .\n+endef\n+\n+define $(package)_build_cmds\n+  $(MAKE) && \\\n+  mkdir -p $($(package)_staging_dir)$(host_prefix)/include && \\\n+  cp -a include/* $($(package)_staging_dir)$(host_prefix)/include/ && \\\n+  cp -a extras/boost_test/include/rapidcheck/* $($(package)_staging_dir)$(host_prefix)/include/rapidcheck/ && \\\n+  mkdir -p $($(package)_staging_dir)$(host_prefix)/lib && \\\n+  cp -a librapidcheck.a $($(package)_staging_dir)$(host_prefix)/lib/\n+endef"
      },
      {
        "sha": "1fa01d0d6e34f43b6514dc9b9a78f31dbde3e064",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -64,6 +64,17 @@ Build Bitcoin Core\n \n         make deploy\n \n+Disable-wallet mode\n+--------------------\n+When the intention is to run only a P2P node without a wallet, Bitcoin Core may be compiled in\n+disable-wallet mode with:\n+\n+    ./configure --disable-wallet\n+\n+In this case there is no dependency on Berkeley DB 4.8.\n+\n+Mining is also possible in disable-wallet mode using the `getblocktemplate` RPC call.\n+\n Running\n -------\n "
      },
      {
        "sha": "337de12b8d26bfbe3faf496ff9b1164b81422f1e",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -234,8 +234,7 @@ disable-wallet mode with:\n \n In this case there is no dependency on Berkeley DB 4.8.\n \n-Mining is also possible in disable-wallet mode, but only using the `getblocktemplate` RPC\n-call not `getwork`.\n+Mining is also possible in disable-wallet mode using the `getblocktemplate` RPC call.\n \n Additional Configure Flags\n --------------------------\n@@ -284,4 +283,3 @@ To build executables for ARM:\n \n \n For further documentation on the depends system see [README.md](../depends/README.md) in the depends directory.\n-"
      },
      {
        "sha": "c4ee5f5fcc4862076e44e43172a6cf158984e55e",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -8,6 +8,7 @@ TEST_SRCDIR = test\n TEST_BINARY=test/test_bitcoin$(EXEEXT)\n \n JSON_TEST_FILES = \\\n+  test/data/script_tests.json \\\n   test/data/base58_encode_decode.json \\\n   test/data/blockfilters.json \\\n   test/data/key_io_valid.json \\\n@@ -95,6 +96,15 @@ BITCOIN_TESTS =\\\n   test/validation_block_tests.cpp \\\n   test/versionbits_tests.cpp\n \n+if ENABLE_PROPERTY_TESTS\n+BITCOIN_TESTS += \\\n+  test/key_properties.cpp\n+\n+BITCOIN_TEST_SUITE += \\\n+  test/gen/crypto_gen.cpp \\\n+  test/gen/crypto_gen.h\n+endif\n+\n if ENABLE_WALLET\n BITCOIN_TESTS += \\\n   wallet/test/psbt_wallet_tests.cpp \\\n@@ -118,7 +128,7 @@ test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_C\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n-test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n+test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n \n if ENABLE_ZMQ"
      },
      {
        "sha": "a3b04c6c446d53a66376da2f823b86d70c7ba74c",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -388,7 +388,7 @@ void SetupServerArgs()\n             \"Warning: Reverting this setting requires re-downloading the entire blockchain. \"\n             \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >=%u = automatically prune block files to stay under the specified target size in MiB)\", MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024), false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-reindex\", \"Rebuild chain state and block index from the blk*.dat files on disk\", false, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-reindex-chainstate\", \"Rebuild chain state from the currently indexed blocks\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-reindex-chainstate\", \"Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.\", false, OptionsCategory::OPTIONS);\n #ifndef WIN32\n     gArgs.AddArg(\"-sysperms\", \"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\", false, OptionsCategory::OPTIONS);\n #else"
      },
      {
        "sha": "b7d05cef1142950b4778cafce922b021a60a3178",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 25,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -19,11 +19,6 @@\n #include <timedata.h>\n #include <util.h>\n #include <utilstrencodings.h>\n-#ifdef ENABLE_WALLET\n-#include <wallet/rpcwallet.h>\n-#include <wallet/wallet.h>\n-#include <wallet/walletdb.h>\n-#endif\n #include <warnings.h>\n \n #include <stdint.h>\n@@ -67,29 +62,18 @@ static UniValue validateaddress(const JSONRPCRequest& request)\n     ret.pushKV(\"isvalid\", isValid);\n     if (isValid)\n     {\n+        std::string currentAddress = EncodeDestination(dest);\n+        ret.pushKV(\"address\", currentAddress);\n \n-#ifdef ENABLE_WALLET\n-        if (HasWallets() && IsDeprecatedRPCEnabled(\"validateaddress\")) {\n-            ret.pushKVs(getaddressinfo(request));\n-        }\n-#endif\n-        if (ret[\"address\"].isNull()) {\n-            std::string currentAddress = EncodeDestination(dest);\n-            ret.pushKV(\"address\", currentAddress);\n-\n-            CScript scriptPubKey = GetScriptForDestination(dest);\n-            ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n+        CScript scriptPubKey = GetScriptForDestination(dest);\n+        ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n \n-            UniValue detail = DescribeAddress(dest);\n-            ret.pushKVs(detail);\n-        }\n+        UniValue detail = DescribeAddress(dest);\n+        ret.pushKVs(detail);\n     }\n     return ret;\n }\n \n-// Needed even with !ENABLE_WALLET, to pass (ignored) pointers around\n-class CWallet;\n-\n static UniValue createmultisig(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n@@ -130,8 +114,7 @@ static UniValue createmultisig(const JSONRPCRequest& request)\n         if (IsHex(keys[i].get_str()) && (keys[i].get_str().length() == 66 || keys[i].get_str().length() == 130)) {\n             pubkeys.push_back(HexToPubKey(keys[i].get_str()));\n         } else {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid public key: %s\\nNote that from v0.16, createmultisig no longer accepts addresses.\"\n-            \" Users must use addmultisigaddress to create multisig addresses with addresses known to the wallet.\", keys[i].get_str()));\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid public key: %s\\n.\", keys[i].get_str()));\n         }\n     }\n \n@@ -461,7 +444,7 @@ static const CRPCCommand commands[] =\n   //  --------------------- ------------------------  -----------------------  ----------\n     { \"control\",            \"getmemoryinfo\",          &getmemoryinfo,          {\"mode\"} },\n     { \"control\",            \"logging\",                &logging,                {\"include\", \"exclude\"}},\n-    { \"util\",               \"validateaddress\",        &validateaddress,        {\"address\"} }, /* uses wallet if enabled */\n+    { \"util\",               \"validateaddress\",        &validateaddress,        {\"address\"} },\n     { \"util\",               \"createmultisig\",         &createmultisig,         {\"nrequired\",\"keys\"} },\n     { \"util\",               \"verifymessage\",          &verifymessage,          {\"address\",\"signature\",\"message\"} },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, {\"privkey\",\"message\"} },"
      },
      {
        "sha": "6acf383646262edd413950ec1c8fe7262b52be78",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 105,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -27,9 +27,6 @@\n #include <txmempool.h>\n #include <uint256.h>\n #include <utilstrencodings.h>\n-#ifdef ENABLE_WALLET\n-#include <wallet/rpcwallet.h>\n-#endif\n \n #include <future>\n #include <stdint.h>\n@@ -824,8 +821,7 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n                 view.AddCoin(out, std::move(newcoin), true);\n             }\n \n-            // if redeemScript given and not using the local wallet (private keys\n-            // given), add redeemScript to the keystore so it can be signed:\n+            // if redeemScript and private keys were given, add redeemScript to the keystore so it can be signed\n             if (is_temp_keystore && (scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash())) {\n                 RPCTypeCheckObj(prevOut,\n                     {\n@@ -980,102 +976,10 @@ static UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n \n UniValue signrawtransaction(const JSONRPCRequest& request)\n {\n-#ifdef ENABLE_WALLET\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    CWallet* const pwallet = wallet.get();\n-#endif\n-\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw std::runtime_error(\n-            \"signrawtransaction \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] [\\\"privatekey1\\\",...] sighashtype )\\n\"\n-            \"\\nDEPRECATED. Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n-            \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n-            \"this transaction depends on but may not yet be in the block chain.\\n\"\n-            \"The third optional argument (may be null) is an array of base58-encoded private\\n\"\n-            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n-#ifdef ENABLE_WALLET\n-            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n-#endif\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"     (string, required) The transaction hex string\\n\"\n-            \"2. \\\"prevtxs\\\"       (string, optional) An json array of previous dependent transaction outputs\\n\"\n-            \"     [               (json array of json objects, or 'null' if none provided)\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n-            \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\",   (string, required for P2SH or P2WSH) redeem script\\n\"\n-            \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"    ]\\n\"\n-            \"3. \\\"privkeys\\\"     (string, optional) A json array of base58-encoded private keys for signing\\n\"\n-            \"    [                  (json array of strings, or 'null' if none provided)\\n\"\n-            \"      \\\"privatekey\\\"   (string) private key in base58-encoding\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"4. \\\"sighashtype\\\"     (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n-            \"       \\\"ALL\\\"\\n\"\n-            \"       \\\"NONE\\\"\\n\"\n-            \"       \\\"SINGLE\\\"\\n\"\n-            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded raw transaction with signature(s)\\n\"\n-            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n-            \"  \\\"errors\\\" : [                 (json array of objects) Script verification errors (if there are any)\\n\"\n-            \"    {\\n\"\n-            \"      \\\"txid\\\" : \\\"hash\\\",           (string) The hash of the referenced, previous transaction\\n\"\n-            \"      \\\"vout\\\" : n,                (numeric) The index of the output to spent and used as input\\n\"\n-            \"      \\\"scriptSig\\\" : \\\"hex\\\",       (string) The hex-encoded signature script\\n\"\n-            \"      \\\"sequence\\\" : n,            (numeric) Script sequence number\\n\"\n-            \"      \\\"error\\\" : \\\"text\\\"           (string) Verification or signing error related to the input\\n\"\n-            \"    }\\n\"\n-            \"    ,...\\n\"\n-            \"  ]\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\")\n-            + HelpExampleRpc(\"signrawtransaction\", \"\\\"myhex\\\"\")\n-        );\n-\n-    if (!IsDeprecatedRPCEnabled(\"signrawtransaction\")) {\n-        throw JSONRPCError(RPC_METHOD_DEPRECATED, \"signrawtransaction is deprecated and will be fully removed in v0.18. \"\n-            \"To use signrawtransaction in v0.17, restart bitcoind with -deprecatedrpc=signrawtransaction.\\n\"\n-            \"Projects should transition to using signrawtransactionwithkey and signrawtransactionwithwallet before upgrading to v0.18\");\n-    }\n-\n-    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);\n-\n-    // Make a JSONRPCRequest to pass on to the right signrawtransaction* command\n-    JSONRPCRequest new_request;\n-    new_request.id = request.id;\n-    new_request.params.setArray();\n-\n-    // For signing with private keys\n-    if (!request.params[2].isNull()) {\n-        new_request.params.push_back(request.params[0]);\n-        // Note: the prevtxs and privkeys are reversed for signrawtransactionwithkey\n-        new_request.params.push_back(request.params[2]);\n-        new_request.params.push_back(request.params[1]);\n-        new_request.params.push_back(request.params[3]);\n-        return signrawtransactionwithkey(new_request);\n-    } else {\n-#ifdef ENABLE_WALLET\n-        // Otherwise sign with the wallet which does not take a privkeys parameter\n-        new_request.params.push_back(request.params[0]);\n-        new_request.params.push_back(request.params[1]);\n-        new_request.params.push_back(request.params[3]);\n-        return signrawtransactionwithwallet(new_request);\n-#else\n-        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"No private keys available.\");\n-#endif\n-    }\n+    // This method should be removed entirely in V0.19, along with the entries in the\n+    // CRPCCommand table and rpc/client.cpp.\n+    throw JSONRPCError(RPC_METHOD_DEPRECATED, \"signrawtransaction was removed in v0.18.\\n\"\n+        \"Clients should transition to using signrawtransactionwithkey and signrawtransactionwithwallet\");\n }\n \n static UniValue sendrawtransaction(const JSONRPCRequest& request)\n@@ -1084,7 +988,7 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n         throw std::runtime_error(\n             \"sendrawtransaction \\\"hexstring\\\" ( allowhighfees )\\n\"\n             \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\n-            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\n+            \"\\nAlso see createrawtransaction and signrawtransactionwithkey calls.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"hexstring\\\"    (string, required) The hex string of the raw transaction)\\n\"\n             \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\n@@ -1094,7 +998,7 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n             \"\\nCreate a transaction\\n\"\n             + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n             \"Sign the transaction, and get back the hex\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            + HelpExampleCli(\"signrawtransactionwithwallet\", \"\\\"myhex\\\"\") +\n             \"\\nSend the transaction (signed hex)\\n\"\n             + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedhex\\\"\") +\n             \"\\nAs a json rpc call\\n\"\n@@ -1199,7 +1103,7 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n             \"\\nCreate a transaction\\n\"\n             + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n             \"Sign the transaction, and get back the hex\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            + HelpExampleCli(\"signrawtransactionwithwallet\", \"\\\"myhex\\\"\") +\n             \"\\nTest acceptance of the transaction (signed hex)\\n\"\n             + HelpExampleCli(\"testmempoolaccept\", \"\\\"signedhex\\\"\") +\n             \"\\nAs a json rpc call\\n\"\n@@ -1800,7 +1704,7 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"decodescript\",                 &decodescript,              {\"hexstring\"} },\n     { \"rawtransactions\",    \"sendrawtransaction\",           &sendrawtransaction,        {\"hexstring\",\"allowhighfees\"} },\n     { \"rawtransactions\",    \"combinerawtransaction\",        &combinerawtransaction,     {\"txs\"} },\n-    { \"rawtransactions\",    \"signrawtransaction\",           &signrawtransaction,        {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n+    { \"hidden\",             \"signrawtransaction\",           &signrawtransaction,        {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} },\n     { \"rawtransactions\",    \"signrawtransactionwithkey\",    &signrawtransactionwithkey, {\"hexstring\",\"privkeys\",\"prevtxs\",\"sighashtype\"} },\n     { \"rawtransactions\",    \"testmempoolaccept\",            &testmempoolaccept,         {\"rawtxs\",\"allowhighfees\"} },\n     { \"rawtransactions\",    \"decodepsbt\",                   &decodepsbt,                {\"psbt\"} },"
      },
      {
        "sha": "ca8c65806ff884722f5473f263a953c457862a7f",
        "filename": "src/test/gen/crypto_gen.cpp",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/test/gen/crypto_gen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/test/gen/crypto_gen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/gen/crypto_gen.cpp?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <test/gen/crypto_gen.h>\n+\n+#include <key.h>\n+\n+#include <rapidcheck/gen/Arbitrary.h>\n+#include <rapidcheck/Gen.h>\n+#include <rapidcheck/gen/Predicate.h>\n+#include <rapidcheck/gen/Container.h>\n+\n+/** Generates 1 to 20 keys for OP_CHECKMULTISIG */\n+rc::Gen<std::vector<CKey>> MultisigKeys()\n+{\n+    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {\n+        return keys.size() >= 1 && keys.size() <= 15;\n+    });\n+};"
      },
      {
        "sha": "7c2fb0350fa50acf00f08409d083a014a99e64c3",
        "filename": "src/test/gen/crypto_gen.h",
        "status": "added",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/test/gen/crypto_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/test/gen/crypto_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/gen/crypto_gen.h?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -0,0 +1,63 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H\n+#define BITCOIN_TEST_GEN_CRYPTO_GEN_H\n+\n+#include <key.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <rapidcheck/gen/Arbitrary.h>\n+#include <rapidcheck/Gen.h>\n+#include <rapidcheck/gen/Create.h>\n+#include <rapidcheck/gen/Numeric.h>\n+\n+/** Generates 1 to 15 keys for OP_CHECKMULTISIG */\n+rc::Gen<std::vector<CKey>> MultisigKeys();\n+\n+namespace rc\n+{\n+/** Generator for a new CKey */\n+template <>\n+struct Arbitrary<CKey> {\n+    static Gen<CKey> arbitrary()\n+    {\n+        return rc::gen::map<int>([](int x) {\n+            CKey key;\n+            key.MakeNewKey(true);\n+            return key;\n+        });\n+    };\n+};\n+\n+/** Generator for a CPrivKey */\n+template <>\n+struct Arbitrary<CPrivKey> {\n+    static Gen<CPrivKey> arbitrary()\n+    {\n+        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {\n+            return key.GetPrivKey();\n+        });\n+    };\n+};\n+\n+/** Generator for a new CPubKey */\n+template <>\n+struct Arbitrary<CPubKey> {\n+    static Gen<CPubKey> arbitrary()\n+    {\n+        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {\n+            return key.GetPubKey();\n+        });\n+    };\n+};\n+/** Generates a arbitrary uint256 */\n+template <>\n+struct Arbitrary<uint256> {\n+    static Gen<uint256> arbitrary()\n+    {\n+        return rc::gen::just(GetRandHash());\n+    };\n+};\n+} //namespace rc\n+#endif"
      },
      {
        "sha": "14e3c8535921381465957f9456bbf591748da010",
        "filename": "src/test/key_properties.cpp",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/test/key_properties.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/src/test/key_properties.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_properties.cpp?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -0,0 +1,53 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <key.h>\n+\n+#include <base58.h>\n+#include <script/script.h>\n+#include <uint256.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <test/test_bitcoin.h>\n+#include <string>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <rapidcheck/boost_test.h>\n+#include <rapidcheck/gen/Arbitrary.h>\n+#include <rapidcheck/Gen.h>\n+\n+#include <test/gen/crypto_gen.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)\n+\n+/** Check CKey uniqueness */\n+RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))\n+{\n+    RC_ASSERT(!(key1 == key2));\n+}\n+\n+/** Verify that a private key generates the correct public key */\n+RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))\n+{\n+    CPubKey pubKey = key.GetPubKey();\n+    RC_ASSERT(key.VerifyPubKey(pubKey));\n+}\n+\n+/** Create a CKey using the 'Set' function must give us the same key */\n+RC_BOOST_PROP(key_set_symmetry, (const CKey& key))\n+{\n+    CKey key1;\n+    key1.Set(key.begin(), key.end(), key.IsCompressed());\n+    RC_ASSERT(key1 == key);\n+}\n+\n+/** Create a CKey, sign a piece of data, then verify it with the public key */\n+RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))\n+{\n+    std::vector<unsigned char> vchSig;\n+    key.Sign(hash, vchSig, 0);\n+    const CPubKey& pubKey = key.GetPubKey();\n+    RC_ASSERT(pubKey.Verify(hash, vchSig));\n+}\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "71c3a396c1ba272d33d2ad4b587f3cac2b3be227",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 40,
        "deletions": 40,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -169,7 +169,7 @@ def run_test(self):\n         self.log.info(\"Reject a block where the miner creates too much coinbase reward\")\n         self.move_tip(6)\n         b9 = self.next_block(9, spend=out[4], additional_coinbase_value=1)\n-        self.sync_blocks([b9], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b9], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -181,7 +181,7 @@ def run_test(self):\n         self.sync_blocks([b10], False)\n \n         b11 = self.next_block(11, spend=out[4], additional_coinbase_value=1)\n-        self.sync_blocks([b11], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b11], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         # Try again, but with a valid fork first\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -194,7 +194,7 @@ def run_test(self):\n         b13 = self.next_block(13, spend=out[4])\n         self.save_spendable_output()\n         b14 = self.next_block(14, spend=out[5], additional_coinbase_value=1)\n-        self.sync_blocks([b12, b13, b14], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b12, b13, b14], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         # New tip should be b13.\n         assert_equal(node.getbestblockhash(), b13.hash)\n@@ -213,7 +213,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many checksigs\")\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n         b16 = self.next_block(16, spend=out[6], script=too_many_checksigs)\n-        self.sync_blocks([b16], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b16], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -222,7 +222,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with a spend from a re-org'ed out tx\")\n         self.move_tip(15)\n         b17 = self.next_block(17, spend=txout_b3)\n-        self.sync_blocks([b17], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b17], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -235,7 +235,7 @@ def run_test(self):\n         self.sync_blocks([b18], False)\n \n         b19 = self.next_block(19, spend=out[6])\n-        self.sync_blocks([b19], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b19], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a coinbase at depth too low\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -244,7 +244,7 @@ def run_test(self):\n         self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n         b20 = self.next_block(20, spend=out[7])\n-        self.sync_blocks([b20], success=False, reject_code=16, reject_reason=b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b20], success=False, reject_reason='bad-txns-premature-spend-of-coinbase')\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -257,7 +257,7 @@ def run_test(self):\n         self.sync_blocks([b21], False)\n \n         b22 = self.next_block(22, spend=out[5])\n-        self.sync_blocks([b22], success=False, reject_code=16, reject_reason=b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b22], success=False, reject_reason='bad-txns-premature-spend-of-coinbase')\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -286,7 +286,7 @@ def run_test(self):\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = self.update_block(24, [tx])\n         assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n-        self.sync_blocks([b24], success=False, reject_code=16, reject_reason=b'bad-blk-length', reconnect=True)\n+        self.sync_blocks([b24], success=False, reject_reason='bad-blk-length', reconnect=True)\n \n         b25 = self.next_block(25, spend=out[7])\n         self.sync_blocks([b25], False)\n@@ -304,7 +304,7 @@ def run_test(self):\n         # update_block causes the merkle root to get updated, even with no new\n         # transactions, and updates the required state.\n         b26 = self.update_block(26, [])\n-        self.sync_blocks([b26], success=False, reject_code=16, reject_reason=b'bad-cb-length', reconnect=True)\n+        self.sync_blocks([b26], success=False, reject_reason='bad-cb-length', reconnect=True)\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n         b27 = self.next_block(27, spend=out[7])\n@@ -316,7 +316,7 @@ def run_test(self):\n         b28.vtx[0].vin[0].scriptSig = b'\\x00' * 101\n         b28.vtx[0].rehash()\n         b28 = self.update_block(28, [])\n-        self.sync_blocks([b28], success=False, reject_code=16, reject_reason=b'bad-cb-length', reconnect=True)\n+        self.sync_blocks([b28], success=False, reject_reason='bad-cb-length', reconnect=True)\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n         b29 = self.next_block(29, spend=out[7])\n@@ -352,7 +352,7 @@ def run_test(self):\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n         b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n-        self.sync_blocks([b32], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b32], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # CHECKMULTISIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKMULTISIGVERIFY sigops\")\n@@ -365,7 +365,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many OP_CHECKMULTISIGVERIFY sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n         b34 = self.next_block(34, spend=out[10], script=too_many_multisigs)\n-        self.sync_blocks([b34], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b34], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # CHECKSIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKSIGVERIFY sigops\")\n@@ -378,7 +378,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many OP_CHECKSIGVERIFY sigops\")\n         too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n         b36 = self.next_block(36, spend=out[11], script=too_many_checksigs)\n-        self.sync_blocks([b36], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b36], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # Check spending of a transaction in a block which failed to connect\n         #\n@@ -395,12 +395,12 @@ def run_test(self):\n         txout_b37 = b37.vtx[1]\n         tx = self.create_and_sign_transaction(out[11], 0)\n         b37 = self.update_block(37, [tx])\n-        self.sync_blocks([b37], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b37], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n         self.move_tip(35)\n         b38 = self.next_block(38, spend=txout_b37)\n-        self.sync_blocks([b38], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b38], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Check P2SH SigOp counting\n         #\n@@ -492,7 +492,7 @@ def run_test(self):\n         tx.rehash()\n         new_txs.append(tx)\n         self.update_block(40, new_txs)\n-        self.sync_blocks([b40], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b40], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # same as b40, but one less sigop\n         self.log.info(\"Accept a block with the max number of P2SH sigops\")\n@@ -555,7 +555,7 @@ def run_test(self):\n         self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256] + 1\n         self.tip = b45\n         self.blocks[45] = b45\n-        self.sync_blocks([b45], success=False, reject_code=16, reject_reason=b'bad-cb-missing', reconnect=True)\n+        self.sync_blocks([b45], success=False, reject_reason='bad-cb-missing', reconnect=True)\n \n         self.log.info(\"Reject a block with no transactions\")\n         self.move_tip(44)\n@@ -570,7 +570,7 @@ def run_test(self):\n         self.tip = b46\n         assert 46 not in self.blocks\n         self.blocks[46] = b46\n-        self.sync_blocks([b46], success=False, reject_code=16, reject_reason=b'bad-blk-length', reconnect=True)\n+        self.sync_blocks([b46], success=False, reject_reason='bad-blk-length', reconnect=True)\n \n         self.log.info(\"Reject a block with invalid work\")\n         self.move_tip(44)\n@@ -593,7 +593,7 @@ def run_test(self):\n         b49 = self.next_block(49)\n         b49.hashMerkleRoot += 1\n         b49.solve()\n-        self.sync_blocks([b49], success=False, reject_code=16, reject_reason=b'bad-txnmrklroot', reconnect=True)\n+        self.sync_blocks([b49], success=False, reject_reason='bad-txnmrklroot', reconnect=True)\n \n         self.log.info(\"Reject a block with incorrect POW limit\")\n         self.move_tip(44)\n@@ -607,15 +607,15 @@ def run_test(self):\n         b51 = self.next_block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n         b51 = self.update_block(51, [cb2])\n-        self.sync_blocks([b51], success=False, reject_code=16, reject_reason=b'bad-cb-multiple', reconnect=True)\n+        self.sync_blocks([b51], success=False, reject_reason='bad-cb-multiple', reconnect=True)\n \n         self.log.info(\"Reject a block with duplicate transactions\")\n         # Note: txns have to be in the right position in the merkle tree to trigger this error\n         self.move_tip(44)\n         b52 = self.next_block(52, spend=out[15])\n         tx = self.create_tx(b52.vtx[1], 0, 1)\n         b52 = self.update_block(52, [tx, tx])\n-        self.sync_blocks([b52], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b52], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         # Test block timestamps\n         #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15)\n@@ -682,7 +682,7 @@ def run_test(self):\n         assert_equal(len(b56.vtx), 3)\n         b56 = self.update_block(56, [tx1])\n         assert_equal(b56.hash, b57.hash)\n-        self.sync_blocks([b56], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b56], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         # b57p2 - a good block with 6 tx'es, don't submit until end\n         self.move_tip(55)\n@@ -702,7 +702,7 @@ def run_test(self):\n         assert_equal(b56p2.hash, b57p2.hash)\n         assert_equal(len(b56p2.vtx), 6)\n         b56p2 = self.update_block(\"b56p2\", [tx3, tx4])\n-        self.sync_blocks([b56p2], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b56p2], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(\"57p2\")\n         self.sync_blocks([b57p2], True)\n@@ -727,15 +727,15 @@ def run_test(self):\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n         b58 = self.update_block(58, [tx])\n-        self.sync_blocks([b58], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b58], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # tx with output value > input value\n         self.log.info(\"Reject a block with a transaction with outputs > inputs\")\n         self.move_tip(57)\n         b59 = self.next_block(59)\n         tx = self.create_and_sign_transaction(out[17], 51 * COIN)\n         b59 = self.update_block(59, [tx])\n-        self.sync_blocks([b59], success=False, reject_code=16, reject_reason=b'bad-txns-in-belowout', reconnect=True)\n+        self.sync_blocks([b59], success=False, reject_reason='bad-txns-in-belowout', reconnect=True)\n \n         # reset to good chain\n         self.move_tip(57)\n@@ -759,7 +759,7 @@ def run_test(self):\n         b61.vtx[0].rehash()\n         b61 = self.update_block(61, [])\n         assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n-        self.sync_blocks([b61], success=False, reject_code=16, reject_reason=b'bad-txns-BIP30', reconnect=True)\n+        self.sync_blocks([b61], success=False, reject_reason='bad-txns-BIP30', reconnect=True)\n \n         # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n         #\n@@ -776,7 +776,7 @@ def run_test(self):\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n         b62 = self.update_block(62, [tx])\n-        self.sync_blocks([b62], success=False, reject_code=16, reject_reason=b'bad-txns-nonfinal')\n+        self.sync_blocks([b62], success=False, reject_reason='bad-txns-nonfinal')\n \n         # Test a non-final coinbase is also rejected\n         #\n@@ -790,7 +790,7 @@ def run_test(self):\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n         b63 = self.update_block(63, [])\n-        self.sync_blocks([b63], success=False, reject_code=16, reject_reason=b'bad-txns-nonfinal')\n+        self.sync_blocks([b63], success=False, reject_reason='bad-txns-nonfinal')\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n@@ -824,7 +824,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = self.update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n-        self.sync_blocks([b64a], success=False, reject_code=1, reject_reason=b'error parsing message')\n+        self.sync_blocks([b64a], success=False, reject_reason='non-canonical ReadCompactSize(): iostream error')\n \n         # bitcoind doesn't disconnect us for sending a bloated block, but if we subsequently\n         # resend the header message, it won't send us the getdata message again. Just\n@@ -866,7 +866,7 @@ def run_test(self):\n         tx1 = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         b66 = self.update_block(66, [tx2, tx1])\n-        self.sync_blocks([b66], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b66], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to double-spend a transaction created in a block\n         #\n@@ -881,7 +881,7 @@ def run_test(self):\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         tx3 = self.create_and_sign_transaction(tx1, 2)\n         b67 = self.update_block(67, [tx1, tx2, tx3])\n-        self.sync_blocks([b67], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b67], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # More tests of block subsidy\n         #\n@@ -900,7 +900,7 @@ def run_test(self):\n         b68 = self.next_block(68, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue - 9)\n         b68 = self.update_block(68, [tx])\n-        self.sync_blocks([b68], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b68], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         self.log.info(\"Accept a block claiming the correct subsidy in the coinbase transaction\")\n         self.move_tip(65)\n@@ -924,7 +924,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(bogus_tx.sha256, 0), b\"\", 0xffffffff))\n         tx.vout.append(CTxOut(1, b\"\"))\n         b70 = self.update_block(70, [tx])\n-        self.sync_blocks([b70], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b70], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n         #\n@@ -949,7 +949,7 @@ def run_test(self):\n         assert_equal(b72.sha256, b71.sha256)\n \n         self.move_tip(71)\n-        self.sync_blocks([b71], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b71], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(72)\n         self.sync_blocks([b72], True)\n@@ -987,7 +987,7 @@ def run_test(self):\n         tx = self.create_and_sign_transaction(out[22], 1, CScript(a))\n         b73 = self.update_block(73, [tx])\n         assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS + 1)\n-        self.sync_blocks([b73], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b73], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # b74/75 - if we push an invalid script element, all previous sigops are counted,\n         #          but sigops after the element are not counted.\n@@ -1011,7 +1011,7 @@ def run_test(self):\n         a[MAX_BLOCK_SIGOPS + 4] = 0xff\n         tx = self.create_and_sign_transaction(out[22], 1, CScript(a))\n         b74 = self.update_block(74, [tx])\n-        self.sync_blocks([b74], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b74], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         self.move_tip(72)\n         b75 = self.next_block(75)\n@@ -1160,7 +1160,7 @@ def run_test(self):\n         b89a = self.next_block(\"89a\", spend=out[32])\n         tx = self.create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n         b89a = self.update_block(\"89a\", [tx])\n-        self.sync_blocks([b89a], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b89a], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         self.log.info(\"Test a re-org of one week's worth of blocks (1088 blocks)\")\n \n@@ -1309,11 +1309,11 @@ def reconnect_p2p(self):\n         self.nodes[0].disconnect_p2ps()\n         self.bootstrap_p2p()\n \n-    def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True, reconnect=False, timeout=60):\n+    def sync_blocks(self, blocks, success=True, reject_reason=None, request_block=True, reconnect=False, timeout=60):\n         \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n \n         Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n-        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_code=reject_code, reject_reason=reject_reason, request_block=request_block, timeout=timeout)\n+        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_reason=reject_reason, request_block=request_block, timeout=timeout, expect_disconnect=reconnect)\n \n         if reconnect:\n             self.reconnect_p2p()"
      },
      {
        "sha": "615b0f8a4aac93a46b1d0494862875bffb6e1ac0",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 16,
        "deletions": 23,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -10,10 +10,14 @@\n \n from test_framework.blocktools import create_coinbase, create_block, create_transaction\n from test_framework.messages import CTransaction, msg_block, ToHex\n-from test_framework.mininode import mininode_lock, P2PInterface\n+from test_framework.mininode import P2PInterface\n from test_framework.script import CScript, OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP, CScriptNum\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, bytes_to_hex_str, hex_str_to_bytes, wait_until\n+from test_framework.util import (\n+    assert_equal,\n+    bytes_to_hex_str,\n+    hex_str_to_bytes,\n+)\n \n from io import BytesIO\n \n@@ -51,10 +55,11 @@ def cltv_validate(node, tx, height):\n                                   list(CScript(new_tx.vin[0].scriptSig)))\n     return new_tx\n \n+\n class BIP65Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.extra_args = [['-whitelist=127.0.0.1']]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-par=1']]  # Use only one script thread to get the exact reject reason for testing\n         self.setup_clean_chain = True\n \n     def run_test(self):\n@@ -88,15 +93,11 @@ def run_test(self):\n         block = create_block(tip, create_coinbase(CLTV_HEIGHT), block_time)\n         block.nVersion = 3\n         block.solve()\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n-        with mininode_lock:\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            del self.nodes[0].p2p.last_message[\"reject\"]\n+        with self.nodes[0].assert_debug_log(expected_msgs=['{}, bad-version(0x00000003)'.format(block.hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n         block.nVersion = 4\n@@ -118,18 +119,10 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-\n-        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n-        with mininode_lock:\n-            assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n-                # Generic rejection when a block is invalid\n-                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n-            else:\n-                assert b'Negative locktime' in self.nodes[0].p2p.last_message[\"reject\"].reason\n+        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputs on {} failed with non-mandatory-script-verify-flag (Negative locktime)'.format(block.vtx[-1].hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n         spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)"
      },
      {
        "sha": "302cfe4266187873cd423a2149f6e02ae0fd2d50",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -165,11 +165,11 @@ def create_test_block(self, txs, version=536870912):\n         block.solve()\n         return block\n \n-    def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True):\n+    def sync_blocks(self, blocks, success=True):\n         \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n \n         Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n-        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_code=reject_code, reject_reason=reject_reason, request_block=request_block)\n+        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success)\n \n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PDataStore())"
      },
      {
        "sha": "6072c5c17810c0536679615016291fc40eb974c8",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 15,
        "deletions": 22,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -12,7 +12,11 @@\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, bytes_to_hex_str, wait_until\n+from test_framework.util import (\n+    assert_equal,\n+    bytes_to_hex_str,\n+    wait_until,\n+)\n \n DERSIG_HEIGHT = 1251\n \n@@ -42,7 +46,7 @@ def unDERify(tx):\n class BIP66Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.extra_args = [['-whitelist=127.0.0.1']]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-par=1', '-enablebip61']]  # Use only one script thread to get the exact reject reason for testing\n         self.setup_clean_chain = True\n \n     def run_test(self):\n@@ -78,15 +82,11 @@ def run_test(self):\n         block.nVersion = 2\n         block.rehash()\n         block.solve()\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n-        with mininode_lock:\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            del self.nodes[0].p2p.last_message[\"reject\"]\n+        with self.nodes[0].assert_debug_log(expected_msgs=['{}, bad-version(0x00000002)'.format(block.hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         self.log.info(\"Test that transactions with non-DER signatures cannot appear in a block\")\n         block.nVersion = 3\n@@ -109,23 +109,16 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputs on {} failed with non-mandatory-script-verify-flag (Non-canonical DER signature)'.format(block.vtx[-1].hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            # We can receive different reject messages depending on whether\n-            # bitcoind is running with multiple script check threads. If script\n-            # check threads are not in use, then transaction script validation\n-            # happens sequentially, and bitcoind produces more specific reject\n-            # reasons.\n             assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n             assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n-                # Generic rejection when a block is invalid\n-                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n-            else:\n-                assert b'Non-canonical DER signature' in self.nodes[0].p2p.last_message[\"reject\"].reason\n+            assert b'Non-canonical DER signature' in self.nodes[0].p2p.last_message[\"reject\"].reason\n \n         self.log.info(\"Test that a version 3 block with a DERSIG-compliant transaction is accepted\")\n         block.vtx[1] = create_transaction(self.nodes[0], self.coinbase_txids[1], self.nodeaddress, amount=1.0)"
      },
      {
        "sha": "b3f4d721f9a6826da142ac78c783c3940bf97af8",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -79,7 +79,7 @@ def run_test(self):\n         assert_equal(orig_hash, block2.rehash())\n         assert(block2_orig.vtx != block2.vtx)\n \n-        node.p2p.send_blocks_and_test([block2], node, success=False, request_block=False, reject_code=16, reject_reason=b'bad-txns-duplicate')\n+        node.p2p.send_blocks_and_test([block2], node, success=False, request_block=False, reject_reason='bad-txns-duplicate')\n \n         self.log.info(\"Test very broken block.\")\n \n@@ -92,7 +92,7 @@ def run_test(self):\n         block3.rehash()\n         block3.solve()\n \n-        node.p2p.send_blocks_and_test([block3], node, success=False, request_block=False, reject_code=16, reject_reason=b'bad-cb-amount')\n+        node.p2p.send_blocks_and_test([block3], node, success=False, request_block=False, reject_reason='bad-cb-amount')\n \n if __name__ == '__main__':\n     InvalidBlockRequestTest().main()"
      },
      {
        "sha": "69d5dd9f9acbf15a1bcc91fd6a9a2067e1dd1da1",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 2,
        "deletions": 13,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -116,7 +116,8 @@ def run_test(self):\n         assert_equal(2, len(node.getpeerinfo()))  # p2ps[1] is still connected\n \n         self.log.info('Send the withhold tx ... ')\n-        node.p2p.send_txs_and_test([tx_withhold], node, success=True)\n+        with node.assert_debug_log(expected_msgs=[\"bad-txns-in-belowout\"]):\n+            node.p2p.send_txs_and_test([tx_withhold], node, success=True)\n \n         # Transactions that should end up in the mempool\n         expected_mempool = {\n@@ -134,18 +135,6 @@ def run_test(self):\n         wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n         assert_equal(expected_mempool, set(node.getrawmempool()))\n \n-        # restart node with sending BIP61 messages disabled, check that it disconnects without sending the reject message\n-        self.log.info('Test a transaction that is rejected, with BIP61 disabled')\n-        self.restart_node(0, ['-enablebip61=0', '-persistmempool=0'])\n-        self.reconnect_p2p(num_connections=1)\n-        with node.assert_debug_log(expected_msgs=[\n-                \"{} from peer=0 was not accepted: mandatory-script-verify-flag-failed (Invalid OP_IF construction) (code 16)\".format(tx1.hash),\n-                \"disconnecting peer=0\",\n-        ]):\n-            node.p2p.send_txs_and_test([tx1], node, success=False, expect_disconnect=True)\n-        # send_txs_and_test will have waited for disconnect, so we can safely check that no reject has been received\n-        assert_equal(node.p2p.reject_code_received, None)\n-\n \n if __name__ == '__main__':\n     InvalidTxRequestTest().main()"
      },
      {
        "sha": "043fa67f773c29320a57c36ee92a22584b41e494",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 27,
        "deletions": 41,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -41,7 +41,6 @@\n from test_framework.mininode import (\n     P2PInterface,\n     mininode_lock,\n-    wait_until,\n )\n from test_framework.script import (\n     CScript,\n@@ -124,32 +123,23 @@ def test_transaction_acceptance(node, p2p, tx, with_witness, accepted, reason=No\n \n     - Submit the transaction over the p2p interface\n     - use the getrawmempool rpc to check for acceptance.\"\"\"\n-    tx_message = msg_tx(tx)\n-    if with_witness:\n-        tx_message = msg_witness_tx(tx)\n-    p2p.send_message(tx_message)\n-    p2p.sync_with_ping()\n-    assert_equal(tx.hash in node.getrawmempool(), accepted)\n-    if (reason is not None and not accepted):\n-        # Check the rejection reason as well.\n-        with mininode_lock:\n-            assert_equal(p2p.last_message[\"reject\"].reason, reason)\n+    reason = [reason] if reason else []\n+    with node.assert_debug_log(expected_msgs=reason):\n+        p2p.send_message(msg_witness_tx(tx) if with_witness else msg_tx(tx))\n+        p2p.sync_with_ping()\n+        assert_equal(tx.hash in node.getrawmempool(), accepted)\n \n def test_witness_block(node, p2p, block, accepted, with_witness=True, reason=None):\n     \"\"\"Send a block to the node and check that it's accepted\n \n     - Submit the block over the p2p interface\n     - use the getbestblockhash rpc to check for acceptance.\"\"\"\n-    if with_witness:\n-        p2p.send_message(msg_witness_block(block))\n-    else:\n-        p2p.send_message(msg_block(block))\n-    p2p.sync_with_ping()\n-    assert_equal(node.getbestblockhash() == block.hash, accepted)\n-    if (reason is not None and not accepted):\n-        # Check the rejection reason as well.\n-        with mininode_lock:\n-            assert_equal(p2p.last_message[\"reject\"].reason, reason)\n+    reason = [reason] if reason else []\n+    with node.assert_debug_log(expected_msgs=reason):\n+        p2p.send_message(msg_witness_block(block) if with_witness else msg_block(block))\n+        p2p.sync_with_ping()\n+        assert_equal(node.getbestblockhash() == block.hash, accepted)\n+\n \n class TestP2PConn(P2PInterface):\n     def __init__(self):\n@@ -349,8 +339,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n-        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n-        wait_until(lambda: 'reject' in self.test_node.last_message and self.test_node.last_message[\"reject\"].reason ==  b\"unexpected-witness\")\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, reason='unexpected-witness')\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n@@ -497,7 +486,7 @@ def test_v0_outputs_arent_spendable(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Verify that segwit isn't activated. A block serialized with witness\n         # should be rejected prior to activation.\n-        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason=b'unexpected-witness')\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason='unexpected-witness')\n         # Now send the block without witness. It should be accepted\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True, with_witness=False)\n \n@@ -523,7 +512,7 @@ def test_v0_outputs_arent_spendable(self):\n \n             # When the block is serialized with a witness, the block will be rejected because witness\n             # data isn't allowed in blocks that don't commit to witness data.\n-            test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason=b'unexpected-witness')\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason='unexpected-witness')\n \n             # When the block is serialized without witness, validation fails because the transaction is\n             # invalid (transactions are always validated with SCRIPT_VERIFY_WITNESS so a segwit v0 transaction\n@@ -1343,9 +1332,9 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Node will not be blinded to the transaction\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, 'tx-size')\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, 'tx-size')\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n@@ -1454,10 +1443,7 @@ def test_segwit_versions(self):\n         tx3.rehash()\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n-        self.test_node.sync_with_ping()\n-        with mininode_lock:\n-            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False, reason=\"reserved for soft-fork upgrades\")\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n@@ -1551,7 +1537,7 @@ def test_uncompressed_pubkey(self):\n         tx2.rehash()\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n@@ -1571,7 +1557,7 @@ def test_uncompressed_pubkey(self):\n         sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx3])\n@@ -1588,7 +1574,7 @@ def test_uncompressed_pubkey(self):\n         sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx4])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -1825,7 +1811,7 @@ def test_non_standard_witness_blinding(self):\n         tx2.rehash()\n         # This will be rejected due to a policy check:\n         # No witness is allowed, since it is not a witness program but a p2sh program\n-        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, 'bad-witness-nonstandard')\n \n         # If we send without witness, it should be accepted.\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx2, False, True)\n@@ -1897,13 +1883,13 @@ def test_non_standard_witness(self):\n         # Testing native P2WSH\n         # Witness stack size, excluding witnessScript, over 100 is non-standard\n         p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[0], True, True)\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n@@ -1917,24 +1903,24 @@ def test_non_standard_witness(self):\n \n         # witnessScript size at 3601 bytes is non-standard\n         p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[3], True, True)\n \n         # Repeating the same tests with P2SH-P2WSH\n         p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[2], True, True)\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[2], True, True)\n         p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n \n         self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node"
      },
      {
        "sha": "58074803ccd7bcf669852b3330333b65d0c4697f",
        "filename": "test/functional/rpc_deprecated.py",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/rpc_deprecated.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/rpc_deprecated.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deprecated.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -18,13 +18,7 @@ def run_test(self):\n         # self.log.info(\"Make sure that -deprecatedrpc=createmultisig allows it to take addresses\")\n         # assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [self.nodes[0].getnewaddress()])\n         # self.nodes[1].createmultisig(1, [self.nodes[1].getnewaddress()])\n-\n-        self.log.info(\"Test validateaddress deprecation\")\n-        SOME_ADDRESS = \"mnvGjUy3NMj67yJ6gkK5o9e5RS33Z2Vqcu\"  # This is just some random address to pass as a parameter to validateaddress\n-        dep_validate_address = self.nodes[0].validateaddress(SOME_ADDRESS)\n-        assert \"ismine\" not in dep_validate_address\n-        not_dep_val = self.nodes[1].validateaddress(SOME_ADDRESS)\n-        assert \"ismine\" in not_dep_val\n+        pass\n \n if __name__ == '__main__':\n     DeprecatedRpcTest().main()"
      },
      {
        "sha": "f6eea1a0276fc4ed2a08ede9423840b3171d6106",
        "filename": "test/functional/rpc_signrawtransaction.py",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/rpc_signrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/rpc_signrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signrawtransaction.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -42,10 +42,6 @@ def successful_signing_test(self):\n         # 2) No script verification error occurred\n         assert 'errors' not in rawTxSigned\n \n-        # Perform the same test on signrawtransaction\n-        rawTxSigned2 = self.nodes[0].signrawtransaction(rawTx, inputs, privKeys)\n-        assert_equal(rawTxSigned, rawTxSigned2)\n-\n     def script_verification_error_test(self):\n         \"\"\"Create and sign a raw transaction with valid (vin 0), invalid (vin 1) and one missing (vin 2) input script.\n \n@@ -112,10 +108,6 @@ def script_verification_error_test(self):\n         assert_equal(rawTxSigned['errors'][1]['vout'], inputs[2]['vout'])\n         assert not rawTxSigned['errors'][0]['witness']\n \n-        # Perform same test with signrawtransaction\n-        rawTxSigned2 = self.nodes[0].signrawtransaction(rawTx, scripts, privKeys)\n-        assert_equal(rawTxSigned, rawTxSigned2)\n-\n         # Now test signing failure for transaction with input witnesses\n         p2wpkh_raw_tx = \"01000000000102fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f00000000494830450221008b9d1dc26ba6a9cb62127b02742fa9d754cd3bebf337f7a55d114c8e5cdd30be022040529b194ba3f9281a99f2b1c0a19c0489bc22ede944ccf4ecbab4cc618ef3ed01eeffffffef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a0100000000ffffffff02202cb206000000001976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac9093510d000000001976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac000247304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee0121025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee635711000000\"\n \n@@ -140,10 +132,6 @@ def script_verification_error_test(self):\n         assert_equal(rawTxSigned['errors'][1]['witness'], [\"304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee01\", \"025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee6357\"])\n         assert not rawTxSigned['errors'][0]['witness']\n \n-        # Perform same test with signrawtransaction\n-        rawTxSigned2 = self.nodes[0].signrawtransaction(p2wpkh_raw_tx)\n-        assert_equal(rawTxSigned, rawTxSigned2)\n-\n     def run_test(self):\n         self.successful_signing_test()\n         self.script_verification_error_test()"
      },
      {
        "sha": "f8caa572505f358952ddad91d3f6dc9b05951a27",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 34,
        "deletions": 48,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -425,8 +425,6 @@ class P2PDataStore(P2PInterface):\n \n     def __init__(self):\n         super().__init__()\n-        self.reject_code_received = None\n-        self.reject_reason_received = None\n         # store of blocks. key is block hash, value is a CBlock object\n         self.block_store = {}\n         self.last_block_hash = ''\n@@ -477,12 +475,7 @@ def on_getheaders(self, message):\n         if response is not None:\n             self.send_message(response)\n \n-    def on_reject(self, message):\n-        \"\"\"Store reject reason and code for testing.\"\"\"\n-        self.reject_code_received = message.code\n-        self.reject_reason_received = message.reason\n-\n-    def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True, reject_code=None, reject_reason=None, timeout=60):\n+    def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True, reject_reason=None, expect_disconnect=False, timeout=60):\n         \"\"\"Send blocks to test node and test whether the tip advances.\n \n          - add all blocks to our block_store\n@@ -492,66 +485,59 @@ def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True\n            ensure that any getdata messages are responded to\n          - if success is True: assert that the node's tip advances to the most recent block\n          - if success is False: assert that the node's tip doesn't advance\n-         - if reject_code and reject_reason are set: assert that the correct reject message is received\"\"\"\n+         - if reject_reason is set: assert that the correct reject message is logged\"\"\"\n \n         with mininode_lock:\n-            self.reject_code_received = None\n-            self.reject_reason_received = None\n-\n             for block in blocks:\n                 self.block_store[block.sha256] = block\n                 self.last_block_hash = block.sha256\n \n-        self.send_message(msg_headers([CBlockHeader(blocks[-1])]))\n+        reject_reason = [reject_reason] if reject_reason else []\n+        with node.assert_debug_log(expected_msgs=reject_reason):\n+            self.send_message(msg_headers([CBlockHeader(blocks[-1])]))\n \n-        if request_block:\n-            wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout, lock=mininode_lock)\n+            if request_block:\n+                wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout, lock=mininode_lock)\n \n-        if success:\n-            wait_until(lambda: node.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n-        else:\n-            assert node.getbestblockhash() != blocks[-1].hash\n+            if expect_disconnect:\n+                self.wait_for_disconnect()\n+            else:\n+                self.sync_with_ping()\n \n-        if reject_code is not None:\n-            wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n-        if reject_reason is not None:\n-            wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)\n+            if success:\n+                wait_until(lambda: node.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n+            else:\n+                assert node.getbestblockhash() != blocks[-1].hash\n \n-    def send_txs_and_test(self, txs, node, *, success=True, expect_disconnect=False, reject_code=None, reject_reason=None):\n+    def send_txs_and_test(self, txs, node, *, success=True, expect_disconnect=False, reject_reason=None):\n         \"\"\"Send txs to test node and test whether they're accepted to the mempool.\n \n          - add all txs to our tx_store\n          - send tx messages for all txs\n          - if success is True/False: assert that the txs are/are not accepted to the mempool\n          - if expect_disconnect is True: Skip the sync with ping\n-         - if reject_code and reject_reason are set: assert that the correct reject message is received.\"\"\"\n+         - if reject_reason is set: assert that the correct reject message is logged.\"\"\"\n \n         with mininode_lock:\n-            self.reject_code_received = None\n-            self.reject_reason_received = None\n-\n             for tx in txs:\n                 self.tx_store[tx.sha256] = tx\n \n-        for tx in txs:\n-            self.send_message(msg_tx(tx))\n-\n-        if expect_disconnect:\n-            self.wait_for_disconnect()\n-        else:\n-            self.sync_with_ping()\n-\n-        raw_mempool = node.getrawmempool()\n-        if success:\n-            # Check that all txs are now in the mempool\n-            for tx in txs:\n-                assert tx.hash in raw_mempool, \"{} not found in mempool\".format(tx.hash)\n-        else:\n-            # Check that none of the txs are now in the mempool\n+        reject_reason = [reject_reason] if reject_reason else []\n+        with node.assert_debug_log(expected_msgs=reject_reason):\n             for tx in txs:\n-                assert tx.hash not in raw_mempool, \"{} tx found in mempool\".format(tx.hash)\n+                self.send_message(msg_tx(tx))\n \n-        if reject_code is not None:\n-            wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n-        if reject_reason is not None:\n-            wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)\n+            if expect_disconnect:\n+                self.wait_for_disconnect()\n+            else:\n+                self.sync_with_ping()\n+\n+            raw_mempool = node.getrawmempool()\n+            if success:\n+                # Check that all txs are now in the mempool\n+                for tx in txs:\n+                    assert tx.hash in raw_mempool, \"{} not found in mempool\".format(tx.hash)\n+            else:\n+                # Check that none of the txs are now in the mempool\n+                for tx in txs:\n+                    assert tx.hash not in raw_mempool, \"{} tx found in mempool\".format(tx.hash)"
      },
      {
        "sha": "3972baed1d49687e25bd5f9757af9a8dea2f8a2e",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69eca482e804cb72cdabcbcaa4581362fe573fd3/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "patch": "@@ -25,7 +25,6 @@ EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"qt/sendcoinsdialog -> qt/walletmodel -> qt/sendcoinsdialog\"\n     \"qt/transactiontablemodel -> qt/walletmodel -> qt/transactiontablemodel\"\n     \"qt/walletmodel -> qt/walletmodeltransaction -> qt/walletmodel\"\n-    \"rpc/rawtransaction -> wallet/rpcwallet -> rpc/rawtransaction\"\n     \"txmempool -> validation -> txmempool\"\n     \"validation -> validationinterface -> validation\"\n     \"wallet/coincontrol -> wallet/wallet -> wallet/coincontrol\""
      }
    ]
  },
  {
    "sha": "04de84db8899a528bcb4c535c2492940b19f3e3e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNGRlODRkYjg4OTlhNTI4YmNiNGM1MzVjMjQ5Mjk0MGIxOWYzZTNl",
    "commit": {
      "author": {
        "name": "Emanuele Cisbani",
        "email": "emanuele.cisbani@gmail.com",
        "date": "2018-10-02T21:47:59Z"
      },
      "committer": {
        "name": "Emanuele Cisbani",
        "email": "emanuele.cisbani@gmail.com",
        "date": "2018-10-02T21:47:59Z"
      },
      "message": "doc/README.md included in make install logic",
      "tree": {
        "sha": "b6c22f250dd52ad7c5d1480b38b45b09eedc29a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b6c22f250dd52ad7c5d1480b38b45b09eedc29a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04de84db8899a528bcb4c535c2492940b19f3e3e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04de84db8899a528bcb4c535c2492940b19f3e3e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/04de84db8899a528bcb4c535c2492940b19f3e3e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04de84db8899a528bcb4c535c2492940b19f3e3e/comments",
    "author": {
      "login": "cisba",
      "id": 2389559,
      "node_id": "MDQ6VXNlcjIzODk1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2389559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cisba",
      "html_url": "https://github.com/cisba",
      "followers_url": "https://api.github.com/users/cisba/followers",
      "following_url": "https://api.github.com/users/cisba/following{/other_user}",
      "gists_url": "https://api.github.com/users/cisba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cisba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cisba/subscriptions",
      "organizations_url": "https://api.github.com/users/cisba/orgs",
      "repos_url": "https://api.github.com/users/cisba/repos",
      "events_url": "https://api.github.com/users/cisba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cisba/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cisba",
      "id": 2389559,
      "node_id": "MDQ6VXNlcjIzODk1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2389559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cisba",
      "html_url": "https://github.com/cisba",
      "followers_url": "https://api.github.com/users/cisba/followers",
      "following_url": "https://api.github.com/users/cisba/following{/other_user}",
      "gists_url": "https://api.github.com/users/cisba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cisba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cisba/subscriptions",
      "organizations_url": "https://api.github.com/users/cisba/orgs",
      "repos_url": "https://api.github.com/users/cisba/repos",
      "events_url": "https://api.github.com/users/cisba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cisba/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69eca482e804cb72cdabcbcaa4581362fe573fd3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/69eca482e804cb72cdabcbcaa4581362fe573fd3"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 4,
      "deletions": 3
    },
    "files": [
      {
        "sha": "f5aea8c33f1d48a7dc9f2f0c65b59b460861d34e",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04de84db8899a528bcb4c535c2492940b19f3e3e/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04de84db8899a528bcb4c535c2492940b19f3e3e/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=04de84db8899a528bcb4c535c2492940b19f3e3e",
        "patch": "@@ -3,7 +3,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n ACLOCAL_AMFLAGS = -I build-aux/m4\n-SUBDIRS = src\n+SUBDIRS = src doc\n if ENABLE_MAN\n SUBDIRS += doc/man\n endif"
      },
      {
        "sha": "8b7f253b84687252283eb339b1f173cd1359a38e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04de84db8899a528bcb4c535c2492940b19f3e3e/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04de84db8899a528bcb4c535c2492940b19f3e3e/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=04de84db8899a528bcb4c535c2492940b19f3e3e",
        "patch": "@@ -1419,7 +1419,7 @@ AC_SUBST(EVENT_PTHREADS_LIBS)\n AC_SUBST(ZMQ_LIBS)\n AC_SUBST(PROTOBUF_LIBS)\n AC_SUBST(QR_LIBS)\n-AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n+AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile doc/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])\n AC_CONFIG_LINKS([contrib/filter-lcov.py:contrib/filter-lcov.py])"
      },
      {
        "sha": "9ec38015a00c7f3051ff9a20b67db3346143c856",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04de84db8899a528bcb4c535c2492940b19f3e3e/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04de84db8899a528bcb4c535c2492940b19f3e3e/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=04de84db8899a528bcb4c535c2492940b19f3e3e",
        "patch": "@@ -185,7 +185,6 @@ script: |\n     find ${DISTNAME} -name \"*.dbg\" | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}-debug.tar.gz\n     DOCDISTNAME=\"${DISTNAME}/share/doc/bitcoin\"\n     mkdir -p ${DOCDISTNAME}/init\n-    cp ../doc/README.md ${DOCDISTNAME}\n     cp -r ../share/examples ${DOCDISTNAME}\n     cp -r ../share/rpcauth ${DOCDISTNAME}\n     cp ../contrib/init/bitcoind.* ${DOCDISTNAME}/init/"
      },
      {
        "sha": "e446494702cd2d80ff503ce4c7d3e220c0e719c1",
        "filename": "doc/Makefile.am",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04de84db8899a528bcb4c535c2492940b19f3e3e/doc/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04de84db8899a528bcb4c535c2492940b19f3e3e/doc/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/Makefile.am?ref=04de84db8899a528bcb4c535c2492940b19f3e3e",
        "patch": "@@ -0,0 +1,2 @@\n+docdir = $(datadir)/doc/@PACKAGE@\n+dist_doc_DATA = README.md"
      }
    ]
  }
]