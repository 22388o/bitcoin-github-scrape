[
  {
    "sha": "579b863cd7586b98974484ad55e19be2a54d241d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NzliODYzY2Q3NTg2Yjk4OTc0NDg0YWQ1NWUxOWJlMmE1NGQyNDFk",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-10-19T12:53:56Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-10-22T01:35:38Z"
      },
      "message": "devtools: Add security-check.py\n\nPerform the following ELF security checks:\n\n- PIE: Check for position independent executable (PIE), allowing for address space randomization\n- NX: Check that no sections are writable and executable (including the stack)\n- RELRO: Check for read-only relocations, binding at startup\n- Canary: Check for use of stack canary\n\nAlso add a check to symbol-check.py that checks that only the subset of\nallowed libraries is imported (to avoid incompatibilities).",
      "tree": {
        "sha": "0a5e4661d767cd45c7c3bfb7d2cf75bb6bc5d831",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a5e4661d767cd45c7c3bfb7d2cf75bb6bc5d831"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/579b863cd7586b98974484ad55e19be2a54d241d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/579b863cd7586b98974484ad55e19be2a54d241d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/579b863cd7586b98974484ad55e19be2a54d241d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/579b863cd7586b98974484ad55e19be2a54d241d/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1d623da3ea4c73605d27703bc966ed8109d231e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1d623da3ea4c73605d27703bc966ed8109d231e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1d623da3ea4c73605d27703bc966ed8109d231e"
      }
    ],
    "stats": {
      "total": 271,
      "additions": 268,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e96eaa9c387e0540514c701425befd6904973443",
        "filename": "contrib/devtools/security-check.py",
        "status": "added",
        "additions": 181,
        "deletions": 0,
        "changes": 181,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/579b863cd7586b98974484ad55e19be2a54d241d/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/579b863cd7586b98974484ad55e19be2a54d241d/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=579b863cd7586b98974484ad55e19be2a54d241d",
        "patch": "@@ -0,0 +1,181 @@\n+#!/usr/bin/python2\n+'''\n+Perform basic ELF security checks on a series of executables.\n+Exit status will be 0 if succesful, and the program will be silent.\n+Otherwise the exit status will be 1 and it will log which executables failed which checks.\n+Needs `readelf` (for ELF) and `objdump` (for PE).\n+'''\n+from __future__ import division,print_function\n+import subprocess\n+import sys\n+import os\n+\n+READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n+OBJDUMP_CMD = os.getenv('OBJDUMP', '/usr/bin/objdump')\n+\n+def check_ELF_PIE(executable):\n+    '''\n+    Check for position independent executable (PIE), allowing for address space randomization.\n+    '''\n+    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    if p.returncode:\n+        raise IOError('Error opening file')\n+\n+    ok = False\n+    for line in stdout.split('\\n'):\n+        line = line.split()\n+        if len(line)>=2 and line[0] == 'Type:' and line[1] == 'DYN':\n+            ok = True\n+    return ok\n+\n+def get_ELF_program_headers(executable):\n+    '''Return type and flags for ELF program headers'''\n+    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    if p.returncode:\n+        raise IOError('Error opening file')\n+    in_headers = False\n+    count = 0\n+    headers = []\n+    for line in stdout.split('\\n'):\n+        if line.startswith('Program Headers:'):\n+            in_headers = True\n+        if line == '':\n+            in_headers = False\n+        if in_headers:\n+            if count == 1: # header line\n+                ofs_typ = line.find('Type')\n+                ofs_offset = line.find('Offset')\n+                ofs_flags = line.find('Flg')\n+                ofs_align = line.find('Align')\n+                if ofs_typ == -1 or ofs_offset == -1 or ofs_flags == -1 or ofs_align  == -1:\n+                    raise ValueError('Cannot parse elfread -lW output')\n+            elif count > 1:\n+                typ = line[ofs_typ:ofs_offset].rstrip()\n+                flags = line[ofs_flags:ofs_align].rstrip()\n+                headers.append((typ, flags))\n+            count += 1\n+    return headers\n+\n+def check_ELF_NX(executable):\n+    '''\n+    Check that no sections are writable and executable (including the stack)\n+    '''\n+    have_wx = False\n+    have_gnu_stack = False\n+    for (typ, flags) in get_ELF_program_headers(executable):\n+        if typ == 'GNU_STACK':\n+            have_gnu_stack = True\n+        if 'W' in flags and 'E' in flags: # section is both writable and executable\n+            have_wx = True\n+    return have_gnu_stack and not have_wx\n+\n+def check_ELF_RELRO(executable):\n+    '''\n+    Check for read-only relocations.\n+    GNU_RELRO program header must exist\n+    Dynamic section must have BIND_NOW flag\n+    '''\n+    have_gnu_relro = False\n+    for (typ, flags) in get_ELF_program_headers(executable):\n+        # Note: not checking flags == 'R': here as linkers set the permission differently\n+        # This does not affect security: the permission flags of the GNU_RELRO program header are ignored, the PT_LOAD header determines the effective permissions.\n+        # However, the dynamic linker need to write to this area so these are RW.\n+        # Glibc itself takes care of mprotecting this area R after relocations are finished.\n+        # See also http://permalink.gmane.org/gmane.comp.gnu.binutils/71347\n+        if typ == 'GNU_RELRO':\n+            have_gnu_relro = True\n+\n+    have_bindnow = False\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    if p.returncode:\n+        raise IOError('Error opening file')\n+    for line in stdout.split('\\n'):\n+        tokens = line.split()\n+        if len(tokens)>1 and tokens[1] == '(BIND_NOW)':\n+            have_bindnow = True\n+    return have_gnu_relro and have_bindnow\n+\n+def check_ELF_Canary(executable):\n+    '''\n+    Check for use of stack canary\n+    '''\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    if p.returncode:\n+        raise IOError('Error opening file')\n+    ok = False\n+    for line in stdout.split('\\n'):\n+        if '__stack_chk_fail' in line:\n+            ok = True\n+    return ok\n+\n+def get_PE_dll_characteristics(executable):\n+    '''\n+    Get PE DllCharacteristics bits\n+    '''\n+    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    if p.returncode:\n+        raise IOError('Error opening file')\n+    for line in stdout.split('\\n'):\n+        tokens = line.split()\n+        if len(tokens)>=2 and tokens[0] == 'DllCharacteristics':\n+            return int(tokens[1],16)\n+    return 0\n+\n+\n+def check_PE_PIE(executable):\n+    '''PIE: DllCharacteristics bit 0x40 signifies dynamicbase (ASLR)'''\n+    return bool(get_PE_dll_characteristics(executable) & 0x40)\n+\n+def check_PE_NX(executable):\n+    '''NX: DllCharacteristics bit 0x100 signifies nxcompat (DEP)'''\n+    return bool(get_PE_dll_characteristics(executable) & 0x100)\n+\n+CHECKS = {\n+'ELF': [\n+    ('PIE', check_ELF_PIE),\n+    ('NX', check_ELF_NX),\n+    ('RELRO', check_ELF_RELRO),\n+    ('Canary', check_ELF_Canary)\n+],\n+'PE': [\n+    ('PIE', check_PE_PIE),\n+    ('NX', check_PE_NX)\n+]\n+}\n+\n+def identify_executable(executable):\n+    with open(filename, 'rb') as f:\n+        magic = f.read(4)\n+    if magic.startswith(b'MZ'):\n+        return 'PE'\n+    elif magic.startswith(b'\\x7fELF'):\n+        return 'ELF'\n+    return None\n+\n+if __name__ == '__main__':\n+    retval = 0\n+    for filename in sys.argv[1:]:\n+        try:\n+            etype = identify_executable(filename)\n+            if etype is None:\n+                print('%s: unknown format' % filename)\n+                retval = 1\n+                continue\n+\n+            failed = []\n+            for (name, func) in CHECKS[etype]:\n+                if not func(filename):\n+                    failed.append(name)\n+            if failed:\n+                print('%s: failed %s' % (filename, ' '.join(failed)))\n+                retval = 1\n+        except IOError:\n+            print('%s: cannot open' % filename)\n+            retval = 1\n+    exit(retval)\n+"
      },
      {
        "sha": "34f1ed2d17b147adbff0ba2e978d5eb46f8f4398",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 27,
        "deletions": 3,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/579b863cd7586b98974484ad55e19be2a54d241d/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/579b863cd7586b98974484ad55e19be2a54d241d/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=579b863cd7586b98974484ad55e19be2a54d241d",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/python2\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -15,6 +15,7 @@\n import subprocess\n import re\n import sys\n+import os\n \n # Debian 6.0.9 (Squeeze) has:\n #\n@@ -45,8 +46,10 @@\n IGNORE_EXPORTS = {\n '_edata', '_end', '_init', '__bss_start', '_fini'\n }\n-READELF_CMD = '/usr/bin/readelf'\n-CPPFILT_CMD = '/usr/bin/c++filt'\n+READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n+CPPFILT_CMD = os.getenv('CPPFILT', '/usr/bin/c++filt')\n+# Allowed NEEDED libraries\n+ALLOWED_LIBRARIES = {'librt.so.1','libpthread.so.0','libanl.so.1','libm.so.6','libgcc_s.so.1','libc.so.6','ld-linux-x86-64.so.2'}\n \n class CPPFilt(object):\n     '''\n@@ -98,6 +101,22 @@ def check_version(max_versions, version):\n         return False\n     return ver <= max_versions[lib]\n \n+def read_libraries(filename):\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    if p.returncode:\n+        raise IOError('Error opening file')\n+    libraries = []\n+    for line in stdout.split('\\n'):\n+        tokens = line.split()\n+        if len(tokens)>2 and tokens[1] == '(NEEDED)':\n+            match = re.match('^Shared library: \\[(.*)\\]$', ' '.join(tokens[2:]))\n+            if match:\n+                libraries.append(match.group(1))\n+            else:\n+                raise ValueError('Unparseable (NEEDED) specification')\n+    return libraries\n+\n if __name__ == '__main__':\n     cppfilt = CPPFilt()\n     retval = 0\n@@ -113,6 +132,11 @@ def check_version(max_versions, version):\n                 continue\n             print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym)))\n             retval = 1\n+        # Check dependency libraries\n+        for library_name in read_libraries(filename):\n+            if library_name not in ALLOWED_LIBRARIES:\n+                print('%s: NEEDED library %s is not allowed' % (filename, library_name))\n+                retval = 1\n \n     exit(retval)\n "
      },
      {
        "sha": "fed7626aabaaf34a7ab4ed1e13a7b5e47769f950",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/579b863cd7586b98974484ad55e19be2a54d241d/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/579b863cd7586b98974484ad55e19be2a54d241d/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=579b863cd7586b98974484ad55e19be2a54d241d",
        "patch": "@@ -0,0 +1,60 @@\n+#!/usr/bin/python2\n+'''\n+Test script for security-check.py\n+'''\n+from __future__ import division,print_function\n+import subprocess\n+import sys\n+import unittest\n+\n+def write_testcode(filename):\n+    with open(filename, 'w') as f:\n+        f.write('''\n+    #include <stdio.h>\n+    int main()\n+    {\n+        printf(\"the quick brown fox jumps over the lazy god\\\\n\");\n+        return 0;\n+    }\n+    ''')\n+\n+def call_security_check(cc, source, executable, options):\n+    subprocess.check_call([cc,source,'-o',executable] + options)\n+    p = subprocess.Popen(['./security-check.py',executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    (stdout, stderr) = p.communicate()\n+    return (p.returncode, stdout.rstrip())\n+\n+class TestSecurityChecks(unittest.TestCase):\n+    def test_ELF(self):\n+        source = 'test1.c'\n+        executable = 'test1'\n+        cc = 'gcc'\n+        write_testcode(source)\n+\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-zexecstack','-fno-stack-protector','-Wl,-znorelro']), \n+                (1, executable+': failed PIE NX RELRO Canary'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fno-stack-protector','-Wl,-znorelro']), \n+                (1, executable+': failed PIE RELRO Canary'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-znorelro']), \n+                (1, executable+': failed PIE RELRO'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-znorelro','-pie','-fPIE']), \n+                (1, executable+': failed RELRO'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-zrelro','-Wl,-z,now','-pie','-fPIE']), \n+                (0, ''))\n+\n+    def test_PE(self):\n+        source = 'test1.c'\n+        executable = 'test1.exe'\n+        cc = 'i686-w64-mingw32-gcc'\n+        write_testcode(source)\n+\n+        self.assertEqual(call_security_check(cc, source, executable, []), \n+                (1, executable+': failed PIE NX'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat']), \n+                (1, executable+': failed PIE'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase']), \n+                (0, ''))\n+\n+if __name__ == '__main__':\n+    unittest.main()\n+"
      }
    ]
  }
]