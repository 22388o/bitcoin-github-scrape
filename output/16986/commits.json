[
  {
    "sha": "7aad3b68e7e1680870ca70d945eee88f790d6454",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YWFkM2I2OGU3ZTE2ODA4NzBjYTcwZDk0NWVlZTg4Zjc5MGQ2NDU0",
    "commit": {
      "author": {
        "name": "Jon Layton",
        "email": "me@jonl.io",
        "date": "2019-09-24T06:35:15Z"
      },
      "committer": {
        "name": "Jon Layton",
        "email": "me@jonl.io",
        "date": "2019-10-10T19:47:39Z"
      },
      "message": "doc: Doxygen-friendly CuckooCache comments",
      "tree": {
        "sha": "0c995724c5ddf134f9ae702728db869cc75435aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c995724c5ddf134f9ae702728db869cc75435aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7aad3b68e7e1680870ca70d945eee88f790d6454",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7aad3b68e7e1680870ca70d945eee88f790d6454",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7aad3b68e7e1680870ca70d945eee88f790d6454",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7aad3b68e7e1680870ca70d945eee88f790d6454/comments",
    "author": {
      "login": "ch4ot1c",
      "id": 2287825,
      "node_id": "MDQ6VXNlcjIyODc4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2287825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ch4ot1c",
      "html_url": "https://github.com/ch4ot1c",
      "followers_url": "https://api.github.com/users/ch4ot1c/followers",
      "following_url": "https://api.github.com/users/ch4ot1c/following{/other_user}",
      "gists_url": "https://api.github.com/users/ch4ot1c/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ch4ot1c/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ch4ot1c/subscriptions",
      "organizations_url": "https://api.github.com/users/ch4ot1c/orgs",
      "repos_url": "https://api.github.com/users/ch4ot1c/repos",
      "events_url": "https://api.github.com/users/ch4ot1c/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ch4ot1c/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ch4ot1c",
      "id": 2287825,
      "node_id": "MDQ6VXNlcjIyODc4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2287825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ch4ot1c",
      "html_url": "https://github.com/ch4ot1c",
      "followers_url": "https://api.github.com/users/ch4ot1c/followers",
      "following_url": "https://api.github.com/users/ch4ot1c/following{/other_user}",
      "gists_url": "https://api.github.com/users/ch4ot1c/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ch4ot1c/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ch4ot1c/subscriptions",
      "organizations_url": "https://api.github.com/users/ch4ot1c/orgs",
      "repos_url": "https://api.github.com/users/ch4ot1c/repos",
      "events_url": "https://api.github.com/users/ch4ot1c/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ch4ot1c/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d5a770b70d55a5874fbd7796a171de22abbbd342",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5a770b70d55a5874fbd7796a171de22abbbd342",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d5a770b70d55a5874fbd7796a171de22abbbd342"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 55,
      "deletions": 54
    },
    "files": [
      {
        "sha": "674f47b956188e1f395e39e95740c87fc7a65f0f",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 50,
        "deletions": 49,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7aad3b68e7e1680870ca70d945eee88f790d6454/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7aad3b68e7e1680870ca70d945eee88f790d6454/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=7aad3b68e7e1680870ca70d945eee88f790d6454",
        "patch": "@@ -14,42 +14,40 @@\n #include <vector>\n \n \n-/** namespace CuckooCache provides high performance cache primitives\n+/** High-performance cache primitives.\n  *\n  * Summary:\n  *\n- * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ * 1. @ref bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n  *\n- * 2) cache is a cache which is performant in memory usage and lookup speed. It\n- * is lockfree for erase operations. Elements are lazily erased on the next\n- * insert.\n+ * 2. @ref cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next insert.\n  */\n namespace CuckooCache\n {\n-/** bit_packed_atomic_flags implements a container for garbage collection flags\n+/** @ref bit_packed_atomic_flags implements a container for garbage collection flags\n  * that is only thread unsafe on calls to setup. This class bit-packs collection\n  * flags for memory efficiency.\n  *\n- * All operations are std::memory_order_relaxed so external mechanisms must\n+ * All operations are `std::memory_order_relaxed` so external mechanisms must\n  * ensure that writes and reads are properly synchronized.\n  *\n- * On setup(n), all bits up to n are marked as collected.\n+ * On setup(n), all bits up to `n` are marked as collected.\n  *\n  * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n  * of 8 for setup, but it will be safe if that is not the case as well.\n- *\n  */\n class bit_packed_atomic_flags\n {\n     std::unique_ptr<std::atomic<uint8_t>[]> mem;\n \n public:\n-    /** No default constructor as there must be some size */\n+    /** No default constructor, as there must be some size. */\n     bit_packed_atomic_flags() = delete;\n \n     /**\n      * bit_packed_atomic_flags constructor creates memory to sufficiently\n-     * keep track of garbage collection information for size entries.\n+     * keep track of garbage collection information for `size` entries.\n      *\n      * @param size the number of elements to allocate space for\n      *\n@@ -68,7 +66,7 @@ class bit_packed_atomic_flags\n     };\n \n     /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n-     * at least size entries\n+     * at least `b` entries.\n      *\n      * @param b the number of elements to allocate space for\n      * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n@@ -84,19 +82,18 @@ class bit_packed_atomic_flags\n \n     /** bit_set sets an entry as discardable.\n      *\n-     * @param s the index of the entry to bit_set.\n+     * @param s the index of the entry to bit_set\n      * @post immediately subsequent call (assuming proper external memory\n      * ordering) to bit_is_set(s) == true.\n-     *\n      */\n     inline void bit_set(uint32_t s)\n     {\n         mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n     }\n \n-    /**  bit_unset marks an entry as something that should not be overwritten\n+    /** bit_unset marks an entry as something that should not be overwritten.\n      *\n-     * @param s the index of the entry to bit_unset.\n+     * @param s the index of the entry to bit_unset\n      * @post immediately subsequent call (assuming proper external memory\n      * ordering) to bit_is_set(s) == false.\n      */\n@@ -105,26 +102,26 @@ class bit_packed_atomic_flags\n         mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n     }\n \n-    /** bit_is_set queries the table for discardability at s\n+    /** bit_is_set queries the table for discardability at `s`.\n      *\n-     * @param s the index of the entry to read.\n-     * @returns if the bit at index s was set.\n+     * @param s the index of the entry to read\n+     * @returns true if the bit at index `s` was set, false otherwise\n      * */\n     inline bool bit_is_set(uint32_t s) const\n     {\n         return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n     }\n };\n \n-/** cache implements a cache with properties similar to a cuckoo-set\n+/** @ref cache implements a cache with properties similar to a cuckoo-set.\n  *\n- *  The cache is able to hold up to (~(uint32_t)0) - 1 elements.\n+ *  The cache is able to hold up to `(~(uint32_t)0) - 1` elements.\n  *\n  *  Read Operations:\n- *      - contains(*, false)\n+ *      - contains() for `erase=false`\n  *\n  *  Read+Erase Operations:\n- *      - contains(*, true)\n+ *      - contains() for `erase=true`\n  *\n  *  Erase Operations:\n  *      - allow_erase()\n@@ -141,10 +138,10 @@ class bit_packed_atomic_flags\n  *\n  * User Must Guarantee:\n  *\n- * 1) Write Requires synchronized access (e.g., a lock)\n- * 2) Read Requires no concurrent Write, synchronized with the last insert.\n- * 3) Erase requires no concurrent Write, synchronized with last insert.\n- * 4) An Erase caller must release all memory before allowing a new Writer.\n+ * 1. Write requires synchronized access (e.g. a lock)\n+ * 2. Read requires no concurrent Write, synchronized with last insert.\n+ * 3. Erase requires no concurrent Write, synchronized with last insert.\n+ * 4. An Erase caller must release all memory before allowing a new Writer.\n  *\n  *\n  * Note on function names:\n@@ -177,7 +174,7 @@ class cache\n     mutable std::vector<bool> epoch_flags;\n \n     /** epoch_heuristic_counter is used to determine when an epoch might be aged\n-     * & an expensive scan should be done.  epoch_heuristic_counter is\n+     * & an expensive scan should be done. epoch_heuristic_counter is\n      * decremented on insert and reset to the new number of inserts which would\n      * cause the epoch to reach epoch_size when it reaches zero.\n      */\n@@ -194,24 +191,25 @@ class cache\n     uint32_t epoch_size;\n \n     /** depth_limit determines how many elements insert should try to replace.\n-     * Should be set to log2(n)*/\n+     * Should be set to log2(n).\n+     */\n     uint8_t depth_limit;\n \n     /** hash_function is a const instance of the hash function. It cannot be\n      * static or initialized at call time as it may have internal state (such as\n      * a nonce).\n-     * */\n+     */\n     const Hash hash_function;\n \n     /** compute_hashes is convenience for not having to write out this\n      * expression everywhere we use the hash values of an Element.\n      *\n      * We need to map the 32-bit input hash onto a hash bucket in a range [0, size) in a\n-     *  manner which preserves as much of the hash's uniformity as possible.  Ideally\n+     *  manner which preserves as much of the hash's uniformity as possible. Ideally\n      *  this would be done by bitmasking but the size is usually not a power of two.\n      *\n      * The naive approach would be to use a mod -- which isn't perfectly uniform but so\n-     *  long as the hash is much larger than size it is not that bad.  Unfortunately,\n+     *  long as the hash is much larger than size it is not that bad. Unfortunately,\n      *  mod/division is fairly slow on ordinary microprocessors (e.g. 90-ish cycles on\n      *  haswell, ARM doesn't even have an instruction for it.); when the divisor is a\n      *  constant the compiler will do clever tricks to turn it into a multiply+add+shift,\n@@ -223,10 +221,10 @@ class cache\n      *  somewhat complicated and the result is still slower than other options:\n      *\n      * Instead we treat the 32-bit random number as a Q32 fixed-point number in the range\n-     *  [0,1) and simply multiply it by the size.  Then we just shift the result down by\n-     *  32-bits to get our bucket number.  The result has non-uniformity the same as a\n+     *  [0, 1) and simply multiply it by the size. Then we just shift the result down by\n+     *  32-bits to get our bucket number. The result has non-uniformity the same as a\n      *  mod, but it is much faster to compute. More about this technique can be found at\n-     *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n+     *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ .\n      *\n      * The resulting non-uniformity is also more equally distributed which would be\n      *  advantageous for something like linear probing, though it shouldn't matter\n@@ -237,8 +235,8 @@ class cache\n      *  32*32->64 multiply, which means the operation is reasonably fast even on a\n      *  typical 32-bit processor.\n      *\n-     * @param e the element whose hashes will be returned\n-     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     * @param e The element whose hashes will be returned\n+     * @returns Deterministic hashes derived from `e` uniformly mapped onto the range [0, size)\n      */\n     inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n     {\n@@ -252,14 +250,14 @@ class cache\n                  (uint32_t)(((uint64_t)hash_function.template operator()<7>(e) * (uint64_t)size) >> 32)}};\n     }\n \n-    /* end\n-     * @returns a constexpr index that can never be inserted to */\n+    /** invalid returns a special index that can never be inserted to\n+     * @returns the special constexpr index that can never be inserted to */\n     constexpr uint32_t invalid() const\n     {\n         return ~(uint32_t)0;\n     }\n \n-    /** allow_erase marks the element at index n as discardable. Threadsafe\n+    /** allow_erase marks the element at index `n` as discardable. Threadsafe\n      * without any concurrent insert.\n      * @param n the index to allow erasure of\n      */\n@@ -268,7 +266,7 @@ class cache\n         collection_flags.bit_set(n);\n     }\n \n-    /** please_keep marks the element at index n as an entry that should be kept.\n+    /** please_keep marks the element at index `n` as an entry that should be kept.\n      * Threadsafe without any concurrent insert.\n      * @param n the index to prioritize keeping\n      */\n@@ -336,7 +334,7 @@ class cache\n      *\n      * @param new_size the desired number of elements to store\n      * @returns the maximum number of elements storable\n-     **/\n+     */\n     uint32_t setup(uint32_t new_size)\n     {\n         // depth_limit must be at least one otherwise errors can occur.\n@@ -360,7 +358,7 @@ class cache\n      * negligible compared to the size of the elements.\n      *\n      * @param bytes the approximate number of bytes to use for this data\n-     * structure.\n+     * structure\n      * @returns the maximum number of elements storable (see setup()\n      * documentation for more detail)\n      */\n@@ -376,18 +374,19 @@ class cache\n      * It drops the last tried element if it runs out of depth before\n      * encountering an open slot.\n      *\n-     * Thus\n+     * Thus:\n      *\n+     * ```\n      * insert(x);\n      * return contains(x, false);\n+     * ```\n      *\n      * is not guaranteed to return true.\n      *\n      * @param e the element to insert\n      * @post one of the following: All previously inserted elements and e are\n      * now in the table, one previously inserted element is evicted from the\n      * table, the entry attempted to be inserted is evicted.\n-     *\n      */\n     inline void insert(Element e)\n     {\n@@ -416,9 +415,9 @@ class cache\n             /** Swap with the element at the location that was\n             * not the last one looked at. Example:\n             *\n-            * 1) On first iteration, last_loc == invalid(), find returns last, so\n+            * 1. On first iteration, last_loc == invalid(), find returns last, so\n             *    last_loc defaults to locs[0].\n-            * 2) On further iterations, where last_loc == locs[k], last_loc will\n+            * 2. On further iterations, where last_loc == locs[k], last_loc will\n             *    go to locs[k+1 % 8], i.e., next of the 8 indices wrapping around\n             *    to 0 if needed.\n             *\n@@ -439,17 +438,19 @@ class cache\n         }\n     }\n \n-    /* contains iterates through the hash locations for a given element\n+    /** contains iterates through the hash locations for a given element\n      * and checks to see if it is present.\n      *\n      * contains does not check garbage collected state (in other words,\n      * garbage is only collected when the space is needed), so:\n      *\n+     * ```\n      * insert(x);\n      * if (contains(x, true))\n      *     return contains(x, false);\n      * else\n      *     return true;\n+     * ```\n      *\n      * executed on a single thread will always return true!\n      *\n@@ -458,7 +459,7 @@ class cache\n      * contains returns a bool set true if the element was found.\n      *\n      * @param e the element to check\n-     * @param erase\n+     * @param erase whether to attempt setting the garbage collect flag\n      *\n      * @post if erase is true and the element is found, then the garbage collect\n      * flag is set"
      },
      {
        "sha": "a3017da3e74d08c22e662420f5632b7e536d9e8a",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7aad3b68e7e1680870ca70d945eee88f790d6454/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7aad3b68e7e1680870ca70d945eee88f790d6454/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=7aad3b68e7e1680870ca70d945eee88f790d6454",
        "patch": "@@ -10,11 +10,11 @@\n \n /** Test Suite for CuckooCache\n  *\n- *  1) All tests should have a deterministic result (using insecure rand\n+ *  1. All tests should have a deterministic result (using insecure rand\n  *  with deterministic seeds)\n- *  2) Some test methods are templated to allow for easier testing\n+ *  2. Some test methods are templated to allow for easier testing\n  *  against new versions / comparing\n- *  3) Results should be treated as a regression test, i.e., did the behavior\n+ *  3. Results should be treated as a regression test, i.e., did the behavior\n  *  change significantly from what was expected. This can be OK, depending on\n  *  the nature of the change, but requires updating the tests to reflect the new\n  *  expected behavior. For example improving the hit rate may cause some tests\n@@ -82,9 +82,9 @@ static double test_cache(size_t megabytes, double load)\n  *\n  * Examples:\n  *\n- * 1) at load 0.5, we expect a perfect hit rate, so we multiply by\n+ * 1. at load 0.5, we expect a perfect hit rate, so we multiply by\n  * 1.0\n- * 2) at load 2.0, we expect to see half the entries, so a perfect hit rate\n+ * 2. at load 2.0, we expect to see half the entries, so a perfect hit rate\n  * would be 0.5. Therefore, if we see a hit rate of 0.4, 0.4*2.0 = 0.8 is the\n  * normalized hit rate.\n  *"
      }
    ]
  }
]