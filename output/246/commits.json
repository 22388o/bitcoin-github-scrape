[
  {
    "sha": "defe363c1f1070473d6a64e6c2556f95c1f55cd5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZWZlMzYzYzFmMTA3MDQ3M2Q2YTY0ZTZjMjU1NmY5NWMxZjU1Y2Q1",
    "commit": {
      "author": {
        "name": "Caner Candan",
        "email": "caner@candan.fr",
        "date": "2011-05-15T21:07:04Z"
      },
      "committer": {
        "name": "Caner Candan",
        "email": "caner@candan.fr",
        "date": "2011-05-15T21:07:04Z"
      },
      "message": "* whitespaces cleanup",
      "tree": {
        "sha": "842357dbc4f931cd03d27a8ddc1a8944886407ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/842357dbc4f931cd03d27a8ddc1a8944886407ff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/defe363c1f1070473d6a64e6c2556f95c1f55cd5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/defe363c1f1070473d6a64e6c2556f95c1f55cd5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/defe363c1f1070473d6a64e6c2556f95c1f55cd5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/defe363c1f1070473d6a64e6c2556f95c1f55cd5/comments",
    "author": {
      "login": "canercandan",
      "id": 285572,
      "node_id": "MDQ6VXNlcjI4NTU3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/285572?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/canercandan",
      "html_url": "https://github.com/canercandan",
      "followers_url": "https://api.github.com/users/canercandan/followers",
      "following_url": "https://api.github.com/users/canercandan/following{/other_user}",
      "gists_url": "https://api.github.com/users/canercandan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/canercandan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/canercandan/subscriptions",
      "organizations_url": "https://api.github.com/users/canercandan/orgs",
      "repos_url": "https://api.github.com/users/canercandan/repos",
      "events_url": "https://api.github.com/users/canercandan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/canercandan/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "canercandan",
      "id": 285572,
      "node_id": "MDQ6VXNlcjI4NTU3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/285572?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/canercandan",
      "html_url": "https://github.com/canercandan",
      "followers_url": "https://api.github.com/users/canercandan/followers",
      "following_url": "https://api.github.com/users/canercandan/following{/other_user}",
      "gists_url": "https://api.github.com/users/canercandan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/canercandan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/canercandan/subscriptions",
      "organizations_url": "https://api.github.com/users/canercandan/orgs",
      "repos_url": "https://api.github.com/users/canercandan/repos",
      "events_url": "https://api.github.com/users/canercandan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/canercandan/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c22feee634ade7f887d7e29635a8e5dc44675273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c22feee634ade7f887d7e29635a8e5dc44675273",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c22feee634ade7f887d7e29635a8e5dc44675273"
      }
    ],
    "stats": {
      "total": 35595,
      "additions": 17795,
      "deletions": 17800
    },
    "files": [
      {
        "sha": "39f36f243f6886c6f9392501804f299738a52678",
        "filename": "contrib/gitian.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/contrib/gitian.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/contrib/gitian.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian.yml?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -5,7 +5,7 @@ suites:\n architectures:\n - \"i386\"\n - \"amd64\"\n-packages: \n+packages:\n - \"libdb4.8++-dev\"\n - \"libxxf86vm-dev\"\n - \"libgtk2.0-dev\""
      },
      {
        "sha": "8edc09dbedf45a968493d47144c2fbf7a3e185c3",
        "filename": "doc/build-msw.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/doc/build-msw.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/doc/build-msw.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-msw.txt?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -26,7 +26,7 @@ Dependencies\n ------------\n Libraries you need to download separately and build:\n \n-                default path               download\n+\t\tdefault path               download\n wxWidgets       \\wxwidgets-2.9.1-mgw       http://www.wxwidgets.org/downloads/\n OpenSSL         \\openssl-1.0.0c-mgw        http://www.openssl.org/source/\n Berkeley DB     \\db-4.7.25.NC-mgw          http://www.oracle.com/technology/software/products/berkeley-db/index.html"
      },
      {
        "sha": "5548ab417a6898ac540551d555b94dbdfb4c2a89",
        "filename": "doc/build-osx.txt",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/doc/build-osx.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/doc/build-osx.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.txt?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -43,7 +43,7 @@ name of the directory, for example /Users/james/bitcoin/deps for a user named\n cd ~/bitcoin\n svn checkout https://bitcoin.svn.sourceforge.net/svnroot/bitcoin/trunk\n \n-This will make ~/bitcoin/trunk for you with all the files from subversion. \n+This will make ~/bitcoin/trunk for you with all the files from subversion.\n \n 3.  Get and build the dependencies\n \n@@ -219,17 +219,17 @@ cd \"$BUILDDIR\" &&\n --with-macosx-sdk=/Developer/SDKs/MacOSX10.5.sdk &&\n \n \n-find . -name Makefile | \n-while read i; do \n-  echo $i; \n-  sed 's/-arch i386/-arch i386 -arch x86_64/g' < \"$i\" > \"$i\".new && \n-  mv \"$i\" \"$i\".old && \n-  mv \"$i\".new \"$i\"; \n+find . -name Makefile |\n+while read i; do\n+  echo $i;\n+  sed 's/-arch i386/-arch i386 -arch x86_64/g' < \"$i\" > \"$i\".new &&\n+  mv \"$i\" \"$i\".old &&\n+  mv \"$i\".new \"$i\";\n done\n \n \n \n-make && \n+make &&\n make install\n \n "
      },
      {
        "sha": "06202baa57df23a1b5805b21eb4592a547a1d9a1",
        "filename": "doc/coding.txt",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/doc/coding.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/doc/coding.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/coding.txt?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -7,10 +7,10 @@ bool Function(char* psz, int n)\n     // Comment summarising what this section of code does\r\n     for (int i = 0; i < n; i++)\r\n     {\r\n-        // When something fails, return early\r\n-        if (!Something())\r\n-            return false;\r\n-        ...\r\n+\t// When something fails, return early\r\n+\tif (!Something())\r\n+\t    return false;\r\n+\t...\r\n     }\r\n \r\n     // Success return is usually at the end\r\n@@ -28,7 +28,7 @@ someVariable.\n \r\n Common types:\r\n n       integer number: short, unsigned short, int, unsigned int,\r\n-            int64, uint64, sometimes char if used as a number\r\n+\t    int64, uint64, sometimes char if used as a number\r\n d       double, float\r\n f       flag\r\n hash    uint256\r"
      },
      {
        "sha": "ea871c7aaf44902286ca8b8aa6ee1c67517b3fec",
        "filename": "share/uiproject.fbp",
        "status": "modified",
        "additions": 6352,
        "deletions": 6352,
        "changes": 12704,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/share/uiproject.fbp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/share/uiproject.fbp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/uiproject.fbp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5"
      },
      {
        "sha": "415d9a2ab2571dc9ab52fb248906f40888688fa6",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -38,16 +38,16 @@ inline string EncodeBase58(const unsigned char* pbegin, const unsigned char* pen\n     CBigNum rem;\n     while (bn > bn0)\n     {\n-        if (!BN_div(&dv, &rem, &bn, &bn58, pctx))\n-            throw bignum_error(\"EncodeBase58 : BN_div failed\");\n-        bn = dv;\n-        unsigned int c = rem.getulong();\n-        str += pszBase58[c];\n+\tif (!BN_div(&dv, &rem, &bn, &bn58, pctx))\n+\t    throw bignum_error(\"EncodeBase58 : BN_div failed\");\n+\tbn = dv;\n+\tunsigned int c = rem.getulong();\n+\tstr += pszBase58[c];\n     }\n \n     // Leading zeroes encoded as base58 zeros\n     for (const unsigned char* p = pbegin; p < pend && *p == 0; p++)\n-        str += pszBase58[0];\n+\tstr += pszBase58[0];\n \n     // Convert little endian string to big endian\n     reverse(str.begin(), str.end());\n@@ -67,37 +67,37 @@ inline bool DecodeBase58(const char* psz, vector<unsigned char>& vchRet)\n     CBigNum bn = 0;\n     CBigNum bnChar;\n     while (isspace(*psz))\n-        psz++;\n+\tpsz++;\n \n     // Convert big endian string to bignum\n     for (const char* p = psz; *p; p++)\n     {\n-        const char* p1 = strchr(pszBase58, *p);\n-        if (p1 == NULL)\n-        {\n-            while (isspace(*p))\n-                p++;\n-            if (*p != '\\0')\n-                return false;\n-            break;\n-        }\n-        bnChar.setulong(p1 - pszBase58);\n-        if (!BN_mul(&bn, &bn, &bn58, pctx))\n-            throw bignum_error(\"DecodeBase58 : BN_mul failed\");\n-        bn += bnChar;\n+\tconst char* p1 = strchr(pszBase58, *p);\n+\tif (p1 == NULL)\n+\t{\n+\t    while (isspace(*p))\n+\t\tp++;\n+\t    if (*p != '\\0')\n+\t\treturn false;\n+\t    break;\n+\t}\n+\tbnChar.setulong(p1 - pszBase58);\n+\tif (!BN_mul(&bn, &bn, &bn58, pctx))\n+\t    throw bignum_error(\"DecodeBase58 : BN_mul failed\");\n+\tbn += bnChar;\n     }\n \n     // Get bignum as little endian data\n     vector<unsigned char> vchTmp = bn.getvch();\n \n     // Trim off sign byte if present\n     if (vchTmp.size() >= 2 && vchTmp.end()[-1] == 0 && vchTmp.end()[-2] >= 0x80)\n-        vchTmp.erase(vchTmp.end()-1);\n+\tvchTmp.erase(vchTmp.end()-1);\n \n     // Restore leading zeros\n     int nLeadingZeros = 0;\n     for (const char* p = psz; *p == pszBase58[0]; p++)\n-        nLeadingZeros++;\n+\tnLeadingZeros++;\n     vchRet.assign(nLeadingZeros + vchTmp.size(), 0);\n \n     // Convert little endian data to big endian\n@@ -126,17 +126,17 @@ inline string EncodeBase58Check(const vector<unsigned char>& vchIn)\n inline bool DecodeBase58Check(const char* psz, vector<unsigned char>& vchRet)\n {\n     if (!DecodeBase58(psz, vchRet))\n-        return false;\n+\treturn false;\n     if (vchRet.size() < 4)\n     {\n-        vchRet.clear();\n-        return false;\n+\tvchRet.clear();\n+\treturn false;\n     }\n     uint256 hash = Hash(vchRet.begin(), vchRet.end()-4);\n     if (memcmp(&hash, &vchRet.end()[-4], 4) != 0)\n     {\n-        vchRet.clear();\n-        return false;\n+\tvchRet.clear();\n+\treturn false;\n     }\n     vchRet.resize(vchRet.size()-4);\n     return true;\n@@ -166,12 +166,12 @@ inline bool AddressToHash160(const char* psz, uint160& hash160Ret)\n {\n     vector<unsigned char> vch;\n     if (!DecodeBase58Check(psz, vch))\n-        return false;\n+\treturn false;\n     if (vch.empty())\n-        return false;\n+\treturn false;\n     unsigned char nVersion = vch[0];\n     if (vch.size() != sizeof(hash160Ret) + 1)\n-        return false;\n+\treturn false;\n     memcpy(&hash160Ret, &vch[1], sizeof(hash160Ret));\n     return (nVersion <= ADDRESSVERSION);\n }"
      },
      {
        "sha": "5c522edb4df7afbe0be3b0dab0e44bbb4084e4b6",
        "filename": "src/bignum.h",
        "status": "modified",
        "additions": 256,
        "deletions": 256,
        "changes": 512,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/bignum.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/bignum.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bignum.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -27,15 +27,15 @@ class CAutoBN_CTX\n public:\n     CAutoBN_CTX()\n     {\n-        pctx = BN_CTX_new();\n-        if (pctx == NULL)\n-            throw bignum_error(\"CAutoBN_CTX : BN_CTX_new() returned NULL\");\n+\tpctx = BN_CTX_new();\n+\tif (pctx == NULL)\n+\t    throw bignum_error(\"CAutoBN_CTX : BN_CTX_new() returned NULL\");\n     }\n \n     ~CAutoBN_CTX()\n     {\n-        if (pctx != NULL)\n-            BN_CTX_free(pctx);\n+\tif (pctx != NULL)\n+\t    BN_CTX_free(pctx);\n     }\n \n     operator BN_CTX*() { return pctx; }\n@@ -51,29 +51,29 @@ class CBigNum : public BIGNUM\n public:\n     CBigNum()\n     {\n-        BN_init(this);\n+\tBN_init(this);\n     }\n \n     CBigNum(const CBigNum& b)\n     {\n-        BN_init(this);\n-        if (!BN_copy(this, &b))\n-        {\n-            BN_clear_free(this);\n-            throw bignum_error(\"CBigNum::CBigNum(const CBigNum&) : BN_copy failed\");\n-        }\n+\tBN_init(this);\n+\tif (!BN_copy(this, &b))\n+\t{\n+\t    BN_clear_free(this);\n+\t    throw bignum_error(\"CBigNum::CBigNum(const CBigNum&) : BN_copy failed\");\n+\t}\n     }\n \n     CBigNum& operator=(const CBigNum& b)\n     {\n-        if (!BN_copy(this, &b))\n-            throw bignum_error(\"CBigNum::operator= : BN_copy failed\");\n-        return (*this);\n+\tif (!BN_copy(this, &b))\n+\t    throw bignum_error(\"CBigNum::operator= : BN_copy failed\");\n+\treturn (*this);\n     }\n \n     ~CBigNum()\n     {\n-        BN_clear_free(this);\n+\tBN_clear_free(this);\n     }\n \n     CBigNum(char n)             { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }\n@@ -90,365 +90,365 @@ class CBigNum : public BIGNUM\n \n     explicit CBigNum(const std::vector<unsigned char>& vch)\n     {\n-        BN_init(this);\n-        setvch(vch);\n+\tBN_init(this);\n+\tsetvch(vch);\n     }\n \n     void setulong(unsigned long n)\n     {\n-        if (!BN_set_word(this, n))\n-            throw bignum_error(\"CBigNum conversion from unsigned long : BN_set_word failed\");\n+\tif (!BN_set_word(this, n))\n+\t    throw bignum_error(\"CBigNum conversion from unsigned long : BN_set_word failed\");\n     }\n \n     unsigned long getulong() const\n     {\n-        return BN_get_word(this);\n+\treturn BN_get_word(this);\n     }\n \n     unsigned int getuint() const\n     {\n-        return BN_get_word(this);\n+\treturn BN_get_word(this);\n     }\n \n     int getint() const\n     {\n-        unsigned long n = BN_get_word(this);\n-        if (!BN_is_negative(this))\n-            return (n > INT_MAX ? INT_MAX : n);\n-        else\n-            return (n > INT_MAX ? INT_MIN : -(int)n);\n+\tunsigned long n = BN_get_word(this);\n+\tif (!BN_is_negative(this))\n+\t    return (n > INT_MAX ? INT_MAX : n);\n+\telse\n+\t    return (n > INT_MAX ? INT_MIN : -(int)n);\n     }\n \n     void setint64(int64 n)\n     {\n-        unsigned char pch[sizeof(n) + 6];\n-        unsigned char* p = pch + 4;\n-        bool fNegative = false;\n-        if (n < (int64)0)\n-        {\n-            n = -n;\n-            fNegative = true;\n-        }\n-        bool fLeadingZeroes = true;\n-        for (int i = 0; i < 8; i++)\n-        {\n-            unsigned char c = (n >> 56) & 0xff;\n-            n <<= 8;\n-            if (fLeadingZeroes)\n-            {\n-                if (c == 0)\n-                    continue;\n-                if (c & 0x80)\n-                    *p++ = (fNegative ? 0x80 : 0);\n-                else if (fNegative)\n-                    c |= 0x80;\n-                fLeadingZeroes = false;\n-            }\n-            *p++ = c;\n-        }\n-        unsigned int nSize = p - (pch + 4);\n-        pch[0] = (nSize >> 24) & 0xff;\n-        pch[1] = (nSize >> 16) & 0xff;\n-        pch[2] = (nSize >> 8) & 0xff;\n-        pch[3] = (nSize) & 0xff;\n-        BN_mpi2bn(pch, p - pch, this);\n+\tunsigned char pch[sizeof(n) + 6];\n+\tunsigned char* p = pch + 4;\n+\tbool fNegative = false;\n+\tif (n < (int64)0)\n+\t{\n+\t    n = -n;\n+\t    fNegative = true;\n+\t}\n+\tbool fLeadingZeroes = true;\n+\tfor (int i = 0; i < 8; i++)\n+\t{\n+\t    unsigned char c = (n >> 56) & 0xff;\n+\t    n <<= 8;\n+\t    if (fLeadingZeroes)\n+\t    {\n+\t\tif (c == 0)\n+\t\t    continue;\n+\t\tif (c & 0x80)\n+\t\t    *p++ = (fNegative ? 0x80 : 0);\n+\t\telse if (fNegative)\n+\t\t    c |= 0x80;\n+\t\tfLeadingZeroes = false;\n+\t    }\n+\t    *p++ = c;\n+\t}\n+\tunsigned int nSize = p - (pch + 4);\n+\tpch[0] = (nSize >> 24) & 0xff;\n+\tpch[1] = (nSize >> 16) & 0xff;\n+\tpch[2] = (nSize >> 8) & 0xff;\n+\tpch[3] = (nSize) & 0xff;\n+\tBN_mpi2bn(pch, p - pch, this);\n     }\n \n     void setuint64(uint64 n)\n     {\n-        unsigned char pch[sizeof(n) + 6];\n-        unsigned char* p = pch + 4;\n-        bool fLeadingZeroes = true;\n-        for (int i = 0; i < 8; i++)\n-        {\n-            unsigned char c = (n >> 56) & 0xff;\n-            n <<= 8;\n-            if (fLeadingZeroes)\n-            {\n-                if (c == 0)\n-                    continue;\n-                if (c & 0x80)\n-                    *p++ = 0;\n-                fLeadingZeroes = false;\n-            }\n-            *p++ = c;\n-        }\n-        unsigned int nSize = p - (pch + 4);\n-        pch[0] = (nSize >> 24) & 0xff;\n-        pch[1] = (nSize >> 16) & 0xff;\n-        pch[2] = (nSize >> 8) & 0xff;\n-        pch[3] = (nSize) & 0xff;\n-        BN_mpi2bn(pch, p - pch, this);\n+\tunsigned char pch[sizeof(n) + 6];\n+\tunsigned char* p = pch + 4;\n+\tbool fLeadingZeroes = true;\n+\tfor (int i = 0; i < 8; i++)\n+\t{\n+\t    unsigned char c = (n >> 56) & 0xff;\n+\t    n <<= 8;\n+\t    if (fLeadingZeroes)\n+\t    {\n+\t\tif (c == 0)\n+\t\t    continue;\n+\t\tif (c & 0x80)\n+\t\t    *p++ = 0;\n+\t\tfLeadingZeroes = false;\n+\t    }\n+\t    *p++ = c;\n+\t}\n+\tunsigned int nSize = p - (pch + 4);\n+\tpch[0] = (nSize >> 24) & 0xff;\n+\tpch[1] = (nSize >> 16) & 0xff;\n+\tpch[2] = (nSize >> 8) & 0xff;\n+\tpch[3] = (nSize) & 0xff;\n+\tBN_mpi2bn(pch, p - pch, this);\n     }\n \n     void setuint256(uint256 n)\n     {\n-        unsigned char pch[sizeof(n) + 6];\n-        unsigned char* p = pch + 4;\n-        bool fLeadingZeroes = true;\n-        unsigned char* pbegin = (unsigned char*)&n;\n-        unsigned char* psrc = pbegin + sizeof(n);\n-        while (psrc != pbegin)\n-        {\n-            unsigned char c = *(--psrc);\n-            if (fLeadingZeroes)\n-            {\n-                if (c == 0)\n-                    continue;\n-                if (c & 0x80)\n-                    *p++ = 0;\n-                fLeadingZeroes = false;\n-            }\n-            *p++ = c;\n-        }\n-        unsigned int nSize = p - (pch + 4);\n-        pch[0] = (nSize >> 24) & 0xff;\n-        pch[1] = (nSize >> 16) & 0xff;\n-        pch[2] = (nSize >> 8) & 0xff;\n-        pch[3] = (nSize >> 0) & 0xff;\n-        BN_mpi2bn(pch, p - pch, this);\n+\tunsigned char pch[sizeof(n) + 6];\n+\tunsigned char* p = pch + 4;\n+\tbool fLeadingZeroes = true;\n+\tunsigned char* pbegin = (unsigned char*)&n;\n+\tunsigned char* psrc = pbegin + sizeof(n);\n+\twhile (psrc != pbegin)\n+\t{\n+\t    unsigned char c = *(--psrc);\n+\t    if (fLeadingZeroes)\n+\t    {\n+\t\tif (c == 0)\n+\t\t    continue;\n+\t\tif (c & 0x80)\n+\t\t    *p++ = 0;\n+\t\tfLeadingZeroes = false;\n+\t    }\n+\t    *p++ = c;\n+\t}\n+\tunsigned int nSize = p - (pch + 4);\n+\tpch[0] = (nSize >> 24) & 0xff;\n+\tpch[1] = (nSize >> 16) & 0xff;\n+\tpch[2] = (nSize >> 8) & 0xff;\n+\tpch[3] = (nSize >> 0) & 0xff;\n+\tBN_mpi2bn(pch, p - pch, this);\n     }\n \n     uint256 getuint256()\n     {\n-        unsigned int nSize = BN_bn2mpi(this, NULL);\n-        if (nSize < 4)\n-            return 0;\n-        std::vector<unsigned char> vch(nSize);\n-        BN_bn2mpi(this, &vch[0]);\n-        if (vch.size() > 4)\n-            vch[4] &= 0x7f;\n-        uint256 n = 0;\n-        for (int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n-            ((unsigned char*)&n)[i] = vch[j];\n-        return n;\n+\tunsigned int nSize = BN_bn2mpi(this, NULL);\n+\tif (nSize < 4)\n+\t    return 0;\n+\tstd::vector<unsigned char> vch(nSize);\n+\tBN_bn2mpi(this, &vch[0]);\n+\tif (vch.size() > 4)\n+\t    vch[4] &= 0x7f;\n+\tuint256 n = 0;\n+\tfor (int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n+\t    ((unsigned char*)&n)[i] = vch[j];\n+\treturn n;\n     }\n \n     void setvch(const std::vector<unsigned char>& vch)\n     {\n-        std::vector<unsigned char> vch2(vch.size() + 4);\n-        unsigned int nSize = vch.size();\n-        vch2[0] = (nSize >> 24) & 0xff;\n-        vch2[1] = (nSize >> 16) & 0xff;\n-        vch2[2] = (nSize >> 8) & 0xff;\n-        vch2[3] = (nSize >> 0) & 0xff;\n-        reverse_copy(vch.begin(), vch.end(), vch2.begin() + 4);\n-        BN_mpi2bn(&vch2[0], vch2.size(), this);\n+\tstd::vector<unsigned char> vch2(vch.size() + 4);\n+\tunsigned int nSize = vch.size();\n+\tvch2[0] = (nSize >> 24) & 0xff;\n+\tvch2[1] = (nSize >> 16) & 0xff;\n+\tvch2[2] = (nSize >> 8) & 0xff;\n+\tvch2[3] = (nSize >> 0) & 0xff;\n+\treverse_copy(vch.begin(), vch.end(), vch2.begin() + 4);\n+\tBN_mpi2bn(&vch2[0], vch2.size(), this);\n     }\n \n     std::vector<unsigned char> getvch() const\n     {\n-        unsigned int nSize = BN_bn2mpi(this, NULL);\n-        if (nSize < 4)\n-            return std::vector<unsigned char>();\n-        std::vector<unsigned char> vch(nSize);\n-        BN_bn2mpi(this, &vch[0]);\n-        vch.erase(vch.begin(), vch.begin() + 4);\n-        reverse(vch.begin(), vch.end());\n-        return vch;\n+\tunsigned int nSize = BN_bn2mpi(this, NULL);\n+\tif (nSize < 4)\n+\t    return std::vector<unsigned char>();\n+\tstd::vector<unsigned char> vch(nSize);\n+\tBN_bn2mpi(this, &vch[0]);\n+\tvch.erase(vch.begin(), vch.begin() + 4);\n+\treverse(vch.begin(), vch.end());\n+\treturn vch;\n     }\n \n     CBigNum& SetCompact(unsigned int nCompact)\n     {\n-        unsigned int nSize = nCompact >> 24;\n-        std::vector<unsigned char> vch(4 + nSize);\n-        vch[3] = nSize;\n-        if (nSize >= 1) vch[4] = (nCompact >> 16) & 0xff;\n-        if (nSize >= 2) vch[5] = (nCompact >> 8) & 0xff;\n-        if (nSize >= 3) vch[6] = (nCompact >> 0) & 0xff;\n-        BN_mpi2bn(&vch[0], vch.size(), this);\n-        return *this;\n+\tunsigned int nSize = nCompact >> 24;\n+\tstd::vector<unsigned char> vch(4 + nSize);\n+\tvch[3] = nSize;\n+\tif (nSize >= 1) vch[4] = (nCompact >> 16) & 0xff;\n+\tif (nSize >= 2) vch[5] = (nCompact >> 8) & 0xff;\n+\tif (nSize >= 3) vch[6] = (nCompact >> 0) & 0xff;\n+\tBN_mpi2bn(&vch[0], vch.size(), this);\n+\treturn *this;\n     }\n \n     unsigned int GetCompact() const\n     {\n-        unsigned int nSize = BN_bn2mpi(this, NULL);\n-        std::vector<unsigned char> vch(nSize);\n-        nSize -= 4;\n-        BN_bn2mpi(this, &vch[0]);\n-        unsigned int nCompact = nSize << 24;\n-        if (nSize >= 1) nCompact |= (vch[4] << 16);\n-        if (nSize >= 2) nCompact |= (vch[5] << 8);\n-        if (nSize >= 3) nCompact |= (vch[6] << 0);\n-        return nCompact;\n+\tunsigned int nSize = BN_bn2mpi(this, NULL);\n+\tstd::vector<unsigned char> vch(nSize);\n+\tnSize -= 4;\n+\tBN_bn2mpi(this, &vch[0]);\n+\tunsigned int nCompact = nSize << 24;\n+\tif (nSize >= 1) nCompact |= (vch[4] << 16);\n+\tif (nSize >= 2) nCompact |= (vch[5] << 8);\n+\tif (nSize >= 3) nCompact |= (vch[6] << 0);\n+\treturn nCompact;\n     }\n \n     void SetHex(const std::string& str)\n     {\n-        // skip 0x\n-        const char* psz = str.c_str();\n-        while (isspace(*psz))\n-            psz++;\n-        bool fNegative = false;\n-        if (*psz == '-')\n-        {\n-            fNegative = true;\n-            psz++;\n-        }\n-        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n-            psz += 2;\n-        while (isspace(*psz))\n-            psz++;\n-\n-        // hex string to bignum\n-        static char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n-        *this = 0;\n-        while (isxdigit(*psz))\n-        {\n-            *this <<= 4;\n-            int n = phexdigit[*psz++];\n-            *this += n;\n-        }\n-        if (fNegative)\n-            *this = 0 - *this;\n+\t// skip 0x\n+\tconst char* psz = str.c_str();\n+\twhile (isspace(*psz))\n+\t    psz++;\n+\tbool fNegative = false;\n+\tif (*psz == '-')\n+\t{\n+\t    fNegative = true;\n+\t    psz++;\n+\t}\n+\tif (psz[0] == '0' && tolower(psz[1]) == 'x')\n+\t    psz += 2;\n+\twhile (isspace(*psz))\n+\t    psz++;\n+\n+\t// hex string to bignum\n+\tstatic char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n+\t*this = 0;\n+\twhile (isxdigit(*psz))\n+\t{\n+\t    *this <<= 4;\n+\t    int n = phexdigit[*psz++];\n+\t    *this += n;\n+\t}\n+\tif (fNegative)\n+\t    *this = 0 - *this;\n     }\n \n     std::string ToString(int nBase=10) const\n     {\n-        CAutoBN_CTX pctx;\n-        CBigNum bnBase = nBase;\n-        CBigNum bn0 = 0;\n-        string str;\n-        CBigNum bn = *this;\n-        BN_set_negative(&bn, false);\n-        CBigNum dv;\n-        CBigNum rem;\n-        if (BN_cmp(&bn, &bn0) == 0)\n-            return \"0\";\n-        while (BN_cmp(&bn, &bn0) > 0)\n-        {\n-            if (!BN_div(&dv, &rem, &bn, &bnBase, pctx))\n-                throw bignum_error(\"CBigNum::ToString() : BN_div failed\");\n-            bn = dv;\n-            unsigned int c = rem.getulong();\n-            str += \"0123456789abcdef\"[c];\n-        }\n-        if (BN_is_negative(this))\n-            str += \"-\";\n-        reverse(str.begin(), str.end());\n-        return str;\n+\tCAutoBN_CTX pctx;\n+\tCBigNum bnBase = nBase;\n+\tCBigNum bn0 = 0;\n+\tstring str;\n+\tCBigNum bn = *this;\n+\tBN_set_negative(&bn, false);\n+\tCBigNum dv;\n+\tCBigNum rem;\n+\tif (BN_cmp(&bn, &bn0) == 0)\n+\t    return \"0\";\n+\twhile (BN_cmp(&bn, &bn0) > 0)\n+\t{\n+\t    if (!BN_div(&dv, &rem, &bn, &bnBase, pctx))\n+\t\tthrow bignum_error(\"CBigNum::ToString() : BN_div failed\");\n+\t    bn = dv;\n+\t    unsigned int c = rem.getulong();\n+\t    str += \"0123456789abcdef\"[c];\n+\t}\n+\tif (BN_is_negative(this))\n+\t    str += \"-\";\n+\treverse(str.begin(), str.end());\n+\treturn str;\n     }\n \n     std::string GetHex() const\n     {\n-        return ToString(16);\n+\treturn ToString(16);\n     }\n \n     unsigned int GetSerializeSize(int nType=0, int nVersion=VERSION) const\n     {\n-        return ::GetSerializeSize(getvch(), nType, nVersion);\n+\treturn ::GetSerializeSize(getvch(), nType, nVersion);\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s, int nType=0, int nVersion=VERSION) const\n     {\n-        ::Serialize(s, getvch(), nType, nVersion);\n+\t::Serialize(s, getvch(), nType, nVersion);\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream& s, int nType=0, int nVersion=VERSION)\n     {\n-        vector<unsigned char> vch;\n-        ::Unserialize(s, vch, nType, nVersion);\n-        setvch(vch);\n+\tvector<unsigned char> vch;\n+\t::Unserialize(s, vch, nType, nVersion);\n+\tsetvch(vch);\n     }\n \n \n     bool operator!() const\n     {\n-        return BN_is_zero(this);\n+\treturn BN_is_zero(this);\n     }\n \n     CBigNum& operator+=(const CBigNum& b)\n     {\n-        if (!BN_add(this, this, &b))\n-            throw bignum_error(\"CBigNum::operator+= : BN_add failed\");\n-        return *this;\n+\tif (!BN_add(this, this, &b))\n+\t    throw bignum_error(\"CBigNum::operator+= : BN_add failed\");\n+\treturn *this;\n     }\n \n     CBigNum& operator-=(const CBigNum& b)\n     {\n-        *this = *this - b;\n-        return *this;\n+\t*this = *this - b;\n+\treturn *this;\n     }\n \n     CBigNum& operator*=(const CBigNum& b)\n     {\n-        CAutoBN_CTX pctx;\n-        if (!BN_mul(this, this, &b, pctx))\n-            throw bignum_error(\"CBigNum::operator*= : BN_mul failed\");\n-        return *this;\n+\tCAutoBN_CTX pctx;\n+\tif (!BN_mul(this, this, &b, pctx))\n+\t    throw bignum_error(\"CBigNum::operator*= : BN_mul failed\");\n+\treturn *this;\n     }\n \n     CBigNum& operator/=(const CBigNum& b)\n     {\n-        *this = *this / b;\n-        return *this;\n+\t*this = *this / b;\n+\treturn *this;\n     }\n \n     CBigNum& operator%=(const CBigNum& b)\n     {\n-        *this = *this % b;\n-        return *this;\n+\t*this = *this % b;\n+\treturn *this;\n     }\n \n     CBigNum& operator<<=(unsigned int shift)\n     {\n-        if (!BN_lshift(this, this, shift))\n-            throw bignum_error(\"CBigNum:operator<<= : BN_lshift failed\");\n-        return *this;\n+\tif (!BN_lshift(this, this, shift))\n+\t    throw bignum_error(\"CBigNum:operator<<= : BN_lshift failed\");\n+\treturn *this;\n     }\n \n     CBigNum& operator>>=(unsigned int shift)\n     {\n-        // Note: BN_rshift segfaults on 64-bit if 2^shift is greater than the number\n-        //   if built on ubuntu 9.04 or 9.10, probably depends on version of openssl\n-        CBigNum a = 1;\n-        a <<= shift;\n-        if (BN_cmp(&a, this) > 0)\n-        {\n-            *this = 0;\n-            return *this;\n-        }\n+\t// Note: BN_rshift segfaults on 64-bit if 2^shift is greater than the number\n+\t//   if built on ubuntu 9.04 or 9.10, probably depends on version of openssl\n+\tCBigNum a = 1;\n+\ta <<= shift;\n+\tif (BN_cmp(&a, this) > 0)\n+\t{\n+\t    *this = 0;\n+\t    return *this;\n+\t}\n \n-        if (!BN_rshift(this, this, shift))\n-            throw bignum_error(\"CBigNum:operator>>= : BN_rshift failed\");\n-        return *this;\n+\tif (!BN_rshift(this, this, shift))\n+\t    throw bignum_error(\"CBigNum:operator>>= : BN_rshift failed\");\n+\treturn *this;\n     }\n \n \n     CBigNum& operator++()\n     {\n-        // prefix operator\n-        if (!BN_add(this, this, BN_value_one()))\n-            throw bignum_error(\"CBigNum::operator++ : BN_add failed\");\n-        return *this;\n+\t// prefix operator\n+\tif (!BN_add(this, this, BN_value_one()))\n+\t    throw bignum_error(\"CBigNum::operator++ : BN_add failed\");\n+\treturn *this;\n     }\n \n     const CBigNum operator++(int)\n     {\n-        // postfix operator\n-        const CBigNum ret = *this;\n-        ++(*this);\n-        return ret;\n+\t// postfix operator\n+\tconst CBigNum ret = *this;\n+\t++(*this);\n+\treturn ret;\n     }\n \n     CBigNum& operator--()\n     {\n-        // prefix operator\n-        CBigNum r;\n-        if (!BN_sub(&r, this, BN_value_one()))\n-            throw bignum_error(\"CBigNum::operator-- : BN_sub failed\");\n-        *this = r;\n-        return *this;\n+\t// prefix operator\n+\tCBigNum r;\n+\tif (!BN_sub(&r, this, BN_value_one()))\n+\t    throw bignum_error(\"CBigNum::operator-- : BN_sub failed\");\n+\t*this = r;\n+\treturn *this;\n     }\n \n     const CBigNum operator--(int)\n     {\n-        // postfix operator\n-        const CBigNum ret = *this;\n-        --(*this);\n-        return ret;\n+\t// postfix operator\n+\tconst CBigNum ret = *this;\n+\t--(*this);\n+\treturn ret;\n     }\n \n \n@@ -463,15 +463,15 @@ inline const CBigNum operator+(const CBigNum& a, const CBigNum& b)\n {\n     CBigNum r;\n     if (!BN_add(&r, &a, &b))\n-        throw bignum_error(\"CBigNum::operator+ : BN_add failed\");\n+\tthrow bignum_error(\"CBigNum::operator+ : BN_add failed\");\n     return r;\n }\n \n inline const CBigNum operator-(const CBigNum& a, const CBigNum& b)\n {\n     CBigNum r;\n     if (!BN_sub(&r, &a, &b))\n-        throw bignum_error(\"CBigNum::operator- : BN_sub failed\");\n+\tthrow bignum_error(\"CBigNum::operator- : BN_sub failed\");\n     return r;\n }\n \n@@ -487,7 +487,7 @@ inline const CBigNum operator*(const CBigNum& a, const CBigNum& b)\n     CAutoBN_CTX pctx;\n     CBigNum r;\n     if (!BN_mul(&r, &a, &b, pctx))\n-        throw bignum_error(\"CBigNum::operator* : BN_mul failed\");\n+\tthrow bignum_error(\"CBigNum::operator* : BN_mul failed\");\n     return r;\n }\n \n@@ -496,7 +496,7 @@ inline const CBigNum operator/(const CBigNum& a, const CBigNum& b)\n     CAutoBN_CTX pctx;\n     CBigNum r;\n     if (!BN_div(&r, NULL, &a, &b, pctx))\n-        throw bignum_error(\"CBigNum::operator/ : BN_div failed\");\n+\tthrow bignum_error(\"CBigNum::operator/ : BN_div failed\");\n     return r;\n }\n \n@@ -505,15 +505,15 @@ inline const CBigNum operator%(const CBigNum& a, const CBigNum& b)\n     CAutoBN_CTX pctx;\n     CBigNum r;\n     if (!BN_mod(&r, &a, &b, pctx))\n-        throw bignum_error(\"CBigNum::operator% : BN_div failed\");\n+\tthrow bignum_error(\"CBigNum::operator% : BN_div failed\");\n     return r;\n }\n \n inline const CBigNum operator<<(const CBigNum& a, unsigned int shift)\n {\n     CBigNum r;\n     if (!BN_lshift(&r, &a, shift))\n-        throw bignum_error(\"CBigNum:operator<< : BN_lshift failed\");\n+\tthrow bignum_error(\"CBigNum:operator<< : BN_lshift failed\");\n     return r;\n }\n "
      },
      {
        "sha": "ca5b38763108d017554ec7e27c26d003a68d0fd4",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 530,
        "deletions": 530,
        "changes": 1060,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -30,11 +30,11 @@ class CDBInit\n     }\n     ~CDBInit()\n     {\n-        if (fDbEnvInit)\n-        {\n-            dbenv.close(0);\n-            fDbEnvInit = false;\n-        }\n+\tif (fDbEnvInit)\n+\t{\n+\t    dbenv.close(0);\n+\t    fDbEnvInit = false;\n+\t}\n     }\n }\n instance_of_cdbinit;\n@@ -44,118 +44,118 @@ CDB::CDB(const char* pszFile, const char* pszMode) : pdb(NULL)\n {\n     int ret;\n     if (pszFile == NULL)\n-        return;\n+\treturn;\n \n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n     bool fCreate = strchr(pszMode, 'c');\n     unsigned int nFlags = DB_THREAD;\n     if (fCreate)\n-        nFlags |= DB_CREATE;\n+\tnFlags |= DB_CREATE;\n \n     CRITICAL_BLOCK(cs_db)\n     {\n-        if (!fDbEnvInit)\n-        {\n-            if (fShutdown)\n-                return;\n-            string strDataDir = GetDataDir();\n-            string strLogDir = strDataDir + \"/database\";\n-            filesystem::create_directory(strLogDir.c_str());\n-            string strErrorFile = strDataDir + \"/db.log\";\n-            printf(\"dbenv.open strLogDir=%s strErrorFile=%s\\n\", strLogDir.c_str(), strErrorFile.c_str());\n-\n-            dbenv.set_lg_dir(strLogDir.c_str());\n-            dbenv.set_lg_max(10000000);\n-            dbenv.set_lk_max_locks(10000);\n-            dbenv.set_lk_max_objects(10000);\n-            dbenv.set_errfile(fopen(strErrorFile.c_str(), \"a\")); /// debug\n-            dbenv.set_flags(DB_AUTO_COMMIT, 1);\n-            ret = dbenv.open(strDataDir.c_str(),\n-                             DB_CREATE     |\n-                             DB_INIT_LOCK  |\n-                             DB_INIT_LOG   |\n-                             DB_INIT_MPOOL |\n-                             DB_INIT_TXN   |\n-                             DB_THREAD     |\n-                             DB_RECOVER,\n-                             S_IRUSR | S_IWUSR);\n-            if (ret > 0)\n-                throw runtime_error(strprintf(\"CDB() : error %d opening database environment\", ret));\n-            fDbEnvInit = true;\n-        }\n-\n-        strFile = pszFile;\n-        ++mapFileUseCount[strFile];\n-        pdb = mapDb[strFile];\n-        if (pdb == NULL)\n-        {\n-            pdb = new Db(&dbenv, 0);\n-\n-            ret = pdb->open(NULL,      // Txn pointer\n-                            pszFile,   // Filename\n-                            \"main\",    // Logical db name\n-                            DB_BTREE,  // Database type\n-                            nFlags,    // Flags\n-                            0);\n-\n-            if (ret > 0)\n-            {\n-                delete pdb;\n-                pdb = NULL;\n-                CRITICAL_BLOCK(cs_db)\n-                    --mapFileUseCount[strFile];\n-                strFile = \"\";\n-                throw runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n-            }\n-\n-            if (fCreate && !Exists(string(\"version\")))\n-            {\n-                bool fTmp = fReadOnly;\n-                fReadOnly = false;\n-                WriteVersion(VERSION);\n-                fReadOnly = fTmp;\n-            }\n-\n-            mapDb[strFile] = pdb;\n-        }\n+\tif (!fDbEnvInit)\n+\t{\n+\t    if (fShutdown)\n+\t\treturn;\n+\t    string strDataDir = GetDataDir();\n+\t    string strLogDir = strDataDir + \"/database\";\n+\t    filesystem::create_directory(strLogDir.c_str());\n+\t    string strErrorFile = strDataDir + \"/db.log\";\n+\t    printf(\"dbenv.open strLogDir=%s strErrorFile=%s\\n\", strLogDir.c_str(), strErrorFile.c_str());\n+\n+\t    dbenv.set_lg_dir(strLogDir.c_str());\n+\t    dbenv.set_lg_max(10000000);\n+\t    dbenv.set_lk_max_locks(10000);\n+\t    dbenv.set_lk_max_objects(10000);\n+\t    dbenv.set_errfile(fopen(strErrorFile.c_str(), \"a\")); /// debug\n+\t    dbenv.set_flags(DB_AUTO_COMMIT, 1);\n+\t    ret = dbenv.open(strDataDir.c_str(),\n+\t\t\t     DB_CREATE     |\n+\t\t\t     DB_INIT_LOCK  |\n+\t\t\t     DB_INIT_LOG   |\n+\t\t\t     DB_INIT_MPOOL |\n+\t\t\t     DB_INIT_TXN   |\n+\t\t\t     DB_THREAD     |\n+\t\t\t     DB_RECOVER,\n+\t\t\t     S_IRUSR | S_IWUSR);\n+\t    if (ret > 0)\n+\t\tthrow runtime_error(strprintf(\"CDB() : error %d opening database environment\", ret));\n+\t    fDbEnvInit = true;\n+\t}\n+\n+\tstrFile = pszFile;\n+\t++mapFileUseCount[strFile];\n+\tpdb = mapDb[strFile];\n+\tif (pdb == NULL)\n+\t{\n+\t    pdb = new Db(&dbenv, 0);\n+\n+\t    ret = pdb->open(NULL,      // Txn pointer\n+\t\t\t    pszFile,   // Filename\n+\t\t\t    \"main\",    // Logical db name\n+\t\t\t    DB_BTREE,  // Database type\n+\t\t\t    nFlags,    // Flags\n+\t\t\t    0);\n+\n+\t    if (ret > 0)\n+\t    {\n+\t\tdelete pdb;\n+\t\tpdb = NULL;\n+\t\tCRITICAL_BLOCK(cs_db)\n+\t\t    --mapFileUseCount[strFile];\n+\t\tstrFile = \"\";\n+\t\tthrow runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n+\t    }\n+\n+\t    if (fCreate && !Exists(string(\"version\")))\n+\t    {\n+\t\tbool fTmp = fReadOnly;\n+\t\tfReadOnly = false;\n+\t\tWriteVersion(VERSION);\n+\t\tfReadOnly = fTmp;\n+\t    }\n+\n+\t    mapDb[strFile] = pdb;\n+\t}\n     }\n }\n \n void CDB::Close()\n {\n     if (!pdb)\n-        return;\n+\treturn;\n     if (!vTxn.empty())\n-        vTxn.front()->abort();\n+\tvTxn.front()->abort();\n     vTxn.clear();\n     pdb = NULL;\n \n     // Flush database activity from memory pool to disk log\n     unsigned int nMinutes = 0;\n     if (fReadOnly)\n-        nMinutes = 1;\n+\tnMinutes = 1;\n     if (strFile == \"addr.dat\")\n-        nMinutes = 2;\n+\tnMinutes = 2;\n     if (strFile == \"blkindex.dat\" && IsInitialBlockDownload() && nBestHeight % 500 != 0)\n-        nMinutes = 1;\n+\tnMinutes = 1;\n     dbenv.txn_checkpoint(0, nMinutes, 0);\n \n     CRITICAL_BLOCK(cs_db)\n-        --mapFileUseCount[strFile];\n+\t--mapFileUseCount[strFile];\n }\n \n void CloseDb(const string& strFile)\n {\n     CRITICAL_BLOCK(cs_db)\n     {\n-        if (mapDb[strFile] != NULL)\n-        {\n-            // Close the database handle\n-            Db* pdb = mapDb[strFile];\n-            pdb->close(0);\n-            delete pdb;\n-            mapDb[strFile] = NULL;\n-        }\n+\tif (mapDb[strFile] != NULL)\n+\t{\n+\t    // Close the database handle\n+\t    Db* pdb = mapDb[strFile];\n+\t    pdb->close(0);\n+\t    delete pdb;\n+\t    mapDb[strFile] = NULL;\n+\t}\n     }\n }\n \n@@ -165,35 +165,35 @@ void DBFlush(bool fShutdown)\n     //  on all files that are not in use\n     printf(\"DBFlush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n     if (!fDbEnvInit)\n-        return;\n+\treturn;\n     CRITICAL_BLOCK(cs_db)\n     {\n-        map<string, int>::iterator mi = mapFileUseCount.begin();\n-        while (mi != mapFileUseCount.end())\n-        {\n-            string strFile = (*mi).first;\n-            int nRefCount = (*mi).second;\n-            printf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n-            if (nRefCount == 0)\n-            {\n-                // Move log data to the dat file\n-                CloseDb(strFile);\n-                dbenv.txn_checkpoint(0, 0, 0);\n-                printf(\"%s flush\\n\", strFile.c_str());\n-                dbenv.lsn_reset(strFile.c_str(), 0);\n-                mapFileUseCount.erase(mi++);\n-            }\n-            else\n-                mi++;\n-        }\n-        if (fShutdown)\n-        {\n-            char** listp;\n-            if (mapFileUseCount.empty())\n-                dbenv.log_archive(&listp, DB_ARCH_REMOVE);\n-            dbenv.close(0);\n-            fDbEnvInit = false;\n-        }\n+\tmap<string, int>::iterator mi = mapFileUseCount.begin();\n+\twhile (mi != mapFileUseCount.end())\n+\t{\n+\t    string strFile = (*mi).first;\n+\t    int nRefCount = (*mi).second;\n+\t    printf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n+\t    if (nRefCount == 0)\n+\t    {\n+\t\t// Move log data to the dat file\n+\t\tCloseDb(strFile);\n+\t\tdbenv.txn_checkpoint(0, 0, 0);\n+\t\tprintf(\"%s flush\\n\", strFile.c_str());\n+\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n+\t\tmapFileUseCount.erase(mi++);\n+\t    }\n+\t    else\n+\t\tmi++;\n+\t}\n+\tif (fShutdown)\n+\t{\n+\t    char** listp;\n+\t    if (mapFileUseCount.empty())\n+\t\tdbenv.log_archive(&listp, DB_ARCH_REMOVE);\n+\t    dbenv.close(0);\n+\t    fDbEnvInit = false;\n+\t}\n     }\n }\n \n@@ -251,46 +251,46 @@ bool CTxDB::ReadOwnerTxes(uint160 hash160, int nMinHeight, vector<CTransaction>&\n     // Get cursor\n     Dbc* pcursor = GetCursor();\n     if (!pcursor)\n-        return false;\n+\treturn false;\n \n     unsigned int fFlags = DB_SET_RANGE;\n     loop\n     {\n-        // Read next record\n-        CDataStream ssKey;\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << string(\"owner\") << hash160 << CDiskTxPos(0, 0, 0);\n-        CDataStream ssValue;\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-        {\n-            pcursor->close();\n-            return false;\n-        }\n-\n-        // Unserialize\n-        string strType;\n-        uint160 hashItem;\n-        CDiskTxPos pos;\n-        ssKey >> strType >> hashItem >> pos;\n-        int nItemHeight;\n-        ssValue >> nItemHeight;\n-\n-        // Read transaction\n-        if (strType != \"owner\" || hashItem != hash160)\n-            break;\n-        if (nItemHeight >= nMinHeight)\n-        {\n-            vtx.resize(vtx.size()+1);\n-            if (!vtx.back().ReadFromDisk(pos))\n-            {\n-                pcursor->close();\n-                return false;\n-            }\n-        }\n+\t// Read next record\n+\tCDataStream ssKey;\n+\tif (fFlags == DB_SET_RANGE)\n+\t    ssKey << string(\"owner\") << hash160 << CDiskTxPos(0, 0, 0);\n+\tCDataStream ssValue;\n+\tint ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+\tfFlags = DB_NEXT;\n+\tif (ret == DB_NOTFOUND)\n+\t    break;\n+\telse if (ret != 0)\n+\t{\n+\t    pcursor->close();\n+\t    return false;\n+\t}\n+\n+\t// Unserialize\n+\tstring strType;\n+\tuint160 hashItem;\n+\tCDiskTxPos pos;\n+\tssKey >> strType >> hashItem >> pos;\n+\tint nItemHeight;\n+\tssValue >> nItemHeight;\n+\n+\t// Read transaction\n+\tif (strType != \"owner\" || hashItem != hash160)\n+\t    break;\n+\tif (nItemHeight >= nMinHeight)\n+\t{\n+\t    vtx.resize(vtx.size()+1);\n+\t    if (!vtx.back().ReadFromDisk(pos))\n+\t    {\n+\t\tpcursor->close();\n+\t\treturn false;\n+\t    }\n+\t}\n     }\n \n     pcursor->close();\n@@ -302,7 +302,7 @@ bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex)\n     assert(!fClient);\n     tx.SetNull();\n     if (!ReadTxIndex(hash, txindex))\n-        return false;\n+\treturn false;\n     return (tx.ReadFromDisk(txindex.pos));\n }\n \n@@ -356,17 +356,17 @@ bool CTxDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n CBlockIndex* InsertBlockIndex(uint256 hash)\n {\n     if (hash == 0)\n-        return NULL;\n+\treturn NULL;\n \n     // Return existing\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n     if (mi != mapBlockIndex.end())\n-        return (*mi).second;\n+\treturn (*mi).second;\n \n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n     if (!pindexNew)\n-        throw runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n+\tthrow runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n     mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n \n@@ -378,56 +378,56 @@ bool CTxDB::LoadBlockIndex()\n     // Get database cursor\n     Dbc* pcursor = GetCursor();\n     if (!pcursor)\n-        return false;\n+\treturn false;\n \n     // Load mapBlockIndex\n     unsigned int fFlags = DB_SET_RANGE;\n     loop\n     {\n-        // Read next record\n-        CDataStream ssKey;\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << make_pair(string(\"blockindex\"), uint256(0));\n-        CDataStream ssValue;\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-            return false;\n-\n-        // Unserialize\n-        string strType;\n-        ssKey >> strType;\n-        if (strType == \"blockindex\")\n-        {\n-            CDiskBlockIndex diskindex;\n-            ssValue >> diskindex;\n-\n-            // Construct block index object\n-            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-            pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-            pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n-            pindexNew->nFile          = diskindex.nFile;\n-            pindexNew->nBlockPos      = diskindex.nBlockPos;\n-            pindexNew->nHeight        = diskindex.nHeight;\n-            pindexNew->nVersion       = diskindex.nVersion;\n-            pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n-            pindexNew->nTime          = diskindex.nTime;\n-            pindexNew->nBits          = diskindex.nBits;\n-            pindexNew->nNonce         = diskindex.nNonce;\n-\n-            // Watch for genesis block\n-            if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n-                pindexGenesisBlock = pindexNew;\n-\n-            if (!pindexNew->CheckIndex())\n-                return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n-        }\n-        else\n-        {\n-            break;\n-        }\n+\t// Read next record\n+\tCDataStream ssKey;\n+\tif (fFlags == DB_SET_RANGE)\n+\t    ssKey << make_pair(string(\"blockindex\"), uint256(0));\n+\tCDataStream ssValue;\n+\tint ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+\tfFlags = DB_NEXT;\n+\tif (ret == DB_NOTFOUND)\n+\t    break;\n+\telse if (ret != 0)\n+\t    return false;\n+\n+\t// Unserialize\n+\tstring strType;\n+\tssKey >> strType;\n+\tif (strType == \"blockindex\")\n+\t{\n+\t    CDiskBlockIndex diskindex;\n+\t    ssValue >> diskindex;\n+\n+\t    // Construct block index object\n+\t    CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n+\t    pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n+\t    pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n+\t    pindexNew->nFile          = diskindex.nFile;\n+\t    pindexNew->nBlockPos      = diskindex.nBlockPos;\n+\t    pindexNew->nHeight        = diskindex.nHeight;\n+\t    pindexNew->nVersion       = diskindex.nVersion;\n+\t    pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n+\t    pindexNew->nTime          = diskindex.nTime;\n+\t    pindexNew->nBits          = diskindex.nBits;\n+\t    pindexNew->nNonce         = diskindex.nNonce;\n+\n+\t    // Watch for genesis block\n+\t    if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n+\t\tpindexGenesisBlock = pindexNew;\n+\n+\t    if (!pindexNew->CheckIndex())\n+\t\treturn error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n+\t}\n+\telse\n+\t{\n+\t    break;\n+\t}\n     }\n     pcursor->close();\n \n@@ -436,25 +436,25 @@ bool CTxDB::LoadBlockIndex()\n     vSortedByHeight.reserve(mapBlockIndex.size());\n     foreach(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n     {\n-        CBlockIndex* pindex = item.second;\n-        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n+\tCBlockIndex* pindex = item.second;\n+\tvSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n     foreach(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n     {\n-        CBlockIndex* pindex = item.second;\n-        pindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n+\tCBlockIndex* pindex = item.second;\n+\tpindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n     }\n \n     // Load hashBestChain pointer to end of best chain\n     if (!ReadHashBestChain(hashBestChain))\n     {\n-        if (pindexGenesisBlock == NULL)\n-            return true;\n-        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n+\tif (pindexGenesisBlock == NULL)\n+\t    return true;\n+\treturn error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n     }\n     if (!mapBlockIndex.count(hashBestChain))\n-        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n+\treturn error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n     pindexBest = mapBlockIndex[hashBestChain];\n     nBestHeight = pindexBest->nHeight;\n     bnBestChainWork = pindexBest->bnChainWork;\n@@ -467,26 +467,26 @@ bool CTxDB::LoadBlockIndex()\n     CBlockIndex* pindexFork = NULL;\n     for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n-        if (pindex->nHeight < nBestHeight-2500 && !mapArgs.count(\"-checkblocks\"))\n-            break;\n-        CBlock block;\n-        if (!block.ReadFromDisk(pindex))\n-            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-        if (!block.CheckBlock())\n-        {\n-            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n-            pindexFork = pindex->pprev;\n-        }\n+\tif (pindex->nHeight < nBestHeight-2500 && !mapArgs.count(\"-checkblocks\"))\n+\t    break;\n+\tCBlock block;\n+\tif (!block.ReadFromDisk(pindex))\n+\t    return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+\tif (!block.CheckBlock())\n+\t{\n+\t    printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+\t    pindexFork = pindex->pprev;\n+\t}\n     }\n     if (pindexFork)\n     {\n-        // Reorg back to the fork\n-        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n-        CBlock block;\n-        if (!block.ReadFromDisk(pindexFork))\n-            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-        CTxDB txdb;\n-        block.SetBestChain(txdb, pindexFork);\n+\t// Reorg back to the fork\n+\tprintf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n+\tCBlock block;\n+\tif (!block.ReadFromDisk(pindexFork))\n+\t    return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+\tCTxDB txdb;\n+\tblock.SetBestChain(txdb, pindexFork);\n     }\n \n     return true;\n@@ -514,53 +514,53 @@ bool CAddrDB::LoadAddresses()\n {\n     CRITICAL_BLOCK(cs_mapAddresses)\n     {\n-        // Load user provided addresses\n-        CAutoFile filein = fopen((GetDataDir() + \"/addr.txt\").c_str(), \"rt\");\n-        if (filein)\n-        {\n-            try\n-            {\n-                char psz[1000];\n-                while (fgets(psz, sizeof(psz), filein))\n-                {\n-                    CAddress addr(psz, NODE_NETWORK);\n-                    addr.nTime = 0; // so it won't relay unless successfully connected\n-                    if (addr.IsValid())\n-                        AddAddress(addr);\n-                }\n-            }\n-            catch (...) { }\n-        }\n-\n-        // Get cursor\n-        Dbc* pcursor = GetCursor();\n-        if (!pcursor)\n-            return false;\n-\n-        loop\n-        {\n-            // Read next record\n-            CDataStream ssKey;\n-            CDataStream ssValue;\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-            if (ret == DB_NOTFOUND)\n-                break;\n-            else if (ret != 0)\n-                return false;\n-\n-            // Unserialize\n-            string strType;\n-            ssKey >> strType;\n-            if (strType == \"addr\")\n-            {\n-                CAddress addr;\n-                ssValue >> addr;\n-                mapAddresses.insert(make_pair(addr.GetKey(), addr));\n-            }\n-        }\n-        pcursor->close();\n-\n-        printf(\"Loaded %d addresses\\n\", mapAddresses.size());\n+\t// Load user provided addresses\n+\tCAutoFile filein = fopen((GetDataDir() + \"/addr.txt\").c_str(), \"rt\");\n+\tif (filein)\n+\t{\n+\t    try\n+\t    {\n+\t\tchar psz[1000];\n+\t\twhile (fgets(psz, sizeof(psz), filein))\n+\t\t{\n+\t\t    CAddress addr(psz, NODE_NETWORK);\n+\t\t    addr.nTime = 0; // so it won't relay unless successfully connected\n+\t\t    if (addr.IsValid())\n+\t\t\tAddAddress(addr);\n+\t\t}\n+\t    }\n+\t    catch (...) { }\n+\t}\n+\n+\t// Get cursor\n+\tDbc* pcursor = GetCursor();\n+\tif (!pcursor)\n+\t    return false;\n+\n+\tloop\n+\t{\n+\t    // Read next record\n+\t    CDataStream ssKey;\n+\t    CDataStream ssValue;\n+\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+\t    if (ret == DB_NOTFOUND)\n+\t\tbreak;\n+\t    else if (ret != 0)\n+\t\treturn false;\n+\n+\t    // Unserialize\n+\t    string strType;\n+\t    ssKey >> strType;\n+\t    if (strType == \"addr\")\n+\t    {\n+\t\tCAddress addr;\n+\t\tssValue >> addr;\n+\t\tmapAddresses.insert(make_pair(addr.GetKey(), addr));\n+\t    }\n+\t}\n+\tpcursor->close();\n+\n+\tprintf(\"Loaded %d addresses\\n\", mapAddresses.size());\n     }\n \n     return true;\n@@ -604,7 +604,7 @@ int64 CWalletDB::GetAccountCreditDebit(const string& strAccount)\n \n     int64 nCreditDebit = 0;\n     foreach (const CAccountingEntry& entry, entries)\n-        nCreditDebit += entry.nCreditDebit;\n+\tnCreditDebit += entry.nCreditDebit;\n \n     return nCreditDebit;\n }\n@@ -617,37 +617,37 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n \n     Dbc* pcursor = GetCursor();\n     if (!pcursor)\n-        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n+\tthrow runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n     unsigned int fFlags = DB_SET_RANGE;\n     loop\n     {\n-        // Read next record\n-        CDataStream ssKey;\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64(0));\n-        CDataStream ssValue;\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-        {\n-            pcursor->close();\n-            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n-        }\n-\n-        // Unserialize\n-        string strType;\n-        ssKey >> strType;\n-        if (strType != \"acentry\")\n-            break;\n-        CAccountingEntry acentry;\n-        ssKey >> acentry.strAccount;\n-        if (!fAllAccounts && acentry.strAccount != strAccount)\n-            break;\n-\n-        ssValue >> acentry;\n-        entries.push_back(acentry);\n+\t// Read next record\n+\tCDataStream ssKey;\n+\tif (fFlags == DB_SET_RANGE)\n+\t    ssKey << make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64(0));\n+\tCDataStream ssValue;\n+\tint ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+\tfFlags = DB_NEXT;\n+\tif (ret == DB_NOTFOUND)\n+\t    break;\n+\telse if (ret != 0)\n+\t{\n+\t    pcursor->close();\n+\t    throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n+\t}\n+\n+\t// Unserialize\n+\tstring strType;\n+\tssKey >> strType;\n+\tif (strType != \"acentry\")\n+\t    break;\n+\tCAccountingEntry acentry;\n+\tssKey >> acentry.strAccount;\n+\tif (!fAllAccounts && acentry.strAccount != strAccount)\n+\t    break;\n+\n+\tssValue >> acentry;\n+\tentries.push_back(acentry);\n     }\n \n     pcursor->close();\n@@ -671,133 +671,133 @@ bool CWalletDB::LoadWallet()\n     CRITICAL_BLOCK(cs_mapWallet)\n     CRITICAL_BLOCK(cs_mapKeys)\n     {\n-        // Get cursor\n-        Dbc* pcursor = GetCursor();\n-        if (!pcursor)\n-            return false;\n-\n-        loop\n-        {\n-            // Read next record\n-            CDataStream ssKey;\n-            CDataStream ssValue;\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-            if (ret == DB_NOTFOUND)\n-                break;\n-            else if (ret != 0)\n-                return false;\n-\n-            // Unserialize\n-            // Taking advantage of the fact that pair serialization\n-            // is just the two items serialized one after the other\n-            string strType;\n-            ssKey >> strType;\n-            if (strType == \"name\")\n-            {\n-                string strAddress;\n-                ssKey >> strAddress;\n-                ssValue >> mapAddressBook[strAddress];\n-            }\n-            else if (strType == \"tx\")\n-            {\n-                uint256 hash;\n-                ssKey >> hash;\n-                CWalletTx& wtx = mapWallet[hash];\n-                ssValue >> wtx;\n-\n-                if (wtx.GetHash() != hash)\n-                    printf(\"Error in wallet.dat, hash mismatch\\n\");\n-\n-                // Undo serialize changes in 31600\n-                if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-                {\n-                    if (!ssValue.empty())\n-                    {\n-                        char fTmp;\n-                        char fUnused;\n-                        ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n-                        printf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\\n\", wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n-                        wtx.fTimeReceivedIsTxTime = fTmp;\n-                    }\n-                    else\n-                    {\n-                        printf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n-                        wtx.fTimeReceivedIsTxTime = 0;\n-                    }\n-                    vWalletUpgrade.push_back(hash);\n-                }\n-\n-                //// debug print\n-                //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n-                //printf(\" %12I64d  %s  %s  %s\\n\",\n-                //    wtx.vout[0].nValue,\n-                //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n-                //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n-                //    wtx.mapValue[\"message\"].c_str());\n-            }\n-            else if (strType == \"acentry\")\n-            {\n-                string strAccount;\n-                ssKey >> strAccount;\n-                uint64 nNumber;\n-                ssKey >> nNumber;\n-                if (nNumber > nAccountingEntryNumber)\n-                    nAccountingEntryNumber = nNumber;\n-            }\n-            else if (strType == \"key\" || strType == \"wkey\")\n-            {\n-                vector<unsigned char> vchPubKey;\n-                ssKey >> vchPubKey;\n-                CWalletKey wkey;\n-                if (strType == \"key\")\n-                    ssValue >> wkey.vchPrivKey;\n-                else\n-                    ssValue >> wkey;\n-\n-                mapKeys[vchPubKey] = wkey.vchPrivKey;\n-                mapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n-            }\n-            else if (strType == \"defaultkey\")\n-            {\n-                ssValue >> vchDefaultKey;\n-            }\n-            else if (strType == \"pool\")\n-            {\n-                int64 nIndex;\n-                ssKey >> nIndex;\n-                setKeyPool.insert(nIndex);\n-            }\n-            else if (strType == \"version\")\n-            {\n-                ssValue >> nFileVersion;\n-                if (nFileVersion == 10300)\n-                    nFileVersion = 300;\n-            }\n-            else if (strType == \"setting\")\n-            {\n-                string strKey;\n-                ssKey >> strKey;\n-\n-                // Options\n+\t// Get cursor\n+\tDbc* pcursor = GetCursor();\n+\tif (!pcursor)\n+\t    return false;\n+\n+\tloop\n+\t{\n+\t    // Read next record\n+\t    CDataStream ssKey;\n+\t    CDataStream ssValue;\n+\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+\t    if (ret == DB_NOTFOUND)\n+\t\tbreak;\n+\t    else if (ret != 0)\n+\t\treturn false;\n+\n+\t    // Unserialize\n+\t    // Taking advantage of the fact that pair serialization\n+\t    // is just the two items serialized one after the other\n+\t    string strType;\n+\t    ssKey >> strType;\n+\t    if (strType == \"name\")\n+\t    {\n+\t\tstring strAddress;\n+\t\tssKey >> strAddress;\n+\t\tssValue >> mapAddressBook[strAddress];\n+\t    }\n+\t    else if (strType == \"tx\")\n+\t    {\n+\t\tuint256 hash;\n+\t\tssKey >> hash;\n+\t\tCWalletTx& wtx = mapWallet[hash];\n+\t\tssValue >> wtx;\n+\n+\t\tif (wtx.GetHash() != hash)\n+\t\t    printf(\"Error in wallet.dat, hash mismatch\\n\");\n+\n+\t\t// Undo serialize changes in 31600\n+\t\tif (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+\t\t{\n+\t\t    if (!ssValue.empty())\n+\t\t    {\n+\t\t\tchar fTmp;\n+\t\t\tchar fUnused;\n+\t\t\tssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n+\t\t\tprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\\n\", wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n+\t\t\twtx.fTimeReceivedIsTxTime = fTmp;\n+\t\t    }\n+\t\t    else\n+\t\t    {\n+\t\t\tprintf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n+\t\t\twtx.fTimeReceivedIsTxTime = 0;\n+\t\t    }\n+\t\t    vWalletUpgrade.push_back(hash);\n+\t\t}\n+\n+\t\t//// debug print\n+\t\t//printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n+\t\t//printf(\" %12I64d  %s  %s  %s\\n\",\n+\t\t//    wtx.vout[0].nValue,\n+\t\t//    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n+\t\t//    wtx.hashBlock.ToString().substr(0,20).c_str(),\n+\t\t//    wtx.mapValue[\"message\"].c_str());\n+\t    }\n+\t    else if (strType == \"acentry\")\n+\t    {\n+\t\tstring strAccount;\n+\t\tssKey >> strAccount;\n+\t\tuint64 nNumber;\n+\t\tssKey >> nNumber;\n+\t\tif (nNumber > nAccountingEntryNumber)\n+\t\t    nAccountingEntryNumber = nNumber;\n+\t    }\n+\t    else if (strType == \"key\" || strType == \"wkey\")\n+\t    {\n+\t\tvector<unsigned char> vchPubKey;\n+\t\tssKey >> vchPubKey;\n+\t\tCWalletKey wkey;\n+\t\tif (strType == \"key\")\n+\t\t    ssValue >> wkey.vchPrivKey;\n+\t\telse\n+\t\t    ssValue >> wkey;\n+\n+\t\tmapKeys[vchPubKey] = wkey.vchPrivKey;\n+\t\tmapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n+\t    }\n+\t    else if (strType == \"defaultkey\")\n+\t    {\n+\t\tssValue >> vchDefaultKey;\n+\t    }\n+\t    else if (strType == \"pool\")\n+\t    {\n+\t\tint64 nIndex;\n+\t\tssKey >> nIndex;\n+\t\tsetKeyPool.insert(nIndex);\n+\t    }\n+\t    else if (strType == \"version\")\n+\t    {\n+\t\tssValue >> nFileVersion;\n+\t\tif (nFileVersion == 10300)\n+\t\t    nFileVersion = 300;\n+\t    }\n+\t    else if (strType == \"setting\")\n+\t    {\n+\t\tstring strKey;\n+\t\tssKey >> strKey;\n+\n+\t\t// Options\n #ifndef GUI\n-                if (strKey == \"fGenerateBitcoins\")  ssValue >> fGenerateBitcoins;\n+\t\tif (strKey == \"fGenerateBitcoins\")  ssValue >> fGenerateBitcoins;\n #endif\n-                if (strKey == \"nTransactionFee\")    ssValue >> nTransactionFee;\n-                if (strKey == \"addrIncoming\")       ssValue >> addrIncoming;\n-                if (strKey == \"fLimitProcessors\")   ssValue >> fLimitProcessors;\n-                if (strKey == \"nLimitProcessors\")   ssValue >> nLimitProcessors;\n-                if (strKey == \"fMinimizeToTray\")    ssValue >> fMinimizeToTray;\n-                if (strKey == \"fMinimizeOnClose\")   ssValue >> fMinimizeOnClose;\n-                if (strKey == \"fUseProxy\")          ssValue >> fUseProxy;\n-                if (strKey == \"addrProxy\")          ssValue >> addrProxy;\n-                if (fHaveUPnP && strKey == \"fUseUPnP\")           ssValue >> fUseUPnP;\n-            }\n-        }\n-        pcursor->close();\n+\t\tif (strKey == \"nTransactionFee\")    ssValue >> nTransactionFee;\n+\t\tif (strKey == \"addrIncoming\")       ssValue >> addrIncoming;\n+\t\tif (strKey == \"fLimitProcessors\")   ssValue >> fLimitProcessors;\n+\t\tif (strKey == \"nLimitProcessors\")   ssValue >> nLimitProcessors;\n+\t\tif (strKey == \"fMinimizeToTray\")    ssValue >> fMinimizeToTray;\n+\t\tif (strKey == \"fMinimizeOnClose\")   ssValue >> fMinimizeOnClose;\n+\t\tif (strKey == \"fUseProxy\")          ssValue >> fUseProxy;\n+\t\tif (strKey == \"addrProxy\")          ssValue >> addrProxy;\n+\t\tif (fHaveUPnP && strKey == \"fUseUPnP\")           ssValue >> fUseUPnP;\n+\t    }\n+\t}\n+\tpcursor->close();\n     }\n \n     foreach(uint256 hash, vWalletUpgrade)\n-        WriteTx(hash, mapWallet[hash]);\n+\tWriteTx(hash, mapWallet[hash]);\n \n     printf(\"nFileVersion = %d\\n\", nFileVersion);\n     printf(\"fGenerateBitcoins = %d\\n\", fGenerateBitcoins);\n@@ -808,17 +808,17 @@ bool CWalletDB::LoadWallet()\n     printf(\"fUseProxy = %d\\n\", fUseProxy);\n     printf(\"addrProxy = %s\\n\", addrProxy.ToString().c_str());\n     if (fHaveUPnP)\n-        printf(\"fUseUPnP = %d\\n\", fUseUPnP);\n+\tprintf(\"fUseUPnP = %d\\n\", fUseUPnP);\n \n \n     // Upgrade\n     if (nFileVersion < VERSION)\n     {\n-        // Get rid of old debug.log file in current directory\n-        if (nFileVersion <= 105 && !pszSetDataDir[0])\n-            unlink(\"debug.log\");\n+\t// Get rid of old debug.log file in current directory\n+\tif (nFileVersion <= 105 && !pszSetDataDir[0])\n+\t    unlink(\"debug.log\");\n \n-        WriteVersion(VERSION);\n+\tWriteVersion(VERSION);\n     }\n \n \n@@ -829,25 +829,25 @@ bool LoadWallet(bool& fFirstRunRet)\n {\n     fFirstRunRet = false;\n     if (!CWalletDB(\"cr+\").LoadWallet())\n-        return false;\n+\treturn false;\n     fFirstRunRet = vchDefaultKey.empty();\n \n     if (mapKeys.count(vchDefaultKey))\n     {\n-        // Set keyUser\n-        keyUser.SetPubKey(vchDefaultKey);\n-        keyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n+\t// Set keyUser\n+\tkeyUser.SetPubKey(vchDefaultKey);\n+\tkeyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n     }\n     else\n     {\n-        // Create new keyUser and set as default key\n-        RandAddSeedPerfmon();\n-        keyUser.MakeNewKey();\n-        if (!AddKey(keyUser))\n-            return false;\n-        if (!SetAddressBookName(PubKeyToAddress(keyUser.GetPubKey()), \"\"))\n-            return false;\n-        CWalletDB().WriteDefaultKey(keyUser.GetPubKey());\n+\t// Create new keyUser and set as default key\n+\tRandAddSeedPerfmon();\n+\tkeyUser.MakeNewKey();\n+\tif (!AddKey(keyUser))\n+\t    return false;\n+\tif (!SetAddressBookName(PubKeyToAddress(keyUser.GetPubKey()), \"\"))\n+\t    return false;\n+\tCWalletDB().WriteDefaultKey(keyUser.GetPubKey());\n     }\n \n     CreateThread(ThreadFlushWalletDB, NULL);\n@@ -858,93 +858,93 @@ void ThreadFlushWalletDB(void* parg)\n {\n     static bool fOneThread;\n     if (fOneThread)\n-        return;\n+\treturn;\n     fOneThread = true;\n     if (mapArgs.count(\"-noflushwallet\"))\n-        return;\n+\treturn;\n \n     unsigned int nLastSeen = nWalletDBUpdated;\n     unsigned int nLastFlushed = nWalletDBUpdated;\n     int64 nLastWalletUpdate = GetTime();\n     while (!fShutdown)\n     {\n-        Sleep(500);\n-\n-        if (nLastSeen != nWalletDBUpdated)\n-        {\n-            nLastSeen = nWalletDBUpdated;\n-            nLastWalletUpdate = GetTime();\n-        }\n-\n-        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n-        {\n-            TRY_CRITICAL_BLOCK(cs_db)\n-            {\n-                // Don't do this if any databases are in use\n-                int nRefCount = 0;\n-                map<string, int>::iterator mi = mapFileUseCount.begin();\n-                while (mi != mapFileUseCount.end())\n-                {\n-                    nRefCount += (*mi).second;\n-                    mi++;\n-                }\n-\n-                if (nRefCount == 0 && !fShutdown)\n-                {\n-                    string strFile = \"wallet.dat\";\n-                    map<string, int>::iterator mi = mapFileUseCount.find(strFile);\n-                    if (mi != mapFileUseCount.end())\n-                    {\n-                        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-                        printf(\"Flushing wallet.dat\\n\");\n-                        nLastFlushed = nWalletDBUpdated;\n-                        int64 nStart = GetTimeMillis();\n-\n-                        // Flush wallet.dat so it's self contained\n-                        CloseDb(strFile);\n-                        dbenv.txn_checkpoint(0, 0, 0);\n-                        dbenv.lsn_reset(strFile.c_str(), 0);\n-\n-                        mapFileUseCount.erase(mi++);\n-                        printf(\"Flushed wallet.dat %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n-                    }\n-                }\n-            }\n-        }\n+\tSleep(500);\n+\n+\tif (nLastSeen != nWalletDBUpdated)\n+\t{\n+\t    nLastSeen = nWalletDBUpdated;\n+\t    nLastWalletUpdate = GetTime();\n+\t}\n+\n+\tif (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n+\t{\n+\t    TRY_CRITICAL_BLOCK(cs_db)\n+\t    {\n+\t\t// Don't do this if any databases are in use\n+\t\tint nRefCount = 0;\n+\t\tmap<string, int>::iterator mi = mapFileUseCount.begin();\n+\t\twhile (mi != mapFileUseCount.end())\n+\t\t{\n+\t\t    nRefCount += (*mi).second;\n+\t\t    mi++;\n+\t\t}\n+\n+\t\tif (nRefCount == 0 && !fShutdown)\n+\t\t{\n+\t\t    string strFile = \"wallet.dat\";\n+\t\t    map<string, int>::iterator mi = mapFileUseCount.find(strFile);\n+\t\t    if (mi != mapFileUseCount.end())\n+\t\t    {\n+\t\t\tprintf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\t\t\tprintf(\"Flushing wallet.dat\\n\");\n+\t\t\tnLastFlushed = nWalletDBUpdated;\n+\t\t\tint64 nStart = GetTimeMillis();\n+\n+\t\t\t// Flush wallet.dat so it's self contained\n+\t\t\tCloseDb(strFile);\n+\t\t\tdbenv.txn_checkpoint(0, 0, 0);\n+\t\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n+\n+\t\t\tmapFileUseCount.erase(mi++);\n+\t\t\tprintf(\"Flushed wallet.dat %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n \n void BackupWallet(const string& strDest)\n {\n     while (!fShutdown)\n     {\n-        CRITICAL_BLOCK(cs_db)\n-        {\n-            const string strFile = \"wallet.dat\";\n-            if (!mapFileUseCount.count(strFile) || mapFileUseCount[strFile] == 0)\n-            {\n-                // Flush log data to the dat file\n-                CloseDb(strFile);\n-                dbenv.txn_checkpoint(0, 0, 0);\n-                dbenv.lsn_reset(strFile.c_str(), 0);\n-                mapFileUseCount.erase(strFile);\n-\n-                // Copy wallet.dat\n-                filesystem::path pathSrc(GetDataDir() + \"/\" + strFile);\n-                filesystem::path pathDest(strDest);\n-                if (filesystem::is_directory(pathDest))\n-                    pathDest = pathDest / strFile;\n+\tCRITICAL_BLOCK(cs_db)\n+\t{\n+\t    const string strFile = \"wallet.dat\";\n+\t    if (!mapFileUseCount.count(strFile) || mapFileUseCount[strFile] == 0)\n+\t    {\n+\t\t// Flush log data to the dat file\n+\t\tCloseDb(strFile);\n+\t\tdbenv.txn_checkpoint(0, 0, 0);\n+\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n+\t\tmapFileUseCount.erase(strFile);\n+\n+\t\t// Copy wallet.dat\n+\t\tfilesystem::path pathSrc(GetDataDir() + \"/\" + strFile);\n+\t\tfilesystem::path pathDest(strDest);\n+\t\tif (filesystem::is_directory(pathDest))\n+\t\t    pathDest = pathDest / strFile;\n #if BOOST_VERSION >= 104000\n-                filesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n+\t\tfilesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n #else\n-                filesystem::copy_file(pathSrc, pathDest);\n+\t\tfilesystem::copy_file(pathSrc, pathDest);\n #endif\n-                printf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n+\t\tprintf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n \n-                return;\n-            }\n-        }\n-        Sleep(100);\n+\t\treturn;\n+\t    }\n+\t}\n+\tSleep(100);\n     }\n }\n \n@@ -957,29 +957,29 @@ void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n     CRITICAL_BLOCK(cs_mapWallet)\n     CRITICAL_BLOCK(cs_setKeyPool)\n     {\n-        // Top up key pool\n-        int64 nTargetSize = max(GetArg(\"-keypool\", 100), (int64)0);\n-        while (setKeyPool.size() < nTargetSize+1)\n-        {\n-            int64 nEnd = 1;\n-            if (!setKeyPool.empty())\n-                nEnd = *(--setKeyPool.end()) + 1;\n-            if (!Write(make_pair(string(\"pool\"), nEnd), CKeyPool(GenerateNewKey())))\n-                throw runtime_error(\"ReserveKeyFromKeyPool() : writing generated key failed\");\n-            setKeyPool.insert(nEnd);\n-            printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n-        }\n-\n-        // Get the oldest key\n-        assert(!setKeyPool.empty());\n-        nIndex = *(setKeyPool.begin());\n-        setKeyPool.erase(setKeyPool.begin());\n-        if (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n-        if (!mapKeys.count(keypool.vchPubKey))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n-        assert(!keypool.vchPubKey.empty());\n-        printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n+\t// Top up key pool\n+\tint64 nTargetSize = max(GetArg(\"-keypool\", 100), (int64)0);\n+\twhile (setKeyPool.size() < nTargetSize+1)\n+\t{\n+\t    int64 nEnd = 1;\n+\t    if (!setKeyPool.empty())\n+\t\tnEnd = *(--setKeyPool.end()) + 1;\n+\t    if (!Write(make_pair(string(\"pool\"), nEnd), CKeyPool(GenerateNewKey())))\n+\t\tthrow runtime_error(\"ReserveKeyFromKeyPool() : writing generated key failed\");\n+\t    setKeyPool.insert(nEnd);\n+\t    printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n+\t}\n+\n+\t// Get the oldest key\n+\tassert(!setKeyPool.empty());\n+\tnIndex = *(setKeyPool.begin());\n+\tsetKeyPool.erase(setKeyPool.begin());\n+\tif (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n+\t    throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n+\tif (!mapKeys.count(keypool.vchPubKey))\n+\t    throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n+\tassert(!keypool.vchPubKey.empty());\n+\tprintf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n     }\n }\n \n@@ -989,7 +989,7 @@ void CWalletDB::KeepKey(int64 nIndex)\n     CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n-        Erase(make_pair(string(\"pool\"), nIndex));\n+\tErase(make_pair(string(\"pool\"), nIndex));\n     }\n     printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n }\n@@ -998,7 +998,7 @@ void CWalletDB::ReturnKey(int64 nIndex)\n {\n     // Return to key pool\n     CRITICAL_BLOCK(cs_setKeyPool)\n-        setKeyPool.insert(nIndex);\n+\tsetKeyPool.insert(nIndex);\n     printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n }\n "
      },
      {
        "sha": "42ebdf54a7f5bccdf5b0c0322e07a248ef0b2ae0",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 196,
        "deletions": 196,
        "changes": 392,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -53,206 +53,206 @@ class CDB\n     template<typename K, typename T>\n     bool Read(const K& key, T& value)\n     {\n-        if (!pdb)\n-            return false;\n+\tif (!pdb)\n+\t    return false;\n \n-        // Key\n-        CDataStream ssKey(SER_DISK);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        Dbt datKey(&ssKey[0], ssKey.size());\n+\t// Key\n+\tCDataStream ssKey(SER_DISK);\n+\tssKey.reserve(1000);\n+\tssKey << key;\n+\tDbt datKey(&ssKey[0], ssKey.size());\n \n-        // Read\n-        Dbt datValue;\n-        datValue.set_flags(DB_DBT_MALLOC);\n-        int ret = pdb->get(GetTxn(), &datKey, &datValue, 0);\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        if (datValue.get_data() == NULL)\n-            return false;\n+\t// Read\n+\tDbt datValue;\n+\tdatValue.set_flags(DB_DBT_MALLOC);\n+\tint ret = pdb->get(GetTxn(), &datKey, &datValue, 0);\n+\tmemset(datKey.get_data(), 0, datKey.get_size());\n+\tif (datValue.get_data() == NULL)\n+\t    return false;\n \n-        // Unserialize value\n-        CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK);\n-        ssValue >> value;\n+\t// Unserialize value\n+\tCDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK);\n+\tssValue >> value;\n \n-        // Clear and free memory\n-        memset(datValue.get_data(), 0, datValue.get_size());\n-        free(datValue.get_data());\n-        return (ret == 0);\n+\t// Clear and free memory\n+\tmemset(datValue.get_data(), 0, datValue.get_size());\n+\tfree(datValue.get_data());\n+\treturn (ret == 0);\n     }\n \n     template<typename K, typename T>\n     bool Write(const K& key, const T& value, bool fOverwrite=true)\n     {\n-        if (!pdb)\n-            return false;\n-        if (fReadOnly)\n-            assert((\"Write called on database in read-only mode\", false));\n+\tif (!pdb)\n+\t    return false;\n+\tif (fReadOnly)\n+\t    assert((\"Write called on database in read-only mode\", false));\n \n-        // Key\n-        CDataStream ssKey(SER_DISK);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        Dbt datKey(&ssKey[0], ssKey.size());\n+\t// Key\n+\tCDataStream ssKey(SER_DISK);\n+\tssKey.reserve(1000);\n+\tssKey << key;\n+\tDbt datKey(&ssKey[0], ssKey.size());\n \n-        // Value\n-        CDataStream ssValue(SER_DISK);\n-        ssValue.reserve(10000);\n-        ssValue << value;\n-        Dbt datValue(&ssValue[0], ssValue.size());\n+\t// Value\n+\tCDataStream ssValue(SER_DISK);\n+\tssValue.reserve(10000);\n+\tssValue << value;\n+\tDbt datValue(&ssValue[0], ssValue.size());\n \n-        // Write\n-        int ret = pdb->put(GetTxn(), &datKey, &datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n+\t// Write\n+\tint ret = pdb->put(GetTxn(), &datKey, &datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n \n-        // Clear memory in case it was a private key\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        memset(datValue.get_data(), 0, datValue.get_size());\n-        return (ret == 0);\n+\t// Clear memory in case it was a private key\n+\tmemset(datKey.get_data(), 0, datKey.get_size());\n+\tmemset(datValue.get_data(), 0, datValue.get_size());\n+\treturn (ret == 0);\n     }\n \n     template<typename K>\n     bool Erase(const K& key)\n     {\n-        if (!pdb)\n-            return false;\n-        if (fReadOnly)\n-            assert((\"Erase called on database in read-only mode\", false));\n+\tif (!pdb)\n+\t    return false;\n+\tif (fReadOnly)\n+\t    assert((\"Erase called on database in read-only mode\", false));\n \n-        // Key\n-        CDataStream ssKey(SER_DISK);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        Dbt datKey(&ssKey[0], ssKey.size());\n+\t// Key\n+\tCDataStream ssKey(SER_DISK);\n+\tssKey.reserve(1000);\n+\tssKey << key;\n+\tDbt datKey(&ssKey[0], ssKey.size());\n \n-        // Erase\n-        int ret = pdb->del(GetTxn(), &datKey, 0);\n+\t// Erase\n+\tint ret = pdb->del(GetTxn(), &datKey, 0);\n \n-        // Clear memory\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        return (ret == 0 || ret == DB_NOTFOUND);\n+\t// Clear memory\n+\tmemset(datKey.get_data(), 0, datKey.get_size());\n+\treturn (ret == 0 || ret == DB_NOTFOUND);\n     }\n \n     template<typename K>\n     bool Exists(const K& key)\n     {\n-        if (!pdb)\n-            return false;\n+\tif (!pdb)\n+\t    return false;\n \n-        // Key\n-        CDataStream ssKey(SER_DISK);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        Dbt datKey(&ssKey[0], ssKey.size());\n+\t// Key\n+\tCDataStream ssKey(SER_DISK);\n+\tssKey.reserve(1000);\n+\tssKey << key;\n+\tDbt datKey(&ssKey[0], ssKey.size());\n \n-        // Exists\n-        int ret = pdb->exists(GetTxn(), &datKey, 0);\n+\t// Exists\n+\tint ret = pdb->exists(GetTxn(), &datKey, 0);\n \n-        // Clear memory\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        return (ret == 0);\n+\t// Clear memory\n+\tmemset(datKey.get_data(), 0, datKey.get_size());\n+\treturn (ret == 0);\n     }\n \n     Dbc* GetCursor()\n     {\n-        if (!pdb)\n-            return NULL;\n-        Dbc* pcursor = NULL;\n-        int ret = pdb->cursor(NULL, &pcursor, 0);\n-        if (ret != 0)\n-            return NULL;\n-        return pcursor;\n+\tif (!pdb)\n+\t    return NULL;\n+\tDbc* pcursor = NULL;\n+\tint ret = pdb->cursor(NULL, &pcursor, 0);\n+\tif (ret != 0)\n+\t    return NULL;\n+\treturn pcursor;\n     }\n \n     int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags=DB_NEXT)\n     {\n-        // Read at cursor\n-        Dbt datKey;\n-        if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n-        {\n-            datKey.set_data(&ssKey[0]);\n-            datKey.set_size(ssKey.size());\n-        }\n-        Dbt datValue;\n-        if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n-        {\n-            datValue.set_data(&ssValue[0]);\n-            datValue.set_size(ssValue.size());\n-        }\n-        datKey.set_flags(DB_DBT_MALLOC);\n-        datValue.set_flags(DB_DBT_MALLOC);\n-        int ret = pcursor->get(&datKey, &datValue, fFlags);\n-        if (ret != 0)\n-            return ret;\n-        else if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n-            return 99999;\n-\n-        // Convert to streams\n-        ssKey.SetType(SER_DISK);\n-        ssKey.clear();\n-        ssKey.write((char*)datKey.get_data(), datKey.get_size());\n-        ssValue.SetType(SER_DISK);\n-        ssValue.clear();\n-        ssValue.write((char*)datValue.get_data(), datValue.get_size());\n-\n-        // Clear and free memory\n-        memset(datKey.get_data(), 0, datKey.get_size());\n-        memset(datValue.get_data(), 0, datValue.get_size());\n-        free(datKey.get_data());\n-        free(datValue.get_data());\n-        return 0;\n+\t// Read at cursor\n+\tDbt datKey;\n+\tif (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n+\t{\n+\t    datKey.set_data(&ssKey[0]);\n+\t    datKey.set_size(ssKey.size());\n+\t}\n+\tDbt datValue;\n+\tif (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n+\t{\n+\t    datValue.set_data(&ssValue[0]);\n+\t    datValue.set_size(ssValue.size());\n+\t}\n+\tdatKey.set_flags(DB_DBT_MALLOC);\n+\tdatValue.set_flags(DB_DBT_MALLOC);\n+\tint ret = pcursor->get(&datKey, &datValue, fFlags);\n+\tif (ret != 0)\n+\t    return ret;\n+\telse if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n+\t    return 99999;\n+\n+\t// Convert to streams\n+\tssKey.SetType(SER_DISK);\n+\tssKey.clear();\n+\tssKey.write((char*)datKey.get_data(), datKey.get_size());\n+\tssValue.SetType(SER_DISK);\n+\tssValue.clear();\n+\tssValue.write((char*)datValue.get_data(), datValue.get_size());\n+\n+\t// Clear and free memory\n+\tmemset(datKey.get_data(), 0, datKey.get_size());\n+\tmemset(datValue.get_data(), 0, datValue.get_size());\n+\tfree(datKey.get_data());\n+\tfree(datValue.get_data());\n+\treturn 0;\n     }\n \n     DbTxn* GetTxn()\n     {\n-        if (!vTxn.empty())\n-            return vTxn.back();\n-        else\n-            return NULL;\n+\tif (!vTxn.empty())\n+\t    return vTxn.back();\n+\telse\n+\t    return NULL;\n     }\n \n public:\n     bool TxnBegin()\n     {\n-        if (!pdb)\n-            return false;\n-        DbTxn* ptxn = NULL;\n-        int ret = dbenv.txn_begin(GetTxn(), &ptxn, DB_TXN_NOSYNC);\n-        if (!ptxn || ret != 0)\n-            return false;\n-        vTxn.push_back(ptxn);\n-        return true;\n+\tif (!pdb)\n+\t    return false;\n+\tDbTxn* ptxn = NULL;\n+\tint ret = dbenv.txn_begin(GetTxn(), &ptxn, DB_TXN_NOSYNC);\n+\tif (!ptxn || ret != 0)\n+\t    return false;\n+\tvTxn.push_back(ptxn);\n+\treturn true;\n     }\n \n     bool TxnCommit()\n     {\n-        if (!pdb)\n-            return false;\n-        if (vTxn.empty())\n-            return false;\n-        int ret = vTxn.back()->commit(0);\n-        vTxn.pop_back();\n-        return (ret == 0);\n+\tif (!pdb)\n+\t    return false;\n+\tif (vTxn.empty())\n+\t    return false;\n+\tint ret = vTxn.back()->commit(0);\n+\tvTxn.pop_back();\n+\treturn (ret == 0);\n     }\n \n     bool TxnAbort()\n     {\n-        if (!pdb)\n-            return false;\n-        if (vTxn.empty())\n-            return false;\n-        int ret = vTxn.back()->abort();\n-        vTxn.pop_back();\n-        return (ret == 0);\n+\tif (!pdb)\n+\t    return false;\n+\tif (vTxn.empty())\n+\t    return false;\n+\tint ret = vTxn.back()->abort();\n+\tvTxn.pop_back();\n+\treturn (ret == 0);\n     }\n \n     bool ReadVersion(int& nVersion)\n     {\n-        nVersion = 0;\n-        return Read(string(\"version\"), nVersion);\n+\tnVersion = 0;\n+\treturn Read(string(\"version\"), nVersion);\n     }\n \n     bool WriteVersion(int nVersion)\n     {\n-        return Write(string(\"version\"), nVersion);\n+\treturn Write(string(\"version\"), nVersion);\n     }\n };\n \n@@ -322,21 +322,21 @@ class CKeyPool\n \n     CKeyPool()\n     {\n-        nTime = GetTime();\n+\tnTime = GetTime();\n     }\n \n     CKeyPool(const vector<unsigned char>& vchPubKeyIn)\n     {\n-        nTime = GetTime();\n-        vchPubKey = vchPubKeyIn;\n+\tnTime = GetTime();\n+\tvchPubKey = vchPubKeyIn;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(nTime);\n-        READWRITE(vchPubKey);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\tREADWRITE(nTime);\n+\tREADWRITE(vchPubKey);\n     )\n };\n \n@@ -355,92 +355,92 @@ class CWalletDB : public CDB\n public:\n     bool ReadName(const string& strAddress, string& strName)\n     {\n-        strName = \"\";\n-        return Read(make_pair(string(\"name\"), strAddress), strName);\n+\tstrName = \"\";\n+\treturn Read(make_pair(string(\"name\"), strAddress), strName);\n     }\n \n     bool WriteName(const string& strAddress, const string& strName)\n     {\n-        CRITICAL_BLOCK(cs_mapAddressBook)\n-            mapAddressBook[strAddress] = strName;\n-        nWalletDBUpdated++;\n-        return Write(make_pair(string(\"name\"), strAddress), strName);\n+\tCRITICAL_BLOCK(cs_mapAddressBook)\n+\t    mapAddressBook[strAddress] = strName;\n+\tnWalletDBUpdated++;\n+\treturn Write(make_pair(string(\"name\"), strAddress), strName);\n     }\n \n     bool EraseName(const string& strAddress)\n     {\n-        // This should only be used for sending addresses, never for receiving addresses,\n-        // receiving addresses must always have an address book entry if they're not change return.\n-        CRITICAL_BLOCK(cs_mapAddressBook)\n-            mapAddressBook.erase(strAddress);\n-        nWalletDBUpdated++;\n-        return Erase(make_pair(string(\"name\"), strAddress));\n+\t// This should only be used for sending addresses, never for receiving addresses,\n+\t// receiving addresses must always have an address book entry if they're not change return.\n+\tCRITICAL_BLOCK(cs_mapAddressBook)\n+\t    mapAddressBook.erase(strAddress);\n+\tnWalletDBUpdated++;\n+\treturn Erase(make_pair(string(\"name\"), strAddress));\n     }\n \n     bool ReadTx(uint256 hash, CWalletTx& wtx)\n     {\n-        return Read(make_pair(string(\"tx\"), hash), wtx);\n+\treturn Read(make_pair(string(\"tx\"), hash), wtx);\n     }\n \n     bool WriteTx(uint256 hash, const CWalletTx& wtx)\n     {\n-        nWalletDBUpdated++;\n-        return Write(make_pair(string(\"tx\"), hash), wtx);\n+\tnWalletDBUpdated++;\n+\treturn Write(make_pair(string(\"tx\"), hash), wtx);\n     }\n \n     bool EraseTx(uint256 hash)\n     {\n-        nWalletDBUpdated++;\n-        return Erase(make_pair(string(\"tx\"), hash));\n+\tnWalletDBUpdated++;\n+\treturn Erase(make_pair(string(\"tx\"), hash));\n     }\n \n     bool ReadKey(const vector<unsigned char>& vchPubKey, CPrivKey& vchPrivKey)\n     {\n-        vchPrivKey.clear();\n-        return Read(make_pair(string(\"key\"), vchPubKey), vchPrivKey);\n+\tvchPrivKey.clear();\n+\treturn Read(make_pair(string(\"key\"), vchPubKey), vchPrivKey);\n     }\n \n     bool WriteKey(const vector<unsigned char>& vchPubKey, const CPrivKey& vchPrivKey)\n     {\n-        nWalletDBUpdated++;\n-        return Write(make_pair(string(\"key\"), vchPubKey), vchPrivKey, false);\n+\tnWalletDBUpdated++;\n+\treturn Write(make_pair(string(\"key\"), vchPubKey), vchPrivKey, false);\n     }\n \n     bool WriteBestBlock(const CBlockLocator& locator)\n     {\n-        nWalletDBUpdated++;\n-        return Write(string(\"bestblock\"), locator);\n+\tnWalletDBUpdated++;\n+\treturn Write(string(\"bestblock\"), locator);\n     }\n \n     bool ReadBestBlock(CBlockLocator& locator)\n     {\n-        return Read(string(\"bestblock\"), locator);\n+\treturn Read(string(\"bestblock\"), locator);\n     }\n \n     bool ReadDefaultKey(vector<unsigned char>& vchPubKey)\n     {\n-        vchPubKey.clear();\n-        return Read(string(\"defaultkey\"), vchPubKey);\n+\tvchPubKey.clear();\n+\treturn Read(string(\"defaultkey\"), vchPubKey);\n     }\n \n     bool WriteDefaultKey(const vector<unsigned char>& vchPubKey)\n     {\n-        vchDefaultKey = vchPubKey;\n-        nWalletDBUpdated++;\n-        return Write(string(\"defaultkey\"), vchPubKey);\n+\tvchDefaultKey = vchPubKey;\n+\tnWalletDBUpdated++;\n+\treturn Write(string(\"defaultkey\"), vchPubKey);\n     }\n \n     template<typename T>\n     bool ReadSetting(const string& strKey, T& value)\n     {\n-        return Read(make_pair(string(\"setting\"), strKey), value);\n+\treturn Read(make_pair(string(\"setting\"), strKey), value);\n     }\n \n     template<typename T>\n     bool WriteSetting(const string& strKey, const T& value)\n     {\n-        nWalletDBUpdated++;\n-        return Write(make_pair(string(\"setting\"), strKey), value);\n+\tnWalletDBUpdated++;\n+\treturn Write(make_pair(string(\"setting\"), strKey), value);\n     }\n \n     bool ReadAccount(const string& strAccount, CAccount& account);\n@@ -475,40 +475,40 @@ class CReserveKey\n public:\n     CReserveKey()\n     {\n-        nIndex = -1;\n+\tnIndex = -1;\n     }\n \n     ~CReserveKey()\n     {\n-        if (!fShutdown)\n-            ReturnKey();\n+\tif (!fShutdown)\n+\t    ReturnKey();\n     }\n \n     vector<unsigned char> GetReservedKey()\n     {\n-        if (nIndex == -1)\n-        {\n-            CKeyPool keypool;\n-            CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n-            vchPubKey = keypool.vchPubKey;\n-        }\n-        assert(!vchPubKey.empty());\n-        return vchPubKey;\n+\tif (nIndex == -1)\n+\t{\n+\t    CKeyPool keypool;\n+\t    CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n+\t    vchPubKey = keypool.vchPubKey;\n+\t}\n+\tassert(!vchPubKey.empty());\n+\treturn vchPubKey;\n     }\n \n     void KeepKey()\n     {\n-        if (nIndex != -1)\n-            CWalletDB().KeepKey(nIndex);\n-        nIndex = -1;\n-        vchPubKey.clear();\n+\tif (nIndex != -1)\n+\t    CWalletDB().KeepKey(nIndex);\n+\tnIndex = -1;\n+\tvchPubKey.clear();\n     }\n \n     void ReturnKey()\n     {\n-        if (nIndex != -1)\n-            CWalletDB::ReturnKey(nIndex);\n-        nIndex = -1;\n-        vchPubKey.clear();\n+\tif (nIndex != -1)\n+\t    CWalletDB::ReturnKey(nIndex);\n+\tnIndex = -1;\n+\tvchPubKey.clear();\n     }\n };"
      },
      {
        "sha": "d459edb79928fb1000af2a753a36b7d1b4c655ee",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 204,
        "deletions": 204,
        "changes": 408,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -30,30 +30,30 @@ void Shutdown(void* parg)\n     bool fFirstThread;\n     CRITICAL_BLOCK(cs_Shutdown)\n     {\n-        fFirstThread = !fTaken;\n-        fTaken = true;\n+\tfFirstThread = !fTaken;\n+\tfTaken = true;\n     }\n     static bool fExit;\n     if (fFirstThread)\n     {\n-        fShutdown = true;\n-        nTransactionsUpdated++;\n-        DBFlush(false);\n-        StopNode();\n-        DBFlush(true);\n-        boost::filesystem::remove(GetPidFile());\n-        CreateThread(ExitTimeout, NULL);\n-        Sleep(50);\n-        printf(\"Bitcoin exiting\\n\\n\");\n-        fExit = true;\n-        exit(0);\n+\tfShutdown = true;\n+\tnTransactionsUpdated++;\n+\tDBFlush(false);\n+\tStopNode();\n+\tDBFlush(true);\n+\tboost::filesystem::remove(GetPidFile());\n+\tCreateThread(ExitTimeout, NULL);\n+\tSleep(50);\n+\tprintf(\"Bitcoin exiting\\n\\n\");\n+\tfExit = true;\n+\texit(0);\n     }\n     else\n     {\n-        while (!fExit)\n-            Sleep(500);\n-        Sleep(100);\n-        ExitThread(0);\n+\twhile (!fExit)\n+\t    Sleep(500);\n+\tSleep(100);\n+\tExitThread(0);\n     }\n }\n \n@@ -79,7 +79,7 @@ int main(int argc, char* argv[])\n     fRet = AppInit(argc, argv);\n \n     if (fRet && fDaemon)\n-        return 0;\n+\treturn 0;\n \n     return 1;\n }\n@@ -90,15 +90,15 @@ bool AppInit(int argc, char* argv[])\n     bool fRet = false;\n     try\n     {\n-        fRet = AppInit2(argc, argv);\n+\tfRet = AppInit2(argc, argv);\n     }\n     catch (std::exception& e) {\n-        PrintException(&e, \"AppInit()\");\n+\tPrintException(&e, \"AppInit()\");\n     } catch (...) {\n-        PrintException(NULL, \"AppInit()\");\n+\tPrintException(NULL, \"AppInit()\");\n     }\n     if (!fRet)\n-        Shutdown(NULL);\n+\tShutdown(NULL);\n     return fRet;\n }\n \n@@ -134,78 +134,78 @@ bool AppInit2(int argc, char* argv[])\n \n     if (mapArgs.count(\"-datadir\"))\n     {\n-        filesystem::path pathDataDir = filesystem::system_complete(mapArgs[\"-datadir\"]);\n-        strlcpy(pszSetDataDir, pathDataDir.string().c_str(), sizeof(pszSetDataDir));\n+\tfilesystem::path pathDataDir = filesystem::system_complete(mapArgs[\"-datadir\"]);\n+\tstrlcpy(pszSetDataDir, pathDataDir.string().c_str(), sizeof(pszSetDataDir));\n     }\n \n     ReadConfigFile(mapArgs, mapMultiArgs); // Must be done after processing datadir\n \n     if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n     {\n-        string beta = VERSION_IS_BETA ? _(\" beta\") : \"\";\n-        string strUsage = string() +\n-          _(\"Bitcoin version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n-          _(\"Usage:\") + \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\" +\n-            \"  bitcoin [options]                   \\t  \" + \"\\n\" +\n-            \"  bitcoin [options] <command> [params]\\t  \" + _(\"Send command to -server or bitcoind\\n\") +\n-            \"  bitcoin [options] help              \\t\\t  \" + _(\"List commands\\n\") +\n-            \"  bitcoin [options] help <command>    \\t\\t  \" + _(\"Get help for a command\\n\") +\n-          _(\"Options:\\n\") +\n-            \"  -conf=<file>     \\t\\t  \" + _(\"Specify configuration file (default: bitcoin.conf)\\n\") +\n-            \"  -pid=<file>      \\t\\t  \" + _(\"Specify pid file (default: bitcoind.pid)\\n\") +\n-            \"  -gen             \\t\\t  \" + _(\"Generate coins\\n\") +\n-            \"  -gen=0           \\t\\t  \" + _(\"Don't generate coins\\n\") +\n-            \"  -min             \\t\\t  \" + _(\"Start minimized\\n\") +\n-            \"  -datadir=<dir>   \\t\\t  \" + _(\"Specify data directory\\n\") +\n-            \"  -proxy=<ip:port> \\t  \"   + _(\"Connect through socks4 proxy\\n\") +\n-            \"  -dns             \\t  \"   + _(\"Allow DNS lookups for addnode and connect\\n\") +\n-            \"  -addnode=<ip>    \\t  \"   + _(\"Add a node to connect to\\n\") +\n-            \"  -connect=<ip>    \\t\\t  \" + _(\"Connect only to the specified node\\n\") +\n-            \"  -nolisten        \\t  \"   + _(\"Don't accept connections from outside\\n\") +\n+\tstring beta = VERSION_IS_BETA ? _(\" beta\") : \"\";\n+\tstring strUsage = string() +\n+\t  _(\"Bitcoin version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n+\t  _(\"Usage:\") + \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\" +\n+\t    \"  bitcoin [options]                   \\t  \" + \"\\n\" +\n+\t    \"  bitcoin [options] <command> [params]\\t  \" + _(\"Send command to -server or bitcoind\\n\") +\n+\t    \"  bitcoin [options] help              \\t\\t  \" + _(\"List commands\\n\") +\n+\t    \"  bitcoin [options] help <command>    \\t\\t  \" + _(\"Get help for a command\\n\") +\n+\t  _(\"Options:\\n\") +\n+\t    \"  -conf=<file>     \\t\\t  \" + _(\"Specify configuration file (default: bitcoin.conf)\\n\") +\n+\t    \"  -pid=<file>      \\t\\t  \" + _(\"Specify pid file (default: bitcoind.pid)\\n\") +\n+\t    \"  -gen             \\t\\t  \" + _(\"Generate coins\\n\") +\n+\t    \"  -gen=0           \\t\\t  \" + _(\"Don't generate coins\\n\") +\n+\t    \"  -min             \\t\\t  \" + _(\"Start minimized\\n\") +\n+\t    \"  -datadir=<dir>   \\t\\t  \" + _(\"Specify data directory\\n\") +\n+\t    \"  -proxy=<ip:port> \\t  \"   + _(\"Connect through socks4 proxy\\n\") +\n+\t    \"  -dns             \\t  \"   + _(\"Allow DNS lookups for addnode and connect\\n\") +\n+\t    \"  -addnode=<ip>    \\t  \"   + _(\"Add a node to connect to\\n\") +\n+\t    \"  -connect=<ip>    \\t\\t  \" + _(\"Connect only to the specified node\\n\") +\n+\t    \"  -nolisten        \\t  \"   + _(\"Don't accept connections from outside\\n\") +\n #ifdef USE_UPNP\n #if USE_UPNP\n-            \"  -noupnp          \\t  \"   + _(\"Don't attempt to use UPnP to map the listening port\\n\") +\n+\t    \"  -noupnp          \\t  \"   + _(\"Don't attempt to use UPnP to map the listening port\\n\") +\n #else\n-            \"  -upnp            \\t  \"   + _(\"Attempt to use UPnP to map the listening port\\n\") +\n+\t    \"  -upnp            \\t  \"   + _(\"Attempt to use UPnP to map the listening port\\n\") +\n #endif\n #endif\n-            \"  -paytxfee=<amt>  \\t  \"   + _(\"Fee per KB to add to transactions you send\\n\") +\n+\t    \"  -paytxfee=<amt>  \\t  \"   + _(\"Fee per KB to add to transactions you send\\n\") +\n #ifdef GUI\n-            \"  -server          \\t\\t  \" + _(\"Accept command line and JSON-RPC commands\\n\") +\n+\t    \"  -server          \\t\\t  \" + _(\"Accept command line and JSON-RPC commands\\n\") +\n #endif\n #ifndef __WXMSW__\n-            \"  -daemon          \\t\\t  \" + _(\"Run in the background as a daemon and accept commands\\n\") +\n+\t    \"  -daemon          \\t\\t  \" + _(\"Run in the background as a daemon and accept commands\\n\") +\n #endif\n-            \"  -testnet         \\t\\t  \" + _(\"Use the test network\\n\") +\n-            \"  -rpcuser=<user>  \\t  \"   + _(\"Username for JSON-RPC connections\\n\") +\n-            \"  -rpcpassword=<pw>\\t  \"   + _(\"Password for JSON-RPC connections\\n\") +\n-            \"  -rpcport=<port>  \\t\\t  \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332)\\n\") +\n-            \"  -rpcallowip=<ip> \\t\\t  \" + _(\"Allow JSON-RPC connections from specified IP address\\n\") +\n-            \"  -rpcconnect=<ip> \\t  \"   + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\\n\") +\n-            \"  -keypool=<n>     \\t  \"   + _(\"Set key pool size to <n> (default: 100)\\n\") +\n-            \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\");\n+\t    \"  -testnet         \\t\\t  \" + _(\"Use the test network\\n\") +\n+\t    \"  -rpcuser=<user>  \\t  \"   + _(\"Username for JSON-RPC connections\\n\") +\n+\t    \"  -rpcpassword=<pw>\\t  \"   + _(\"Password for JSON-RPC connections\\n\") +\n+\t    \"  -rpcport=<port>  \\t\\t  \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332)\\n\") +\n+\t    \"  -rpcallowip=<ip> \\t\\t  \" + _(\"Allow JSON-RPC connections from specified IP address\\n\") +\n+\t    \"  -rpcconnect=<ip> \\t  \"   + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\\n\") +\n+\t    \"  -keypool=<n>     \\t  \"   + _(\"Set key pool size to <n> (default: 100)\\n\") +\n+\t    \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\");\n \n #ifdef USE_SSL\n-        strUsage += string() +\n-            _(\"\\nSSL options: (see the Bitcoin Wiki for SSL setup instructions)\\n\") +\n-            \"  -rpcssl                                \\t  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\\n\") +\n-            \"  -rpcsslcertificatechainfile=<file.cert>\\t  \" + _(\"Server certificate file (default: server.cert)\\n\") +\n-            \"  -rpcsslprivatekeyfile=<file.pem>       \\t  \" + _(\"Server private key (default: server.pem)\\n\") +\n-            \"  -rpcsslciphers=<ciphers>               \\t  \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\\n\");\n+\tstrUsage += string() +\n+\t    _(\"\\nSSL options: (see the Bitcoin Wiki for SSL setup instructions)\\n\") +\n+\t    \"  -rpcssl                                \\t  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\\n\") +\n+\t    \"  -rpcsslcertificatechainfile=<file.cert>\\t  \" + _(\"Server certificate file (default: server.cert)\\n\") +\n+\t    \"  -rpcsslprivatekeyfile=<file.pem>       \\t  \" + _(\"Server private key (default: server.pem)\\n\") +\n+\t    \"  -rpcsslciphers=<ciphers>               \\t  \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\\n\");\n #endif\n \n-        strUsage += string() +\n-            \"  -?               \\t\\t  \" + _(\"This help message\\n\");\n+\tstrUsage += string() +\n+\t    \"  -?               \\t\\t  \" + _(\"This help message\\n\");\n \n #if defined(__WXMSW__) && defined(GUI)\n-        // Tabs make the columns line up in the message box\n-        wxMessageBox(strUsage, \"Bitcoin\", wxOK);\n+\t// Tabs make the columns line up in the message box\n+\twxMessageBox(strUsage, \"Bitcoin\", wxOK);\n #else\n-        // Remove tabs\n-        strUsage.erase(std::remove(strUsage.begin(), strUsage.end(), '\\t'), strUsage.end());\n-        fprintf(stderr, \"%s\", strUsage.c_str());\n+\t// Remove tabs\n+\tstrUsage.erase(std::remove(strUsage.begin(), strUsage.end(), '\\t'), strUsage.end());\n+\tfprintf(stderr, \"%s\", strUsage.c_str());\n #endif\n-        return false;\n+\treturn false;\n     }\n \n     fDebug = GetBoolArg(\"-debug\");\n@@ -218,9 +218,9 @@ bool AppInit2(int argc, char* argv[])\n #endif\n \n     if (fDaemon)\n-        fServer = true;\n+\tfServer = true;\n     else\n-        fServer = GetBoolArg(\"-server\");\n+\tfServer = GetBoolArg(\"-server\");\n \n     /* force fServer when running without GUI */\n #ifndef GUI\n@@ -235,39 +235,39 @@ bool AppInit2(int argc, char* argv[])\n     fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n \n     for (int i = 1; i < argc; i++)\n-        if (!IsSwitchChar(argv[i][0]))\n-            fCommandLine = true;\n+\tif (!IsSwitchChar(argv[i][0]))\n+\t    fCommandLine = true;\n \n     if (fCommandLine)\n     {\n-        int ret = CommandLineRPC(argc, argv);\n-        exit(ret);\n+\tint ret = CommandLineRPC(argc, argv);\n+\texit(ret);\n     }\n \n #ifndef __WXMSW__\n     if (fDaemon)\n     {\n-        // Daemonize\n-        pid_t pid = fork();\n-        if (pid < 0)\n-        {\n-            fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n-            return false;\n-        }\n-        if (pid > 0)\n-        {\n-            CreatePidFile(GetPidFile(), pid);\n-            return true;\n-        }\n-\n-        pid_t sid = setsid();\n-        if (sid < 0)\n-            fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n+\t// Daemonize\n+\tpid_t pid = fork();\n+\tif (pid < 0)\n+\t{\n+\t    fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n+\t    return false;\n+\t}\n+\tif (pid > 0)\n+\t{\n+\t    CreatePidFile(GetPidFile(), pid);\n+\t    return true;\n+\t}\n+\n+\tpid_t sid = setsid();\n+\tif (sid < 0)\n+\t    fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n     }\n #endif\n \n     if (!fDebug && !pszSetDataDir[0])\n-        ShrinkDebugFile();\n+\tShrinkDebugFile();\n     printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n     printf(\"Bitcoin version %s\\n\", FormatFullVersion().c_str());\n #ifdef GUI\n@@ -279,10 +279,10 @@ bool AppInit2(int argc, char* argv[])\n \n     if (GetBoolArg(\"-loadblockindextest\"))\n     {\n-        CTxDB txdb(\"r\");\n-        txdb.LoadBlockIndex();\n-        PrintBlockTree();\n-        return false;\n+\tCTxDB txdb(\"r\");\n+\ttxdb.LoadBlockIndex();\n+\tPrintBlockTree();\n+\treturn false;\n     }\n \n     //\n@@ -293,35 +293,35 @@ bool AppInit2(int argc, char* argv[])\n     // wxSingleInstanceChecker doesn't work on Linux\n     wxString strMutexName = wxString(\"bitcoin_running.\") + getenv(\"HOMEPATH\");\n     for (int i = 0; i < strMutexName.size(); i++)\n-        if (!isalnum(strMutexName[i]))\n-            strMutexName[i] = '.';\n+\tif (!isalnum(strMutexName[i]))\n+\t    strMutexName[i] = '.';\n     wxSingleInstanceChecker* psingleinstancechecker = new wxSingleInstanceChecker(strMutexName);\n     if (psingleinstancechecker->IsAnotherRunning())\n     {\n-        printf(\"Existing instance found\\n\");\n-        unsigned int nStart = GetTime();\n-        loop\n-        {\n-            // Show the previous instance and exit\n-            HWND hwndPrev = FindWindowA(\"wxWindowClassNR\", \"Bitcoin\");\n-            if (hwndPrev)\n-            {\n-                if (IsIconic(hwndPrev))\n-                    ShowWindow(hwndPrev, SW_RESTORE);\n-                SetForegroundWindow(hwndPrev);\n-                return false;\n-            }\n-\n-            if (GetTime() > nStart + 60)\n-                return false;\n-\n-            // Resume this instance if the other exits\n-            delete psingleinstancechecker;\n-            Sleep(1000);\n-            psingleinstancechecker = new wxSingleInstanceChecker(strMutexName);\n-            if (!psingleinstancechecker->IsAnotherRunning())\n-                break;\n-        }\n+\tprintf(\"Existing instance found\\n\");\n+\tunsigned int nStart = GetTime();\n+\tloop\n+\t{\n+\t    // Show the previous instance and exit\n+\t    HWND hwndPrev = FindWindowA(\"wxWindowClassNR\", \"Bitcoin\");\n+\t    if (hwndPrev)\n+\t    {\n+\t\tif (IsIconic(hwndPrev))\n+\t\t    ShowWindow(hwndPrev, SW_RESTORE);\n+\t\tSetForegroundWindow(hwndPrev);\n+\t\treturn false;\n+\t    }\n+\n+\t    if (GetTime() > nStart + 60)\n+\t\treturn false;\n+\n+\t    // Resume this instance if the other exits\n+\t    delete psingleinstancechecker;\n+\t    Sleep(1000);\n+\t    psingleinstancechecker = new wxSingleInstanceChecker(strMutexName);\n+\t    if (!psingleinstancechecker->IsAnotherRunning())\n+\t\tbreak;\n+\t}\n     }\n #endif\n \n@@ -332,80 +332,80 @@ bool AppInit2(int argc, char* argv[])\n     static boost::interprocess::file_lock lock(strLockFile.c_str());\n     if (!lock.try_lock())\n     {\n-        wxMessageBox(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().c_str()), \"Bitcoin\");\n-        return false;\n+\twxMessageBox(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().c_str()), \"Bitcoin\");\n+\treturn false;\n     }\n \n     // Bind to the port early so we can tell if another instance is already running.\n     string strErrors;\n     if (!fNoListen)\n     {\n-        if (!BindListenPort(strErrors))\n-        {\n-            wxMessageBox(strErrors, \"Bitcoin\");\n-            return false;\n-        }\n+\tif (!BindListenPort(strErrors))\n+\t{\n+\t    wxMessageBox(strErrors, \"Bitcoin\");\n+\t    return false;\n+\t}\n     }\n \n     //\n     // Load data files\n     //\n     if (fDaemon)\n-        fprintf(stdout, \"bitcoin server starting\\n\");\n+\tfprintf(stdout, \"bitcoin server starting\\n\");\n     strErrors = \"\";\n     int64 nStart;\n \n     printf(\"Loading addresses...\\n\");\n     nStart = GetTimeMillis();\n     if (!LoadAddresses())\n-        strErrors += _(\"Error loading addr.dat      \\n\");\n+\tstrErrors += _(\"Error loading addr.dat      \\n\");\n     printf(\" addresses   %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();\n     if (!LoadBlockIndex())\n-        strErrors += _(\"Error loading blkindex.dat      \\n\");\n+\tstrErrors += _(\"Error loading blkindex.dat      \\n\");\n     printf(\" block index %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n     printf(\"Loading wallet...\\n\");\n     nStart = GetTimeMillis();\n     bool fFirstRun;\n     if (!LoadWallet(fFirstRun))\n-        strErrors += _(\"Error loading wallet.dat      \\n\");\n+\tstrErrors += _(\"Error loading wallet.dat      \\n\");\n     printf(\" wallet      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n     CBlockIndex *pindexRescan = pindexBest;\n     if (GetBoolArg(\"-rescan\"))\n-        pindexRescan = pindexGenesisBlock;\n+\tpindexRescan = pindexGenesisBlock;\n     else\n     {\n-        CWalletDB walletdb;\n-        CBlockLocator locator;\n-        if (walletdb.ReadBestBlock(locator))\n-            pindexRescan = locator.GetBlockIndex();\n+\tCWalletDB walletdb;\n+\tCBlockLocator locator;\n+\tif (walletdb.ReadBestBlock(locator))\n+\t    pindexRescan = locator.GetBlockIndex();\n     }\n     if (pindexBest != pindexRescan)\n     {\n-        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n-        nStart = GetTimeMillis();\n-        ScanForWalletTransactions(pindexRescan);\n-        printf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+\tprintf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n+\tnStart = GetTimeMillis();\n+\tScanForWalletTransactions(pindexRescan);\n+\tprintf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n     }\n \n     printf(\"Done loading\\n\");\n \n-        //// debug print\n-        printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n-        printf(\"nBestHeight = %d\\n\",            nBestHeight);\n-        printf(\"mapKeys.size() = %d\\n\",         mapKeys.size());\n-        printf(\"mapPubKeys.size() = %d\\n\",      mapPubKeys.size());\n-        printf(\"mapWallet.size() = %d\\n\",       mapWallet.size());\n-        printf(\"mapAddressBook.size() = %d\\n\",  mapAddressBook.size());\n+\t//// debug print\n+\tprintf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n+\tprintf(\"nBestHeight = %d\\n\",            nBestHeight);\n+\tprintf(\"mapKeys.size() = %d\\n\",         mapKeys.size());\n+\tprintf(\"mapPubKeys.size() = %d\\n\",      mapPubKeys.size());\n+\tprintf(\"mapWallet.size() = %d\\n\",       mapWallet.size());\n+\tprintf(\"mapAddressBook.size() = %d\\n\",  mapAddressBook.size());\n \n     if (!strErrors.empty())\n     {\n-        wxMessageBox(strErrors, \"Bitcoin\", wxOK | wxICON_ERROR);\n-        return false;\n+\twxMessageBox(strErrors, \"Bitcoin\", wxOK | wxICON_ERROR);\n+\treturn false;\n     }\n \n     // Add wallet transactions that aren't already in a block to mapTransactions\n@@ -416,79 +416,79 @@ bool AppInit2(int argc, char* argv[])\n     //\n     if (GetBoolArg(\"-printblockindex\") || GetBoolArg(\"-printblocktree\"))\n     {\n-        PrintBlockTree();\n-        return false;\n+\tPrintBlockTree();\n+\treturn false;\n     }\n \n     if (mapArgs.count(\"-printblock\"))\n     {\n-        string strMatch = mapArgs[\"-printblock\"];\n-        int nFound = 0;\n-        for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n-        {\n-            uint256 hash = (*mi).first;\n-            if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n-            {\n-                CBlockIndex* pindex = (*mi).second;\n-                CBlock block;\n-                block.ReadFromDisk(pindex);\n-                block.BuildMerkleTree();\n-                block.print();\n-                printf(\"\\n\");\n-                nFound++;\n-            }\n-        }\n-        if (nFound == 0)\n-            printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n-        return false;\n+\tstring strMatch = mapArgs[\"-printblock\"];\n+\tint nFound = 0;\n+\tfor (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n+\t{\n+\t    uint256 hash = (*mi).first;\n+\t    if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n+\t    {\n+\t\tCBlockIndex* pindex = (*mi).second;\n+\t\tCBlock block;\n+\t\tblock.ReadFromDisk(pindex);\n+\t\tblock.BuildMerkleTree();\n+\t\tblock.print();\n+\t\tprintf(\"\\n\");\n+\t\tnFound++;\n+\t    }\n+\t}\n+\tif (nFound == 0)\n+\t    printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n+\treturn false;\n     }\n \n     fGenerateBitcoins = GetBoolArg(\"-gen\");\n \n     if (mapArgs.count(\"-proxy\"))\n     {\n-        fUseProxy = true;\n-        addrProxy = CAddress(mapArgs[\"-proxy\"]);\n-        if (!addrProxy.IsValid())\n-        {\n-            wxMessageBox(_(\"Invalid -proxy address\"), \"Bitcoin\");\n-            return false;\n-        }\n+\tfUseProxy = true;\n+\taddrProxy = CAddress(mapArgs[\"-proxy\"]);\n+\tif (!addrProxy.IsValid())\n+\t{\n+\t    wxMessageBox(_(\"Invalid -proxy address\"), \"Bitcoin\");\n+\t    return false;\n+\t}\n     }\n \n     if (mapArgs.count(\"-addnode\"))\n     {\n-        foreach(string strAddr, mapMultiArgs[\"-addnode\"])\n-        {\n-            CAddress addr(strAddr, fAllowDNS);\n-            addr.nTime = 0; // so it won't relay unless successfully connected\n-            if (addr.IsValid())\n-                AddAddress(addr);\n-        }\n+\tforeach(string strAddr, mapMultiArgs[\"-addnode\"])\n+\t{\n+\t    CAddress addr(strAddr, fAllowDNS);\n+\t    addr.nTime = 0; // so it won't relay unless successfully connected\n+\t    if (addr.IsValid())\n+\t\tAddAddress(addr);\n+\t}\n     }\n \n     if (mapArgs.count(\"-dnsseed\"))\n-        DNSAddressSeed();\n+\tDNSAddressSeed();\n \n     if (mapArgs.count(\"-paytxfee\"))\n     {\n-        if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n-        {\n-            wxMessageBox(_(\"Invalid amount for -paytxfee=<amount>\"), \"Bitcoin\");\n-            return false;\n-        }\n-        if (nTransactionFee > 0.25 * COIN)\n-            wxMessageBox(_(\"Warning: -paytxfee is set very high.  This is the transaction fee you will pay if you send a transaction.\"), \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n+\tif (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n+\t{\n+\t    wxMessageBox(_(\"Invalid amount for -paytxfee=<amount>\"), \"Bitcoin\");\n+\t    return false;\n+\t}\n+\tif (nTransactionFee > 0.25 * COIN)\n+\t    wxMessageBox(_(\"Warning: -paytxfee is set very high.  This is the transaction fee you will pay if you send a transaction.\"), \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n     }\n \n     if (fHaveUPnP)\n     {\n #if USE_UPNP\n     if (GetBoolArg(\"-noupnp\"))\n-        fUseUPnP = false;\n+\tfUseUPnP = false;\n #else\n     if (GetBoolArg(\"-upnp\"))\n-        fUseUPnP = true;\n+\tfUseUPnP = true;\n #endif\n     }\n \n@@ -497,28 +497,28 @@ bool AppInit2(int argc, char* argv[])\n     //\n #ifdef GUI\n     if (!fDaemon)\n-        CreateMainWindow();\n+\tCreateMainWindow();\n #endif\n \n     if (!CheckDiskSpace())\n-        return false;\n+\treturn false;\n \n     RandAddSeedPerfmon();\n \n     if (!CreateThread(StartNode, NULL))\n-        wxMessageBox(\"Error: CreateThread(StartNode) failed\", \"Bitcoin\");\n+\twxMessageBox(\"Error: CreateThread(StartNode) failed\", \"Bitcoin\");\n \n     if (fServer)\n-        CreateThread(ThreadRPCServer, NULL);\n+\tCreateThread(ThreadRPCServer, NULL);\n \n #if defined(__WXMSW__) && defined(GUI)\n     if (fFirstRun)\n-        SetStartOnSystemStartup(true);\n+\tSetStartOnSystemStartup(true);\n #endif\n \n #ifndef GUI\n     while (1)\n-        Sleep(5000);\n+\tSleep(5000);\n #endif\n \n     return true;"
      },
      {
        "sha": "ff998c09e7489204b1970395728b3996b95a853d",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 254,
        "deletions": 254,
        "changes": 508,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -34,11 +34,11 @@ bool DecodeAddress(string str, CAddress& addr)\n {\n     vector<unsigned char> vch;\n     if (!DecodeBase58Check(str.substr(1), vch))\n-        return false;\n+\treturn false;\n \n     struct ircaddr tmp;\n     if (vch.size() != sizeof(tmp))\n-        return false;\n+\treturn false;\n     memcpy(&tmp, &vch[0], sizeof(tmp));\n \n     addr = CAddress(tmp.ip, ntohs(tmp.port), NODE_NETWORK);\n@@ -53,15 +53,15 @@ bool DecodeAddress(string str, CAddress& addr)\n static bool Send(SOCKET hSocket, const char* pszSend)\n {\n     if (strstr(pszSend, \"PONG\") != pszSend)\n-        printf(\"IRC SENDING: %s\\n\", pszSend);\n+\tprintf(\"IRC SENDING: %s\\n\", pszSend);\n     const char* psz = pszSend;\n     const char* pszEnd = psz + strlen(psz);\n     while (psz < pszEnd)\n     {\n-        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n-        if (ret < 0)\n-            return false;\n-        psz += ret;\n+\tint ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n+\tif (ret < 0)\n+\t    return false;\n+\tpsz += ret;\n     }\n     return true;\n }\n@@ -71,105 +71,105 @@ bool RecvLine(SOCKET hSocket, string& strLine)\n     strLine = \"\";\n     loop\n     {\n-        char c;\n-        int nBytes = recv(hSocket, &c, 1, 0);\n-        if (nBytes > 0)\n-        {\n-            if (c == '\\n')\n-                continue;\n-            if (c == '\\r')\n-                return true;\n-            strLine += c;\n-            if (strLine.size() >= 9000)\n-                return true;\n-        }\n-        else if (nBytes <= 0)\n-        {\n-            if (fShutdown)\n-                return false;\n-            if (nBytes < 0)\n-            {\n-                int nErr = WSAGetLastError();\n-                if (nErr == WSAEMSGSIZE)\n-                    continue;\n-                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n-                {\n-                    Sleep(10);\n-                    continue;\n-                }\n-            }\n-            if (!strLine.empty())\n-                return true;\n-            if (nBytes == 0)\n-            {\n-                // socket closed\n-                printf(\"IRC socket closed\\n\");\n-                return false;\n-            }\n-            else\n-            {\n-                // socket error\n-                int nErr = WSAGetLastError();\n-                printf(\"IRC recv failed: %d\\n\", nErr);\n-                return false;\n-            }\n-        }\n+\tchar c;\n+\tint nBytes = recv(hSocket, &c, 1, 0);\n+\tif (nBytes > 0)\n+\t{\n+\t    if (c == '\\n')\n+\t\tcontinue;\n+\t    if (c == '\\r')\n+\t\treturn true;\n+\t    strLine += c;\n+\t    if (strLine.size() >= 9000)\n+\t\treturn true;\n+\t}\n+\telse if (nBytes <= 0)\n+\t{\n+\t    if (fShutdown)\n+\t\treturn false;\n+\t    if (nBytes < 0)\n+\t    {\n+\t\tint nErr = WSAGetLastError();\n+\t\tif (nErr == WSAEMSGSIZE)\n+\t\t    continue;\n+\t\tif (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n+\t\t{\n+\t\t    Sleep(10);\n+\t\t    continue;\n+\t\t}\n+\t    }\n+\t    if (!strLine.empty())\n+\t\treturn true;\n+\t    if (nBytes == 0)\n+\t    {\n+\t\t// socket closed\n+\t\tprintf(\"IRC socket closed\\n\");\n+\t\treturn false;\n+\t    }\n+\t    else\n+\t    {\n+\t\t// socket error\n+\t\tint nErr = WSAGetLastError();\n+\t\tprintf(\"IRC recv failed: %d\\n\", nErr);\n+\t\treturn false;\n+\t    }\n+\t}\n     }\n }\n \n bool RecvLineIRC(SOCKET hSocket, string& strLine)\n {\n     loop\n     {\n-        bool fRet = RecvLine(hSocket, strLine);\n-        if (fRet)\n-        {\n-            if (fShutdown)\n-                return false;\n-            vector<string> vWords;\n-            ParseString(strLine, ' ', vWords);\n-            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n-            {\n-                strLine[1] = 'O';\n-                strLine += '\\r';\n-                Send(hSocket, strLine.c_str());\n-                continue;\n-            }\n-        }\n-        return fRet;\n+\tbool fRet = RecvLine(hSocket, strLine);\n+\tif (fRet)\n+\t{\n+\t    if (fShutdown)\n+\t\treturn false;\n+\t    vector<string> vWords;\n+\t    ParseString(strLine, ' ', vWords);\n+\t    if (vWords.size() >= 1 && vWords[0] == \"PING\")\n+\t    {\n+\t\tstrLine[1] = 'O';\n+\t\tstrLine += '\\r';\n+\t\tSend(hSocket, strLine.c_str());\n+\t\tcontinue;\n+\t    }\n+\t}\n+\treturn fRet;\n     }\n }\n \n int RecvUntil(SOCKET hSocket, const char* psz1, const char* psz2=NULL, const char* psz3=NULL, const char* psz4=NULL)\n {\n     loop\n     {\n-        string strLine;\n-        strLine.reserve(10000);\n-        if (!RecvLineIRC(hSocket, strLine))\n-            return 0;\n-        printf(\"IRC %s\\n\", strLine.c_str());\n-        if (psz1 && strLine.find(psz1) != -1)\n-            return 1;\n-        if (psz2 && strLine.find(psz2) != -1)\n-            return 2;\n-        if (psz3 && strLine.find(psz3) != -1)\n-            return 3;\n-        if (psz4 && strLine.find(psz4) != -1)\n-            return 4;\n+\tstring strLine;\n+\tstrLine.reserve(10000);\n+\tif (!RecvLineIRC(hSocket, strLine))\n+\t    return 0;\n+\tprintf(\"IRC %s\\n\", strLine.c_str());\n+\tif (psz1 && strLine.find(psz1) != -1)\n+\t    return 1;\n+\tif (psz2 && strLine.find(psz2) != -1)\n+\t    return 2;\n+\tif (psz3 && strLine.find(psz3) != -1)\n+\t    return 3;\n+\tif (psz4 && strLine.find(psz4) != -1)\n+\t    return 4;\n     }\n }\n \n bool Wait(int nSeconds)\n {\n     if (fShutdown)\n-        return false;\n+\treturn false;\n     printf(\"IRC waiting %d seconds to reconnect\\n\", nSeconds);\n     for (int i = 0; i < nSeconds; i++)\n     {\n-        if (fShutdown)\n-            return false;\n-        Sleep(1000);\n+\tif (fShutdown)\n+\t    return false;\n+\tSleep(1000);\n     }\n     return true;\n }\n@@ -179,21 +179,21 @@ bool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n     strRet.clear();\n     loop\n     {\n-        string strLine;\n-        if (!RecvLineIRC(hSocket, strLine))\n-            return false;\n-\n-        vector<string> vWords;\n-        ParseString(strLine, ' ', vWords);\n-        if (vWords.size() < 2)\n-            continue;\n-\n-        if (vWords[1] == psz1)\n-        {\n-            printf(\"IRC %s\\n\", strLine.c_str());\n-            strRet = strLine;\n-            return true;\n-        }\n+\tstring strLine;\n+\tif (!RecvLineIRC(hSocket, strLine))\n+\t    return false;\n+\n+\tvector<string> vWords;\n+\tParseString(strLine, ' ', vWords);\n+\tif (vWords.size() < 2)\n+\t    continue;\n+\n+\tif (vWords[1] == psz1)\n+\t{\n+\t    printf(\"IRC %s\\n\", strLine.c_str());\n+\t    strRet = strLine;\n+\t    return true;\n+\t}\n     }\n }\n \n@@ -203,26 +203,26 @@ bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n \n     string strLine;\n     if (!RecvCodeLine(hSocket, \"302\", strLine))\n-        return false;\n+\treturn false;\n \n     vector<string> vWords;\n     ParseString(strLine, ' ', vWords);\n     if (vWords.size() < 4)\n-        return false;\n+\treturn false;\n \n     string str = vWords[3];\n     if (str.rfind(\"@\") == string::npos)\n-        return false;\n+\treturn false;\n     string strHost = str.substr(str.rfind(\"@\")+1);\n \n     // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n     // but in case another IRC is ever used this should work.\n     printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n     if (fUseProxy)\n-        return false;\n+\treturn false;\n     CAddress addr(strHost, 0, true);\n     if (!addr.IsValid())\n-        return false;\n+\treturn false;\n     ipRet = addr.ip;\n \n     return true;\n@@ -235,12 +235,12 @@ void ThreadIRCSeed(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadIRCSeed(parg));\n     try\n     {\n-        ThreadIRCSeed2(parg);\n+\tThreadIRCSeed2(parg);\n     }\n     catch (std::exception& e) {\n-        PrintExceptionContinue(&e, \"ThreadIRCSeed()\");\n+\tPrintExceptionContinue(&e, \"ThreadIRCSeed()\");\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"ThreadIRCSeed()\");\n+\tPrintExceptionContinue(NULL, \"ThreadIRCSeed()\");\n     }\n     printf(\"ThreadIRCSeed exiting\\n\");\n }\n@@ -249,10 +249,10 @@ void ThreadIRCSeed2(void* parg)\n {\n     /* Dont advertise on IRC if we don't allow incoming connections */\n     if (mapArgs.count(\"-connect\") || fNoListen)\n-        return;\n+\treturn;\n \n     if (GetBoolArg(\"-noirc\"))\n-        return;\n+\treturn;\n     printf(\"ThreadIRCSeed started\\n\");\n     int nErrorWait = 10;\n     int nRetryWait = 10;\n@@ -261,150 +261,150 @@ void ThreadIRCSeed2(void* parg)\n \n     while (!fShutdown)\n     {\n-        //CAddress addrConnect(\"216.155.130.130:6667\"); // chat.freenode.net\n-        CAddress addrConnect(\"92.243.23.21:6667\"); // irc.lfnet.org\n-        if (!fTOR)\n-        {\n-            //struct hostent* phostent = gethostbyname(\"chat.freenode.net\");\n-            CAddress addrIRC(\"irc.lfnet.org:6667\", 0, true);\n-            if (addrIRC.IsValid())\n-                addrConnect = addrIRC;\n-        }\n-\n-        SOCKET hSocket;\n-        if (!ConnectSocket(addrConnect, hSocket))\n-        {\n-            printf(\"IRC connect failed\\n\");\n-            nErrorWait = nErrorWait * 11 / 10;\n-            if (Wait(nErrorWait += 60))\n-                continue;\n-            else\n-                return;\n-        }\n-\n-        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n-        {\n-            closesocket(hSocket);\n-            hSocket = INVALID_SOCKET;\n-            nErrorWait = nErrorWait * 11 / 10;\n-            if (Wait(nErrorWait += 60))\n-                continue;\n-            else\n-                return;\n-        }\n-\n-        string strMyName;\n-        if (addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n-            strMyName = EncodeAddress(addrLocalHost);\n-        else\n-            strMyName = strprintf(\"x%u\", GetRand(1000000000));\n-\n-        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n-        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n-\n-        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n-        if (nRet != 1)\n-        {\n-            closesocket(hSocket);\n-            hSocket = INVALID_SOCKET;\n-            if (nRet == 2)\n-            {\n-                printf(\"IRC name already in use\\n\");\n-                fNameInUse = true;\n-                Wait(10);\n-                continue;\n-            }\n-            nErrorWait = nErrorWait * 11 / 10;\n-            if (Wait(nErrorWait += 60))\n-                continue;\n-            else\n-                return;\n-        }\n-        Sleep(500);\n-\n-        // Get our external IP from the IRC server and re-nick before joining the channel\n-        CAddress addrFromIRC;\n-        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC.ip))\n-        {\n-            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToStringIP().c_str());\n-            if (!fUseProxy && addrFromIRC.IsRoutable())\n-            {\n-                // IRC lets you to re-nick\n-                fGotExternalIP = true;\n-                addrLocalHost.ip = addrFromIRC.ip;\n-                strMyName = EncodeAddress(addrLocalHost);\n-                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n-            }\n-        }\n-\n-        Send(hSocket, fTestNet ? \"JOIN #bitcoinTEST\\r\" : \"JOIN #bitcoin\\r\");\n-        Send(hSocket, fTestNet ? \"WHO #bitcoinTEST\\r\"  : \"WHO #bitcoin\\r\");\n-\n-        int64 nStart = GetTime();\n-        string strLine;\n-        strLine.reserve(10000);\n-        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n-        {\n-            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n-                continue;\n-\n-            vector<string> vWords;\n-            ParseString(strLine, ' ', vWords);\n-            if (vWords.size() < 2)\n-                continue;\n-\n-            char pszName[10000];\n-            pszName[0] = '\\0';\n-\n-            if (vWords[1] == \"352\" && vWords.size() >= 8)\n-            {\n-                // index 7 is limited to 16 characters\n-                // could get full length name at index 10, but would be different from join messages\n-                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n-                printf(\"IRC got who\\n\");\n-            }\n-\n-            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n-            {\n-                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n-                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n-                if (strchr(pszName, '!'))\n-                    *strchr(pszName, '!') = '\\0';\n-                printf(\"IRC got join\\n\");\n-            }\n-\n-            if (pszName[0] == 'u')\n-            {\n-                CAddress addr;\n-                if (DecodeAddress(pszName, addr))\n-                {\n-                    addr.nTime = GetAdjustedTime();\n-                    if (AddAddress(addr, 51 * 60))\n-                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n-                    nGotIRCAddresses++;\n-                }\n-                else\n-                {\n-                    printf(\"IRC decode failed\\n\");\n-                }\n-            }\n-        }\n-        closesocket(hSocket);\n-        hSocket = INVALID_SOCKET;\n-\n-        // IRC usually blocks TOR, so only try once\n-        if (fTOR)\n-            return;\n-\n-        if (GetTime() - nStart > 20 * 60)\n-        {\n-            nErrorWait /= 3;\n-            nRetryWait /= 3;\n-        }\n-\n-        nRetryWait = nRetryWait * 11 / 10;\n-        if (!Wait(nRetryWait += 60))\n-            return;\n+\t//CAddress addrConnect(\"216.155.130.130:6667\"); // chat.freenode.net\n+\tCAddress addrConnect(\"92.243.23.21:6667\"); // irc.lfnet.org\n+\tif (!fTOR)\n+\t{\n+\t    //struct hostent* phostent = gethostbyname(\"chat.freenode.net\");\n+\t    CAddress addrIRC(\"irc.lfnet.org:6667\", 0, true);\n+\t    if (addrIRC.IsValid())\n+\t\taddrConnect = addrIRC;\n+\t}\n+\n+\tSOCKET hSocket;\n+\tif (!ConnectSocket(addrConnect, hSocket))\n+\t{\n+\t    printf(\"IRC connect failed\\n\");\n+\t    nErrorWait = nErrorWait * 11 / 10;\n+\t    if (Wait(nErrorWait += 60))\n+\t\tcontinue;\n+\t    else\n+\t\treturn;\n+\t}\n+\n+\tif (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n+\t{\n+\t    closesocket(hSocket);\n+\t    hSocket = INVALID_SOCKET;\n+\t    nErrorWait = nErrorWait * 11 / 10;\n+\t    if (Wait(nErrorWait += 60))\n+\t\tcontinue;\n+\t    else\n+\t\treturn;\n+\t}\n+\n+\tstring strMyName;\n+\tif (addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n+\t    strMyName = EncodeAddress(addrLocalHost);\n+\telse\n+\t    strMyName = strprintf(\"x%u\", GetRand(1000000000));\n+\n+\tSend(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n+\tSend(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n+\n+\tint nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n+\tif (nRet != 1)\n+\t{\n+\t    closesocket(hSocket);\n+\t    hSocket = INVALID_SOCKET;\n+\t    if (nRet == 2)\n+\t    {\n+\t\tprintf(\"IRC name already in use\\n\");\n+\t\tfNameInUse = true;\n+\t\tWait(10);\n+\t\tcontinue;\n+\t    }\n+\t    nErrorWait = nErrorWait * 11 / 10;\n+\t    if (Wait(nErrorWait += 60))\n+\t\tcontinue;\n+\t    else\n+\t\treturn;\n+\t}\n+\tSleep(500);\n+\n+\t// Get our external IP from the IRC server and re-nick before joining the channel\n+\tCAddress addrFromIRC;\n+\tif (GetIPFromIRC(hSocket, strMyName, addrFromIRC.ip))\n+\t{\n+\t    printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToStringIP().c_str());\n+\t    if (!fUseProxy && addrFromIRC.IsRoutable())\n+\t    {\n+\t\t// IRC lets you to re-nick\n+\t\tfGotExternalIP = true;\n+\t\taddrLocalHost.ip = addrFromIRC.ip;\n+\t\tstrMyName = EncodeAddress(addrLocalHost);\n+\t\tSend(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n+\t    }\n+\t}\n+\n+\tSend(hSocket, fTestNet ? \"JOIN #bitcoinTEST\\r\" : \"JOIN #bitcoin\\r\");\n+\tSend(hSocket, fTestNet ? \"WHO #bitcoinTEST\\r\"  : \"WHO #bitcoin\\r\");\n+\n+\tint64 nStart = GetTime();\n+\tstring strLine;\n+\tstrLine.reserve(10000);\n+\twhile (!fShutdown && RecvLineIRC(hSocket, strLine))\n+\t{\n+\t    if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n+\t\tcontinue;\n+\n+\t    vector<string> vWords;\n+\t    ParseString(strLine, ' ', vWords);\n+\t    if (vWords.size() < 2)\n+\t\tcontinue;\n+\n+\t    char pszName[10000];\n+\t    pszName[0] = '\\0';\n+\n+\t    if (vWords[1] == \"352\" && vWords.size() >= 8)\n+\t    {\n+\t\t// index 7 is limited to 16 characters\n+\t\t// could get full length name at index 10, but would be different from join messages\n+\t\tstrlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n+\t\tprintf(\"IRC got who\\n\");\n+\t    }\n+\n+\t    if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n+\t    {\n+\t\t// :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n+\t\tstrlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n+\t\tif (strchr(pszName, '!'))\n+\t\t    *strchr(pszName, '!') = '\\0';\n+\t\tprintf(\"IRC got join\\n\");\n+\t    }\n+\n+\t    if (pszName[0] == 'u')\n+\t    {\n+\t\tCAddress addr;\n+\t\tif (DecodeAddress(pszName, addr))\n+\t\t{\n+\t\t    addr.nTime = GetAdjustedTime();\n+\t\t    if (AddAddress(addr, 51 * 60))\n+\t\t\tprintf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n+\t\t    nGotIRCAddresses++;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t    printf(\"IRC decode failed\\n\");\n+\t\t}\n+\t    }\n+\t}\n+\tclosesocket(hSocket);\n+\thSocket = INVALID_SOCKET;\n+\n+\t// IRC usually blocks TOR, so only try once\n+\tif (fTOR)\n+\t    return;\n+\n+\tif (GetTime() - nStart > 20 * 60)\n+\t{\n+\t    nErrorWait /= 3;\n+\t    nRetryWait /= 3;\n+\t}\n+\n+\tnRetryWait = nRetryWait * 11 / 10;\n+\tif (!Wait(nRetryWait += 60))\n+\t    return;\n     }\n }\n \n@@ -423,8 +423,8 @@ int main(int argc, char *argv[])\n     WSADATA wsadata;\n     if (WSAStartup(MAKEWORD(2,2), &wsadata) != NO_ERROR)\n     {\n-        printf(\"Error at WSAStartup()\\n\");\n-        return false;\n+\tprintf(\"Error at WSAStartup()\\n\");\n+\treturn false;\n     }\n \n     ThreadIRCSeed(NULL);"
      },
      {
        "sha": "c15b1c664afc108f356eceadb5940e2c0607daad",
        "filename": "src/json/json_spirit_error_position.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_error_position.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_error_position.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_error_position.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -15,17 +15,17 @@\n namespace json_spirit\n {\n     // An Error_position exception is thrown by the \"read_or_throw\" functions below on finding an error.\n-    // Note the \"read_or_throw\" functions are around 3 times slower than the standard functions \"read\" \n+    // Note the \"read_or_throw\" functions are around 3 times slower than the standard functions \"read\"\n     // functions that return a bool.\n     //\n     struct Error_position\n     {\n-        Error_position();\n-        Error_position( unsigned int line, unsigned int column, const std::string& reason );\n-        bool operator==( const Error_position& lhs ) const;\n-        unsigned int line_;\n-        unsigned int column_;\n-        std::string reason_;\n+\tError_position();\n+\tError_position( unsigned int line, unsigned int column, const std::string& reason );\n+\tbool operator==( const Error_position& lhs ) const;\n+\tunsigned int line_;\n+\tunsigned int column_;\n+\tstd::string reason_;\n     };\n \n     inline Error_position::Error_position()\n@@ -43,11 +43,11 @@ namespace json_spirit\n \n     inline bool Error_position::operator==( const Error_position& lhs ) const\n     {\n-        if( this == &lhs ) return true;\n+\tif( this == &lhs ) return true;\n \n-        return ( reason_ == lhs.reason_ ) &&\n-               ( line_   == lhs.line_ ) &&\n-               ( column_ == lhs.column_ ); \n+\treturn ( reason_ == lhs.reason_ ) &&\n+\t       ( line_   == lhs.line_ ) &&\n+\t       ( column_ == lhs.column_ );\n }\n }\n "
      },
      {
        "sha": "19de2a517a0b5c66cc286b7891f2f0a8a1c38c2c",
        "filename": "src/json/json_spirit_reader.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_reader.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_reader.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_reader.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -22,15 +22,15 @@ namespace json_spirit\n     bool read( std::istream& is,     Value& value );\n     bool read( std::string::const_iterator& begin, std::string::const_iterator end, Value& value );\n \n-    void read_or_throw( const std::string& s, Value& value );  \n+    void read_or_throw( const std::string& s, Value& value );\n     void read_or_throw( std::istream& is,     Value& value );\n     void read_or_throw( std::string::const_iterator& begin, std::string::const_iterator end, Value& value );\n \n #ifndef BOOST_NO_STD_WSTRING\n \n     bool read( const std::wstring& s, wValue& value );\n     bool read( std::wistream&  is,    wValue& value );\n-    bool read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wValue& value );    \n+    bool read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wValue& value );\n \n     void read_or_throw( const std::wstring& s, wValue& value );\n     void read_or_throw( std::wistream& is,     wValue& value );\n@@ -42,15 +42,15 @@ namespace json_spirit\n     bool read( std::istream& is,     mValue& value );\n     bool read( std::string::const_iterator& begin, std::string::const_iterator end, mValue& value );\n \n-    void read_or_throw( const std::string& s, mValue& value );  \n+    void read_or_throw( const std::string& s, mValue& value );\n     void read_or_throw( std::istream& is,     mValue& value );\n     void read_or_throw( std::string::const_iterator& begin, std::string::const_iterator end, mValue& value );\n \n #ifndef BOOST_NO_STD_WSTRING\n \n     bool read( const std::wstring& s, wmValue& value );\n     bool read( std::wistream& is,     wmValue& value );\n-    bool read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wmValue& value );    \n+    bool read( std::wstring::const_iterator& begin, std::wstring::const_iterator end, wmValue& value );\n \n     void read_or_throw( const std::wstring& s, wmValue& value );\n     void read_or_throw( std::wistream& is,     wmValue& value );"
      },
      {
        "sha": "4ef4a26bf126f5b467ecdaf97134d7f52d4336ae",
        "filename": "src/json/json_spirit_reader_template.h",
        "status": "modified",
        "additions": 396,
        "deletions": 396,
        "changes": 792,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_reader_template.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_reader_template.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_reader_template.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -39,152 +39,152 @@ namespace json_spirit\n     template< class Iter_type >\n     bool is_eq( Iter_type first, Iter_type last, const char* c_str )\n     {\n-        for( Iter_type i = first; i != last; ++i, ++c_str )\n-        {\n-            if( *c_str == 0 ) return false;\n+\tfor( Iter_type i = first; i != last; ++i, ++c_str )\n+\t{\n+\t    if( *c_str == 0 ) return false;\n \n-            if( *i != *c_str ) return false;\n-        }\n+\t    if( *i != *c_str ) return false;\n+\t}\n \n-        return true;\n+\treturn true;\n     }\n \n     template< class Char_type >\n     Char_type hex_to_num( const Char_type c )\n     {\n-        if( ( c >= '0' ) && ( c <= '9' ) ) return c - '0';\n-        if( ( c >= 'a' ) && ( c <= 'f' ) ) return c - 'a' + 10;\n-        if( ( c >= 'A' ) && ( c <= 'F' ) ) return c - 'A' + 10;\n-        return 0;\n+\tif( ( c >= '0' ) && ( c <= '9' ) ) return c - '0';\n+\tif( ( c >= 'a' ) && ( c <= 'f' ) ) return c - 'a' + 10;\n+\tif( ( c >= 'A' ) && ( c <= 'F' ) ) return c - 'A' + 10;\n+\treturn 0;\n     }\n \n     template< class Char_type, class Iter_type >\n     Char_type hex_str_to_char( Iter_type& begin )\n     {\n-        const Char_type c1( *( ++begin ) );\n-        const Char_type c2( *( ++begin ) );\n+\tconst Char_type c1( *( ++begin ) );\n+\tconst Char_type c2( *( ++begin ) );\n \n-        return ( hex_to_num( c1 ) << 4 ) + hex_to_num( c2 );\n-    }       \n+\treturn ( hex_to_num( c1 ) << 4 ) + hex_to_num( c2 );\n+    }\n \n     template< class Char_type, class Iter_type >\n     Char_type unicode_str_to_char( Iter_type& begin )\n     {\n-        const Char_type c1( *( ++begin ) );\n-        const Char_type c2( *( ++begin ) );\n-        const Char_type c3( *( ++begin ) );\n-        const Char_type c4( *( ++begin ) );\n-\n-        return ( hex_to_num( c1 ) << 12 ) + \n-               ( hex_to_num( c2 ) <<  8 ) + \n-               ( hex_to_num( c3 ) <<  4 ) + \n-               hex_to_num( c4 );\n+\tconst Char_type c1( *( ++begin ) );\n+\tconst Char_type c2( *( ++begin ) );\n+\tconst Char_type c3( *( ++begin ) );\n+\tconst Char_type c4( *( ++begin ) );\n+\n+\treturn ( hex_to_num( c1 ) << 12 ) +\n+\t       ( hex_to_num( c2 ) <<  8 ) +\n+\t       ( hex_to_num( c3 ) <<  4 ) +\n+\t       hex_to_num( c4 );\n     }\n \n     template< class String_type >\n-    void append_esc_char_and_incr_iter( String_type& s, \n-                                        typename String_type::const_iterator& begin, \n-                                        typename String_type::const_iterator end )\n+    void append_esc_char_and_incr_iter( String_type& s,\n+\t\t\t\t\ttypename String_type::const_iterator& begin,\n+\t\t\t\t\ttypename String_type::const_iterator end )\n     {\n-        typedef typename String_type::value_type Char_type;\n-             \n-        const Char_type c2( *begin );\n-\n-        switch( c2 )\n-        {\n-            case 't':  s += '\\t'; break;\n-            case 'b':  s += '\\b'; break;\n-            case 'f':  s += '\\f'; break;\n-            case 'n':  s += '\\n'; break;\n-            case 'r':  s += '\\r'; break;\n-            case '\\\\': s += '\\\\'; break;\n-            case '/':  s += '/';  break;\n-            case '\"':  s += '\"';  break;\n-            case 'x':  \n-            {\n-                if( end - begin >= 3 )  //  expecting \"xHH...\"\n-                {\n-                    s += hex_str_to_char< Char_type >( begin );  \n-                }\n-                break;\n-            }\n-            case 'u':  \n-            {\n-                if( end - begin >= 5 )  //  expecting \"uHHHH...\"\n-                {\n-                    s += unicode_str_to_char< Char_type >( begin );  \n-                }\n-                break;\n-            }\n-        }\n+\ttypedef typename String_type::value_type Char_type;\n+\n+\tconst Char_type c2( *begin );\n+\n+\tswitch( c2 )\n+\t{\n+\t    case 't':  s += '\\t'; break;\n+\t    case 'b':  s += '\\b'; break;\n+\t    case 'f':  s += '\\f'; break;\n+\t    case 'n':  s += '\\n'; break;\n+\t    case 'r':  s += '\\r'; break;\n+\t    case '\\\\': s += '\\\\'; break;\n+\t    case '/':  s += '/';  break;\n+\t    case '\"':  s += '\"';  break;\n+\t    case 'x':\n+\t    {\n+\t\tif( end - begin >= 3 )  //  expecting \"xHH...\"\n+\t\t{\n+\t\t    s += hex_str_to_char< Char_type >( begin );\n+\t\t}\n+\t\tbreak;\n+\t    }\n+\t    case 'u':\n+\t    {\n+\t\tif( end - begin >= 5 )  //  expecting \"uHHHH...\"\n+\t\t{\n+\t\t    s += unicode_str_to_char< Char_type >( begin );\n+\t\t}\n+\t\tbreak;\n+\t    }\n+\t}\n     }\n \n     template< class String_type >\n-    String_type substitute_esc_chars( typename String_type::const_iterator begin, \n-                                   typename String_type::const_iterator end )\n+    String_type substitute_esc_chars( typename String_type::const_iterator begin,\n+\t\t\t\t   typename String_type::const_iterator end )\n     {\n-        typedef typename String_type::const_iterator Iter_type;\n+\ttypedef typename String_type::const_iterator Iter_type;\n+\n+\tif( end - begin < 2 ) return String_type( begin, end );\n+\n+\tString_type result;\n \n-        if( end - begin < 2 ) return String_type( begin, end );\n+\tresult.reserve( end - begin );\n \n-        String_type result;\n-        \n-        result.reserve( end - begin );\n+\tconst Iter_type end_minus_1( end - 1 );\n \n-        const Iter_type end_minus_1( end - 1 );\n+\tIter_type substr_start = begin;\n+\tIter_type i = begin;\n \n-        Iter_type substr_start = begin;\n-        Iter_type i = begin;\n+\tfor( ; i < end_minus_1; ++i )\n+\t{\n+\t    if( *i == '\\\\' )\n+\t    {\n+\t\tresult.append( substr_start, i );\n \n-        for( ; i < end_minus_1; ++i )\n-        {\n-            if( *i == '\\\\' )\n-            {\n-                result.append( substr_start, i );\n+\t\t++i;  // skip the '\\'\n \n-                ++i;  // skip the '\\'\n-             \n-                append_esc_char_and_incr_iter( result, i, end );\n+\t\tappend_esc_char_and_incr_iter( result, i, end );\n \n-                substr_start = i + 1;\n-            }\n-        }\n+\t\tsubstr_start = i + 1;\n+\t    }\n+\t}\n \n-        result.append( substr_start, end );\n+\tresult.append( substr_start, end );\n \n-        return result;\n+\treturn result;\n     }\n \n     template< class String_type >\n-    String_type get_str_( typename String_type::const_iterator begin, \n-                       typename String_type::const_iterator end )\n+    String_type get_str_( typename String_type::const_iterator begin,\n+\t\t       typename String_type::const_iterator end )\n     {\n-        assert( end - begin >= 2 );\n+\tassert( end - begin >= 2 );\n \n-        typedef typename String_type::const_iterator Iter_type;\n+\ttypedef typename String_type::const_iterator Iter_type;\n \n-        Iter_type str_without_quotes( ++begin );\n-        Iter_type end_without_quotes( --end );\n+\tIter_type str_without_quotes( ++begin );\n+\tIter_type end_without_quotes( --end );\n \n-        return substitute_esc_chars< String_type >( str_without_quotes, end_without_quotes );\n+\treturn substitute_esc_chars< String_type >( str_without_quotes, end_without_quotes );\n     }\n \n     inline std::string get_str( std::string::const_iterator begin, std::string::const_iterator end )\n     {\n-        return get_str_< std::string >( begin, end );\n+\treturn get_str_< std::string >( begin, end );\n     }\n \n     inline std::wstring get_str( std::wstring::const_iterator begin, std::wstring::const_iterator end )\n     {\n-        return get_str_< std::wstring >( begin, end );\n+\treturn get_str_< std::wstring >( begin, end );\n     }\n-    \n+\n     template< class String_type, class Iter_type >\n     String_type get_str( Iter_type begin, Iter_type end )\n     {\n-        const String_type tmp( begin, end );  // convert multipass iterators to string iterators\n+\tconst String_type tmp( begin, end );  // convert multipass iterators to string iterators\n \n-        return get_str( tmp.begin(), tmp.end() );\n+\treturn get_str( tmp.begin(), tmp.end() );\n     }\n \n     // this class's methods get called by the spirit parse resulting\n@@ -193,169 +193,169 @@ namespace json_spirit\n     // NB Iter_type could be a std::string iterator, wstring iterator, a position iterator or a multipass iterator\n     //\n     template< class Value_type, class Iter_type >\n-    class Semantic_actions \n+    class Semantic_actions\n     {\n     public:\n \n-        typedef typename Value_type::Config_type Config_type;\n-        typedef typename Config_type::String_type String_type;\n-        typedef typename Config_type::Object_type Object_type;\n-        typedef typename Config_type::Array_type Array_type;\n-        typedef typename String_type::value_type Char_type;\n+\ttypedef typename Value_type::Config_type Config_type;\n+\ttypedef typename Config_type::String_type String_type;\n+\ttypedef typename Config_type::Object_type Object_type;\n+\ttypedef typename Config_type::Array_type Array_type;\n+\ttypedef typename String_type::value_type Char_type;\n+\n+\tSemantic_actions( Value_type& value )\n+\t:   value_( value )\n+\t,   current_p_( 0 )\n+\t{\n+\t}\n \n-        Semantic_actions( Value_type& value )\n-        :   value_( value )\n-        ,   current_p_( 0 )\n-        {\n-        }\n+\tvoid begin_obj( Char_type c )\n+\t{\n+\t    assert( c == '{' );\n \n-        void begin_obj( Char_type c )\n-        {\n-            assert( c == '{' );\n+\t    begin_compound< Object_type >();\n+\t}\n \n-            begin_compound< Object_type >();\n-        }\n+\tvoid end_obj( Char_type c )\n+\t{\n+\t    assert( c == '}' );\n \n-        void end_obj( Char_type c )\n-        {\n-            assert( c == '}' );\n+\t    end_compound();\n+\t}\n \n-            end_compound();\n-        }\n+\tvoid begin_array( Char_type c )\n+\t{\n+\t    assert( c == '[' );\n \n-        void begin_array( Char_type c )\n-        {\n-            assert( c == '[' );\n-     \n-            begin_compound< Array_type >();\n-        }\n+\t    begin_compound< Array_type >();\n+\t}\n \n-        void end_array( Char_type c )\n-        {\n-            assert( c == ']' );\n+\tvoid end_array( Char_type c )\n+\t{\n+\t    assert( c == ']' );\n \n-            end_compound();\n-        }\n+\t    end_compound();\n+\t}\n \n-        void new_name( Iter_type begin, Iter_type end )\n-        {\n-            assert( current_p_->type() == obj_type );\n+\tvoid new_name( Iter_type begin, Iter_type end )\n+\t{\n+\t    assert( current_p_->type() == obj_type );\n \n-            name_ = get_str< String_type >( begin, end );\n-        }\n+\t    name_ = get_str< String_type >( begin, end );\n+\t}\n \n-        void new_str( Iter_type begin, Iter_type end )\n-        {\n-            add_to_current( get_str< String_type >( begin, end ) );\n-        }\n+\tvoid new_str( Iter_type begin, Iter_type end )\n+\t{\n+\t    add_to_current( get_str< String_type >( begin, end ) );\n+\t}\n \n-        void new_true( Iter_type begin, Iter_type end )\n-        {\n-            assert( is_eq( begin, end, \"true\" ) );\n+\tvoid new_true( Iter_type begin, Iter_type end )\n+\t{\n+\t    assert( is_eq( begin, end, \"true\" ) );\n \n-            add_to_current( true );\n-        }\n+\t    add_to_current( true );\n+\t}\n \n-        void new_false( Iter_type begin, Iter_type end )\n-        {\n-            assert( is_eq( begin, end, \"false\" ) );\n+\tvoid new_false( Iter_type begin, Iter_type end )\n+\t{\n+\t    assert( is_eq( begin, end, \"false\" ) );\n \n-            add_to_current( false );\n-        }\n+\t    add_to_current( false );\n+\t}\n \n-        void new_null( Iter_type begin, Iter_type end )\n-        {\n-            assert( is_eq( begin, end, \"null\" ) );\n+\tvoid new_null( Iter_type begin, Iter_type end )\n+\t{\n+\t    assert( is_eq( begin, end, \"null\" ) );\n \n-            add_to_current( Value_type() );\n-        }\n+\t    add_to_current( Value_type() );\n+\t}\n \n-        void new_int( boost::int64_t i )\n-        {\n-            add_to_current( i );\n-        }\n+\tvoid new_int( boost::int64_t i )\n+\t{\n+\t    add_to_current( i );\n+\t}\n \n-        void new_uint64( boost::uint64_t ui )\n-        {\n-            add_to_current( ui );\n-        }\n+\tvoid new_uint64( boost::uint64_t ui )\n+\t{\n+\t    add_to_current( ui );\n+\t}\n \n-        void new_real( double d )\n-        {\n-            add_to_current( d );\n-        }\n+\tvoid new_real( double d )\n+\t{\n+\t    add_to_current( d );\n+\t}\n \n     private:\n \n-        Semantic_actions& operator=( const Semantic_actions& ); \n-                                    // to prevent \"assignment operator could not be generated\" warning\n-\n-        Value_type* add_first( const Value_type& value )\n-        {\n-            assert( current_p_ == 0 );\n-\n-            value_ = value;\n-            current_p_ = &value_;\n-            return current_p_;\n-        }\n-\n-        template< class Array_or_obj >\n-        void begin_compound()\n-        {\n-            if( current_p_ == 0 )\n-            {\n-                add_first( Array_or_obj() );\n-            }\n-            else\n-            {\n-                stack_.push_back( current_p_ );\n-\n-                Array_or_obj new_array_or_obj;   // avoid copy by building new array or object in place\n-\n-                current_p_ = add_to_current( new_array_or_obj );\n-            }\n-        }\n-\n-        void end_compound()\n-        {\n-            if( current_p_ != &value_ )\n-            {\n-                current_p_ = stack_.back();\n-                \n-                stack_.pop_back();\n-            }    \n-        }\n-\n-        Value_type* add_to_current( const Value_type& value )\n-        {\n-            if( current_p_ == 0 )\n-            {\n-                return add_first( value );\n-            }\n-            else if( current_p_->type() == array_type )\n-            {\n-                current_p_->get_array().push_back( value );\n-\n-                return &current_p_->get_array().back(); \n-            }\n-            \n-            assert( current_p_->type() == obj_type );\n-\n-            return &Config_type::add( current_p_->get_obj(), name_, value );\n-        }\n-\n-        Value_type& value_;             // this is the object or array that is being created\n-        Value_type* current_p_;         // the child object or array that is currently being constructed\n-\n-        std::vector< Value_type* > stack_;   // previous child objects and arrays\n-\n-        String_type name_;              // of current name/value pair\n+\tSemantic_actions& operator=( const Semantic_actions& );\n+\t\t\t\t    // to prevent \"assignment operator could not be generated\" warning\n+\n+\tValue_type* add_first( const Value_type& value )\n+\t{\n+\t    assert( current_p_ == 0 );\n+\n+\t    value_ = value;\n+\t    current_p_ = &value_;\n+\t    return current_p_;\n+\t}\n+\n+\ttemplate< class Array_or_obj >\n+\tvoid begin_compound()\n+\t{\n+\t    if( current_p_ == 0 )\n+\t    {\n+\t\tadd_first( Array_or_obj() );\n+\t    }\n+\t    else\n+\t    {\n+\t\tstack_.push_back( current_p_ );\n+\n+\t\tArray_or_obj new_array_or_obj;   // avoid copy by building new array or object in place\n+\n+\t\tcurrent_p_ = add_to_current( new_array_or_obj );\n+\t    }\n+\t}\n+\n+\tvoid end_compound()\n+\t{\n+\t    if( current_p_ != &value_ )\n+\t    {\n+\t\tcurrent_p_ = stack_.back();\n+\n+\t\tstack_.pop_back();\n+\t    }\n+\t}\n+\n+\tValue_type* add_to_current( const Value_type& value )\n+\t{\n+\t    if( current_p_ == 0 )\n+\t    {\n+\t\treturn add_first( value );\n+\t    }\n+\t    else if( current_p_->type() == array_type )\n+\t    {\n+\t\tcurrent_p_->get_array().push_back( value );\n+\n+\t\treturn &current_p_->get_array().back();\n+\t    }\n+\n+\t    assert( current_p_->type() == obj_type );\n+\n+\t    return &Config_type::add( current_p_->get_obj(), name_, value );\n+\t}\n+\n+\tValue_type& value_;             // this is the object or array that is being created\n+\tValue_type* current_p_;         // the child object or array that is currently being constructed\n+\n+\tstd::vector< Value_type* > stack_;   // previous child objects and arrays\n+\n+\tString_type name_;              // of current name/value pair\n     };\n \n     template< typename Iter_type >\n     void throw_error( spirit_namespace::position_iterator< Iter_type > i, const std::string& reason )\n     {\n-        throw Error_position( i.get_position().line, i.get_position().column, reason );\n+\tthrow Error_position( i.get_position().line, i.get_position().column, reason );\n     }\n \n     template< typename Iter_type >\n@@ -364,248 +364,248 @@ namespace json_spirit\n        throw reason;\n     }\n \n-    // the spirit grammer \n+    // the spirit grammer\n     //\n     template< class Value_type, class Iter_type >\n     class Json_grammer : public spirit_namespace::grammar< Json_grammer< Value_type, Iter_type > >\n     {\n     public:\n \n-        typedef Semantic_actions< Value_type, Iter_type > Semantic_actions_t;\n+\ttypedef Semantic_actions< Value_type, Iter_type > Semantic_actions_t;\n \n-        Json_grammer( Semantic_actions_t& semantic_actions )\n-        :   actions_( semantic_actions )\n-        {\n-        }\n+\tJson_grammer( Semantic_actions_t& semantic_actions )\n+\t:   actions_( semantic_actions )\n+\t{\n+\t}\n \n-        static void throw_not_value( Iter_type begin, Iter_type end )\n-        {\n+\tstatic void throw_not_value( Iter_type begin, Iter_type end )\n+\t{\n     \t    throw_error( begin, \"not a value\" );\n-        }\n+\t}\n \n-        static void throw_not_array( Iter_type begin, Iter_type end )\n-        {\n+\tstatic void throw_not_array( Iter_type begin, Iter_type end )\n+\t{\n     \t    throw_error( begin, \"not an array\" );\n-        }\n+\t}\n \n-        static void throw_not_object( Iter_type begin, Iter_type end )\n-        {\n+\tstatic void throw_not_object( Iter_type begin, Iter_type end )\n+\t{\n     \t    throw_error( begin, \"not an object\" );\n-        }\n+\t}\n \n-        static void throw_not_pair( Iter_type begin, Iter_type end )\n-        {\n+\tstatic void throw_not_pair( Iter_type begin, Iter_type end )\n+\t{\n     \t    throw_error( begin, \"not a pair\" );\n-        }\n+\t}\n \n-        static void throw_not_colon( Iter_type begin, Iter_type end )\n-        {\n+\tstatic void throw_not_colon( Iter_type begin, Iter_type end )\n+\t{\n     \t    throw_error( begin, \"no colon in pair\" );\n-        }\n+\t}\n \n-        static void throw_not_string( Iter_type begin, Iter_type end )\n-        {\n+\tstatic void throw_not_string( Iter_type begin, Iter_type end )\n+\t{\n     \t    throw_error( begin, \"not a string\" );\n-        }\n-\n-        template< typename ScannerT >\n-        class definition\n-        {\n-        public:\n-\n-            definition( const Json_grammer& self )\n-            {\n-                using namespace spirit_namespace;\n-\n-                typedef typename Value_type::String_type::value_type Char_type;\n-\n-                // first we convert the semantic action class methods to functors with the \n-                // parameter signature expected by spirit\n-\n-                typedef boost::function< void( Char_type )            > Char_action;\n-                typedef boost::function< void( Iter_type, Iter_type ) > Str_action;\n-                typedef boost::function< void( double )               > Real_action;\n-                typedef boost::function< void( boost::int64_t )       > Int_action;\n-                typedef boost::function< void( boost::uint64_t )      > Uint64_action;\n-\n-                Char_action   begin_obj  ( boost::bind( &Semantic_actions_t::begin_obj,   &self.actions_, _1 ) );\n-                Char_action   end_obj    ( boost::bind( &Semantic_actions_t::end_obj,     &self.actions_, _1 ) );\n-                Char_action   begin_array( boost::bind( &Semantic_actions_t::begin_array, &self.actions_, _1 ) );\n-                Char_action   end_array  ( boost::bind( &Semantic_actions_t::end_array,   &self.actions_, _1 ) );\n-                Str_action    new_name   ( boost::bind( &Semantic_actions_t::new_name,    &self.actions_, _1, _2 ) );\n-                Str_action    new_str    ( boost::bind( &Semantic_actions_t::new_str,     &self.actions_, _1, _2 ) );\n-                Str_action    new_true   ( boost::bind( &Semantic_actions_t::new_true,    &self.actions_, _1, _2 ) );\n-                Str_action    new_false  ( boost::bind( &Semantic_actions_t::new_false,   &self.actions_, _1, _2 ) );\n-                Str_action    new_null   ( boost::bind( &Semantic_actions_t::new_null,    &self.actions_, _1, _2 ) );\n-                Real_action   new_real   ( boost::bind( &Semantic_actions_t::new_real,    &self.actions_, _1 ) );\n-                Int_action    new_int    ( boost::bind( &Semantic_actions_t::new_int,     &self.actions_, _1 ) );\n-                Uint64_action new_uint64 ( boost::bind( &Semantic_actions_t::new_uint64,  &self.actions_, _1 ) );\n-\n-                // actual grammer\n-\n-                json_\n-                    = value_ | eps_p[ &throw_not_value ]\n-                    ;\n-\n-                value_\n-                    = string_[ new_str ] \n-                    | number_ \n-                    | object_ \n-                    | array_ \n-                    | str_p( \"true\" ) [ new_true  ] \n-                    | str_p( \"false\" )[ new_false ] \n-                    | str_p( \"null\" ) [ new_null  ]\n-                    ;\n-\n-                object_ \n-                    = ch_p('{')[ begin_obj ]\n-                    >> !members_\n-                    >> ( ch_p('}')[ end_obj ] | eps_p[ &throw_not_object ] )\n-                    ;\n-\n-                members_\n-                    = pair_ >> *( ',' >> pair_ )\n-                    ;\n-\n-                pair_\n-                    = string_[ new_name ]\n-                    >> ( ':' | eps_p[ &throw_not_colon ] )\n-                    >> ( value_ | eps_p[ &throw_not_value ] )\n-                    ;\n-\n-                array_\n-                    = ch_p('[')[ begin_array ]\n-                    >> !elements_\n-                    >> ( ch_p(']')[ end_array ] | eps_p[ &throw_not_array ] )\n-                    ;\n-\n-                elements_\n-                    = value_ >> *( ',' >> value_ )\n-                    ;\n-\n-                string_ \n-                    = lexeme_d // this causes white space inside a string to be retained\n-                      [\n-                          confix_p\n-                          ( \n-                              '\"', \n-                              *lex_escape_ch_p,\n-                              '\"'\n-                          ) \n-                      ]\n-                    ;\n-\n-                number_\n-                    = strict_real_p[ new_real   ] \n-                    | int64_p      [ new_int    ]\n-                    | uint64_p     [ new_uint64 ]\n-                    ;\n-            }\n-\n-            spirit_namespace::rule< ScannerT > json_, object_, members_, pair_, array_, elements_, value_, string_, number_;\n-\n-            const spirit_namespace::rule< ScannerT >& start() const { return json_; }\n-        };\n+\t}\n+\n+\ttemplate< typename ScannerT >\n+\tclass definition\n+\t{\n+\tpublic:\n+\n+\t    definition( const Json_grammer& self )\n+\t    {\n+\t\tusing namespace spirit_namespace;\n+\n+\t\ttypedef typename Value_type::String_type::value_type Char_type;\n+\n+\t\t// first we convert the semantic action class methods to functors with the\n+\t\t// parameter signature expected by spirit\n+\n+\t\ttypedef boost::function< void( Char_type )            > Char_action;\n+\t\ttypedef boost::function< void( Iter_type, Iter_type ) > Str_action;\n+\t\ttypedef boost::function< void( double )               > Real_action;\n+\t\ttypedef boost::function< void( boost::int64_t )       > Int_action;\n+\t\ttypedef boost::function< void( boost::uint64_t )      > Uint64_action;\n+\n+\t\tChar_action   begin_obj  ( boost::bind( &Semantic_actions_t::begin_obj,   &self.actions_, _1 ) );\n+\t\tChar_action   end_obj    ( boost::bind( &Semantic_actions_t::end_obj,     &self.actions_, _1 ) );\n+\t\tChar_action   begin_array( boost::bind( &Semantic_actions_t::begin_array, &self.actions_, _1 ) );\n+\t\tChar_action   end_array  ( boost::bind( &Semantic_actions_t::end_array,   &self.actions_, _1 ) );\n+\t\tStr_action    new_name   ( boost::bind( &Semantic_actions_t::new_name,    &self.actions_, _1, _2 ) );\n+\t\tStr_action    new_str    ( boost::bind( &Semantic_actions_t::new_str,     &self.actions_, _1, _2 ) );\n+\t\tStr_action    new_true   ( boost::bind( &Semantic_actions_t::new_true,    &self.actions_, _1, _2 ) );\n+\t\tStr_action    new_false  ( boost::bind( &Semantic_actions_t::new_false,   &self.actions_, _1, _2 ) );\n+\t\tStr_action    new_null   ( boost::bind( &Semantic_actions_t::new_null,    &self.actions_, _1, _2 ) );\n+\t\tReal_action   new_real   ( boost::bind( &Semantic_actions_t::new_real,    &self.actions_, _1 ) );\n+\t\tInt_action    new_int    ( boost::bind( &Semantic_actions_t::new_int,     &self.actions_, _1 ) );\n+\t\tUint64_action new_uint64 ( boost::bind( &Semantic_actions_t::new_uint64,  &self.actions_, _1 ) );\n+\n+\t\t// actual grammer\n+\n+\t\tjson_\n+\t\t    = value_ | eps_p[ &throw_not_value ]\n+\t\t    ;\n+\n+\t\tvalue_\n+\t\t    = string_[ new_str ]\n+\t\t    | number_\n+\t\t    | object_\n+\t\t    | array_\n+\t\t    | str_p( \"true\" ) [ new_true  ]\n+\t\t    | str_p( \"false\" )[ new_false ]\n+\t\t    | str_p( \"null\" ) [ new_null  ]\n+\t\t    ;\n+\n+\t\tobject_\n+\t\t    = ch_p('{')[ begin_obj ]\n+\t\t    >> !members_\n+\t\t    >> ( ch_p('}')[ end_obj ] | eps_p[ &throw_not_object ] )\n+\t\t    ;\n+\n+\t\tmembers_\n+\t\t    = pair_ >> *( ',' >> pair_ )\n+\t\t    ;\n+\n+\t\tpair_\n+\t\t    = string_[ new_name ]\n+\t\t    >> ( ':' | eps_p[ &throw_not_colon ] )\n+\t\t    >> ( value_ | eps_p[ &throw_not_value ] )\n+\t\t    ;\n+\n+\t\tarray_\n+\t\t    = ch_p('[')[ begin_array ]\n+\t\t    >> !elements_\n+\t\t    >> ( ch_p(']')[ end_array ] | eps_p[ &throw_not_array ] )\n+\t\t    ;\n+\n+\t\telements_\n+\t\t    = value_ >> *( ',' >> value_ )\n+\t\t    ;\n+\n+\t\tstring_\n+\t\t    = lexeme_d // this causes white space inside a string to be retained\n+\t\t      [\n+\t\t\t  confix_p\n+\t\t\t  (\n+\t\t\t      '\"',\n+\t\t\t      *lex_escape_ch_p,\n+\t\t\t      '\"'\n+\t\t\t  )\n+\t\t      ]\n+\t\t    ;\n+\n+\t\tnumber_\n+\t\t    = strict_real_p[ new_real   ]\n+\t\t    | int64_p      [ new_int    ]\n+\t\t    | uint64_p     [ new_uint64 ]\n+\t\t    ;\n+\t    }\n+\n+\t    spirit_namespace::rule< ScannerT > json_, object_, members_, pair_, array_, elements_, value_, string_, number_;\n+\n+\t    const spirit_namespace::rule< ScannerT >& start() const { return json_; }\n+\t};\n \n     private:\n \n-        Json_grammer& operator=( const Json_grammer& ); // to prevent \"assignment operator could not be generated\" warning\n+\tJson_grammer& operator=( const Json_grammer& ); // to prevent \"assignment operator could not be generated\" warning\n \n-        Semantic_actions_t& actions_;\n+\tSemantic_actions_t& actions_;\n     };\n \n     template< class Iter_type, class Value_type >\n     Iter_type read_range_or_throw( Iter_type begin, Iter_type end, Value_type& value )\n     {\n-        Semantic_actions< Value_type, Iter_type > semantic_actions( value );\n-     \n-        const spirit_namespace::parse_info< Iter_type > info = \n-                            spirit_namespace::parse( begin, end, \n-                                                    Json_grammer< Value_type, Iter_type >( semantic_actions ), \n-                                                    spirit_namespace::space_p );\n-\n-        if( !info.hit )\n-        {\n-            assert( false ); // in theory exception should already have been thrown\n-            throw_error( info.stop, \"error\" );\n-        }\n-\n-        return info.stop;\n+\tSemantic_actions< Value_type, Iter_type > semantic_actions( value );\n+\n+\tconst spirit_namespace::parse_info< Iter_type > info =\n+\t\t\t    spirit_namespace::parse( begin, end,\n+\t\t\t\t\t\t    Json_grammer< Value_type, Iter_type >( semantic_actions ),\n+\t\t\t\t\t\t    spirit_namespace::space_p );\n+\n+\tif( !info.hit )\n+\t{\n+\t    assert( false ); // in theory exception should already have been thrown\n+\t    throw_error( info.stop, \"error\" );\n+\t}\n+\n+\treturn info.stop;\n     }\n \n     template< class Iter_type, class Value_type >\n     void add_posn_iter_and_read_range_or_throw( Iter_type begin, Iter_type end, Value_type& value )\n     {\n-        typedef spirit_namespace::position_iterator< Iter_type > Posn_iter_t;\n+\ttypedef spirit_namespace::position_iterator< Iter_type > Posn_iter_t;\n+\n+\tconst Posn_iter_t posn_begin( begin, end );\n+\tconst Posn_iter_t posn_end( end, end );\n \n-        const Posn_iter_t posn_begin( begin, end );\n-        const Posn_iter_t posn_end( end, end );\n-     \n-        read_range_or_throw( posn_begin, posn_end, value );\n+\tread_range_or_throw( posn_begin, posn_end, value );\n     }\n \n     template< class Iter_type, class Value_type >\n     bool read_range( Iter_type& begin, Iter_type end, Value_type& value )\n     {\n-        try\n-        {\n-            begin = read_range_or_throw( begin, end, value );\n-\n-            return true;\n-        }\n-        catch( ... )\n-        {\n-            return false;\n-        }\n+\ttry\n+\t{\n+\t    begin = read_range_or_throw( begin, end, value );\n+\n+\t    return true;\n+\t}\n+\tcatch( ... )\n+\t{\n+\t    return false;\n+\t}\n     }\n \n     template< class String_type, class Value_type >\n     void read_string_or_throw( const String_type& s, Value_type& value )\n     {\n-        add_posn_iter_and_read_range_or_throw( s.begin(), s.end(), value );\n+\tadd_posn_iter_and_read_range_or_throw( s.begin(), s.end(), value );\n     }\n \n     template< class String_type, class Value_type >\n     bool read_string( const String_type& s, Value_type& value )\n     {\n-        typename String_type::const_iterator begin = s.begin();\n+\ttypename String_type::const_iterator begin = s.begin();\n \n-        return read_range( begin, s.end(), value );\n+\treturn read_range( begin, s.end(), value );\n     }\n \n     template< class Istream_type >\n     struct Multi_pass_iters\n     {\n-        typedef typename Istream_type::char_type Char_type;\n-        typedef std::istream_iterator< Char_type, Char_type > istream_iter;\n-        typedef spirit_namespace::multi_pass< istream_iter > Mp_iter;\n+\ttypedef typename Istream_type::char_type Char_type;\n+\ttypedef std::istream_iterator< Char_type, Char_type > istream_iter;\n+\ttypedef spirit_namespace::multi_pass< istream_iter > Mp_iter;\n \n-        Multi_pass_iters( Istream_type& is )\n-        {\n-            is.unsetf( std::ios::skipws );\n+\tMulti_pass_iters( Istream_type& is )\n+\t{\n+\t    is.unsetf( std::ios::skipws );\n \n-            begin_ = spirit_namespace::make_multi_pass( istream_iter( is ) );\n-            end_   = spirit_namespace::make_multi_pass( istream_iter() );\n-        }\n+\t    begin_ = spirit_namespace::make_multi_pass( istream_iter( is ) );\n+\t    end_   = spirit_namespace::make_multi_pass( istream_iter() );\n+\t}\n \n-        Mp_iter begin_;\n-        Mp_iter end_;\n+\tMp_iter begin_;\n+\tMp_iter end_;\n     };\n \n     template< class Istream_type, class Value_type >\n     bool read_stream( Istream_type& is, Value_type& value )\n     {\n-        Multi_pass_iters< Istream_type > mp_iters( is );\n+\tMulti_pass_iters< Istream_type > mp_iters( is );\n \n-        return read_range( mp_iters.begin_, mp_iters.end_, value );\n+\treturn read_range( mp_iters.begin_, mp_iters.end_, value );\n     }\n \n     template< class Istream_type, class Value_type >\n     void read_stream_or_throw( Istream_type& is, Value_type& value )\n     {\n-        const Multi_pass_iters< Istream_type > mp_iters( is );\n+\tconst Multi_pass_iters< Istream_type > mp_iters( is );\n \n-        add_posn_iter_and_read_range_or_throw( mp_iters.begin_, mp_iters.end_, value );\n+\tadd_posn_iter_and_read_range_or_throw( mp_iters.begin_, mp_iters.end_, value );\n     }\n }\n "
      },
      {
        "sha": "73410558fcbaa3f875ee92d3e1d13527df688a46",
        "filename": "src/json/json_spirit_stream_reader.h",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_stream_reader.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_stream_reader.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_stream_reader.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -15,55 +15,55 @@\n namespace json_spirit\n {\n     // these classes allows you to read multiple top level contiguous values from a stream,\n-    // the normal stream read functions have a bug that prevent multiple top level values \n+    // the normal stream read functions have a bug that prevent multiple top level values\n     // from being read unless they are separated by spaces\n \n     template< class Istream_type, class Value_type >\n     class Stream_reader\n     {\n     public:\n \n-        Stream_reader( Istream_type& is )\n-        :   iters_( is )\n-        {\n-        }\n+\tStream_reader( Istream_type& is )\n+\t:   iters_( is )\n+\t{\n+\t}\n \n-        bool read_next( Value_type& value )\n-        {\n-            return read_range( iters_.begin_, iters_.end_, value );\n-        }\n+\tbool read_next( Value_type& value )\n+\t{\n+\t    return read_range( iters_.begin_, iters_.end_, value );\n+\t}\n \n     private:\n \n-        typedef Multi_pass_iters< Istream_type > Mp_iters;\n+\ttypedef Multi_pass_iters< Istream_type > Mp_iters;\n \n-        Mp_iters iters_;\n+\tMp_iters iters_;\n     };\n \n     template< class Istream_type, class Value_type >\n     class Stream_reader_thrower\n     {\n     public:\n \n-        Stream_reader_thrower( Istream_type& is )\n-        :   iters_( is )\n-        ,    posn_begin_( iters_.begin_, iters_.end_ )\n-        ,    posn_end_( iters_.end_, iters_.end_ )\n-        {\n-        }\n+\tStream_reader_thrower( Istream_type& is )\n+\t:   iters_( is )\n+\t,    posn_begin_( iters_.begin_, iters_.end_ )\n+\t,    posn_end_( iters_.end_, iters_.end_ )\n+\t{\n+\t}\n \n-        void read_next( Value_type& value )\n-        {\n-            posn_begin_ = read_range_or_throw( posn_begin_, posn_end_, value );\n-        }\n+\tvoid read_next( Value_type& value )\n+\t{\n+\t    posn_begin_ = read_range_or_throw( posn_begin_, posn_end_, value );\n+\t}\n \n     private:\n \n-        typedef Multi_pass_iters< Istream_type > Mp_iters;\n-        typedef spirit_namespace::position_iterator< typename Mp_iters::Mp_iter > Posn_iter_t;\n+\ttypedef Multi_pass_iters< Istream_type > Mp_iters;\n+\ttypedef spirit_namespace::position_iterator< typename Mp_iters::Mp_iter > Posn_iter_t;\n \n-        Mp_iters iters_;\n-        Posn_iter_t posn_begin_, posn_end_;\n+\tMp_iters iters_;\n+\tPosn_iter_t posn_begin_, posn_end_;\n     };\n }\n "
      },
      {
        "sha": "70cf4fd2cbb4698a5769bcc6b99849a437d12288",
        "filename": "src/json/json_spirit_utils.h",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_utils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_utils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_utils.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -14,27 +14,27 @@\n #include <map>\n \n namespace json_spirit\n-{ \n+{\n     template< class Obj_t, class Map_t >\n     void obj_to_map( const Obj_t& obj, Map_t& mp_obj )\n     {\n-        mp_obj.clear();\n+\tmp_obj.clear();\n \n-        for( typename Obj_t::const_iterator i = obj.begin(); i != obj.end(); ++i )\n-        {\n-            mp_obj[ i->name_ ] = i->value_;\n-        }\n+\tfor( typename Obj_t::const_iterator i = obj.begin(); i != obj.end(); ++i )\n+\t{\n+\t    mp_obj[ i->name_ ] = i->value_;\n+\t}\n     }\n \n     template< class Obj_t, class Map_t >\n     void map_to_obj( const Map_t& mp_obj, Obj_t& obj )\n     {\n-        obj.clear();\n+\tobj.clear();\n \n-        for( typename Map_t::const_iterator i = mp_obj.begin(); i != mp_obj.end(); ++i )\n-        {\n-            obj.push_back( typename Obj_t::value_type( i->first, i->second ) );\n-        }\n+\tfor( typename Map_t::const_iterator i = mp_obj.begin(); i != mp_obj.end(); ++i )\n+\t{\n+\t    obj.push_back( typename Obj_t::value_type( i->first, i->second ) );\n+\t}\n     }\n \n     typedef std::map< std::string, Value > Mapped_obj;\n@@ -46,15 +46,15 @@ namespace json_spirit\n     template< class Object_type, class String_type >\n     const typename Object_type::value_type::Value_type& find_value( const Object_type& obj, const String_type& name )\n     {\n-        for( typename Object_type::const_iterator i = obj.begin(); i != obj.end(); ++i )\n-        {\n-            if( i->name_ == name )\n-            {\n-                return i->value_;\n-            }\n-        }\n-\n-        return Object_type::value_type::Value_type::null;\n+\tfor( typename Object_type::const_iterator i = obj.begin(); i != obj.end(); ++i )\n+\t{\n+\t    if( i->name_ == name )\n+\t    {\n+\t\treturn i->value_;\n+\t    }\n+\t}\n+\n+\treturn Object_type::value_type::Value_type::null;\n     }\n }\n "
      },
      {
        "sha": "e8fe546b39eb7ce22d867bccdf6dde5434c05eb1",
        "filename": "src/json/json_spirit_value.h",
        "status": "modified",
        "additions": 207,
        "deletions": 207,
        "changes": 414,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_value.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_value.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_value.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -16,121 +16,121 @@\n #include <cassert>\n #include <sstream>\n #include <stdexcept>\n-#include <boost/config.hpp> \n-#include <boost/cstdint.hpp> \n-#include <boost/shared_ptr.hpp> \n-#include <boost/variant.hpp> \n+#include <boost/config.hpp>\n+#include <boost/cstdint.hpp>\n+#include <boost/shared_ptr.hpp>\n+#include <boost/variant.hpp>\n \n namespace json_spirit\n {\n     enum Value_type{ obj_type, array_type, str_type, bool_type, int_type, real_type, null_type };\n     static const char* Value_type_name[]={\"obj\", \"array\", \"str\", \"bool\", \"int\", \"real\", \"null\"};\n \n     template< class Config >    // Config determines whether the value uses std::string or std::wstring and\n-                                // whether JSON Objects are represented as vectors or maps\n+\t\t\t\t// whether JSON Objects are represented as vectors or maps\n     class Value_impl\n     {\n     public:\n \n-        typedef Config Config_type;\n-        typedef typename Config::String_type String_type;\n-        typedef typename Config::Object_type Object;\n-        typedef typename Config::Array_type Array;\n-        typedef typename String_type::const_pointer Const_str_ptr;  // eg const char*\n+\ttypedef Config Config_type;\n+\ttypedef typename Config::String_type String_type;\n+\ttypedef typename Config::Object_type Object;\n+\ttypedef typename Config::Array_type Array;\n+\ttypedef typename String_type::const_pointer Const_str_ptr;  // eg const char*\n \n-        Value_impl();  // creates null value\n-        Value_impl( Const_str_ptr      value ); \n-        Value_impl( const String_type& value );\n-        Value_impl( const Object&      value );\n-        Value_impl( const Array&       value );\n-        Value_impl( bool               value );\n-        Value_impl( int                value );\n-        Value_impl( boost::int64_t     value );\n-        Value_impl( boost::uint64_t    value );\n-        Value_impl( double             value );\n+\tValue_impl();  // creates null value\n+\tValue_impl( Const_str_ptr      value );\n+\tValue_impl( const String_type& value );\n+\tValue_impl( const Object&      value );\n+\tValue_impl( const Array&       value );\n+\tValue_impl( bool               value );\n+\tValue_impl( int                value );\n+\tValue_impl( boost::int64_t     value );\n+\tValue_impl( boost::uint64_t    value );\n+\tValue_impl( double             value );\n \n-        Value_impl( const Value_impl& other );\n+\tValue_impl( const Value_impl& other );\n \n-        bool operator==( const Value_impl& lhs ) const;\n+\tbool operator==( const Value_impl& lhs ) const;\n \n-        Value_impl& operator=( const Value_impl& lhs );\n+\tValue_impl& operator=( const Value_impl& lhs );\n \n-        Value_type type() const;\n+\tValue_type type() const;\n \n-        bool is_uint64() const;\n-        bool is_null() const;\n+\tbool is_uint64() const;\n+\tbool is_null() const;\n \n-        const String_type& get_str()    const;\n-        const Object&      get_obj()    const;\n-        const Array&       get_array()  const;\n-        bool               get_bool()   const;\n-        int                get_int()    const;\n-        boost::int64_t     get_int64()  const;\n-        boost::uint64_t    get_uint64() const;\n-        double             get_real()   const;\n+\tconst String_type& get_str()    const;\n+\tconst Object&      get_obj()    const;\n+\tconst Array&       get_array()  const;\n+\tbool               get_bool()   const;\n+\tint                get_int()    const;\n+\tboost::int64_t     get_int64()  const;\n+\tboost::uint64_t    get_uint64() const;\n+\tdouble             get_real()   const;\n \n-        Object& get_obj();\n-        Array&  get_array();\n+\tObject& get_obj();\n+\tArray&  get_array();\n \n-        template< typename T > T get_value() const;  // example usage: int    i = value.get_value< int >();\n-                                                     // or             double d = value.get_value< double >();\n+\ttemplate< typename T > T get_value() const;  // example usage: int    i = value.get_value< int >();\n+\t\t\t\t\t\t     // or             double d = value.get_value< double >();\n \n-        static const Value_impl null;\n+\tstatic const Value_impl null;\n \n     private:\n \n-        void check_type( const Value_type vtype ) const;\n+\tvoid check_type( const Value_type vtype ) const;\n \n-        typedef boost::variant< String_type, \n-                                boost::recursive_wrapper< Object >, boost::recursive_wrapper< Array >, \n-                                bool, boost::int64_t, double > Variant;\n+\ttypedef boost::variant< String_type,\n+\t\t\t\tboost::recursive_wrapper< Object >, boost::recursive_wrapper< Array >,\n+\t\t\t\tbool, boost::int64_t, double > Variant;\n \n-        Value_type type_;\n-        Variant v_;\n-        bool is_uint64_;\n+\tValue_type type_;\n+\tVariant v_;\n+\tbool is_uint64_;\n     };\n \n     // vector objects\n \n     template< class Config >\n     struct Pair_impl\n     {\n-        typedef typename Config::String_type String_type;\n-        typedef typename Config::Value_type Value_type;\n+\ttypedef typename Config::String_type String_type;\n+\ttypedef typename Config::Value_type Value_type;\n \n-        Pair_impl( const String_type& name, const Value_type& value );\n+\tPair_impl( const String_type& name, const Value_type& value );\n \n-        bool operator==( const Pair_impl& lhs ) const;\n+\tbool operator==( const Pair_impl& lhs ) const;\n \n-        String_type name_;\n-        Value_type value_;\n+\tString_type name_;\n+\tValue_type value_;\n     };\n \n     template< class String >\n     struct Config_vector\n     {\n-        typedef String String_type;\n-        typedef Value_impl< Config_vector > Value_type;\n-        typedef Pair_impl < Config_vector > Pair_type;\n-        typedef std::vector< Value_type > Array_type;\n-        typedef std::vector< Pair_type > Object_type;\n-\n-        static Value_type& add( Object_type& obj, const String_type& name, const Value_type& value )\n-        {\n-            obj.push_back( Pair_type( name , value ) );\n-\n-            return obj.back().value_;\n-        }\n-                \n-        static String_type get_name( const Pair_type& pair )\n-        {\n-            return pair.name_;\n-        }\n-                \n-        static Value_type get_value( const Pair_type& pair )\n-        {\n-            return pair.value_;\n-        }\n+\ttypedef String String_type;\n+\ttypedef Value_impl< Config_vector > Value_type;\n+\ttypedef Pair_impl < Config_vector > Pair_type;\n+\ttypedef std::vector< Value_type > Array_type;\n+\ttypedef std::vector< Pair_type > Object_type;\n+\n+\tstatic Value_type& add( Object_type& obj, const String_type& name, const Value_type& value )\n+\t{\n+\t    obj.push_back( Pair_type( name , value ) );\n+\n+\t    return obj.back().value_;\n+\t}\n+\n+\tstatic String_type get_name( const Pair_type& pair )\n+\t{\n+\t    return pair.name_;\n+\t}\n+\n+\tstatic Value_type get_value( const Pair_type& pair )\n+\t{\n+\t    return pair.value_;\n+\t}\n     };\n \n     // typedefs for ASCII\n@@ -159,26 +159,26 @@ namespace json_spirit\n     template< class String >\n     struct Config_map\n     {\n-        typedef String String_type;\n-        typedef Value_impl< Config_map > Value_type;\n-        typedef std::vector< Value_type > Array_type;\n-        typedef std::map< String_type, Value_type > Object_type;\n-        typedef typename Object_type::value_type Pair_type;\n-\n-        static Value_type& add( Object_type& obj, const String_type& name, const Value_type& value )\n-        {\n-            return obj[ name ] = value;\n-        }\n-                \n-        static String_type get_name( const Pair_type& pair )\n-        {\n-            return pair.first;\n-        }\n-                \n-        static Value_type get_value( const Pair_type& pair )\n-        {\n-            return pair.second;\n-        }\n+\ttypedef String String_type;\n+\ttypedef Value_impl< Config_map > Value_type;\n+\ttypedef std::vector< Value_type > Array_type;\n+\ttypedef std::map< String_type, Value_type > Object_type;\n+\ttypedef typename Object_type::value_type Pair_type;\n+\n+\tstatic Value_type& add( Object_type& obj, const String_type& name, const Value_type& value )\n+\t{\n+\t    return obj[ name ] = value;\n+\t}\n+\n+\tstatic String_type get_name( const Pair_type& pair )\n+\t{\n+\t    return pair.first;\n+\t}\n+\n+\tstatic Value_type get_value( const Pair_type& pair )\n+\t{\n+\t    return pair.second;\n+\t}\n     };\n \n     // typedefs for ASCII\n@@ -298,141 +298,141 @@ namespace json_spirit\n     template< class Config >\n     Value_impl< Config >& Value_impl< Config >::operator=( const Value_impl& lhs )\n     {\n-        Value_impl tmp( lhs );\n+\tValue_impl tmp( lhs );\n \n-        std::swap( type_, tmp.type_ );\n-        std::swap( v_, tmp.v_ );\n-        std::swap( is_uint64_, tmp.is_uint64_ );\n+\tstd::swap( type_, tmp.type_ );\n+\tstd::swap( v_, tmp.v_ );\n+\tstd::swap( is_uint64_, tmp.is_uint64_ );\n \n-        return *this;\n+\treturn *this;\n     }\n \n     template< class Config >\n     bool Value_impl< Config >::operator==( const Value_impl& lhs ) const\n     {\n-        if( this == &lhs ) return true;\n+\tif( this == &lhs ) return true;\n \n-        if( type() != lhs.type() ) return false;\n+\tif( type() != lhs.type() ) return false;\n \n-        return v_ == lhs.v_; \n+\treturn v_ == lhs.v_;\n     }\n \n     template< class Config >\n     Value_type Value_impl< Config >::type() const\n     {\n-        return type_;\n+\treturn type_;\n     }\n \n     template< class Config >\n     bool Value_impl< Config >::is_uint64() const\n     {\n-        return is_uint64_;\n+\treturn is_uint64_;\n     }\n \n     template< class Config >\n     bool Value_impl< Config >::is_null() const\n     {\n-        return type() == null_type;\n+\treturn type() == null_type;\n     }\n \n     template< class Config >\n     void Value_impl< Config >::check_type( const Value_type vtype ) const\n     {\n-        if( type() != vtype ) \n-        {\n-            std::ostringstream os;\n+\tif( type() != vtype )\n+\t{\n+\t    std::ostringstream os;\n \n-            ///// Bitcoin: Tell the types by name instead of by number\n-            os << \"value is type \" << Value_type_name[type()] << \", expected \" << Value_type_name[vtype];\n+\t    ///// Bitcoin: Tell the types by name instead of by number\n+\t    os << \"value is type \" << Value_type_name[type()] << \", expected \" << Value_type_name[vtype];\n \n-            throw std::runtime_error( os.str() );\n-        }\n+\t    throw std::runtime_error( os.str() );\n+\t}\n     }\n \n     template< class Config >\n     const typename Config::String_type& Value_impl< Config >::get_str() const\n     {\n-        check_type(  str_type );\n+\tcheck_type(  str_type );\n \n-        return *boost::get< String_type >( &v_ );\n+\treturn *boost::get< String_type >( &v_ );\n     }\n \n     template< class Config >\n     const typename Value_impl< Config >::Object& Value_impl< Config >::get_obj() const\n     {\n-        check_type( obj_type );\n+\tcheck_type( obj_type );\n \n-        return *boost::get< Object >( &v_ );\n+\treturn *boost::get< Object >( &v_ );\n     }\n-     \n+\n     template< class Config >\n     const typename Value_impl< Config >::Array& Value_impl< Config >::get_array() const\n     {\n-        check_type(  array_type );\n+\tcheck_type(  array_type );\n \n-        return *boost::get< Array >( &v_ );\n+\treturn *boost::get< Array >( &v_ );\n     }\n-     \n+\n     template< class Config >\n     bool Value_impl< Config >::get_bool() const\n     {\n-        check_type(  bool_type );\n+\tcheck_type(  bool_type );\n \n-        return boost::get< bool >( v_ );\n+\treturn boost::get< bool >( v_ );\n     }\n-     \n+\n     template< class Config >\n     int Value_impl< Config >::get_int() const\n     {\n-        check_type(  int_type );\n+\tcheck_type(  int_type );\n \n-        return static_cast< int >( get_int64() );\n+\treturn static_cast< int >( get_int64() );\n     }\n-    \n+\n     template< class Config >\n     boost::int64_t Value_impl< Config >::get_int64() const\n     {\n-        check_type(  int_type );\n+\tcheck_type(  int_type );\n \n-        return boost::get< boost::int64_t >( v_ );\n+\treturn boost::get< boost::int64_t >( v_ );\n     }\n-    \n+\n     template< class Config >\n     boost::uint64_t Value_impl< Config >::get_uint64() const\n     {\n-        check_type(  int_type );\n+\tcheck_type(  int_type );\n \n-        return static_cast< boost::uint64_t >( get_int64() );\n+\treturn static_cast< boost::uint64_t >( get_int64() );\n     }\n \n     template< class Config >\n     double Value_impl< Config >::get_real() const\n     {\n-        if( type() == int_type )\n-        {\n-            return is_uint64() ? static_cast< double >( get_uint64() )\n-                               : static_cast< double >( get_int64() );\n-        }\n+\tif( type() == int_type )\n+\t{\n+\t    return is_uint64() ? static_cast< double >( get_uint64() )\n+\t\t\t       : static_cast< double >( get_int64() );\n+\t}\n \n-        check_type(  real_type );\n+\tcheck_type(  real_type );\n \n-        return boost::get< double >( v_ );\n+\treturn boost::get< double >( v_ );\n     }\n \n     template< class Config >\n     typename Value_impl< Config >::Object& Value_impl< Config >::get_obj()\n     {\n-        check_type(  obj_type );\n+\tcheck_type(  obj_type );\n \n-        return *boost::get< Object >( &v_ );\n+\treturn *boost::get< Object >( &v_ );\n     }\n \n     template< class Config >\n     typename Value_impl< Config >::Array& Value_impl< Config >::get_array()\n     {\n-        check_type(  array_type );\n+\tcheck_type(  array_type );\n \n-        return *boost::get< Array >( &v_ );\n+\treturn *boost::get< Array >( &v_ );\n     }\n \n     template< class Config >\n@@ -445,89 +445,89 @@ namespace json_spirit\n     template< class Config >\n     bool Pair_impl< Config >::operator==( const Pair_impl< Config >& lhs ) const\n     {\n-        if( this == &lhs ) return true;\n+\tif( this == &lhs ) return true;\n \n-        return ( name_ == lhs.name_ ) && ( value_ == lhs.value_ );\n+\treturn ( name_ == lhs.name_ ) && ( value_ == lhs.value_ );\n     }\n \n     // converts a C string, ie. 8 bit char array, to a string object\n     //\n     template < class String_type >\n     String_type to_str( const char* c_str )\n     {\n-        String_type result;\n+\tString_type result;\n \n-        for( const char* p = c_str; *p != 0; ++p )\n-        {\n-            result += *p;\n-        }\n+\tfor( const char* p = c_str; *p != 0; ++p )\n+\t{\n+\t    result += *p;\n+\t}\n \n-        return result;\n+\treturn result;\n     }\n \n     //\n \n     namespace internal_\n     {\n-        template< typename T >\n-        struct Type_to_type\n-        {\n-        };\n-\n-        template< class Value > \n-        int get_value( const Value& value, Type_to_type< int > )\n-        {\n-            return value.get_int();\n-        }\n-       \n-        template< class Value > \n-        boost::int64_t get_value( const Value& value, Type_to_type< boost::int64_t > )\n-        {\n-            return value.get_int64();\n-        }\n-       \n-        template< class Value > \n-        boost::uint64_t get_value( const Value& value, Type_to_type< boost::uint64_t > )\n-        {\n-            return value.get_uint64();\n-        }\n-       \n-        template< class Value > \n-        double get_value( const Value& value, Type_to_type< double > )\n-        {\n-            return value.get_real();\n-        }\n-       \n-        template< class Value > \n-        typename Value::String_type get_value( const Value& value, Type_to_type< typename Value::String_type > )\n-        {\n-            return value.get_str();\n-        }\n-       \n-        template< class Value > \n-        typename Value::Array get_value( const Value& value, Type_to_type< typename Value::Array > )\n-        {\n-            return value.get_array();\n-        }\n-       \n-        template< class Value > \n-        typename Value::Object get_value( const Value& value, Type_to_type< typename Value::Object > )\n-        {\n-            return value.get_obj();\n-        }\n-       \n-        template< class Value > \n-        bool get_value( const Value& value, Type_to_type< bool > )\n-        {\n-            return value.get_bool();\n-        }\n-    }\n-\n-    template< class Config >\n-    template< typename T > \n+\ttemplate< typename T >\n+\tstruct Type_to_type\n+\t{\n+\t};\n+\n+\ttemplate< class Value >\n+\tint get_value( const Value& value, Type_to_type< int > )\n+\t{\n+\t    return value.get_int();\n+\t}\n+\n+\ttemplate< class Value >\n+\tboost::int64_t get_value( const Value& value, Type_to_type< boost::int64_t > )\n+\t{\n+\t    return value.get_int64();\n+\t}\n+\n+\ttemplate< class Value >\n+\tboost::uint64_t get_value( const Value& value, Type_to_type< boost::uint64_t > )\n+\t{\n+\t    return value.get_uint64();\n+\t}\n+\n+\ttemplate< class Value >\n+\tdouble get_value( const Value& value, Type_to_type< double > )\n+\t{\n+\t    return value.get_real();\n+\t}\n+\n+\ttemplate< class Value >\n+\ttypename Value::String_type get_value( const Value& value, Type_to_type< typename Value::String_type > )\n+\t{\n+\t    return value.get_str();\n+\t}\n+\n+\ttemplate< class Value >\n+\ttypename Value::Array get_value( const Value& value, Type_to_type< typename Value::Array > )\n+\t{\n+\t    return value.get_array();\n+\t}\n+\n+\ttemplate< class Value >\n+\ttypename Value::Object get_value( const Value& value, Type_to_type< typename Value::Object > )\n+\t{\n+\t    return value.get_obj();\n+\t}\n+\n+\ttemplate< class Value >\n+\tbool get_value( const Value& value, Type_to_type< bool > )\n+\t{\n+\t    return value.get_bool();\n+\t}\n+    }\n+\n+    template< class Config >\n+    template< typename T >\n     T Value_impl< Config >::get_value() const\n     {\n-        return internal_::get_value( *this, internal_::Type_to_type< T >() );\n+\treturn internal_::get_value( *this, internal_::Type_to_type< T >() );\n     }\n }\n "
      },
      {
        "sha": "108a07f4d2fabfba9277736fb6b79f91f386ecf2",
        "filename": "src/json/json_spirit_writer.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_writer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_writer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_writer.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -15,7 +15,7 @@\n \n namespace json_spirit\n {\n-    // functions to convert JSON Values to text, \n+    // functions to convert JSON Values to text,\n     // the \"formatted\" versions add whitespace to format the output nicely\n \n     void         write          ( const Value& value, std::ostream&  os );"
      },
      {
        "sha": "3b658908f9a981cbb55ada9b9125154d82150f64",
        "filename": "src/json/json_spirit_writer_template.h",
        "status": "modified",
        "additions": 170,
        "deletions": 170,
        "changes": 340,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_writer_template.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/json/json_spirit_writer_template.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/json/json_spirit_writer_template.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -16,78 +16,78 @@ namespace json_spirit\n {\n     inline char to_hex_char( unsigned int c )\n     {\n-        assert( c <= 0xF );\n+\tassert( c <= 0xF );\n \n-        const char ch = static_cast< char >( c );\n+\tconst char ch = static_cast< char >( c );\n \n-        if( ch < 10 ) return '0' + ch;\n+\tif( ch < 10 ) return '0' + ch;\n \n-        return 'A' - 10 + ch;\n+\treturn 'A' - 10 + ch;\n     }\n \n     template< class String_type >\n     String_type non_printable_to_string( unsigned int c )\n     {\n-        typedef typename String_type::value_type Char_type;\n+\ttypedef typename String_type::value_type Char_type;\n \n-        String_type result( 6, '\\\\' );\n+\tString_type result( 6, '\\\\' );\n \n-        result[1] = 'u';\n+\tresult[1] = 'u';\n \n-        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n-        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n-        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n-        result[ 2 ] = to_hex_char( c & 0x000F );\n+\tresult[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n+\tresult[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n+\tresult[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n+\tresult[ 2 ] = to_hex_char( c & 0x000F );\n \n-        return result;\n+\treturn result;\n     }\n \n     template< typename Char_type, class String_type >\n     bool add_esc_char( Char_type c, String_type& s )\n     {\n-        switch( c )\n-        {\n-            case '\"':  s += to_str< String_type >( \"\\\\\\\"\" ); return true;\n-            case '\\\\': s += to_str< String_type >( \"\\\\\\\\\" ); return true;\n-            case '\\b': s += to_str< String_type >( \"\\\\b\"  ); return true;\n-            case '\\f': s += to_str< String_type >( \"\\\\f\"  ); return true;\n-            case '\\n': s += to_str< String_type >( \"\\\\n\"  ); return true;\n-            case '\\r': s += to_str< String_type >( \"\\\\r\"  ); return true;\n-            case '\\t': s += to_str< String_type >( \"\\\\t\"  ); return true;\n-        }\n-\n-        return false;\n+\tswitch( c )\n+\t{\n+\t    case '\"':  s += to_str< String_type >( \"\\\\\\\"\" ); return true;\n+\t    case '\\\\': s += to_str< String_type >( \"\\\\\\\\\" ); return true;\n+\t    case '\\b': s += to_str< String_type >( \"\\\\b\"  ); return true;\n+\t    case '\\f': s += to_str< String_type >( \"\\\\f\"  ); return true;\n+\t    case '\\n': s += to_str< String_type >( \"\\\\n\"  ); return true;\n+\t    case '\\r': s += to_str< String_type >( \"\\\\r\"  ); return true;\n+\t    case '\\t': s += to_str< String_type >( \"\\\\t\"  ); return true;\n+\t}\n+\n+\treturn false;\n     }\n \n     template< class String_type >\n     String_type add_esc_chars( const String_type& s )\n     {\n-        typedef typename String_type::const_iterator Iter_type;\n-        typedef typename String_type::value_type     Char_type;\n+\ttypedef typename String_type::const_iterator Iter_type;\n+\ttypedef typename String_type::value_type     Char_type;\n \n-        String_type result;\n+\tString_type result;\n \n-        const Iter_type end( s.end() );\n+\tconst Iter_type end( s.end() );\n \n-        for( Iter_type i = s.begin(); i != end; ++i )\n-        {\n-            const Char_type c( *i );\n+\tfor( Iter_type i = s.begin(); i != end; ++i )\n+\t{\n+\t    const Char_type c( *i );\n \n-            if( add_esc_char( c, result ) ) continue;\n+\t    if( add_esc_char( c, result ) ) continue;\n \n-            const wint_t unsigned_c( ( c >= 0 ) ? c : 256 + c );\n+\t    const wint_t unsigned_c( ( c >= 0 ) ? c : 256 + c );\n \n-            if( iswprint( unsigned_c ) )\n-            {\n-                result += c;\n-            }\n-            else\n-            {\n-                result += non_printable_to_string< String_type >( unsigned_c );\n-            }\n-        }\n+\t    if( iswprint( unsigned_c ) )\n+\t    {\n+\t\tresult += c;\n+\t    }\n+\t    else\n+\t    {\n+\t\tresult += non_printable_to_string< String_type >( unsigned_c );\n+\t    }\n+\t}\n \n-        return result;\n+\treturn result;\n     }\n \n     // this class generates the JSON text,\n@@ -96,152 +96,152 @@ namespace json_spirit\n     template< class Value_type, class Ostream_type >\n     class Generator\n     {\n-        typedef typename Value_type::Config_type Config_type;\n-        typedef typename Config_type::String_type String_type;\n-        typedef typename Config_type::Object_type Object_type;\n-        typedef typename Config_type::Array_type Array_type;\n-        typedef typename String_type::value_type Char_type;\n-        typedef typename Object_type::value_type Obj_member_type;\n+\ttypedef typename Value_type::Config_type Config_type;\n+\ttypedef typename Config_type::String_type String_type;\n+\ttypedef typename Config_type::Object_type Object_type;\n+\ttypedef typename Config_type::Array_type Array_type;\n+\ttypedef typename String_type::value_type Char_type;\n+\ttypedef typename Object_type::value_type Obj_member_type;\n \n     public:\n \n-        Generator( const Value_type& value, Ostream_type& os, bool pretty )\n-        :   os_( os )\n-        ,   indentation_level_( 0 )\n-        ,   pretty_( pretty )\n-        {\n-            output( value );\n-        }\n+\tGenerator( const Value_type& value, Ostream_type& os, bool pretty )\n+\t:   os_( os )\n+\t,   indentation_level_( 0 )\n+\t,   pretty_( pretty )\n+\t{\n+\t    output( value );\n+\t}\n \n     private:\n \n-        void output( const Value_type& value )\n-        {\n-            switch( value.type() )\n-            {\n-                case obj_type:   output( value.get_obj() );   break;\n-                case array_type: output( value.get_array() ); break;\n-                case str_type:   output( value.get_str() );   break;\n-                case bool_type:  output( value.get_bool() );  break;\n-                case int_type:   output_int( value );         break;\n-\n-                /// Bitcoin: Added std::fixed and changed precision from 16 to 8\n-                case real_type:  os_ << std::showpoint << std::fixed << std::setprecision(8)\n-                                     << value.get_real();     break;\n-\n-                case null_type:  os_ << \"null\";               break;\n-                default: assert( false );\n-            }\n-        }\n-\n-        void output( const Object_type& obj )\n-        {\n-            output_array_or_obj( obj, '{', '}' );\n-        }\n-\n-        void output( const Array_type& arr )\n-        {\n-            output_array_or_obj( arr, '[', ']' );\n-        }\n-\n-        void output( const Obj_member_type& member )\n-        {\n-            output( Config_type::get_name( member ) ); space(); \n-            os_ << ':'; space(); \n-            output( Config_type::get_value( member ) );\n-        }\n-\n-        void output_int( const Value_type& value )\n-        {\n-            if( value.is_uint64() )\n-            {\n-                os_ << value.get_uint64();\n-            }\n-            else\n-            {\n-               os_ << value.get_int64();\n-            }\n-        }\n-\n-        void output( const String_type& s )\n-        {\n-            os_ << '\"' << add_esc_chars( s ) << '\"';\n-        }\n-\n-        void output( bool b )\n-        {\n-            os_ << to_str< String_type >( b ? \"true\" : \"false\" );\n-        }\n-\n-        template< class T >\n-        void output_array_or_obj( const T& t, Char_type start_char, Char_type end_char )\n-        {\n-            os_ << start_char; new_line();\n-\n-            ++indentation_level_;\n-            \n-            for( typename T::const_iterator i = t.begin(); i != t.end(); ++i )\n-            {\n-                indent(); output( *i );\n-\n-                typename T::const_iterator next = i;\n-\n-                if( ++next != t.end())\n-                {\n-                    os_ << ',';\n-                }\n-\n-                new_line();\n-            }\n-\n-            --indentation_level_;\n-\n-            indent(); os_ << end_char;\n-        }\n-        \n-        void indent()\n-        {\n-            if( !pretty_ ) return;\n-\n-            for( int i = 0; i < indentation_level_; ++i )\n-            { \n-                os_ << \"    \";\n-            }\n-        }\n-\n-        void space()\n-        {\n-            if( pretty_ ) os_ << ' ';\n-        }\n-\n-        void new_line()\n-        {\n-            if( pretty_ ) os_ << '\\n';\n-        }\n-\n-        Generator& operator=( const Generator& ); // to prevent \"assignment operator could not be generated\" warning\n-\n-        Ostream_type& os_;\n-        int indentation_level_;\n-        bool pretty_;\n+\tvoid output( const Value_type& value )\n+\t{\n+\t    switch( value.type() )\n+\t    {\n+\t\tcase obj_type:   output( value.get_obj() );   break;\n+\t\tcase array_type: output( value.get_array() ); break;\n+\t\tcase str_type:   output( value.get_str() );   break;\n+\t\tcase bool_type:  output( value.get_bool() );  break;\n+\t\tcase int_type:   output_int( value );         break;\n+\n+\t\t/// Bitcoin: Added std::fixed and changed precision from 16 to 8\n+\t\tcase real_type:  os_ << std::showpoint << std::fixed << std::setprecision(8)\n+\t\t\t\t     << value.get_real();     break;\n+\n+\t\tcase null_type:  os_ << \"null\";               break;\n+\t\tdefault: assert( false );\n+\t    }\n+\t}\n+\n+\tvoid output( const Object_type& obj )\n+\t{\n+\t    output_array_or_obj( obj, '{', '}' );\n+\t}\n+\n+\tvoid output( const Array_type& arr )\n+\t{\n+\t    output_array_or_obj( arr, '[', ']' );\n+\t}\n+\n+\tvoid output( const Obj_member_type& member )\n+\t{\n+\t    output( Config_type::get_name( member ) ); space();\n+\t    os_ << ':'; space();\n+\t    output( Config_type::get_value( member ) );\n+\t}\n+\n+\tvoid output_int( const Value_type& value )\n+\t{\n+\t    if( value.is_uint64() )\n+\t    {\n+\t\tos_ << value.get_uint64();\n+\t    }\n+\t    else\n+\t    {\n+\t       os_ << value.get_int64();\n+\t    }\n+\t}\n+\n+\tvoid output( const String_type& s )\n+\t{\n+\t    os_ << '\"' << add_esc_chars( s ) << '\"';\n+\t}\n+\n+\tvoid output( bool b )\n+\t{\n+\t    os_ << to_str< String_type >( b ? \"true\" : \"false\" );\n+\t}\n+\n+\ttemplate< class T >\n+\tvoid output_array_or_obj( const T& t, Char_type start_char, Char_type end_char )\n+\t{\n+\t    os_ << start_char; new_line();\n+\n+\t    ++indentation_level_;\n+\n+\t    for( typename T::const_iterator i = t.begin(); i != t.end(); ++i )\n+\t    {\n+\t\tindent(); output( *i );\n+\n+\t\ttypename T::const_iterator next = i;\n+\n+\t\tif( ++next != t.end())\n+\t\t{\n+\t\t    os_ << ',';\n+\t\t}\n+\n+\t\tnew_line();\n+\t    }\n+\n+\t    --indentation_level_;\n+\n+\t    indent(); os_ << end_char;\n+\t}\n+\n+\tvoid indent()\n+\t{\n+\t    if( !pretty_ ) return;\n+\n+\t    for( int i = 0; i < indentation_level_; ++i )\n+\t    {\n+\t\tos_ << \"    \";\n+\t    }\n+\t}\n+\n+\tvoid space()\n+\t{\n+\t    if( pretty_ ) os_ << ' ';\n+\t}\n+\n+\tvoid new_line()\n+\t{\n+\t    if( pretty_ ) os_ << '\\n';\n+\t}\n+\n+\tGenerator& operator=( const Generator& ); // to prevent \"assignment operator could not be generated\" warning\n+\n+\tOstream_type& os_;\n+\tint indentation_level_;\n+\tbool pretty_;\n     };\n \n     template< class Value_type, class Ostream_type >\n     void write_stream( const Value_type& value, Ostream_type& os, bool pretty )\n     {\n-        Generator< Value_type, Ostream_type >( value, os, pretty );\n+\tGenerator< Value_type, Ostream_type >( value, os, pretty );\n     }\n \n     template< class Value_type >\n     typename Value_type::String_type write_string( const Value_type& value, bool pretty )\n     {\n-        typedef typename Value_type::String_type::value_type Char_type;\n+\ttypedef typename Value_type::String_type::value_type Char_type;\n \n-        std::basic_ostringstream< Char_type > os;\n+\tstd::basic_ostringstream< Char_type > os;\n \n-        write_stream( value, os, pretty );\n+\twrite_stream( value, os, pretty );\n \n-        return os.str();\n+\treturn os.str();\n     }\n }\n "
      },
      {
        "sha": "2fffccb39cd6b76945facea0fbb3f11c9e6d2b8e",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 63,
        "deletions": 63,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -49,120 +49,120 @@ class CKey\n public:\n     CKey()\n     {\n-        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-        if (pkey == NULL)\n-            throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n-        fSet = false;\n+\tpkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+\tif (pkey == NULL)\n+\t    throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n+\tfSet = false;\n     }\n \n     CKey(const CKey& b)\n     {\n-        pkey = EC_KEY_dup(b.pkey);\n-        if (pkey == NULL)\n-            throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n-        fSet = b.fSet;\n+\tpkey = EC_KEY_dup(b.pkey);\n+\tif (pkey == NULL)\n+\t    throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n+\tfSet = b.fSet;\n     }\n \n     CKey& operator=(const CKey& b)\n     {\n-        if (!EC_KEY_copy(pkey, b.pkey))\n-            throw key_error(\"CKey::operator=(const CKey&) : EC_KEY_copy failed\");\n-        fSet = b.fSet;\n-        return (*this);\n+\tif (!EC_KEY_copy(pkey, b.pkey))\n+\t    throw key_error(\"CKey::operator=(const CKey&) : EC_KEY_copy failed\");\n+\tfSet = b.fSet;\n+\treturn (*this);\n     }\n \n     ~CKey()\n     {\n-        EC_KEY_free(pkey);\n+\tEC_KEY_free(pkey);\n     }\n \n     bool IsNull() const\n     {\n-        return !fSet;\n+\treturn !fSet;\n     }\n \n     void MakeNewKey()\n     {\n-        if (!EC_KEY_generate_key(pkey))\n-            throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n-        fSet = true;\n+\tif (!EC_KEY_generate_key(pkey))\n+\t    throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n+\tfSet = true;\n     }\n \n     bool SetPrivKey(const CPrivKey& vchPrivKey)\n     {\n-        const unsigned char* pbegin = &vchPrivKey[0];\n-        if (!d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n-            return false;\n-        fSet = true;\n-        return true;\n+\tconst unsigned char* pbegin = &vchPrivKey[0];\n+\tif (!d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n+\t    return false;\n+\tfSet = true;\n+\treturn true;\n     }\n \n     CPrivKey GetPrivKey() const\n     {\n-        unsigned int nSize = i2d_ECPrivateKey(pkey, NULL);\n-        if (!nSize)\n-            throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n-        CPrivKey vchPrivKey(nSize, 0);\n-        unsigned char* pbegin = &vchPrivKey[0];\n-        if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n-            throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n-        return vchPrivKey;\n+\tunsigned int nSize = i2d_ECPrivateKey(pkey, NULL);\n+\tif (!nSize)\n+\t    throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n+\tCPrivKey vchPrivKey(nSize, 0);\n+\tunsigned char* pbegin = &vchPrivKey[0];\n+\tif (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n+\t    throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n+\treturn vchPrivKey;\n     }\n \n     bool SetPubKey(const vector<unsigned char>& vchPubKey)\n     {\n-        const unsigned char* pbegin = &vchPubKey[0];\n-        if (!o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))\n-            return false;\n-        fSet = true;\n-        return true;\n+\tconst unsigned char* pbegin = &vchPubKey[0];\n+\tif (!o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))\n+\t    return false;\n+\tfSet = true;\n+\treturn true;\n     }\n \n     vector<unsigned char> GetPubKey() const\n     {\n-        unsigned int nSize = i2o_ECPublicKey(pkey, NULL);\n-        if (!nSize)\n-            throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n-        vector<unsigned char> vchPubKey(nSize, 0);\n-        unsigned char* pbegin = &vchPubKey[0];\n-        if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n-            throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n-        return vchPubKey;\n+\tunsigned int nSize = i2o_ECPublicKey(pkey, NULL);\n+\tif (!nSize)\n+\t    throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n+\tvector<unsigned char> vchPubKey(nSize, 0);\n+\tunsigned char* pbegin = &vchPubKey[0];\n+\tif (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n+\t    throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n+\treturn vchPubKey;\n     }\n \n     bool Sign(uint256 hash, vector<unsigned char>& vchSig)\n     {\n-        vchSig.clear();\n-        unsigned char pchSig[10000];\n-        unsigned int nSize = 0;\n-        if (!ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), pchSig, &nSize, pkey))\n-            return false;\n-        vchSig.resize(nSize);\n-        memcpy(&vchSig[0], pchSig, nSize);\n-        return true;\n+\tvchSig.clear();\n+\tunsigned char pchSig[10000];\n+\tunsigned int nSize = 0;\n+\tif (!ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), pchSig, &nSize, pkey))\n+\t    return false;\n+\tvchSig.resize(nSize);\n+\tmemcpy(&vchSig[0], pchSig, nSize);\n+\treturn true;\n     }\n \n     bool Verify(uint256 hash, const vector<unsigned char>& vchSig)\n     {\n-        // -1 = error, 0 = bad sig, 1 = good\n-        if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n-            return false;\n-        return true;\n+\t// -1 = error, 0 = bad sig, 1 = good\n+\tif (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n+\t    return false;\n+\treturn true;\n     }\n \n     static bool Sign(const CPrivKey& vchPrivKey, uint256 hash, vector<unsigned char>& vchSig)\n     {\n-        CKey key;\n-        if (!key.SetPrivKey(vchPrivKey))\n-            return false;\n-        return key.Sign(hash, vchSig);\n+\tCKey key;\n+\tif (!key.SetPrivKey(vchPrivKey))\n+\t    return false;\n+\treturn key.Sign(hash, vchSig);\n     }\n \n     static bool Verify(const vector<unsigned char>& vchPubKey, uint256 hash, const vector<unsigned char>& vchSig)\n     {\n-        CKey key;\n-        if (!key.SetPubKey(vchPubKey))\n-            return false;\n-        return key.Verify(hash, vchSig);\n+\tCKey key;\n+\tif (!key.SetPubKey(vchPubKey))\n+\t    return false;\n+\treturn key.Verify(hash, vchSig);\n     }\n };"
      },
      {
        "sha": "4f162e3e1f2ec3f04b8476195c79be4aecb4ad38",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2254,
        "deletions": 2254,
        "changes": 4508,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5"
      },
      {
        "sha": "df90a0ecf5c0bf5dc4b7a99d36bf598d8ae26f64",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 874,
        "deletions": 874,
        "changes": 1748,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -121,14 +121,14 @@ class CDiskTxPos\n \n     CDiskTxPos()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n     {\n-        nFile = nFileIn;\n-        nBlockPos = nBlockPosIn;\n-        nTxPos = nTxPosIn;\n+\tnFile = nFileIn;\n+\tnBlockPos = nBlockPosIn;\n+\tnTxPos = nTxPosIn;\n     }\n \n     IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )\n@@ -137,27 +137,27 @@ class CDiskTxPos\n \n     friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)\n     {\n-        return (a.nFile     == b.nFile &&\n-                a.nBlockPos == b.nBlockPos &&\n-                a.nTxPos    == b.nTxPos);\n+\treturn (a.nFile     == b.nFile &&\n+\t\ta.nBlockPos == b.nBlockPos &&\n+\t\ta.nTxPos    == b.nTxPos);\n     }\n \n     friend bool operator!=(const CDiskTxPos& a, const CDiskTxPos& b)\n     {\n-        return !(a == b);\n+\treturn !(a == b);\n     }\n \n     string ToString() const\n     {\n-        if (IsNull())\n-            return strprintf(\"null\");\n-        else\n-            return strprintf(\"(nFile=%d, nBlockPos=%d, nTxPos=%d)\", nFile, nBlockPos, nTxPos);\n+\tif (IsNull())\n+\t    return strprintf(\"null\");\n+\telse\n+\t    return strprintf(\"(nFile=%d, nBlockPos=%d, nTxPos=%d)\", nFile, nBlockPos, nTxPos);\n     }\n \n     void print() const\n     {\n-        printf(\"%s\", ToString().c_str());\n+\tprintf(\"%s\", ToString().c_str());\n     }\n };\n \n@@ -193,27 +193,27 @@ class COutPoint\n \n     friend bool operator<(const COutPoint& a, const COutPoint& b)\n     {\n-        return (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));\n+\treturn (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));\n     }\n \n     friend bool operator==(const COutPoint& a, const COutPoint& b)\n     {\n-        return (a.hash == b.hash && a.n == b.n);\n+\treturn (a.hash == b.hash && a.n == b.n);\n     }\n \n     friend bool operator!=(const COutPoint& a, const COutPoint& b)\n     {\n-        return !(a == b);\n+\treturn !(a == b);\n     }\n \n     string ToString() const\n     {\n-        return strprintf(\"COutPoint(%s, %d)\", hash.ToString().substr(0,10).c_str(), n);\n+\treturn strprintf(\"COutPoint(%s, %d)\", hash.ToString().substr(0,10).c_str(), n);\n     }\n \n     void print() const\n     {\n-        printf(\"%s\\n\", ToString().c_str());\n+\tprintf(\"%s\\n\", ToString().c_str());\n     }\n };\n \n@@ -234,65 +234,65 @@ class CTxIn\n \n     CTxIn()\n     {\n-        nSequence = UINT_MAX;\n+\tnSequence = UINT_MAX;\n     }\n \n     explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=UINT_MAX)\n     {\n-        prevout = prevoutIn;\n-        scriptSig = scriptSigIn;\n-        nSequence = nSequenceIn;\n+\tprevout = prevoutIn;\n+\tscriptSig = scriptSigIn;\n+\tnSequence = nSequenceIn;\n     }\n \n     CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=UINT_MAX)\n     {\n-        prevout = COutPoint(hashPrevTx, nOut);\n-        scriptSig = scriptSigIn;\n-        nSequence = nSequenceIn;\n+\tprevout = COutPoint(hashPrevTx, nOut);\n+\tscriptSig = scriptSigIn;\n+\tnSequence = nSequenceIn;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(prevout);\n-        READWRITE(scriptSig);\n-        READWRITE(nSequence);\n+\tREADWRITE(prevout);\n+\tREADWRITE(scriptSig);\n+\tREADWRITE(nSequence);\n     )\n \n     bool IsFinal() const\n     {\n-        return (nSequence == UINT_MAX);\n+\treturn (nSequence == UINT_MAX);\n     }\n \n     friend bool operator==(const CTxIn& a, const CTxIn& b)\n     {\n-        return (a.prevout   == b.prevout &&\n-                a.scriptSig == b.scriptSig &&\n-                a.nSequence == b.nSequence);\n+\treturn (a.prevout   == b.prevout &&\n+\t\ta.scriptSig == b.scriptSig &&\n+\t\ta.nSequence == b.nSequence);\n     }\n \n     friend bool operator!=(const CTxIn& a, const CTxIn& b)\n     {\n-        return !(a == b);\n+\treturn !(a == b);\n     }\n \n     string ToString() const\n     {\n-        string str;\n-        str += strprintf(\"CTxIn(\");\n-        str += prevout.ToString();\n-        if (prevout.IsNull())\n-            str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n-        else\n-            str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n-        if (nSequence != UINT_MAX)\n-            str += strprintf(\", nSequence=%u\", nSequence);\n-        str += \")\";\n-        return str;\n+\tstring str;\n+\tstr += strprintf(\"CTxIn(\");\n+\tstr += prevout.ToString();\n+\tif (prevout.IsNull())\n+\t    str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n+\telse\n+\t    str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n+\tif (nSequence != UINT_MAX)\n+\t    str += strprintf(\", nSequence=%u\", nSequence);\n+\tstr += \")\";\n+\treturn str;\n     }\n \n     void print() const\n     {\n-        printf(\"%s\\n\", ToString().c_str());\n+\tprintf(\"%s\\n\", ToString().c_str());\n     }\n \n     bool IsMine() const;\n@@ -314,88 +314,88 @@ class CTxOut\n \n     CTxOut()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     CTxOut(int64 nValueIn, CScript scriptPubKeyIn)\n     {\n-        nValue = nValueIn;\n-        scriptPubKey = scriptPubKeyIn;\n+\tnValue = nValueIn;\n+\tscriptPubKey = scriptPubKeyIn;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(nValue);\n-        READWRITE(scriptPubKey);\n+\tREADWRITE(nValue);\n+\tREADWRITE(scriptPubKey);\n     )\n \n     void SetNull()\n     {\n-        nValue = -1;\n-        scriptPubKey.clear();\n+\tnValue = -1;\n+\tscriptPubKey.clear();\n     }\n \n     bool IsNull()\n     {\n-        return (nValue == -1);\n+\treturn (nValue == -1);\n     }\n \n     uint256 GetHash() const\n     {\n-        return SerializeHash(*this);\n+\treturn SerializeHash(*this);\n     }\n \n     bool IsMine() const\n     {\n-        return ::IsMine(scriptPubKey);\n+\treturn ::IsMine(scriptPubKey);\n     }\n \n     int64 GetCredit() const\n     {\n-        if (!MoneyRange(nValue))\n-            throw runtime_error(\"CTxOut::GetCredit() : value out of range\");\n-        return (IsMine() ? nValue : 0);\n+\tif (!MoneyRange(nValue))\n+\t    throw runtime_error(\"CTxOut::GetCredit() : value out of range\");\n+\treturn (IsMine() ? nValue : 0);\n     }\n \n     bool IsChange() const\n     {\n-        // On a debit transaction, a txout that's mine but isn't in the address book is change\n-        vector<unsigned char> vchPubKey;\n-        if (ExtractPubKey(scriptPubKey, true, vchPubKey))\n-            CRITICAL_BLOCK(cs_mapAddressBook)\n-                if (!mapAddressBook.count(PubKeyToAddress(vchPubKey)))\n-                    return true;\n-        return false;\n+\t// On a debit transaction, a txout that's mine but isn't in the address book is change\n+\tvector<unsigned char> vchPubKey;\n+\tif (ExtractPubKey(scriptPubKey, true, vchPubKey))\n+\t    CRITICAL_BLOCK(cs_mapAddressBook)\n+\t\tif (!mapAddressBook.count(PubKeyToAddress(vchPubKey)))\n+\t\t    return true;\n+\treturn false;\n     }\n \n     int64 GetChange() const\n     {\n-        if (!MoneyRange(nValue))\n-            throw runtime_error(\"CTxOut::GetChange() : value out of range\");\n-        return (IsChange() ? nValue : 0);\n+\tif (!MoneyRange(nValue))\n+\t    throw runtime_error(\"CTxOut::GetChange() : value out of range\");\n+\treturn (IsChange() ? nValue : 0);\n     }\n \n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n     {\n-        return (a.nValue       == b.nValue &&\n-                a.scriptPubKey == b.scriptPubKey);\n+\treturn (a.nValue       == b.nValue &&\n+\t\ta.scriptPubKey == b.scriptPubKey);\n     }\n \n     friend bool operator!=(const CTxOut& a, const CTxOut& b)\n     {\n-        return !(a == b);\n+\treturn !(a == b);\n     }\n \n     string ToString() const\n     {\n-        if (scriptPubKey.size() < 6)\n-            return \"CTxOut(error)\";\n-        return strprintf(\"CTxOut(nValue=%\"PRI64d\".%08\"PRI64d\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n+\tif (scriptPubKey.size() < 6)\n+\t    return \"CTxOut(error)\";\n+\treturn strprintf(\"CTxOut(nValue=%\"PRI64d\".%08\"PRI64d\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n     }\n \n     void print() const\n     {\n-        printf(\"%s\\n\", ToString().c_str());\n+\tprintf(\"%s\\n\", ToString().c_str());\n     }\n };\n \n@@ -417,276 +417,276 @@ class CTransaction\n \n     CTransaction()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(this->nVersion);\n-        nVersion = this->nVersion;\n-        READWRITE(vin);\n-        READWRITE(vout);\n-        READWRITE(nLockTime);\n+\tREADWRITE(this->nVersion);\n+\tnVersion = this->nVersion;\n+\tREADWRITE(vin);\n+\tREADWRITE(vout);\n+\tREADWRITE(nLockTime);\n     )\n \n     void SetNull()\n     {\n-        nVersion = 1;\n-        vin.clear();\n-        vout.clear();\n-        nLockTime = 0;\n+\tnVersion = 1;\n+\tvin.clear();\n+\tvout.clear();\n+\tnLockTime = 0;\n     }\n \n     bool IsNull() const\n     {\n-        return (vin.empty() && vout.empty());\n+\treturn (vin.empty() && vout.empty());\n     }\n \n     uint256 GetHash() const\n     {\n-        return SerializeHash(*this);\n+\treturn SerializeHash(*this);\n     }\n \n     bool IsFinal(int nBlockHeight=0, int64 nBlockTime=0) const\n     {\n-        // Time based nLockTime implemented in 0.1.6\n-        if (nLockTime == 0)\n-            return true;\n-        if (nBlockHeight == 0)\n-            nBlockHeight = nBestHeight;\n-        if (nBlockTime == 0)\n-            nBlockTime = GetAdjustedTime();\n-        if ((int64)nLockTime < (nLockTime < 500000000 ? (int64)nBlockHeight : nBlockTime))\n-            return true;\n-        foreach(const CTxIn& txin, vin)\n-            if (!txin.IsFinal())\n-                return false;\n-        return true;\n+\t// Time based nLockTime implemented in 0.1.6\n+\tif (nLockTime == 0)\n+\t    return true;\n+\tif (nBlockHeight == 0)\n+\t    nBlockHeight = nBestHeight;\n+\tif (nBlockTime == 0)\n+\t    nBlockTime = GetAdjustedTime();\n+\tif ((int64)nLockTime < (nLockTime < 500000000 ? (int64)nBlockHeight : nBlockTime))\n+\t    return true;\n+\tforeach(const CTxIn& txin, vin)\n+\t    if (!txin.IsFinal())\n+\t\treturn false;\n+\treturn true;\n     }\n \n     bool IsNewerThan(const CTransaction& old) const\n     {\n-        if (vin.size() != old.vin.size())\n-            return false;\n-        for (int i = 0; i < vin.size(); i++)\n-            if (vin[i].prevout != old.vin[i].prevout)\n-                return false;\n-\n-        bool fNewer = false;\n-        unsigned int nLowest = UINT_MAX;\n-        for (int i = 0; i < vin.size(); i++)\n-        {\n-            if (vin[i].nSequence != old.vin[i].nSequence)\n-            {\n-                if (vin[i].nSequence <= nLowest)\n-                {\n-                    fNewer = false;\n-                    nLowest = vin[i].nSequence;\n-                }\n-                if (old.vin[i].nSequence < nLowest)\n-                {\n-                    fNewer = true;\n-                    nLowest = old.vin[i].nSequence;\n-                }\n-            }\n-        }\n-        return fNewer;\n+\tif (vin.size() != old.vin.size())\n+\t    return false;\n+\tfor (int i = 0; i < vin.size(); i++)\n+\t    if (vin[i].prevout != old.vin[i].prevout)\n+\t\treturn false;\n+\n+\tbool fNewer = false;\n+\tunsigned int nLowest = UINT_MAX;\n+\tfor (int i = 0; i < vin.size(); i++)\n+\t{\n+\t    if (vin[i].nSequence != old.vin[i].nSequence)\n+\t    {\n+\t\tif (vin[i].nSequence <= nLowest)\n+\t\t{\n+\t\t    fNewer = false;\n+\t\t    nLowest = vin[i].nSequence;\n+\t\t}\n+\t\tif (old.vin[i].nSequence < nLowest)\n+\t\t{\n+\t\t    fNewer = true;\n+\t\t    nLowest = old.vin[i].nSequence;\n+\t\t}\n+\t    }\n+\t}\n+\treturn fNewer;\n     }\n \n     bool IsCoinBase() const\n     {\n-        return (vin.size() == 1 && vin[0].prevout.IsNull());\n+\treturn (vin.size() == 1 && vin[0].prevout.IsNull());\n     }\n \n     int GetSigOpCount() const\n     {\n-        int n = 0;\n-        foreach(const CTxIn& txin, vin)\n-            n += txin.scriptSig.GetSigOpCount();\n-        foreach(const CTxOut& txout, vout)\n-            n += txout.scriptPubKey.GetSigOpCount();\n-        return n;\n+\tint n = 0;\n+\tforeach(const CTxIn& txin, vin)\n+\t    n += txin.scriptSig.GetSigOpCount();\n+\tforeach(const CTxOut& txout, vout)\n+\t    n += txout.scriptPubKey.GetSigOpCount();\n+\treturn n;\n     }\n \n     bool IsStandard() const\n     {\n-        foreach(const CTxIn& txin, vin)\n-            if (!txin.scriptSig.IsPushOnly())\n-                return error(\"nonstandard txin: %s\", txin.scriptSig.ToString().c_str());\n-        foreach(const CTxOut& txout, vout)\n-            if (!::IsStandard(txout.scriptPubKey))\n-                return error(\"nonstandard txout: %s\", txout.scriptPubKey.ToString().c_str());\n-        return true;\n+\tforeach(const CTxIn& txin, vin)\n+\t    if (!txin.scriptSig.IsPushOnly())\n+\t\treturn error(\"nonstandard txin: %s\", txin.scriptSig.ToString().c_str());\n+\tforeach(const CTxOut& txout, vout)\n+\t    if (!::IsStandard(txout.scriptPubKey))\n+\t\treturn error(\"nonstandard txout: %s\", txout.scriptPubKey.ToString().c_str());\n+\treturn true;\n     }\n \n     bool IsMine() const\n     {\n-        foreach(const CTxOut& txout, vout)\n-            if (txout.IsMine())\n-                return true;\n-        return false;\n+\tforeach(const CTxOut& txout, vout)\n+\t    if (txout.IsMine())\n+\t\treturn true;\n+\treturn false;\n     }\n \n     bool IsFromMe() const\n     {\n-        return (GetDebit() > 0);\n+\treturn (GetDebit() > 0);\n     }\n \n     int64 GetDebit() const\n     {\n-        int64 nDebit = 0;\n-        foreach(const CTxIn& txin, vin)\n-        {\n-            nDebit += txin.GetDebit();\n-            if (!MoneyRange(nDebit))\n-                throw runtime_error(\"CTransaction::GetDebit() : value out of range\");\n-        }\n-        return nDebit;\n+\tint64 nDebit = 0;\n+\tforeach(const CTxIn& txin, vin)\n+\t{\n+\t    nDebit += txin.GetDebit();\n+\t    if (!MoneyRange(nDebit))\n+\t\tthrow runtime_error(\"CTransaction::GetDebit() : value out of range\");\n+\t}\n+\treturn nDebit;\n     }\n \n     int64 GetCredit() const\n     {\n-        int64 nCredit = 0;\n-        foreach(const CTxOut& txout, vout)\n-        {\n-            nCredit += txout.GetCredit();\n-            if (!MoneyRange(nCredit))\n-                throw runtime_error(\"CTransaction::GetCredit() : value out of range\");\n-        }\n-        return nCredit;\n+\tint64 nCredit = 0;\n+\tforeach(const CTxOut& txout, vout)\n+\t{\n+\t    nCredit += txout.GetCredit();\n+\t    if (!MoneyRange(nCredit))\n+\t\tthrow runtime_error(\"CTransaction::GetCredit() : value out of range\");\n+\t}\n+\treturn nCredit;\n     }\n \n     int64 GetChange() const\n     {\n-        if (IsCoinBase())\n-            return 0;\n-        int64 nChange = 0;\n-        foreach(const CTxOut& txout, vout)\n-        {\n-            nChange += txout.GetChange();\n-            if (!MoneyRange(nChange))\n-                throw runtime_error(\"CTransaction::GetChange() : value out of range\");\n-        }\n-        return nChange;\n+\tif (IsCoinBase())\n+\t    return 0;\n+\tint64 nChange = 0;\n+\tforeach(const CTxOut& txout, vout)\n+\t{\n+\t    nChange += txout.GetChange();\n+\t    if (!MoneyRange(nChange))\n+\t\tthrow runtime_error(\"CTransaction::GetChange() : value out of range\");\n+\t}\n+\treturn nChange;\n     }\n \n     int64 GetValueOut() const\n     {\n-        int64 nValueOut = 0;\n-        foreach(const CTxOut& txout, vout)\n-        {\n-            nValueOut += txout.nValue;\n-            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n-                throw runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n-        }\n-        return nValueOut;\n+\tint64 nValueOut = 0;\n+\tforeach(const CTxOut& txout, vout)\n+\t{\n+\t    nValueOut += txout.nValue;\n+\t    if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n+\t\tthrow runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n+\t}\n+\treturn nValueOut;\n     }\n \n     static bool AllowFree(double dPriority)\n     {\n-        // Large (in bytes) low-priority (new, small-coin) transactions\n-        // need a fee.\n-        return dPriority > COIN * 144 / 250;\n+\t// Large (in bytes) low-priority (new, small-coin) transactions\n+\t// need a fee.\n+\treturn dPriority > COIN * 144 / 250;\n     }\n \n     int64 GetMinFee(unsigned int nBlockSize=1, bool fAllowFree=true) const\n     {\n-        // Base fee is 1 cent per kilobyte\n-        unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK);\n-        unsigned int nNewBlockSize = nBlockSize + nBytes;\n-        int64 nMinFee = (1 + (int64)nBytes / 1000) * MIN_TX_FEE;\n-\n-        if (fAllowFree)\n-        {\n-            if (nBlockSize == 1)\n-            {\n-                // Transactions under 10K are free\n-                // (about 4500bc if made of 50bc inputs)\n-                if (nBytes < 10000)\n-                    nMinFee = 0;\n-            }\n-            else\n-            {\n-                // Free transaction area\n-                if (nNewBlockSize < 27000)\n-                    nMinFee = 0;\n-            }\n-        }\n-\n-        // To limit dust spam, require MIN_TX_FEE if any output is less than 0.01\n-        if (nMinFee < MIN_TX_FEE)\n-            foreach(const CTxOut& txout, vout)\n-                if (txout.nValue < CENT)\n-                    nMinFee = MIN_TX_FEE;\n-\n-        // Raise the price as the block approaches full\n-        if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n-        {\n-            if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n-                return MAX_MONEY;\n-            nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n-        }\n-\n-        if (!MoneyRange(nMinFee))\n-            nMinFee = MAX_MONEY;\n-        return nMinFee;\n+\t// Base fee is 1 cent per kilobyte\n+\tunsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK);\n+\tunsigned int nNewBlockSize = nBlockSize + nBytes;\n+\tint64 nMinFee = (1 + (int64)nBytes / 1000) * MIN_TX_FEE;\n+\n+\tif (fAllowFree)\n+\t{\n+\t    if (nBlockSize == 1)\n+\t    {\n+\t\t// Transactions under 10K are free\n+\t\t// (about 4500bc if made of 50bc inputs)\n+\t\tif (nBytes < 10000)\n+\t\t    nMinFee = 0;\n+\t    }\n+\t    else\n+\t    {\n+\t\t// Free transaction area\n+\t\tif (nNewBlockSize < 27000)\n+\t\t    nMinFee = 0;\n+\t    }\n+\t}\n+\n+\t// To limit dust spam, require MIN_TX_FEE if any output is less than 0.01\n+\tif (nMinFee < MIN_TX_FEE)\n+\t    foreach(const CTxOut& txout, vout)\n+\t\tif (txout.nValue < CENT)\n+\t\t    nMinFee = MIN_TX_FEE;\n+\n+\t// Raise the price as the block approaches full\n+\tif (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n+\t{\n+\t    if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n+\t\treturn MAX_MONEY;\n+\t    nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n+\t}\n+\n+\tif (!MoneyRange(nMinFee))\n+\t    nMinFee = MAX_MONEY;\n+\treturn nMinFee;\n     }\n \n \n     bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n     {\n-        CAutoFile filein = OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\");\n-        if (!filein)\n-            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n+\tCAutoFile filein = OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\");\n+\tif (!filein)\n+\t    return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n \n-        // Read transaction\n-        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n-            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n-        filein >> *this;\n+\t// Read transaction\n+\tif (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n+\t    return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n+\tfilein >> *this;\n \n-        // Return file pointer\n-        if (pfileRet)\n-        {\n-            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n-                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n-            *pfileRet = filein.release();\n-        }\n-        return true;\n+\t// Return file pointer\n+\tif (pfileRet)\n+\t{\n+\t    if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n+\t\treturn error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n+\t    *pfileRet = filein.release();\n+\t}\n+\treturn true;\n     }\n \n     friend bool operator==(const CTransaction& a, const CTransaction& b)\n     {\n-        return (a.nVersion  == b.nVersion &&\n-                a.vin       == b.vin &&\n-                a.vout      == b.vout &&\n-                a.nLockTime == b.nLockTime);\n+\treturn (a.nVersion  == b.nVersion &&\n+\t\ta.vin       == b.vin &&\n+\t\ta.vout      == b.vout &&\n+\t\ta.nLockTime == b.nLockTime);\n     }\n \n     friend bool operator!=(const CTransaction& a, const CTransaction& b)\n     {\n-        return !(a == b);\n+\treturn !(a == b);\n     }\n \n \n     string ToString() const\n     {\n-        string str;\n-        str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%d, vout.size=%d, nLockTime=%d)\\n\",\n-            GetHash().ToString().substr(0,10).c_str(),\n-            nVersion,\n-            vin.size(),\n-            vout.size(),\n-            nLockTime);\n-        for (int i = 0; i < vin.size(); i++)\n-            str += \"    \" + vin[i].ToString() + \"\\n\";\n-        for (int i = 0; i < vout.size(); i++)\n-            str += \"    \" + vout[i].ToString() + \"\\n\";\n-        return str;\n+\tstring str;\n+\tstr += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%d, vout.size=%d, nLockTime=%d)\\n\",\n+\t    GetHash().ToString().substr(0,10).c_str(),\n+\t    nVersion,\n+\t    vin.size(),\n+\t    vout.size(),\n+\t    nLockTime);\n+\tfor (int i = 0; i < vin.size(); i++)\n+\t    str += \"    \" + vin[i].ToString() + \"\\n\";\n+\tfor (int i = 0; i < vout.size(); i++)\n+\t    str += \"    \" + vout[i].ToString() + \"\\n\";\n+\treturn str;\n     }\n \n     void print() const\n     {\n-        printf(\"%s\", ToString().c_str());\n+\tprintf(\"%s\", ToString().c_str());\n     }\n \n \n@@ -695,14 +695,14 @@ class CTransaction\n     bool ReadFromDisk(COutPoint prevout);\n     bool DisconnectInputs(CTxDB& txdb);\n     bool ConnectInputs(CTxDB& txdb, map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n-                       CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee=0);\n+\t\t       CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee=0);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n     bool AcceptToMemoryPool(bool fCheckInputs=true, bool* pfMissingInputs=NULL)\n     {\n-        CTxDB txdb(\"r\");\n-        return AcceptToMemoryPool(txdb, fCheckInputs, pfMissingInputs);\n+\tCTxDB txdb(\"r\");\n+\treturn AcceptToMemoryPool(txdb, fCheckInputs, pfMissingInputs);\n     }\n protected:\n     bool AddToMemoryPoolUnchecked();\n@@ -730,29 +730,29 @@ class CMerkleTx : public CTransaction\n \n     CMerkleTx()\n     {\n-        Init();\n+\tInit();\n     }\n \n     CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n     {\n-        Init();\n+\tInit();\n     }\n \n     void Init()\n     {\n-        hashBlock = 0;\n-        nIndex = -1;\n-        fMerkleVerified = false;\n+\thashBlock = 0;\n+\tnIndex = -1;\n+\tfMerkleVerified = false;\n     }\n \n \n     IMPLEMENT_SERIALIZE\n     (\n-        nSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);\n-        nVersion = this->nVersion;\n-        READWRITE(hashBlock);\n-        READWRITE(vMerkleBranch);\n-        READWRITE(nIndex);\n+\tnSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);\n+\tnVersion = this->nVersion;\n+\tREADWRITE(hashBlock);\n+\tREADWRITE(vMerkleBranch);\n+\tREADWRITE(nIndex);\n     )\n \n \n@@ -803,253 +803,253 @@ class CWalletTx : public CMerkleTx\n \n     CWalletTx()\n     {\n-        Init();\n+\tInit();\n     }\n \n     CWalletTx(const CMerkleTx& txIn) : CMerkleTx(txIn)\n     {\n-        Init();\n+\tInit();\n     }\n \n     CWalletTx(const CTransaction& txIn) : CMerkleTx(txIn)\n     {\n-        Init();\n+\tInit();\n     }\n \n     void Init()\n     {\n-        vtxPrev.clear();\n-        mapValue.clear();\n-        vOrderForm.clear();\n-        fTimeReceivedIsTxTime = false;\n-        nTimeReceived = 0;\n-        fFromMe = false;\n-        strFromAccount.clear();\n-        vfSpent.clear();\n-        fDebitCached = false;\n-        fCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fChangeCached = false;\n-        nDebitCached = 0;\n-        nCreditCached = 0;\n-        nAvailableCreditCached = 0;\n-        nChangeCached = 0;\n-        nTimeDisplayed = 0;\n-        nLinesDisplayed = 0;\n-        fConfirmedDisplayed = false;\n+\tvtxPrev.clear();\n+\tmapValue.clear();\n+\tvOrderForm.clear();\n+\tfTimeReceivedIsTxTime = false;\n+\tnTimeReceived = 0;\n+\tfFromMe = false;\n+\tstrFromAccount.clear();\n+\tvfSpent.clear();\n+\tfDebitCached = false;\n+\tfCreditCached = false;\n+\tfAvailableCreditCached = false;\n+\tfChangeCached = false;\n+\tnDebitCached = 0;\n+\tnCreditCached = 0;\n+\tnAvailableCreditCached = 0;\n+\tnChangeCached = 0;\n+\tnTimeDisplayed = 0;\n+\tnLinesDisplayed = 0;\n+\tfConfirmedDisplayed = false;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        CWalletTx* pthis = const_cast<CWalletTx*>(this);\n-        if (fRead)\n-            pthis->Init();\n-        char fSpent = false;\n-\n-        if (!fRead)\n-        {\n-            pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n-\n-            string str;\n-            foreach(char f, vfSpent)\n-            {\n-                str += (f ? '1' : '0');\n-                if (f)\n-                    fSpent = true;\n-            }\n-            pthis->mapValue[\"spent\"] = str;\n-        }\n-\n-        nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n-        READWRITE(vtxPrev);\n-        READWRITE(mapValue);\n-        READWRITE(vOrderForm);\n-        READWRITE(fTimeReceivedIsTxTime);\n-        READWRITE(nTimeReceived);\n-        READWRITE(fFromMe);\n-        READWRITE(fSpent);\n-\n-        if (fRead)\n-        {\n-            pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n-\n-            if (mapValue.count(\"spent\"))\n-                foreach(char c, pthis->mapValue[\"spent\"])\n-                    pthis->vfSpent.push_back(c != '0');\n-            else\n-                pthis->vfSpent.assign(vout.size(), fSpent);\n-        }\n-\n-        pthis->mapValue.erase(\"fromaccount\");\n-        pthis->mapValue.erase(\"version\");\n-        pthis->mapValue.erase(\"spent\");\n+\tCWalletTx* pthis = const_cast<CWalletTx*>(this);\n+\tif (fRead)\n+\t    pthis->Init();\n+\tchar fSpent = false;\n+\n+\tif (!fRead)\n+\t{\n+\t    pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n+\n+\t    string str;\n+\t    foreach(char f, vfSpent)\n+\t    {\n+\t\tstr += (f ? '1' : '0');\n+\t\tif (f)\n+\t\t    fSpent = true;\n+\t    }\n+\t    pthis->mapValue[\"spent\"] = str;\n+\t}\n+\n+\tnSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n+\tREADWRITE(vtxPrev);\n+\tREADWRITE(mapValue);\n+\tREADWRITE(vOrderForm);\n+\tREADWRITE(fTimeReceivedIsTxTime);\n+\tREADWRITE(nTimeReceived);\n+\tREADWRITE(fFromMe);\n+\tREADWRITE(fSpent);\n+\n+\tif (fRead)\n+\t{\n+\t    pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n+\n+\t    if (mapValue.count(\"spent\"))\n+\t\tforeach(char c, pthis->mapValue[\"spent\"])\n+\t\t    pthis->vfSpent.push_back(c != '0');\n+\t    else\n+\t\tpthis->vfSpent.assign(vout.size(), fSpent);\n+\t}\n+\n+\tpthis->mapValue.erase(\"fromaccount\");\n+\tpthis->mapValue.erase(\"version\");\n+\tpthis->mapValue.erase(\"spent\");\n     )\n \n     // marks certain txout's as spent\n     // returns true if any update took place\n     bool UpdateSpent(const vector<char>& vfNewSpent)\n     {\n-        bool fReturn = false;\n-        for (int i=0; i < vfNewSpent.size(); i++)\n-        {\n-            if (i == vfSpent.size())\n-                break;\n+\tbool fReturn = false;\n+\tfor (int i=0; i < vfNewSpent.size(); i++)\n+\t{\n+\t    if (i == vfSpent.size())\n+\t\tbreak;\n \n-            if (vfNewSpent[i] && !vfSpent[i])\n-            {\n-                vfSpent[i] = true;\n-                fReturn = true;\n-                fAvailableCreditCached = false;\n-            }\n-        }\n-        return fReturn;\n+\t    if (vfNewSpent[i] && !vfSpent[i])\n+\t    {\n+\t\tvfSpent[i] = true;\n+\t\tfReturn = true;\n+\t\tfAvailableCreditCached = false;\n+\t    }\n+\t}\n+\treturn fReturn;\n     }\n \n     void MarkDirty()\n     {\n-        fCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fDebitCached = false;\n-        fChangeCached = false;\n+\tfCreditCached = false;\n+\tfAvailableCreditCached = false;\n+\tfDebitCached = false;\n+\tfChangeCached = false;\n     }\n \n     void MarkSpent(unsigned int nOut)\n     {\n-        if (nOut >= vout.size())\n-            throw runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n-        vfSpent.resize(vout.size());\n-        if (!vfSpent[nOut])\n-        {\n-            vfSpent[nOut] = true;\n-            fAvailableCreditCached = false;\n-        }\n+\tif (nOut >= vout.size())\n+\t    throw runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n+\tvfSpent.resize(vout.size());\n+\tif (!vfSpent[nOut])\n+\t{\n+\t    vfSpent[nOut] = true;\n+\t    fAvailableCreditCached = false;\n+\t}\n     }\n \n     bool IsSpent(unsigned int nOut) const\n     {\n-        if (nOut >= vout.size())\n-            throw runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n-        if (nOut >= vfSpent.size())\n-            return false;\n-        return (!!vfSpent[nOut]);\n+\tif (nOut >= vout.size())\n+\t    throw runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n+\tif (nOut >= vfSpent.size())\n+\t    return false;\n+\treturn (!!vfSpent[nOut]);\n     }\n \n     int64 GetDebit() const\n     {\n-        if (vin.empty())\n-            return 0;\n-        if (fDebitCached)\n-            return nDebitCached;\n-        nDebitCached = CTransaction::GetDebit();\n-        fDebitCached = true;\n-        return nDebitCached;\n+\tif (vin.empty())\n+\t    return 0;\n+\tif (fDebitCached)\n+\t    return nDebitCached;\n+\tnDebitCached = CTransaction::GetDebit();\n+\tfDebitCached = true;\n+\treturn nDebitCached;\n     }\n \n     int64 GetCredit(bool fUseCache=true) const\n     {\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n+\t// Must wait until coinbase is safely deep enough in the chain before valuing it\n+\tif (IsCoinBase() && GetBlocksToMaturity() > 0)\n+\t    return 0;\n \n-        // GetBalance can assume transactions in mapWallet won't change\n-        if (fUseCache && fCreditCached)\n-            return nCreditCached;\n-        nCreditCached = CTransaction::GetCredit();\n-        fCreditCached = true;\n-        return nCreditCached;\n+\t// GetBalance can assume transactions in mapWallet won't change\n+\tif (fUseCache && fCreditCached)\n+\t    return nCreditCached;\n+\tnCreditCached = CTransaction::GetCredit();\n+\tfCreditCached = true;\n+\treturn nCreditCached;\n     }\n \n     int64 GetAvailableCredit(bool fUseCache=true) const\n     {\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n+\t// Must wait until coinbase is safely deep enough in the chain before valuing it\n+\tif (IsCoinBase() && GetBlocksToMaturity() > 0)\n+\t    return 0;\n \n-        if (fUseCache && fAvailableCreditCached)\n-            return nAvailableCreditCached;\n+\tif (fUseCache && fAvailableCreditCached)\n+\t    return nAvailableCreditCached;\n \n-        int64 nCredit = 0;\n-        for (int i = 0; i < vout.size(); i++)\n-        {\n-            if (!IsSpent(i))\n-            {\n-                const CTxOut &txout = vout[i];\n-                nCredit += txout.GetCredit();\n-                if (!MoneyRange(nCredit))\n-                    throw runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n-            }\n-        }\n+\tint64 nCredit = 0;\n+\tfor (int i = 0; i < vout.size(); i++)\n+\t{\n+\t    if (!IsSpent(i))\n+\t    {\n+\t\tconst CTxOut &txout = vout[i];\n+\t\tnCredit += txout.GetCredit();\n+\t\tif (!MoneyRange(nCredit))\n+\t\t    throw runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+\t    }\n+\t}\n \n-        nAvailableCreditCached = nCredit;\n-        fAvailableCreditCached = true;\n-        return nCredit;\n+\tnAvailableCreditCached = nCredit;\n+\tfAvailableCreditCached = true;\n+\treturn nCredit;\n     }\n \n \n     int64 GetChange() const\n     {\n-        if (fChangeCached)\n-            return nChangeCached;\n-        nChangeCached = CTransaction::GetChange();\n-        fChangeCached = true;\n-        return nChangeCached;\n+\tif (fChangeCached)\n+\t    return nChangeCached;\n+\tnChangeCached = CTransaction::GetChange();\n+\tfChangeCached = true;\n+\treturn nChangeCached;\n     }\n \n     void GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, list<pair<string /* address */, int64> >& listReceived,\n-                    list<pair<string /* address */, int64> >& listSent, int64& nFee, string& strSentAccount) const;\n+\t\t    list<pair<string /* address */, int64> >& listSent, int64& nFee, string& strSentAccount) const;\n \n-    void GetAccountAmounts(const string& strAccount, int64& nGenerated, int64& nReceived, \n-                           int64& nSent, int64& nFee) const;\n+    void GetAccountAmounts(const string& strAccount, int64& nGenerated, int64& nReceived,\n+\t\t\t   int64& nSent, int64& nFee) const;\n \n     bool IsFromMe() const\n     {\n-        return (GetDebit() > 0);\n+\treturn (GetDebit() > 0);\n     }\n \n     bool IsConfirmed() const\n     {\n-        // Quick answer in most cases\n-        if (!IsFinal())\n-            return false;\n-        if (GetDepthInMainChain() >= 1)\n-            return true;\n-        if (!IsFromMe()) // using wtx's cached debit\n-            return false;\n-\n-        // If no confirmations but it's from us, we can still\n-        // consider it confirmed if all dependencies are confirmed\n-        map<uint256, const CMerkleTx*> mapPrev;\n-        vector<const CMerkleTx*> vWorkQueue;\n-        vWorkQueue.reserve(vtxPrev.size()+1);\n-        vWorkQueue.push_back(this);\n-        for (int i = 0; i < vWorkQueue.size(); i++)\n-        {\n-            const CMerkleTx* ptx = vWorkQueue[i];\n-\n-            if (!ptx->IsFinal())\n-                return false;\n-            if (ptx->GetDepthInMainChain() >= 1)\n-                continue;\n-            if (!ptx->IsFromMe())\n-                return false;\n-\n-            if (mapPrev.empty())\n-                foreach(const CMerkleTx& tx, vtxPrev)\n-                    mapPrev[tx.GetHash()] = &tx;\n-\n-            foreach(const CTxIn& txin, ptx->vin)\n-            {\n-                if (!mapPrev.count(txin.prevout.hash))\n-                    return false;\n-                vWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n-            }\n-        }\n-        return true;\n+\t// Quick answer in most cases\n+\tif (!IsFinal())\n+\t    return false;\n+\tif (GetDepthInMainChain() >= 1)\n+\t    return true;\n+\tif (!IsFromMe()) // using wtx's cached debit\n+\t    return false;\n+\n+\t// If no confirmations but it's from us, we can still\n+\t// consider it confirmed if all dependencies are confirmed\n+\tmap<uint256, const CMerkleTx*> mapPrev;\n+\tvector<const CMerkleTx*> vWorkQueue;\n+\tvWorkQueue.reserve(vtxPrev.size()+1);\n+\tvWorkQueue.push_back(this);\n+\tfor (int i = 0; i < vWorkQueue.size(); i++)\n+\t{\n+\t    const CMerkleTx* ptx = vWorkQueue[i];\n+\n+\t    if (!ptx->IsFinal())\n+\t\treturn false;\n+\t    if (ptx->GetDepthInMainChain() >= 1)\n+\t\tcontinue;\n+\t    if (!ptx->IsFromMe())\n+\t\treturn false;\n+\n+\t    if (mapPrev.empty())\n+\t\tforeach(const CMerkleTx& tx, vtxPrev)\n+\t\t    mapPrev[tx.GetHash()] = &tx;\n+\n+\t    foreach(const CTxIn& txin, ptx->vin)\n+\t    {\n+\t\tif (!mapPrev.count(txin.prevout.hash))\n+\t\t    return false;\n+\t\tvWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n+\t    }\n+\t}\n+\treturn true;\n     }\n \n     bool WriteToDisk()\n     {\n-        return CWalletDB().WriteTx(GetHash(), *this);\n+\treturn CWalletDB().WriteTx(GetHash(), *this);\n     }\n \n \n@@ -1081,43 +1081,43 @@ class CTxIndex\n \n     CTxIndex()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n     {\n-        pos = posIn;\n-        vSpent.resize(nOutputs);\n+\tpos = posIn;\n+\tvSpent.resize(nOutputs);\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(pos);\n-        READWRITE(vSpent);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\tREADWRITE(pos);\n+\tREADWRITE(vSpent);\n     )\n \n     void SetNull()\n     {\n-        pos.SetNull();\n-        vSpent.clear();\n+\tpos.SetNull();\n+\tvSpent.clear();\n     }\n \n     bool IsNull()\n     {\n-        return pos.IsNull();\n+\treturn pos.IsNull();\n     }\n \n     friend bool operator==(const CTxIndex& a, const CTxIndex& b)\n     {\n-        return (a.pos    == b.pos &&\n-                a.vSpent == b.vSpent);\n+\treturn (a.pos    == b.pos &&\n+\t\ta.vSpent == b.vSpent);\n     }\n \n     friend bool operator!=(const CTxIndex& a, const CTxIndex& b)\n     {\n-        return !(a == b);\n+\treturn !(a == b);\n     }\n     int GetDepthInMainChain() const;\n };\n@@ -1157,185 +1157,185 @@ class CBlock\n \n     CBlock()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(this->nVersion);\n-        nVersion = this->nVersion;\n-        READWRITE(hashPrevBlock);\n-        READWRITE(hashMerkleRoot);\n-        READWRITE(nTime);\n-        READWRITE(nBits);\n-        READWRITE(nNonce);\n-\n-        // ConnectBlock depends on vtx being last so it can calculate offset\n-        if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n-            READWRITE(vtx);\n-        else if (fRead)\n-            const_cast<CBlock*>(this)->vtx.clear();\n+\tREADWRITE(this->nVersion);\n+\tnVersion = this->nVersion;\n+\tREADWRITE(hashPrevBlock);\n+\tREADWRITE(hashMerkleRoot);\n+\tREADWRITE(nTime);\n+\tREADWRITE(nBits);\n+\tREADWRITE(nNonce);\n+\n+\t// ConnectBlock depends on vtx being last so it can calculate offset\n+\tif (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n+\t    READWRITE(vtx);\n+\telse if (fRead)\n+\t    const_cast<CBlock*>(this)->vtx.clear();\n     )\n \n     void SetNull()\n     {\n-        nVersion = 1;\n-        hashPrevBlock = 0;\n-        hashMerkleRoot = 0;\n-        nTime = 0;\n-        nBits = 0;\n-        nNonce = 0;\n-        vtx.clear();\n-        vMerkleTree.clear();\n+\tnVersion = 1;\n+\thashPrevBlock = 0;\n+\thashMerkleRoot = 0;\n+\tnTime = 0;\n+\tnBits = 0;\n+\tnNonce = 0;\n+\tvtx.clear();\n+\tvMerkleTree.clear();\n     }\n \n     bool IsNull() const\n     {\n-        return (nBits == 0);\n+\treturn (nBits == 0);\n     }\n \n     uint256 GetHash() const\n     {\n-        return Hash(BEGIN(nVersion), END(nNonce));\n+\treturn Hash(BEGIN(nVersion), END(nNonce));\n     }\n \n     int64 GetBlockTime() const\n     {\n-        return (int64)nTime;\n+\treturn (int64)nTime;\n     }\n \n     int GetSigOpCount() const\n     {\n-        int n = 0;\n-        foreach(const CTransaction& tx, vtx)\n-            n += tx.GetSigOpCount();\n-        return n;\n+\tint n = 0;\n+\tforeach(const CTransaction& tx, vtx)\n+\t    n += tx.GetSigOpCount();\n+\treturn n;\n     }\n \n \n     uint256 BuildMerkleTree() const\n     {\n-        vMerkleTree.clear();\n-        foreach(const CTransaction& tx, vtx)\n-            vMerkleTree.push_back(tx.GetHash());\n-        int j = 0;\n-        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-        {\n-            for (int i = 0; i < nSize; i += 2)\n-            {\n-                int i2 = min(i+1, nSize-1);\n-                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n-                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n-            }\n-            j += nSize;\n-        }\n-        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n+\tvMerkleTree.clear();\n+\tforeach(const CTransaction& tx, vtx)\n+\t    vMerkleTree.push_back(tx.GetHash());\n+\tint j = 0;\n+\tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n+\t{\n+\t    for (int i = 0; i < nSize; i += 2)\n+\t    {\n+\t\tint i2 = min(i+1, nSize-1);\n+\t\tvMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n+\t\t\t\t\t   BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n+\t    }\n+\t    j += nSize;\n+\t}\n+\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n     }\n \n     vector<uint256> GetMerkleBranch(int nIndex) const\n     {\n-        if (vMerkleTree.empty())\n-            BuildMerkleTree();\n-        vector<uint256> vMerkleBranch;\n-        int j = 0;\n-        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-        {\n-            int i = min(nIndex^1, nSize-1);\n-            vMerkleBranch.push_back(vMerkleTree[j+i]);\n-            nIndex >>= 1;\n-            j += nSize;\n-        }\n-        return vMerkleBranch;\n+\tif (vMerkleTree.empty())\n+\t    BuildMerkleTree();\n+\tvector<uint256> vMerkleBranch;\n+\tint j = 0;\n+\tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n+\t{\n+\t    int i = min(nIndex^1, nSize-1);\n+\t    vMerkleBranch.push_back(vMerkleTree[j+i]);\n+\t    nIndex >>= 1;\n+\t    j += nSize;\n+\t}\n+\treturn vMerkleBranch;\n     }\n \n     static uint256 CheckMerkleBranch(uint256 hash, const vector<uint256>& vMerkleBranch, int nIndex)\n     {\n-        if (nIndex == -1)\n-            return 0;\n-        foreach(const uint256& otherside, vMerkleBranch)\n-        {\n-            if (nIndex & 1)\n-                hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n-            else\n-                hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n-            nIndex >>= 1;\n-        }\n-        return hash;\n+\tif (nIndex == -1)\n+\t    return 0;\n+\tforeach(const uint256& otherside, vMerkleBranch)\n+\t{\n+\t    if (nIndex & 1)\n+\t\thash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n+\t    else\n+\t\thash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n+\t    nIndex >>= 1;\n+\t}\n+\treturn hash;\n     }\n \n \n     bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n     {\n-        // Open history file to append\n-        CAutoFile fileout = AppendBlockFile(nFileRet);\n-        if (!fileout)\n-            return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n-\n-        // Write index header\n-        unsigned int nSize = fileout.GetSerializeSize(*this);\n-        fileout << FLATDATA(pchMessageStart) << nSize;\n-\n-        // Write block\n-        nBlockPosRet = ftell(fileout);\n-        if (nBlockPosRet == -1)\n-            return error(\"CBlock::WriteToDisk() : ftell failed\");\n-        fileout << *this;\n-\n-        // Flush stdio buffers and commit to disk before returning\n-        fflush(fileout);\n-        if (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n-        {\n+\t// Open history file to append\n+\tCAutoFile fileout = AppendBlockFile(nFileRet);\n+\tif (!fileout)\n+\t    return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n+\n+\t// Write index header\n+\tunsigned int nSize = fileout.GetSerializeSize(*this);\n+\tfileout << FLATDATA(pchMessageStart) << nSize;\n+\n+\t// Write block\n+\tnBlockPosRet = ftell(fileout);\n+\tif (nBlockPosRet == -1)\n+\t    return error(\"CBlock::WriteToDisk() : ftell failed\");\n+\tfileout << *this;\n+\n+\t// Flush stdio buffers and commit to disk before returning\n+\tfflush(fileout);\n+\tif (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n+\t{\n #ifdef __WXMSW__\n-            _commit(_fileno(fileout));\n+\t    _commit(_fileno(fileout));\n #else\n-            fsync(fileno(fileout));\n+\t    fsync(fileno(fileout));\n #endif\n-        }\n+\t}\n \n-        return true;\n+\treturn true;\n     }\n \n     bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n     {\n-        SetNull();\n+\tSetNull();\n \n-        // Open history file to read\n-        CAutoFile filein = OpenBlockFile(nFile, nBlockPos, \"rb\");\n-        if (!filein)\n-            return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n-        if (!fReadTransactions)\n-            filein.nType |= SER_BLOCKHEADERONLY;\n+\t// Open history file to read\n+\tCAutoFile filein = OpenBlockFile(nFile, nBlockPos, \"rb\");\n+\tif (!filein)\n+\t    return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n+\tif (!fReadTransactions)\n+\t    filein.nType |= SER_BLOCKHEADERONLY;\n \n-        // Read block\n-        filein >> *this;\n+\t// Read block\n+\tfilein >> *this;\n \n-        // Check the header\n-        if (!CheckProofOfWork(GetHash(), nBits))\n-            return error(\"CBlock::ReadFromDisk() : errors in block header\");\n+\t// Check the header\n+\tif (!CheckProofOfWork(GetHash(), nBits))\n+\t    return error(\"CBlock::ReadFromDisk() : errors in block header\");\n \n-        return true;\n+\treturn true;\n     }\n \n \n \n     void print() const\n     {\n-        printf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%d)\\n\",\n-            GetHash().ToString().substr(0,20).c_str(),\n-            nVersion,\n-            hashPrevBlock.ToString().substr(0,20).c_str(),\n-            hashMerkleRoot.ToString().substr(0,10).c_str(),\n-            nTime, nBits, nNonce,\n-            vtx.size());\n-        for (int i = 0; i < vtx.size(); i++)\n-        {\n-            printf(\"  \");\n-            vtx[i].print();\n-        }\n-        printf(\"  vMerkleTree: \");\n-        for (int i = 0; i < vMerkleTree.size(); i++)\n-            printf(\"%s \", vMerkleTree[i].ToString().substr(0,10).c_str());\n-        printf(\"\\n\");\n+\tprintf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%d)\\n\",\n+\t    GetHash().ToString().substr(0,20).c_str(),\n+\t    nVersion,\n+\t    hashPrevBlock.ToString().substr(0,20).c_str(),\n+\t    hashMerkleRoot.ToString().substr(0,10).c_str(),\n+\t    nTime, nBits, nNonce,\n+\t    vtx.size());\n+\tfor (int i = 0; i < vtx.size(); i++)\n+\t{\n+\t    printf(\"  \");\n+\t    vtx[i].print();\n+\t}\n+\tprintf(\"  vMerkleTree: \");\n+\tfor (int i = 0; i < vMerkleTree.size(); i++)\n+\t    printf(\"%s \", vMerkleTree[i].ToString().substr(0,10).c_str());\n+\tprintf(\"\\n\");\n     }\n \n \n@@ -1382,136 +1382,136 @@ class CBlockIndex\n \n     CBlockIndex()\n     {\n-        phashBlock = NULL;\n-        pprev = NULL;\n-        pnext = NULL;\n-        nFile = 0;\n-        nBlockPos = 0;\n-        nHeight = 0;\n-        bnChainWork = 0;\n+\tphashBlock = NULL;\n+\tpprev = NULL;\n+\tpnext = NULL;\n+\tnFile = 0;\n+\tnBlockPos = 0;\n+\tnHeight = 0;\n+\tbnChainWork = 0;\n \n-        nVersion       = 0;\n-        hashMerkleRoot = 0;\n-        nTime          = 0;\n-        nBits          = 0;\n-        nNonce         = 0;\n+\tnVersion       = 0;\n+\thashMerkleRoot = 0;\n+\tnTime          = 0;\n+\tnBits          = 0;\n+\tnNonce         = 0;\n     }\n \n     CBlockIndex(unsigned int nFileIn, unsigned int nBlockPosIn, CBlock& block)\n     {\n-        phashBlock = NULL;\n-        pprev = NULL;\n-        pnext = NULL;\n-        nFile = nFileIn;\n-        nBlockPos = nBlockPosIn;\n-        nHeight = 0;\n-        bnChainWork = 0;\n+\tphashBlock = NULL;\n+\tpprev = NULL;\n+\tpnext = NULL;\n+\tnFile = nFileIn;\n+\tnBlockPos = nBlockPosIn;\n+\tnHeight = 0;\n+\tbnChainWork = 0;\n \n-        nVersion       = block.nVersion;\n-        hashMerkleRoot = block.hashMerkleRoot;\n-        nTime          = block.nTime;\n-        nBits          = block.nBits;\n-        nNonce         = block.nNonce;\n+\tnVersion       = block.nVersion;\n+\thashMerkleRoot = block.hashMerkleRoot;\n+\tnTime          = block.nTime;\n+\tnBits          = block.nBits;\n+\tnNonce         = block.nNonce;\n     }\n \n     CBlock GetBlockHeader() const\n     {\n-        CBlock block;\n-        block.nVersion       = nVersion;\n-        if (pprev)\n-            block.hashPrevBlock = pprev->GetBlockHash();\n-        block.hashMerkleRoot = hashMerkleRoot;\n-        block.nTime          = nTime;\n-        block.nBits          = nBits;\n-        block.nNonce         = nNonce;\n-        return block;\n+\tCBlock block;\n+\tblock.nVersion       = nVersion;\n+\tif (pprev)\n+\t    block.hashPrevBlock = pprev->GetBlockHash();\n+\tblock.hashMerkleRoot = hashMerkleRoot;\n+\tblock.nTime          = nTime;\n+\tblock.nBits          = nBits;\n+\tblock.nNonce         = nNonce;\n+\treturn block;\n     }\n \n     uint256 GetBlockHash() const\n     {\n-        return *phashBlock;\n+\treturn *phashBlock;\n     }\n \n     int64 GetBlockTime() const\n     {\n-        return (int64)nTime;\n+\treturn (int64)nTime;\n     }\n \n     CBigNum GetBlockWork() const\n     {\n-        CBigNum bnTarget;\n-        bnTarget.SetCompact(nBits);\n-        if (bnTarget <= 0)\n-            return 0;\n-        return (CBigNum(1)<<256) / (bnTarget+1);\n+\tCBigNum bnTarget;\n+\tbnTarget.SetCompact(nBits);\n+\tif (bnTarget <= 0)\n+\t    return 0;\n+\treturn (CBigNum(1)<<256) / (bnTarget+1);\n     }\n \n     bool IsInMainChain() const\n     {\n-        return (pnext || this == pindexBest);\n+\treturn (pnext || this == pindexBest);\n     }\n \n     bool CheckIndex() const\n     {\n-        return CheckProofOfWork(GetBlockHash(), nBits);\n+\treturn CheckProofOfWork(GetBlockHash(), nBits);\n     }\n \n     bool EraseBlockFromDisk()\n     {\n-        // Open history file\n-        CAutoFile fileout = OpenBlockFile(nFile, nBlockPos, \"rb+\");\n-        if (!fileout)\n-            return false;\n+\t// Open history file\n+\tCAutoFile fileout = OpenBlockFile(nFile, nBlockPos, \"rb+\");\n+\tif (!fileout)\n+\t    return false;\n \n-        // Overwrite with empty null block\n-        CBlock block;\n-        block.SetNull();\n-        fileout << block;\n+\t// Overwrite with empty null block\n+\tCBlock block;\n+\tblock.SetNull();\n+\tfileout << block;\n \n-        return true;\n+\treturn true;\n     }\n \n     enum { nMedianTimeSpan=11 };\n \n     int64 GetMedianTimePast() const\n     {\n-        int64 pmedian[nMedianTimeSpan];\n-        int64* pbegin = &pmedian[nMedianTimeSpan];\n-        int64* pend = &pmedian[nMedianTimeSpan];\n+\tint64 pmedian[nMedianTimeSpan];\n+\tint64* pbegin = &pmedian[nMedianTimeSpan];\n+\tint64* pend = &pmedian[nMedianTimeSpan];\n \n-        const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n-            *(--pbegin) = pindex->GetBlockTime();\n+\tconst CBlockIndex* pindex = this;\n+\tfor (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n+\t    *(--pbegin) = pindex->GetBlockTime();\n \n-        sort(pbegin, pend);\n-        return pbegin[(pend - pbegin)/2];\n+\tsort(pbegin, pend);\n+\treturn pbegin[(pend - pbegin)/2];\n     }\n \n     int64 GetMedianTime() const\n     {\n-        const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan/2; i++)\n-        {\n-            if (!pindex->pnext)\n-                return GetBlockTime();\n-            pindex = pindex->pnext;\n-        }\n-        return pindex->GetMedianTimePast();\n+\tconst CBlockIndex* pindex = this;\n+\tfor (int i = 0; i < nMedianTimeSpan/2; i++)\n+\t{\n+\t    if (!pindex->pnext)\n+\t\treturn GetBlockTime();\n+\t    pindex = pindex->pnext;\n+\t}\n+\treturn pindex->GetMedianTimePast();\n     }\n \n \n \n     string ToString() const\n     {\n-        return strprintf(\"CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%-6d nHeight=%d, merkle=%s, hashBlock=%s)\",\n-            pprev, pnext, nFile, nBlockPos, nHeight,\n-            hashMerkleRoot.ToString().substr(0,10).c_str(),\n-            GetBlockHash().ToString().substr(0,20).c_str());\n+\treturn strprintf(\"CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%-6d nHeight=%d, merkle=%s, hashBlock=%s)\",\n+\t    pprev, pnext, nFile, nBlockPos, nHeight,\n+\t    hashMerkleRoot.ToString().substr(0,10).c_str(),\n+\t    GetBlockHash().ToString().substr(0,20).c_str());\n     }\n \n     void print() const\n     {\n-        printf(\"%s\\n\", ToString().c_str());\n+\tprintf(\"%s\\n\", ToString().c_str());\n     }\n };\n \n@@ -1528,62 +1528,62 @@ class CDiskBlockIndex : public CBlockIndex\n \n     CDiskBlockIndex()\n     {\n-        hashPrev = 0;\n-        hashNext = 0;\n+\thashPrev = 0;\n+\thashNext = 0;\n     }\n \n     explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex)\n     {\n-        hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n-        hashNext = (pnext ? pnext->GetBlockHash() : 0);\n+\thashPrev = (pprev ? pprev->GetBlockHash() : 0);\n+\thashNext = (pnext ? pnext->GetBlockHash() : 0);\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-\n-        READWRITE(hashNext);\n-        READWRITE(nFile);\n-        READWRITE(nBlockPos);\n-        READWRITE(nHeight);\n-\n-        // block header\n-        READWRITE(this->nVersion);\n-        READWRITE(hashPrev);\n-        READWRITE(hashMerkleRoot);\n-        READWRITE(nTime);\n-        READWRITE(nBits);\n-        READWRITE(nNonce);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\n+\tREADWRITE(hashNext);\n+\tREADWRITE(nFile);\n+\tREADWRITE(nBlockPos);\n+\tREADWRITE(nHeight);\n+\n+\t// block header\n+\tREADWRITE(this->nVersion);\n+\tREADWRITE(hashPrev);\n+\tREADWRITE(hashMerkleRoot);\n+\tREADWRITE(nTime);\n+\tREADWRITE(nBits);\n+\tREADWRITE(nNonce);\n     )\n \n     uint256 GetBlockHash() const\n     {\n-        CBlock block;\n-        block.nVersion        = nVersion;\n-        block.hashPrevBlock   = hashPrev;\n-        block.hashMerkleRoot  = hashMerkleRoot;\n-        block.nTime           = nTime;\n-        block.nBits           = nBits;\n-        block.nNonce          = nNonce;\n-        return block.GetHash();\n+\tCBlock block;\n+\tblock.nVersion        = nVersion;\n+\tblock.hashPrevBlock   = hashPrev;\n+\tblock.hashMerkleRoot  = hashMerkleRoot;\n+\tblock.nTime           = nTime;\n+\tblock.nBits           = nBits;\n+\tblock.nNonce          = nNonce;\n+\treturn block.GetHash();\n     }\n \n \n     string ToString() const\n     {\n-        string str = \"CDiskBlockIndex(\";\n-        str += CBlockIndex::ToString();\n-        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n-            GetBlockHash().ToString().c_str(),\n-            hashPrev.ToString().substr(0,20).c_str(),\n-            hashNext.ToString().substr(0,20).c_str());\n-        return str;\n+\tstring str = \"CDiskBlockIndex(\";\n+\tstr += CBlockIndex::ToString();\n+\tstr += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n+\t    GetBlockHash().ToString().c_str(),\n+\t    hashPrev.ToString().substr(0,20).c_str(),\n+\t    hashNext.ToString().substr(0,20).c_str());\n+\treturn str;\n     }\n \n     void print() const\n     {\n-        printf(\"%s\\n\", ToString().c_str());\n+\tprintf(\"%s\\n\", ToString().c_str());\n     }\n };\n \n@@ -1611,109 +1611,109 @@ class CBlockLocator\n \n     explicit CBlockLocator(const CBlockIndex* pindex)\n     {\n-        Set(pindex);\n+\tSet(pindex);\n     }\n \n     explicit CBlockLocator(uint256 hashBlock)\n     {\n-        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end())\n-            Set((*mi).second);\n+\tmap<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n+\tif (mi != mapBlockIndex.end())\n+\t    Set((*mi).second);\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vHave);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\tREADWRITE(vHave);\n     )\n \n     void SetNull()\n     {\n-        vHave.clear();\n+\tvHave.clear();\n     }\n \n     bool IsNull()\n     {\n-        return vHave.empty();\n+\treturn vHave.empty();\n     }\n \n     void Set(const CBlockIndex* pindex)\n     {\n-        vHave.clear();\n-        int nStep = 1;\n-        while (pindex)\n-        {\n-            vHave.push_back(pindex->GetBlockHash());\n+\tvHave.clear();\n+\tint nStep = 1;\n+\twhile (pindex)\n+\t{\n+\t    vHave.push_back(pindex->GetBlockHash());\n \n-            // Exponentially larger steps back\n-            for (int i = 0; pindex && i < nStep; i++)\n-                pindex = pindex->pprev;\n-            if (vHave.size() > 10)\n-                nStep *= 2;\n-        }\n-        vHave.push_back(hashGenesisBlock);\n+\t    // Exponentially larger steps back\n+\t    for (int i = 0; pindex && i < nStep; i++)\n+\t\tpindex = pindex->pprev;\n+\t    if (vHave.size() > 10)\n+\t\tnStep *= 2;\n+\t}\n+\tvHave.push_back(hashGenesisBlock);\n     }\n \n     int GetDistanceBack()\n     {\n-        // Retrace how far back it was in the sender's branch\n-        int nDistance = 0;\n-        int nStep = 1;\n-        foreach(const uint256& hash, vHave)\n-        {\n-            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end())\n-            {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex->IsInMainChain())\n-                    return nDistance;\n-            }\n-            nDistance += nStep;\n-            if (nDistance > 10)\n-                nStep *= 2;\n-        }\n-        return nDistance;\n+\t// Retrace how far back it was in the sender's branch\n+\tint nDistance = 0;\n+\tint nStep = 1;\n+\tforeach(const uint256& hash, vHave)\n+\t{\n+\t    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+\t    if (mi != mapBlockIndex.end())\n+\t    {\n+\t\tCBlockIndex* pindex = (*mi).second;\n+\t\tif (pindex->IsInMainChain())\n+\t\t    return nDistance;\n+\t    }\n+\t    nDistance += nStep;\n+\t    if (nDistance > 10)\n+\t\tnStep *= 2;\n+\t}\n+\treturn nDistance;\n     }\n \n     CBlockIndex* GetBlockIndex()\n     {\n-        // Find the first block the caller has in the main chain\n-        foreach(const uint256& hash, vHave)\n-        {\n-            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end())\n-            {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex->IsInMainChain())\n-                    return pindex;\n-            }\n-        }\n-        return pindexGenesisBlock;\n+\t// Find the first block the caller has in the main chain\n+\tforeach(const uint256& hash, vHave)\n+\t{\n+\t    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+\t    if (mi != mapBlockIndex.end())\n+\t    {\n+\t\tCBlockIndex* pindex = (*mi).second;\n+\t\tif (pindex->IsInMainChain())\n+\t\t    return pindex;\n+\t    }\n+\t}\n+\treturn pindexGenesisBlock;\n     }\n \n     uint256 GetBlockHash()\n     {\n-        // Find the first block the caller has in the main chain\n-        foreach(const uint256& hash, vHave)\n-        {\n-            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end())\n-            {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex->IsInMainChain())\n-                    return hash;\n-            }\n-        }\n-        return hashGenesisBlock;\n+\t// Find the first block the caller has in the main chain\n+\tforeach(const uint256& hash, vHave)\n+\t{\n+\t    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+\t    if (mi != mapBlockIndex.end())\n+\t    {\n+\t\tCBlockIndex* pindex = (*mi).second;\n+\t\tif (pindex->IsInMainChain())\n+\t\t    return hash;\n+\t    }\n+\t}\n+\treturn hashGenesisBlock;\n     }\n \n     int GetHeight()\n     {\n-        CBlockIndex* pindex = GetBlockIndex();\n-        if (!pindex)\n-            return 0;\n-        return pindex->nHeight;\n+\tCBlockIndex* pindex = GetBlockIndex();\n+\tif (!pindex)\n+\t    return 0;\n+\treturn pindex->nHeight;\n     }\n };\n \n@@ -1737,18 +1737,18 @@ class CWalletKey\n \n     CWalletKey(int64 nExpires=0)\n     {\n-        nTimeCreated = (nExpires ? GetTime() : 0);\n-        nTimeExpires = nExpires;\n+\tnTimeCreated = (nExpires ? GetTime() : 0);\n+\tnTimeExpires = nExpires;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vchPrivKey);\n-        READWRITE(nTimeCreated);\n-        READWRITE(nTimeExpires);\n-        READWRITE(strComment);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\tREADWRITE(vchPrivKey);\n+\tREADWRITE(nTimeCreated);\n+\tREADWRITE(nTimeExpires);\n+\tREADWRITE(strComment);\n     )\n };\n \n@@ -1768,19 +1768,19 @@ class CAccount\n \n     CAccount()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     void SetNull()\n     {\n-        vchPubKey.clear();\n+\tvchPubKey.clear();\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vchPubKey);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\tREADWRITE(vchPubKey);\n     )\n };\n \n@@ -1801,27 +1801,27 @@ class CAccountingEntry\n \n     CAccountingEntry()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     void SetNull()\n     {\n-        nCreditDebit = 0;\n-        nTime = 0;\n-        strAccount.clear();\n-        strOtherAccount.clear();\n-        strComment.clear();\n+\tnCreditDebit = 0;\n+\tnTime = 0;\n+\tstrAccount.clear();\n+\tstrOtherAccount.clear();\n+\tstrComment.clear();\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        // Note: strAccount is serialized as part of the key, not here.\n-        READWRITE(nCreditDebit);\n-        READWRITE(nTime);\n-        READWRITE(strOtherAccount);\n-        READWRITE(strComment);\n+\tif (!(nType & SER_GETHASH))\n+\t    READWRITE(nVersion);\n+\t// Note: strAccount is serialized as part of the key, not here.\n+\tREADWRITE(nCreditDebit);\n+\tREADWRITE(nTime);\n+\tREADWRITE(strOtherAccount);\n+\tREADWRITE(strComment);\n     )\n };\n \n@@ -1861,81 +1861,81 @@ class CUnsignedAlert\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(this->nVersion);\n-        nVersion = this->nVersion;\n-        READWRITE(nRelayUntil);\n-        READWRITE(nExpiration);\n-        READWRITE(nID);\n-        READWRITE(nCancel);\n-        READWRITE(setCancel);\n-        READWRITE(nMinVer);\n-        READWRITE(nMaxVer);\n-        READWRITE(setSubVer);\n-        READWRITE(nPriority);\n-\n-        READWRITE(strComment);\n-        READWRITE(strStatusBar);\n-        READWRITE(strReserved);\n+\tREADWRITE(this->nVersion);\n+\tnVersion = this->nVersion;\n+\tREADWRITE(nRelayUntil);\n+\tREADWRITE(nExpiration);\n+\tREADWRITE(nID);\n+\tREADWRITE(nCancel);\n+\tREADWRITE(setCancel);\n+\tREADWRITE(nMinVer);\n+\tREADWRITE(nMaxVer);\n+\tREADWRITE(setSubVer);\n+\tREADWRITE(nPriority);\n+\n+\tREADWRITE(strComment);\n+\tREADWRITE(strStatusBar);\n+\tREADWRITE(strReserved);\n     )\n \n     void SetNull()\n     {\n-        nVersion = 1;\n-        nRelayUntil = 0;\n-        nExpiration = 0;\n-        nID = 0;\n-        nCancel = 0;\n-        setCancel.clear();\n-        nMinVer = 0;\n-        nMaxVer = 0;\n-        setSubVer.clear();\n-        nPriority = 0;\n+\tnVersion = 1;\n+\tnRelayUntil = 0;\n+\tnExpiration = 0;\n+\tnID = 0;\n+\tnCancel = 0;\n+\tsetCancel.clear();\n+\tnMinVer = 0;\n+\tnMaxVer = 0;\n+\tsetSubVer.clear();\n+\tnPriority = 0;\n \n-        strComment.clear();\n-        strStatusBar.clear();\n-        strReserved.clear();\n+\tstrComment.clear();\n+\tstrStatusBar.clear();\n+\tstrReserved.clear();\n     }\n \n     string ToString() const\n     {\n-        string strSetCancel;\n-        foreach(int n, setCancel)\n-            strSetCancel += strprintf(\"%d \", n);\n-        string strSetSubVer;\n-        foreach(string str, setSubVer)\n-            strSetSubVer += \"\\\"\" + str + \"\\\" \";\n-        return strprintf(\n-                \"CAlert(\\n\"\n-                \"    nVersion     = %d\\n\"\n-                \"    nRelayUntil  = %\"PRI64d\"\\n\"\n-                \"    nExpiration  = %\"PRI64d\"\\n\"\n-                \"    nID          = %d\\n\"\n-                \"    nCancel      = %d\\n\"\n-                \"    setCancel    = %s\\n\"\n-                \"    nMinVer      = %d\\n\"\n-                \"    nMaxVer      = %d\\n\"\n-                \"    setSubVer    = %s\\n\"\n-                \"    nPriority    = %d\\n\"\n-                \"    strComment   = \\\"%s\\\"\\n\"\n-                \"    strStatusBar = \\\"%s\\\"\\n\"\n-                \")\\n\",\n-            nVersion,\n-            nRelayUntil,\n-            nExpiration,\n-            nID,\n-            nCancel,\n-            strSetCancel.c_str(),\n-            nMinVer,\n-            nMaxVer,\n-            strSetSubVer.c_str(),\n-            nPriority,\n-            strComment.c_str(),\n-            strStatusBar.c_str());\n+\tstring strSetCancel;\n+\tforeach(int n, setCancel)\n+\t    strSetCancel += strprintf(\"%d \", n);\n+\tstring strSetSubVer;\n+\tforeach(string str, setSubVer)\n+\t    strSetSubVer += \"\\\"\" + str + \"\\\" \";\n+\treturn strprintf(\n+\t\t\"CAlert(\\n\"\n+\t\t\"    nVersion     = %d\\n\"\n+\t\t\"    nRelayUntil  = %\"PRI64d\"\\n\"\n+\t\t\"    nExpiration  = %\"PRI64d\"\\n\"\n+\t\t\"    nID          = %d\\n\"\n+\t\t\"    nCancel      = %d\\n\"\n+\t\t\"    setCancel    = %s\\n\"\n+\t\t\"    nMinVer      = %d\\n\"\n+\t\t\"    nMaxVer      = %d\\n\"\n+\t\t\"    setSubVer    = %s\\n\"\n+\t\t\"    nPriority    = %d\\n\"\n+\t\t\"    strComment   = \\\"%s\\\"\\n\"\n+\t\t\"    strStatusBar = \\\"%s\\\"\\n\"\n+\t\t\")\\n\",\n+\t    nVersion,\n+\t    nRelayUntil,\n+\t    nExpiration,\n+\t    nID,\n+\t    nCancel,\n+\t    strSetCancel.c_str(),\n+\t    nMinVer,\n+\t    nMaxVer,\n+\t    strSetSubVer.c_str(),\n+\t    nPriority,\n+\t    strComment.c_str(),\n+\t    strStatusBar.c_str());\n     }\n \n     void print() const\n     {\n-        printf(\"%s\", ToString().c_str());\n+\tprintf(\"%s\", ToString().c_str());\n     }\n };\n \n@@ -1947,86 +1947,86 @@ class CAlert : public CUnsignedAlert\n \n     CAlert()\n     {\n-        SetNull();\n+\tSetNull();\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(vchMsg);\n-        READWRITE(vchSig);\n+\tREADWRITE(vchMsg);\n+\tREADWRITE(vchSig);\n     )\n \n     void SetNull()\n     {\n-        CUnsignedAlert::SetNull();\n-        vchMsg.clear();\n-        vchSig.clear();\n+\tCUnsignedAlert::SetNull();\n+\tvchMsg.clear();\n+\tvchSig.clear();\n     }\n \n     bool IsNull() const\n     {\n-        return (nExpiration == 0);\n+\treturn (nExpiration == 0);\n     }\n \n     uint256 GetHash() const\n     {\n-        return SerializeHash(*this);\n+\treturn SerializeHash(*this);\n     }\n \n     bool IsInEffect() const\n     {\n-        return (GetAdjustedTime() < nExpiration);\n+\treturn (GetAdjustedTime() < nExpiration);\n     }\n \n     bool Cancels(const CAlert& alert) const\n     {\n-        if (!IsInEffect())\n-            return false; // this was a no-op before 31403\n-        return (alert.nID <= nCancel || setCancel.count(alert.nID));\n+\tif (!IsInEffect())\n+\t    return false; // this was a no-op before 31403\n+\treturn (alert.nID <= nCancel || setCancel.count(alert.nID));\n     }\n \n     bool AppliesTo(int nVersion, string strSubVerIn) const\n     {\n-        return (IsInEffect() &&\n-                nMinVer <= nVersion && nVersion <= nMaxVer &&\n-                (setSubVer.empty() || setSubVer.count(strSubVerIn)));\n+\treturn (IsInEffect() &&\n+\t\tnMinVer <= nVersion && nVersion <= nMaxVer &&\n+\t\t(setSubVer.empty() || setSubVer.count(strSubVerIn)));\n     }\n \n     bool AppliesToMe() const\n     {\n-        return AppliesTo(VERSION, ::pszSubVer);\n+\treturn AppliesTo(VERSION, ::pszSubVer);\n     }\n \n     bool RelayTo(CNode* pnode) const\n     {\n-        if (!IsInEffect())\n-            return false;\n-        // returns true if wasn't already contained in the set\n-        if (pnode->setKnown.insert(GetHash()).second)\n-        {\n-            if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n-                AppliesToMe() ||\n-                GetAdjustedTime() < nRelayUntil)\n-            {\n-                pnode->PushMessage(\"alert\", *this);\n-                return true;\n-            }\n-        }\n-        return false;\n+\tif (!IsInEffect())\n+\t    return false;\n+\t// returns true if wasn't already contained in the set\n+\tif (pnode->setKnown.insert(GetHash()).second)\n+\t{\n+\t    if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n+\t\tAppliesToMe() ||\n+\t\tGetAdjustedTime() < nRelayUntil)\n+\t    {\n+\t\tpnode->PushMessage(\"alert\", *this);\n+\t\treturn true;\n+\t    }\n+\t}\n+\treturn false;\n     }\n \n     bool CheckSignature()\n     {\n-        CKey key;\n-        if (!key.SetPubKey(ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\")))\n-            return error(\"CAlert::CheckSignature() : SetPubKey failed\");\n-        if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n-            return error(\"CAlert::CheckSignature() : verify signature failed\");\n+\tCKey key;\n+\tif (!key.SetPubKey(ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\")))\n+\t    return error(\"CAlert::CheckSignature() : SetPubKey failed\");\n+\tif (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n+\t    return error(\"CAlert::CheckSignature() : verify signature failed\");\n \n-        // Now unserialize the data\n-        CDataStream sMsg(vchMsg);\n-        sMsg >> *(CUnsignedAlert*)this;\n-        return true;\n+\t// Now unserialize the data\n+\tCDataStream sMsg(vchMsg);\n+\tsMsg >> *(CUnsignedAlert*)this;\n+\treturn true;\n     }\n \n     bool ProcessAlert();"
      },
      {
        "sha": "3503b7f8bde86f81b5bc3ed130c757f7d0eb9896",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -25,7 +25,7 @@ LIBS= -dead_strip \\\n  $(DEPSDIR)/lib/libboost_program_options.a \\\n  $(DEPSDIR)/lib/libboost_thread.a \\\n  $(DEPSDIR)/lib/libssl.a \\\n- $(DEPSDIR)/lib/libcrypto.a \n+ $(DEPSDIR)/lib/libcrypto.a\n \n DEFS=$(shell $(DEPSDIR)/bin/wx-config --cxxflags) -D__WXMAC_OSX__ -DNOPCH -DMSG_NOSIGNAL=0 -DUSE_SSL\n \n@@ -51,7 +51,7 @@ ifdef USE_UPNP\n \tLIBS += $(DEPSDIR)/lib/libminiupnpc.a\n \tDEFS += -DUSE_UPNP=$(USE_UPNP)\n endif\n-\t\n+\n \n all: bitcoin\n "
      },
      {
        "sha": "99be15df069adca2058f4f76d293200ebefa634e",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 916,
        "deletions": 916,
        "changes": 1832,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -58,7 +58,7 @@ void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n {\n     // Filter out duplicate requests\n     if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n-        return;\n+\treturn;\n     pindexLastGetBlocksBegin = pindexBegin;\n     hashLastGetBlocksEnd = hashEnd;\n \n@@ -75,7 +75,7 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet)\n \n     SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n     if (hSocket == INVALID_SOCKET)\n-        return false;\n+\treturn false;\n #ifdef BSD\n     int set = 1;\n     setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n@@ -87,39 +87,39 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet)\n \n     if (connect(hSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n     {\n-        closesocket(hSocket);\n-        return false;\n+\tclosesocket(hSocket);\n+\treturn false;\n     }\n \n     if (fProxy)\n     {\n-        printf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n-        char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n-        memcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n-        memcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n-        char* pszSocks4 = pszSocks4IP;\n-        int nSize = sizeof(pszSocks4IP);\n-\n-        int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n-        if (ret != nSize)\n-        {\n-            closesocket(hSocket);\n-            return error(\"Error sending to proxy\");\n-        }\n-        char pchRet[8];\n-        if (recv(hSocket, pchRet, 8, 0) != 8)\n-        {\n-            closesocket(hSocket);\n-            return error(\"Error reading proxy response\");\n-        }\n-        if (pchRet[1] != 0x5a)\n-        {\n-            closesocket(hSocket);\n-            if (pchRet[1] != 0x5b)\n-                printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n-            return false;\n-        }\n-        printf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n+\tprintf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n+\tchar pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n+\tmemcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n+\tmemcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n+\tchar* pszSocks4 = pszSocks4IP;\n+\tint nSize = sizeof(pszSocks4IP);\n+\n+\tint ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n+\tif (ret != nSize)\n+\t{\n+\t    closesocket(hSocket);\n+\t    return error(\"Error sending to proxy\");\n+\t}\n+\tchar pchRet[8];\n+\tif (recv(hSocket, pchRet, 8, 0) != 8)\n+\t{\n+\t    closesocket(hSocket);\n+\t    return error(\"Error reading proxy response\");\n+\t}\n+\tif (pchRet[1] != 0x5a)\n+\t{\n+\t    closesocket(hSocket);\n+\t    if (pchRet[1] != 0x5b)\n+\t\tprintf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n+\t    return false;\n+\t}\n+\tprintf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n     }\n \n     hSocketRet = hSocket;\n@@ -131,57 +131,57 @@ bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMa\n {\n     vaddr.clear();\n     if (pszName[0] == 0)\n-        return false;\n+\treturn false;\n     int port = portDefault;\n     char psz[256];\n     char *pszHost = psz;\n     strlcpy(psz, pszName, sizeof(psz));\n     if (fAllowPort)\n     {\n-        char* pszColon = strrchr(psz+1,':');\n-        char *pszPortEnd = NULL;\n-        int portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n-        if (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n-        {\n-            if (psz[0] == '[' && pszColon[-1] == ']')\n-            {\n-                // Future: enable IPv6 colon-notation inside []\n-                pszHost = psz+1;\n-                pszColon[-1] = 0;\n-            }\n-            else\n-                pszColon[0] = 0;\n-            port = portParsed;\n-            if (port < 0 || port > USHRT_MAX)\n-                port = USHRT_MAX;\n-        }\n+\tchar* pszColon = strrchr(psz+1,':');\n+\tchar *pszPortEnd = NULL;\n+\tint portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n+\tif (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n+\t{\n+\t    if (psz[0] == '[' && pszColon[-1] == ']')\n+\t    {\n+\t\t// Future: enable IPv6 colon-notation inside []\n+\t\tpszHost = psz+1;\n+\t\tpszColon[-1] = 0;\n+\t    }\n+\t    else\n+\t\tpszColon[0] = 0;\n+\t    port = portParsed;\n+\t    if (port < 0 || port > USHRT_MAX)\n+\t\tport = USHRT_MAX;\n+\t}\n     }\n \n     unsigned int addrIP = inet_addr(pszHost);\n     if (addrIP != INADDR_NONE)\n     {\n-        // valid IP address passed\n-        vaddr.push_back(CAddress(addrIP, port, nServices));\n-        return true;\n+\t// valid IP address passed\n+\tvaddr.push_back(CAddress(addrIP, port, nServices));\n+\treturn true;\n     }\n \n     if (!fAllowLookup)\n-        return false;\n+\treturn false;\n \n     struct hostent* phostent = gethostbyname(pszHost);\n     if (!phostent)\n-        return false;\n+\treturn false;\n \n     if (phostent->h_addrtype != AF_INET)\n-        return false;\n+\treturn false;\n \n     char** ppAddr = phostent->h_addr_list;\n     while (*ppAddr != NULL && vaddr.size() != nMaxSolutions)\n     {\n-        CAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n-        if (addr.IsValid())\n-            vaddr.push_back(addr);\n-        ppAddr++;\n+\tCAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n+\tif (addr.IsValid())\n+\t    vaddr.push_back(addr);\n+\tppAddr++;\n     }\n \n     return (vaddr.size() > 0);\n@@ -193,51 +193,51 @@ bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLooku\n     vector<CAddress> vaddr;\n     bool fRet = Lookup(pszName, vaddr, nServices, 1, fAllowLookup, portDefault, fAllowPort);\n     if (fRet)\n-        addr = vaddr[0];\n+\taddr = vaddr[0];\n     return fRet;\n }\n \n bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const char* pszKeyword, unsigned int& ipRet)\n {\n     SOCKET hSocket;\n     if (!ConnectSocket(addrConnect, hSocket))\n-        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n+\treturn error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n \n     send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n \n     string strLine;\n     while (RecvLine(hSocket, strLine))\n     {\n-        if (strLine.empty()) // HTTP response is separated from headers by blank line\n-        {\n-            loop\n-            {\n-                if (!RecvLine(hSocket, strLine))\n-                {\n-                    closesocket(hSocket);\n-                    return false;\n-                }\n-                if (pszKeyword == NULL)\n-                    break;\n-                if (strLine.find(pszKeyword) != -1)\n-                {\n-                    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n-                    break;\n-                }\n-            }\n-            closesocket(hSocket);\n-            if (strLine.find(\"<\") != -1)\n-                strLine = strLine.substr(0, strLine.find(\"<\"));\n-            strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n-            while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n-                strLine.resize(strLine.size()-1);\n-            CAddress addr(strLine,0,true);\n-            printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n-            if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n-                return false;\n-            ipRet = addr.ip;\n-            return true;\n-        }\n+\tif (strLine.empty()) // HTTP response is separated from headers by blank line\n+\t{\n+\t    loop\n+\t    {\n+\t\tif (!RecvLine(hSocket, strLine))\n+\t\t{\n+\t\t    closesocket(hSocket);\n+\t\t    return false;\n+\t\t}\n+\t\tif (pszKeyword == NULL)\n+\t\t    break;\n+\t\tif (strLine.find(pszKeyword) != -1)\n+\t\t{\n+\t\t    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t    closesocket(hSocket);\n+\t    if (strLine.find(\"<\") != -1)\n+\t\tstrLine = strLine.substr(0, strLine.find(\"<\"));\n+\t    strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n+\t    while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n+\t\tstrLine.resize(strLine.size()-1);\n+\t    CAddress addr(strLine,0,true);\n+\t    printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n+\t    if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n+\t\treturn false;\n+\t    ipRet = addr.ip;\n+\t    return true;\n+\t}\n     }\n     closesocket(hSocket);\n     return error(\"GetMyExternalIP() : connection closed\");\n@@ -251,56 +251,56 @@ bool GetMyExternalIP(unsigned int& ipRet)\n     const char* pszKeyword;\n \n     if (fUseProxy)\n-        return false;\n+\treturn false;\n \n     for (int nLookup = 0; nLookup <= 1; nLookup++)\n     for (int nHost = 1; nHost <= 2; nHost++)\n     {\n-        // We should be phasing out our use of sites like these.  If we need\n-        // replacements, we should ask for volunteers to put this simple\n-        // php file on their webserver that prints the client IP:\n-        //  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n-        if (nHost == 1)\n-        {\n-            addrConnect = CAddress(\"91.198.22.70\",80); // checkip.dyndns.org\n-\n-            if (nLookup == 1)\n-            {\n-                CAddress addrIP(\"checkip.dyndns.org\", 80, true);\n-                if (addrIP.IsValid())\n-                    addrConnect = addrIP;\n-            }\n-\n-            pszGet = \"GET / HTTP/1.1\\r\\n\"\n-                     \"Host: checkip.dyndns.org\\r\\n\"\n-                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n-                     \"Connection: close\\r\\n\"\n-                     \"\\r\\n\";\n-\n-            pszKeyword = \"Address:\";\n-        }\n-        else if (nHost == 2)\n-        {\n-            addrConnect = CAddress(\"74.208.43.192\", 80); // www.showmyip.com\n-\n-            if (nLookup == 1)\n-            {\n-                CAddress addrIP(\"www.showmyip.com\", 80, true);\n-                if (addrIP.IsValid())\n-                    addrConnect = addrIP;\n-            }\n-\n-            pszGet = \"GET /simple/ HTTP/1.1\\r\\n\"\n-                     \"Host: www.showmyip.com\\r\\n\"\n-                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n-                     \"Connection: close\\r\\n\"\n-                     \"\\r\\n\";\n-\n-            pszKeyword = NULL; // Returns just IP address\n-        }\n-\n-        if (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n-            return true;\n+\t// We should be phasing out our use of sites like these.  If we need\n+\t// replacements, we should ask for volunteers to put this simple\n+\t// php file on their webserver that prints the client IP:\n+\t//  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n+\tif (nHost == 1)\n+\t{\n+\t    addrConnect = CAddress(\"91.198.22.70\",80); // checkip.dyndns.org\n+\n+\t    if (nLookup == 1)\n+\t    {\n+\t\tCAddress addrIP(\"checkip.dyndns.org\", 80, true);\n+\t\tif (addrIP.IsValid())\n+\t\t    addrConnect = addrIP;\n+\t    }\n+\n+\t    pszGet = \"GET / HTTP/1.1\\r\\n\"\n+\t\t     \"Host: checkip.dyndns.org\\r\\n\"\n+\t\t     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n+\t\t     \"Connection: close\\r\\n\"\n+\t\t     \"\\r\\n\";\n+\n+\t    pszKeyword = \"Address:\";\n+\t}\n+\telse if (nHost == 2)\n+\t{\n+\t    addrConnect = CAddress(\"74.208.43.192\", 80); // www.showmyip.com\n+\n+\t    if (nLookup == 1)\n+\t    {\n+\t\tCAddress addrIP(\"www.showmyip.com\", 80, true);\n+\t\tif (addrIP.IsValid())\n+\t\t    addrConnect = addrIP;\n+\t    }\n+\n+\t    pszGet = \"GET /simple/ HTTP/1.1\\r\\n\"\n+\t\t     \"Host: www.showmyip.com\\r\\n\"\n+\t\t     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n+\t\t     \"Connection: close\\r\\n\"\n+\t\t     \"\\r\\n\";\n+\n+\t    pszKeyword = NULL; // Returns just IP address\n+\t}\n+\n+\tif (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n+\t    return true;\n     }\n \n     return false;\n@@ -311,28 +311,28 @@ void ThreadGetMyExternalIP(void* parg)\n     // Wait for IRC to get it first\n     if (!GetBoolArg(\"-noirc\"))\n     {\n-        for (int i = 0; i < 2 * 60; i++)\n-        {\n-            Sleep(1000);\n-            if (fGotExternalIP || fShutdown)\n-                return;\n-        }\n+\tfor (int i = 0; i < 2 * 60; i++)\n+\t{\n+\t    Sleep(1000);\n+\t    if (fGotExternalIP || fShutdown)\n+\t\treturn;\n+\t}\n     }\n \n     // Fallback in case IRC fails to get it\n     if (GetMyExternalIP(addrLocalHost.ip))\n     {\n-        printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n-        if (addrLocalHost.IsRoutable())\n-        {\n-            // If we already connected to a few before we had our IP, go back and addr them.\n-            // setAddrKnown automatically filters any duplicate sends.\n-            CAddress addr(addrLocalHost);\n-            addr.nTime = GetAdjustedTime();\n-            CRITICAL_BLOCK(cs_vNodes)\n-                foreach(CNode* pnode, vNodes)\n-                    pnode->PushAddress(addr);\n-        }\n+\tprintf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n+\tif (addrLocalHost.IsRoutable())\n+\t{\n+\t    // If we already connected to a few before we had our IP, go back and addr them.\n+\t    // setAddrKnown automatically filters any duplicate sends.\n+\t    CAddress addr(addrLocalHost);\n+\t    addr.nTime = GetAdjustedTime();\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tforeach(CNode* pnode, vNodes)\n+\t\t    pnode->PushAddress(addr);\n+\t}\n     }\n }\n \n@@ -343,42 +343,42 @@ void ThreadGetMyExternalIP(void* parg)\n bool AddAddress(CAddress addr, int64 nTimePenalty)\n {\n     if (!addr.IsRoutable())\n-        return false;\n+\treturn false;\n     if (addr.ip == addrLocalHost.ip)\n-        return false;\n+\treturn false;\n     addr.nTime = max((int64)0, (int64)addr.nTime - nTimePenalty);\n     CRITICAL_BLOCK(cs_mapAddresses)\n     {\n-        map<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n-        if (it == mapAddresses.end())\n-        {\n-            // New address\n-            printf(\"AddAddress(%s)\\n\", addr.ToString().c_str());\n-            mapAddresses.insert(make_pair(addr.GetKey(), addr));\n-            CAddrDB().WriteAddress(addr);\n-            return true;\n-        }\n-        else\n-        {\n-            bool fUpdated = false;\n-            CAddress& addrFound = (*it).second;\n-            if ((addrFound.nServices | addr.nServices) != addrFound.nServices)\n-            {\n-                // Services have been added\n-                addrFound.nServices |= addr.nServices;\n-                fUpdated = true;\n-            }\n-            bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n-            int64 nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n-            if (addrFound.nTime < addr.nTime - nUpdateInterval)\n-            {\n-                // Periodically update most recently seen time\n-                addrFound.nTime = addr.nTime;\n-                fUpdated = true;\n-            }\n-            if (fUpdated)\n-                CAddrDB().WriteAddress(addrFound);\n-        }\n+\tmap<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n+\tif (it == mapAddresses.end())\n+\t{\n+\t    // New address\n+\t    printf(\"AddAddress(%s)\\n\", addr.ToString().c_str());\n+\t    mapAddresses.insert(make_pair(addr.GetKey(), addr));\n+\t    CAddrDB().WriteAddress(addr);\n+\t    return true;\n+\t}\n+\telse\n+\t{\n+\t    bool fUpdated = false;\n+\t    CAddress& addrFound = (*it).second;\n+\t    if ((addrFound.nServices | addr.nServices) != addrFound.nServices)\n+\t    {\n+\t\t// Services have been added\n+\t\taddrFound.nServices |= addr.nServices;\n+\t\tfUpdated = true;\n+\t    }\n+\t    bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n+\t    int64 nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n+\t    if (addrFound.nTime < addr.nTime - nUpdateInterval)\n+\t    {\n+\t\t// Periodically update most recently seen time\n+\t\taddrFound.nTime = addr.nTime;\n+\t\tfUpdated = true;\n+\t    }\n+\t    if (fUpdated)\n+\t\tCAddrDB().WriteAddress(addrFound);\n+\t}\n     }\n     return false;\n }\n@@ -387,20 +387,20 @@ void AddressCurrentlyConnected(const CAddress& addr)\n {\n     CRITICAL_BLOCK(cs_mapAddresses)\n     {\n-        // Only if it's been published already\n-        map<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n-        if (it != mapAddresses.end())\n-        {\n-            CAddress& addrFound = (*it).second;\n-            int64 nUpdateInterval = 20 * 60;\n-            if (addrFound.nTime < GetAdjustedTime() - nUpdateInterval)\n-            {\n-                // Periodically update most recently seen time\n-                addrFound.nTime = GetAdjustedTime();\n-                CAddrDB addrdb;\n-                addrdb.WriteAddress(addrFound);\n-            }\n-        }\n+\t// Only if it's been published already\n+\tmap<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n+\tif (it != mapAddresses.end())\n+\t{\n+\t    CAddress& addrFound = (*it).second;\n+\t    int64 nUpdateInterval = 20 * 60;\n+\t    if (addrFound.nTime < GetAdjustedTime() - nUpdateInterval)\n+\t    {\n+\t\t// Periodically update most recently seen time\n+\t\taddrFound.nTime = GetAdjustedTime();\n+\t\tCAddrDB addrdb;\n+\t\taddrdb.WriteAddress(addrFound);\n+\t    }\n+\t}\n     }\n }\n \n@@ -414,20 +414,20 @@ void AbandonRequests(void (*fn)(void*, CDataStream&), void* param1)\n     // call this in the destructor so it doesn't get called after it's deleted.\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n-        foreach(CNode* pnode, vNodes)\n-        {\n-            CRITICAL_BLOCK(pnode->cs_mapRequests)\n-            {\n-                for (map<uint256, CRequestTracker>::iterator mi = pnode->mapRequests.begin(); mi != pnode->mapRequests.end();)\n-                {\n-                    CRequestTracker& tracker = (*mi).second;\n-                    if (tracker.fn == fn && tracker.param1 == param1)\n-                        pnode->mapRequests.erase(mi++);\n-                    else\n-                        mi++;\n-                }\n-            }\n-        }\n+\tforeach(CNode* pnode, vNodes)\n+\t{\n+\t    CRITICAL_BLOCK(pnode->cs_mapRequests)\n+\t    {\n+\t\tfor (map<uint256, CRequestTracker>::iterator mi = pnode->mapRequests.begin(); mi != pnode->mapRequests.end();)\n+\t\t{\n+\t\t    CRequestTracker& tracker = (*mi).second;\n+\t\t    if (tracker.fn == fn && tracker.param1 == param1)\n+\t\t\tpnode->mapRequests.erase(mi++);\n+\t\t    else\n+\t\t\tmi++;\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n \n@@ -449,33 +449,33 @@ void AbandonRequests(void (*fn)(void*, CDataStream&), void* param1)\n bool AnySubscribed(unsigned int nChannel)\n {\n     if (pnodeLocalHost->IsSubscribed(nChannel))\n-        return true;\n+\treturn true;\n     CRITICAL_BLOCK(cs_vNodes)\n-        foreach(CNode* pnode, vNodes)\n-            if (pnode->IsSubscribed(nChannel))\n-                return true;\n+\tforeach(CNode* pnode, vNodes)\n+\t    if (pnode->IsSubscribed(nChannel))\n+\t\treturn true;\n     return false;\n }\n \n bool CNode::IsSubscribed(unsigned int nChannel)\n {\n     if (nChannel >= vfSubscribe.size())\n-        return false;\n+\treturn false;\n     return vfSubscribe[nChannel];\n }\n \n void CNode::Subscribe(unsigned int nChannel, unsigned int nHops)\n {\n     if (nChannel >= vfSubscribe.size())\n-        return;\n+\treturn;\n \n     if (!AnySubscribed(nChannel))\n     {\n-        // Relay subscribe\n-        CRITICAL_BLOCK(cs_vNodes)\n-            foreach(CNode* pnode, vNodes)\n-                if (pnode != this)\n-                    pnode->PushMessage(\"subscribe\", nChannel, nHops);\n+\t// Relay subscribe\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t    foreach(CNode* pnode, vNodes)\n+\t\tif (pnode != this)\n+\t\t    pnode->PushMessage(\"subscribe\", nChannel, nHops);\n     }\n \n     vfSubscribe[nChannel] = true;\n@@ -484,20 +484,20 @@ void CNode::Subscribe(unsigned int nChannel, unsigned int nHops)\n void CNode::CancelSubscribe(unsigned int nChannel)\n {\n     if (nChannel >= vfSubscribe.size())\n-        return;\n+\treturn;\n \n     // Prevent from relaying cancel if wasn't subscribed\n     if (!vfSubscribe[nChannel])\n-        return;\n+\treturn;\n     vfSubscribe[nChannel] = false;\n \n     if (!AnySubscribed(nChannel))\n     {\n-        // Relay subscription cancel\n-        CRITICAL_BLOCK(cs_vNodes)\n-            foreach(CNode* pnode, vNodes)\n-                if (pnode != this)\n-                    pnode->PushMessage(\"sub-cancel\", nChannel);\n+\t// Relay subscription cancel\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t    foreach(CNode* pnode, vNodes)\n+\t\tif (pnode != this)\n+\t\t    pnode->PushMessage(\"sub-cancel\", nChannel);\n     }\n }\n \n@@ -513,9 +513,9 @@ CNode* FindNode(unsigned int ip)\n {\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n-        foreach(CNode* pnode, vNodes)\n-            if (pnode->addr.ip == ip)\n-                return (pnode);\n+\tforeach(CNode* pnode, vNodes)\n+\t    if (pnode->addr.ip == ip)\n+\t\treturn (pnode);\n     }\n     return NULL;\n }\n@@ -524,70 +524,70 @@ CNode* FindNode(CAddress addr)\n {\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n-        foreach(CNode* pnode, vNodes)\n-            if (pnode->addr == addr)\n-                return (pnode);\n+\tforeach(CNode* pnode, vNodes)\n+\t    if (pnode->addr == addr)\n+\t\treturn (pnode);\n     }\n     return NULL;\n }\n \n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n {\n     if (addrConnect.ip == addrLocalHost.ip)\n-        return NULL;\n+\treturn NULL;\n \n     // Look for an existing connection\n     CNode* pnode = FindNode(addrConnect.ip);\n     if (pnode)\n     {\n-        if (nTimeout != 0)\n-            pnode->AddRef(nTimeout);\n-        else\n-            pnode->AddRef();\n-        return pnode;\n+\tif (nTimeout != 0)\n+\t    pnode->AddRef(nTimeout);\n+\telse\n+\t    pnode->AddRef();\n+\treturn pnode;\n     }\n \n     /// debug print\n     printf(\"trying connection %s lastseen=%.1fhrs lasttry=%.1fhrs\\n\",\n-        addrConnect.ToString().c_str(),\n-        (double)(addrConnect.nTime - GetAdjustedTime())/3600.0,\n-        (double)(addrConnect.nLastTry - GetAdjustedTime())/3600.0);\n+\taddrConnect.ToString().c_str(),\n+\t(double)(addrConnect.nTime - GetAdjustedTime())/3600.0,\n+\t(double)(addrConnect.nLastTry - GetAdjustedTime())/3600.0);\n \n     CRITICAL_BLOCK(cs_mapAddresses)\n-        mapAddresses[addrConnect.GetKey()].nLastTry = GetAdjustedTime();\n+\tmapAddresses[addrConnect.GetKey()].nLastTry = GetAdjustedTime();\n \n     // Connect\n     SOCKET hSocket;\n     if (ConnectSocket(addrConnect, hSocket))\n     {\n-        /// debug print\n-        printf(\"connected %s\\n\", addrConnect.ToString().c_str());\n+\t/// debug print\n+\tprintf(\"connected %s\\n\", addrConnect.ToString().c_str());\n \n-        // Set to nonblocking\n+\t// Set to nonblocking\n #ifdef __WXMSW__\n-        u_long nOne = 1;\n-        if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n-            printf(\"ConnectSocket() : ioctlsocket nonblocking setting failed, error %d\\n\", WSAGetLastError());\n+\tu_long nOne = 1;\n+\tif (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n+\t    printf(\"ConnectSocket() : ioctlsocket nonblocking setting failed, error %d\\n\", WSAGetLastError());\n #else\n-        if (fcntl(hSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n-            printf(\"ConnectSocket() : fcntl nonblocking setting failed, error %d\\n\", errno);\n+\tif (fcntl(hSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n+\t    printf(\"ConnectSocket() : fcntl nonblocking setting failed, error %d\\n\", errno);\n #endif\n \n-        // Add node\n-        CNode* pnode = new CNode(hSocket, addrConnect, false);\n-        if (nTimeout != 0)\n-            pnode->AddRef(nTimeout);\n-        else\n-            pnode->AddRef();\n-        CRITICAL_BLOCK(cs_vNodes)\n-            vNodes.push_back(pnode);\n-\n-        pnode->nTimeConnected = GetTime();\n-        return pnode;\n+\t// Add node\n+\tCNode* pnode = new CNode(hSocket, addrConnect, false);\n+\tif (nTimeout != 0)\n+\t    pnode->AddRef(nTimeout);\n+\telse\n+\t    pnode->AddRef();\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t    vNodes.push_back(pnode);\n+\n+\tpnode->nTimeConnected = GetTime();\n+\treturn pnode;\n     }\n     else\n     {\n-        return NULL;\n+\treturn NULL;\n     }\n }\n \n@@ -596,11 +596,11 @@ void CNode::CloseSocketDisconnect()\n     fDisconnect = true;\n     if (hSocket != INVALID_SOCKET)\n     {\n-        if (fDebug)\n-            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-        printf(\"disconnecting node %s\\n\", addr.ToString().c_str());\n-        closesocket(hSocket);\n-        hSocket = INVALID_SOCKET;\n+\tif (fDebug)\n+\t    printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\tprintf(\"disconnecting node %s\\n\", addr.ToString().c_str());\n+\tclosesocket(hSocket);\n+\thSocket = INVALID_SOCKET;\n     }\n }\n \n@@ -611,8 +611,8 @@ void CNode::Cleanup()\n \n     // Cancel subscriptions\n     for (unsigned int nChannel = 0; nChannel < vfSubscribe.size(); nChannel++)\n-        if (vfSubscribe[nChannel])\n-            CancelSubscribe(nChannel);\n+\tif (vfSubscribe[nChannel])\n+\t    CancelSubscribe(nChannel);\n }\n \n \n@@ -632,16 +632,16 @@ void ThreadSocketHandler(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadSocketHandler(parg));\n     try\n     {\n-        vnThreadsRunning[0]++;\n-        ThreadSocketHandler2(parg);\n-        vnThreadsRunning[0]--;\n+\tvnThreadsRunning[0]++;\n+\tThreadSocketHandler2(parg);\n+\tvnThreadsRunning[0]--;\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[0]--;\n-        PrintException(&e, \"ThreadSocketHandler()\");\n+\tvnThreadsRunning[0]--;\n+\tPrintException(&e, \"ThreadSocketHandler()\");\n     } catch (...) {\n-        vnThreadsRunning[0]--;\n-        throw; // support pthread_cancel()\n+\tvnThreadsRunning[0]--;\n+\tthrow; // support pthread_cancel()\n     }\n     printf(\"ThreadSocketHandler exiting\\n\");\n }\n@@ -654,278 +654,278 @@ void ThreadSocketHandler2(void* parg)\n \n     loop\n     {\n-        //\n-        // Disconnect nodes\n-        //\n-        CRITICAL_BLOCK(cs_vNodes)\n-        {\n-            // Disconnect unused nodes\n-            vector<CNode*> vNodesCopy = vNodes;\n-            foreach(CNode* pnode, vNodesCopy)\n-            {\n-                if (pnode->fDisconnect ||\n-                    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n-                {\n-                    // remove from vNodes\n-                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n-\n-                    // close socket and cleanup\n-                    pnode->CloseSocketDisconnect();\n-                    pnode->Cleanup();\n-\n-                    // hold in disconnected pool until all refs are released\n-                    pnode->nReleaseTime = max(pnode->nReleaseTime, GetTime() + 15 * 60);\n-                    if (pnode->fNetworkNode || pnode->fInbound)\n-                        pnode->Release();\n-                    vNodesDisconnected.push_back(pnode);\n-                }\n-            }\n-\n-            // Delete disconnected nodes\n-            list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            foreach(CNode* pnode, vNodesDisconnectedCopy)\n-            {\n-                // wait until threads are done using it\n-                if (pnode->GetRefCount() <= 0)\n-                {\n-                    bool fDelete = false;\n-                    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                     TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-                      TRY_CRITICAL_BLOCK(pnode->cs_mapRequests)\n-                       TRY_CRITICAL_BLOCK(pnode->cs_inventory)\n-                        fDelete = true;\n-                    if (fDelete)\n-                    {\n-                        vNodesDisconnected.remove(pnode);\n-                        delete pnode;\n-                    }\n-                }\n-            }\n-        }\n-        if (vNodes.size() != nPrevNodeCount)\n-        {\n-            nPrevNodeCount = vNodes.size();\n-            MainFrameRepaint();\n-        }\n-\n-\n-        //\n-        // Find which sockets have data to receive\n-        //\n-        struct timeval timeout;\n-        timeout.tv_sec  = 0;\n-        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n-\n-        fd_set fdsetRecv;\n-        fd_set fdsetSend;\n-        fd_set fdsetError;\n-        FD_ZERO(&fdsetRecv);\n-        FD_ZERO(&fdsetSend);\n-        FD_ZERO(&fdsetError);\n-        SOCKET hSocketMax = 0;\n-\n-        if(hListenSocket != INVALID_SOCKET)\n-            FD_SET(hListenSocket, &fdsetRecv);\n-        hSocketMax = max(hSocketMax, hListenSocket);\n-        CRITICAL_BLOCK(cs_vNodes)\n-        {\n-            foreach(CNode* pnode, vNodes)\n-            {\n-                if (pnode->hSocket == INVALID_SOCKET || pnode->hSocket < 0)\n-                    continue;\n-                FD_SET(pnode->hSocket, &fdsetRecv);\n-                FD_SET(pnode->hSocket, &fdsetError);\n-                hSocketMax = max(hSocketMax, pnode->hSocket);\n-                TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                    if (!pnode->vSend.empty())\n-                        FD_SET(pnode->hSocket, &fdsetSend);\n-            }\n-        }\n-\n-        vnThreadsRunning[0]--;\n-        int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-        vnThreadsRunning[0]++;\n-        if (fShutdown)\n-            return;\n-        if (nSelect == SOCKET_ERROR)\n-        {\n-            int nErr = WSAGetLastError();\n-            printf(\"socket select error %d\\n\", nErr);\n-            for (int i = 0; i <= hSocketMax; i++)\n-                FD_SET(i, &fdsetRecv);\n-            FD_ZERO(&fdsetSend);\n-            FD_ZERO(&fdsetError);\n-            Sleep(timeout.tv_usec/1000);\n-        }\n-\n-\n-        //\n-        // Accept new connections\n-        //\n-        if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n-        {\n-            struct sockaddr_in sockaddr;\n-            socklen_t len = sizeof(sockaddr);\n-            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n-            CAddress addr(sockaddr);\n-            int nInbound = 0;\n-\n-            CRITICAL_BLOCK(cs_vNodes)\n-                foreach(CNode* pnode, vNodes)\n-                if (pnode->fInbound)\n-                    nInbound++;\n-            if (hSocket == INVALID_SOCKET)\n-            {\n-                if (WSAGetLastError() != WSAEWOULDBLOCK)\n-                    printf(\"socket error accept failed: %d\\n\", WSAGetLastError());\n-            }\n-            else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n-            {\n-                closesocket(hSocket);\n-            }\n-            else\n-            {\n-                printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n-                CNode* pnode = new CNode(hSocket, addr, true);\n-                pnode->AddRef();\n-                CRITICAL_BLOCK(cs_vNodes)\n-                    vNodes.push_back(pnode);\n-            }\n-        }\n-\n-\n-        //\n-        // Service each socket\n-        //\n-        vector<CNode*> vNodesCopy;\n-        CRITICAL_BLOCK(cs_vNodes)\n-        {\n-            vNodesCopy = vNodes;\n-            foreach(CNode* pnode, vNodesCopy)\n-                pnode->AddRef();\n-        }\n-        foreach(CNode* pnode, vNodesCopy)\n-        {\n-            if (fShutdown)\n-                return;\n-\n-            //\n-            // Receive\n-            //\n-            if (pnode->hSocket == INVALID_SOCKET)\n-                continue;\n-            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n-            {\n-                TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-                {\n-                    CDataStream& vRecv = pnode->vRecv;\n-                    unsigned int nPos = vRecv.size();\n-\n-                    if (nPos > 1000*GetArg(\"-maxreceivebuffer\", 10*1000)) {\n-                        if (!pnode->fDisconnect)\n-                            printf(\"socket recv flood control disconnect (%d bytes)\\n\", vRecv.size());\n-                        pnode->CloseSocketDisconnect();\n-                    }\n-                    else {\n-                        // typical socket buffer is 8K-64K\n-                        char pchBuf[0x10000];\n-                        int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n-                        if (nBytes > 0)\n-                        {\n-                            vRecv.resize(nPos + nBytes);\n-                            memcpy(&vRecv[nPos], pchBuf, nBytes);\n-                            pnode->nLastRecv = GetTime();\n-                        }\n-                        else if (nBytes == 0)\n-                        {\n-                            // socket closed gracefully\n-                            if (!pnode->fDisconnect)\n-                                printf(\"socket closed\\n\");\n-                            pnode->CloseSocketDisconnect();\n-                        }\n-                        else if (nBytes < 0)\n-                        {\n-                            // error\n-                            int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                            {\n-                                if (!pnode->fDisconnect)\n-                                    printf(\"socket recv error %d\\n\", nErr);\n-                                pnode->CloseSocketDisconnect();\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            //\n-            // Send\n-            //\n-            if (pnode->hSocket == INVALID_SOCKET)\n-                continue;\n-            if (FD_ISSET(pnode->hSocket, &fdsetSend))\n-            {\n-                TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                {\n-                    CDataStream& vSend = pnode->vSend;\n-                    if (!vSend.empty())\n-                    {\n-                        int nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n-                        if (nBytes > 0)\n-                        {\n-                            vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n-                            pnode->nLastSend = GetTime();\n-                        }\n-                        else if (nBytes < 0)\n-                        {\n-                            // error\n-                            int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                            {\n-                                printf(\"socket send error %d\\n\", nErr);\n-                                pnode->CloseSocketDisconnect();\n-                            }\n-                        }\n-                        if (vSend.size() > 1000*GetArg(\"-maxsendbuffer\", 10*1000)) {\n-                            if (!pnode->fDisconnect)\n-                                printf(\"socket send flood control disconnect (%d bytes)\\n\", vSend.size());\n-                            pnode->CloseSocketDisconnect();\n-                        }\n-                    }\n-                }\n-            }\n-\n-            //\n-            // Inactivity checking\n-            //\n-            if (pnode->vSend.empty())\n-                pnode->nLastSendEmpty = GetTime();\n-            if (GetTime() - pnode->nTimeConnected > 60)\n-            {\n-                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n-                {\n-                    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n-                    pnode->fDisconnect = true;\n-                }\n-                else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n-                {\n-                    printf(\"socket not sending\\n\");\n-                    pnode->fDisconnect = true;\n-                }\n-                else if (GetTime() - pnode->nLastRecv > 90*60)\n-                {\n-                    printf(\"socket inactivity timeout\\n\");\n-                    pnode->fDisconnect = true;\n-                }\n-            }\n-        }\n-        CRITICAL_BLOCK(cs_vNodes)\n-        {\n-            foreach(CNode* pnode, vNodesCopy)\n-                pnode->Release();\n-        }\n-\n-        Sleep(10);\n+\t//\n+\t// Disconnect nodes\n+\t//\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t{\n+\t    // Disconnect unused nodes\n+\t    vector<CNode*> vNodesCopy = vNodes;\n+\t    foreach(CNode* pnode, vNodesCopy)\n+\t    {\n+\t\tif (pnode->fDisconnect ||\n+\t\t    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n+\t\t{\n+\t\t    // remove from vNodes\n+\t\t    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n+\n+\t\t    // close socket and cleanup\n+\t\t    pnode->CloseSocketDisconnect();\n+\t\t    pnode->Cleanup();\n+\n+\t\t    // hold in disconnected pool until all refs are released\n+\t\t    pnode->nReleaseTime = max(pnode->nReleaseTime, GetTime() + 15 * 60);\n+\t\t    if (pnode->fNetworkNode || pnode->fInbound)\n+\t\t\tpnode->Release();\n+\t\t    vNodesDisconnected.push_back(pnode);\n+\t\t}\n+\t    }\n+\n+\t    // Delete disconnected nodes\n+\t    list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n+\t    foreach(CNode* pnode, vNodesDisconnectedCopy)\n+\t    {\n+\t\t// wait until threads are done using it\n+\t\tif (pnode->GetRefCount() <= 0)\n+\t\t{\n+\t\t    bool fDelete = false;\n+\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t     TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t\t      TRY_CRITICAL_BLOCK(pnode->cs_mapRequests)\n+\t\t       TRY_CRITICAL_BLOCK(pnode->cs_inventory)\n+\t\t\tfDelete = true;\n+\t\t    if (fDelete)\n+\t\t    {\n+\t\t\tvNodesDisconnected.remove(pnode);\n+\t\t\tdelete pnode;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\tif (vNodes.size() != nPrevNodeCount)\n+\t{\n+\t    nPrevNodeCount = vNodes.size();\n+\t    MainFrameRepaint();\n+\t}\n+\n+\n+\t//\n+\t// Find which sockets have data to receive\n+\t//\n+\tstruct timeval timeout;\n+\ttimeout.tv_sec  = 0;\n+\ttimeout.tv_usec = 50000; // frequency to poll pnode->vSend\n+\n+\tfd_set fdsetRecv;\n+\tfd_set fdsetSend;\n+\tfd_set fdsetError;\n+\tFD_ZERO(&fdsetRecv);\n+\tFD_ZERO(&fdsetSend);\n+\tFD_ZERO(&fdsetError);\n+\tSOCKET hSocketMax = 0;\n+\n+\tif(hListenSocket != INVALID_SOCKET)\n+\t    FD_SET(hListenSocket, &fdsetRecv);\n+\thSocketMax = max(hSocketMax, hListenSocket);\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t{\n+\t    foreach(CNode* pnode, vNodes)\n+\t    {\n+\t\tif (pnode->hSocket == INVALID_SOCKET || pnode->hSocket < 0)\n+\t\t    continue;\n+\t\tFD_SET(pnode->hSocket, &fdsetRecv);\n+\t\tFD_SET(pnode->hSocket, &fdsetError);\n+\t\thSocketMax = max(hSocketMax, pnode->hSocket);\n+\t\tTRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t    if (!pnode->vSend.empty())\n+\t\t\tFD_SET(pnode->hSocket, &fdsetSend);\n+\t    }\n+\t}\n+\n+\tvnThreadsRunning[0]--;\n+\tint nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+\tvnThreadsRunning[0]++;\n+\tif (fShutdown)\n+\t    return;\n+\tif (nSelect == SOCKET_ERROR)\n+\t{\n+\t    int nErr = WSAGetLastError();\n+\t    printf(\"socket select error %d\\n\", nErr);\n+\t    for (int i = 0; i <= hSocketMax; i++)\n+\t\tFD_SET(i, &fdsetRecv);\n+\t    FD_ZERO(&fdsetSend);\n+\t    FD_ZERO(&fdsetError);\n+\t    Sleep(timeout.tv_usec/1000);\n+\t}\n+\n+\n+\t//\n+\t// Accept new connections\n+\t//\n+\tif (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n+\t{\n+\t    struct sockaddr_in sockaddr;\n+\t    socklen_t len = sizeof(sockaddr);\n+\t    SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n+\t    CAddress addr(sockaddr);\n+\t    int nInbound = 0;\n+\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tforeach(CNode* pnode, vNodes)\n+\t\tif (pnode->fInbound)\n+\t\t    nInbound++;\n+\t    if (hSocket == INVALID_SOCKET)\n+\t    {\n+\t\tif (WSAGetLastError() != WSAEWOULDBLOCK)\n+\t\t    printf(\"socket error accept failed: %d\\n\", WSAGetLastError());\n+\t    }\n+\t    else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n+\t    {\n+\t\tclosesocket(hSocket);\n+\t    }\n+\t    else\n+\t    {\n+\t\tprintf(\"accepted connection %s\\n\", addr.ToString().c_str());\n+\t\tCNode* pnode = new CNode(hSocket, addr, true);\n+\t\tpnode->AddRef();\n+\t\tCRITICAL_BLOCK(cs_vNodes)\n+\t\t    vNodes.push_back(pnode);\n+\t    }\n+\t}\n+\n+\n+\t//\n+\t// Service each socket\n+\t//\n+\tvector<CNode*> vNodesCopy;\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t{\n+\t    vNodesCopy = vNodes;\n+\t    foreach(CNode* pnode, vNodesCopy)\n+\t\tpnode->AddRef();\n+\t}\n+\tforeach(CNode* pnode, vNodesCopy)\n+\t{\n+\t    if (fShutdown)\n+\t\treturn;\n+\n+\t    //\n+\t    // Receive\n+\t    //\n+\t    if (pnode->hSocket == INVALID_SOCKET)\n+\t\tcontinue;\n+\t    if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n+\t    {\n+\t\tTRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t\t{\n+\t\t    CDataStream& vRecv = pnode->vRecv;\n+\t\t    unsigned int nPos = vRecv.size();\n+\n+\t\t    if (nPos > 1000*GetArg(\"-maxreceivebuffer\", 10*1000)) {\n+\t\t\tif (!pnode->fDisconnect)\n+\t\t\t    printf(\"socket recv flood control disconnect (%d bytes)\\n\", vRecv.size());\n+\t\t\tpnode->CloseSocketDisconnect();\n+\t\t    }\n+\t\t    else {\n+\t\t\t// typical socket buffer is 8K-64K\n+\t\t\tchar pchBuf[0x10000];\n+\t\t\tint nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n+\t\t\tif (nBytes > 0)\n+\t\t\t{\n+\t\t\t    vRecv.resize(nPos + nBytes);\n+\t\t\t    memcpy(&vRecv[nPos], pchBuf, nBytes);\n+\t\t\t    pnode->nLastRecv = GetTime();\n+\t\t\t}\n+\t\t\telse if (nBytes == 0)\n+\t\t\t{\n+\t\t\t    // socket closed gracefully\n+\t\t\t    if (!pnode->fDisconnect)\n+\t\t\t\tprintf(\"socket closed\\n\");\n+\t\t\t    pnode->CloseSocketDisconnect();\n+\t\t\t}\n+\t\t\telse if (nBytes < 0)\n+\t\t\t{\n+\t\t\t    // error\n+\t\t\t    int nErr = WSAGetLastError();\n+\t\t\t    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+\t\t\t    {\n+\t\t\t\tif (!pnode->fDisconnect)\n+\t\t\t\t    printf(\"socket recv error %d\\n\", nErr);\n+\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t    //\n+\t    // Send\n+\t    //\n+\t    if (pnode->hSocket == INVALID_SOCKET)\n+\t\tcontinue;\n+\t    if (FD_ISSET(pnode->hSocket, &fdsetSend))\n+\t    {\n+\t\tTRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t{\n+\t\t    CDataStream& vSend = pnode->vSend;\n+\t\t    if (!vSend.empty())\n+\t\t    {\n+\t\t\tint nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n+\t\t\tif (nBytes > 0)\n+\t\t\t{\n+\t\t\t    vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n+\t\t\t    pnode->nLastSend = GetTime();\n+\t\t\t}\n+\t\t\telse if (nBytes < 0)\n+\t\t\t{\n+\t\t\t    // error\n+\t\t\t    int nErr = WSAGetLastError();\n+\t\t\t    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+\t\t\t    {\n+\t\t\t\tprintf(\"socket send error %d\\n\", nErr);\n+\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t    }\n+\t\t\t}\n+\t\t\tif (vSend.size() > 1000*GetArg(\"-maxsendbuffer\", 10*1000)) {\n+\t\t\t    if (!pnode->fDisconnect)\n+\t\t\t\tprintf(\"socket send flood control disconnect (%d bytes)\\n\", vSend.size());\n+\t\t\t    pnode->CloseSocketDisconnect();\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t    //\n+\t    // Inactivity checking\n+\t    //\n+\t    if (pnode->vSend.empty())\n+\t\tpnode->nLastSendEmpty = GetTime();\n+\t    if (GetTime() - pnode->nTimeConnected > 60)\n+\t    {\n+\t\tif (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n+\t\t{\n+\t\t    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n+\t\t    pnode->fDisconnect = true;\n+\t\t}\n+\t\telse if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n+\t\t{\n+\t\t    printf(\"socket not sending\\n\");\n+\t\t    pnode->fDisconnect = true;\n+\t\t}\n+\t\telse if (GetTime() - pnode->nLastRecv > 90*60)\n+\t\t{\n+\t\t    printf(\"socket inactivity timeout\\n\");\n+\t\t    pnode->fDisconnect = true;\n+\t\t}\n+\t    }\n+\t}\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t{\n+\t    foreach(CNode* pnode, vNodesCopy)\n+\t\tpnode->Release();\n+\t}\n+\n+\tSleep(10);\n     }\n }\n \n@@ -943,16 +943,16 @@ void ThreadMapPort(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadMapPort(parg));\n     try\n     {\n-        vnThreadsRunning[5]++;\n-        ThreadMapPort2(parg);\n-        vnThreadsRunning[5]--;\n+\tvnThreadsRunning[5]++;\n+\tThreadMapPort2(parg);\n+\tvnThreadsRunning[5]--;\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[5]--;\n-        PrintException(&e, \"ThreadMapPort()\");\n+\tvnThreadsRunning[5]--;\n+\tPrintException(&e, \"ThreadMapPort()\");\n     } catch (...) {\n-        vnThreadsRunning[5]--;\n-        PrintException(NULL, \"ThreadMapPort()\");\n+\tvnThreadsRunning[5]--;\n+\tPrintException(NULL, \"ThreadMapPort()\");\n     }\n     printf(\"ThreadMapPort exiting\\n\");\n }\n@@ -979,56 +979,56 @@ void ThreadMapPort2(void* parg)\n     r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n     if (r == 1)\n     {\n-        char intClient[16];\n-        char intPort[6];\n+\tchar intClient[16];\n+\tchar intPort[6];\n \n #ifndef __WXMSW__\n-        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-\t                        port, port, lanaddr, 0, \"TCP\", 0);\n+\tr = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n+\t\t\t\tport, port, lanaddr, 0, \"TCP\", 0);\n #else\n-        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-\t                        port, port, lanaddr, 0, \"TCP\", 0, \"0\");\n+\tr = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n+\t\t\t\tport, port, lanaddr, 0, \"TCP\", 0, \"0\");\n #endif\n-        if(r!=UPNPCOMMAND_SUCCESS)\n-            printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n-                port, port, lanaddr, r, strupnperror(r));\n-        else\n-            printf(\"UPnP Port Mapping successful.\\n\");\n-        loop {\n-            if (fShutdown || !fUseUPnP)\n-            {\n-                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port, \"TCP\", 0);\n-                printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n-                freeUPNPDevlist(devlist); devlist = 0;\n-                FreeUPNPUrls(&urls);\n-                return;\n-            }\n-            Sleep(2000);\n-        }\n+\tif(r!=UPNPCOMMAND_SUCCESS)\n+\t    printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n+\t\tport, port, lanaddr, r, strupnperror(r));\n+\telse\n+\t    printf(\"UPnP Port Mapping successful.\\n\");\n+\tloop {\n+\t    if (fShutdown || !fUseUPnP)\n+\t    {\n+\t\tr = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port, \"TCP\", 0);\n+\t\tprintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+\t\tfreeUPNPDevlist(devlist); devlist = 0;\n+\t\tFreeUPNPUrls(&urls);\n+\t\treturn;\n+\t    }\n+\t    Sleep(2000);\n+\t}\n     } else {\n-        printf(\"No valid UPnP IGDs found\\n\");\n-        freeUPNPDevlist(devlist); devlist = 0;\n-        if (r != 0)\n-            FreeUPNPUrls(&urls);\n-        loop {\n-            if (fShutdown || !fUseUPnP)\n-                return;\n-            Sleep(2000);\n-        }\n+\tprintf(\"No valid UPnP IGDs found\\n\");\n+\tfreeUPNPDevlist(devlist); devlist = 0;\n+\tif (r != 0)\n+\t    FreeUPNPUrls(&urls);\n+\tloop {\n+\t    if (fShutdown || !fUseUPnP)\n+\t\treturn;\n+\t    Sleep(2000);\n+\t}\n     }\n }\n \n void MapPort(bool fMapPort)\n {\n     if (fUseUPnP != fMapPort)\n     {\n-        fUseUPnP = fMapPort;\n-        CWalletDB().WriteSetting(\"fUseUPnP\", fUseUPnP);\n+\tfUseUPnP = fMapPort;\n+\tCWalletDB().WriteSetting(\"fUseUPnP\", fUseUPnP);\n     }\n     if (fUseUPnP && vnThreadsRunning[5] < 1)\n     {\n-        if (!CreateThread(ThreadMapPort, NULL))\n-            printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n+\tif (!CreateThread(ThreadMapPort, NULL))\n+\t    printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n     }\n }\n #endif\n@@ -1054,19 +1054,19 @@ void DNSAddressSeed()\n     printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n     for (int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n-        vector<CAddress> vaddr;\n-        if (Lookup(strDNSSeed[seed_idx], vaddr, NODE_NETWORK, true))\n-        {\n-            foreach (CAddress& addr, vaddr)\n-            {\n-                if (addr.GetByte(3) != 127)\n-                {\n-                    addr.nTime = 0;\n-                    AddAddress(addr);\n-                    found++;\n-                }\n-            }\n-        }\n+\tvector<CAddress> vaddr;\n+\tif (Lookup(strDNSSeed[seed_idx], vaddr, NODE_NETWORK, true))\n+\t{\n+\t    foreach (CAddress& addr, vaddr)\n+\t    {\n+\t\tif (addr.GetByte(3) != 127)\n+\t\t{\n+\t\t    addr.nTime = 0;\n+\t\t    AddAddress(addr);\n+\t\t    found++;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n     printf(\"%d addresses found from DNS seeds\\n\", found);\n@@ -1125,16 +1125,16 @@ void ThreadOpenConnections(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadOpenConnections(parg));\n     try\n     {\n-        vnThreadsRunning[1]++;\n-        ThreadOpenConnections2(parg);\n-        vnThreadsRunning[1]--;\n+\tvnThreadsRunning[1]++;\n+\tThreadOpenConnections2(parg);\n+\tvnThreadsRunning[1]--;\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[1]--;\n-        PrintException(&e, \"ThreadOpenConnections()\");\n+\tvnThreadsRunning[1]--;\n+\tPrintException(&e, \"ThreadOpenConnections()\");\n     } catch (...) {\n-        vnThreadsRunning[1]--;\n-        PrintException(NULL, \"ThreadOpenConnections()\");\n+\tvnThreadsRunning[1]--;\n+\tPrintException(NULL, \"ThreadOpenConnections()\");\n     }\n     printf(\"ThreadOpenConnections exiting\\n\");\n }\n@@ -1146,184 +1146,184 @@ void ThreadOpenConnections2(void* parg)\n     // Connect to specific addresses\n     if (mapArgs.count(\"-connect\"))\n     {\n-        for (int64 nLoop = 0;; nLoop++)\n-        {\n-            foreach(string strAddr, mapMultiArgs[\"-connect\"])\n-            {\n-                CAddress addr(strAddr, fAllowDNS);\n-                if (addr.IsValid())\n-                    OpenNetworkConnection(addr);\n-                for (int i = 0; i < 10 && i < nLoop; i++)\n-                {\n-                    Sleep(500);\n-                    if (fShutdown)\n-                        return;\n-                }\n-            }\n-        }\n+\tfor (int64 nLoop = 0;; nLoop++)\n+\t{\n+\t    foreach(string strAddr, mapMultiArgs[\"-connect\"])\n+\t    {\n+\t\tCAddress addr(strAddr, fAllowDNS);\n+\t\tif (addr.IsValid())\n+\t\t    OpenNetworkConnection(addr);\n+\t\tfor (int i = 0; i < 10 && i < nLoop; i++)\n+\t\t{\n+\t\t    Sleep(500);\n+\t\t    if (fShutdown)\n+\t\t\treturn;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n     // Connect to manually added nodes first\n     if (mapArgs.count(\"-addnode\"))\n     {\n-        foreach(string strAddr, mapMultiArgs[\"-addnode\"])\n-        {\n-            CAddress addr(strAddr, fAllowDNS);\n-            if (addr.IsValid())\n-            {\n-                OpenNetworkConnection(addr);\n-                Sleep(500);\n-                if (fShutdown)\n-                    return;\n-            }\n-        }\n+\tforeach(string strAddr, mapMultiArgs[\"-addnode\"])\n+\t{\n+\t    CAddress addr(strAddr, fAllowDNS);\n+\t    if (addr.IsValid())\n+\t    {\n+\t\tOpenNetworkConnection(addr);\n+\t\tSleep(500);\n+\t\tif (fShutdown)\n+\t\t    return;\n+\t    }\n+\t}\n     }\n \n     // Initiate network connections\n     int64 nStart = GetTime();\n     loop\n     {\n-        // Limit outbound connections\n-        vnThreadsRunning[1]--;\n-        Sleep(500);\n-        loop\n-        {\n-            int nOutbound = 0;\n-            CRITICAL_BLOCK(cs_vNodes)\n-                foreach(CNode* pnode, vNodes)\n-                    if (!pnode->fInbound)\n-                        nOutbound++;\n-            int nMaxOutboundConnections = MAX_OUTBOUND_CONNECTIONS;\n-            nMaxOutboundConnections = min(nMaxOutboundConnections, (int)GetArg(\"-maxconnections\", 125));\n-            if (nOutbound < nMaxOutboundConnections)\n-                break;\n-            Sleep(2000);\n-            if (fShutdown)\n-                return;\n-        }\n-        vnThreadsRunning[1]++;\n-        if (fShutdown)\n-            return;\n-\n-        CRITICAL_BLOCK(cs_mapAddresses)\n-        {\n-            // Add seed nodes if IRC isn't working\n-            static bool fSeedUsed;\n-            bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n-            if (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n-            {\n-                for (int i = 0; i < ARRAYLEN(pnSeed); i++)\n-                {\n-                    // It'll only connect to one or two seed nodes because once it connects,\n-                    // it'll get a pile of addresses with newer timestamps.\n-                    CAddress addr;\n-                    addr.ip = pnSeed[i];\n-                    addr.nTime = 0;\n-                    AddAddress(addr);\n-                }\n-                fSeedUsed = true;\n-            }\n-\n-            if (fSeedUsed && mapAddresses.size() > ARRAYLEN(pnSeed) + 100)\n-            {\n-                // Disconnect seed nodes\n-                set<unsigned int> setSeed(pnSeed, pnSeed + ARRAYLEN(pnSeed));\n-                static int64 nSeedDisconnected;\n-                if (nSeedDisconnected == 0)\n-                {\n-                    nSeedDisconnected = GetTime();\n-                    CRITICAL_BLOCK(cs_vNodes)\n-                        foreach(CNode* pnode, vNodes)\n-                            if (setSeed.count(pnode->addr.ip))\n-                                pnode->fDisconnect = true;\n-                }\n-\n-                // Keep setting timestamps to 0 so they won't reconnect\n-                if (GetTime() - nSeedDisconnected < 60 * 60)\n-                {\n-                    foreach(PAIRTYPE(const vector<unsigned char>, CAddress)& item, mapAddresses)\n-                    {\n-                        if (setSeed.count(item.second.ip) && item.second.nTime != 0)\n-                        {\n-                            item.second.nTime = 0;\n-                            CAddrDB().WriteAddress(item.second);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-\n-        //\n-        // Choose an address to connect to based on most recently seen\n-        //\n-        CAddress addrConnect;\n-        int64 nBest = INT64_MIN;\n-\n-        // Only connect to one address per a.b.?.? range.\n-        // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n-        set<unsigned int> setConnected;\n-        CRITICAL_BLOCK(cs_vNodes)\n-            foreach(CNode* pnode, vNodes)\n-                setConnected.insert(pnode->addr.ip & 0x0000ffff);\n-\n-        CRITICAL_BLOCK(cs_mapAddresses)\n-        {\n-            foreach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n-            {\n-                const CAddress& addr = item.second;\n-                if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.ip & 0x0000ffff))\n-                    continue;\n-                int64 nSinceLastSeen = GetAdjustedTime() - addr.nTime;\n-                int64 nSinceLastTry = GetAdjustedTime() - addr.nLastTry;\n-\n-                // Randomize the order in a deterministic way, putting the standard port first\n-                int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n-                if (addr.port != htons(GetDefaultPort()))\n-                    nRandomizer += 2 * 60 * 60;\n-\n-                // Last seen  Base retry frequency\n-                //   <1 hour   10 min\n-                //    1 hour    1 hour\n-                //    4 hours   2 hours\n-                //   24 hours   5 hours\n-                //   48 hours   7 hours\n-                //    7 days   13 hours\n-                //   30 days   27 hours\n-                //   90 days   46 hours\n-                //  365 days   93 hours\n-                int64 nDelay = (int64)(3600.0 * sqrt(fabs((double)nSinceLastSeen) / 3600.0) + nRandomizer);\n-\n-                // Fast reconnect for one hour after last seen\n-                if (nSinceLastSeen < 60 * 60)\n-                    nDelay = 10 * 60;\n-\n-                // Limit retry frequency\n-                if (nSinceLastTry < nDelay)\n-                    continue;\n-\n-                // If we have IRC, we'll be notified when they first come online,\n-                // and again every 24 hours by the refresh broadcast.\n-                if (nGotIRCAddresses > 0 && vNodes.size() >= 2 && nSinceLastSeen > 24 * 60 * 60)\n-                    continue;\n-\n-                // Only try the old stuff if we don't have enough connections\n-                if (vNodes.size() >= 8 && nSinceLastSeen > 24 * 60 * 60)\n-                    continue;\n-\n-                // If multiple addresses are ready, prioritize by time since\n-                // last seen and time since last tried.\n-                int64 nScore = min(nSinceLastTry, (int64)24 * 60 * 60) - nSinceLastSeen - nRandomizer;\n-                if (nScore > nBest)\n-                {\n-                    nBest = nScore;\n-                    addrConnect = addr;\n-                }\n-            }\n-        }\n-\n-        if (addrConnect.IsValid())\n-            OpenNetworkConnection(addrConnect);\n+\t// Limit outbound connections\n+\tvnThreadsRunning[1]--;\n+\tSleep(500);\n+\tloop\n+\t{\n+\t    int nOutbound = 0;\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tforeach(CNode* pnode, vNodes)\n+\t\t    if (!pnode->fInbound)\n+\t\t\tnOutbound++;\n+\t    int nMaxOutboundConnections = MAX_OUTBOUND_CONNECTIONS;\n+\t    nMaxOutboundConnections = min(nMaxOutboundConnections, (int)GetArg(\"-maxconnections\", 125));\n+\t    if (nOutbound < nMaxOutboundConnections)\n+\t\tbreak;\n+\t    Sleep(2000);\n+\t    if (fShutdown)\n+\t\treturn;\n+\t}\n+\tvnThreadsRunning[1]++;\n+\tif (fShutdown)\n+\t    return;\n+\n+\tCRITICAL_BLOCK(cs_mapAddresses)\n+\t{\n+\t    // Add seed nodes if IRC isn't working\n+\t    static bool fSeedUsed;\n+\t    bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n+\t    if (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n+\t    {\n+\t\tfor (int i = 0; i < ARRAYLEN(pnSeed); i++)\n+\t\t{\n+\t\t    // It'll only connect to one or two seed nodes because once it connects,\n+\t\t    // it'll get a pile of addresses with newer timestamps.\n+\t\t    CAddress addr;\n+\t\t    addr.ip = pnSeed[i];\n+\t\t    addr.nTime = 0;\n+\t\t    AddAddress(addr);\n+\t\t}\n+\t\tfSeedUsed = true;\n+\t    }\n+\n+\t    if (fSeedUsed && mapAddresses.size() > ARRAYLEN(pnSeed) + 100)\n+\t    {\n+\t\t// Disconnect seed nodes\n+\t\tset<unsigned int> setSeed(pnSeed, pnSeed + ARRAYLEN(pnSeed));\n+\t\tstatic int64 nSeedDisconnected;\n+\t\tif (nSeedDisconnected == 0)\n+\t\t{\n+\t\t    nSeedDisconnected = GetTime();\n+\t\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\t\tforeach(CNode* pnode, vNodes)\n+\t\t\t    if (setSeed.count(pnode->addr.ip))\n+\t\t\t\tpnode->fDisconnect = true;\n+\t\t}\n+\n+\t\t// Keep setting timestamps to 0 so they won't reconnect\n+\t\tif (GetTime() - nSeedDisconnected < 60 * 60)\n+\t\t{\n+\t\t    foreach(PAIRTYPE(const vector<unsigned char>, CAddress)& item, mapAddresses)\n+\t\t    {\n+\t\t\tif (setSeed.count(item.second.ip) && item.second.nTime != 0)\n+\t\t\t{\n+\t\t\t    item.second.nTime = 0;\n+\t\t\t    CAddrDB().WriteAddress(item.second);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+\n+\t//\n+\t// Choose an address to connect to based on most recently seen\n+\t//\n+\tCAddress addrConnect;\n+\tint64 nBest = INT64_MIN;\n+\n+\t// Only connect to one address per a.b.?.? range.\n+\t// Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n+\tset<unsigned int> setConnected;\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t    foreach(CNode* pnode, vNodes)\n+\t\tsetConnected.insert(pnode->addr.ip & 0x0000ffff);\n+\n+\tCRITICAL_BLOCK(cs_mapAddresses)\n+\t{\n+\t    foreach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n+\t    {\n+\t\tconst CAddress& addr = item.second;\n+\t\tif (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.ip & 0x0000ffff))\n+\t\t    continue;\n+\t\tint64 nSinceLastSeen = GetAdjustedTime() - addr.nTime;\n+\t\tint64 nSinceLastTry = GetAdjustedTime() - addr.nLastTry;\n+\n+\t\t// Randomize the order in a deterministic way, putting the standard port first\n+\t\tint64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n+\t\tif (addr.port != htons(GetDefaultPort()))\n+\t\t    nRandomizer += 2 * 60 * 60;\n+\n+\t\t// Last seen  Base retry frequency\n+\t\t//   <1 hour   10 min\n+\t\t//    1 hour    1 hour\n+\t\t//    4 hours   2 hours\n+\t\t//   24 hours   5 hours\n+\t\t//   48 hours   7 hours\n+\t\t//    7 days   13 hours\n+\t\t//   30 days   27 hours\n+\t\t//   90 days   46 hours\n+\t\t//  365 days   93 hours\n+\t\tint64 nDelay = (int64)(3600.0 * sqrt(fabs((double)nSinceLastSeen) / 3600.0) + nRandomizer);\n+\n+\t\t// Fast reconnect for one hour after last seen\n+\t\tif (nSinceLastSeen < 60 * 60)\n+\t\t    nDelay = 10 * 60;\n+\n+\t\t// Limit retry frequency\n+\t\tif (nSinceLastTry < nDelay)\n+\t\t    continue;\n+\n+\t\t// If we have IRC, we'll be notified when they first come online,\n+\t\t// and again every 24 hours by the refresh broadcast.\n+\t\tif (nGotIRCAddresses > 0 && vNodes.size() >= 2 && nSinceLastSeen > 24 * 60 * 60)\n+\t\t    continue;\n+\n+\t\t// Only try the old stuff if we don't have enough connections\n+\t\tif (vNodes.size() >= 8 && nSinceLastSeen > 24 * 60 * 60)\n+\t\t    continue;\n+\n+\t\t// If multiple addresses are ready, prioritize by time since\n+\t\t// last seen and time since last tried.\n+\t\tint64 nScore = min(nSinceLastTry, (int64)24 * 60 * 60) - nSinceLastSeen - nRandomizer;\n+\t\tif (nScore > nBest)\n+\t\t{\n+\t\t    nBest = nScore;\n+\t\t    addrConnect = addr;\n+\t\t}\n+\t    }\n+\t}\n+\n+\tif (addrConnect.IsValid())\n+\t    OpenNetworkConnection(addrConnect);\n     }\n }\n \n@@ -1333,17 +1333,17 @@ bool OpenNetworkConnection(const CAddress& addrConnect)\n     // Initiate outbound network connection\n     //\n     if (fShutdown)\n-        return false;\n+\treturn false;\n     if (addrConnect.ip == addrLocalHost.ip || !addrConnect.IsIPv4() || FindNode(addrConnect.ip))\n-        return false;\n+\treturn false;\n \n     vnThreadsRunning[1]--;\n     CNode* pnode = ConnectNode(addrConnect);\n     vnThreadsRunning[1]++;\n     if (fShutdown)\n-        return false;\n+\treturn false;\n     if (!pnode)\n-        return false;\n+\treturn false;\n     pnode->fNetworkNode = true;\n \n     return true;\n@@ -1361,16 +1361,16 @@ void ThreadMessageHandler(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadMessageHandler(parg));\n     try\n     {\n-        vnThreadsRunning[2]++;\n-        ThreadMessageHandler2(parg);\n-        vnThreadsRunning[2]--;\n+\tvnThreadsRunning[2]++;\n+\tThreadMessageHandler2(parg);\n+\tvnThreadsRunning[2]--;\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[2]--;\n-        PrintException(&e, \"ThreadMessageHandler()\");\n+\tvnThreadsRunning[2]--;\n+\tPrintException(&e, \"ThreadMessageHandler()\");\n     } catch (...) {\n-        vnThreadsRunning[2]--;\n-        PrintException(NULL, \"ThreadMessageHandler()\");\n+\tvnThreadsRunning[2]--;\n+\tPrintException(NULL, \"ThreadMessageHandler()\");\n     }\n     printf(\"ThreadMessageHandler exiting\\n\");\n }\n@@ -1381,49 +1381,49 @@ void ThreadMessageHandler2(void* parg)\n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n     while (!fShutdown)\n     {\n-        vector<CNode*> vNodesCopy;\n-        CRITICAL_BLOCK(cs_vNodes)\n-        {\n-            vNodesCopy = vNodes;\n-            foreach(CNode* pnode, vNodesCopy)\n-                pnode->AddRef();\n-        }\n-\n-        // Poll the connected nodes for messages\n-        CNode* pnodeTrickle = NULL;\n-        if (!vNodesCopy.empty())\n-            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n-        foreach(CNode* pnode, vNodesCopy)\n-        {\n-            // Receive messages\n-            TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-                ProcessMessages(pnode);\n-            if (fShutdown)\n-                return;\n-\n-            // Send messages\n-            TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                SendMessages(pnode, pnode == pnodeTrickle);\n-            if (fShutdown)\n-                return;\n-        }\n-\n-        CRITICAL_BLOCK(cs_vNodes)\n-        {\n-            foreach(CNode* pnode, vNodesCopy)\n-                pnode->Release();\n-        }\n-\n-        // Wait and allow messages to bunch up.\n-        // Reduce vnThreadsRunning so StopNode has permission to exit while\n-        // we're sleeping, but we must always check fShutdown after doing this.\n-        vnThreadsRunning[2]--;\n-        Sleep(100);\n-        if (fRequestShutdown)\n-            Shutdown(NULL);\n-        vnThreadsRunning[2]++;\n-        if (fShutdown)\n-            return;\n+\tvector<CNode*> vNodesCopy;\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t{\n+\t    vNodesCopy = vNodes;\n+\t    foreach(CNode* pnode, vNodesCopy)\n+\t\tpnode->AddRef();\n+\t}\n+\n+\t// Poll the connected nodes for messages\n+\tCNode* pnodeTrickle = NULL;\n+\tif (!vNodesCopy.empty())\n+\t    pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n+\tforeach(CNode* pnode, vNodesCopy)\n+\t{\n+\t    // Receive messages\n+\t    TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t\tProcessMessages(pnode);\n+\t    if (fShutdown)\n+\t\treturn;\n+\n+\t    // Send messages\n+\t    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\tSendMessages(pnode, pnode == pnodeTrickle);\n+\t    if (fShutdown)\n+\t\treturn;\n+\t}\n+\n+\tCRITICAL_BLOCK(cs_vNodes)\n+\t{\n+\t    foreach(CNode* pnode, vNodesCopy)\n+\t\tpnode->Release();\n+\t}\n+\n+\t// Wait and allow messages to bunch up.\n+\t// Reduce vnThreadsRunning so StopNode has permission to exit while\n+\t// we're sleeping, but we must always check fShutdown after doing this.\n+\tvnThreadsRunning[2]--;\n+\tSleep(100);\n+\tif (fRequestShutdown)\n+\t    Shutdown(NULL);\n+\tvnThreadsRunning[2]++;\n+\tif (fShutdown)\n+\t    return;\n     }\n }\n \n@@ -1447,19 +1447,19 @@ bool BindListenPort(string& strError)\n     int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n     if (ret != NO_ERROR)\n     {\n-        strError = strprintf(\"Error: TCP/IP socket library failed to start (WSAStartup returned error %d)\", ret);\n-        printf(\"%s\\n\", strError.c_str());\n-        return false;\n+\tstrError = strprintf(\"Error: TCP/IP socket library failed to start (WSAStartup returned error %d)\", ret);\n+\tprintf(\"%s\\n\", strError.c_str());\n+\treturn false;\n     }\n #endif\n \n     // Create socket for listening for incoming connections\n     hListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n     if (hListenSocket == INVALID_SOCKET)\n     {\n-        strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n-        printf(\"%s\\n\", strError.c_str());\n-        return false;\n+\tstrError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n+\tprintf(\"%s\\n\", strError.c_str());\n+\treturn false;\n     }\n \n #ifdef BSD\n@@ -1480,9 +1480,9 @@ bool BindListenPort(string& strError)\n     if (fcntl(hListenSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n #endif\n     {\n-        strError = strprintf(\"Error: Couldn't set properties on socket for incoming connections (error %d)\", WSAGetLastError());\n-        printf(\"%s\\n\", strError.c_str());\n-        return false;\n+\tstrError = strprintf(\"Error: Couldn't set properties on socket for incoming connections (error %d)\", WSAGetLastError());\n+\tprintf(\"%s\\n\", strError.c_str());\n+\treturn false;\n     }\n \n     // The sockaddr_in structure specifies the address family,\n@@ -1494,22 +1494,22 @@ bool BindListenPort(string& strError)\n     sockaddr.sin_port = htons(GetDefaultPort());\n     if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n     {\n-        int nErr = WSAGetLastError();\n-        if (nErr == WSAEADDRINUSE)\n-            strError = strprintf(_(\"Unable to bind to port %d on this computer.  Bitcoin is probably already running.\"), ntohs(sockaddr.sin_port));\n-        else\n-            strError = strprintf(\"Error: Unable to bind to port %d on this computer (bind returned error %d)\", ntohs(sockaddr.sin_port), nErr);\n-        printf(\"%s\\n\", strError.c_str());\n-        return false;\n+\tint nErr = WSAGetLastError();\n+\tif (nErr == WSAEADDRINUSE)\n+\t    strError = strprintf(_(\"Unable to bind to port %d on this computer.  Bitcoin is probably already running.\"), ntohs(sockaddr.sin_port));\n+\telse\n+\t    strError = strprintf(\"Error: Unable to bind to port %d on this computer (bind returned error %d)\", ntohs(sockaddr.sin_port), nErr);\n+\tprintf(\"%s\\n\", strError.c_str());\n+\treturn false;\n     }\n     printf(\"Bound to port %d\\n\", ntohs(sockaddr.sin_port));\n \n     // Listen for incoming connections\n     if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n     {\n-        strError = strprintf(\"Error: Listening for incoming connections failed (listen returned error %d)\", WSAGetLastError());\n-        printf(\"%s\\n\", strError.c_str());\n-        return false;\n+\tstrError = strprintf(\"Error: Listening for incoming connections failed (listen returned error %d)\", WSAGetLastError());\n+\tprintf(\"%s\\n\", strError.c_str());\n+\treturn false;\n     }\n \n     return true;\n@@ -1518,69 +1518,69 @@ bool BindListenPort(string& strError)\n void StartNode(void* parg)\n {\n     if (pnodeLocalHost == NULL)\n-        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(\"127.0.0.1\", 0, false, nLocalServices));\n+\tpnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(\"127.0.0.1\", 0, false, nLocalServices));\n \n #ifdef __WXMSW__\n     // Get local host ip\n     char pszHostName[1000] = \"\";\n     if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n     {\n-        vector<CAddress> vaddr;\n-        if (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n-            foreach (const CAddress &addr, vaddr)\n-                if (addr.GetByte(3) != 127)\n-                {\n-                    addrLocalHost = addr;\n-                    break;\n-                }\n+\tvector<CAddress> vaddr;\n+\tif (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n+\t    foreach (const CAddress &addr, vaddr)\n+\t\tif (addr.GetByte(3) != 127)\n+\t\t{\n+\t\t    addrLocalHost = addr;\n+\t\t    break;\n+\t\t}\n     }\n #else\n     // Get local host ip\n     struct ifaddrs* myaddrs;\n     if (getifaddrs(&myaddrs) == 0)\n     {\n-        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n-        {\n-            if (ifa->ifa_addr == NULL) continue;\n-            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n-            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n-            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n-            char pszIP[100];\n-            if (ifa->ifa_addr->sa_family == AF_INET)\n-            {\n-                struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n-                if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s4->sin_addr), pszIP, sizeof(pszIP)) != NULL)\n-                    printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n-\n-                // Take the first IP that isn't loopback 127.x.x.x\n-                CAddress addr(*(unsigned int*)&s4->sin_addr, 0, nLocalServices);\n-                if (addr.IsValid() && addr.GetByte(3) != 127)\n-                {\n-                    addrLocalHost = addr;\n-                    break;\n-                }\n-            }\n-            else if (ifa->ifa_addr->sa_family == AF_INET6)\n-            {\n-                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n-                if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s6->sin6_addr), pszIP, sizeof(pszIP)) != NULL)\n-                    printf(\"ipv6 %s: %s\\n\", ifa->ifa_name, pszIP);\n-            }\n-        }\n-        freeifaddrs(myaddrs);\n+\tfor (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n+\t{\n+\t    if (ifa->ifa_addr == NULL) continue;\n+\t    if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n+\t    if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n+\t    if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n+\t    char pszIP[100];\n+\t    if (ifa->ifa_addr->sa_family == AF_INET)\n+\t    {\n+\t\tstruct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n+\t\tif (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s4->sin_addr), pszIP, sizeof(pszIP)) != NULL)\n+\t\t    printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n+\n+\t\t// Take the first IP that isn't loopback 127.x.x.x\n+\t\tCAddress addr(*(unsigned int*)&s4->sin_addr, 0, nLocalServices);\n+\t\tif (addr.IsValid() && addr.GetByte(3) != 127)\n+\t\t{\n+\t\t    addrLocalHost = addr;\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t    else if (ifa->ifa_addr->sa_family == AF_INET6)\n+\t    {\n+\t\tstruct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n+\t\tif (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s6->sin6_addr), pszIP, sizeof(pszIP)) != NULL)\n+\t\t    printf(\"ipv6 %s: %s\\n\", ifa->ifa_name, pszIP);\n+\t    }\n+\t}\n+\tfreeifaddrs(myaddrs);\n     }\n #endif\n     printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n \n     if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n     {\n-        // Proxies can't take incoming connections\n-        addrLocalHost.ip = CAddress(\"0.0.0.0\").ip;\n-        printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n+\t// Proxies can't take incoming connections\n+\taddrLocalHost.ip = CAddress(\"0.0.0.0\").ip;\n+\tprintf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n     }\n     else\n     {\n-        CreateThread(ThreadGetMyExternalIP, NULL);\n+\tCreateThread(ThreadGetMyExternalIP, NULL);\n     }\n \n     //\n@@ -1589,22 +1589,22 @@ void StartNode(void* parg)\n \n     // Map ports with UPnP\n     if (fHaveUPnP)\n-        MapPort(fUseUPnP);\n+\tMapPort(fUseUPnP);\n \n     // Get addresses from IRC and advertise ours\n     if (!CreateThread(ThreadIRCSeed, NULL))\n-        printf(\"Error: CreateThread(ThreadIRCSeed) failed\\n\");\n+\tprintf(\"Error: CreateThread(ThreadIRCSeed) failed\\n\");\n \n     // Send and receive from sockets, accept connections\n     pthread_t hThreadSocketHandler = CreateThread(ThreadSocketHandler, NULL, true);\n \n     // Initiate outbound connections\n     if (!CreateThread(ThreadOpenConnections, NULL))\n-        printf(\"Error: CreateThread(ThreadOpenConnections) failed\\n\");\n+\tprintf(\"Error: CreateThread(ThreadOpenConnections) failed\\n\");\n \n     // Process messages\n     if (!CreateThread(ThreadMessageHandler, NULL))\n-        printf(\"Error: CreateThread(ThreadMessageHandler) failed\\n\");\n+\tprintf(\"Error: CreateThread(ThreadMessageHandler) failed\\n\");\n \n     // Generate coins in the background\n     GenerateBitcoins(fGenerateBitcoins);\n@@ -1618,13 +1618,13 @@ bool StopNode()\n     int64 nStart = GetTime();\n     while (vnThreadsRunning[0] > 0 || vnThreadsRunning[2] > 0 || vnThreadsRunning[3] > 0 || vnThreadsRunning[4] > 0\n #ifdef USE_UPNP\n-        || vnThreadsRunning[5] > 0\n+\t|| vnThreadsRunning[5] > 0\n #endif\n     )\n     {\n-        if (GetTime() - nStart > 20)\n-            break;\n-        Sleep(20);\n+\tif (GetTime() - nStart > 20)\n+\t    break;\n+\tSleep(20);\n     }\n     if (vnThreadsRunning[0] > 0) printf(\"ThreadSocketHandler still running\\n\");\n     if (vnThreadsRunning[1] > 0) printf(\"ThreadOpenConnections still running\\n\");\n@@ -1633,7 +1633,7 @@ bool StopNode()\n     if (vnThreadsRunning[4] > 0) printf(\"ThreadRPCServer still running\\n\");\n     if (fHaveUPnP && vnThreadsRunning[5] > 0) printf(\"ThreadMapPort still running\\n\");\n     while (vnThreadsRunning[2] > 0 || vnThreadsRunning[4] > 0)\n-        Sleep(20);\n+\tSleep(20);\n     Sleep(50);\n \n     return true;\n@@ -1647,17 +1647,17 @@ class CNetCleanup\n     }\n     ~CNetCleanup()\n     {\n-        // Close sockets\n-        foreach(CNode* pnode, vNodes)\n-            if (pnode->hSocket != INVALID_SOCKET)\n-                closesocket(pnode->hSocket);\n-        if (hListenSocket != INVALID_SOCKET)\n-            if (closesocket(hListenSocket) == SOCKET_ERROR)\n-                printf(\"closesocket(hListenSocket) failed with error %d\\n\", WSAGetLastError());\n+\t// Close sockets\n+\tforeach(CNode* pnode, vNodes)\n+\t    if (pnode->hSocket != INVALID_SOCKET)\n+\t\tclosesocket(pnode->hSocket);\n+\tif (hListenSocket != INVALID_SOCKET)\n+\t    if (closesocket(hListenSocket) == SOCKET_ERROR)\n+\t\tprintf(\"closesocket(hListenSocket) failed with error %d\\n\", WSAGetLastError());\n \n #ifdef __WXMSW__\n-        // Shutdown Windows Sockets\n-        WSACleanup();\n+\t// Shutdown Windows Sockets\n+\tWSACleanup();\n #endif\n     }\n }"
      },
      {
        "sha": "1279d10127f9c6d814f66f7a49bb5f5c46af23c8",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 428,
        "deletions": 428,
        "changes": 856,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -65,66 +65,66 @@ class CMessageHeader\n \n     CMessageHeader()\n     {\n-        memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-        memset(pchCommand, 0, sizeof(pchCommand));\n-        pchCommand[1] = 1;\n-        nMessageSize = -1;\n-        nChecksum = 0;\n+\tmemcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n+\tmemset(pchCommand, 0, sizeof(pchCommand));\n+\tpchCommand[1] = 1;\n+\tnMessageSize = -1;\n+\tnChecksum = 0;\n     }\n \n     CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n     {\n-        memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-        strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n-        nMessageSize = nMessageSizeIn;\n-        nChecksum = 0;\n+\tmemcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n+\tstrncpy(pchCommand, pszCommand, COMMAND_SIZE);\n+\tnMessageSize = nMessageSizeIn;\n+\tnChecksum = 0;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(FLATDATA(pchMessageStart));\n-        READWRITE(FLATDATA(pchCommand));\n-        READWRITE(nMessageSize);\n-        if (nVersion >= 209)\n-            READWRITE(nChecksum);\n+\tREADWRITE(FLATDATA(pchMessageStart));\n+\tREADWRITE(FLATDATA(pchCommand));\n+\tREADWRITE(nMessageSize);\n+\tif (nVersion >= 209)\n+\t    READWRITE(nChecksum);\n     )\n \n     string GetCommand()\n     {\n-        if (pchCommand[COMMAND_SIZE-1] == 0)\n-            return string(pchCommand, pchCommand + strlen(pchCommand));\n-        else\n-            return string(pchCommand, pchCommand + COMMAND_SIZE);\n+\tif (pchCommand[COMMAND_SIZE-1] == 0)\n+\t    return string(pchCommand, pchCommand + strlen(pchCommand));\n+\telse\n+\t    return string(pchCommand, pchCommand + COMMAND_SIZE);\n     }\n \n     bool IsValid()\n     {\n-        // Check start string\n-        if (memcmp(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart)) != 0)\n-            return false;\n-\n-        // Check the command string for errors\n-        for (char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n-        {\n-            if (*p1 == 0)\n-            {\n-                // Must be all zeros after the first zero\n-                for (; p1 < pchCommand + COMMAND_SIZE; p1++)\n-                    if (*p1 != 0)\n-                        return false;\n-            }\n-            else if (*p1 < ' ' || *p1 > 0x7E)\n-                return false;\n-        }\n-\n-        // Message size\n-        if (nMessageSize > MAX_SIZE)\n-        {\n-            printf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n-            return false;\n-        }\n-\n-        return true;\n+\t// Check start string\n+\tif (memcmp(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart)) != 0)\n+\t    return false;\n+\n+\t// Check the command string for errors\n+\tfor (char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n+\t{\n+\t    if (*p1 == 0)\n+\t    {\n+\t\t// Must be all zeros after the first zero\n+\t\tfor (; p1 < pchCommand + COMMAND_SIZE; p1++)\n+\t\t    if (*p1 != 0)\n+\t\t\treturn false;\n+\t    }\n+\t    else if (*p1 < ' ' || *p1 > 0x7E)\n+\t\treturn false;\n+\t}\n+\n+\t// Message size\n+\tif (nMessageSize > MAX_SIZE)\n+\t{\n+\t    printf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n+\t    return false;\n+\t}\n+\n+\treturn true;\n     }\n };\n \n@@ -151,179 +151,179 @@ class CAddress\n \n     CAddress()\n     {\n-        Init();\n+\tInit();\n     }\n \n     CAddress(unsigned int ipIn, unsigned short portIn=0, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        ip = ipIn;\n-        port = htons(portIn == 0 ? GetDefaultPort() : portIn);\n-        nServices = nServicesIn;\n+\tInit();\n+\tip = ipIn;\n+\tport = htons(portIn == 0 ? GetDefaultPort() : portIn);\n+\tnServices = nServicesIn;\n     }\n \n     explicit CAddress(const struct sockaddr_in& sockaddr, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        ip = sockaddr.sin_addr.s_addr;\n-        port = sockaddr.sin_port;\n-        nServices = nServicesIn;\n+\tInit();\n+\tip = sockaddr.sin_addr.s_addr;\n+\tport = sockaddr.sin_port;\n+\tnServices = nServicesIn;\n     }\n \n     explicit CAddress(const char* pszIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        Lookup(pszIn, *this, nServicesIn, fNameLookup, portIn);\n+\tInit();\n+\tLookup(pszIn, *this, nServicesIn, fNameLookup, portIn);\n     }\n \n     explicit CAddress(const char* pszIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        Lookup(pszIn, *this, nServicesIn, fNameLookup, 0, true);\n+\tInit();\n+\tLookup(pszIn, *this, nServicesIn, fNameLookup, 0, true);\n     }\n \n     explicit CAddress(string strIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        Lookup(strIn.c_str(), *this, nServicesIn, fNameLookup, portIn);\n+\tInit();\n+\tLookup(strIn.c_str(), *this, nServicesIn, fNameLookup, portIn);\n     }\n \n     explicit CAddress(string strIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK)\n     {\n-        Init();\n-        Lookup(strIn.c_str(), *this, nServicesIn, fNameLookup, 0, true);\n+\tInit();\n+\tLookup(strIn.c_str(), *this, nServicesIn, fNameLookup, 0, true);\n     }\n \n     void Init()\n     {\n-        nServices = NODE_NETWORK;\n-        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));\n-        ip = INADDR_NONE;\n-        port = htons(GetDefaultPort());\n-        nTime = 100000000;\n-        nLastTry = 0;\n+\tnServices = NODE_NETWORK;\n+\tmemcpy(pchReserved, pchIPv4, sizeof(pchReserved));\n+\tip = INADDR_NONE;\n+\tport = htons(GetDefaultPort());\n+\tnTime = 100000000;\n+\tnLastTry = 0;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        if (fRead)\n-            const_cast<CAddress*>(this)->Init();\n-        if (nType & SER_DISK)\n-            READWRITE(nVersion);\n-        if ((nType & SER_DISK) || (nVersion >= 31402 && !(nType & SER_GETHASH)))\n-            READWRITE(nTime);\n-        READWRITE(nServices);\n-        READWRITE(FLATDATA(pchReserved)); // for IPv6\n-        READWRITE(ip);\n-        READWRITE(port);\n+\tif (fRead)\n+\t    const_cast<CAddress*>(this)->Init();\n+\tif (nType & SER_DISK)\n+\t    READWRITE(nVersion);\n+\tif ((nType & SER_DISK) || (nVersion >= 31402 && !(nType & SER_GETHASH)))\n+\t    READWRITE(nTime);\n+\tREADWRITE(nServices);\n+\tREADWRITE(FLATDATA(pchReserved)); // for IPv6\n+\tREADWRITE(ip);\n+\tREADWRITE(port);\n     )\n \n     friend inline bool operator==(const CAddress& a, const CAddress& b)\n     {\n-        return (memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved)) == 0 &&\n-                a.ip   == b.ip &&\n-                a.port == b.port);\n+\treturn (memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved)) == 0 &&\n+\t\ta.ip   == b.ip &&\n+\t\ta.port == b.port);\n     }\n \n     friend inline bool operator!=(const CAddress& a, const CAddress& b)\n     {\n-        return (!(a == b));\n+\treturn (!(a == b));\n     }\n \n     friend inline bool operator<(const CAddress& a, const CAddress& b)\n     {\n-        int ret = memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved));\n-        if (ret < 0)\n-            return true;\n-        else if (ret == 0)\n-        {\n-            if (ntohl(a.ip) < ntohl(b.ip))\n-                return true;\n-            else if (a.ip == b.ip)\n-                return ntohs(a.port) < ntohs(b.port);\n-        }\n-        return false;\n+\tint ret = memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved));\n+\tif (ret < 0)\n+\t    return true;\n+\telse if (ret == 0)\n+\t{\n+\t    if (ntohl(a.ip) < ntohl(b.ip))\n+\t\treturn true;\n+\t    else if (a.ip == b.ip)\n+\t\treturn ntohs(a.port) < ntohs(b.port);\n+\t}\n+\treturn false;\n     }\n \n     vector<unsigned char> GetKey() const\n     {\n-        CDataStream ss;\n-        ss.reserve(18);\n-        ss << FLATDATA(pchReserved) << ip << port;\n+\tCDataStream ss;\n+\tss.reserve(18);\n+\tss << FLATDATA(pchReserved) << ip << port;\n \n-        #if defined(_MSC_VER) && _MSC_VER < 1300\n-        return vector<unsigned char>((unsigned char*)&ss.begin()[0], (unsigned char*)&ss.end()[0]);\n-        #else\n-        return vector<unsigned char>(ss.begin(), ss.end());\n-        #endif\n+\t#if defined(_MSC_VER) && _MSC_VER < 1300\n+\treturn vector<unsigned char>((unsigned char*)&ss.begin()[0], (unsigned char*)&ss.end()[0]);\n+\t#else\n+\treturn vector<unsigned char>(ss.begin(), ss.end());\n+\t#endif\n     }\n \n     struct sockaddr_in GetSockAddr() const\n     {\n-        struct sockaddr_in sockaddr;\n-        memset(&sockaddr, 0, sizeof(sockaddr));\n-        sockaddr.sin_family = AF_INET;\n-        sockaddr.sin_addr.s_addr = ip;\n-        sockaddr.sin_port = port;\n-        return sockaddr;\n+\tstruct sockaddr_in sockaddr;\n+\tmemset(&sockaddr, 0, sizeof(sockaddr));\n+\tsockaddr.sin_family = AF_INET;\n+\tsockaddr.sin_addr.s_addr = ip;\n+\tsockaddr.sin_port = port;\n+\treturn sockaddr;\n     }\n \n     bool IsIPv4() const\n     {\n-        return (memcmp(pchReserved, pchIPv4, sizeof(pchIPv4)) == 0);\n+\treturn (memcmp(pchReserved, pchIPv4, sizeof(pchIPv4)) == 0);\n     }\n \n     bool IsRoutable() const\n     {\n-        return IsValid() &&\n-            !(GetByte(3) == 10 ||\n-              (GetByte(3) == 192 && GetByte(2) == 168) ||\n-              GetByte(3) == 127 ||\n-              GetByte(3) == 0);\n+\treturn IsValid() &&\n+\t    !(GetByte(3) == 10 ||\n+\t      (GetByte(3) == 192 && GetByte(2) == 168) ||\n+\t      GetByte(3) == 127 ||\n+\t      GetByte(3) == 0);\n     }\n \n     bool IsValid() const\n     {\n-        // Clean up 3-byte shifted addresses caused by garbage in size field\n-        // of addr messages from versions before 0.2.9 checksum.\n-        // Two consecutive addr messages look like this:\n-        // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n-        // so if the first length field is garbled, it reads the second batch\n-        // of addr misaligned by 3 bytes.\n-        if (memcmp(pchReserved, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n-            return false;\n+\t// Clean up 3-byte shifted addresses caused by garbage in size field\n+\t// of addr messages from versions before 0.2.9 checksum.\n+\t// Two consecutive addr messages look like this:\n+\t// header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n+\t// so if the first length field is garbled, it reads the second batch\n+\t// of addr misaligned by 3 bytes.\n+\tif (memcmp(pchReserved, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+\t    return false;\n \n-        return (ip != 0 && ip != INADDR_NONE && port != htons(USHRT_MAX));\n+\treturn (ip != 0 && ip != INADDR_NONE && port != htons(USHRT_MAX));\n     }\n \n     unsigned char GetByte(int n) const\n     {\n-        return ((unsigned char*)&ip)[3-n];\n+\treturn ((unsigned char*)&ip)[3-n];\n     }\n \n     string ToStringIPPort() const\n     {\n-        return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n+\treturn strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n     }\n \n     string ToStringIP() const\n     {\n-        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+\treturn strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n     }\n \n     string ToStringPort() const\n     {\n-        return strprintf(\"%u\", ntohs(port));\n+\treturn strprintf(\"%u\", ntohs(port));\n     }\n \n     string ToString() const\n     {\n-        return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n+\treturn strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n     }\n \n     void print() const\n     {\n-        printf(\"CAddress(%s)\\n\", ToString().c_str());\n+\tprintf(\"CAddress(%s)\\n\", ToString().c_str());\n     }\n };\n \n@@ -354,63 +354,63 @@ class CInv\n \n     CInv()\n     {\n-        type = 0;\n-        hash = 0;\n+\ttype = 0;\n+\thash = 0;\n     }\n \n     CInv(int typeIn, const uint256& hashIn)\n     {\n-        type = typeIn;\n-        hash = hashIn;\n+\ttype = typeIn;\n+\thash = hashIn;\n     }\n \n     CInv(const string& strType, const uint256& hashIn)\n     {\n-        int i;\n-        for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n-        {\n-            if (strType == ppszTypeName[i])\n-            {\n-                type = i;\n-                break;\n-            }\n-        }\n-        if (i == ARRAYLEN(ppszTypeName))\n-            throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n-        hash = hashIn;\n+\tint i;\n+\tfor (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n+\t{\n+\t    if (strType == ppszTypeName[i])\n+\t    {\n+\t\ttype = i;\n+\t\tbreak;\n+\t    }\n+\t}\n+\tif (i == ARRAYLEN(ppszTypeName))\n+\t    throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n+\thash = hashIn;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-        READWRITE(type);\n-        READWRITE(hash);\n+\tREADWRITE(type);\n+\tREADWRITE(hash);\n     )\n \n     friend inline bool operator<(const CInv& a, const CInv& b)\n     {\n-        return (a.type < b.type || (a.type == b.type && a.hash < b.hash));\n+\treturn (a.type < b.type || (a.type == b.type && a.hash < b.hash));\n     }\n \n     bool IsKnownType() const\n     {\n-        return (type >= 1 && type < ARRAYLEN(ppszTypeName));\n+\treturn (type >= 1 && type < ARRAYLEN(ppszTypeName));\n     }\n \n     const char* GetCommand() const\n     {\n-        if (!IsKnownType())\n-            throw std::out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n-        return ppszTypeName[type];\n+\tif (!IsKnownType())\n+\t    throw std::out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n+\treturn ppszTypeName[type];\n     }\n \n     string ToString() const\n     {\n-        return strprintf(\"%s %s\", GetCommand(), hash.ToString().substr(0,20).c_str());\n+\treturn strprintf(\"%s %s\", GetCommand(), hash.ToString().substr(0,20).c_str());\n     }\n \n     void print() const\n     {\n-        printf(\"CInv(%s)\\n\", ToString().c_str());\n+\tprintf(\"CInv(%s)\\n\", ToString().c_str());\n     }\n };\n \n@@ -426,13 +426,13 @@ class CRequestTracker\n \n     explicit CRequestTracker(void (*fnIn)(void*, CDataStream&)=NULL, void* param1In=NULL)\n     {\n-        fn = fnIn;\n-        param1 = param1In;\n+\tfn = fnIn;\n+\tparam1 = param1In;\n     }\n \n     bool IsNull()\n     {\n-        return fn == NULL;\n+\treturn fn == NULL;\n     }\n };\n \n@@ -520,53 +520,53 @@ class CNode\n \n     CNode(SOCKET hSocketIn, CAddress addrIn, bool fInboundIn=false)\n     {\n-        nServices = 0;\n-        hSocket = hSocketIn;\n-        vSend.SetType(SER_NETWORK);\n-        vSend.SetVersion(0);\n-        vRecv.SetType(SER_NETWORK);\n-        vRecv.SetVersion(0);\n-        // Version 0.2 obsoletes 20 Feb 2012\n-        if (GetTime() > 1329696000)\n-        {\n-            vSend.SetVersion(209);\n-            vRecv.SetVersion(209);\n-        }\n-        nLastSend = 0;\n-        nLastRecv = 0;\n-        nLastSendEmpty = GetTime();\n-        nTimeConnected = GetTime();\n-        nHeaderStart = -1;\n-        nMessageStart = -1;\n-        addr = addrIn;\n-        nVersion = 0;\n-        strSubVer = \"\";\n-        fClient = false; // set by version message\n-        fInbound = fInboundIn;\n-        fNetworkNode = false;\n-        fSuccessfullyConnected = false;\n-        fDisconnect = false;\n-        nRefCount = 0;\n-        nReleaseTime = 0;\n-        hashContinue = 0;\n-        pindexLastGetBlocksBegin = 0;\n-        hashLastGetBlocksEnd = 0;\n-        nStartingHeight = -1;\n-        fGetAddr = false;\n-        vfSubscribe.assign(256, false);\n-\n-        // Be shy and don't send version until we hear\n-        if (!fInbound)\n-            PushVersion();\n+\tnServices = 0;\n+\thSocket = hSocketIn;\n+\tvSend.SetType(SER_NETWORK);\n+\tvSend.SetVersion(0);\n+\tvRecv.SetType(SER_NETWORK);\n+\tvRecv.SetVersion(0);\n+\t// Version 0.2 obsoletes 20 Feb 2012\n+\tif (GetTime() > 1329696000)\n+\t{\n+\t    vSend.SetVersion(209);\n+\t    vRecv.SetVersion(209);\n+\t}\n+\tnLastSend = 0;\n+\tnLastRecv = 0;\n+\tnLastSendEmpty = GetTime();\n+\tnTimeConnected = GetTime();\n+\tnHeaderStart = -1;\n+\tnMessageStart = -1;\n+\taddr = addrIn;\n+\tnVersion = 0;\n+\tstrSubVer = \"\";\n+\tfClient = false; // set by version message\n+\tfInbound = fInboundIn;\n+\tfNetworkNode = false;\n+\tfSuccessfullyConnected = false;\n+\tfDisconnect = false;\n+\tnRefCount = 0;\n+\tnReleaseTime = 0;\n+\thashContinue = 0;\n+\tpindexLastGetBlocksBegin = 0;\n+\thashLastGetBlocksEnd = 0;\n+\tnStartingHeight = -1;\n+\tfGetAddr = false;\n+\tvfSubscribe.assign(256, false);\n+\n+\t// Be shy and don't send version until we hear\n+\tif (!fInbound)\n+\t    PushVersion();\n     }\n \n     ~CNode()\n     {\n-        if (hSocket != INVALID_SOCKET)\n-        {\n-            closesocket(hSocket);\n-            hSocket = INVALID_SOCKET;\n-        }\n+\tif (hSocket != INVALID_SOCKET)\n+\t{\n+\t    closesocket(hSocket);\n+\t    hSocket = INVALID_SOCKET;\n+\t}\n     }\n \n private:\n@@ -577,352 +577,352 @@ class CNode\n \n     int GetRefCount()\n     {\n-        return max(nRefCount, 0) + (GetTime() < nReleaseTime ? 1 : 0);\n+\treturn max(nRefCount, 0) + (GetTime() < nReleaseTime ? 1 : 0);\n     }\n \n     CNode* AddRef(int64 nTimeout=0)\n     {\n-        if (nTimeout != 0)\n-            nReleaseTime = max(nReleaseTime, GetTime() + nTimeout);\n-        else\n-            nRefCount++;\n-        return this;\n+\tif (nTimeout != 0)\n+\t    nReleaseTime = max(nReleaseTime, GetTime() + nTimeout);\n+\telse\n+\t    nRefCount++;\n+\treturn this;\n     }\n \n     void Release()\n     {\n-        nRefCount--;\n+\tnRefCount--;\n     }\n \n \n \n     void AddAddressKnown(const CAddress& addr)\n     {\n-        setAddrKnown.insert(addr);\n+\tsetAddrKnown.insert(addr);\n     }\n \n     void PushAddress(const CAddress& addr)\n     {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        if (addr.IsValid() && !setAddrKnown.count(addr))\n-            vAddrToSend.push_back(addr);\n+\t// Known checking here is only to save space from duplicates.\n+\t// SendMessages will filter it again for knowns that were added\n+\t// after addresses were pushed.\n+\tif (addr.IsValid() && !setAddrKnown.count(addr))\n+\t    vAddrToSend.push_back(addr);\n     }\n \n \n     void AddInventoryKnown(const CInv& inv)\n     {\n-        CRITICAL_BLOCK(cs_inventory)\n-            setInventoryKnown.insert(inv);\n+\tCRITICAL_BLOCK(cs_inventory)\n+\t    setInventoryKnown.insert(inv);\n     }\n \n     void PushInventory(const CInv& inv)\n     {\n-        CRITICAL_BLOCK(cs_inventory)\n-            if (!setInventoryKnown.count(inv))\n-                vInventoryToSend.push_back(inv);\n+\tCRITICAL_BLOCK(cs_inventory)\n+\t    if (!setInventoryKnown.count(inv))\n+\t\tvInventoryToSend.push_back(inv);\n     }\n \n     void AskFor(const CInv& inv)\n     {\n-        // We're using mapAskFor as a priority queue,\n-        // the key is the earliest time the request can be sent\n-        int64& nRequestTime = mapAlreadyAskedFor[inv];\n-        printf(\"askfor %s   %\"PRI64d\"\\n\", inv.ToString().c_str(), nRequestTime);\n+\t// We're using mapAskFor as a priority queue,\n+\t// the key is the earliest time the request can be sent\n+\tint64& nRequestTime = mapAlreadyAskedFor[inv];\n+\tprintf(\"askfor %s   %\"PRI64d\"\\n\", inv.ToString().c_str(), nRequestTime);\n \n-        // Make sure not to reuse time indexes to keep things in the same order\n-        int64 nNow = (GetTime() - 1) * 1000000;\n-        static int64 nLastTime;\n-        nLastTime = nNow = max(nNow, ++nLastTime);\n+\t// Make sure not to reuse time indexes to keep things in the same order\n+\tint64 nNow = (GetTime() - 1) * 1000000;\n+\tstatic int64 nLastTime;\n+\tnLastTime = nNow = max(nNow, ++nLastTime);\n \n-        // Each retry is 2 minutes after the last\n-        nRequestTime = max(nRequestTime + 2 * 60 * 1000000, nNow);\n-        mapAskFor.insert(make_pair(nRequestTime, inv));\n+\t// Each retry is 2 minutes after the last\n+\tnRequestTime = max(nRequestTime + 2 * 60 * 1000000, nNow);\n+\tmapAskFor.insert(make_pair(nRequestTime, inv));\n     }\n \n \n \n     void BeginMessage(const char* pszCommand)\n     {\n-        cs_vSend.Enter();\n-        if (nHeaderStart != -1)\n-            AbortMessage();\n-        nHeaderStart = vSend.size();\n-        vSend << CMessageHeader(pszCommand, 0);\n-        nMessageStart = vSend.size();\n-        if (fDebug)\n-            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-        printf(\"sending: %s \", pszCommand);\n+\tcs_vSend.Enter();\n+\tif (nHeaderStart != -1)\n+\t    AbortMessage();\n+\tnHeaderStart = vSend.size();\n+\tvSend << CMessageHeader(pszCommand, 0);\n+\tnMessageStart = vSend.size();\n+\tif (fDebug)\n+\t    printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\tprintf(\"sending: %s \", pszCommand);\n     }\n \n     void AbortMessage()\n     {\n-        if (nHeaderStart == -1)\n-            return;\n-        vSend.resize(nHeaderStart);\n-        nHeaderStart = -1;\n-        nMessageStart = -1;\n-        cs_vSend.Leave();\n-        printf(\"(aborted)\\n\");\n+\tif (nHeaderStart == -1)\n+\t    return;\n+\tvSend.resize(nHeaderStart);\n+\tnHeaderStart = -1;\n+\tnMessageStart = -1;\n+\tcs_vSend.Leave();\n+\tprintf(\"(aborted)\\n\");\n     }\n \n     void EndMessage()\n     {\n-        if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n-        {\n-            printf(\"dropmessages DROPPING SEND MESSAGE\\n\");\n-            AbortMessage();\n-            return;\n-        }\n+\tif (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n+\t{\n+\t    printf(\"dropmessages DROPPING SEND MESSAGE\\n\");\n+\t    AbortMessage();\n+\t    return;\n+\t}\n \n-        if (nHeaderStart == -1)\n-            return;\n+\tif (nHeaderStart == -1)\n+\t    return;\n \n-        // Set the size\n-        unsigned int nSize = vSend.size() - nMessageStart;\n-        memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nMessageSize), &nSize, sizeof(nSize));\n+\t// Set the size\n+\tunsigned int nSize = vSend.size() - nMessageStart;\n+\tmemcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nMessageSize), &nSize, sizeof(nSize));\n \n-        // Set the checksum\n-        if (vSend.GetVersion() >= 209)\n-        {\n-            uint256 hash = Hash(vSend.begin() + nMessageStart, vSend.end());\n-            unsigned int nChecksum = 0;\n-            memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-            assert(nMessageStart - nHeaderStart >= offsetof(CMessageHeader, nChecksum) + sizeof(nChecksum));\n-            memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nChecksum), &nChecksum, sizeof(nChecksum));\n-        }\n+\t// Set the checksum\n+\tif (vSend.GetVersion() >= 209)\n+\t{\n+\t    uint256 hash = Hash(vSend.begin() + nMessageStart, vSend.end());\n+\t    unsigned int nChecksum = 0;\n+\t    memcpy(&nChecksum, &hash, sizeof(nChecksum));\n+\t    assert(nMessageStart - nHeaderStart >= offsetof(CMessageHeader, nChecksum) + sizeof(nChecksum));\n+\t    memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nChecksum), &nChecksum, sizeof(nChecksum));\n+\t}\n \n-        printf(\"(%d bytes) \", nSize);\n-        printf(\"\\n\");\n+\tprintf(\"(%d bytes) \", nSize);\n+\tprintf(\"\\n\");\n \n-        nHeaderStart = -1;\n-        nMessageStart = -1;\n-        cs_vSend.Leave();\n+\tnHeaderStart = -1;\n+\tnMessageStart = -1;\n+\tcs_vSend.Leave();\n     }\n \n     void EndMessageAbortIfEmpty()\n     {\n-        if (nHeaderStart == -1)\n-            return;\n-        int nSize = vSend.size() - nMessageStart;\n-        if (nSize > 0)\n-            EndMessage();\n-        else\n-            AbortMessage();\n+\tif (nHeaderStart == -1)\n+\t    return;\n+\tint nSize = vSend.size() - nMessageStart;\n+\tif (nSize > 0)\n+\t    EndMessage();\n+\telse\n+\t    AbortMessage();\n     }\n \n \n \n     void PushVersion()\n     {\n-        /// when NTP implemented, change to just nTime = GetAdjustedTime()\n-        int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-        CAddress addrYou = (fUseProxy ? CAddress(\"0.0.0.0\") : addr);\n-        CAddress addrMe = (fUseProxy ? CAddress(\"0.0.0.0\") : addrLocalHost);\n-        RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n-        PushMessage(\"version\", VERSION, nLocalServices, nTime, addrYou, addrMe,\n-                nLocalHostNonce, string(pszSubVer), nBestHeight);\n+\t/// when NTP implemented, change to just nTime = GetAdjustedTime()\n+\tint64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n+\tCAddress addrYou = (fUseProxy ? CAddress(\"0.0.0.0\") : addr);\n+\tCAddress addrMe = (fUseProxy ? CAddress(\"0.0.0.0\") : addrLocalHost);\n+\tRAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n+\tPushMessage(\"version\", VERSION, nLocalServices, nTime, addrYou, addrMe,\n+\t\tnLocalHostNonce, string(pszSubVer), nBestHeight);\n     }\n \n \n \n \n     void PushMessage(const char* pszCommand)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1>\n     void PushMessage(const char* pszCommand, const T1& a1)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3 << a4;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3 << a4;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3 << a4 << a5;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3 << a4 << a5;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3 << a4 << a5 << a6;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3 << a4 << a5 << a6;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8, const T9& a9)\n     {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8 << a9;\n-            EndMessage();\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n+\ttry\n+\t{\n+\t    BeginMessage(pszCommand);\n+\t    vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8 << a9;\n+\t    EndMessage();\n+\t}\n+\tcatch (...)\n+\t{\n+\t    AbortMessage();\n+\t    throw;\n+\t}\n     }\n \n \n     void PushRequest(const char* pszCommand,\n-                     void (*fn)(void*, CDataStream&), void* param1)\n+\t\t     void (*fn)(void*, CDataStream&), void* param1)\n     {\n-        uint256 hashReply;\n-        RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n+\tuint256 hashReply;\n+\tRAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n \n-        CRITICAL_BLOCK(cs_mapRequests)\n-            mapRequests[hashReply] = CRequestTracker(fn, param1);\n+\tCRITICAL_BLOCK(cs_mapRequests)\n+\t    mapRequests[hashReply] = CRequestTracker(fn, param1);\n \n-        PushMessage(pszCommand, hashReply);\n+\tPushMessage(pszCommand, hashReply);\n     }\n \n     template<typename T1>\n     void PushRequest(const char* pszCommand, const T1& a1,\n-                     void (*fn)(void*, CDataStream&), void* param1)\n+\t\t     void (*fn)(void*, CDataStream&), void* param1)\n     {\n-        uint256 hashReply;\n-        RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n+\tuint256 hashReply;\n+\tRAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n \n-        CRITICAL_BLOCK(cs_mapRequests)\n-            mapRequests[hashReply] = CRequestTracker(fn, param1);\n+\tCRITICAL_BLOCK(cs_mapRequests)\n+\t    mapRequests[hashReply] = CRequestTracker(fn, param1);\n \n-        PushMessage(pszCommand, hashReply, a1);\n+\tPushMessage(pszCommand, hashReply, a1);\n     }\n \n     template<typename T1, typename T2>\n     void PushRequest(const char* pszCommand, const T1& a1, const T2& a2,\n-                     void (*fn)(void*, CDataStream&), void* param1)\n+\t\t     void (*fn)(void*, CDataStream&), void* param1)\n     {\n-        uint256 hashReply;\n-        RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n+\tuint256 hashReply;\n+\tRAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n \n-        CRITICAL_BLOCK(cs_mapRequests)\n-            mapRequests[hashReply] = CRequestTracker(fn, param1);\n+\tCRITICAL_BLOCK(cs_mapRequests)\n+\t    mapRequests[hashReply] = CRequestTracker(fn, param1);\n \n-        PushMessage(pszCommand, hashReply, a1, a2);\n+\tPushMessage(pszCommand, hashReply, a1, a2);\n     }\n \n \n@@ -948,8 +948,8 @@ inline void RelayInventory(const CInv& inv)\n {\n     // Put on lists to offer to the other nodes\n     CRITICAL_BLOCK(cs_vNodes)\n-        foreach(CNode* pnode, vNodes)\n-            pnode->PushInventory(inv);\n+\tforeach(CNode* pnode, vNodes)\n+\t    pnode->PushInventory(inv);\n }\n \n template<typename T>\n@@ -966,16 +966,16 @@ inline void RelayMessage<>(const CInv& inv, const CDataStream& ss)\n {\n     CRITICAL_BLOCK(cs_mapRelay)\n     {\n-        // Expire old relay messages\n-        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n-        {\n-            mapRelay.erase(vRelayExpiration.front().second);\n-            vRelayExpiration.pop_front();\n-        }\n+\t// Expire old relay messages\n+\twhile (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n+\t{\n+\t    mapRelay.erase(vRelayExpiration.front().second);\n+\t    vRelayExpiration.pop_front();\n+\t}\n \n-        // Save original serialized message so newer versions are preserved\n-        mapRelay[inv] = ss;\n-        vRelayExpiration.push_back(make_pair(GetTime() + 15 * 60, inv));\n+\t// Save original serialized message so newer versions are preserved\n+\tmapRelay[inv] = ss;\n+\tvRelayExpiration.push_back(make_pair(GetTime() + 15 * 60, inv));\n     }\n \n     RelayInventory(inv);\n@@ -1003,13 +1003,13 @@ void AdvertStartPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops,\n     obj.setSources.insert(pfrom->addr.ip);\n \n     if (!AdvertInsert(obj))\n-        return;\n+\treturn;\n \n     // Relay\n     CRITICAL_BLOCK(cs_vNodes)\n-        foreach(CNode* pnode, vNodes)\n-            if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n-                pnode->PushMessage(\"publish\", nChannel, nHops, obj);\n+\tforeach(CNode* pnode, vNodes)\n+\t    if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n+\t\tpnode->PushMessage(\"publish\", nChannel, nHops, obj);\n }\n \n template<typename T>\n@@ -1018,9 +1018,9 @@ void AdvertStopPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops,\n     uint256 hash = obj.GetHash();\n \n     CRITICAL_BLOCK(cs_vNodes)\n-        foreach(CNode* pnode, vNodes)\n-            if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n-                pnode->PushMessage(\"pub-cancel\", nChannel, nHops, hash);\n+\tforeach(CNode* pnode, vNodes)\n+\t    if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n+\t\tpnode->PushMessage(\"pub-cancel\", nChannel, nHops, hash);\n \n     AdvertErase(obj);\n }\n@@ -1033,5 +1033,5 @@ void AdvertRemoveSource(CNode* pfrom, unsigned int nChannel, unsigned int nHops,\n \n     // If no longer supported by any sources, cancel it\n     if (obj.setSources.empty())\n-        AdvertStopPublish(pfrom, nChannel, nHops, obj);\n+\tAdvertStopPublish(pfrom, nChannel, nHops, obj);\n }"
      },
      {
        "sha": "4f82f9b09b050aadf95edb13d1c02d37308c264c",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 992,
        "deletions": 992,
        "changes": 1984,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5"
      },
      {
        "sha": "cbf91ad7dd129f0274aa89ddcabc2ea8a5c1b1a7",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 925,
        "deletions": 925,
        "changes": 1850,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -22,7 +22,7 @@ static const size_t nMaxNumSize = 4;\n CBigNum CastToBigNum(const valtype& vch)\n {\n     if (vch.size() > nMaxNumSize)\n-        throw runtime_error(\"CastToBigNum() : overflow\");\n+\tthrow runtime_error(\"CastToBigNum() : overflow\");\n     // Get rid of extra leading zeros\n     return CBigNum(CBigNum(vch).getvch());\n }\n@@ -31,13 +31,13 @@ bool CastToBool(const valtype& vch)\n {\n     for (int i = 0; i < vch.size(); i++)\n     {\n-        if (vch[i] != 0)\n-        {\n-            // Can be negative zero\n-            if (i == vch.size()-1 && vch[i] == 0x80)\n-                return false;\n-            return true;\n-        }\n+\tif (vch[i] != 0)\n+\t{\n+\t    // Can be negative zero\n+\t    if (i == vch.size()-1 && vch[i] == 0x80)\n+\t\treturn false;\n+\t    return true;\n+\t}\n     }\n     return false;\n }\n@@ -46,9 +46,9 @@ void MakeSameSize(valtype& vch1, valtype& vch2)\n {\n     // Lengthen the shorter one\n     if (vch1.size() < vch2.size())\n-        vch1.resize(vch2.size(), 0);\n+\tvch1.resize(vch2.size(), 0);\n     if (vch2.size() < vch1.size())\n-        vch2.resize(vch1.size(), 0);\n+\tvch2.resize(vch1.size(), 0);\n }\n \n \n@@ -62,7 +62,7 @@ void MakeSameSize(valtype& vch1, valtype& vch2)\n static inline void popstack(vector<valtype>& stack)\n {\n     if (stack.empty())\n-        throw runtime_error(\"popstack() : stack empty\");\n+\tthrow runtime_error(\"popstack() : stack empty\");\n     stack.pop_back();\n }\n \n@@ -78,784 +78,784 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n     vector<bool> vfExec;\n     vector<valtype> altstack;\n     if (script.size() > 10000)\n-        return false;\n+\treturn false;\n     int nOpCount = 0;\n \n \n     try\n     {\n-        while (pc < pend)\n-        {\n-            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n-\n-            //\n-            // Read instruction\n-            //\n-            if (!script.GetOp(pc, opcode, vchPushValue))\n-                return false;\n-            if (vchPushValue.size() > 520)\n-                return false;\n-            if (opcode > OP_16 && ++nOpCount > 201)\n-                return false;\n-\n-            if (opcode == OP_CAT ||\n-                opcode == OP_SUBSTR ||\n-                opcode == OP_LEFT ||\n-                opcode == OP_RIGHT ||\n-                opcode == OP_INVERT ||\n-                opcode == OP_AND ||\n-                opcode == OP_OR ||\n-                opcode == OP_XOR ||\n-                opcode == OP_2MUL ||\n-                opcode == OP_2DIV ||\n-                opcode == OP_MUL ||\n-                opcode == OP_DIV ||\n-                opcode == OP_MOD ||\n-                opcode == OP_LSHIFT ||\n-                opcode == OP_RSHIFT)\n-                return false;\n-\n-            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n-                stack.push_back(vchPushValue);\n-            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n-            switch (opcode)\n-            {\n-                //\n-                // Push value\n-                //\n-                case OP_1NEGATE:\n-                case OP_1:\n-                case OP_2:\n-                case OP_3:\n-                case OP_4:\n-                case OP_5:\n-                case OP_6:\n-                case OP_7:\n-                case OP_8:\n-                case OP_9:\n-                case OP_10:\n-                case OP_11:\n-                case OP_12:\n-                case OP_13:\n-                case OP_14:\n-                case OP_15:\n-                case OP_16:\n-                {\n-                    // ( -- value)\n-                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-\n-                //\n-                // Control\n-                //\n-                case OP_NOP:\n-                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n-                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n-                break;\n-\n-                case OP_IF:\n-                case OP_NOTIF:\n-                {\n-                    // <expression> if [statements] [else [statements]] endif\n-                    bool fValue = false;\n-                    if (fExec)\n-                    {\n-                        if (stack.size() < 1)\n-                            return false;\n-                        valtype& vch = stacktop(-1);\n-                        fValue = CastToBool(vch);\n-                        if (opcode == OP_NOTIF)\n-                            fValue = !fValue;\n-                        popstack(stack);\n-                    }\n-                    vfExec.push_back(fValue);\n-                }\n-                break;\n-\n-                case OP_ELSE:\n-                {\n-                    if (vfExec.empty())\n-                        return false;\n-                    vfExec.back() = !vfExec.back();\n-                }\n-                break;\n-\n-                case OP_ENDIF:\n-                {\n-                    if (vfExec.empty())\n-                        return false;\n-                    vfExec.pop_back();\n-                }\n-                break;\n-\n-                case OP_VERIFY:\n-                {\n-                    // (true -- ) or\n-                    // (false -- false) and return\n-                    if (stack.size() < 1)\n-                        return false;\n-                    bool fValue = CastToBool(stacktop(-1));\n-                    if (fValue)\n-                        popstack(stack);\n-                    else\n-                        return false;\n-                }\n-                break;\n-\n-                case OP_RETURN:\n-                {\n-                    return false;\n-                }\n-                break;\n-\n-\n-                //\n-                // Stack ops\n-                //\n-                case OP_TOALTSTACK:\n-                {\n-                    if (stack.size() < 1)\n-                        return false;\n-                    altstack.push_back(stacktop(-1));\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_FROMALTSTACK:\n-                {\n-                    if (altstack.size() < 1)\n-                        return false;\n-                    stack.push_back(altstacktop(-1));\n-                    popstack(altstack);\n-                }\n-                break;\n-\n-                case OP_2DROP:\n-                {\n-                    // (x1 x2 -- )\n-                    if (stack.size() < 2)\n-                        return false;\n-                    popstack(stack);\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_2DUP:\n-                {\n-                    // (x1 x2 -- x1 x2 x1 x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch1 = stacktop(-2);\n-                    valtype vch2 = stacktop(-1);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_3DUP:\n-                {\n-                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    valtype vch1 = stacktop(-3);\n-                    valtype vch2 = stacktop(-2);\n-                    valtype vch3 = stacktop(-1);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                    stack.push_back(vch3);\n-                }\n-                break;\n-\n-                case OP_2OVER:\n-                {\n-                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n-                    if (stack.size() < 4)\n-                        return false;\n-                    valtype vch1 = stacktop(-4);\n-                    valtype vch2 = stacktop(-3);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_2ROT:\n-                {\n-                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n-                    if (stack.size() < 6)\n-                        return false;\n-                    valtype vch1 = stacktop(-6);\n-                    valtype vch2 = stacktop(-5);\n-                    stack.erase(stack.end()-6, stack.end()-4);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_2SWAP:\n-                {\n-                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n-                    if (stack.size() < 4)\n-                        return false;\n-                    swap(stacktop(-4), stacktop(-2));\n-                    swap(stacktop(-3), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_IFDUP:\n-                {\n-                    // (x - 0 | x x)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    if (CastToBool(vch))\n-                        stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_DEPTH:\n-                {\n-                    // -- stacksize\n-                    CBigNum bn(stack.size());\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-                case OP_DROP:\n-                {\n-                    // (x -- )\n-                    if (stack.size() < 1)\n-                        return false;\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_DUP:\n-                {\n-                    // (x -- x x)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_NIP:\n-                {\n-                    // (x1 x2 -- x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    stack.erase(stack.end() - 2);\n-                }\n-                break;\n-\n-                case OP_OVER:\n-                {\n-                    // (x1 x2 -- x1 x2 x1)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch = stacktop(-2);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_PICK:\n-                case OP_ROLL:\n-                {\n-                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n-                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    int n = CastToBigNum(stacktop(-1)).getint();\n-                    popstack(stack);\n-                    if (n < 0 || n >= stack.size())\n-                        return false;\n-                    valtype vch = stacktop(-n-1);\n-                    if (opcode == OP_ROLL)\n-                        stack.erase(stack.end()-n-1);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_ROT:\n-                {\n-                    // (x1 x2 x3 -- x2 x3 x1)\n-                    //  x2 x1 x3  after first swap\n-                    //  x2 x3 x1  after second swap\n-                    if (stack.size() < 3)\n-                        return false;\n-                    swap(stacktop(-3), stacktop(-2));\n-                    swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_SWAP:\n-                {\n-                    // (x1 x2 -- x2 x1)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_TUCK:\n-                {\n-                    // (x1 x2 -- x2 x1 x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    stack.insert(stack.end()-2, vch);\n-                }\n-                break;\n-\n-\n-                //\n-                // Splice ops\n-                //\n-                case OP_CAT:\n-                {\n-                    // (x1 x2 -- out)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype& vch1 = stacktop(-2);\n-                    valtype& vch2 = stacktop(-1);\n-                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n-                    popstack(stack);\n-                    if (stacktop(-1).size() > 520)\n-                        return false;\n-                }\n-                break;\n-\n-                case OP_SUBSTR:\n-                {\n-                    // (in begin size -- out)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    valtype& vch = stacktop(-3);\n-                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n-                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n-                    if (nBegin < 0 || nEnd < nBegin)\n-                        return false;\n-                    if (nBegin > vch.size())\n-                        nBegin = vch.size();\n-                    if (nEnd > vch.size())\n-                        nEnd = vch.size();\n-                    vch.erase(vch.begin() + nEnd, vch.end());\n-                    vch.erase(vch.begin(), vch.begin() + nBegin);\n-                    popstack(stack);\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_LEFT:\n-                case OP_RIGHT:\n-                {\n-                    // (in size -- out)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype& vch = stacktop(-2);\n-                    int nSize = CastToBigNum(stacktop(-1)).getint();\n-                    if (nSize < 0)\n-                        return false;\n-                    if (nSize > vch.size())\n-                        nSize = vch.size();\n-                    if (opcode == OP_LEFT)\n-                        vch.erase(vch.begin() + nSize, vch.end());\n-                    else\n-                        vch.erase(vch.begin(), vch.end() - nSize);\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_SIZE:\n-                {\n-                    // (in -- in size)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    CBigNum bn(stacktop(-1).size());\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-\n-                //\n-                // Bitwise logic\n-                //\n-                case OP_INVERT:\n-                {\n-                    // (in - out)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype& vch = stacktop(-1);\n-                    for (int i = 0; i < vch.size(); i++)\n-                        vch[i] = ~vch[i];\n-                }\n-                break;\n-\n-                case OP_AND:\n-                case OP_OR:\n-                case OP_XOR:\n-                {\n-                    // (x1 x2 - out)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype& vch1 = stacktop(-2);\n-                    valtype& vch2 = stacktop(-1);\n-                    MakeSameSize(vch1, vch2);\n-                    if (opcode == OP_AND)\n-                    {\n-                        for (int i = 0; i < vch1.size(); i++)\n-                            vch1[i] &= vch2[i];\n-                    }\n-                    else if (opcode == OP_OR)\n-                    {\n-                        for (int i = 0; i < vch1.size(); i++)\n-                            vch1[i] |= vch2[i];\n-                    }\n-                    else if (opcode == OP_XOR)\n-                    {\n-                        for (int i = 0; i < vch1.size(); i++)\n-                            vch1[i] ^= vch2[i];\n-                    }\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_EQUAL:\n-                case OP_EQUALVERIFY:\n-                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n-                {\n-                    // (x1 x2 - bool)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype& vch1 = stacktop(-2);\n-                    valtype& vch2 = stacktop(-1);\n-                    bool fEqual = (vch1 == vch2);\n-                    // OP_NOTEQUAL is disabled because it would be too easy to say\n-                    // something like n != 1 and have some wiseguy pass in 1 with extra\n-                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n-                    //if (opcode == OP_NOTEQUAL)\n-                    //    fEqual = !fEqual;\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fEqual ? vchTrue : vchFalse);\n-                    if (opcode == OP_EQUALVERIFY)\n-                    {\n-                        if (fEqual)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-\n-                //\n-                // Numeric\n-                //\n-                case OP_1ADD:\n-                case OP_1SUB:\n-                case OP_2MUL:\n-                case OP_2DIV:\n-                case OP_NEGATE:\n-                case OP_ABS:\n-                case OP_NOT:\n-                case OP_0NOTEQUAL:\n-                {\n-                    // (in -- out)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    CBigNum bn = CastToBigNum(stacktop(-1));\n-                    switch (opcode)\n-                    {\n-                    case OP_1ADD:       bn += bnOne; break;\n-                    case OP_1SUB:       bn -= bnOne; break;\n-                    case OP_2MUL:       bn <<= 1; break;\n-                    case OP_2DIV:       bn >>= 1; break;\n-                    case OP_NEGATE:     bn = -bn; break;\n-                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n-                    case OP_NOT:        bn = (bn == bnZero); break;\n-                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n-                    }\n-                    popstack(stack);\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-                case OP_ADD:\n-                case OP_SUB:\n-                case OP_MUL:\n-                case OP_DIV:\n-                case OP_MOD:\n-                case OP_LSHIFT:\n-                case OP_RSHIFT:\n-                case OP_BOOLAND:\n-                case OP_BOOLOR:\n-                case OP_NUMEQUAL:\n-                case OP_NUMEQUALVERIFY:\n-                case OP_NUMNOTEQUAL:\n-                case OP_LESSTHAN:\n-                case OP_GREATERTHAN:\n-                case OP_LESSTHANOREQUAL:\n-                case OP_GREATERTHANOREQUAL:\n-                case OP_MIN:\n-                case OP_MAX:\n-                {\n-                    // (x1 x2 -- out)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n-                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n-                    CBigNum bn;\n-                    switch (opcode)\n-                    {\n-                    case OP_ADD:\n-                        bn = bn1 + bn2;\n-                        break;\n-\n-                    case OP_SUB:\n-                        bn = bn1 - bn2;\n-                        break;\n-\n-                    case OP_MUL:\n-                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n-                            return false;\n-                        break;\n-\n-                    case OP_DIV:\n-                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n-                            return false;\n-                        break;\n-\n-                    case OP_MOD:\n-                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n-                            return false;\n-                        break;\n-\n-                    case OP_LSHIFT:\n-                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n-                            return false;\n-                        bn = bn1 << bn2.getulong();\n-                        break;\n-\n-                    case OP_RSHIFT:\n-                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n-                            return false;\n-                        bn = bn1 >> bn2.getulong();\n-                        break;\n-\n-                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n-                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n-                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n-                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n-                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n-                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n-                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n-                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n-                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n-                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n-                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n-                    }\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(bn.getvch());\n-\n-                    if (opcode == OP_NUMEQUALVERIFY)\n-                    {\n-                        if (CastToBool(stacktop(-1)))\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                case OP_WITHIN:\n-                {\n-                    // (x min max -- out)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n-                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n-                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n-                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n-                    popstack(stack);\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fValue ? vchTrue : vchFalse);\n-                }\n-                break;\n-\n-\n-                //\n-                // Crypto\n-                //\n-                case OP_RIPEMD160:\n-                case OP_SHA1:\n-                case OP_SHA256:\n-                case OP_HASH160:\n-                case OP_HASH256:\n-                {\n-                    // (in -- hash)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype& vch = stacktop(-1);\n-                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n-                    if (opcode == OP_RIPEMD160)\n-                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n-                    else if (opcode == OP_SHA1)\n-                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n-                    else if (opcode == OP_SHA256)\n-                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n-                    else if (opcode == OP_HASH160)\n-                    {\n-                        uint160 hash160 = Hash160(vch);\n-                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n-                    }\n-                    else if (opcode == OP_HASH256)\n-                    {\n-                        uint256 hash = Hash(vch.begin(), vch.end());\n-                        memcpy(&vchHash[0], &hash, sizeof(hash));\n-                    }\n-                    popstack(stack);\n-                    stack.push_back(vchHash);\n-                }\n-                break;\n-\n-                case OP_CODESEPARATOR:\n-                {\n-                    // Hash starts after the code separator\n-                    pbegincodehash = pc;\n-                }\n-                break;\n-\n-                case OP_CHECKSIG:\n-                case OP_CHECKSIGVERIFY:\n-                {\n-                    // (sig pubkey -- bool)\n-                    if (stack.size() < 2)\n-                        return false;\n-\n-                    valtype& vchSig    = stacktop(-2);\n-                    valtype& vchPubKey = stacktop(-1);\n-\n-                    ////// debug print\n-                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n-                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n-\n-                    // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n-\n-                    // Drop the signature, since there's no way for a signature to sign itself\n-                    scriptCode.FindAndDelete(CScript(vchSig));\n-\n-                    bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n-\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-                    if (opcode == OP_CHECKSIGVERIFY)\n-                    {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                case OP_CHECKMULTISIG:\n-                case OP_CHECKMULTISIGVERIFY:\n-                {\n-                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n-\n-                    int i = 1;\n-                    if (stack.size() < i)\n-                        return false;\n-\n-                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n-                    if (nKeysCount < 0 || nKeysCount > 20)\n-                        return false;\n-                    nOpCount += nKeysCount;\n-                    if (nOpCount > 201)\n-                        return false;\n-                    int ikey = ++i;\n-                    i += nKeysCount;\n-                    if (stack.size() < i)\n-                        return false;\n-\n-                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n-                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n-                        return false;\n-                    int isig = ++i;\n-                    i += nSigsCount;\n-                    if (stack.size() < i)\n-                        return false;\n-\n-                    // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n-\n-                    // Drop the signatures, since there's no way for a signature to sign itself\n-                    for (int k = 0; k < nSigsCount; k++)\n-                    {\n-                        valtype& vchSig = stacktop(-isig-k);\n-                        scriptCode.FindAndDelete(CScript(vchSig));\n-                    }\n-\n-                    bool fSuccess = true;\n-                    while (fSuccess && nSigsCount > 0)\n-                    {\n-                        valtype& vchSig    = stacktop(-isig);\n-                        valtype& vchPubKey = stacktop(-ikey);\n-\n-                        // Check signature\n-                        if (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n-                        {\n-                            isig++;\n-                            nSigsCount--;\n-                        }\n-                        ikey++;\n-                        nKeysCount--;\n-\n-                        // If there are more signatures left than keys left,\n-                        // then too many signatures have failed\n-                        if (nSigsCount > nKeysCount)\n-                            fSuccess = false;\n-                    }\n-\n-                    while (i-- > 0)\n-                        popstack(stack);\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-\n-                    if (opcode == OP_CHECKMULTISIGVERIFY)\n-                    {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                default:\n-                    return false;\n-            }\n-\n-            // Size limits\n-            if (stack.size() + altstack.size() > 1000)\n-                return false;\n-        }\n+\twhile (pc < pend)\n+\t{\n+\t    bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n+\n+\t    //\n+\t    // Read instruction\n+\t    //\n+\t    if (!script.GetOp(pc, opcode, vchPushValue))\n+\t\treturn false;\n+\t    if (vchPushValue.size() > 520)\n+\t\treturn false;\n+\t    if (opcode > OP_16 && ++nOpCount > 201)\n+\t\treturn false;\n+\n+\t    if (opcode == OP_CAT ||\n+\t\topcode == OP_SUBSTR ||\n+\t\topcode == OP_LEFT ||\n+\t\topcode == OP_RIGHT ||\n+\t\topcode == OP_INVERT ||\n+\t\topcode == OP_AND ||\n+\t\topcode == OP_OR ||\n+\t\topcode == OP_XOR ||\n+\t\topcode == OP_2MUL ||\n+\t\topcode == OP_2DIV ||\n+\t\topcode == OP_MUL ||\n+\t\topcode == OP_DIV ||\n+\t\topcode == OP_MOD ||\n+\t\topcode == OP_LSHIFT ||\n+\t\topcode == OP_RSHIFT)\n+\t\treturn false;\n+\n+\t    if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n+\t\tstack.push_back(vchPushValue);\n+\t    else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n+\t    switch (opcode)\n+\t    {\n+\t\t//\n+\t\t// Push value\n+\t\t//\n+\t\tcase OP_1NEGATE:\n+\t\tcase OP_1:\n+\t\tcase OP_2:\n+\t\tcase OP_3:\n+\t\tcase OP_4:\n+\t\tcase OP_5:\n+\t\tcase OP_6:\n+\t\tcase OP_7:\n+\t\tcase OP_8:\n+\t\tcase OP_9:\n+\t\tcase OP_10:\n+\t\tcase OP_11:\n+\t\tcase OP_12:\n+\t\tcase OP_13:\n+\t\tcase OP_14:\n+\t\tcase OP_15:\n+\t\tcase OP_16:\n+\t\t{\n+\t\t    // ( -- value)\n+\t\t    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n+\t\t    stack.push_back(bn.getvch());\n+\t\t}\n+\t\tbreak;\n+\n+\n+\t\t//\n+\t\t// Control\n+\t\t//\n+\t\tcase OP_NOP:\n+\t\tcase OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n+\t\tcase OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n+\t\tbreak;\n+\n+\t\tcase OP_IF:\n+\t\tcase OP_NOTIF:\n+\t\t{\n+\t\t    // <expression> if [statements] [else [statements]] endif\n+\t\t    bool fValue = false;\n+\t\t    if (fExec)\n+\t\t    {\n+\t\t\tif (stack.size() < 1)\n+\t\t\t    return false;\n+\t\t\tvaltype& vch = stacktop(-1);\n+\t\t\tfValue = CastToBool(vch);\n+\t\t\tif (opcode == OP_NOTIF)\n+\t\t\t    fValue = !fValue;\n+\t\t\tpopstack(stack);\n+\t\t    }\n+\t\t    vfExec.push_back(fValue);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_ELSE:\n+\t\t{\n+\t\t    if (vfExec.empty())\n+\t\t\treturn false;\n+\t\t    vfExec.back() = !vfExec.back();\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_ENDIF:\n+\t\t{\n+\t\t    if (vfExec.empty())\n+\t\t\treturn false;\n+\t\t    vfExec.pop_back();\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_VERIFY:\n+\t\t{\n+\t\t    // (true -- ) or\n+\t\t    // (false -- false) and return\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    bool fValue = CastToBool(stacktop(-1));\n+\t\t    if (fValue)\n+\t\t\tpopstack(stack);\n+\t\t    else\n+\t\t\treturn false;\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_RETURN:\n+\t\t{\n+\t\t    return false;\n+\t\t}\n+\t\tbreak;\n+\n+\n+\t\t//\n+\t\t// Stack ops\n+\t\t//\n+\t\tcase OP_TOALTSTACK:\n+\t\t{\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    altstack.push_back(stacktop(-1));\n+\t\t    popstack(stack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_FROMALTSTACK:\n+\t\t{\n+\t\t    if (altstack.size() < 1)\n+\t\t\treturn false;\n+\t\t    stack.push_back(altstacktop(-1));\n+\t\t    popstack(altstack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_2DROP:\n+\t\t{\n+\t\t    // (x1 x2 -- )\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_2DUP:\n+\t\t{\n+\t\t    // (x1 x2 -- x1 x2 x1 x2)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype vch1 = stacktop(-2);\n+\t\t    valtype vch2 = stacktop(-1);\n+\t\t    stack.push_back(vch1);\n+\t\t    stack.push_back(vch2);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_3DUP:\n+\t\t{\n+\t\t    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n+\t\t    if (stack.size() < 3)\n+\t\t\treturn false;\n+\t\t    valtype vch1 = stacktop(-3);\n+\t\t    valtype vch2 = stacktop(-2);\n+\t\t    valtype vch3 = stacktop(-1);\n+\t\t    stack.push_back(vch1);\n+\t\t    stack.push_back(vch2);\n+\t\t    stack.push_back(vch3);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_2OVER:\n+\t\t{\n+\t\t    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n+\t\t    if (stack.size() < 4)\n+\t\t\treturn false;\n+\t\t    valtype vch1 = stacktop(-4);\n+\t\t    valtype vch2 = stacktop(-3);\n+\t\t    stack.push_back(vch1);\n+\t\t    stack.push_back(vch2);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_2ROT:\n+\t\t{\n+\t\t    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n+\t\t    if (stack.size() < 6)\n+\t\t\treturn false;\n+\t\t    valtype vch1 = stacktop(-6);\n+\t\t    valtype vch2 = stacktop(-5);\n+\t\t    stack.erase(stack.end()-6, stack.end()-4);\n+\t\t    stack.push_back(vch1);\n+\t\t    stack.push_back(vch2);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_2SWAP:\n+\t\t{\n+\t\t    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n+\t\t    if (stack.size() < 4)\n+\t\t\treturn false;\n+\t\t    swap(stacktop(-4), stacktop(-2));\n+\t\t    swap(stacktop(-3), stacktop(-1));\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_IFDUP:\n+\t\t{\n+\t\t    // (x - 0 | x x)\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    valtype vch = stacktop(-1);\n+\t\t    if (CastToBool(vch))\n+\t\t\tstack.push_back(vch);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_DEPTH:\n+\t\t{\n+\t\t    // -- stacksize\n+\t\t    CBigNum bn(stack.size());\n+\t\t    stack.push_back(bn.getvch());\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_DROP:\n+\t\t{\n+\t\t    // (x -- )\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    popstack(stack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_DUP:\n+\t\t{\n+\t\t    // (x -- x x)\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    valtype vch = stacktop(-1);\n+\t\t    stack.push_back(vch);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_NIP:\n+\t\t{\n+\t\t    // (x1 x2 -- x2)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    stack.erase(stack.end() - 2);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_OVER:\n+\t\t{\n+\t\t    // (x1 x2 -- x1 x2 x1)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype vch = stacktop(-2);\n+\t\t    stack.push_back(vch);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_PICK:\n+\t\tcase OP_ROLL:\n+\t\t{\n+\t\t    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n+\t\t    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    int n = CastToBigNum(stacktop(-1)).getint();\n+\t\t    popstack(stack);\n+\t\t    if (n < 0 || n >= stack.size())\n+\t\t\treturn false;\n+\t\t    valtype vch = stacktop(-n-1);\n+\t\t    if (opcode == OP_ROLL)\n+\t\t\tstack.erase(stack.end()-n-1);\n+\t\t    stack.push_back(vch);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_ROT:\n+\t\t{\n+\t\t    // (x1 x2 x3 -- x2 x3 x1)\n+\t\t    //  x2 x1 x3  after first swap\n+\t\t    //  x2 x3 x1  after second swap\n+\t\t    if (stack.size() < 3)\n+\t\t\treturn false;\n+\t\t    swap(stacktop(-3), stacktop(-2));\n+\t\t    swap(stacktop(-2), stacktop(-1));\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_SWAP:\n+\t\t{\n+\t\t    // (x1 x2 -- x2 x1)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    swap(stacktop(-2), stacktop(-1));\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_TUCK:\n+\t\t{\n+\t\t    // (x1 x2 -- x2 x1 x2)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype vch = stacktop(-1);\n+\t\t    stack.insert(stack.end()-2, vch);\n+\t\t}\n+\t\tbreak;\n+\n+\n+\t\t//\n+\t\t// Splice ops\n+\t\t//\n+\t\tcase OP_CAT:\n+\t\t{\n+\t\t    // (x1 x2 -- out)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype& vch1 = stacktop(-2);\n+\t\t    valtype& vch2 = stacktop(-1);\n+\t\t    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n+\t\t    popstack(stack);\n+\t\t    if (stacktop(-1).size() > 520)\n+\t\t\treturn false;\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_SUBSTR:\n+\t\t{\n+\t\t    // (in begin size -- out)\n+\t\t    if (stack.size() < 3)\n+\t\t\treturn false;\n+\t\t    valtype& vch = stacktop(-3);\n+\t\t    int nBegin = CastToBigNum(stacktop(-2)).getint();\n+\t\t    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n+\t\t    if (nBegin < 0 || nEnd < nBegin)\n+\t\t\treturn false;\n+\t\t    if (nBegin > vch.size())\n+\t\t\tnBegin = vch.size();\n+\t\t    if (nEnd > vch.size())\n+\t\t\tnEnd = vch.size();\n+\t\t    vch.erase(vch.begin() + nEnd, vch.end());\n+\t\t    vch.erase(vch.begin(), vch.begin() + nBegin);\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_LEFT:\n+\t\tcase OP_RIGHT:\n+\t\t{\n+\t\t    // (in size -- out)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype& vch = stacktop(-2);\n+\t\t    int nSize = CastToBigNum(stacktop(-1)).getint();\n+\t\t    if (nSize < 0)\n+\t\t\treturn false;\n+\t\t    if (nSize > vch.size())\n+\t\t\tnSize = vch.size();\n+\t\t    if (opcode == OP_LEFT)\n+\t\t\tvch.erase(vch.begin() + nSize, vch.end());\n+\t\t    else\n+\t\t\tvch.erase(vch.begin(), vch.end() - nSize);\n+\t\t    popstack(stack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_SIZE:\n+\t\t{\n+\t\t    // (in -- in size)\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    CBigNum bn(stacktop(-1).size());\n+\t\t    stack.push_back(bn.getvch());\n+\t\t}\n+\t\tbreak;\n+\n+\n+\t\t//\n+\t\t// Bitwise logic\n+\t\t//\n+\t\tcase OP_INVERT:\n+\t\t{\n+\t\t    // (in - out)\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    valtype& vch = stacktop(-1);\n+\t\t    for (int i = 0; i < vch.size(); i++)\n+\t\t\tvch[i] = ~vch[i];\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_AND:\n+\t\tcase OP_OR:\n+\t\tcase OP_XOR:\n+\t\t{\n+\t\t    // (x1 x2 - out)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype& vch1 = stacktop(-2);\n+\t\t    valtype& vch2 = stacktop(-1);\n+\t\t    MakeSameSize(vch1, vch2);\n+\t\t    if (opcode == OP_AND)\n+\t\t    {\n+\t\t\tfor (int i = 0; i < vch1.size(); i++)\n+\t\t\t    vch1[i] &= vch2[i];\n+\t\t    }\n+\t\t    else if (opcode == OP_OR)\n+\t\t    {\n+\t\t\tfor (int i = 0; i < vch1.size(); i++)\n+\t\t\t    vch1[i] |= vch2[i];\n+\t\t    }\n+\t\t    else if (opcode == OP_XOR)\n+\t\t    {\n+\t\t\tfor (int i = 0; i < vch1.size(); i++)\n+\t\t\t    vch1[i] ^= vch2[i];\n+\t\t    }\n+\t\t    popstack(stack);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_EQUAL:\n+\t\tcase OP_EQUALVERIFY:\n+\t\t//case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n+\t\t{\n+\t\t    // (x1 x2 - bool)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    valtype& vch1 = stacktop(-2);\n+\t\t    valtype& vch2 = stacktop(-1);\n+\t\t    bool fEqual = (vch1 == vch2);\n+\t\t    // OP_NOTEQUAL is disabled because it would be too easy to say\n+\t\t    // something like n != 1 and have some wiseguy pass in 1 with extra\n+\t\t    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n+\t\t    //if (opcode == OP_NOTEQUAL)\n+\t\t    //    fEqual = !fEqual;\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t    stack.push_back(fEqual ? vchTrue : vchFalse);\n+\t\t    if (opcode == OP_EQUALVERIFY)\n+\t\t    {\n+\t\t\tif (fEqual)\n+\t\t\t    popstack(stack);\n+\t\t\telse\n+\t\t\t    return false;\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\n+\t\t//\n+\t\t// Numeric\n+\t\t//\n+\t\tcase OP_1ADD:\n+\t\tcase OP_1SUB:\n+\t\tcase OP_2MUL:\n+\t\tcase OP_2DIV:\n+\t\tcase OP_NEGATE:\n+\t\tcase OP_ABS:\n+\t\tcase OP_NOT:\n+\t\tcase OP_0NOTEQUAL:\n+\t\t{\n+\t\t    // (in -- out)\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    CBigNum bn = CastToBigNum(stacktop(-1));\n+\t\t    switch (opcode)\n+\t\t    {\n+\t\t    case OP_1ADD:       bn += bnOne; break;\n+\t\t    case OP_1SUB:       bn -= bnOne; break;\n+\t\t    case OP_2MUL:       bn <<= 1; break;\n+\t\t    case OP_2DIV:       bn >>= 1; break;\n+\t\t    case OP_NEGATE:     bn = -bn; break;\n+\t\t    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n+\t\t    case OP_NOT:        bn = (bn == bnZero); break;\n+\t\t    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n+\t\t    }\n+\t\t    popstack(stack);\n+\t\t    stack.push_back(bn.getvch());\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_ADD:\n+\t\tcase OP_SUB:\n+\t\tcase OP_MUL:\n+\t\tcase OP_DIV:\n+\t\tcase OP_MOD:\n+\t\tcase OP_LSHIFT:\n+\t\tcase OP_RSHIFT:\n+\t\tcase OP_BOOLAND:\n+\t\tcase OP_BOOLOR:\n+\t\tcase OP_NUMEQUAL:\n+\t\tcase OP_NUMEQUALVERIFY:\n+\t\tcase OP_NUMNOTEQUAL:\n+\t\tcase OP_LESSTHAN:\n+\t\tcase OP_GREATERTHAN:\n+\t\tcase OP_LESSTHANOREQUAL:\n+\t\tcase OP_GREATERTHANOREQUAL:\n+\t\tcase OP_MIN:\n+\t\tcase OP_MAX:\n+\t\t{\n+\t\t    // (x1 x2 -- out)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\t\t    CBigNum bn1 = CastToBigNum(stacktop(-2));\n+\t\t    CBigNum bn2 = CastToBigNum(stacktop(-1));\n+\t\t    CBigNum bn;\n+\t\t    switch (opcode)\n+\t\t    {\n+\t\t    case OP_ADD:\n+\t\t\tbn = bn1 + bn2;\n+\t\t\tbreak;\n+\n+\t\t    case OP_SUB:\n+\t\t\tbn = bn1 - bn2;\n+\t\t\tbreak;\n+\n+\t\t    case OP_MUL:\n+\t\t\tif (!BN_mul(&bn, &bn1, &bn2, pctx))\n+\t\t\t    return false;\n+\t\t\tbreak;\n+\n+\t\t    case OP_DIV:\n+\t\t\tif (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n+\t\t\t    return false;\n+\t\t\tbreak;\n+\n+\t\t    case OP_MOD:\n+\t\t\tif (!BN_mod(&bn, &bn1, &bn2, pctx))\n+\t\t\t    return false;\n+\t\t\tbreak;\n+\n+\t\t    case OP_LSHIFT:\n+\t\t\tif (bn2 < bnZero || bn2 > CBigNum(2048))\n+\t\t\t    return false;\n+\t\t\tbn = bn1 << bn2.getulong();\n+\t\t\tbreak;\n+\n+\t\t    case OP_RSHIFT:\n+\t\t\tif (bn2 < bnZero || bn2 > CBigNum(2048))\n+\t\t\t    return false;\n+\t\t\tbn = bn1 >> bn2.getulong();\n+\t\t\tbreak;\n+\n+\t\t    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n+\t\t    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n+\t\t    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n+\t\t    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n+\t\t    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n+\t\t    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n+\t\t    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n+\t\t    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n+\t\t    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n+\t\t    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n+\t\t    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n+\t\t    }\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t    stack.push_back(bn.getvch());\n+\n+\t\t    if (opcode == OP_NUMEQUALVERIFY)\n+\t\t    {\n+\t\t\tif (CastToBool(stacktop(-1)))\n+\t\t\t    popstack(stack);\n+\t\t\telse\n+\t\t\t    return false;\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_WITHIN:\n+\t\t{\n+\t\t    // (x min max -- out)\n+\t\t    if (stack.size() < 3)\n+\t\t\treturn false;\n+\t\t    CBigNum bn1 = CastToBigNum(stacktop(-3));\n+\t\t    CBigNum bn2 = CastToBigNum(stacktop(-2));\n+\t\t    CBigNum bn3 = CastToBigNum(stacktop(-1));\n+\t\t    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t    stack.push_back(fValue ? vchTrue : vchFalse);\n+\t\t}\n+\t\tbreak;\n+\n+\n+\t\t//\n+\t\t// Crypto\n+\t\t//\n+\t\tcase OP_RIPEMD160:\n+\t\tcase OP_SHA1:\n+\t\tcase OP_SHA256:\n+\t\tcase OP_HASH160:\n+\t\tcase OP_HASH256:\n+\t\t{\n+\t\t    // (in -- hash)\n+\t\t    if (stack.size() < 1)\n+\t\t\treturn false;\n+\t\t    valtype& vch = stacktop(-1);\n+\t\t    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n+\t\t    if (opcode == OP_RIPEMD160)\n+\t\t\tRIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n+\t\t    else if (opcode == OP_SHA1)\n+\t\t\tSHA1(&vch[0], vch.size(), &vchHash[0]);\n+\t\t    else if (opcode == OP_SHA256)\n+\t\t\tSHA256(&vch[0], vch.size(), &vchHash[0]);\n+\t\t    else if (opcode == OP_HASH160)\n+\t\t    {\n+\t\t\tuint160 hash160 = Hash160(vch);\n+\t\t\tmemcpy(&vchHash[0], &hash160, sizeof(hash160));\n+\t\t    }\n+\t\t    else if (opcode == OP_HASH256)\n+\t\t    {\n+\t\t\tuint256 hash = Hash(vch.begin(), vch.end());\n+\t\t\tmemcpy(&vchHash[0], &hash, sizeof(hash));\n+\t\t    }\n+\t\t    popstack(stack);\n+\t\t    stack.push_back(vchHash);\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_CODESEPARATOR:\n+\t\t{\n+\t\t    // Hash starts after the code separator\n+\t\t    pbegincodehash = pc;\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_CHECKSIG:\n+\t\tcase OP_CHECKSIGVERIFY:\n+\t\t{\n+\t\t    // (sig pubkey -- bool)\n+\t\t    if (stack.size() < 2)\n+\t\t\treturn false;\n+\n+\t\t    valtype& vchSig    = stacktop(-2);\n+\t\t    valtype& vchPubKey = stacktop(-1);\n+\n+\t\t    ////// debug print\n+\t\t    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n+\t\t    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n+\n+\t\t    // Subset of script starting at the most recent codeseparator\n+\t\t    CScript scriptCode(pbegincodehash, pend);\n+\n+\t\t    // Drop the signature, since there's no way for a signature to sign itself\n+\t\t    scriptCode.FindAndDelete(CScript(vchSig));\n+\n+\t\t    bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+\n+\t\t    popstack(stack);\n+\t\t    popstack(stack);\n+\t\t    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+\t\t    if (opcode == OP_CHECKSIGVERIFY)\n+\t\t    {\n+\t\t\tif (fSuccess)\n+\t\t\t    popstack(stack);\n+\t\t\telse\n+\t\t\t    return false;\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t\tcase OP_CHECKMULTISIG:\n+\t\tcase OP_CHECKMULTISIGVERIFY:\n+\t\t{\n+\t\t    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n+\n+\t\t    int i = 1;\n+\t\t    if (stack.size() < i)\n+\t\t\treturn false;\n+\n+\t\t    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n+\t\t    if (nKeysCount < 0 || nKeysCount > 20)\n+\t\t\treturn false;\n+\t\t    nOpCount += nKeysCount;\n+\t\t    if (nOpCount > 201)\n+\t\t\treturn false;\n+\t\t    int ikey = ++i;\n+\t\t    i += nKeysCount;\n+\t\t    if (stack.size() < i)\n+\t\t\treturn false;\n+\n+\t\t    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n+\t\t    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n+\t\t\treturn false;\n+\t\t    int isig = ++i;\n+\t\t    i += nSigsCount;\n+\t\t    if (stack.size() < i)\n+\t\t\treturn false;\n+\n+\t\t    // Subset of script starting at the most recent codeseparator\n+\t\t    CScript scriptCode(pbegincodehash, pend);\n+\n+\t\t    // Drop the signatures, since there's no way for a signature to sign itself\n+\t\t    for (int k = 0; k < nSigsCount; k++)\n+\t\t    {\n+\t\t\tvaltype& vchSig = stacktop(-isig-k);\n+\t\t\tscriptCode.FindAndDelete(CScript(vchSig));\n+\t\t    }\n+\n+\t\t    bool fSuccess = true;\n+\t\t    while (fSuccess && nSigsCount > 0)\n+\t\t    {\n+\t\t\tvaltype& vchSig    = stacktop(-isig);\n+\t\t\tvaltype& vchPubKey = stacktop(-ikey);\n+\n+\t\t\t// Check signature\n+\t\t\tif (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n+\t\t\t{\n+\t\t\t    isig++;\n+\t\t\t    nSigsCount--;\n+\t\t\t}\n+\t\t\tikey++;\n+\t\t\tnKeysCount--;\n+\n+\t\t\t// If there are more signatures left than keys left,\n+\t\t\t// then too many signatures have failed\n+\t\t\tif (nSigsCount > nKeysCount)\n+\t\t\t    fSuccess = false;\n+\t\t    }\n+\n+\t\t    while (i-- > 0)\n+\t\t\tpopstack(stack);\n+\t\t    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+\n+\t\t    if (opcode == OP_CHECKMULTISIGVERIFY)\n+\t\t    {\n+\t\t\tif (fSuccess)\n+\t\t\t    popstack(stack);\n+\t\t\telse\n+\t\t\t    return false;\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t\tdefault:\n+\t\t    return false;\n+\t    }\n+\n+\t    // Size limits\n+\t    if (stack.size() + altstack.size() > 1000)\n+\t\treturn false;\n+\t}\n     }\n     catch (...)\n     {\n-        return false;\n+\treturn false;\n     }\n \n \n     if (!vfExec.empty())\n-        return false;\n+\treturn false;\n \n     return true;\n }\n@@ -872,8 +872,8 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n {\n     if (nIn >= txTo.vin.size())\n     {\n-        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n-        return 1;\n+\tprintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+\treturn 1;\n     }\n     CTransaction txTmp(txTo);\n \n@@ -883,44 +883,44 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n \n     // Blank out other inputs' signatures\n     for (int i = 0; i < txTmp.vin.size(); i++)\n-        txTmp.vin[i].scriptSig = CScript();\n+\ttxTmp.vin[i].scriptSig = CScript();\n     txTmp.vin[nIn].scriptSig = scriptCode;\n \n     // Blank out some of the outputs\n     if ((nHashType & 0x1f) == SIGHASH_NONE)\n     {\n-        // Wildcard payee\n-        txTmp.vout.clear();\n+\t// Wildcard payee\n+\ttxTmp.vout.clear();\n \n-        // Let the others update at will\n-        for (int i = 0; i < txTmp.vin.size(); i++)\n-            if (i != nIn)\n-                txTmp.vin[i].nSequence = 0;\n+\t// Let the others update at will\n+\tfor (int i = 0; i < txTmp.vin.size(); i++)\n+\t    if (i != nIn)\n+\t\ttxTmp.vin[i].nSequence = 0;\n     }\n     else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n     {\n-        // Only lockin the txout payee at same index as txin\n-        unsigned int nOut = nIn;\n-        if (nOut >= txTmp.vout.size())\n-        {\n-            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n-            return 1;\n-        }\n-        txTmp.vout.resize(nOut+1);\n-        for (int i = 0; i < nOut; i++)\n-            txTmp.vout[i].SetNull();\n-\n-        // Let the others update at will\n-        for (int i = 0; i < txTmp.vin.size(); i++)\n-            if (i != nIn)\n-                txTmp.vin[i].nSequence = 0;\n+\t// Only lockin the txout payee at same index as txin\n+\tunsigned int nOut = nIn;\n+\tif (nOut >= txTmp.vout.size())\n+\t{\n+\t    printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n+\t    return 1;\n+\t}\n+\ttxTmp.vout.resize(nOut+1);\n+\tfor (int i = 0; i < nOut; i++)\n+\t    txTmp.vout[i].SetNull();\n+\n+\t// Let the others update at will\n+\tfor (int i = 0; i < txTmp.vin.size(); i++)\n+\t    if (i != nIn)\n+\t\ttxTmp.vin[i].nSequence = 0;\n     }\n \n     // Blank out other inputs completely, not recommended for open transactions\n     if (nHashType & SIGHASH_ANYONECANPAY)\n     {\n-        txTmp.vin[0] = txTmp.vin[nIn];\n-        txTmp.vin.resize(1);\n+\ttxTmp.vin[0] = txTmp.vin[nIn];\n+\ttxTmp.vin.resize(1);\n     }\n \n     // Serialize and hash\n@@ -932,19 +932,19 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n \n \n bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n-              const CTransaction& txTo, unsigned int nIn, int nHashType)\n+\t      const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     CKey key;\n     if (!key.SetPubKey(vchPubKey))\n-        return false;\n+\treturn false;\n \n     // Hash type is one byte tacked on to the end of the signature\n     if (vchSig.empty())\n-        return false;\n+\treturn false;\n     if (nHashType == 0)\n-        nHashType = vchSig.back();\n+\tnHashType = vchSig.back();\n     else if (nHashType != vchSig.back())\n-        return false;\n+\treturn false;\n     vchSig.pop_back();\n \n     return key.Verify(SignatureHash(scriptCode, txTo, nIn, nHashType), vchSig);\n@@ -965,53 +965,53 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n     static vector<CScript> vTemplates;\n     if (vTemplates.empty())\n     {\n-        // Standard tx, sender provides pubkey, receiver adds signature\n-        vTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);\n+\t// Standard tx, sender provides pubkey, receiver adds signature\n+\tvTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);\n \n-        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n+\t// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n+\tvTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n     }\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n     foreach(const CScript& script2, vTemplates)\n     {\n-        vSolutionRet.clear();\n-        opcodetype opcode1, opcode2;\n-        vector<unsigned char> vch1, vch2;\n-\n-        // Compare\n-        CScript::const_iterator pc1 = script1.begin();\n-        CScript::const_iterator pc2 = script2.begin();\n-        loop\n-        {\n-            if (pc1 == script1.end() && pc2 == script2.end())\n-            {\n-                // Found a match\n-                reverse(vSolutionRet.begin(), vSolutionRet.end());\n-                return true;\n-            }\n-            if (!script1.GetOp(pc1, opcode1, vch1))\n-                break;\n-            if (!script2.GetOp(pc2, opcode2, vch2))\n-                break;\n-            if (opcode2 == OP_PUBKEY)\n-            {\n-                if (vch1.size() < 33 || vch1.size() > 120)\n-                    break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n-            }\n-            else if (opcode2 == OP_PUBKEYHASH)\n-            {\n-                if (vch1.size() != sizeof(uint160))\n-                    break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n-            }\n-            else if (opcode1 != opcode2 || vch1 != vch2)\n-            {\n-                break;\n-            }\n-        }\n+\tvSolutionRet.clear();\n+\topcodetype opcode1, opcode2;\n+\tvector<unsigned char> vch1, vch2;\n+\n+\t// Compare\n+\tCScript::const_iterator pc1 = script1.begin();\n+\tCScript::const_iterator pc2 = script2.begin();\n+\tloop\n+\t{\n+\t    if (pc1 == script1.end() && pc2 == script2.end())\n+\t    {\n+\t\t// Found a match\n+\t\treverse(vSolutionRet.begin(), vSolutionRet.end());\n+\t\treturn true;\n+\t    }\n+\t    if (!script1.GetOp(pc1, opcode1, vch1))\n+\t\tbreak;\n+\t    if (!script2.GetOp(pc2, opcode2, vch2))\n+\t\tbreak;\n+\t    if (opcode2 == OP_PUBKEY)\n+\t    {\n+\t\tif (vch1.size() < 33 || vch1.size() > 120)\n+\t\t    break;\n+\t\tvSolutionRet.push_back(make_pair(opcode2, vch1));\n+\t    }\n+\t    else if (opcode2 == OP_PUBKEYHASH)\n+\t    {\n+\t\tif (vch1.size() != sizeof(uint160))\n+\t\t    break;\n+\t\tvSolutionRet.push_back(make_pair(opcode2, vch1));\n+\t    }\n+\t    else if (opcode1 != opcode2 || vch1 != vch2)\n+\t    {\n+\t\tbreak;\n+\t    }\n+\t}\n     }\n \n     vSolutionRet.clear();\n@@ -1025,51 +1025,51 @@ bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& s\n \n     vector<pair<opcodetype, valtype> > vSolution;\n     if (!Solver(scriptPubKey, vSolution))\n-        return false;\n+\treturn false;\n \n     // Compile solution\n     CRITICAL_BLOCK(cs_mapKeys)\n     {\n-        foreach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n-        {\n-            if (item.first == OP_PUBKEY)\n-            {\n-                // Sign\n-                const valtype& vchPubKey = item.second;\n-                if (!mapKeys.count(vchPubKey))\n-                    return false;\n-                if (hash != 0)\n-                {\n-                    vector<unsigned char> vchSig;\n-                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n-                        return false;\n-                    vchSig.push_back((unsigned char)nHashType);\n-                    scriptSigRet << vchSig;\n-                }\n-            }\n-            else if (item.first == OP_PUBKEYHASH)\n-            {\n-                // Sign and give pubkey\n-                map<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n-                if (mi == mapPubKeys.end())\n-                    return false;\n-                const vector<unsigned char>& vchPubKey = (*mi).second;\n-                if (!mapKeys.count(vchPubKey))\n-                    return false;\n-                if (hash != 0)\n-                {\n-                    vector<unsigned char> vchSig;\n-                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n-                        return false;\n-                    vchSig.push_back((unsigned char)nHashType);\n-                    scriptSigRet << vchSig << vchPubKey;\n-                }\n-            }\n-            else\n-            {\n-                return false;\n-            }\n-        }\n+\tforeach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+\t{\n+\t    if (item.first == OP_PUBKEY)\n+\t    {\n+\t\t// Sign\n+\t\tconst valtype& vchPubKey = item.second;\n+\t\tif (!mapKeys.count(vchPubKey))\n+\t\t    return false;\n+\t\tif (hash != 0)\n+\t\t{\n+\t\t    vector<unsigned char> vchSig;\n+\t\t    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+\t\t\treturn false;\n+\t\t    vchSig.push_back((unsigned char)nHashType);\n+\t\t    scriptSigRet << vchSig;\n+\t\t}\n+\t    }\n+\t    else if (item.first == OP_PUBKEYHASH)\n+\t    {\n+\t\t// Sign and give pubkey\n+\t\tmap<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n+\t\tif (mi == mapPubKeys.end())\n+\t\t    return false;\n+\t\tconst vector<unsigned char>& vchPubKey = (*mi).second;\n+\t\tif (!mapKeys.count(vchPubKey))\n+\t\t    return false;\n+\t\tif (hash != 0)\n+\t\t{\n+\t\t    vector<unsigned char> vchSig;\n+\t\t    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+\t\t\treturn false;\n+\t\t    vchSig.push_back((unsigned char)nHashType);\n+\t\t    scriptSigRet << vchSig << vchPubKey;\n+\t\t}\n+\t    }\n+\t    else\n+\t    {\n+\t\treturn false;\n+\t    }\n+\t}\n     }\n \n     return true;\n@@ -1096,30 +1096,30 @@ bool ExtractPubKey(const CScript& scriptPubKey, bool fMineOnly, vector<unsigned\n \n     vector<pair<opcodetype, valtype> > vSolution;\n     if (!Solver(scriptPubKey, vSolution))\n-        return false;\n+\treturn false;\n \n     CRITICAL_BLOCK(cs_mapKeys)\n     {\n-        foreach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n-        {\n-            valtype vchPubKey;\n-            if (item.first == OP_PUBKEY)\n-            {\n-                vchPubKey = item.second;\n-            }\n-            else if (item.first == OP_PUBKEYHASH)\n-            {\n-                map<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n-                if (mi == mapPubKeys.end())\n-                    continue;\n-                vchPubKey = (*mi).second;\n-            }\n-            if (!fMineOnly || mapKeys.count(vchPubKey))\n-            {\n-                vchPubKeyRet = vchPubKey;\n-                return true;\n-            }\n-        }\n+\tforeach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+\t{\n+\t    valtype vchPubKey;\n+\t    if (item.first == OP_PUBKEY)\n+\t    {\n+\t\tvchPubKey = item.second;\n+\t    }\n+\t    else if (item.first == OP_PUBKEYHASH)\n+\t    {\n+\t\tmap<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n+\t\tif (mi == mapPubKeys.end())\n+\t\t    continue;\n+\t\tvchPubKey = (*mi).second;\n+\t    }\n+\t    if (!fMineOnly || mapKeys.count(vchPubKey))\n+\t    {\n+\t\tvchPubKeyRet = vchPubKey;\n+\t\treturn true;\n+\t    }\n+\t}\n     }\n     return false;\n }\n@@ -1131,15 +1131,15 @@ bool ExtractHash160(const CScript& scriptPubKey, uint160& hash160Ret)\n \n     vector<pair<opcodetype, valtype> > vSolution;\n     if (!Solver(scriptPubKey, vSolution))\n-        return false;\n+\treturn false;\n \n     foreach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n     {\n-        if (item.first == OP_PUBKEYHASH)\n-        {\n-            hash160Ret = uint160(item.second);\n-            return true;\n-        }\n+\tif (item.first == OP_PUBKEYHASH)\n+\t{\n+\t    hash160Ret = uint160(item.second);\n+\t    return true;\n+\t}\n     }\n     return false;\n }\n@@ -1149,11 +1149,11 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n {\n     vector<vector<unsigned char> > stack;\n     if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n-        return false;\n+\treturn false;\n     if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n-        return false;\n+\treturn false;\n     if (stack.empty())\n-        return false;\n+\treturn false;\n     return CastToBool(stack.back());\n }\n \n@@ -1170,14 +1170,14 @@ bool SignSignature(const CTransaction& txFrom, CTransaction& txTo, unsigned int\n     uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType);\n \n     if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig))\n-        return false;\n+\treturn false;\n \n     txin.scriptSig = scriptPrereq + txin.scriptSig;\n \n     // Test solution\n     if (scriptPrereq.empty())\n-        if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, 0))\n-            return false;\n+\tif (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, 0))\n+\t    return false;\n \n     return true;\n }\n@@ -1188,14 +1188,14 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n     if (txin.prevout.n >= txFrom.vout.size())\n-        return false;\n+\treturn false;\n     const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n     if (txin.prevout.hash != txFrom.GetHash())\n-        return false;\n+\treturn false;\n \n     if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType))\n-        return false;\n+\treturn false;\n \n     // Anytime a signature is successfully verified, it's proof the outpoint is spent,\n     // so lets update the wallet spent flag if it doesn't know due to wallet.dat being"
      },
      {
        "sha": "542f74356234b620865ba31ba8177eb37b4e743a",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 210,
        "deletions": 210,
        "changes": 420,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -303,7 +303,7 @@ inline const char* GetOpName(opcodetype opcode)\n \n     case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n     default:\n-        return \"OP_UNKNOWN\";\n+\treturn \"OP_UNKNOWN\";\n     }\n };\n \n@@ -313,19 +313,19 @@ inline const char* GetOpName(opcodetype opcode)\n inline string ValueString(const vector<unsigned char>& vch)\n {\n     if (vch.size() <= 4)\n-        return strprintf(\"%d\", CBigNum(vch).getint());\n+\treturn strprintf(\"%d\", CBigNum(vch).getint());\n     else\n-        return HexStr(vch);\n+\treturn HexStr(vch);\n }\n \n inline string StackString(const vector<vector<unsigned char> >& vStack)\n {\n     string str;\n     foreach(const vector<unsigned char>& vch, vStack)\n     {\n-        if (!str.empty())\n-            str += \" \";\n-        str += ValueString(vch);\n+\tif (!str.empty())\n+\t    str += \" \";\n+\tstr += ValueString(vch);\n     }\n     return str;\n }\n@@ -343,30 +343,30 @@ class CScript : public vector<unsigned char>\n protected:\n     CScript& push_int64(int64 n)\n     {\n-        if (n == -1 || (n >= 1 && n <= 16))\n-        {\n-            push_back(n + (OP_1 - 1));\n-        }\n-        else\n-        {\n-            CBigNum bn(n);\n-            *this << bn.getvch();\n-        }\n-        return *this;\n+\tif (n == -1 || (n >= 1 && n <= 16))\n+\t{\n+\t    push_back(n + (OP_1 - 1));\n+\t}\n+\telse\n+\t{\n+\t    CBigNum bn(n);\n+\t    *this << bn.getvch();\n+\t}\n+\treturn *this;\n     }\n \n     CScript& push_uint64(uint64 n)\n     {\n-        if (n >= 1 && n <= 16)\n-        {\n-            push_back(n + (OP_1 - 1));\n-        }\n-        else\n-        {\n-            CBigNum bn(n);\n-            *this << bn.getvch();\n-        }\n-        return *this;\n+\tif (n >= 1 && n <= 16)\n+\t{\n+\t    push_back(n + (OP_1 - 1));\n+\t}\n+\telse\n+\t{\n+\t    CBigNum bn(n);\n+\t    *this << bn.getvch();\n+\t}\n+\treturn *this;\n     }\n \n public:\n@@ -379,15 +379,15 @@ class CScript : public vector<unsigned char>\n \n     CScript& operator+=(const CScript& b)\n     {\n-        insert(end(), b.begin(), b.end());\n-        return *this;\n+\tinsert(end(), b.begin(), b.end());\n+\treturn *this;\n     }\n \n     friend CScript operator+(const CScript& a, const CScript& b)\n     {\n-        CScript ret = a;\n-        ret += b;\n-        return ret;\n+\tCScript ret = a;\n+\tret += b;\n+\treturn ret;\n     }\n \n \n@@ -421,275 +421,275 @@ class CScript : public vector<unsigned char>\n \n     CScript& operator<<(opcodetype opcode)\n     {\n-        if (opcode < 0 || opcode > 0xff)\n-            throw runtime_error(\"CScript::operator<<() : invalid opcode\");\n-        insert(end(), (unsigned char)opcode);\n-        return *this;\n+\tif (opcode < 0 || opcode > 0xff)\n+\t    throw runtime_error(\"CScript::operator<<() : invalid opcode\");\n+\tinsert(end(), (unsigned char)opcode);\n+\treturn *this;\n     }\n \n     CScript& operator<<(const uint160& b)\n     {\n-        insert(end(), sizeof(b));\n-        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n-        return *this;\n+\tinsert(end(), sizeof(b));\n+\tinsert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n+\treturn *this;\n     }\n \n     CScript& operator<<(const uint256& b)\n     {\n-        insert(end(), sizeof(b));\n-        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n-        return *this;\n+\tinsert(end(), sizeof(b));\n+\tinsert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n+\treturn *this;\n     }\n \n     CScript& operator<<(const CBigNum& b)\n     {\n-        *this << b.getvch();\n-        return *this;\n+\t*this << b.getvch();\n+\treturn *this;\n     }\n \n     CScript& operator<<(const vector<unsigned char>& b)\n     {\n-        if (b.size() < OP_PUSHDATA1)\n-        {\n-            insert(end(), (unsigned char)b.size());\n-        }\n-        else if (b.size() <= 0xff)\n-        {\n-            insert(end(), OP_PUSHDATA1);\n-            insert(end(), (unsigned char)b.size());\n-        }\n-        else if (b.size() <= 0xffff)\n-        {\n-            insert(end(), OP_PUSHDATA2);\n-            unsigned short nSize = b.size();\n-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-        }\n-        else\n-        {\n-            insert(end(), OP_PUSHDATA4);\n-            unsigned int nSize = b.size();\n-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-        }\n-        insert(end(), b.begin(), b.end());\n-        return *this;\n+\tif (b.size() < OP_PUSHDATA1)\n+\t{\n+\t    insert(end(), (unsigned char)b.size());\n+\t}\n+\telse if (b.size() <= 0xff)\n+\t{\n+\t    insert(end(), OP_PUSHDATA1);\n+\t    insert(end(), (unsigned char)b.size());\n+\t}\n+\telse if (b.size() <= 0xffff)\n+\t{\n+\t    insert(end(), OP_PUSHDATA2);\n+\t    unsigned short nSize = b.size();\n+\t    insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+\t}\n+\telse\n+\t{\n+\t    insert(end(), OP_PUSHDATA4);\n+\t    unsigned int nSize = b.size();\n+\t    insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+\t}\n+\tinsert(end(), b.begin(), b.end());\n+\treturn *this;\n     }\n \n     CScript& operator<<(const CScript& b)\n     {\n-        // I'm not sure if this should push the script or concatenate scripts.\n-        // If there's ever a use for pushing a script onto a script, delete this member fn\n-        assert((\"warning: pushing a CScript onto a CScript with << is probably not intended, use + to concatenate\", false));\n-        return *this;\n+\t// I'm not sure if this should push the script or concatenate scripts.\n+\t// If there's ever a use for pushing a script onto a script, delete this member fn\n+\tassert((\"warning: pushing a CScript onto a CScript with << is probably not intended, use + to concatenate\", false));\n+\treturn *this;\n     }\n \n \n     bool GetOp(iterator& pc, opcodetype& opcodeRet, vector<unsigned char>& vchRet)\n     {\n-         // Wrapper so it can be called with either iterator or const_iterator\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n+\t // Wrapper so it can be called with either iterator or const_iterator\n+\t const_iterator pc2 = pc;\n+\t bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n+\t pc = begin() + (pc2 - begin());\n+\t return fRet;\n     }\n \n     bool GetOp(iterator& pc, opcodetype& opcodeRet)\n     {\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, NULL);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n+\t const_iterator pc2 = pc;\n+\t bool fRet = GetOp2(pc2, opcodeRet, NULL);\n+\t pc = begin() + (pc2 - begin());\n+\t return fRet;\n     }\n \n     bool GetOp(const_iterator& pc, opcodetype& opcodeRet, vector<unsigned char>& vchRet) const\n     {\n-        return GetOp2(pc, opcodeRet, &vchRet);\n+\treturn GetOp2(pc, opcodeRet, &vchRet);\n     }\n \n     bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n     {\n-        return GetOp2(pc, opcodeRet, NULL);\n+\treturn GetOp2(pc, opcodeRet, NULL);\n     }\n \n     bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, vector<unsigned char>* pvchRet) const\n     {\n-        opcodeRet = OP_INVALIDOPCODE;\n-        if (pvchRet)\n-            pvchRet->clear();\n-        if (pc >= end())\n-            return false;\n-\n-        // Read instruction\n-        if (end() - pc < 1)\n-            return false;\n-        unsigned int opcode = *pc++;\n-\n-        // Immediate operand\n-        if (opcode <= OP_PUSHDATA4)\n-        {\n-            unsigned int nSize;\n-            if (opcode < OP_PUSHDATA1)\n-            {\n-                nSize = opcode;\n-            }\n-            else if (opcode == OP_PUSHDATA1)\n-            {\n-                if (end() - pc < 1)\n-                    return false;\n-                nSize = *pc++;\n-            }\n-            else if (opcode == OP_PUSHDATA2)\n-            {\n-                if (end() - pc < 2)\n-                    return false;\n-                nSize = 0;\n-                memcpy(&nSize, &pc[0], 2);\n-                pc += 2;\n-            }\n-            else if (opcode == OP_PUSHDATA4)\n-            {\n-                if (end() - pc < 4)\n-                    return false;\n-                memcpy(&nSize, &pc[0], 4);\n-                pc += 4;\n-            }\n-            if (end() - pc < nSize)\n-                return false;\n-            if (pvchRet)\n-                pvchRet->assign(pc, pc + nSize);\n-            pc += nSize;\n-        }\n-\n-        opcodeRet = (opcodetype)opcode;\n-        return true;\n+\topcodeRet = OP_INVALIDOPCODE;\n+\tif (pvchRet)\n+\t    pvchRet->clear();\n+\tif (pc >= end())\n+\t    return false;\n+\n+\t// Read instruction\n+\tif (end() - pc < 1)\n+\t    return false;\n+\tunsigned int opcode = *pc++;\n+\n+\t// Immediate operand\n+\tif (opcode <= OP_PUSHDATA4)\n+\t{\n+\t    unsigned int nSize;\n+\t    if (opcode < OP_PUSHDATA1)\n+\t    {\n+\t\tnSize = opcode;\n+\t    }\n+\t    else if (opcode == OP_PUSHDATA1)\n+\t    {\n+\t\tif (end() - pc < 1)\n+\t\t    return false;\n+\t\tnSize = *pc++;\n+\t    }\n+\t    else if (opcode == OP_PUSHDATA2)\n+\t    {\n+\t\tif (end() - pc < 2)\n+\t\t    return false;\n+\t\tnSize = 0;\n+\t\tmemcpy(&nSize, &pc[0], 2);\n+\t\tpc += 2;\n+\t    }\n+\t    else if (opcode == OP_PUSHDATA4)\n+\t    {\n+\t\tif (end() - pc < 4)\n+\t\t    return false;\n+\t\tmemcpy(&nSize, &pc[0], 4);\n+\t\tpc += 4;\n+\t    }\n+\t    if (end() - pc < nSize)\n+\t\treturn false;\n+\t    if (pvchRet)\n+\t\tpvchRet->assign(pc, pc + nSize);\n+\t    pc += nSize;\n+\t}\n+\n+\topcodeRet = (opcodetype)opcode;\n+\treturn true;\n     }\n \n \n     void FindAndDelete(const CScript& b)\n     {\n-        if (b.empty())\n-            return;\n-        iterator pc = begin();\n-        opcodetype opcode;\n-        do\n-        {\n-            while (end() - pc >= b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n-                erase(pc, pc + b.size());\n-        }\n-        while (GetOp(pc, opcode));\n+\tif (b.empty())\n+\t    return;\n+\titerator pc = begin();\n+\topcodetype opcode;\n+\tdo\n+\t{\n+\t    while (end() - pc >= b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n+\t\terase(pc, pc + b.size());\n+\t}\n+\twhile (GetOp(pc, opcode));\n     }\n \n \n     int GetSigOpCount() const\n     {\n-        int n = 0;\n-        const_iterator pc = begin();\n-        while (pc < end())\n-        {\n-            opcodetype opcode;\n-            if (!GetOp(pc, opcode))\n-                break;\n-            if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n-                n++;\n-            else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n-                n += 20;\n-        }\n-        return n;\n+\tint n = 0;\n+\tconst_iterator pc = begin();\n+\twhile (pc < end())\n+\t{\n+\t    opcodetype opcode;\n+\t    if (!GetOp(pc, opcode))\n+\t\tbreak;\n+\t    if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n+\t\tn++;\n+\t    else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n+\t\tn += 20;\n+\t}\n+\treturn n;\n     }\n \n \n     bool IsPushOnly() const\n     {\n-        if (size() > 200)\n-            return false;\n-        const_iterator pc = begin();\n-        while (pc < end())\n-        {\n-            opcodetype opcode;\n-            if (!GetOp(pc, opcode))\n-                return false;\n-            if (opcode > OP_16)\n-                return false;\n-        }\n-        return true;\n+\tif (size() > 200)\n+\t    return false;\n+\tconst_iterator pc = begin();\n+\twhile (pc < end())\n+\t{\n+\t    opcodetype opcode;\n+\t    if (!GetOp(pc, opcode))\n+\t\treturn false;\n+\t    if (opcode > OP_16)\n+\t\treturn false;\n+\t}\n+\treturn true;\n     }\n \n \n     uint160 GetBitcoinAddressHash160() const\n     {\n-        opcodetype opcode;\n-        vector<unsigned char> vch;\n-        CScript::const_iterator pc = begin();\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_DUP) return 0;\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_HASH160) return 0;\n-        if (!GetOp(pc, opcode, vch) || vch.size() != sizeof(uint160)) return 0;\n-        uint160 hash160 = uint160(vch);\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_EQUALVERIFY) return 0;\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_CHECKSIG) return 0;\n-        if (pc != end()) return 0;\n-        return hash160;\n+\topcodetype opcode;\n+\tvector<unsigned char> vch;\n+\tCScript::const_iterator pc = begin();\n+\tif (!GetOp(pc, opcode, vch) || opcode != OP_DUP) return 0;\n+\tif (!GetOp(pc, opcode, vch) || opcode != OP_HASH160) return 0;\n+\tif (!GetOp(pc, opcode, vch) || vch.size() != sizeof(uint160)) return 0;\n+\tuint160 hash160 = uint160(vch);\n+\tif (!GetOp(pc, opcode, vch) || opcode != OP_EQUALVERIFY) return 0;\n+\tif (!GetOp(pc, opcode, vch) || opcode != OP_CHECKSIG) return 0;\n+\tif (pc != end()) return 0;\n+\treturn hash160;\n     }\n \n     string GetBitcoinAddress() const\n     {\n-        uint160 hash160 = GetBitcoinAddressHash160();\n-        if (hash160 == 0)\n-            return \"\";\n-        return Hash160ToAddress(hash160);\n+\tuint160 hash160 = GetBitcoinAddressHash160();\n+\tif (hash160 == 0)\n+\t    return \"\";\n+\treturn Hash160ToAddress(hash160);\n     }\n \n     void SetBitcoinAddress(const uint160& hash160)\n     {\n-        this->clear();\n-        *this << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+\tthis->clear();\n+\t*this << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n     }\n \n     void SetBitcoinAddress(const vector<unsigned char>& vchPubKey)\n     {\n-        SetBitcoinAddress(Hash160(vchPubKey));\n+\tSetBitcoinAddress(Hash160(vchPubKey));\n     }\n \n     bool SetBitcoinAddress(const string& strAddress)\n     {\n-        this->clear();\n-        uint160 hash160;\n-        if (!AddressToHash160(strAddress, hash160))\n-            return false;\n-        SetBitcoinAddress(hash160);\n-        return true;\n+\tthis->clear();\n+\tuint160 hash160;\n+\tif (!AddressToHash160(strAddress, hash160))\n+\t    return false;\n+\tSetBitcoinAddress(hash160);\n+\treturn true;\n     }\n \n \n     void PrintHex() const\n     {\n-        printf(\"CScript(%s)\\n\", HexStr(begin(), end(), true).c_str());\n+\tprintf(\"CScript(%s)\\n\", HexStr(begin(), end(), true).c_str());\n     }\n \n     string ToString() const\n     {\n-        string str;\n-        opcodetype opcode;\n-        vector<unsigned char> vch;\n-        const_iterator pc = begin();\n-        while (pc < end())\n-        {\n-            if (!str.empty())\n-                str += \" \";\n-            if (!GetOp(pc, opcode, vch))\n-            {\n-                str += \"[error]\";\n-                return str;\n-            }\n-            if (0 <= opcode && opcode <= OP_PUSHDATA4)\n-                str += ValueString(vch);\n-            else\n-                str += GetOpName(opcode);\n-        }\n-        return str;\n+\tstring str;\n+\topcodetype opcode;\n+\tvector<unsigned char> vch;\n+\tconst_iterator pc = begin();\n+\twhile (pc < end())\n+\t{\n+\t    if (!str.empty())\n+\t\tstr += \" \";\n+\t    if (!GetOp(pc, opcode, vch))\n+\t    {\n+\t\tstr += \"[error]\";\n+\t\treturn str;\n+\t    }\n+\t    if (0 <= opcode && opcode <= OP_PUSHDATA4)\n+\t\tstr += ValueString(vch);\n+\t    else\n+\t\tstr += GetOpName(opcode);\n+\t}\n+\treturn str;\n     }\n \n     void print() const\n     {\n-        printf(\"%s\\n\", ToString().c_str());\n+\tprintf(\"%s\\n\", ToString().c_str());\n     }\n };\n "
      },
      {
        "sha": "7e5d6cd7c24b75a7388335eb501004aab0bf5130",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 262,
        "deletions": 262,
        "changes": 524,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -55,36 +55,36 @@ enum\n #define IMPLEMENT_SERIALIZE(statements)    \\\n     unsigned int GetSerializeSize(int nType=0, int nVersion=VERSION) const  \\\n     {                                           \\\n-        CSerActionGetSerializeSize ser_action;  \\\n-        const bool fGetSize = true;             \\\n-        const bool fWrite = false;              \\\n-        const bool fRead = false;               \\\n-        unsigned int nSerSize = 0;              \\\n-        ser_streamplaceholder s;                \\\n-        s.nType = nType;                        \\\n-        s.nVersion = nVersion;                  \\\n-        {statements}                            \\\n-        return nSerSize;                        \\\n+\tCSerActionGetSerializeSize ser_action;  \\\n+\tconst bool fGetSize = true;             \\\n+\tconst bool fWrite = false;              \\\n+\tconst bool fRead = false;               \\\n+\tunsigned int nSerSize = 0;              \\\n+\tser_streamplaceholder s;                \\\n+\ts.nType = nType;                        \\\n+\ts.nVersion = nVersion;                  \\\n+\t{statements}                            \\\n+\treturn nSerSize;                        \\\n     }                                           \\\n     template<typename Stream>                   \\\n     void Serialize(Stream& s, int nType=0, int nVersion=VERSION) const  \\\n     {                                           \\\n-        CSerActionSerialize ser_action;         \\\n-        const bool fGetSize = false;            \\\n-        const bool fWrite = true;               \\\n-        const bool fRead = false;               \\\n-        unsigned int nSerSize = 0;              \\\n-        {statements}                            \\\n+\tCSerActionSerialize ser_action;         \\\n+\tconst bool fGetSize = false;            \\\n+\tconst bool fWrite = true;               \\\n+\tconst bool fRead = false;               \\\n+\tunsigned int nSerSize = 0;              \\\n+\t{statements}                            \\\n     }                                           \\\n     template<typename Stream>                   \\\n     void Unserialize(Stream& s, int nType=0, int nVersion=VERSION)  \\\n     {                                           \\\n-        CSerActionUnserialize ser_action;       \\\n-        const bool fGetSize = false;            \\\n-        const bool fWrite = false;              \\\n-        const bool fRead = true;                \\\n-        unsigned int nSerSize = 0;              \\\n-        {statements}                            \\\n+\tCSerActionUnserialize ser_action;       \\\n+\tconst bool fGetSize = false;            \\\n+\tconst bool fWrite = false;              \\\n+\tconst bool fRead = true;                \\\n+\tunsigned int nSerSize = 0;              \\\n+\t{statements}                            \\\n     }\n \n #define READWRITE(obj)      (nSerSize += ::SerReadWrite(s, (obj), nType, nVersion, ser_action))\n@@ -171,29 +171,29 @@ void WriteCompactSize(Stream& os, uint64 nSize)\n {\n     if (nSize < 253)\n     {\n-        unsigned char chSize = nSize;\n-        WRITEDATA(os, chSize);\n+\tunsigned char chSize = nSize;\n+\tWRITEDATA(os, chSize);\n     }\n     else if (nSize <= USHRT_MAX)\n     {\n-        unsigned char chSize = 253;\n-        unsigned short xSize = nSize;\n-        WRITEDATA(os, chSize);\n-        WRITEDATA(os, xSize);\n+\tunsigned char chSize = 253;\n+\tunsigned short xSize = nSize;\n+\tWRITEDATA(os, chSize);\n+\tWRITEDATA(os, xSize);\n     }\n     else if (nSize <= UINT_MAX)\n     {\n-        unsigned char chSize = 254;\n-        unsigned int xSize = nSize;\n-        WRITEDATA(os, chSize);\n-        WRITEDATA(os, xSize);\n+\tunsigned char chSize = 254;\n+\tunsigned int xSize = nSize;\n+\tWRITEDATA(os, chSize);\n+\tWRITEDATA(os, xSize);\n     }\n     else\n     {\n-        unsigned char chSize = 255;\n-        uint64 xSize = nSize;\n-        WRITEDATA(os, chSize);\n-        WRITEDATA(os, xSize);\n+\tunsigned char chSize = 255;\n+\tuint64 xSize = nSize;\n+\tWRITEDATA(os, chSize);\n+\tWRITEDATA(os, xSize);\n     }\n     return;\n }\n@@ -206,28 +206,28 @@ uint64 ReadCompactSize(Stream& is)\n     uint64 nSizeRet = 0;\n     if (chSize < 253)\n     {\n-        nSizeRet = chSize;\n+\tnSizeRet = chSize;\n     }\n     else if (chSize == 253)\n     {\n-        unsigned short xSize;\n-        READDATA(is, xSize);\n-        nSizeRet = xSize;\n+\tunsigned short xSize;\n+\tREADDATA(is, xSize);\n+\tnSizeRet = xSize;\n     }\n     else if (chSize == 254)\n     {\n-        unsigned int xSize;\n-        READDATA(is, xSize);\n-        nSizeRet = xSize;\n+\tunsigned int xSize;\n+\tREADDATA(is, xSize);\n+\tnSizeRet = xSize;\n     }\n     else\n     {\n-        uint64 xSize;\n-        READDATA(is, xSize);\n-        nSizeRet = xSize;\n+\tuint64 xSize;\n+\tREADDATA(is, xSize);\n+\tnSizeRet = xSize;\n     }\n     if (nSizeRet > (uint64)MAX_SIZE)\n-        throw std::ios_base::failure(\"ReadCompactSize() : size too large\");\n+\tthrow std::ios_base::failure(\"ReadCompactSize() : size too large\");\n     return nSizeRet;\n }\n \n@@ -252,19 +252,19 @@ class CFlatData\n \n     unsigned int GetSerializeSize(int, int=0) const\n     {\n-        return pend - pbegin;\n+\treturn pend - pbegin;\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s, int, int=0) const\n     {\n-        s.write(pbegin, pend - pbegin);\n+\ts.write(pbegin, pend - pbegin);\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream& s, int, int=0)\n     {\n-        s.read(pbegin, pend - pbegin);\n+\ts.read(pbegin, pend - pbegin);\n     }\n };\n \n@@ -285,26 +285,26 @@ class CFixedFieldString\n \n     unsigned int GetSerializeSize(int, int=0) const\n     {\n-        return LEN;\n+\treturn LEN;\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s, int, int=0) const\n     {\n-        char pszBuf[LEN];\n-        strncpy(pszBuf, pcstr->c_str(), LEN);\n-        s.write(pszBuf, LEN);\n+\tchar pszBuf[LEN];\n+\tstrncpy(pszBuf, pcstr->c_str(), LEN);\n+\ts.write(pszBuf, LEN);\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream& s, int, int=0)\n     {\n-        if (pstr == NULL)\n-            throw std::ios_base::failure(\"CFixedFieldString::Unserialize : trying to unserialize to const string\");\n-        char pszBuf[LEN+1];\n-        s.read(pszBuf, LEN);\n-        pszBuf[LEN] = '\\0';\n-        *pstr = pszBuf;\n+\tif (pstr == NULL)\n+\t    throw std::ios_base::failure(\"CFixedFieldString::Unserialize : trying to unserialize to const string\");\n+\tchar pszBuf[LEN+1];\n+\ts.read(pszBuf, LEN);\n+\tpszBuf[LEN] = '\\0';\n+\t*pstr = pszBuf;\n     }\n };\n \n@@ -408,7 +408,7 @@ void Serialize(Stream& os, const basic_string<C>& str, int, int)\n {\n     WriteCompactSize(os, str.size());\n     if (!str.empty())\n-        os.write((char*)&str[0], str.size() * sizeof(str[0]));\n+\tos.write((char*)&str[0], str.size() * sizeof(str[0]));\n }\n \n template<typename Stream, typename C>\n@@ -417,7 +417,7 @@ void Unserialize(Stream& is, basic_string<C>& str, int, int)\n     unsigned int nSize = ReadCompactSize(is);\n     str.resize(nSize);\n     if (nSize != 0)\n-        is.read((char*)&str[0], nSize * sizeof(str[0]));\n+\tis.read((char*)&str[0], nSize * sizeof(str[0]));\n }\n \n \n@@ -436,7 +436,7 @@ unsigned int GetSerializeSize_impl(const std::vector<T, A>& v, int nType, int nV\n {\n     unsigned int nSize = GetSizeOfCompactSize(v.size());\n     for (typename std::vector<T, A>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n-        nSize += GetSerializeSize((*vi), nType, nVersion);\n+\tnSize += GetSerializeSize((*vi), nType, nVersion);\n     return nSize;\n }\n \n@@ -452,15 +452,15 @@ void Serialize_impl(Stream& os, const std::vector<T, A>& v, int nType, int nVers\n {\n     WriteCompactSize(os, v.size());\n     if (!v.empty())\n-        os.write((char*)&v[0], v.size() * sizeof(T));\n+\tos.write((char*)&v[0], v.size() * sizeof(T));\n }\n \n template<typename Stream, typename T, typename A>\n void Serialize_impl(Stream& os, const std::vector<T, A>& v, int nType, int nVersion, const boost::false_type&)\n {\n     WriteCompactSize(os, v.size());\n     for (typename std::vector<T, A>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n-        ::Serialize(os, (*vi), nType, nVersion);\n+\t::Serialize(os, (*vi), nType, nVersion);\n }\n \n template<typename Stream, typename T, typename A>\n@@ -483,10 +483,10 @@ void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion,\n     unsigned int i = 0;\n     while (i < nSize)\n     {\n-        unsigned int blk = min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n-        v.resize(i + blk);\n-        is.read((char*)&v[i], blk * sizeof(T));\n-        i += blk;\n+\tunsigned int blk = min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n+\tv.resize(i + blk);\n+\tis.read((char*)&v[i], blk * sizeof(T));\n+\ti += blk;\n     }\n }\n \n@@ -504,12 +504,12 @@ void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion,\n     unsigned int nMid = 0;\n     while (nMid < nSize)\n     {\n-        nMid += 5000000 / sizeof(T);\n-        if (nMid > nSize)\n-            nMid = nSize;\n-        v.resize(nMid);\n-        for (; i < nMid; i++)\n-            Unserialize(is, v[i], nType, nVersion);\n+\tnMid += 5000000 / sizeof(T);\n+\tif (nMid > nSize)\n+\t    nMid = nSize;\n+\tv.resize(nMid);\n+\tfor (; i < nMid; i++)\n+\t    Unserialize(is, v[i], nType, nVersion);\n     }\n }\n \n@@ -641,7 +641,7 @@ unsigned int GetSerializeSize(const std::map<K, T, Pred, A>& m, int nType, int n\n {\n     unsigned int nSize = GetSizeOfCompactSize(m.size());\n     for (typename std::map<K, T, Pred, A>::const_iterator mi = m.begin(); mi != m.end(); ++mi)\n-        nSize += GetSerializeSize((*mi), nType, nVersion);\n+\tnSize += GetSerializeSize((*mi), nType, nVersion);\n     return nSize;\n }\n \n@@ -650,7 +650,7 @@ void Serialize(Stream& os, const std::map<K, T, Pred, A>& m, int nType, int nVer\n {\n     WriteCompactSize(os, m.size());\n     for (typename std::map<K, T, Pred, A>::const_iterator mi = m.begin(); mi != m.end(); ++mi)\n-        Serialize(os, (*mi), nType, nVersion);\n+\tSerialize(os, (*mi), nType, nVersion);\n }\n \n template<typename Stream, typename K, typename T, typename Pred, typename A>\n@@ -661,9 +661,9 @@ void Unserialize(Stream& is, std::map<K, T, Pred, A>& m, int nType, int nVersion\n     typename std::map<K, T, Pred, A>::iterator mi = m.begin();\n     for (unsigned int i = 0; i < nSize; i++)\n     {\n-        pair<K, T> item;\n-        Unserialize(is, item, nType, nVersion);\n-        mi = m.insert(mi, item);\n+\tpair<K, T> item;\n+\tUnserialize(is, item, nType, nVersion);\n+\tmi = m.insert(mi, item);\n     }\n }\n \n@@ -677,7 +677,7 @@ unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVer\n {\n     unsigned int nSize = GetSizeOfCompactSize(m.size());\n     for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n-        nSize += GetSerializeSize((*it), nType, nVersion);\n+\tnSize += GetSerializeSize((*it), nType, nVersion);\n     return nSize;\n }\n \n@@ -686,7 +686,7 @@ void Serialize(Stream& os, const std::set<K, Pred, A>& m, int nType, int nVersio\n {\n     WriteCompactSize(os, m.size());\n     for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n-        Serialize(os, (*it), nType, nVersion);\n+\tSerialize(os, (*it), nType, nVersion);\n }\n \n template<typename Stream, typename K, typename Pred, typename A>\n@@ -697,9 +697,9 @@ void Unserialize(Stream& is, std::set<K, Pred, A>& m, int nType, int nVersion)\n     typename std::set<K, Pred, A>::iterator it = m.begin();\n     for (unsigned int i = 0; i < nSize; i++)\n     {\n-        K key;\n-        Unserialize(is, key, nType, nVersion);\n-        it = m.insert(it, key);\n+\tK key;\n+\tUnserialize(is, key, nType, nVersion);\n+\tit = m.insert(it, key);\n     }\n }\n \n@@ -771,9 +771,9 @@ struct secure_allocator : public std::allocator<T>\n \n     void deallocate(T* p, std::size_t n)\n     {\n-        if (p != NULL)\n-            memset(p, 0, sizeof(T) * n);\n-        allocator<T>::deallocate(p, n);\n+\tif (p != NULL)\n+\t    memset(p, 0, sizeof(T) * n);\n+\tallocator<T>::deallocate(p, n);\n     }\n };\n \n@@ -808,61 +808,61 @@ class CDataStream\n \n     explicit CDataStream(int nTypeIn=SER_NETWORK, int nVersionIn=VERSION)\n     {\n-        Init(nTypeIn, nVersionIn);\n+\tInit(nTypeIn, nVersionIn);\n     }\n \n     CDataStream(const_iterator pbegin, const_iterator pend, int nTypeIn=SER_NETWORK, int nVersionIn=VERSION) : vch(pbegin, pend)\n     {\n-        Init(nTypeIn, nVersionIn);\n+\tInit(nTypeIn, nVersionIn);\n     }\n \n #if !defined(_MSC_VER) || _MSC_VER >= 1300\n     CDataStream(const char* pbegin, const char* pend, int nTypeIn=SER_NETWORK, int nVersionIn=VERSION) : vch(pbegin, pend)\n     {\n-        Init(nTypeIn, nVersionIn);\n+\tInit(nTypeIn, nVersionIn);\n     }\n #endif\n \n     CDataStream(const vector_type& vchIn, int nTypeIn=SER_NETWORK, int nVersionIn=VERSION) : vch(vchIn.begin(), vchIn.end())\n     {\n-        Init(nTypeIn, nVersionIn);\n+\tInit(nTypeIn, nVersionIn);\n     }\n \n     CDataStream(const vector<char>& vchIn, int nTypeIn=SER_NETWORK, int nVersionIn=VERSION) : vch(vchIn.begin(), vchIn.end())\n     {\n-        Init(nTypeIn, nVersionIn);\n+\tInit(nTypeIn, nVersionIn);\n     }\n \n     CDataStream(const vector<unsigned char>& vchIn, int nTypeIn=SER_NETWORK, int nVersionIn=VERSION) : vch((char*)&vchIn.begin()[0], (char*)&vchIn.end()[0])\n     {\n-        Init(nTypeIn, nVersionIn);\n+\tInit(nTypeIn, nVersionIn);\n     }\n \n     void Init(int nTypeIn=SER_NETWORK, int nVersionIn=VERSION)\n     {\n-        nReadPos = 0;\n-        nType = nTypeIn;\n-        nVersion = nVersionIn;\n-        state = 0;\n-        exceptmask = ios::badbit | ios::failbit;\n+\tnReadPos = 0;\n+\tnType = nTypeIn;\n+\tnVersion = nVersionIn;\n+\tstate = 0;\n+\texceptmask = ios::badbit | ios::failbit;\n     }\n \n     CDataStream& operator+=(const CDataStream& b)\n     {\n-        vch.insert(vch.end(), b.begin(), b.end());\n-        return *this;\n+\tvch.insert(vch.end(), b.begin(), b.end());\n+\treturn *this;\n     }\n \n     friend CDataStream operator+(const CDataStream& a, const CDataStream& b)\n     {\n-        CDataStream ret = a;\n-        ret += b;\n-        return (ret);\n+\tCDataStream ret = a;\n+\tret += b;\n+\treturn (ret);\n     }\n \n     string str() const\n     {\n-        return (string(begin(), end()));\n+\treturn (string(begin(), end()));\n     }\n \n \n@@ -885,92 +885,92 @@ class CDataStream\n \n     void insert(iterator it, const_iterator first, const_iterator last)\n     {\n-        if (it == vch.begin() + nReadPos && last - first <= nReadPos)\n-        {\n-            // special case for inserting at the front when there's room\n-            nReadPos -= (last - first);\n-            memcpy(&vch[nReadPos], &first[0], last - first);\n-        }\n-        else\n-            vch.insert(it, first, last);\n+\tif (it == vch.begin() + nReadPos && last - first <= nReadPos)\n+\t{\n+\t    // special case for inserting at the front when there's room\n+\t    nReadPos -= (last - first);\n+\t    memcpy(&vch[nReadPos], &first[0], last - first);\n+\t}\n+\telse\n+\t    vch.insert(it, first, last);\n     }\n \n     void insert(iterator it, vector<char>::const_iterator first, vector<char>::const_iterator last)\n     {\n-        if (it == vch.begin() + nReadPos && last - first <= nReadPos)\n-        {\n-            // special case for inserting at the front when there's room\n-            nReadPos -= (last - first);\n-            memcpy(&vch[nReadPos], &first[0], last - first);\n-        }\n-        else\n-            vch.insert(it, first, last);\n+\tif (it == vch.begin() + nReadPos && last - first <= nReadPos)\n+\t{\n+\t    // special case for inserting at the front when there's room\n+\t    nReadPos -= (last - first);\n+\t    memcpy(&vch[nReadPos], &first[0], last - first);\n+\t}\n+\telse\n+\t    vch.insert(it, first, last);\n     }\n \n #if !defined(_MSC_VER) || _MSC_VER >= 1300\n     void insert(iterator it, const char* first, const char* last)\n     {\n-        if (it == vch.begin() + nReadPos && last - first <= nReadPos)\n-        {\n-            // special case for inserting at the front when there's room\n-            nReadPos -= (last - first);\n-            memcpy(&vch[nReadPos], &first[0], last - first);\n-        }\n-        else\n-            vch.insert(it, first, last);\n+\tif (it == vch.begin() + nReadPos && last - first <= nReadPos)\n+\t{\n+\t    // special case for inserting at the front when there's room\n+\t    nReadPos -= (last - first);\n+\t    memcpy(&vch[nReadPos], &first[0], last - first);\n+\t}\n+\telse\n+\t    vch.insert(it, first, last);\n     }\n #endif\n \n     iterator erase(iterator it)\n     {\n-        if (it == vch.begin() + nReadPos)\n-        {\n-            // special case for erasing from the front\n-            if (++nReadPos >= vch.size())\n-            {\n-                // whenever we reach the end, we take the opportunity to clear the buffer\n-                nReadPos = 0;\n-                return vch.erase(vch.begin(), vch.end());\n-            }\n-            return vch.begin() + nReadPos;\n-        }\n-        else\n-            return vch.erase(it);\n+\tif (it == vch.begin() + nReadPos)\n+\t{\n+\t    // special case for erasing from the front\n+\t    if (++nReadPos >= vch.size())\n+\t    {\n+\t\t// whenever we reach the end, we take the opportunity to clear the buffer\n+\t\tnReadPos = 0;\n+\t\treturn vch.erase(vch.begin(), vch.end());\n+\t    }\n+\t    return vch.begin() + nReadPos;\n+\t}\n+\telse\n+\t    return vch.erase(it);\n     }\n \n     iterator erase(iterator first, iterator last)\n     {\n-        if (first == vch.begin() + nReadPos)\n-        {\n-            // special case for erasing from the front\n-            if (last == vch.end())\n-            {\n-                nReadPos = 0;\n-                return vch.erase(vch.begin(), vch.end());\n-            }\n-            else\n-            {\n-                nReadPos = (last - vch.begin());\n-                return last;\n-            }\n-        }\n-        else\n-            return vch.erase(first, last);\n+\tif (first == vch.begin() + nReadPos)\n+\t{\n+\t    // special case for erasing from the front\n+\t    if (last == vch.end())\n+\t    {\n+\t\tnReadPos = 0;\n+\t\treturn vch.erase(vch.begin(), vch.end());\n+\t    }\n+\t    else\n+\t    {\n+\t\tnReadPos = (last - vch.begin());\n+\t\treturn last;\n+\t    }\n+\t}\n+\telse\n+\t    return vch.erase(first, last);\n     }\n \n     inline void Compact()\n     {\n-        vch.erase(vch.begin(), vch.begin() + nReadPos);\n-        nReadPos = 0;\n+\tvch.erase(vch.begin(), vch.begin() + nReadPos);\n+\tnReadPos = 0;\n     }\n \n     bool Rewind(size_type n)\n     {\n-        // Rewind by n characters if the buffer hasn't been compacted yet\n-        if (n > nReadPos)\n-            return false;\n-        nReadPos -= n;\n-        return true;\n+\t// Rewind by n characters if the buffer hasn't been compacted yet\n+\tif (n > nReadPos)\n+\t    return false;\n+\tnReadPos -= n;\n+\treturn true;\n     }\n \n \n@@ -979,9 +979,9 @@ class CDataStream\n     //\n     void setstate(short bits, const char* psz)\n     {\n-        state |= bits;\n-        if (state & exceptmask)\n-            throw std::ios_base::failure(psz);\n+\tstate |= bits;\n+\tif (state & exceptmask)\n+\t    throw std::ios_base::failure(psz);\n     }\n \n     bool eof() const             { return size() == 0; }\n@@ -1002,84 +1002,84 @@ class CDataStream\n \n     CDataStream& read(char* pch, int nSize)\n     {\n-        // Read from the beginning of the buffer\n-        assert(nSize >= 0);\n-        unsigned int nReadPosNext = nReadPos + nSize;\n-        if (nReadPosNext >= vch.size())\n-        {\n-            if (nReadPosNext > vch.size())\n-            {\n-                setstate(ios::failbit, \"CDataStream::read() : end of data\");\n-                memset(pch, 0, nSize);\n-                nSize = vch.size() - nReadPos;\n-            }\n-            memcpy(pch, &vch[nReadPos], nSize);\n-            nReadPos = 0;\n-            vch.clear();\n-            return (*this);\n-        }\n-        memcpy(pch, &vch[nReadPos], nSize);\n-        nReadPos = nReadPosNext;\n-        return (*this);\n+\t// Read from the beginning of the buffer\n+\tassert(nSize >= 0);\n+\tunsigned int nReadPosNext = nReadPos + nSize;\n+\tif (nReadPosNext >= vch.size())\n+\t{\n+\t    if (nReadPosNext > vch.size())\n+\t    {\n+\t\tsetstate(ios::failbit, \"CDataStream::read() : end of data\");\n+\t\tmemset(pch, 0, nSize);\n+\t\tnSize = vch.size() - nReadPos;\n+\t    }\n+\t    memcpy(pch, &vch[nReadPos], nSize);\n+\t    nReadPos = 0;\n+\t    vch.clear();\n+\t    return (*this);\n+\t}\n+\tmemcpy(pch, &vch[nReadPos], nSize);\n+\tnReadPos = nReadPosNext;\n+\treturn (*this);\n     }\n \n     CDataStream& ignore(int nSize)\n     {\n-        // Ignore from the beginning of the buffer\n-        assert(nSize >= 0);\n-        unsigned int nReadPosNext = nReadPos + nSize;\n-        if (nReadPosNext >= vch.size())\n-        {\n-            if (nReadPosNext > vch.size())\n-            {\n-                setstate(ios::failbit, \"CDataStream::ignore() : end of data\");\n-                nSize = vch.size() - nReadPos;\n-            }\n-            nReadPos = 0;\n-            vch.clear();\n-            return (*this);\n-        }\n-        nReadPos = nReadPosNext;\n-        return (*this);\n+\t// Ignore from the beginning of the buffer\n+\tassert(nSize >= 0);\n+\tunsigned int nReadPosNext = nReadPos + nSize;\n+\tif (nReadPosNext >= vch.size())\n+\t{\n+\t    if (nReadPosNext > vch.size())\n+\t    {\n+\t\tsetstate(ios::failbit, \"CDataStream::ignore() : end of data\");\n+\t\tnSize = vch.size() - nReadPos;\n+\t    }\n+\t    nReadPos = 0;\n+\t    vch.clear();\n+\t    return (*this);\n+\t}\n+\tnReadPos = nReadPosNext;\n+\treturn (*this);\n     }\n \n     CDataStream& write(const char* pch, int nSize)\n     {\n-        // Write to the end of the buffer\n-        assert(nSize >= 0);\n-        vch.insert(vch.end(), pch, pch + nSize);\n-        return (*this);\n+\t// Write to the end of the buffer\n+\tassert(nSize >= 0);\n+\tvch.insert(vch.end(), pch, pch + nSize);\n+\treturn (*this);\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s, int nType=0, int nVersion=VERSION) const\n     {\n-        // Special case: stream << stream concatenates like stream += stream\n-        if (!vch.empty())\n-            s.write((char*)&vch[0], vch.size() * sizeof(vch[0]));\n+\t// Special case: stream << stream concatenates like stream += stream\n+\tif (!vch.empty())\n+\t    s.write((char*)&vch[0], vch.size() * sizeof(vch[0]));\n     }\n \n     template<typename T>\n     unsigned int GetSerializeSize(const T& obj)\n     {\n-        // Tells the size of the object if serialized to this stream\n-        return ::GetSerializeSize(obj, nType, nVersion);\n+\t// Tells the size of the object if serialized to this stream\n+\treturn ::GetSerializeSize(obj, nType, nVersion);\n     }\n \n     template<typename T>\n     CDataStream& operator<<(const T& obj)\n     {\n-        // Serialize to this stream\n-        ::Serialize(*this, obj, nType, nVersion);\n-        return (*this);\n+\t// Serialize to this stream\n+\t::Serialize(*this, obj, nType, nVersion);\n+\treturn (*this);\n     }\n \n     template<typename T>\n     CDataStream& operator>>(T& obj)\n     {\n-        // Unserialize from this stream\n-        ::Unserialize(*this, obj, nType, nVersion);\n-        return (*this);\n+\t// Unserialize from this stream\n+\t::Unserialize(*this, obj, nType, nVersion);\n+\treturn (*this);\n     }\n };\n \n@@ -1116,20 +1116,20 @@ int main(int argc, char *argv[])\n     printf(\"CDataStream:\\n\");\n     for (int n = 1000; n <= 4500000; n *= 2)\n     {\n-        CDataStream ss;\n-        time_t nStart = time(NULL);\n-        for (int i = 0; i < n; i++)\n-            ss.write((char*)&vch[0], vch.size());\n-        printf(\"n=%-10d %d seconds\\n\", n, time(NULL) - nStart);\n+\tCDataStream ss;\n+\ttime_t nStart = time(NULL);\n+\tfor (int i = 0; i < n; i++)\n+\t    ss.write((char*)&vch[0], vch.size());\n+\tprintf(\"n=%-10d %d seconds\\n\", n, time(NULL) - nStart);\n     }\n     printf(\"stringstream:\\n\");\n     for (int n = 1000; n <= 4500000; n *= 2)\n     {\n-        stringstream ss;\n-        time_t nStart = time(NULL);\n-        for (int i = 0; i < n; i++)\n-            ss.write((char*)&vch[0], vch.size());\n-        printf(\"n=%-10d %d seconds\\n\", n, time(NULL) - nStart);\n+\tstringstream ss;\n+\ttime_t nStart = time(NULL);\n+\tfor (int i = 0; i < n; i++)\n+\t    ss.write((char*)&vch[0], vch.size());\n+\tprintf(\"n=%-10d %d seconds\\n\", n, time(NULL) - nStart);\n     }\n }\n #endif\n@@ -1163,23 +1163,23 @@ class CAutoFile\n \n     CAutoFile(FILE* filenew=NULL, int nTypeIn=SER_DISK, int nVersionIn=VERSION)\n     {\n-        file = filenew;\n-        nType = nTypeIn;\n-        nVersion = nVersionIn;\n-        state = 0;\n-        exceptmask = ios::badbit | ios::failbit;\n+\tfile = filenew;\n+\tnType = nTypeIn;\n+\tnVersion = nVersionIn;\n+\tstate = 0;\n+\texceptmask = ios::badbit | ios::failbit;\n     }\n \n     ~CAutoFile()\n     {\n-        fclose();\n+\tfclose();\n     }\n \n     void fclose()\n     {\n-        if (file != NULL && file != stdin && file != stdout && file != stderr)\n-            ::fclose(file);\n-        file = NULL;\n+\tif (file != NULL && file != stdin && file != stdout && file != stderr)\n+\t    ::fclose(file);\n+\tfile = NULL;\n     }\n \n     FILE* release()             { FILE* ret = file; file = NULL; return ret; }\n@@ -1196,9 +1196,9 @@ class CAutoFile\n     //\n     void setstate(short bits, const char* psz)\n     {\n-        state |= bits;\n-        if (state & exceptmask)\n-            throw std::ios_base::failure(psz);\n+\tstate |= bits;\n+\tif (state & exceptmask)\n+\t    throw std::ios_base::failure(psz);\n     }\n \n     bool fail() const            { return state & (ios::badbit | ios::failbit); }\n@@ -1216,46 +1216,46 @@ class CAutoFile\n \n     CAutoFile& read(char* pch, int nSize)\n     {\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::read : file handle is NULL\");\n-        if (fread(pch, 1, nSize, file) != nSize)\n-            setstate(ios::failbit, feof(file) ? \"CAutoFile::read : end of file\" : \"CAutoFile::read : fread failed\");\n-        return (*this);\n+\tif (!file)\n+\t    throw std::ios_base::failure(\"CAutoFile::read : file handle is NULL\");\n+\tif (fread(pch, 1, nSize, file) != nSize)\n+\t    setstate(ios::failbit, feof(file) ? \"CAutoFile::read : end of file\" : \"CAutoFile::read : fread failed\");\n+\treturn (*this);\n     }\n \n     CAutoFile& write(const char* pch, int nSize)\n     {\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::write : file handle is NULL\");\n-        if (fwrite(pch, 1, nSize, file) != nSize)\n-            setstate(ios::failbit, \"CAutoFile::write : write failed\");\n-        return (*this);\n+\tif (!file)\n+\t    throw std::ios_base::failure(\"CAutoFile::write : file handle is NULL\");\n+\tif (fwrite(pch, 1, nSize, file) != nSize)\n+\t    setstate(ios::failbit, \"CAutoFile::write : write failed\");\n+\treturn (*this);\n     }\n \n     template<typename T>\n     unsigned int GetSerializeSize(const T& obj)\n     {\n-        // Tells the size of the object if serialized to this stream\n-        return ::GetSerializeSize(obj, nType, nVersion);\n+\t// Tells the size of the object if serialized to this stream\n+\treturn ::GetSerializeSize(obj, nType, nVersion);\n     }\n \n     template<typename T>\n     CAutoFile& operator<<(const T& obj)\n     {\n-        // Serialize to this stream\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator<< : file handle is NULL\");\n-        ::Serialize(*this, obj, nType, nVersion);\n-        return (*this);\n+\t// Serialize to this stream\n+\tif (!file)\n+\t    throw std::ios_base::failure(\"CAutoFile::operator<< : file handle is NULL\");\n+\t::Serialize(*this, obj, nType, nVersion);\n+\treturn (*this);\n     }\n \n     template<typename T>\n     CAutoFile& operator>>(T& obj)\n     {\n-        // Unserialize from this stream\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator>> : file handle is NULL\");\n-        ::Unserialize(*this, obj, nType, nVersion);\n-        return (*this);\n+\t// Unserialize from this stream\n+\tif (!file)\n+\t    throw std::ios_base::failure(\"CAutoFile::operator>> : file handle is NULL\");\n+\t::Unserialize(*this, obj, nType, nVersion);\n+\treturn (*this);\n     }\n };"
      },
      {
        "sha": "d9706cbfffa21a9957b6381b6fbab55f5933a1b9",
        "filename": "src/strlcpy.h",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/strlcpy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/strlcpy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/strlcpy.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -28,20 +28,20 @@ inline size_t strlcpy(char *dst, const char *src, size_t siz)\n     /* Copy as many bytes as will fit */\n     if (n != 0)\n     {\n-        while (--n != 0)\n-        {\n-            if ((*d++ = *s++) == '\\0')\n-                break;\n-        }\n+\twhile (--n != 0)\n+\t{\n+\t    if ((*d++ = *s++) == '\\0')\n+\t\tbreak;\n+\t}\n     }\n \n     /* Not enough room in dst, add NUL and traverse rest of src */\n     if (n == 0)\n     {\n-        if (siz != 0)\n-            *d = '\\0';  /* NUL-terminate dst */\n-        while (*s++)\n-            ;\n+\tif (siz != 0)\n+\t    *d = '\\0';  /* NUL-terminate dst */\n+\twhile (*s++)\n+\t    ;\n     }\n \n     return(s - src - 1); /* count does not include NUL */\n@@ -63,20 +63,20 @@ inline size_t strlcat(char *dst, const char *src, size_t siz)\n \n     /* Find the end of dst and adjust bytes left but don't go past end */\n     while (n-- != 0 && *d != '\\0')\n-        d++;\n+\td++;\n     dlen = d - dst;\n     n = siz - dlen;\n \n     if (n == 0)\n-        return(dlen + strlen(s));\n+\treturn(dlen + strlen(s));\n     while (*s != '\\0')\n     {\n-        if (n != 1)\n-        {\n-            *d++ = *s;\n-            n--;\n-        }\n-        s++;\n+\tif (n != 1)\n+\t{\n+\t    *d++ = *s;\n+\t    n--;\n+\t}\n+\ts++;\n     }\n     *d = '\\0';\n "
      },
      {
        "sha": "004952f6ae09cf26a58e3af1924ef49cf521c416",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 1209,
        "deletions": 1209,
        "changes": 2418,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5"
      },
      {
        "sha": "6cadc70042641878a5dbaf45c5406ca489f0fc67",
        "filename": "src/ui.h",
        "status": "modified",
        "additions": 36,
        "deletions": 36,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/ui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/ui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -26,7 +26,7 @@ inline int MyMessageBox(const wxString& message, const wxString& caption=\"Messag\n {\n #ifdef GUI\n     if (!fDaemon)\n-        return wxMessageBox(message, caption, style, parent, x, y);\n+\treturn wxMessageBox(message, caption, style, parent, x, y);\n #endif\n     printf(\"wxMessageBox %s: %s\\n\", string(caption).c_str(), string(message).c_str());\n     fprintf(stderr, \"%s: %s\\n\", string(caption).c_str(), string(message).c_str());\n@@ -67,7 +67,7 @@ class CMainFrame : public CMainFrameBase\n     void OnListItemActivatedProductsSent(wxListEvent& event);\n     void OnListItemActivatedOrdersSent(wxListEvent& event);\n     void OnListItemActivatedOrdersReceived(wxListEvent& event);\n-\t\n+\n public:\n     /** Constructor */\n     CMainFrame(wxWindow* parent);\n@@ -76,10 +76,10 @@ class CMainFrame : public CMainFrameBase\n     // Custom\n     enum\n     {\n-        ALL = 0,\n-        SENTRECEIVED = 1,\n-        SENT = 2,\n-        RECEIVED = 3,\n+\tALL = 0,\n+\tSENTRECEIVED = 1,\n+\tSENT = 2,\n+\tRECEIVED = 3,\n     };\n     int nPage;\n     wxListCtrl* m_listCtrl;\n@@ -169,7 +169,7 @@ class CSendDialog : public CSendDialogBase\n     void OnButtonPaste(wxCommandEvent& event);\n     void OnButtonSend(wxCommandEvent& event);\n     void OnButtonCancel(wxCommandEvent& event);\n-\t\n+\n public:\n     /** Constructor */\n     CSendDialog(wxWindow* parent, const wxString& strAddress=\"\");\n@@ -190,7 +190,7 @@ class CSendingDialog : public CSendingDialogBase\n     void OnButtonOK(wxCommandEvent& event);\n     void OnButtonCancel(wxCommandEvent& event);\n     void OnPaint(wxPaintEvent& event);\n-\t\n+\n public:\n     /** Constructor */\n     CSendingDialog(wxWindow* parent, const CAddress& addrIn, int64 nPriceIn, const CWalletTx& wtxIn);\n@@ -247,8 +247,8 @@ class CAddressBookDialog : public CAddressBookDialogBase\n     // Custom\n     enum\n     {\n-        SENDING = 0,\n-        RECEIVING = 1,\n+\tSENDING = 0,\n+\tRECEIVING = 1,\n     };\n     int nPage;\n     wxListCtrl* m_listCtrl;\n@@ -272,39 +272,39 @@ class CGetTextFromUserDialog : public CGetTextFromUserDialogBase\n \n     void OnKeyDown(wxKeyEvent& event)\n     {\n-        if (event.GetKeyCode() == '\\r' || event.GetKeyCode() == WXK_NUMPAD_ENTER)\n-            EndModal(true);\n-        else\n-            HandleCtrlA(event);\n+\tif (event.GetKeyCode() == '\\r' || event.GetKeyCode() == WXK_NUMPAD_ENTER)\n+\t    EndModal(true);\n+\telse\n+\t    HandleCtrlA(event);\n     }\n \n public:\n     /** Constructor */\n     CGetTextFromUserDialog(wxWindow* parent,\n-                           const string& strCaption,\n-                           const string& strMessage1,\n-                           const string& strValue1=\"\",\n-                           const string& strMessage2=\"\",\n-                           const string& strValue2=\"\") : CGetTextFromUserDialogBase(parent, wxID_ANY, strCaption)\n+\t\t\t   const string& strCaption,\n+\t\t\t   const string& strMessage1,\n+\t\t\t   const string& strValue1=\"\",\n+\t\t\t   const string& strMessage2=\"\",\n+\t\t\t   const string& strValue2=\"\") : CGetTextFromUserDialogBase(parent, wxID_ANY, strCaption)\n     {\n-        int x = GetSize().GetWidth();\n-        int y = GetSize().GetHeight();\n-        m_staticTextMessage1->SetLabel(strMessage1);\n-        m_textCtrl1->SetValue(strValue1);\n-        y += wxString(strMessage1).Freq('\\n') * 14;\n-        if (!strMessage2.empty())\n-        {\n-            m_staticTextMessage2->Show(true);\n-            m_staticTextMessage2->SetLabel(strMessage2);\n-            m_textCtrl2->Show(true);\n-            m_textCtrl2->SetValue(strValue2);\n-            y += 46 + wxString(strMessage2).Freq('\\n') * 14;\n-        }\n+\tint x = GetSize().GetWidth();\n+\tint y = GetSize().GetHeight();\n+\tm_staticTextMessage1->SetLabel(strMessage1);\n+\tm_textCtrl1->SetValue(strValue1);\n+\ty += wxString(strMessage1).Freq('\\n') * 14;\n+\tif (!strMessage2.empty())\n+\t{\n+\t    m_staticTextMessage2->Show(true);\n+\t    m_staticTextMessage2->SetLabel(strMessage2);\n+\t    m_textCtrl2->Show(true);\n+\t    m_textCtrl2->SetValue(strValue2);\n+\t    y += 46 + wxString(strMessage2).Freq('\\n') * 14;\n+\t}\n #ifndef __WXMSW__\n-        x = x * 114 / 100;\n-        y = y * 114 / 100;\n+\tx = x * 114 / 100;\n+\ty = y * 114 / 100;\n #endif\n-        SetSize(x, y);\n+\tSetSize(x, y);\n     }\n \n     // Custom\n@@ -330,7 +330,7 @@ class CMyTaskBarIcon : public wxTaskBarIcon\n public:\n     CMyTaskBarIcon() : wxTaskBarIcon()\n     {\n-        Show(true);\n+\tShow(true);\n     }\n \n     void Show(bool fShow=true);"
      },
      {
        "sha": "7aaca3f028abb739693cc29b4a8612ce5d3a15f7",
        "filename": "src/uibase.cpp",
        "status": "modified",
        "additions": 253,
        "deletions": 253,
        "changes": 506,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/uibase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/uibase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uibase.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -18,155 +18,155 @@ CMainFrameBase::CMainFrameBase( wxWindow* parent, wxWindowID id, const wxString&\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n \tthis->SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_BTNFACE ) );\n-\t\n+\n \tm_menubar = new wxMenuBar( 0 );\n \tm_menuFile = new wxMenu();\n \twxMenuItem* m_menuFileExit;\n \tm_menuFileExit = new wxMenuItem( m_menuFile, wxID_EXIT, wxString( _(\"E&xit\") ) , wxEmptyString, wxITEM_NORMAL );\n \tm_menuFile->Append( m_menuFileExit );\n-\t\n+\n \tm_menubar->Append( m_menuFile, _(\"&File\") );\n-\t\n+\n \tm_menuOptions = new wxMenu();\n \twxMenuItem* m_menuOptionsChangeYourAddress;\n \tm_menuOptionsChangeYourAddress = new wxMenuItem( m_menuOptions, wxID_ANY, wxString( _(\"&Your Receiving Addresses...\") ) , wxEmptyString, wxITEM_NORMAL );\n \tm_menuOptions->Append( m_menuOptionsChangeYourAddress );\n-\t\n+\n \twxMenuItem* m_menuOptionsOptions;\n \tm_menuOptionsOptions = new wxMenuItem( m_menuOptions, wxID_PREFERENCES, wxString( _(\"&Options...\") ) , wxEmptyString, wxITEM_NORMAL );\n \tm_menuOptions->Append( m_menuOptionsOptions );\n-\t\n+\n \tm_menubar->Append( m_menuOptions, _(\"&Settings\") );\n-\t\n+\n \tm_menuHelp = new wxMenu();\n \twxMenuItem* m_menuHelpAbout;\n \tm_menuHelpAbout = new wxMenuItem( m_menuHelp, wxID_ABOUT, wxString( _(\"&About...\") ) , wxEmptyString, wxITEM_NORMAL );\n \tm_menuHelp->Append( m_menuHelpAbout );\n-\t\n+\n \tm_menubar->Append( m_menuHelp, _(\"&Help\") );\n-\t\n+\n \tthis->SetMenuBar( m_menubar );\n-\t\n+\n \tm_toolBar = this->CreateToolBar( wxTB_FLAT|wxTB_HORZ_TEXT, wxID_ANY );\n \tm_toolBar->SetToolBitmapSize( wxSize( 20,20 ) );\n \tm_toolBar->SetToolSeparation( 1 );\n \tm_toolBar->SetFont( wxFont( wxNORMAL_FONT->GetPointSize(), 70, 90, 90, false, wxEmptyString ) );\n-\t\n+\n \tm_toolBar->AddTool( wxID_BUTTONSEND, _(\"Send Coins\"), wxBitmap( send20_xpm ), wxNullBitmap, wxITEM_NORMAL, wxEmptyString, wxEmptyString );\n \tm_toolBar->AddTool( wxID_BUTTONRECEIVE, _(\"Address Book\"), wxBitmap( addressbook20_xpm ), wxNullBitmap, wxITEM_NORMAL, wxEmptyString, wxEmptyString );\n \tm_toolBar->Realize();\n-\t\n+\n \tm_statusBar = this->CreateStatusBar( 1, wxST_SIZEGRIP, wxID_ANY );\n \twxBoxSizer* bSizer2;\n \tbSizer2 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer2->Add( 0, 2, 0, wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer85;\n \tbSizer85 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_staticText32 = new wxStaticText( this, wxID_ANY, _(\"Your Bitcoin Address:\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText32->Wrap( -1 );\n \tbSizer85->Add( m_staticText32, 0, wxALIGN_CENTER_VERTICAL|wxLEFT, 5 );\n-\t\n+\n \tm_textCtrlAddress = new wxTextCtrl( this, wxID_TEXTCTRLADDRESS, wxEmptyString, wxDefaultPosition, wxSize( 340,-1 ), wxTE_READONLY );\n \tbSizer85->Add( m_textCtrlAddress, 0, wxALIGN_CENTER_VERTICAL|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \tm_buttonNew = new wxButton( this, wxID_BUTTONNEW, _(\" &New... \"), wxDefaultPosition, wxSize( -1,-1 ), wxBU_EXACTFIT );\n \tbSizer85->Add( m_buttonNew, 0, wxRIGHT|wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tm_buttonCopy = new wxButton( this, wxID_BUTTONCOPY, _(\" &Copy to Clipboard \"), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT );\n \tbSizer85->Add( m_buttonCopy, 0, wxALIGN_CENTER_VERTICAL|wxRIGHT, 5 );\n-\t\n-\t\n+\n+\n \tbSizer85->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \tbSizer2->Add( bSizer85, 0, wxEXPAND|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \twxBoxSizer* bSizer3;\n \tbSizer3 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \twxBoxSizer* bSizer66;\n \tbSizer66 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_staticText41 = new wxStaticText( this, wxID_ANY, _(\"Balance:\"), wxDefaultPosition, wxSize( -1,15 ), 0 );\n \tm_staticText41->Wrap( -1 );\n \tbSizer66->Add( m_staticText41, 0, wxALIGN_CENTER_VERTICAL|wxTOP|wxBOTTOM|wxLEFT, 5 );\n-\t\n+\n \tm_staticTextBalance = new wxStaticText( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxSize( 120,15 ), wxALIGN_RIGHT|wxST_NO_AUTORESIZE );\n \tm_staticTextBalance->Wrap( -1 );\n \tm_staticTextBalance->SetFont( wxFont( 8, 70, 90, 90, false, wxEmptyString ) );\n \tm_staticTextBalance->SetBackgroundColour( wxColour( 255, 255, 255 ) );\n-\t\n+\n \tbSizer66->Add( m_staticTextBalance, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5 );\n-\t\n+\n \tbSizer3->Add( bSizer66, 1, wxEXPAND|wxALL, 5 );\n-\t\n-\t\n+\n+\n \tbSizer3->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \twxString m_choiceFilterChoices[] = { _(\" All\"), _(\" Sent\"), _(\" Received\"), _(\" In Progress\") };\n \tint m_choiceFilterNChoices = sizeof( m_choiceFilterChoices ) / sizeof( wxString );\n \tm_choiceFilter = new wxChoice( this, wxID_ANY, wxDefaultPosition, wxSize( 110,-1 ), m_choiceFilterNChoices, m_choiceFilterChoices, 0 );\n \tm_choiceFilter->SetSelection( 0 );\n \tm_choiceFilter->Hide();\n-\t\n+\n \tbSizer3->Add( m_choiceFilter, 0, wxALIGN_BOTTOM|wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \tbSizer2->Add( bSizer3, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_notebook = new wxNotebook( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0 );\n \tm_panel9 = new wxPanel( m_notebook, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer11;\n \tbSizer11 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_listCtrlAll = new wxListCtrl( m_panel9, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_DESCENDING );\n \tbSizer11->Add( m_listCtrlAll, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_panel9->SetSizer( bSizer11 );\n \tm_panel9->Layout();\n \tbSizer11->Fit( m_panel9 );\n \tm_notebook->AddPage( m_panel9, _(\"All Transactions\"), true );\n \tm_panel91 = new wxPanel( m_notebook, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer111;\n \tbSizer111 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_listCtrlSentReceived = new wxListCtrl( m_panel91, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_DESCENDING );\n \tbSizer111->Add( m_listCtrlSentReceived, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_panel91->SetSizer( bSizer111 );\n \tm_panel91->Layout();\n \tbSizer111->Fit( m_panel91 );\n \tm_notebook->AddPage( m_panel91, _(\"Sent/Received\"), false );\n \tm_panel92 = new wxPanel( m_notebook, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer112;\n \tbSizer112 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_listCtrlSent = new wxListCtrl( m_panel92, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_DESCENDING );\n \tbSizer112->Add( m_listCtrlSent, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_panel92->SetSizer( bSizer112 );\n \tm_panel92->Layout();\n \tbSizer112->Fit( m_panel92 );\n \tm_notebook->AddPage( m_panel92, _(\"Sent\"), false );\n \tm_panel93 = new wxPanel( m_notebook, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer113;\n \tbSizer113 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_listCtrlReceived = new wxListCtrl( m_panel93, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_DESCENDING );\n \tbSizer113->Add( m_listCtrlReceived, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_panel93->SetSizer( bSizer113 );\n \tm_panel93->Layout();\n \tbSizer113->Fit( m_panel93 );\n \tm_notebook->AddPage( m_panel93, _(\"Received\"), false );\n-\t\n+\n \tbSizer2->Add( m_notebook, 1, wxEXPAND, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer2 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tthis->Connect( wxEVT_CLOSE_WINDOW, wxCloseEventHandler( CMainFrameBase::OnClose ) );\n \tthis->Connect( wxEVT_ICONIZE, wxIconizeEventHandler( CMainFrameBase::OnIconize ) );\n@@ -284,29 +284,29 @@ CMainFrameBase::~CMainFrameBase()\n CTxDetailsDialogBase::CTxDetailsDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer64;\n \tbSizer64 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \twxBoxSizer* bSizer66;\n \tbSizer66 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_htmlWin = new wxHtmlWindow( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxHW_SCROLLBAR_AUTO );\n \tbSizer66->Add( m_htmlWin, 1, wxALL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer64->Add( bSizer66, 1, wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer65;\n \tbSizer65 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_OK, _(\"OK\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer65->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer64->Add( bSizer65, 0, wxALIGN_RIGHT, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer64 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tm_buttonOK->Connect( wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler( CTxDetailsDialogBase::OnButtonOK ), NULL, this );\n }\n@@ -320,140 +320,140 @@ CTxDetailsDialogBase::~CTxDetailsDialogBase()\n COptionsDialogBase::COptionsDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer55;\n \tbSizer55 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \twxBoxSizer* bSizer66;\n \tbSizer66 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\tm_listBox = new wxListBox( this, wxID_ANY, wxDefaultPosition, wxSize( 110,-1 ), 0, NULL, wxLB_NEEDED_SB|wxLB_SINGLE ); \n+\n+\tm_listBox = new wxListBox( this, wxID_ANY, wxDefaultPosition, wxSize( 110,-1 ), 0, NULL, wxLB_NEEDED_SB|wxLB_SINGLE );\n \tbSizer66->Add( m_listBox, 0, wxEXPAND|wxRIGHT, 5 );\n-\t\n+\n \tm_scrolledWindow = new wxScrolledWindow( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0 );\n \tm_scrolledWindow->SetScrollRate( 5, 5 );\n \twxBoxSizer* bSizer63;\n \tbSizer63 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_panelMain = new wxPanel( m_scrolledWindow, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer69;\n \tbSizer69 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer69->Add( 0, 16, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_checkBoxStartOnSystemStartup = new wxCheckBox( m_panelMain, wxID_ANY, _(\"&Start Bitcoin on system startup\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_checkBoxStartOnSystemStartup, 0, wxALL, 5 );\n-\t\n+\n \tm_checkBoxMinimizeToTray = new wxCheckBox( m_panelMain, wxID_ANY, _(\"&Minimize to the tray instead of the taskbar\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_checkBoxMinimizeToTray, 0, wxALL, 5 );\n-\t\n+\n \tm_checkBoxUseUPnP = new wxCheckBox( m_panelMain, wxID_ANY, _(\"Map port using &UPnP\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_checkBoxUseUPnP, 0, wxALL, 5 );\n-\t\n+\n \tm_checkBoxMinimizeOnClose = new wxCheckBox( m_panelMain, wxID_ANY, _(\"M&inimize to the tray on close\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_checkBoxMinimizeOnClose, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \twxBoxSizer* bSizer102;\n \tbSizer102 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_checkBoxUseProxy = new wxCheckBox( m_panelMain, wxID_ANY, _(\"&Connect through socks4 proxy: \"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer102->Add( m_checkBoxUseProxy, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tbSizer69->Add( bSizer102, 1, wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer103;\n \tbSizer103 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer103->Add( 18, 0, 0, 0, 5 );\n-\t\n+\n \tm_staticTextProxyIP = new wxStaticText( m_panelMain, wxID_ANY, _(\"Proxy &IP:\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextProxyIP->Wrap( -1 );\n \tbSizer103->Add( m_staticTextProxyIP, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tm_textCtrlProxyIP = new wxTextCtrl( m_panelMain, wxID_PROXYIP, wxEmptyString, wxDefaultPosition, wxSize( 140,-1 ), 0 );\n-\tm_textCtrlProxyIP->SetMaxLength( 15 ); \n+\tm_textCtrlProxyIP->SetMaxLength( 15 );\n \tbSizer103->Add( m_textCtrlProxyIP, 0, wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tm_staticTextProxyPort = new wxStaticText( m_panelMain, wxID_ANY, _(\" &Port:\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextProxyPort->Wrap( -1 );\n \tbSizer103->Add( m_staticTextProxyPort, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tm_textCtrlProxyPort = new wxTextCtrl( m_panelMain, wxID_PROXYPORT, wxEmptyString, wxDefaultPosition, wxSize( 55,-1 ), 0 );\n-\tm_textCtrlProxyPort->SetMaxLength( 5 ); \n+\tm_textCtrlProxyPort->SetMaxLength( 5 );\n \tbSizer103->Add( m_textCtrlProxyPort, 0, wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tbSizer69->Add( bSizer103, 1, wxEXPAND, 5 );\n-\t\n-\t\n+\n+\n \tbSizer69->Add( 0, 1, 0, 0, 5 );\n-\t\n+\n \tm_staticText32 = new wxStaticText( m_panelMain, wxID_ANY, _(\"Optional transaction fee per KB that helps make sure your transactions are processed quickly.  Most transactions are 1KB.  Fee 0.01 recommended.\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText32->Wrap( 365 );\n \tbSizer69->Add( m_staticText32, 0, wxALIGN_CENTER_VERTICAL|wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \twxBoxSizer* bSizer56;\n \tbSizer56 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_staticText31 = new wxStaticText( m_panelMain, wxID_ANY, _(\"Pay transaction fee:\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText31->Wrap( -1 );\n \tbSizer56->Add( m_staticText31, 0, wxALIGN_CENTER_VERTICAL|wxTOP|wxBOTTOM|wxLEFT, 5 );\n-\t\n+\n \tm_textCtrlTransactionFee = new wxTextCtrl( m_panelMain, wxID_TRANSACTIONFEE, wxEmptyString, wxDefaultPosition, wxSize( 70,-1 ), 0 );\n \tbSizer56->Add( m_textCtrlTransactionFee, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5 );\n-\t\n+\n \tbSizer69->Add( bSizer56, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_panelMain->SetSizer( bSizer69 );\n \tm_panelMain->Layout();\n \tbSizer69->Fit( m_panelMain );\n \tbSizer63->Add( m_panelMain, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_panelTest2 = new wxPanel( m_scrolledWindow, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer64;\n \tbSizer64 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer64->Add( 0, 16, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_staticText321 = new wxStaticText( m_panelTest2, wxID_ANY, _(\"// [don't translate] Test panel 2 for future expansion\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText321->Wrap( -1 );\n \tbSizer64->Add( m_staticText321, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5 );\n-\t\n+\n \tm_staticText69 = new wxStaticText( m_panelTest2, wxID_ANY, _(\"// [don't translate] Let's not start multiple pages until the first page is filled up\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText69->Wrap( -1 );\n \tbSizer64->Add( m_staticText69, 0, wxALL, 5 );\n-\t\n+\n \tm_panelTest2->SetSizer( bSizer64 );\n \tm_panelTest2->Layout();\n \tbSizer64->Fit( m_panelTest2 );\n \tbSizer63->Add( m_panelTest2, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_scrolledWindow->SetSizer( bSizer63 );\n \tm_scrolledWindow->Layout();\n \tbSizer63->Fit( m_scrolledWindow );\n \tbSizer66->Add( m_scrolledWindow, 1, wxEXPAND|wxLEFT, 5 );\n-\t\n+\n \tbSizer55->Add( bSizer66, 1, wxEXPAND|wxALL, 9 );\n-\t\n+\n \twxBoxSizer* bSizer58;\n \tbSizer58 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_OK, _(\"OK\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer58->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCancel = new wxButton( this, wxID_CANCEL, _(\"Cancel\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer58->Add( m_buttonCancel, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonApply = new wxButton( this, wxID_APPLY, _(\"&Apply\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer58->Add( m_buttonApply, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer55->Add( bSizer58, 0, wxALIGN_RIGHT, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer55 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tm_listBox->Connect( wxEVT_COMMAND_LISTBOX_SELECTED, wxCommandEventHandler( COptionsDialogBase::OnListBox ), NULL, this );\n \tm_checkBoxMinimizeToTray->Connect( wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler( COptionsDialogBase::OnCheckBoxMinimizeToTray ), NULL, this );\n@@ -483,72 +483,72 @@ COptionsDialogBase::~COptionsDialogBase()\n CAboutDialogBase::CAboutDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer63;\n \tbSizer63 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_bitmap = new wxStaticBitmap( this, wxID_ANY, wxBitmap( about_xpm ), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer63->Add( m_bitmap, 0, 0, 5 );\n-\t\n+\n \twxBoxSizer* bSizer60;\n \tbSizer60 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \twxBoxSizer* bSizer62;\n \tbSizer62 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \twxBoxSizer* bSizer631;\n \tbSizer631 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer631->Add( 0, 65, 0, wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer64;\n \tbSizer64 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_staticText40 = new wxStaticText( this, wxID_ANY, _(\"Bitcoin \"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText40->Wrap( -1 );\n \tm_staticText40->SetFont( wxFont( 10, 74, 90, 92, false, wxT(\"Tahoma\") ) );\n-\t\n+\n \tbSizer64->Add( m_staticText40, 0, wxALIGN_BOTTOM|wxTOP|wxBOTTOM|wxLEFT, 5 );\n-\t\n+\n \tm_staticTextVersion = new wxStaticText( this, wxID_ANY, _(\"version\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextVersion->Wrap( -1 );\n \tm_staticTextVersion->SetFont( wxFont( 10, 74, 90, 90, false, wxT(\"Tahoma\") ) );\n-\t\n+\n \tbSizer64->Add( m_staticTextVersion, 0, wxALIGN_BOTTOM|wxTOP|wxBOTTOM|wxRIGHT, 5 );\n-\t\n+\n \tbSizer631->Add( bSizer64, 0, wxEXPAND, 5 );\n-\t\n-\t\n+\n+\n \tbSizer631->Add( 0, 4, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_staticTextMain = new wxStaticText( this, wxID_ANY, _(\"Copyright (c) 2009-2011 Bitcoin Developers\\n\\nThis is experimental software.\\n\\nDistributed under the MIT/X11 software license, see the accompanying file \\nlicense.txt or http://www.opensource.org/licenses/mit-license.php.\\n\\nThis product includes software developed by the OpenSSL Project for use in the \\nOpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by \\nEric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextMain->Wrap( -1 );\n \tbSizer631->Add( m_staticTextMain, 0, wxALL, 5 );\n-\t\n-\t\n+\n+\n \tbSizer631->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \tbSizer62->Add( bSizer631, 1, wxEXPAND, 5 );\n-\t\n+\n \tbSizer60->Add( bSizer62, 1, wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer61;\n \tbSizer61 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer61->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_OK, _(\"OK\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer61->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 6 );\n-\t\n+\n \tbSizer60->Add( bSizer61, 0, wxALIGN_RIGHT|wxEXPAND|wxRIGHT, 2 );\n-\t\n+\n \tbSizer63->Add( bSizer60, 1, wxEXPAND|wxLEFT, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer63 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tm_buttonOK->Connect( wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler( CAboutDialogBase::OnButtonOK ), NULL, this );\n }\n@@ -562,117 +562,117 @@ CAboutDialogBase::~CAboutDialogBase()\n CSendDialogBase::CSendDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer21;\n \tbSizer21 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer21->Add( 0, 5, 0, wxEXPAND, 5 );\n-\t\n+\n \twxFlexGridSizer* fgSizer1;\n \tfgSizer1 = new wxFlexGridSizer( 0, 2, 0, 0 );\n \tfgSizer1->AddGrowableCol( 1 );\n \tfgSizer1->SetFlexibleDirection( wxBOTH );\n \tfgSizer1->SetNonFlexibleGrowMode( wxFLEX_GROWMODE_SPECIFIED );\n-\t\n-\t\n+\n+\n \tfgSizer1->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_staticTextInstructions = new wxStaticText( this, wxID_ANY, _(\"Enter a Bitcoin address (e.g. 1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L)\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextInstructions->Wrap( -1 );\n \tfgSizer1->Add( m_staticTextInstructions, 0, wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \twxBoxSizer* bSizer47;\n \tbSizer47 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\tbSizer47->SetMinSize( wxSize( 70,-1 ) ); \n-\t\n+\n+\tbSizer47->SetMinSize( wxSize( 70,-1 ) );\n+\n \tbSizer47->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_bitmapCheckMark = new wxStaticBitmap( this, wxID_ANY, wxBitmap( check_xpm ), wxDefaultPosition, wxSize( 16,16 ), 0 );\n \tbSizer47->Add( m_bitmapCheckMark, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tm_staticText36 = new wxStaticText( this, wxID_ANY, _(\"Pay &To:\"), wxDefaultPosition, wxSize( -1,-1 ), wxALIGN_RIGHT );\n \tm_staticText36->Wrap( -1 );\n \tbSizer47->Add( m_staticText36, 0, wxALIGN_CENTER_VERTICAL|wxTOP|wxBOTTOM|wxLEFT, 5 );\n-\t\n+\n \tfgSizer1->Add( bSizer47, 1, wxEXPAND|wxLEFT, 5 );\n-\t\n+\n \twxBoxSizer* bSizer19;\n \tbSizer19 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_textCtrlAddress = new wxTextCtrl( this, wxID_TEXTCTRLPAYTO, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer19->Add( m_textCtrlAddress, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5 );\n-\t\n+\n \twxBoxSizer* bSizer66;\n \tbSizer66 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tm_buttonPaste = new wxButton( this, wxID_BUTTONPASTE, _(\"&Paste\"), wxDefaultPosition, wxSize( -1,-1 ), wxBU_EXACTFIT );\n \tbSizer66->Add( m_buttonPaste, 0, wxALIGN_CENTER_VERTICAL|wxRIGHT|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonAddress = new wxButton( this, wxID_BUTTONADDRESSBOOK, _(\" Address &Book...\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer66->Add( m_buttonAddress, 0, wxALIGN_CENTER_VERTICAL|wxRIGHT|wxEXPAND, 5 );\n-\t\n+\n \tbSizer19->Add( bSizer66, 0, wxALIGN_CENTER_VERTICAL, 5 );\n-\t\n+\n \tfgSizer1->Add( bSizer19, 1, wxEXPAND|wxRIGHT, 5 );\n-\t\n+\n \tm_staticText19 = new wxStaticText( this, wxID_ANY, _(\"&Amount:\"), wxDefaultPosition, wxSize( -1,-1 ), wxALIGN_RIGHT );\n \tm_staticText19->Wrap( -1 );\n \tfgSizer1->Add( m_staticText19, 0, wxALIGN_CENTER_VERTICAL|wxTOP|wxBOTTOM|wxLEFT|wxALIGN_RIGHT, 5 );\n-\t\n+\n \tm_textCtrlAmount = new wxTextCtrl( this, wxID_TEXTCTRLAMOUNT, wxEmptyString, wxDefaultPosition, wxSize( 145,-1 ), 0 );\n-\tm_textCtrlAmount->SetMaxLength( 20 ); \n+\tm_textCtrlAmount->SetMaxLength( 20 );\n \tm_textCtrlAmount->SetFont( wxFont( wxNORMAL_FONT->GetPointSize(), 70, 90, 90, false, wxEmptyString ) );\n-\t\n+\n \tfgSizer1->Add( m_textCtrlAmount, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5 );\n-\t\n+\n \tm_staticText20 = new wxStaticText( this, wxID_ANY, _(\"T&ransfer:\"), wxDefaultPosition, wxSize( -1,-1 ), wxALIGN_RIGHT );\n \tm_staticText20->Wrap( -1 );\n \tm_staticText20->Hide();\n-\t\n+\n \tfgSizer1->Add( m_staticText20, 0, wxALIGN_CENTER_VERTICAL|wxALIGN_RIGHT|wxTOP|wxBOTTOM|wxLEFT, 5 );\n-\t\n+\n \twxString m_choiceTransferTypeChoices[] = { _(\" Standard\") };\n \tint m_choiceTransferTypeNChoices = sizeof( m_choiceTransferTypeChoices ) / sizeof( wxString );\n \tm_choiceTransferType = new wxChoice( this, wxID_CHOICETRANSFERTYPE, wxDefaultPosition, wxDefaultSize, m_choiceTransferTypeNChoices, m_choiceTransferTypeChoices, 0 );\n \tm_choiceTransferType->SetSelection( 0 );\n \tm_choiceTransferType->Hide();\n-\t\n+\n \tfgSizer1->Add( m_choiceTransferType, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5 );\n-\t\n-\t\n+\n+\n \tfgSizer1->Add( 0, 3, 0, wxEXPAND, 5 );\n-\t\n-\t\n+\n+\n \tfgSizer1->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \tbSizer21->Add( fgSizer1, 0, wxEXPAND|wxLEFT, 5 );\n-\t\n+\n \twxBoxSizer* bSizer672;\n \tbSizer672 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n+\n \tbSizer21->Add( bSizer672, 0, wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer23;\n \tbSizer23 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer23->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_buttonSend = new wxButton( this, wxID_BUTTONSEND, _(\"&Send\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tm_buttonSend->SetFont( wxFont( wxNORMAL_FONT->GetPointSize(), 70, 90, 90, false, wxEmptyString ) );\n-\t\n+\n \tbSizer23->Add( m_buttonSend, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCancel = new wxButton( this, wxID_CANCEL, _(\"Cancel\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer23->Add( m_buttonCancel, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer21->Add( bSizer23, 0, wxEXPAND, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer21 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tm_textCtrlAddress->Connect( wxEVT_KEY_DOWN, wxKeyEventHandler( CSendDialogBase::OnKeyDown ), NULL, this );\n \tm_textCtrlAddress->Connect( wxEVT_COMMAND_TEXT_UPDATED, wxCommandEventHandler( CSendDialogBase::OnTextAddress ), NULL, this );\n@@ -700,38 +700,38 @@ CSendDialogBase::~CSendDialogBase()\n CSendingDialogBase::CSendingDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer68;\n \tbSizer68 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_staticTextSending = new wxStaticText( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxSize( -1,14 ), 0 );\n \tm_staticTextSending->Wrap( -1 );\n \tbSizer68->Add( m_staticTextSending, 0, wxALIGN_CENTER_VERTICAL|wxEXPAND|wxTOP|wxRIGHT|wxLEFT, 8 );\n-\t\n+\n \tm_textCtrlStatus = new wxTextCtrl( this, wxID_ANY, _(\"\\n\\nConnecting...\"), wxDefaultPosition, wxDefaultSize, wxTE_CENTRE|wxTE_MULTILINE|wxTE_NO_VSCROLL|wxTE_READONLY|wxNO_BORDER );\n \tm_textCtrlStatus->SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_BTNFACE ) );\n-\t\n+\n \tbSizer68->Add( m_textCtrlStatus, 1, wxEXPAND|wxRIGHT|wxLEFT, 10 );\n-\t\n+\n \twxBoxSizer* bSizer69;\n \tbSizer69 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer69->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_ANY, _(\"OK\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_buttonOK->Enable( false );\n-\t\n+\n \tbSizer69->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCancel = new wxButton( this, wxID_CANCEL, _(\"Cancel\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer69->Add( m_buttonCancel, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer68->Add( bSizer69, 0, wxEXPAND, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer68 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tthis->Connect( wxEVT_CLOSE_WINDOW, wxCloseEventHandler( CSendingDialogBase::OnClose ) );\n \tthis->Connect( wxEVT_PAINT, wxPaintEventHandler( CSendingDialogBase::OnPaint ) );\n@@ -751,48 +751,48 @@ CSendingDialogBase::~CSendingDialogBase()\n CYourAddressDialogBase::CYourAddressDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer68;\n \tbSizer68 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer68->Add( 0, 5, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_staticText45 = new wxStaticText( this, wxID_ANY, _(\"These are your Bitcoin addresses for receiving payments.  You may want to give a different one to each sender so you can keep track of who is paying you.  The highlighted address is displayed in the main window.\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText45->Wrap( 590 );\n \tbSizer68->Add( m_staticText45, 0, wxALL, 5 );\n-\t\n+\n \tm_listCtrl = new wxListCtrl( this, wxID_LISTCTRL, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_ASCENDING );\n \tbSizer68->Add( m_listCtrl, 1, wxALL|wxEXPAND, 5 );\n-\t\n+\n \twxBoxSizer* bSizer69;\n \tbSizer69 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer69->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_buttonRename = new wxButton( this, wxID_BUTTONRENAME, _(\"&Edit...\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_buttonRename, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonNew = new wxButton( this, wxID_BUTTONNEW, _(\" &New Address... \"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer69->Add( m_buttonNew, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCopy = new wxButton( this, wxID_BUTTONCOPY, _(\" &Copy to Clipboard \"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer69->Add( m_buttonCopy, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_OK, _(\"OK\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCancel = new wxButton( this, wxID_CANCEL, _(\"Cancel\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tm_buttonCancel->Hide();\n-\t\n+\n \tbSizer69->Add( m_buttonCancel, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer68->Add( bSizer69, 0, wxEXPAND, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer68 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tthis->Connect( wxEVT_CLOSE_WINDOW, wxCloseEventHandler( CYourAddressDialogBase::OnClose ) );\n \tm_listCtrl->Connect( wxEVT_COMMAND_LIST_END_LABEL_EDIT, wxListEventHandler( CYourAddressDialogBase::OnListEndLabelEdit ), NULL, this );\n@@ -822,84 +822,84 @@ CYourAddressDialogBase::~CYourAddressDialogBase()\n CAddressBookDialogBase::CAddressBookDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer58;\n \tbSizer58 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \tm_notebook = new wxNotebook( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0 );\n \tm_panelSending = new wxPanel( m_notebook, wxID_PANELSENDING, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer68;\n \tbSizer68 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer68->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_staticText55 = new wxStaticText( m_panelSending, wxID_ANY, _(\"Bitcoin Address\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText55->Wrap( -1 );\n \tm_staticText55->Hide();\n-\t\n+\n \tbSizer68->Add( m_staticText55, 0, wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \tm_listCtrlSending = new wxListCtrl( m_panelSending, wxID_LISTCTRLSENDING, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_ASCENDING );\n \tbSizer68->Add( m_listCtrlSending, 1, wxALL|wxEXPAND, 5 );\n-\t\n+\n \tm_panelSending->SetSizer( bSizer68 );\n \tm_panelSending->Layout();\n \tbSizer68->Fit( m_panelSending );\n \tm_notebook->AddPage( m_panelSending, _(\"Sending\"), false );\n \tm_panelReceiving = new wxPanel( m_notebook, wxID_PANELRECEIVING, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );\n \twxBoxSizer* bSizer681;\n \tbSizer681 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer681->Add( 0, 0, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_staticText45 = new wxStaticText( m_panelReceiving, wxID_ANY, _(\"These are your Bitcoin addresses for receiving payments.  You can give a different one to each sender to keep track of who is paying you.  The highlighted address will be displayed in the main window.\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticText45->Wrap( 570 );\n \tbSizer681->Add( m_staticText45, 0, wxTOP|wxRIGHT|wxLEFT, 6 );\n-\t\n-\t\n+\n+\n \tbSizer681->Add( 0, 2, 0, wxEXPAND, 5 );\n-\t\n+\n \tm_listCtrlReceiving = new wxListCtrl( m_panelReceiving, wxID_LISTCTRLRECEIVING, wxDefaultPosition, wxDefaultSize, wxLC_NO_SORT_HEADER|wxLC_REPORT|wxLC_SORT_ASCENDING );\n \tbSizer681->Add( m_listCtrlReceiving, 1, wxALL|wxEXPAND, 5 );\n-\t\n+\n \tm_panelReceiving->SetSizer( bSizer681 );\n \tm_panelReceiving->Layout();\n \tbSizer681->Fit( m_panelReceiving );\n \tm_notebook->AddPage( m_panelReceiving, _(\"Receiving\"), true );\n-\t\n+\n \tbSizer58->Add( m_notebook, 1, wxEXPAND|wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \twxBoxSizer* bSizer69;\n \tbSizer69 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer69->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_buttonDelete = new wxButton( this, wxID_BUTTONDELETE, _(\"&Delete\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_buttonDelete, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCopy = new wxButton( this, wxID_BUTTONCOPY, _(\" &Copy to Clipboard \"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer69->Add( m_buttonCopy, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonEdit = new wxButton( this, wxID_BUTTONEDIT, _(\"&Edit...\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_buttonEdit, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonNew = new wxButton( this, wxID_BUTTONNEW, _(\" &New Address... \"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer69->Add( m_buttonNew, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_OK, _(\"OK\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer69->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCancel = new wxButton( this, wxID_CANCEL, _(\"Cancel\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer69->Add( m_buttonCancel, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer58->Add( bSizer69, 0, wxEXPAND, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer58 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tthis->Connect( wxEVT_CLOSE_WINDOW, wxCloseEventHandler( CAddressBookDialogBase::OnClose ) );\n \tm_notebook->Connect( wxEVT_COMMAND_NOTEBOOK_PAGE_CHANGED, wxNotebookEventHandler( CAddressBookDialogBase::OnNotebookPageChanged ), NULL, this );\n@@ -939,56 +939,56 @@ CAddressBookDialogBase::~CAddressBookDialogBase()\n CGetTextFromUserDialogBase::CGetTextFromUserDialogBase( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )\n {\n \tthis->SetSizeHints( wxDefaultSize, wxDefaultSize );\n-\t\n+\n \twxBoxSizer* bSizer79;\n \tbSizer79 = new wxBoxSizer( wxVERTICAL );\n-\t\n+\n \twxBoxSizer* bSizer81;\n \tbSizer81 = new wxBoxSizer( wxVERTICAL );\n-\t\n-\t\n+\n+\n \tbSizer81->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_staticTextMessage1 = new wxStaticText( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextMessage1->Wrap( -1 );\n \tbSizer81->Add( m_staticTextMessage1, 0, wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \tm_textCtrl1 = new wxTextCtrl( this, wxID_TEXTCTRL, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER );\n \tbSizer81->Add( m_textCtrl1, 0, wxALL|wxEXPAND|wxALIGN_CENTER_HORIZONTAL, 5 );\n-\t\n+\n \tm_staticTextMessage2 = new wxStaticText( this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0 );\n \tm_staticTextMessage2->Wrap( -1 );\n \tm_staticTextMessage2->Hide();\n-\t\n+\n \tbSizer81->Add( m_staticTextMessage2, 0, wxTOP|wxRIGHT|wxLEFT, 5 );\n-\t\n+\n \tm_textCtrl2 = new wxTextCtrl( this, wxID_TEXTCTRL, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER );\n \tm_textCtrl2->Hide();\n-\t\n+\n \tbSizer81->Add( m_textCtrl2, 0, wxALL|wxEXPAND|wxALIGN_CENTER_HORIZONTAL, 5 );\n-\t\n-\t\n+\n+\n \tbSizer81->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tbSizer79->Add( bSizer81, 1, wxEXPAND|wxALL, 10 );\n-\t\n+\n \twxBoxSizer* bSizer80;\n \tbSizer80 = new wxBoxSizer( wxHORIZONTAL );\n-\t\n-\t\n+\n+\n \tbSizer80->Add( 0, 0, 1, wxEXPAND, 5 );\n-\t\n+\n \tm_buttonOK = new wxButton( this, wxID_OK, _(\"OK\"), wxDefaultPosition, wxSize( -1,-1 ), 0 );\n \tbSizer80->Add( m_buttonOK, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tm_buttonCancel = new wxButton( this, wxID_CANCEL, _(\"Cancel\"), wxDefaultPosition, wxDefaultSize, 0 );\n \tbSizer80->Add( m_buttonCancel, 0, wxALL|wxALIGN_CENTER_VERTICAL|wxEXPAND, 5 );\n-\t\n+\n \tbSizer79->Add( bSizer80, 0, wxEXPAND, 5 );\n-\t\n+\n \tthis->SetSizer( bSizer79 );\n \tthis->Layout();\n-\t\n+\n \t// Connect Events\n \tthis->Connect( wxEVT_CLOSE_WINDOW, wxCloseEventHandler( CGetTextFromUserDialogBase::OnClose ) );\n \tm_textCtrl1->Connect( wxEVT_KEY_DOWN, wxKeyEventHandler( CGetTextFromUserDialogBase::OnKeyDown ), NULL, this );"
      },
      {
        "sha": "f54ab57e9f799f7fe75eb6b8d04341447058c511",
        "filename": "src/uibase.h",
        "status": "modified",
        "additions": 90,
        "deletions": 90,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/uibase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/uibase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uibase.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -66,30 +66,30 @@\n ///////////////////////////////////////////////////////////////////////////////\n /// Class CMainFrameBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CMainFrameBase : public wxFrame \n+class CMainFrameBase : public wxFrame\n {\n \tprivate:\n-\t\n+\n \tprotected:\n \t\twxMenuBar* m_menubar;\n \t\twxMenu* m_menuFile;\n \t\twxMenu* m_menuHelp;\n \t\twxToolBar* m_toolBar;\n-\t\t\n+\n \t\twxStaticText* m_staticText32;\n \t\twxButton* m_buttonNew;\n \t\twxButton* m_buttonCopy;\n-\t\t\n+\n \t\twxStaticText* m_staticText41;\n \t\twxStaticText* m_staticTextBalance;\n-\t\t\n+\n \t\twxChoice* m_choiceFilter;\n \t\twxNotebook* m_notebook;\n \t\twxPanel* m_panel9;\n \t\twxPanel* m_panel91;\n \t\twxPanel* m_panel92;\n \t\twxPanel* m_panel93;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n \t\tvirtual void OnIconize( wxIconizeEvent& event ) { event.Skip(); }\n@@ -111,8 +111,8 @@ class CMainFrameBase : public wxFrame\n \t\tvirtual void OnListColBeginDrag( wxListEvent& event ) { event.Skip(); }\n \t\tvirtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n \t\tvirtual void OnPaintListCtrl( wxPaintEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n \t\twxMenu* m_menuOptions;\n \t\twxStatusBar* m_statusBar;\n@@ -121,68 +121,68 @@ class CMainFrameBase : public wxFrame\n \t\twxListCtrl* m_listCtrlSentReceived;\n \t\twxListCtrl* m_listCtrlSent;\n \t\twxListCtrl* m_listCtrlReceived;\n-\t\t\n+\n \t\tCMainFrameBase( wxWindow* parent, wxWindowID id = wxID_MAINFRAME, const wxString& title = _(\"Bitcoin\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 723,484 ), long style = wxDEFAULT_FRAME_STYLE|wxRESIZE_BORDER|wxTAB_TRAVERSAL );\n \t\t~CMainFrameBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CTxDetailsDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CTxDetailsDialogBase : public wxDialog \n+class CTxDetailsDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n \t\twxHtmlWindow* m_htmlWin;\n \t\twxButton* m_buttonOK;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n-\t\t\n+\n \t\tCTxDetailsDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Transaction Details\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 620,450 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n \t\t~CTxDetailsDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class COptionsDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class COptionsDialogBase : public wxDialog \n+class COptionsDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n \t\twxListBox* m_listBox;\n \t\twxScrolledWindow* m_scrolledWindow;\n \t\twxPanel* m_panelMain;\n-\t\t\n+\n \t\twxCheckBox* m_checkBoxStartOnSystemStartup;\n \t\twxCheckBox* m_checkBoxMinimizeToTray;\n \t\twxCheckBox* m_checkBoxUseUPnP;\n \t\twxCheckBox* m_checkBoxMinimizeOnClose;\n \t\twxCheckBox* m_checkBoxUseProxy;\n-\t\t\n+\n \t\twxStaticText* m_staticTextProxyIP;\n \t\twxTextCtrl* m_textCtrlProxyIP;\n \t\twxStaticText* m_staticTextProxyPort;\n \t\twxTextCtrl* m_textCtrlProxyPort;\n-\t\t\n+\n \t\twxStaticText* m_staticText32;\n \t\twxStaticText* m_staticText31;\n \t\twxTextCtrl* m_textCtrlTransactionFee;\n \t\twxPanel* m_panelTest2;\n-\t\t\n+\n \t\twxStaticText* m_staticText321;\n \t\twxStaticText* m_staticText69;\n \t\twxButton* m_buttonOK;\n \t\twxButton* m_buttonCancel;\n \t\twxButton* m_buttonApply;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnListBox( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnCheckBoxMinimizeToTray( wxCommandEvent& event ) { event.Skip(); }\n@@ -192,56 +192,56 @@ class COptionsDialogBase : public wxDialog\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonApply( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n-\t\t\n+\n \t\tCOptionsDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Options\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 540,360 ), long style = wxDEFAULT_DIALOG_STYLE );\n \t\t~COptionsDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CAboutDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CAboutDialogBase : public wxDialog \n+class CAboutDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n \t\twxStaticBitmap* m_bitmap;\n-\t\t\n+\n \t\twxStaticText* m_staticText40;\n-\t\t\n+\n \t\twxStaticText* m_staticTextMain;\n-\t\t\n-\t\t\n+\n+\n \t\twxButton* m_buttonOK;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n \t\twxStaticText* m_staticTextVersion;\n-\t\t\n+\n \t\tCAboutDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"About Bitcoin\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 532,333 ), long style = wxDEFAULT_DIALOG_STYLE );\n \t\t~CAboutDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CSendDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CSendDialogBase : public wxDialog \n+class CSendDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n-\t\t\n-\t\t\n+\n+\n \t\twxStaticText* m_staticTextInstructions;\n-\t\t\n+\n \t\twxStaticBitmap* m_bitmapCheckMark;\n \t\twxStaticText* m_staticText36;\n \t\twxTextCtrl* m_textCtrlAddress;\n@@ -251,12 +251,12 @@ class CSendDialogBase : public wxDialog\n \t\twxTextCtrl* m_textCtrlAmount;\n \t\twxStaticText* m_staticText20;\n \t\twxChoice* m_choiceTransferType;\n-\t\t\n-\t\t\n-\t\t\n+\n+\n+\n \t\twxButton* m_buttonSend;\n \t\twxButton* m_buttonCancel;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n \t\tvirtual void OnTextAddress( wxCommandEvent& event ) { event.Skip(); }\n@@ -265,61 +265,61 @@ class CSendDialogBase : public wxDialog\n \t\tvirtual void OnKillFocusAmount( wxFocusEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonSend( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n-\t\t\n+\n \t\tCSendDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Send Coins\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 498,157 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n \t\t~CSendDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CSendingDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CSendingDialogBase : public wxDialog \n+class CSendingDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n \t\twxStaticText* m_staticTextSending;\n \t\twxTextCtrl* m_textCtrlStatus;\n-\t\t\n+\n \t\twxButton* m_buttonOK;\n \t\twxButton* m_buttonCancel;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n \t\tvirtual void OnPaint( wxPaintEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n-\t\t\n+\n \t\tCSendingDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Sending...\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 442,151 ), long style = wxDEFAULT_DIALOG_STYLE );\n \t\t~CSendingDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CYourAddressDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CYourAddressDialogBase : public wxDialog \n+class CYourAddressDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n-\t\t\n+\n \t\twxStaticText* m_staticText45;\n \t\twxListCtrl* m_listCtrl;\n-\t\t\n+\n \t\twxButton* m_buttonRename;\n \t\twxButton* m_buttonNew;\n \t\twxButton* m_buttonCopy;\n \t\twxButton* m_buttonOK;\n \t\twxButton* m_buttonCancel;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n \t\tvirtual void OnListEndLabelEdit( wxListEvent& event ) { event.Skip(); }\n@@ -330,40 +330,40 @@ class CYourAddressDialogBase : public wxDialog\n \t\tvirtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n-\t\t\n+\n \t\tCYourAddressDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Your Bitcoin Addresses\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 610,390 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n \t\t~CYourAddressDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CAddressBookDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CAddressBookDialogBase : public wxDialog \n+class CAddressBookDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n \t\twxNotebook* m_notebook;\n \t\twxPanel* m_panelSending;\n-\t\t\n+\n \t\twxStaticText* m_staticText55;\n \t\twxListCtrl* m_listCtrlSending;\n \t\twxPanel* m_panelReceiving;\n-\t\t\n+\n \t\twxStaticText* m_staticText45;\n-\t\t\n+\n \t\twxListCtrl* m_listCtrlReceiving;\n-\t\t\n+\n \t\twxButton* m_buttonDelete;\n \t\twxButton* m_buttonCopy;\n \t\twxButton* m_buttonEdit;\n \t\twxButton* m_buttonNew;\n \t\twxButton* m_buttonOK;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n \t\tvirtual void OnNotebookPageChanged( wxNotebookEvent& event ) { event.Skip(); }\n@@ -376,46 +376,46 @@ class CAddressBookDialogBase : public wxDialog\n \t\tvirtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n \t\twxButton* m_buttonCancel;\n-\t\t\n+\n \t\tCAddressBookDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Address Book\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 610,390 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n \t\t~CAddressBookDialogBase();\n-\t\n+\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n /// Class CGetTextFromUserDialogBase\n ///////////////////////////////////////////////////////////////////////////////\n-class CGetTextFromUserDialogBase : public wxDialog \n+class CGetTextFromUserDialogBase : public wxDialog\n {\n \tprivate:\n-\t\n+\n \tprotected:\n-\t\t\n+\n \t\twxStaticText* m_staticTextMessage1;\n \t\twxTextCtrl* m_textCtrl1;\n \t\twxStaticText* m_staticTextMessage2;\n \t\twxTextCtrl* m_textCtrl2;\n-\t\t\n-\t\t\n+\n+\n \t\twxButton* m_buttonOK;\n \t\twxButton* m_buttonCancel;\n-\t\t\n+\n \t\t// Virtual event handlers, overide them in your derived class\n \t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n \t\tvirtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n-\t\t\n-\t\n+\n+\n \tpublic:\n-\t\t\n+\n \t\tCGetTextFromUserDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = wxEmptyString, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 440,138 ), long style = wxDEFAULT_DIALOG_STYLE );\n \t\t~CGetTextFromUserDialogBase();\n-\t\n+\n };\n \n #endif //__uibase__"
      },
      {
        "sha": "91a5785c89c1415affa4f5475c942dd4e9e8cb1d",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 235,
        "deletions": 235,
        "changes": 470,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -32,346 +32,346 @@ class base_uint\n \n     bool operator!() const\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            if (pn[i] != 0)\n-                return false;\n-        return true;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    if (pn[i] != 0)\n+\t\treturn false;\n+\treturn true;\n     }\n \n     const base_uint operator~() const\n     {\n-        base_uint ret;\n-        for (int i = 0; i < WIDTH; i++)\n-            ret.pn[i] = ~pn[i];\n-        return ret;\n+\tbase_uint ret;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    ret.pn[i] = ~pn[i];\n+\treturn ret;\n     }\n \n     const base_uint operator-() const\n     {\n-        base_uint ret;\n-        for (int i = 0; i < WIDTH; i++)\n-            ret.pn[i] = ~pn[i];\n-        ret++;\n-        return ret;\n+\tbase_uint ret;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    ret.pn[i] = ~pn[i];\n+\tret++;\n+\treturn ret;\n     }\n \n \n     base_uint& operator=(uint64 b)\n     {\n-        pn[0] = (unsigned int)b;\n-        pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n-            pn[i] = 0;\n-        return *this;\n+\tpn[0] = (unsigned int)b;\n+\tpn[1] = (unsigned int)(b >> 32);\n+\tfor (int i = 2; i < WIDTH; i++)\n+\t    pn[i] = 0;\n+\treturn *this;\n     }\n \n     base_uint& operator^=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] ^= b.pn[i];\n-        return *this;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] ^= b.pn[i];\n+\treturn *this;\n     }\n \n     base_uint& operator&=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] &= b.pn[i];\n-        return *this;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] &= b.pn[i];\n+\treturn *this;\n     }\n \n     base_uint& operator|=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] |= b.pn[i];\n-        return *this;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] |= b.pn[i];\n+\treturn *this;\n     }\n \n     base_uint& operator^=(uint64 b)\n     {\n-        pn[0] ^= (unsigned int)b;\n-        pn[1] ^= (unsigned int)(b >> 32);\n-        return *this;\n+\tpn[0] ^= (unsigned int)b;\n+\tpn[1] ^= (unsigned int)(b >> 32);\n+\treturn *this;\n     }\n \n     base_uint& operator&=(uint64 b)\n     {\n-        pn[0] &= (unsigned int)b;\n-        pn[1] &= (unsigned int)(b >> 32);\n-        return *this;\n+\tpn[0] &= (unsigned int)b;\n+\tpn[1] &= (unsigned int)(b >> 32);\n+\treturn *this;\n     }\n \n     base_uint& operator|=(uint64 b)\n     {\n-        pn[0] |= (unsigned int)b;\n-        pn[1] |= (unsigned int)(b >> 32);\n-        return *this;\n+\tpn[0] |= (unsigned int)b;\n+\tpn[1] |= (unsigned int)(b >> 32);\n+\treturn *this;\n     }\n \n     base_uint& operator<<=(unsigned int shift)\n     {\n-        base_uint a(*this);\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n-        int k = shift / 32;\n-        shift = shift % 32;\n-        for (int i = 0; i < WIDTH; i++)\n-        {\n-            if (i+k+1 < WIDTH && shift != 0)\n-                pn[i+k+1] |= (a.pn[i] >> (32-shift));\n-            if (i+k < WIDTH)\n-                pn[i+k] |= (a.pn[i] << shift);\n-        }\n-        return *this;\n+\tbase_uint a(*this);\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = 0;\n+\tint k = shift / 32;\n+\tshift = shift % 32;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t{\n+\t    if (i+k+1 < WIDTH && shift != 0)\n+\t\tpn[i+k+1] |= (a.pn[i] >> (32-shift));\n+\t    if (i+k < WIDTH)\n+\t\tpn[i+k] |= (a.pn[i] << shift);\n+\t}\n+\treturn *this;\n     }\n \n     base_uint& operator>>=(unsigned int shift)\n     {\n-        base_uint a(*this);\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n-        int k = shift / 32;\n-        shift = shift % 32;\n-        for (int i = 0; i < WIDTH; i++)\n-        {\n-            if (i-k-1 >= 0 && shift != 0)\n-                pn[i-k-1] |= (a.pn[i] << (32-shift));\n-            if (i-k >= 0)\n-                pn[i-k] |= (a.pn[i] >> shift);\n-        }\n-        return *this;\n+\tbase_uint a(*this);\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = 0;\n+\tint k = shift / 32;\n+\tshift = shift % 32;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t{\n+\t    if (i-k-1 >= 0 && shift != 0)\n+\t\tpn[i-k-1] |= (a.pn[i] << (32-shift));\n+\t    if (i-k >= 0)\n+\t\tpn[i-k] |= (a.pn[i] >> shift);\n+\t}\n+\treturn *this;\n     }\n \n     base_uint& operator+=(const base_uint& b)\n     {\n-        uint64 carry = 0;\n-        for (int i = 0; i < WIDTH; i++)\n-        {\n-            uint64 n = carry + pn[i] + b.pn[i];\n-            pn[i] = n & 0xffffffff;\n-            carry = n >> 32;\n-        }\n-        return *this;\n+\tuint64 carry = 0;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t{\n+\t    uint64 n = carry + pn[i] + b.pn[i];\n+\t    pn[i] = n & 0xffffffff;\n+\t    carry = n >> 32;\n+\t}\n+\treturn *this;\n     }\n \n     base_uint& operator-=(const base_uint& b)\n     {\n-        *this += -b;\n-        return *this;\n+\t*this += -b;\n+\treturn *this;\n     }\n \n     base_uint& operator+=(uint64 b64)\n     {\n-        base_uint b;\n-        b = b64;\n-        *this += b;\n-        return *this;\n+\tbase_uint b;\n+\tb = b64;\n+\t*this += b;\n+\treturn *this;\n     }\n \n     base_uint& operator-=(uint64 b64)\n     {\n-        base_uint b;\n-        b = b64;\n-        *this += -b;\n-        return *this;\n+\tbase_uint b;\n+\tb = b64;\n+\t*this += -b;\n+\treturn *this;\n     }\n \n \n     base_uint& operator++()\n     {\n-        // prefix operator\n-        int i = 0;\n-        while (++pn[i] == 0 && i < WIDTH-1)\n-            i++;\n-        return *this;\n+\t// prefix operator\n+\tint i = 0;\n+\twhile (++pn[i] == 0 && i < WIDTH-1)\n+\t    i++;\n+\treturn *this;\n     }\n \n     const base_uint operator++(int)\n     {\n-        // postfix operator\n-        const base_uint ret = *this;\n-        ++(*this);\n-        return ret;\n+\t// postfix operator\n+\tconst base_uint ret = *this;\n+\t++(*this);\n+\treturn ret;\n     }\n \n     base_uint& operator--()\n     {\n-        // prefix operator\n-        int i = 0;\n-        while (--pn[i] == -1 && i < WIDTH-1)\n-            i++;\n-        return *this;\n+\t// prefix operator\n+\tint i = 0;\n+\twhile (--pn[i] == -1 && i < WIDTH-1)\n+\t    i++;\n+\treturn *this;\n     }\n \n     const base_uint operator--(int)\n     {\n-        // postfix operator\n-        const base_uint ret = *this;\n-        --(*this);\n-        return ret;\n+\t// postfix operator\n+\tconst base_uint ret = *this;\n+\t--(*this);\n+\treturn ret;\n     }\n \n \n     friend inline bool operator<(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n-        {\n-            if (a.pn[i] < b.pn[i])\n-                return true;\n-            else if (a.pn[i] > b.pn[i])\n-                return false;\n-        }\n-        return false;\n+\tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n+\t{\n+\t    if (a.pn[i] < b.pn[i])\n+\t\treturn true;\n+\t    else if (a.pn[i] > b.pn[i])\n+\t\treturn false;\n+\t}\n+\treturn false;\n     }\n \n     friend inline bool operator<=(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n-        {\n-            if (a.pn[i] < b.pn[i])\n-                return true;\n-            else if (a.pn[i] > b.pn[i])\n-                return false;\n-        }\n-        return true;\n+\tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n+\t{\n+\t    if (a.pn[i] < b.pn[i])\n+\t\treturn true;\n+\t    else if (a.pn[i] > b.pn[i])\n+\t\treturn false;\n+\t}\n+\treturn true;\n     }\n \n     friend inline bool operator>(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n-        {\n-            if (a.pn[i] > b.pn[i])\n-                return true;\n-            else if (a.pn[i] < b.pn[i])\n-                return false;\n-        }\n-        return false;\n+\tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n+\t{\n+\t    if (a.pn[i] > b.pn[i])\n+\t\treturn true;\n+\t    else if (a.pn[i] < b.pn[i])\n+\t\treturn false;\n+\t}\n+\treturn false;\n     }\n \n     friend inline bool operator>=(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n-        {\n-            if (a.pn[i] > b.pn[i])\n-                return true;\n-            else if (a.pn[i] < b.pn[i])\n-                return false;\n-        }\n-        return true;\n+\tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n+\t{\n+\t    if (a.pn[i] > b.pn[i])\n+\t\treturn true;\n+\t    else if (a.pn[i] < b.pn[i])\n+\t\treturn false;\n+\t}\n+\treturn true;\n     }\n \n     friend inline bool operator==(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = 0; i < base_uint::WIDTH; i++)\n-            if (a.pn[i] != b.pn[i])\n-                return false;\n-        return true;\n+\tfor (int i = 0; i < base_uint::WIDTH; i++)\n+\t    if (a.pn[i] != b.pn[i])\n+\t\treturn false;\n+\treturn true;\n     }\n \n     friend inline bool operator==(const base_uint& a, uint64 b)\n     {\n-        if (a.pn[0] != (unsigned int)b)\n-            return false;\n-        if (a.pn[1] != (unsigned int)(b >> 32))\n-            return false;\n-        for (int i = 2; i < base_uint::WIDTH; i++)\n-            if (a.pn[i] != 0)\n-                return false;\n-        return true;\n+\tif (a.pn[0] != (unsigned int)b)\n+\t    return false;\n+\tif (a.pn[1] != (unsigned int)(b >> 32))\n+\t    return false;\n+\tfor (int i = 2; i < base_uint::WIDTH; i++)\n+\t    if (a.pn[i] != 0)\n+\t\treturn false;\n+\treturn true;\n     }\n \n     friend inline bool operator!=(const base_uint& a, const base_uint& b)\n     {\n-        return (!(a == b));\n+\treturn (!(a == b));\n     }\n \n     friend inline bool operator!=(const base_uint& a, uint64 b)\n     {\n-        return (!(a == b));\n+\treturn (!(a == b));\n     }\n \n \n \n     std::string GetHex() const\n     {\n-        char psz[sizeof(pn)*2 + 1];\n-        for (int i = 0; i < sizeof(pn); i++)\n-            sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n-        return string(psz, psz + sizeof(pn)*2);\n+\tchar psz[sizeof(pn)*2 + 1];\n+\tfor (int i = 0; i < sizeof(pn); i++)\n+\t    sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n+\treturn string(psz, psz + sizeof(pn)*2);\n     }\n \n     void SetHex(const char* psz)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n-\n-        // skip leading spaces\n-        while (isspace(*psz))\n-            psz++;\n-\n-        // skip 0x\n-        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n-            psz += 2;\n-\n-        // hex string to uint\n-        static char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n-        const char* pbegin = psz;\n-        while (phexdigit[*psz] || *psz == '0')\n-            psz++;\n-        psz--;\n-        unsigned char* p1 = (unsigned char*)pn;\n-        unsigned char* pend = p1 + WIDTH * 4;\n-        while (psz >= pbegin && p1 < pend)\n-        {\n-            *p1 = phexdigit[(unsigned char)*psz--];\n-            if (psz >= pbegin)\n-            {\n-                *p1 |= (phexdigit[(unsigned char)*psz--] << 4);\n-                p1++;\n-            }\n-        }\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = 0;\n+\n+\t// skip leading spaces\n+\twhile (isspace(*psz))\n+\t    psz++;\n+\n+\t// skip 0x\n+\tif (psz[0] == '0' && tolower(psz[1]) == 'x')\n+\t    psz += 2;\n+\n+\t// hex string to uint\n+\tstatic char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n+\tconst char* pbegin = psz;\n+\twhile (phexdigit[*psz] || *psz == '0')\n+\t    psz++;\n+\tpsz--;\n+\tunsigned char* p1 = (unsigned char*)pn;\n+\tunsigned char* pend = p1 + WIDTH * 4;\n+\twhile (psz >= pbegin && p1 < pend)\n+\t{\n+\t    *p1 = phexdigit[(unsigned char)*psz--];\n+\t    if (psz >= pbegin)\n+\t    {\n+\t\t*p1 |= (phexdigit[(unsigned char)*psz--] << 4);\n+\t\tp1++;\n+\t    }\n+\t}\n     }\n \n     void SetHex(const std::string& str)\n     {\n-        SetHex(str.c_str());\n+\tSetHex(str.c_str());\n     }\n \n     std::string ToString() const\n     {\n-        return (GetHex());\n+\treturn (GetHex());\n     }\n \n     unsigned char* begin()\n     {\n-        return (unsigned char*)&pn[0];\n+\treturn (unsigned char*)&pn[0];\n     }\n \n     unsigned char* end()\n     {\n-        return (unsigned char*)&pn[WIDTH];\n+\treturn (unsigned char*)&pn[WIDTH];\n     }\n \n     unsigned int size()\n     {\n-        return sizeof(pn);\n+\treturn sizeof(pn);\n     }\n \n \n     unsigned int GetSerializeSize(int nType=0, int nVersion=VERSION) const\n     {\n-        return sizeof(pn);\n+\treturn sizeof(pn);\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s, int nType=0, int nVersion=VERSION) const\n     {\n-        s.write((char*)pn, sizeof(pn));\n+\ts.write((char*)pn, sizeof(pn));\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream& s, int nType=0, int nVersion=VERSION)\n     {\n-        s.read((char*)pn, sizeof(pn));\n+\ts.read((char*)pn, sizeof(pn));\n     }\n \n \n@@ -404,51 +404,51 @@ class uint160 : public base_uint160\n \n     uint160()\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = 0;\n     }\n \n     uint160(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = b.pn[i];\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = b.pn[i];\n     }\n \n     uint160& operator=(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = b.pn[i];\n-        return *this;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = b.pn[i];\n+\treturn *this;\n     }\n \n     uint160(uint64 b)\n     {\n-        pn[0] = (unsigned int)b;\n-        pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n-            pn[i] = 0;\n+\tpn[0] = (unsigned int)b;\n+\tpn[1] = (unsigned int)(b >> 32);\n+\tfor (int i = 2; i < WIDTH; i++)\n+\t    pn[i] = 0;\n     }\n \n     uint160& operator=(uint64 b)\n     {\n-        pn[0] = (unsigned int)b;\n-        pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n-            pn[i] = 0;\n-        return *this;\n+\tpn[0] = (unsigned int)b;\n+\tpn[1] = (unsigned int)(b >> 32);\n+\tfor (int i = 2; i < WIDTH; i++)\n+\t    pn[i] = 0;\n+\treturn *this;\n     }\n \n     explicit uint160(const std::string& str)\n     {\n-        SetHex(str);\n+\tSetHex(str);\n     }\n \n     explicit uint160(const std::vector<unsigned char>& vch)\n     {\n-        if (vch.size() == sizeof(pn))\n-            memcpy(pn, &vch[0], sizeof(pn));\n-        else\n-            *this = 0;\n+\tif (vch.size() == sizeof(pn))\n+\t    memcpy(pn, &vch[0], sizeof(pn));\n+\telse\n+\t    *this = 0;\n     }\n };\n \n@@ -518,51 +518,51 @@ class uint256 : public base_uint256\n \n     uint256()\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = 0;\n     }\n \n     uint256(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = b.pn[i];\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = b.pn[i];\n     }\n \n     uint256& operator=(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = b.pn[i];\n-        return *this;\n+\tfor (int i = 0; i < WIDTH; i++)\n+\t    pn[i] = b.pn[i];\n+\treturn *this;\n     }\n \n     uint256(uint64 b)\n     {\n-        pn[0] = (unsigned int)b;\n-        pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n-            pn[i] = 0;\n+\tpn[0] = (unsigned int)b;\n+\tpn[1] = (unsigned int)(b >> 32);\n+\tfor (int i = 2; i < WIDTH; i++)\n+\t    pn[i] = 0;\n     }\n \n     uint256& operator=(uint64 b)\n     {\n-        pn[0] = (unsigned int)b;\n-        pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n-            pn[i] = 0;\n-        return *this;\n+\tpn[0] = (unsigned int)b;\n+\tpn[1] = (unsigned int)(b >> 32);\n+\tfor (int i = 2; i < WIDTH; i++)\n+\t    pn[i] = 0;\n+\treturn *this;\n     }\n \n     explicit uint256(const std::string& str)\n     {\n-        SetHex(str);\n+\tSetHex(str);\n     }\n \n     explicit uint256(const std::vector<unsigned char>& vch)\n     {\n-        if (vch.size() == sizeof(pn))\n-            memcpy(pn, &vch[0], sizeof(pn));\n-        else\n-            *this = 0;\n+\tif (vch.size() == sizeof(pn))\n+\t    memcpy(pn, &vch[0], sizeof(pn));\n+\telse\n+\t    *this = 0;\n     }\n };\n \n@@ -727,30 +727,30 @@ inline int Testuint256AdHoc(vector<string> vArg)\n     printf(\"%s\\n\", x1.ToString().c_str());\n     for (int i = 0; i < 270; i += 4)\n     {\n-        x2 = x1 << i;\n-        printf(\"%s\\n\", x2.ToString().c_str());\n+\tx2 = x1 << i;\n+\tprintf(\"%s\\n\", x2.ToString().c_str());\n     }\n \n     printf(\"\\n\");\n     printf(\"%s\\n\", x1.ToString().c_str());\n     for (int i = 0; i < 270; i += 4)\n     {\n-        x2 = x1;\n-        x2 >>= i;\n-        printf(\"%s\\n\", x2.ToString().c_str());\n+\tx2 = x1;\n+\tx2 >>= i;\n+\tprintf(\"%s\\n\", x2.ToString().c_str());\n     }\n \n \n     for (int i = 0; i < 100; i++)\n     {\n-        uint256 k = (~uint256(0) >> i);\n-        printf(\"%s\\n\", k.ToString().c_str());\n+\tuint256 k = (~uint256(0) >> i);\n+\tprintf(\"%s\\n\", k.ToString().c_str());\n     }\n \n     for (int i = 0; i < 100; i++)\n     {\n-        uint256 k = (~uint256(0) << i);\n-        printf(\"%s\\n\", k.ToString().c_str());\n+\tuint256 k = (~uint256(0) << i);\n+\tprintf(\"%s\\n\", k.ToString().c_str());\n     }\n \n     return (0);"
      },
      {
        "sha": "92ce61401981046655a7f0433607635b2844b5a7",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 313,
        "deletions": 318,
        "changes": 631,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -37,9 +37,9 @@ static boost::interprocess::interprocess_mutex** ppmutexOpenSSL;\n void locking_callback(int mode, int i, const char* file, int line)\n {\n     if (mode & CRYPTO_LOCK)\n-        ppmutexOpenSSL[i]->lock();\n+\tppmutexOpenSSL[i]->lock();\n     else\n-        ppmutexOpenSSL[i]->unlock();\n+\tppmutexOpenSSL[i]->unlock();\n }\n \n // Init\n@@ -48,27 +48,27 @@ class CInit\n public:\n     CInit()\n     {\n-        // Init openssl library multithreading support\n-        ppmutexOpenSSL = (boost::interprocess::interprocess_mutex**)OPENSSL_malloc(CRYPTO_num_locks() * sizeof(boost::interprocess::interprocess_mutex*));\n-        for (int i = 0; i < CRYPTO_num_locks(); i++)\n-            ppmutexOpenSSL[i] = new boost::interprocess::interprocess_mutex();\n-        CRYPTO_set_locking_callback(locking_callback);\n+\t// Init openssl library multithreading support\n+\tppmutexOpenSSL = (boost::interprocess::interprocess_mutex**)OPENSSL_malloc(CRYPTO_num_locks() * sizeof(boost::interprocess::interprocess_mutex*));\n+\tfor (int i = 0; i < CRYPTO_num_locks(); i++)\n+\t    ppmutexOpenSSL[i] = new boost::interprocess::interprocess_mutex();\n+\tCRYPTO_set_locking_callback(locking_callback);\n \n #ifdef __WXMSW__\n-        // Seed random number generator with screen scrape and other hardware sources\n-        RAND_screen();\n+\t// Seed random number generator with screen scrape and other hardware sources\n+\tRAND_screen();\n #endif\n \n-        // Seed random number generator with performance counter\n-        RandAddSeed();\n+\t// Seed random number generator with performance counter\n+\tRandAddSeed();\n     }\n     ~CInit()\n     {\n-        // Shutdown openssl library multithreading support\n-        CRYPTO_set_locking_callback(NULL);\n-        for (int i = 0; i < CRYPTO_num_locks(); i++)\n-            delete ppmutexOpenSSL[i];\n-        OPENSSL_free(ppmutexOpenSSL);\n+\t// Shutdown openssl library multithreading support\n+\tCRYPTO_set_locking_callback(NULL);\n+\tfor (int i = 0; i < CRYPTO_num_locks(); i++)\n+\t    delete ppmutexOpenSSL[i];\n+\tOPENSSL_free(ppmutexOpenSSL);\n     }\n }\n instance_of_cinit;\n@@ -95,7 +95,7 @@ void RandAddSeedPerfmon()\n     // This can take up to 2 seconds, so only do it every 10 minutes\n     static int64 nLastPerfmon;\n     if (GetTime() < nLastPerfmon + 10 * 60)\n-        return;\n+\treturn;\n     nLastPerfmon = GetTime();\n \n #ifdef __WXMSW__\n@@ -108,24 +108,24 @@ void RandAddSeedPerfmon()\n     RegCloseKey(HKEY_PERFORMANCE_DATA);\n     if (ret == ERROR_SUCCESS)\n     {\n-        RAND_add(pdata, nSize, nSize/100.0);\n-        memset(pdata, 0, nSize);\n-        printf(\"%s RandAddSeed() %d bytes\\n\", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str(), nSize);\n+\tRAND_add(pdata, nSize, nSize/100.0);\n+\tmemset(pdata, 0, nSize);\n+\tprintf(\"%s RandAddSeed() %d bytes\\n\", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str(), nSize);\n     }\n #endif\n }\n \n uint64 GetRand(uint64 nMax)\n {\n     if (nMax == 0)\n-        return 0;\n+\treturn 0;\n \n     // The range of the random source must be a multiple of the modulus\n     // to give every possible output value an equal possibility\n     uint64 nRange = (UINT64_MAX / nMax) * nMax;\n     uint64 nRand = 0;\n     do\n-        RAND_bytes((unsigned char*)&nRand, sizeof(nRand));\n+\tRAND_bytes((unsigned char*)&nRand, sizeof(nRand));\n     while (nRand >= nRange);\n     return (nRand % nMax);\n }\n@@ -150,84 +150,84 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n     int ret = 0;\n     if (fPrintToConsole)\n     {\n-        // print to console\n-        va_list arg_ptr;\n-        va_start(arg_ptr, pszFormat);\n-        ret = vprintf(pszFormat, arg_ptr);\n-        va_end(arg_ptr);\n+\t// print to console\n+\tva_list arg_ptr;\n+\tva_start(arg_ptr, pszFormat);\n+\tret = vprintf(pszFormat, arg_ptr);\n+\tva_end(arg_ptr);\n     }\n     else\n     {\n-        // print to debug.log\n-        static FILE* fileout = NULL;\n-\n-        if (!fileout)\n-        {\n-            char pszFile[MAX_PATH+100];\n-            GetDataDir(pszFile);\n-            strlcat(pszFile, \"/debug.log\", sizeof(pszFile));\n-            fileout = fopen(pszFile, \"a\");\n-            if (fileout) setbuf(fileout, NULL); // unbuffered\n-        }\n-        if (fileout)\n-        {\n-            static bool fStartedNewLine = true;\n-\n-            // Debug print useful for profiling\n-            if (fLogTimestamps && fStartedNewLine)\n-                fprintf(fileout, \"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-            if (pszFormat[strlen(pszFormat) - 1] == '\\n')\n-                fStartedNewLine = true;\n-            else\n-                fStartedNewLine = false;\n-\n-            va_list arg_ptr;\n-            va_start(arg_ptr, pszFormat);\n-            ret = vfprintf(fileout, pszFormat, arg_ptr);\n-            va_end(arg_ptr);\n-        }\n+\t// print to debug.log\n+\tstatic FILE* fileout = NULL;\n+\n+\tif (!fileout)\n+\t{\n+\t    char pszFile[MAX_PATH+100];\n+\t    GetDataDir(pszFile);\n+\t    strlcat(pszFile, \"/debug.log\", sizeof(pszFile));\n+\t    fileout = fopen(pszFile, \"a\");\n+\t    if (fileout) setbuf(fileout, NULL); // unbuffered\n+\t}\n+\tif (fileout)\n+\t{\n+\t    static bool fStartedNewLine = true;\n+\n+\t    // Debug print useful for profiling\n+\t    if (fLogTimestamps && fStartedNewLine)\n+\t\tfprintf(fileout, \"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\t    if (pszFormat[strlen(pszFormat) - 1] == '\\n')\n+\t\tfStartedNewLine = true;\n+\t    else\n+\t\tfStartedNewLine = false;\n+\n+\t    va_list arg_ptr;\n+\t    va_start(arg_ptr, pszFormat);\n+\t    ret = vfprintf(fileout, pszFormat, arg_ptr);\n+\t    va_end(arg_ptr);\n+\t}\n     }\n \n #ifdef __WXMSW__\n     if (fPrintToDebugger)\n     {\n-        static CCriticalSection cs_OutputDebugStringF;\n-\n-        // accumulate a line at a time\n-        CRITICAL_BLOCK(cs_OutputDebugStringF)\n-        {\n-            static char pszBuffer[50000];\n-            static char* pend;\n-            if (pend == NULL)\n-                pend = pszBuffer;\n-            va_list arg_ptr;\n-            va_start(arg_ptr, pszFormat);\n-            int limit = END(pszBuffer) - pend - 2;\n-            int ret = _vsnprintf(pend, limit, pszFormat, arg_ptr);\n-            va_end(arg_ptr);\n-            if (ret < 0 || ret >= limit)\n-            {\n-                pend = END(pszBuffer) - 2;\n-                *pend++ = '\\n';\n-            }\n-            else\n-                pend += ret;\n-            *pend = '\\0';\n-            char* p1 = pszBuffer;\n-            char* p2;\n-            while (p2 = strchr(p1, '\\n'))\n-            {\n-                p2++;\n-                char c = *p2;\n-                *p2 = '\\0';\n-                OutputDebugStringA(p1);\n-                *p2 = c;\n-                p1 = p2;\n-            }\n-            if (p1 != pszBuffer)\n-                memmove(pszBuffer, p1, pend - p1 + 1);\n-            pend -= (p1 - pszBuffer);\n-        }\n+\tstatic CCriticalSection cs_OutputDebugStringF;\n+\n+\t// accumulate a line at a time\n+\tCRITICAL_BLOCK(cs_OutputDebugStringF)\n+\t{\n+\t    static char pszBuffer[50000];\n+\t    static char* pend;\n+\t    if (pend == NULL)\n+\t\tpend = pszBuffer;\n+\t    va_list arg_ptr;\n+\t    va_start(arg_ptr, pszFormat);\n+\t    int limit = END(pszBuffer) - pend - 2;\n+\t    int ret = _vsnprintf(pend, limit, pszFormat, arg_ptr);\n+\t    va_end(arg_ptr);\n+\t    if (ret < 0 || ret >= limit)\n+\t    {\n+\t\tpend = END(pszBuffer) - 2;\n+\t\t*pend++ = '\\n';\n+\t    }\n+\t    else\n+\t\tpend += ret;\n+\t    *pend = '\\0';\n+\t    char* p1 = pszBuffer;\n+\t    char* p2;\n+\t    while (p2 = strchr(p1, '\\n'))\n+\t    {\n+\t\tp2++;\n+\t\tchar c = *p2;\n+\t\t*p2 = '\\0';\n+\t\tOutputDebugStringA(p1);\n+\t\t*p2 = c;\n+\t\tp1 = p2;\n+\t    }\n+\t    if (p1 != pszBuffer)\n+\t\tmemmove(pszBuffer, p1, pend - p1 + 1);\n+\t    pend -= (p1 - pszBuffer);\n+\t}\n     }\n #endif\n     return ret;\n@@ -241,15 +241,15 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n int my_snprintf(char* buffer, size_t limit, const char* format, ...)\n {\n     if (limit == 0)\n-        return 0;\n+\treturn 0;\n     va_list arg_ptr;\n     va_start(arg_ptr, format);\n     int ret = _vsnprintf(buffer, limit, format, arg_ptr);\n     va_end(arg_ptr);\n     if (ret < 0 || ret >= limit)\n     {\n-        ret = limit - 1;\n-        buffer[limit-1] = 0;\n+\tret = limit - 1;\n+\tbuffer[limit-1] = 0;\n     }\n     return ret;\n }\n@@ -263,22 +263,22 @@ string strprintf(const char* format, ...)\n     int ret;\n     loop\n     {\n-        va_list arg_ptr;\n-        va_start(arg_ptr, format);\n-        ret = _vsnprintf(p, limit, format, arg_ptr);\n-        va_end(arg_ptr);\n-        if (ret >= 0 && ret < limit)\n-            break;\n-        if (p != buffer)\n-            delete p;\n-        limit *= 2;\n-        p = new char[limit];\n-        if (p == NULL)\n-            throw std::bad_alloc();\n+\tva_list arg_ptr;\n+\tva_start(arg_ptr, format);\n+\tret = _vsnprintf(p, limit, format, arg_ptr);\n+\tva_end(arg_ptr);\n+\tif (ret >= 0 && ret < limit)\n+\t    break;\n+\tif (p != buffer)\n+\t    delete p;\n+\tlimit *= 2;\n+\tp = new char[limit];\n+\tif (p == NULL)\n+\t    throw std::bad_alloc();\n     }\n     string str(p, p+ret);\n     if (p != buffer)\n-        delete p;\n+\tdelete p;\n     return str;\n }\n \n@@ -293,8 +293,8 @@ bool error(const char* format, ...)\n     va_end(arg_ptr);\n     if (ret < 0 || ret >= limit)\n     {\n-        ret = limit - 1;\n-        buffer[limit-1] = 0;\n+\tret = limit - 1;\n+\tbuffer[limit-1] = 0;\n     }\n     printf(\"ERROR: %s\\n\", buffer);\n     return false;\n@@ -304,19 +304,19 @@ bool error(const char* format, ...)\n void ParseString(const string& str, char c, vector<string>& v)\n {\n     if (str.empty())\n-        return;\n+\treturn;\n     string::size_type i1 = 0;\n     string::size_type i2;\n     loop\n     {\n-        i2 = str.find(c, i1);\n-        if (i2 == str.npos)\n-        {\n-            v.push_back(str.substr(i1));\n-            return;\n-        }\n-        v.push_back(str.substr(i1, i2-i1));\n-        i1 = i2+1;\n+\ti2 = str.find(c, i1);\n+\tif (i2 == str.npos)\n+\t{\n+\t    v.push_back(str.substr(i1));\n+\t    return;\n+\t}\n+\tv.push_back(str.substr(i1, i2-i1));\n+\ti1 = i2+1;\n     }\n }\n \n@@ -333,19 +333,19 @@ string FormatMoney(int64 n, bool fPlus)\n     // Right-trim excess 0's before the decimal point:\n     int nTrim = 0;\n     for (int i = str.size()-1; (str[i] == '0' && isdigit(str[i-2])); --i)\n-        ++nTrim;\n+\t++nTrim;\n     if (nTrim)\n-        str.erase(str.size()-nTrim, nTrim);\n+\tstr.erase(str.size()-nTrim, nTrim);\n \n     // Insert thousands-separators:\n     size_t point = str.find(\".\");\n     for (int i = (str.size()-point)+3; i < str.size(); i += 4)\n-        if (isdigit(str[str.size() - i - 1]))\n-            str.insert(str.size() - i, 1, ',');\n+\tif (isdigit(str[str.size() - i - 1]))\n+\t    str.insert(str.size() - i, 1, ',');\n     if (n < 0)\n-        str.insert((unsigned int)0, 1, '-');\n+\tstr.insert((unsigned int)0, 1, '-');\n     else if (fPlus && n > 0)\n-        str.insert((unsigned int)0, 1, '+');\n+\tstr.insert((unsigned int)0, 1, '+');\n     return str;\n }\n \n@@ -361,35 +361,35 @@ bool ParseMoney(const char* pszIn, int64& nRet)\n     int64 nUnits = 0;\n     const char* p = pszIn;\n     while (isspace(*p))\n-        p++;\n+\tp++;\n     for (; *p; p++)\n     {\n-        if (*p == ',' && p > pszIn && isdigit(p[-1]) && isdigit(p[1]) && isdigit(p[2]) && isdigit(p[3]) && !isdigit(p[4]))\n-            continue;\n-        if (*p == '.')\n-        {\n-            p++;\n-            int64 nMult = CENT*10;\n-            while (isdigit(*p) && (nMult > 0))\n-            {\n-                nUnits += nMult * (*p++ - '0');\n-                nMult /= 10;\n-            }\n-            break;\n-        }\n-        if (isspace(*p))\n-            break;\n-        if (!isdigit(*p))\n-            return false;\n-        strWhole.insert(strWhole.end(), *p);\n+\tif (*p == ',' && p > pszIn && isdigit(p[-1]) && isdigit(p[1]) && isdigit(p[2]) && isdigit(p[3]) && !isdigit(p[4]))\n+\t    continue;\n+\tif (*p == '.')\n+\t{\n+\t    p++;\n+\t    int64 nMult = CENT*10;\n+\t    while (isdigit(*p) && (nMult > 0))\n+\t    {\n+\t\tnUnits += nMult * (*p++ - '0');\n+\t\tnMult /= 10;\n+\t    }\n+\t    break;\n+\t}\n+\tif (isspace(*p))\n+\t    break;\n+\tif (!isdigit(*p))\n+\t    return false;\n+\tstrWhole.insert(strWhole.end(), *p);\n     }\n     for (; *p; p++)\n-        if (!isspace(*p))\n-            return false;\n+\tif (!isspace(*p))\n+\t    return false;\n     if (strWhole.size() > 14)\n-        return false;\n+\treturn false;\n     if (nUnits < 0 || nUnits > COIN)\n-        return false;\n+\treturn false;\n     int64 nWhole = atoi64(strWhole);\n     int64 nValue = nWhole*COIN + nUnits;\n \n@@ -422,17 +422,17 @@ vector<unsigned char> ParseHex(const char* psz)\n     vector<unsigned char> vch;\n     loop\n     {\n-        while (isspace(*psz))\n-            psz++;\n-        char c = phexdigit[(unsigned char)*psz++];\n-        if (c == (char)-1)\n-            break;\n-        unsigned char n = (c << 4);\n-        c = phexdigit[(unsigned char)*psz++];\n-        if (c == (char)-1)\n-            break;\n-        n |= c;\n-        vch.push_back(n);\n+\twhile (isspace(*psz))\n+\t    psz++;\n+\tchar c = phexdigit[(unsigned char)*psz++];\n+\tif (c == (char)-1)\n+\t    break;\n+\tunsigned char n = (c << 4);\n+\tc = phexdigit[(unsigned char)*psz++];\n+\tif (c == (char)-1)\n+\t    break;\n+\tn |= c;\n+\tvch.push_back(n);\n     }\n     return vch;\n }\n@@ -449,23 +449,23 @@ void ParseParameters(int argc, char* argv[])\n     mapMultiArgs.clear();\n     for (int i = 1; i < argc; i++)\n     {\n-        char psz[10000];\n-        strlcpy(psz, argv[i], sizeof(psz));\n-        char* pszValue = (char*)\"\";\n-        if (strchr(psz, '='))\n-        {\n-            pszValue = strchr(psz, '=');\n-            *pszValue++ = '\\0';\n-        }\n-        #ifdef __WXMSW__\n-        _strlwr(psz);\n-        if (psz[0] == '/')\n-            psz[0] = '-';\n-        #endif\n-        if (psz[0] != '-')\n-            break;\n-        mapArgs[psz] = pszValue;\n-        mapMultiArgs[psz].push_back(pszValue);\n+\tchar psz[10000];\n+\tstrlcpy(psz, argv[i], sizeof(psz));\n+\tchar* pszValue = (char*)\"\";\n+\tif (strchr(psz, '='))\n+\t{\n+\t    pszValue = strchr(psz, '=');\n+\t    *pszValue++ = '\\0';\n+\t}\n+\t#ifdef __WXMSW__\n+\t_strlwr(psz);\n+\tif (psz[0] == '/')\n+\t    psz[0] = '-';\n+\t#endif\n+\tif (psz[0] != '-')\n+\t    break;\n+\tmapArgs[psz] = pszValue;\n+\tmapMultiArgs[psz].push_back(pszValue);\n     }\n }\n \n@@ -477,26 +477,26 @@ const char* wxGetTranslation(const char* pszEnglish)\n     static CCriticalSection cs;\n     CRITICAL_BLOCK(cs)\n     {\n-        // Look in cache\n-        static map<string, char*> mapCache;\n-        map<string, char*>::iterator mi = mapCache.find(pszEnglish);\n-        if (mi != mapCache.end())\n-            return (*mi).second;\n-\n-        // wxWidgets translation\n-        wxString strTranslated = wxGetTranslation(wxString(pszEnglish, wxConvUTF8));\n-\n-        // We don't cache unknown strings because caller might be passing in a\n-        // dynamic string and we would keep allocating memory for each variation.\n-        if (strcmp(pszEnglish, strTranslated.utf8_str()) == 0)\n-            return pszEnglish;\n-\n-        // Add to cache, memory doesn't need to be freed.  We only cache because\n-        // we must pass back a pointer to permanently allocated memory.\n-        char* pszCached = new char[strlen(strTranslated.utf8_str())+1];\n-        strcpy(pszCached, strTranslated.utf8_str());\n-        mapCache[pszEnglish] = pszCached;\n-        return pszCached;\n+\t// Look in cache\n+\tstatic map<string, char*> mapCache;\n+\tmap<string, char*>::iterator mi = mapCache.find(pszEnglish);\n+\tif (mi != mapCache.end())\n+\t    return (*mi).second;\n+\n+\t// wxWidgets translation\n+\twxString strTranslated = wxGetTranslation(wxString(pszEnglish, wxConvUTF8));\n+\n+\t// We don't cache unknown strings because caller might be passing in a\n+\t// dynamic string and we would keep allocating memory for each variation.\n+\tif (strcmp(pszEnglish, strTranslated.utf8_str()) == 0)\n+\t    return pszEnglish;\n+\n+\t// Add to cache, memory doesn't need to be freed.  We only cache because\n+\t// we must pass back a pointer to permanently allocated memory.\n+\tchar* pszCached = new char[strlen(strTranslated.utf8_str())+1];\n+\tstrcpy(pszCached, strTranslated.utf8_str());\n+\tmapCache[pszEnglish] = pszCached;\n+\treturn pszCached;\n     }\n     return NULL;\n #else\n@@ -509,23 +509,23 @@ bool WildcardMatch(const char* psz, const char* mask)\n {\n     loop\n     {\n-        switch (*mask)\n-        {\n-        case '\\0':\n-            return (*psz == '\\0');\n-        case '*':\n-            return WildcardMatch(psz, mask+1) || (*psz && WildcardMatch(psz+1, mask));\n-        case '?':\n-            if (*psz == '\\0')\n-                return false;\n-            break;\n-        default:\n-            if (*psz != *mask)\n-                return false;\n-            break;\n-        }\n-        psz++;\n-        mask++;\n+\tswitch (*mask)\n+\t{\n+\tcase '\\0':\n+\t    return (*psz == '\\0');\n+\tcase '*':\n+\t    return WildcardMatch(psz, mask+1) || (*psz && WildcardMatch(psz+1, mask));\n+\tcase '?':\n+\t    if (*psz == '\\0')\n+\t\treturn false;\n+\t    break;\n+\tdefault:\n+\t    if (*psz != *mask)\n+\t\treturn false;\n+\t    break;\n+\t}\n+\tpsz++;\n+\tmask++;\n     }\n }\n \n@@ -551,11 +551,11 @@ void FormatException(char* pszMessage, std::exception* pex, const char* pszThrea\n     const char* pszModule = \"bitcoin\";\n #endif\n     if (pex)\n-        snprintf(pszMessage, 1000,\n-            \"EXCEPTION: %s       \\n%s       \\n%s in %s       \\n\", typeid(*pex).name(), pex->what(), pszModule, pszThread);\n+\tsnprintf(pszMessage, 1000,\n+\t    \"EXCEPTION: %s       \\n%s       \\n%s in %s       \\n\", typeid(*pex).name(), pex->what(), pszModule, pszThread);\n     else\n-        snprintf(pszMessage, 1000,\n-            \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n+\tsnprintf(pszMessage, 1000,\n+\t    \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n }\n \n void LogException(std::exception* pex, const char* pszThread)\n@@ -574,7 +574,7 @@ void PrintException(std::exception* pex, const char* pszThread)\n     strMiscWarning = pszMessage;\n #ifdef GUI\n     if (wxTheApp && !fDaemon)\n-        MyMessageBox(pszMessage, \"Bitcoin\", wxOK | wxICON_ERROR);\n+\tMyMessageBox(pszMessage, \"Bitcoin\", wxOK | wxICON_ERROR);\n #endif\n     throw;\n }\n@@ -584,7 +584,7 @@ void ThreadOneMessageBox(string strMessage)\n     // Skip message boxes if one is already open\n     static bool fMessageBoxOpen;\n     if (fMessageBoxOpen)\n-        return;\n+\treturn;\n     fMessageBoxOpen = true;\n     ThreadSafeMessageBox(strMessage, \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n     fMessageBoxOpen = false;\n@@ -599,7 +599,7 @@ void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n     strMiscWarning = pszMessage;\n #ifdef GUI\n     if (wxTheApp && !fDaemon)\n-        boost::thread(boost::bind(ThreadOneMessageBox, string(pszMessage)));\n+\tboost::thread(boost::bind(ThreadOneMessageBox, string(pszMessage)));\n #endif\n }\n \n@@ -621,25 +621,25 @@ string MyGetSpecialFolderPath(int nFolder, bool fCreate)\n     HMODULE hShell32 = LoadLibraryA(\"shell32.dll\");\n     if (hShell32)\n     {\n-        PSHGETSPECIALFOLDERPATHA pSHGetSpecialFolderPath =\n-            (PSHGETSPECIALFOLDERPATHA)GetProcAddress(hShell32, \"SHGetSpecialFolderPathA\");\n-        if (pSHGetSpecialFolderPath)\n-            (*pSHGetSpecialFolderPath)(NULL, pszPath, nFolder, fCreate);\n-        FreeModule(hShell32);\n+\tPSHGETSPECIALFOLDERPATHA pSHGetSpecialFolderPath =\n+\t    (PSHGETSPECIALFOLDERPATHA)GetProcAddress(hShell32, \"SHGetSpecialFolderPathA\");\n+\tif (pSHGetSpecialFolderPath)\n+\t    (*pSHGetSpecialFolderPath)(NULL, pszPath, nFolder, fCreate);\n+\tFreeModule(hShell32);\n     }\n \n     // Backup option\n     if (pszPath[0] == '\\0')\n     {\n-        if (nFolder == CSIDL_STARTUP)\n-        {\n-            strcpy(pszPath, getenv(\"USERPROFILE\"));\n-            strcat(pszPath, \"\\\\Start Menu\\\\Programs\\\\Startup\");\n-        }\n-        else if (nFolder == CSIDL_APPDATA)\n-        {\n-            strcpy(pszPath, getenv(\"APPDATA\"));\n-        }\n+\tif (nFolder == CSIDL_STARTUP)\n+\t{\n+\t    strcpy(pszPath, getenv(\"USERPROFILE\"));\n+\t    strcat(pszPath, \"\\\\Start Menu\\\\Programs\\\\Startup\");\n+\t}\n+\telse if (nFolder == CSIDL_APPDATA)\n+\t{\n+\t    strcpy(pszPath, getenv(\"APPDATA\"));\n+\t}\n     }\n \n     return pszPath;\n@@ -657,10 +657,10 @@ string GetDefaultDataDir()\n #else\n     char* pszHome = getenv(\"HOME\");\n     if (pszHome == NULL || strlen(pszHome) == 0)\n-        pszHome = (char*)\"/\";\n+\tpszHome = (char*)\"/\";\n     string strHome = pszHome;\n     if (strHome[strHome.size()-1] != '/')\n-        strHome += '/';\n+\tstrHome += '/';\n #ifdef __WXMAC_OSX__\n     // Mac\n     strHome += \"Library/Application Support/\";\n@@ -679,32 +679,32 @@ void GetDataDir(char* pszDir)\n     int nVariation;\n     if (pszSetDataDir[0] != 0)\n     {\n-        strlcpy(pszDir, pszSetDataDir, MAX_PATH);\n-        nVariation = 0;\n+\tstrlcpy(pszDir, pszSetDataDir, MAX_PATH);\n+\tnVariation = 0;\n     }\n     else\n     {\n-        // This can be called during exceptions by printf, so we cache the\n-        // value so we don't have to do memory allocations after that.\n-        static char pszCachedDir[MAX_PATH];\n-        if (pszCachedDir[0] == 0)\n-            strlcpy(pszCachedDir, GetDefaultDataDir().c_str(), sizeof(pszCachedDir));\n-        strlcpy(pszDir, pszCachedDir, MAX_PATH);\n-        nVariation = 1;\n+\t// This can be called during exceptions by printf, so we cache the\n+\t// value so we don't have to do memory allocations after that.\n+\tstatic char pszCachedDir[MAX_PATH];\n+\tif (pszCachedDir[0] == 0)\n+\t    strlcpy(pszCachedDir, GetDefaultDataDir().c_str(), sizeof(pszCachedDir));\n+\tstrlcpy(pszDir, pszCachedDir, MAX_PATH);\n+\tnVariation = 1;\n     }\n     if (fTestNet)\n     {\n-        char* p = pszDir + strlen(pszDir);\n-        if (p > pszDir && p[-1] != '/' && p[-1] != '\\\\')\n-            *p++ = '/';\n-        strcpy(p, \"testnet\");\n-        nVariation += 2;\n+\tchar* p = pszDir + strlen(pszDir);\n+\tif (p > pszDir && p[-1] != '/' && p[-1] != '\\\\')\n+\t    *p++ = '/';\n+\tstrcpy(p, \"testnet\");\n+\tnVariation += 2;\n     }\n     static bool pfMkdir[4];\n     if (!pfMkdir[nVariation])\n     {\n-        pfMkdir[nVariation] = true;\n-        filesystem::create_directory(pszDir);\n+\tpfMkdir[nVariation] = true;\n+\tfilesystem::create_directory(pszDir);\n     }\n }\n \n@@ -720,30 +720,30 @@ string GetConfigFile()\n     namespace fs = boost::filesystem;\n     fs::path pathConfig(GetArg(\"-conf\", \"bitcoin.conf\"));\n     if (!pathConfig.is_complete())\n-        pathConfig = fs::path(GetDataDir()) / pathConfig;\n+\tpathConfig = fs::path(GetDataDir()) / pathConfig;\n     return pathConfig.string();\n }\n \n void ReadConfigFile(map<string, string>& mapSettingsRet,\n-                    map<string, vector<string> >& mapMultiSettingsRet)\n+\t\t    map<string, vector<string> >& mapMultiSettingsRet)\n {\n     namespace fs = boost::filesystem;\n     namespace pod = boost::program_options::detail;\n \n     fs::ifstream streamConfig(GetConfigFile());\n     if (!streamConfig.good())\n-        return;\n+\treturn;\n \n     set<string> setOptions;\n     setOptions.insert(\"*\");\n-    \n+\n     for (pod::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n     {\n-        // Don't overwrite existing settings so command line settings override bitcoin.conf\n-        string strKey = string(\"-\") + it->string_key;\n-        if (mapSettingsRet.count(strKey) == 0)\n-            mapSettingsRet[strKey] = it->value[0];\n-        mapMultiSettingsRet[strKey].push_back(it->value[0]);\n+\t// Don't overwrite existing settings so command line settings override bitcoin.conf\n+\tstring strKey = string(\"-\") + it->string_key;\n+\tif (mapSettingsRet.count(strKey) == 0)\n+\t    mapSettingsRet[strKey] = it->value[0];\n+\tmapMultiSettingsRet[strKey].push_back(it->value[0]);\n     }\n }\n \n@@ -752,7 +752,7 @@ string GetPidFile()\n     namespace fs = boost::filesystem;\n     fs::path pathConfig(GetArg(\"-pid\", \"bitcoind.pid\"));\n     if (!pathConfig.is_complete())\n-        pathConfig = fs::path(GetDataDir()) / pathConfig;\n+\tpathConfig = fs::path(GetDataDir()) / pathConfig;\n     return pathConfig.string();\n }\n \n@@ -761,8 +761,8 @@ void CreatePidFile(string pidFile, pid_t pid)\n     FILE* file;\n     if (file = fopen(pidFile.c_str(), \"w\"))\n     {\n-        fprintf(file, \"%d\\n\", pid);\n-        fclose(file);\n+\tfprintf(file, \"%d\\n\", pid);\n+\tfclose(file);\n     }\n }\n \n@@ -771,7 +771,7 @@ int GetFilesize(FILE* file)\n     int nSavePos = ftell(file);\n     int nFilesize = -1;\n     if (fseek(file, 0, SEEK_END) == 0)\n-        nFilesize = ftell(file);\n+\tnFilesize = ftell(file);\n     fseek(file, nSavePos, SEEK_SET);\n     return nFilesize;\n }\n@@ -783,16 +783,16 @@ void ShrinkDebugFile()\n     FILE* file = fopen(strFile.c_str(), \"r\");\n     if (file && GetFilesize(file) > 10 * 1000000)\n     {\n-        // Restart the file with some of the end\n-        char pch[200000];\n-        fseek(file, -sizeof(pch), SEEK_END);\n-        int nBytes = fread(pch, 1, sizeof(pch), file);\n-        fclose(file);\n-        if (file = fopen(strFile.c_str(), \"w\"))\n-        {\n-            fwrite(pch, 1, nBytes, file);\n-            fclose(file);\n-        }\n+\t// Restart the file with some of the end\n+\tchar pch[200000];\n+\tfseek(file, -sizeof(pch), SEEK_END);\n+\tint nBytes = fread(pch, 1, sizeof(pch), file);\n+\tfclose(file);\n+\tif (file = fopen(strFile.c_str(), \"w\"))\n+\t{\n+\t    fwrite(pch, 1, nBytes, file);\n+\t    fclose(file);\n+\t}\n     }\n }\n \n@@ -829,49 +829,49 @@ void AddTimeData(unsigned int ip, int64 nTime)\n     // Ignore duplicates\n     static set<unsigned int> setKnown;\n     if (!setKnown.insert(ip).second)\n-        return;\n+\treturn;\n \n     // Add data\n     static vector<int64> vTimeOffsets;\n     if (vTimeOffsets.empty())\n-        vTimeOffsets.push_back(0);\n+\tvTimeOffsets.push_back(0);\n     vTimeOffsets.push_back(nOffsetSample);\n     printf(\"Added time data, samples %d, offset %+\"PRI64d\" (%+\"PRI64d\" minutes)\\n\", vTimeOffsets.size(), vTimeOffsets.back(), vTimeOffsets.back()/60);\n     if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n     {\n-        sort(vTimeOffsets.begin(), vTimeOffsets.end());\n-        int64 nMedian = vTimeOffsets[vTimeOffsets.size()/2];\n-        // Only let other nodes change our time by so much\n-        if (abs64(nMedian) < 70 * 60)\n-        {\n-            nTimeOffset = nMedian;\n-        }\n-        else\n-        {\n-            nTimeOffset = 0;\n-\n-            static bool fDone;\n-            if (!fDone)\n-            {\n-                // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n-                bool fMatch = false;\n-                foreach(int64 nOffset, vTimeOffsets)\n-                    if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n-                        fMatch = true;\n-\n-                if (!fMatch)\n-                {\n-                    fDone = true;\n-                    string strMessage = _(\"Warning: Please check that your computer's date and time are correct.  If your clock is wrong Bitcoin will not work properly.\");\n-                    strMiscWarning = strMessage;\n-                    printf(\"*** %s\\n\", strMessage.c_str());\n-                    boost::thread(boost::bind(ThreadSafeMessageBox, strMessage+\" \", string(\"Bitcoin\"), wxOK | wxICON_EXCLAMATION, (wxWindow*)NULL, -1, -1));\n-                }\n-            }\n-        }\n-        foreach(int64 n, vTimeOffsets)\n-            printf(\"%+\"PRI64d\"  \", n);\n-        printf(\"|  nTimeOffset = %+\"PRI64d\"  (%+\"PRI64d\" minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+\tsort(vTimeOffsets.begin(), vTimeOffsets.end());\n+\tint64 nMedian = vTimeOffsets[vTimeOffsets.size()/2];\n+\t// Only let other nodes change our time by so much\n+\tif (abs64(nMedian) < 70 * 60)\n+\t{\n+\t    nTimeOffset = nMedian;\n+\t}\n+\telse\n+\t{\n+\t    nTimeOffset = 0;\n+\n+\t    static bool fDone;\n+\t    if (!fDone)\n+\t    {\n+\t\t// If nobody has a time different than ours but within 5 minutes of ours, give a warning\n+\t\tbool fMatch = false;\n+\t\tforeach(int64 nOffset, vTimeOffsets)\n+\t\t    if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n+\t\t\tfMatch = true;\n+\n+\t\tif (!fMatch)\n+\t\t{\n+\t\t    fDone = true;\n+\t\t    string strMessage = _(\"Warning: Please check that your computer's date and time are correct.  If your clock is wrong Bitcoin will not work properly.\");\n+\t\t    strMiscWarning = strMessage;\n+\t\t    printf(\"*** %s\\n\", strMessage.c_str());\n+\t\t    boost::thread(boost::bind(ThreadSafeMessageBox, strMessage+\" \", string(\"Bitcoin\"), wxOK | wxICON_EXCLAMATION, (wxWindow*)NULL, -1, -1));\n+\t\t}\n+\t    }\n+\t}\n+\tforeach(int64 n, vTimeOffsets)\n+\t    printf(\"%+\"PRI64d\"  \", n);\n+\tprintf(\"|  nTimeOffset = %+\"PRI64d\"  (%+\"PRI64d\" minutes)\\n\", nTimeOffset, nTimeOffset/60);\n     }\n }\n \n@@ -886,20 +886,15 @@ void AddTimeData(unsigned int ip, int64 nTime)\n string FormatVersion(int nVersion)\n {\n     if (nVersion%100 == 0)\n-        return strprintf(\"%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100);\n+\treturn strprintf(\"%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100);\n     else\n-        return strprintf(\"%d.%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100, nVersion%100);\n+\treturn strprintf(\"%d.%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100, nVersion%100);\n }\n \n string FormatFullVersion()\n {\n     string s = FormatVersion(VERSION) + pszSubVer;\n     if (VERSION_IS_BETA)\n-        s += _(\"-beta\");\n+\ts += _(\"-beta\");\n     return s;\n }\n-\n-\n-\n-\n-"
      },
      {
        "sha": "5f5a29c0f48b063e6d32d2916d15e25edad7df82",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/defe363c1f1070473d6a64e6c2556f95c1f55cd5/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "patch": "@@ -60,8 +60,8 @@ T* alignup(T* p)\n {\n     union\n     {\n-        T* ptr;\n-        size_t n;\n+\tT* ptr;\n+\tsize_t n;\n     } u;\n     u.ptr = p;\n     u.n = (u.n + (nBytes-1)) & ~(nBytes-1);\n@@ -107,7 +107,7 @@ inline void Sleep(int64 n)\n inline int myclosesocket(SOCKET& hSocket)\n {\n     if (hSocket == INVALID_SOCKET)\n-        return WSAENOTSOCK;\n+\treturn WSAENOTSOCK;\n #ifdef __WXMSW__\n     int ret = closesocket(hSocket);\n #else\n@@ -320,13 +320,13 @@ template<typename T>\n string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n {\n     if (itbegin == itend)\n-        return \"\";\n+\treturn \"\";\n     const unsigned char* pbegin = (const unsigned char*)&itbegin[0];\n     const unsigned char* pend = pbegin + (itend - itbegin) * sizeof(itbegin[0]);\n     string str;\n     str.reserve((pend-pbegin) * (fSpaces ? 3 : 2));\n     for (const unsigned char* p = pbegin; p != pend; p++)\n-        str += strprintf((fSpaces && p != pend-1 ? \"%02x \" : \"%02x\"), *p);\n+\tstr += strprintf((fSpaces && p != pend-1 ? \"%02x \" : \"%02x\"), *p);\n     return str;\n }\n \n@@ -339,13 +339,13 @@ template<typename T>\n string HexNumStr(const T itbegin, const T itend, bool f0x=true)\n {\n     if (itbegin == itend)\n-        return \"\";\n+\treturn \"\";\n     const unsigned char* pbegin = (const unsigned char*)&itbegin[0];\n     const unsigned char* pend = pbegin + (itend - itbegin) * sizeof(itbegin[0]);\n     string str = (f0x ? \"0x\" : \"\");\n     str.reserve(str.size() + (pend-pbegin) * 2);\n     for (const unsigned char* p = pend-1; p >= pbegin; p--)\n-        str += strprintf(\"%02x\", *p);\n+\tstr += strprintf(\"%02x\", *p);\n     return str;\n }\n \n@@ -381,7 +381,7 @@ inline int64 GetPerformanceCounter()\n inline int64 GetTimeMillis()\n {\n     return (posix_time::ptime(posix_time::microsec_clock::universal_time()) -\n-            posix_time::ptime(gregorian::date(1970,1,1))).total_milliseconds();\n+\t    posix_time::ptime(gregorian::date(1970,1,1))).total_milliseconds();\n }\n \n inline string DateTimeStrFormat(const char* pszFormat, int64 nTime)\n@@ -397,7 +397,7 @@ template<typename T>\n void skipspaces(T& it)\n {\n     while (isspace(*it))\n-        ++it;\n+\t++it;\n }\n \n inline bool IsSwitchChar(char c)\n@@ -412,24 +412,24 @@ inline bool IsSwitchChar(char c)\n inline string GetArg(const string& strArg, const string& strDefault)\n {\n     if (mapArgs.count(strArg))\n-        return mapArgs[strArg];\n+\treturn mapArgs[strArg];\n     return strDefault;\n }\n \n inline int64 GetArg(const string& strArg, int64 nDefault)\n {\n     if (mapArgs.count(strArg))\n-        return atoi64(mapArgs[strArg]);\n+\treturn atoi64(mapArgs[strArg]);\n     return nDefault;\n }\n \n inline bool GetBoolArg(const string& strArg)\n {\n     if (mapArgs.count(strArg))\n     {\n-        if (mapArgs[strArg].empty())\n-            return true;\n-        return (atoi(mapArgs[strArg]) != 0);\n+\tif (mapArgs[strArg].empty())\n+\t    return true;\n+\treturn (atoi(mapArgs[strArg]) != 0);\n     }\n     return false;\n }\n@@ -455,21 +455,21 @@ inline void heapchk()\n // Randomize the stack to help protect against buffer overrun exploits\n #define IMPLEMENT_RANDOMIZE_STACK(ThreadFn)     \\\n     {                                           \\\n-        static char nLoops;                     \\\n-        if (nLoops <= 0)                        \\\n-            nLoops = GetRand(20) + 1;           \\\n-        if (nLoops-- > 1)                       \\\n-        {                                       \\\n-            ThreadFn;                           \\\n-            return;                             \\\n-        }                                       \\\n+\tstatic char nLoops;                     \\\n+\tif (nLoops <= 0)                        \\\n+\t    nLoops = GetRand(20) + 1;           \\\n+\tif (nLoops-- > 1)                       \\\n+\t{                                       \\\n+\t    ThreadFn;                           \\\n+\t    return;                             \\\n+\t}                                       \\\n     }\n \n #define CATCH_PRINT_EXCEPTION(pszFn)     \\\n     catch (std::exception& e) {          \\\n-        PrintException(&e, (pszFn));     \\\n+\tPrintException(&e, (pszFn));     \\\n     } catch (...) {                      \\\n-        PrintException(NULL, (pszFn));   \\\n+\tPrintException(NULL, (pszFn));   \\\n     }\n \n \n@@ -494,7 +494,7 @@ inline uint256 Hash(const T1 pbegin, const T1 pend)\n \n template<typename T1, typename T2>\n inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end)\n+\t\t    const T2 p2begin, const T2 p2end)\n {\n     static unsigned char pblank[1];\n     uint256 hash1;\n@@ -510,8 +510,8 @@ inline uint256 Hash(const T1 p1begin, const T1 p1end,\n \n template<typename T1, typename T2, typename T3>\n inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end,\n-                    const T3 p3begin, const T3 p3end)\n+\t\t    const T2 p2begin, const T2 p2end,\n+\t\t    const T3 p3begin, const T3 p3end)\n {\n     static unsigned char pblank[1];\n     uint256 hash1;\n@@ -566,22 +566,22 @@ inline pthread_t CreateThread(void(*pfn)(void*), void* parg, bool fWantHandle=fa\n {\n     DWORD nUnused = 0;\n     HANDLE hthread =\n-        CreateThread(\n-            NULL,                        // default security\n-            0,                           // inherit stack size from parent\n-            (LPTHREAD_START_ROUTINE)pfn, // function pointer\n-            parg,                        // argument\n-            0,                           // creation option, start immediately\n-            &nUnused);                   // thread identifier\n+\tCreateThread(\n+\t    NULL,                        // default security\n+\t    0,                           // inherit stack size from parent\n+\t    (LPTHREAD_START_ROUTINE)pfn, // function pointer\n+\t    parg,                        // argument\n+\t    0,                           // creation option, start immediately\n+\t    &nUnused);                   // thread identifier\n     if (hthread == NULL)\n     {\n-        printf(\"Error: CreateThread() returned %d\\n\", GetLastError());\n-        return (pthread_t)0;\n+\tprintf(\"Error: CreateThread() returned %d\\n\", GetLastError());\n+\treturn (pthread_t)0;\n     }\n     if (!fWantHandle)\n     {\n-        CloseHandle(hthread);\n-        return (pthread_t)-1;\n+\tCloseHandle(hthread);\n+\treturn (pthread_t)-1;\n     }\n     return hthread;\n }\n@@ -597,11 +597,11 @@ inline pthread_t CreateThread(void(*pfn)(void*), void* parg, bool fWantHandle=fa\n     int ret = pthread_create(&hthread, NULL, (void*(*)(void*))pfn, parg);\n     if (ret != 0)\n     {\n-        printf(\"Error: pthread_create() returned %d\\n\", ret);\n-        return (pthread_t)0;\n+\tprintf(\"Error: pthread_create() returned %d\\n\", ret);\n+\treturn (pthread_t)0;\n     }\n     if (!fWantHandle)\n-        return (pthread_t)-1;\n+\treturn (pthread_t)-1;\n     return hthread;\n }\n \n@@ -647,10 +647,10 @@ inline bool AffinityBugWorkaround(void(*pfn)(void*))\n     DWORD dwPrev2 = SetThreadAffinityMask(GetCurrentThread(), dwProcessAffinityMask);\n     if (dwPrev2 != dwProcessAffinityMask)\n     {\n-        printf(\"AffinityBugWorkaround() : SetThreadAffinityMask=%d, ProcessAffinityMask=%d, restarting thread\\n\", dwPrev2, dwProcessAffinityMask);\n-        if (!CreateThread(pfn, NULL))\n-            printf(\"Error: CreateThread() failed\\n\");\n-        return true;\n+\tprintf(\"AffinityBugWorkaround() : SetThreadAffinityMask=%d, ProcessAffinityMask=%d, restarting thread\\n\", dwPrev2, dwProcessAffinityMask);\n+\tif (!CreateThread(pfn, NULL))\n+\t    printf(\"Error: CreateThread() failed\\n\");\n+\treturn true;\n     }\n #endif\n     return false;"
      }
    ]
  },
  {
    "sha": "9957f8eea8c410a02bdf2c548024cd2534afdb7f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTU3ZjhlZWE4YzQxMGEwMmJkZjJjNTQ4MDI0Y2QyNTM0YWZkYjdm",
    "commit": {
      "author": {
        "name": "Caner Candan",
        "email": "caner@candan.fr",
        "date": "2011-05-15T21:48:26Z"
      },
      "committer": {
        "name": "Caner Candan",
        "email": "caner@candan.fr",
        "date": "2011-05-15T21:48:26Z"
      },
      "message": "* indentations",
      "tree": {
        "sha": "676e370a2cba310a226ed8879f282593fa06080a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/676e370a2cba310a226ed8879f282593fa06080a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9957f8eea8c410a02bdf2c548024cd2534afdb7f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9957f8eea8c410a02bdf2c548024cd2534afdb7f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9957f8eea8c410a02bdf2c548024cd2534afdb7f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9957f8eea8c410a02bdf2c548024cd2534afdb7f/comments",
    "author": {
      "login": "canercandan",
      "id": 285572,
      "node_id": "MDQ6VXNlcjI4NTU3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/285572?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/canercandan",
      "html_url": "https://github.com/canercandan",
      "followers_url": "https://api.github.com/users/canercandan/followers",
      "following_url": "https://api.github.com/users/canercandan/following{/other_user}",
      "gists_url": "https://api.github.com/users/canercandan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/canercandan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/canercandan/subscriptions",
      "organizations_url": "https://api.github.com/users/canercandan/orgs",
      "repos_url": "https://api.github.com/users/canercandan/repos",
      "events_url": "https://api.github.com/users/canercandan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/canercandan/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "canercandan",
      "id": 285572,
      "node_id": "MDQ6VXNlcjI4NTU3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/285572?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/canercandan",
      "html_url": "https://github.com/canercandan",
      "followers_url": "https://api.github.com/users/canercandan/followers",
      "following_url": "https://api.github.com/users/canercandan/following{/other_user}",
      "gists_url": "https://api.github.com/users/canercandan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/canercandan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/canercandan/subscriptions",
      "organizations_url": "https://api.github.com/users/canercandan/orgs",
      "repos_url": "https://api.github.com/users/canercandan/repos",
      "events_url": "https://api.github.com/users/canercandan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/canercandan/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/defe363c1f1070473d6a64e6c2556f95c1f55cd5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/defe363c1f1070473d6a64e6c2556f95c1f55cd5"
      }
    ],
    "stats": {
      "total": 17901,
      "additions": 8996,
      "deletions": 8905
    },
    "files": [
      {
        "sha": "94714bc73fc715996bc28e3c57c6e2d833a5aecf",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 32,
        "deletions": 28,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -12,6 +12,8 @@\n // - Doubleclicking selects the whole number as one word if it's all alphanumeric.\n //\n \n+#ifndef BASE58_H\n+#define BASE58_H\n \n static const char* pszBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n \n@@ -37,13 +39,13 @@ inline string EncodeBase58(const unsigned char* pbegin, const unsigned char* pen\n     CBigNum dv;\n     CBigNum rem;\n     while (bn > bn0)\n-    {\n-\tif (!BN_div(&dv, &rem, &bn, &bn58, pctx))\n-\t    throw bignum_error(\"EncodeBase58 : BN_div failed\");\n-\tbn = dv;\n-\tunsigned int c = rem.getulong();\n-\tstr += pszBase58[c];\n-    }\n+\t{\n+\t    if (!BN_div(&dv, &rem, &bn, &bn58, pctx))\n+\t\tthrow bignum_error(\"EncodeBase58 : BN_div failed\");\n+\t    bn = dv;\n+\t    unsigned int c = rem.getulong();\n+\t    str += pszBase58[c];\n+\t}\n \n     // Leading zeroes encoded as base58 zeros\n     for (const unsigned char* p = pbegin; p < pend && *p == 0; p++)\n@@ -71,21 +73,21 @@ inline bool DecodeBase58(const char* psz, vector<unsigned char>& vchRet)\n \n     // Convert big endian string to bignum\n     for (const char* p = psz; *p; p++)\n-    {\n-\tconst char* p1 = strchr(pszBase58, *p);\n-\tif (p1 == NULL)\n \t{\n-\t    while (isspace(*p))\n-\t\tp++;\n-\t    if (*p != '\\0')\n-\t\treturn false;\n-\t    break;\n+\t    const char* p1 = strchr(pszBase58, *p);\n+\t    if (p1 == NULL)\n+\t\t{\n+\t\t    while (isspace(*p))\n+\t\t\tp++;\n+\t\t    if (*p != '\\0')\n+\t\t\treturn false;\n+\t\t    break;\n+\t\t}\n+\t    bnChar.setulong(p1 - pszBase58);\n+\t    if (!BN_mul(&bn, &bn, &bn58, pctx))\n+\t\tthrow bignum_error(\"DecodeBase58 : BN_mul failed\");\n+\t    bn += bnChar;\n \t}\n-\tbnChar.setulong(p1 - pszBase58);\n-\tif (!BN_mul(&bn, &bn, &bn58, pctx))\n-\t    throw bignum_error(\"DecodeBase58 : BN_mul failed\");\n-\tbn += bnChar;\n-    }\n \n     // Get bignum as little endian data\n     vector<unsigned char> vchTmp = bn.getvch();\n@@ -128,16 +130,16 @@ inline bool DecodeBase58Check(const char* psz, vector<unsigned char>& vchRet)\n     if (!DecodeBase58(psz, vchRet))\n \treturn false;\n     if (vchRet.size() < 4)\n-    {\n-\tvchRet.clear();\n-\treturn false;\n-    }\n+\t{\n+\t    vchRet.clear();\n+\t    return false;\n+\t}\n     uint256 hash = Hash(vchRet.begin(), vchRet.end()-4);\n     if (memcmp(&hash, &vchRet.end()[-4], 4) != 0)\n-    {\n-\tvchRet.clear();\n-\treturn false;\n-    }\n+\t{\n+\t    vchRet.clear();\n+\t    return false;\n+\t}\n     vchRet.resize(vchRet.size()-4);\n     return true;\n }\n@@ -199,3 +201,5 @@ inline string PubKeyToAddress(const vector<unsigned char>& vchPubKey)\n {\n     return Hash160ToAddress(Hash160(vchPubKey));\n }\n+\n+#endif // !BASE58_H"
      },
      {
        "sha": "0ba5fe2e3b51c5f853447c256ac07512d0171539",
        "filename": "src/bignum.h",
        "status": "modified",
        "additions": 67,
        "deletions": 62,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/bignum.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/bignum.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bignum.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef BIGNUM_H\n+#define BIGNUM_H\n+\n #include <stdexcept>\n #include <vector>\n #include <openssl/bn.h>\n@@ -58,10 +61,10 @@ class CBigNum : public BIGNUM\n     {\n \tBN_init(this);\n \tif (!BN_copy(this, &b))\n-\t{\n-\t    BN_clear_free(this);\n-\t    throw bignum_error(\"CBigNum::CBigNum(const CBigNum&) : BN_copy failed\");\n-\t}\n+\t    {\n+\t\tBN_clear_free(this);\n+\t\tthrow bignum_error(\"CBigNum::CBigNum(const CBigNum&) : BN_copy failed\");\n+\t    }\n     }\n \n     CBigNum& operator=(const CBigNum& b)\n@@ -125,27 +128,27 @@ class CBigNum : public BIGNUM\n \tunsigned char* p = pch + 4;\n \tbool fNegative = false;\n \tif (n < (int64)0)\n-\t{\n-\t    n = -n;\n-\t    fNegative = true;\n-\t}\n+\t    {\n+\t\tn = -n;\n+\t\tfNegative = true;\n+\t    }\n \tbool fLeadingZeroes = true;\n \tfor (int i = 0; i < 8; i++)\n-\t{\n-\t    unsigned char c = (n >> 56) & 0xff;\n-\t    n <<= 8;\n-\t    if (fLeadingZeroes)\n \t    {\n-\t\tif (c == 0)\n-\t\t    continue;\n-\t\tif (c & 0x80)\n-\t\t    *p++ = (fNegative ? 0x80 : 0);\n-\t\telse if (fNegative)\n-\t\t    c |= 0x80;\n-\t\tfLeadingZeroes = false;\n+\t\tunsigned char c = (n >> 56) & 0xff;\n+\t\tn <<= 8;\n+\t\tif (fLeadingZeroes)\n+\t\t    {\n+\t\t\tif (c == 0)\n+\t\t\t    continue;\n+\t\t\tif (c & 0x80)\n+\t\t\t    *p++ = (fNegative ? 0x80 : 0);\n+\t\t\telse if (fNegative)\n+\t\t\t    c |= 0x80;\n+\t\t\tfLeadingZeroes = false;\n+\t\t    }\n+\t\t*p++ = c;\n \t    }\n-\t    *p++ = c;\n-\t}\n \tunsigned int nSize = p - (pch + 4);\n \tpch[0] = (nSize >> 24) & 0xff;\n \tpch[1] = (nSize >> 16) & 0xff;\n@@ -160,19 +163,19 @@ class CBigNum : public BIGNUM\n \tunsigned char* p = pch + 4;\n \tbool fLeadingZeroes = true;\n \tfor (int i = 0; i < 8; i++)\n-\t{\n-\t    unsigned char c = (n >> 56) & 0xff;\n-\t    n <<= 8;\n-\t    if (fLeadingZeroes)\n \t    {\n-\t\tif (c == 0)\n-\t\t    continue;\n-\t\tif (c & 0x80)\n-\t\t    *p++ = 0;\n-\t\tfLeadingZeroes = false;\n+\t\tunsigned char c = (n >> 56) & 0xff;\n+\t\tn <<= 8;\n+\t\tif (fLeadingZeroes)\n+\t\t    {\n+\t\t\tif (c == 0)\n+\t\t\t    continue;\n+\t\t\tif (c & 0x80)\n+\t\t\t    *p++ = 0;\n+\t\t\tfLeadingZeroes = false;\n+\t\t    }\n+\t\t*p++ = c;\n \t    }\n-\t    *p++ = c;\n-\t}\n \tunsigned int nSize = p - (pch + 4);\n \tpch[0] = (nSize >> 24) & 0xff;\n \tpch[1] = (nSize >> 16) & 0xff;\n@@ -189,18 +192,18 @@ class CBigNum : public BIGNUM\n \tunsigned char* pbegin = (unsigned char*)&n;\n \tunsigned char* psrc = pbegin + sizeof(n);\n \twhile (psrc != pbegin)\n-\t{\n-\t    unsigned char c = *(--psrc);\n-\t    if (fLeadingZeroes)\n \t    {\n-\t\tif (c == 0)\n-\t\t    continue;\n-\t\tif (c & 0x80)\n-\t\t    *p++ = 0;\n-\t\tfLeadingZeroes = false;\n+\t\tunsigned char c = *(--psrc);\n+\t\tif (fLeadingZeroes)\n+\t\t    {\n+\t\t\tif (c == 0)\n+\t\t\t    continue;\n+\t\t\tif (c & 0x80)\n+\t\t\t    *p++ = 0;\n+\t\t\tfLeadingZeroes = false;\n+\t\t    }\n+\t\t*p++ = c;\n \t    }\n-\t    *p++ = c;\n-\t}\n \tunsigned int nSize = p - (pch + 4);\n \tpch[0] = (nSize >> 24) & 0xff;\n \tpch[1] = (nSize >> 16) & 0xff;\n@@ -281,10 +284,10 @@ class CBigNum : public BIGNUM\n \t    psz++;\n \tbool fNegative = false;\n \tif (*psz == '-')\n-\t{\n-\t    fNegative = true;\n-\t    psz++;\n-\t}\n+\t    {\n+\t\tfNegative = true;\n+\t\tpsz++;\n+\t    }\n \tif (psz[0] == '0' && tolower(psz[1]) == 'x')\n \t    psz += 2;\n \twhile (isspace(*psz))\n@@ -294,11 +297,11 @@ class CBigNum : public BIGNUM\n \tstatic char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n \t*this = 0;\n \twhile (isxdigit(*psz))\n-\t{\n-\t    *this <<= 4;\n-\t    int n = phexdigit[*psz++];\n-\t    *this += n;\n-\t}\n+\t    {\n+\t\t*this <<= 4;\n+\t\tint n = phexdigit[*psz++];\n+\t\t*this += n;\n+\t    }\n \tif (fNegative)\n \t    *this = 0 - *this;\n     }\n@@ -316,13 +319,13 @@ class CBigNum : public BIGNUM\n \tif (BN_cmp(&bn, &bn0) == 0)\n \t    return \"0\";\n \twhile (BN_cmp(&bn, &bn0) > 0)\n-\t{\n-\t    if (!BN_div(&dv, &rem, &bn, &bnBase, pctx))\n-\t\tthrow bignum_error(\"CBigNum::ToString() : BN_div failed\");\n-\t    bn = dv;\n-\t    unsigned int c = rem.getulong();\n-\t    str += \"0123456789abcdef\"[c];\n-\t}\n+\t    {\n+\t\tif (!BN_div(&dv, &rem, &bn, &bnBase, pctx))\n+\t\t    throw bignum_error(\"CBigNum::ToString() : BN_div failed\");\n+\t\tbn = dv;\n+\t\tunsigned int c = rem.getulong();\n+\t\tstr += \"0123456789abcdef\"[c];\n+\t    }\n \tif (BN_is_negative(this))\n \t    str += \"-\";\n \treverse(str.begin(), str.end());\n@@ -406,10 +409,10 @@ class CBigNum : public BIGNUM\n \tCBigNum a = 1;\n \ta <<= shift;\n \tif (BN_cmp(&a, this) > 0)\n-\t{\n-\t    *this = 0;\n-\t    return *this;\n-\t}\n+\t    {\n+\t\t*this = 0;\n+\t\treturn *this;\n+\t    }\n \n \tif (!BN_rshift(this, this, shift))\n \t    throw bignum_error(\"CBigNum:operator>>= : BN_rshift failed\");\n@@ -530,3 +533,5 @@ inline bool operator<=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a,\n inline bool operator>=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) >= 0); }\n inline bool operator<(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) < 0); }\n inline bool operator>(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) > 0); }\n+\n+#endif // !BIGNUM_H"
      },
      {
        "sha": "e1909af86a1bdf8d4a3816e45f685777ae1041bd",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 454,
        "deletions": 454,
        "changes": 908,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -31,13 +31,13 @@ class CDBInit\n     ~CDBInit()\n     {\n \tif (fDbEnvInit)\n-\t{\n-\t    dbenv.close(0);\n-\t    fDbEnvInit = false;\n-\t}\n+\t    {\n+\t\tdbenv.close(0);\n+\t\tfDbEnvInit = false;\n+\t    }\n     }\n }\n-instance_of_cdbinit;\n+    instance_of_cdbinit;\n \n \n CDB::CDB(const char* pszFile, const char* pszMode) : pdb(NULL)\n@@ -55,69 +55,69 @@ CDB::CDB(const char* pszFile, const char* pszMode) : pdb(NULL)\n     CRITICAL_BLOCK(cs_db)\n     {\n \tif (!fDbEnvInit)\n-\t{\n-\t    if (fShutdown)\n-\t\treturn;\n-\t    string strDataDir = GetDataDir();\n-\t    string strLogDir = strDataDir + \"/database\";\n-\t    filesystem::create_directory(strLogDir.c_str());\n-\t    string strErrorFile = strDataDir + \"/db.log\";\n-\t    printf(\"dbenv.open strLogDir=%s strErrorFile=%s\\n\", strLogDir.c_str(), strErrorFile.c_str());\n-\n-\t    dbenv.set_lg_dir(strLogDir.c_str());\n-\t    dbenv.set_lg_max(10000000);\n-\t    dbenv.set_lk_max_locks(10000);\n-\t    dbenv.set_lk_max_objects(10000);\n-\t    dbenv.set_errfile(fopen(strErrorFile.c_str(), \"a\")); /// debug\n-\t    dbenv.set_flags(DB_AUTO_COMMIT, 1);\n-\t    ret = dbenv.open(strDataDir.c_str(),\n-\t\t\t     DB_CREATE     |\n-\t\t\t     DB_INIT_LOCK  |\n-\t\t\t     DB_INIT_LOG   |\n-\t\t\t     DB_INIT_MPOOL |\n-\t\t\t     DB_INIT_TXN   |\n-\t\t\t     DB_THREAD     |\n-\t\t\t     DB_RECOVER,\n-\t\t\t     S_IRUSR | S_IWUSR);\n-\t    if (ret > 0)\n-\t\tthrow runtime_error(strprintf(\"CDB() : error %d opening database environment\", ret));\n-\t    fDbEnvInit = true;\n-\t}\n+\t    {\n+\t\tif (fShutdown)\n+\t\t    return;\n+\t\tstring strDataDir = GetDataDir();\n+\t\tstring strLogDir = strDataDir + \"/database\";\n+\t\tfilesystem::create_directory(strLogDir.c_str());\n+\t\tstring strErrorFile = strDataDir + \"/db.log\";\n+\t\tprintf(\"dbenv.open strLogDir=%s strErrorFile=%s\\n\", strLogDir.c_str(), strErrorFile.c_str());\n+\n+\t\tdbenv.set_lg_dir(strLogDir.c_str());\n+\t\tdbenv.set_lg_max(10000000);\n+\t\tdbenv.set_lk_max_locks(10000);\n+\t\tdbenv.set_lk_max_objects(10000);\n+\t\tdbenv.set_errfile(fopen(strErrorFile.c_str(), \"a\")); /// debug\n+\t\tdbenv.set_flags(DB_AUTO_COMMIT, 1);\n+\t\tret = dbenv.open(strDataDir.c_str(),\n+\t\t\t\t DB_CREATE     |\n+\t\t\t\t DB_INIT_LOCK  |\n+\t\t\t\t DB_INIT_LOG   |\n+\t\t\t\t DB_INIT_MPOOL |\n+\t\t\t\t DB_INIT_TXN   |\n+\t\t\t\t DB_THREAD     |\n+\t\t\t\t DB_RECOVER,\n+\t\t\t\t S_IRUSR | S_IWUSR);\n+\t\tif (ret > 0)\n+\t\t    throw runtime_error(strprintf(\"CDB() : error %d opening database environment\", ret));\n+\t\tfDbEnvInit = true;\n+\t    }\n \n \tstrFile = pszFile;\n \t++mapFileUseCount[strFile];\n \tpdb = mapDb[strFile];\n \tif (pdb == NULL)\n-\t{\n-\t    pdb = new Db(&dbenv, 0);\n+\t    {\n+\t\tpdb = new Db(&dbenv, 0);\n \n-\t    ret = pdb->open(NULL,      // Txn pointer\n-\t\t\t    pszFile,   // Filename\n-\t\t\t    \"main\",    // Logical db name\n-\t\t\t    DB_BTREE,  // Database type\n-\t\t\t    nFlags,    // Flags\n-\t\t\t    0);\n+\t\tret = pdb->open(NULL,      // Txn pointer\n+\t\t\t\tpszFile,   // Filename\n+\t\t\t\t\"main\",    // Logical db name\n+\t\t\t\tDB_BTREE,  // Database type\n+\t\t\t\tnFlags,    // Flags\n+\t\t\t\t0);\n \n-\t    if (ret > 0)\n-\t    {\n-\t\tdelete pdb;\n-\t\tpdb = NULL;\n-\t\tCRITICAL_BLOCK(cs_db)\n-\t\t    --mapFileUseCount[strFile];\n-\t\tstrFile = \"\";\n-\t\tthrow runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n-\t    }\n+\t\tif (ret > 0)\n+\t\t    {\n+\t\t\tdelete pdb;\n+\t\t\tpdb = NULL;\n+\t\t\tCRITICAL_BLOCK(cs_db)\n+\t\t\t    --mapFileUseCount[strFile];\n+\t\t\tstrFile = \"\";\n+\t\t\tthrow runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n+\t\t    }\n \n-\t    if (fCreate && !Exists(string(\"version\")))\n-\t    {\n-\t\tbool fTmp = fReadOnly;\n-\t\tfReadOnly = false;\n-\t\tWriteVersion(VERSION);\n-\t\tfReadOnly = fTmp;\n-\t    }\n+\t\tif (fCreate && !Exists(string(\"version\")))\n+\t\t    {\n+\t\t\tbool fTmp = fReadOnly;\n+\t\t\tfReadOnly = false;\n+\t\t\tWriteVersion(VERSION);\n+\t\t\tfReadOnly = fTmp;\n+\t\t    }\n \n-\t    mapDb[strFile] = pdb;\n-\t}\n+\t\tmapDb[strFile] = pdb;\n+\t    }\n     }\n }\n \n@@ -149,13 +149,13 @@ void CloseDb(const string& strFile)\n     CRITICAL_BLOCK(cs_db)\n     {\n \tif (mapDb[strFile] != NULL)\n-\t{\n-\t    // Close the database handle\n-\t    Db* pdb = mapDb[strFile];\n-\t    pdb->close(0);\n-\t    delete pdb;\n-\t    mapDb[strFile] = NULL;\n-\t}\n+\t    {\n+\t\t// Close the database handle\n+\t\tDb* pdb = mapDb[strFile];\n+\t\tpdb->close(0);\n+\t\tdelete pdb;\n+\t\tmapDb[strFile] = NULL;\n+\t    }\n     }\n }\n \n@@ -170,30 +170,30 @@ void DBFlush(bool fShutdown)\n     {\n \tmap<string, int>::iterator mi = mapFileUseCount.begin();\n \twhile (mi != mapFileUseCount.end())\n-\t{\n-\t    string strFile = (*mi).first;\n-\t    int nRefCount = (*mi).second;\n-\t    printf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n-\t    if (nRefCount == 0)\n \t    {\n-\t\t// Move log data to the dat file\n-\t\tCloseDb(strFile);\n-\t\tdbenv.txn_checkpoint(0, 0, 0);\n-\t\tprintf(\"%s flush\\n\", strFile.c_str());\n-\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n-\t\tmapFileUseCount.erase(mi++);\n+\t\tstring strFile = (*mi).first;\n+\t\tint nRefCount = (*mi).second;\n+\t\tprintf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n+\t\tif (nRefCount == 0)\n+\t\t    {\n+\t\t\t// Move log data to the dat file\n+\t\t\tCloseDb(strFile);\n+\t\t\tdbenv.txn_checkpoint(0, 0, 0);\n+\t\t\tprintf(\"%s flush\\n\", strFile.c_str());\n+\t\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n+\t\t\tmapFileUseCount.erase(mi++);\n+\t\t    }\n+\t\telse\n+\t\t    mi++;\n \t    }\n-\t    else\n-\t\tmi++;\n-\t}\n \tif (fShutdown)\n-\t{\n-\t    char** listp;\n-\t    if (mapFileUseCount.empty())\n-\t\tdbenv.log_archive(&listp, DB_ARCH_REMOVE);\n-\t    dbenv.close(0);\n-\t    fDbEnvInit = false;\n-\t}\n+\t    {\n+\t\tchar** listp;\n+\t\tif (mapFileUseCount.empty())\n+\t\t    dbenv.log_archive(&listp, DB_ARCH_REMOVE);\n+\t\tdbenv.close(0);\n+\t\tfDbEnvInit = false;\n+\t    }\n     }\n }\n \n@@ -255,43 +255,43 @@ bool CTxDB::ReadOwnerTxes(uint160 hash160, int nMinHeight, vector<CTransaction>&\n \n     unsigned int fFlags = DB_SET_RANGE;\n     loop\n-    {\n-\t// Read next record\n-\tCDataStream ssKey;\n-\tif (fFlags == DB_SET_RANGE)\n-\t    ssKey << string(\"owner\") << hash160 << CDiskTxPos(0, 0, 0);\n-\tCDataStream ssValue;\n-\tint ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-\tfFlags = DB_NEXT;\n-\tif (ret == DB_NOTFOUND)\n-\t    break;\n-\telse if (ret != 0)\n \t{\n-\t    pcursor->close();\n-\t    return false;\n-\t}\n+\t    // Read next record\n+\t    CDataStream ssKey;\n+\t    if (fFlags == DB_SET_RANGE)\n+\t\tssKey << string(\"owner\") << hash160 << CDiskTxPos(0, 0, 0);\n+\t    CDataStream ssValue;\n+\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+\t    fFlags = DB_NEXT;\n+\t    if (ret == DB_NOTFOUND)\n+\t\tbreak;\n+\t    else if (ret != 0)\n+\t\t{\n+\t\t    pcursor->close();\n+\t\t    return false;\n+\t\t}\n \n-\t// Unserialize\n-\tstring strType;\n-\tuint160 hashItem;\n-\tCDiskTxPos pos;\n-\tssKey >> strType >> hashItem >> pos;\n-\tint nItemHeight;\n-\tssValue >> nItemHeight;\n-\n-\t// Read transaction\n-\tif (strType != \"owner\" || hashItem != hash160)\n-\t    break;\n-\tif (nItemHeight >= nMinHeight)\n-\t{\n-\t    vtx.resize(vtx.size()+1);\n-\t    if (!vtx.back().ReadFromDisk(pos))\n-\t    {\n-\t\tpcursor->close();\n-\t\treturn false;\n-\t    }\n+\t    // Unserialize\n+\t    string strType;\n+\t    uint160 hashItem;\n+\t    CDiskTxPos pos;\n+\t    ssKey >> strType >> hashItem >> pos;\n+\t    int nItemHeight;\n+\t    ssValue >> nItemHeight;\n+\n+\t    // Read transaction\n+\t    if (strType != \"owner\" || hashItem != hash160)\n+\t\tbreak;\n+\t    if (nItemHeight >= nMinHeight)\n+\t\t{\n+\t\t    vtx.resize(vtx.size()+1);\n+\t\t    if (!vtx.back().ReadFromDisk(pos))\n+\t\t\t{\n+\t\t\t    pcursor->close();\n+\t\t\t    return false;\n+\t\t\t}\n+\t\t}\n \t}\n-    }\n \n     pcursor->close();\n     return true;\n@@ -383,76 +383,76 @@ bool CTxDB::LoadBlockIndex()\n     // Load mapBlockIndex\n     unsigned int fFlags = DB_SET_RANGE;\n     loop\n-    {\n-\t// Read next record\n-\tCDataStream ssKey;\n-\tif (fFlags == DB_SET_RANGE)\n-\t    ssKey << make_pair(string(\"blockindex\"), uint256(0));\n-\tCDataStream ssValue;\n-\tint ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-\tfFlags = DB_NEXT;\n-\tif (ret == DB_NOTFOUND)\n-\t    break;\n-\telse if (ret != 0)\n-\t    return false;\n-\n-\t// Unserialize\n-\tstring strType;\n-\tssKey >> strType;\n-\tif (strType == \"blockindex\")\n \t{\n-\t    CDiskBlockIndex diskindex;\n-\t    ssValue >> diskindex;\n-\n-\t    // Construct block index object\n-\t    CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-\t    pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-\t    pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n-\t    pindexNew->nFile          = diskindex.nFile;\n-\t    pindexNew->nBlockPos      = diskindex.nBlockPos;\n-\t    pindexNew->nHeight        = diskindex.nHeight;\n-\t    pindexNew->nVersion       = diskindex.nVersion;\n-\t    pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n-\t    pindexNew->nTime          = diskindex.nTime;\n-\t    pindexNew->nBits          = diskindex.nBits;\n-\t    pindexNew->nNonce         = diskindex.nNonce;\n-\n-\t    // Watch for genesis block\n-\t    if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n-\t\tpindexGenesisBlock = pindexNew;\n-\n-\t    if (!pindexNew->CheckIndex())\n-\t\treturn error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n-\t}\n-\telse\n-\t{\n-\t    break;\n+\t    // Read next record\n+\t    CDataStream ssKey;\n+\t    if (fFlags == DB_SET_RANGE)\n+\t\tssKey << make_pair(string(\"blockindex\"), uint256(0));\n+\t    CDataStream ssValue;\n+\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+\t    fFlags = DB_NEXT;\n+\t    if (ret == DB_NOTFOUND)\n+\t\tbreak;\n+\t    else if (ret != 0)\n+\t\treturn false;\n+\n+\t    // Unserialize\n+\t    string strType;\n+\t    ssKey >> strType;\n+\t    if (strType == \"blockindex\")\n+\t\t{\n+\t\t    CDiskBlockIndex diskindex;\n+\t\t    ssValue >> diskindex;\n+\n+\t\t    // Construct block index object\n+\t\t    CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n+\t\t    pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n+\t\t    pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n+\t\t    pindexNew->nFile          = diskindex.nFile;\n+\t\t    pindexNew->nBlockPos      = diskindex.nBlockPos;\n+\t\t    pindexNew->nHeight        = diskindex.nHeight;\n+\t\t    pindexNew->nVersion       = diskindex.nVersion;\n+\t\t    pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n+\t\t    pindexNew->nTime          = diskindex.nTime;\n+\t\t    pindexNew->nBits          = diskindex.nBits;\n+\t\t    pindexNew->nNonce         = diskindex.nNonce;\n+\n+\t\t    // Watch for genesis block\n+\t\t    if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n+\t\t\tpindexGenesisBlock = pindexNew;\n+\n+\t\t    if (!pindexNew->CheckIndex())\n+\t\t\treturn error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n+\t\t}\n+\t    else\n+\t\t{\n+\t\t    break;\n+\t\t}\n \t}\n-    }\n     pcursor->close();\n \n     // Calculate bnChainWork\n     vector<pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(mapBlockIndex.size());\n     foreach(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n-    {\n-\tCBlockIndex* pindex = item.second;\n-\tvSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n-    }\n+\t{\n+\t    CBlockIndex* pindex = item.second;\n+\t    vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n+\t}\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n     foreach(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n-    {\n-\tCBlockIndex* pindex = item.second;\n-\tpindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n-    }\n+\t{\n+\t    CBlockIndex* pindex = item.second;\n+\t    pindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n+\t}\n \n     // Load hashBestChain pointer to end of best chain\n     if (!ReadHashBestChain(hashBestChain))\n-    {\n-\tif (pindexGenesisBlock == NULL)\n-\t    return true;\n-\treturn error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n-    }\n+\t{\n+\t    if (pindexGenesisBlock == NULL)\n+\t\treturn true;\n+\t    return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n+\t}\n     if (!mapBlockIndex.count(hashBestChain))\n \treturn error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n     pindexBest = mapBlockIndex[hashBestChain];\n@@ -466,28 +466,28 @@ bool CTxDB::LoadBlockIndex()\n     // Verify blocks in the best chain\n     CBlockIndex* pindexFork = NULL;\n     for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n-    {\n-\tif (pindex->nHeight < nBestHeight-2500 && !mapArgs.count(\"-checkblocks\"))\n-\t    break;\n-\tCBlock block;\n-\tif (!block.ReadFromDisk(pindex))\n-\t    return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-\tif (!block.CheckBlock())\n \t{\n-\t    printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n-\t    pindexFork = pindex->pprev;\n+\t    if (pindex->nHeight < nBestHeight-2500 && !mapArgs.count(\"-checkblocks\"))\n+\t\tbreak;\n+\t    CBlock block;\n+\t    if (!block.ReadFromDisk(pindex))\n+\t\treturn error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+\t    if (!block.CheckBlock())\n+\t\t{\n+\t\t    printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+\t\t    pindexFork = pindex->pprev;\n+\t\t}\n \t}\n-    }\n     if (pindexFork)\n-    {\n-\t// Reorg back to the fork\n-\tprintf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n-\tCBlock block;\n-\tif (!block.ReadFromDisk(pindexFork))\n-\t    return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-\tCTxDB txdb;\n-\tblock.SetBestChain(txdb, pindexFork);\n-    }\n+\t{\n+\t    // Reorg back to the fork\n+\t    printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n+\t    CBlock block;\n+\t    if (!block.ReadFromDisk(pindexFork))\n+\t\treturn error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+\t    CTxDB txdb;\n+\t    block.SetBestChain(txdb, pindexFork);\n+\t}\n \n     return true;\n }\n@@ -517,47 +517,47 @@ bool CAddrDB::LoadAddresses()\n \t// Load user provided addresses\n \tCAutoFile filein = fopen((GetDataDir() + \"/addr.txt\").c_str(), \"rt\");\n \tif (filein)\n-\t{\n-\t    try\n \t    {\n-\t\tchar psz[1000];\n-\t\twhile (fgets(psz, sizeof(psz), filein))\n-\t\t{\n-\t\t    CAddress addr(psz, NODE_NETWORK);\n-\t\t    addr.nTime = 0; // so it won't relay unless successfully connected\n-\t\t    if (addr.IsValid())\n-\t\t\tAddAddress(addr);\n-\t\t}\n+\t\ttry\n+\t\t    {\n+\t\t\tchar psz[1000];\n+\t\t\twhile (fgets(psz, sizeof(psz), filein))\n+\t\t\t    {\n+\t\t\t\tCAddress addr(psz, NODE_NETWORK);\n+\t\t\t\taddr.nTime = 0; // so it won't relay unless successfully connected\n+\t\t\t\tif (addr.IsValid())\n+\t\t\t\t    AddAddress(addr);\n+\t\t\t    }\n+\t\t    }\n+\t\tcatch (...) { }\n \t    }\n-\t    catch (...) { }\n-\t}\n \n \t// Get cursor\n \tDbc* pcursor = GetCursor();\n \tif (!pcursor)\n \t    return false;\n \n \tloop\n-\t{\n-\t    // Read next record\n-\t    CDataStream ssKey;\n-\t    CDataStream ssValue;\n-\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-\t    if (ret == DB_NOTFOUND)\n-\t\tbreak;\n-\t    else if (ret != 0)\n-\t\treturn false;\n-\n-\t    // Unserialize\n-\t    string strType;\n-\t    ssKey >> strType;\n-\t    if (strType == \"addr\")\n \t    {\n-\t\tCAddress addr;\n-\t\tssValue >> addr;\n-\t\tmapAddresses.insert(make_pair(addr.GetKey(), addr));\n+\t\t// Read next record\n+\t\tCDataStream ssKey;\n+\t\tCDataStream ssValue;\n+\t\tint ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+\t\tif (ret == DB_NOTFOUND)\n+\t\t    break;\n+\t\telse if (ret != 0)\n+\t\t    return false;\n+\n+\t\t// Unserialize\n+\t\tstring strType;\n+\t\tssKey >> strType;\n+\t\tif (strType == \"addr\")\n+\t\t    {\n+\t\t\tCAddress addr;\n+\t\t\tssValue >> addr;\n+\t\t\tmapAddresses.insert(make_pair(addr.GetKey(), addr));\n+\t\t    }\n \t    }\n-\t}\n \tpcursor->close();\n \n \tprintf(\"Loaded %d addresses\\n\", mapAddresses.size());\n@@ -620,35 +620,35 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n \tthrow runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n     unsigned int fFlags = DB_SET_RANGE;\n     loop\n-    {\n-\t// Read next record\n-\tCDataStream ssKey;\n-\tif (fFlags == DB_SET_RANGE)\n-\t    ssKey << make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64(0));\n-\tCDataStream ssValue;\n-\tint ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-\tfFlags = DB_NEXT;\n-\tif (ret == DB_NOTFOUND)\n-\t    break;\n-\telse if (ret != 0)\n \t{\n-\t    pcursor->close();\n-\t    throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n-\t}\n+\t    // Read next record\n+\t    CDataStream ssKey;\n+\t    if (fFlags == DB_SET_RANGE)\n+\t\tssKey << make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64(0));\n+\t    CDataStream ssValue;\n+\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+\t    fFlags = DB_NEXT;\n+\t    if (ret == DB_NOTFOUND)\n+\t\tbreak;\n+\t    else if (ret != 0)\n+\t\t{\n+\t\t    pcursor->close();\n+\t\t    throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n+\t\t}\n \n-\t// Unserialize\n-\tstring strType;\n-\tssKey >> strType;\n-\tif (strType != \"acentry\")\n-\t    break;\n-\tCAccountingEntry acentry;\n-\tssKey >> acentry.strAccount;\n-\tif (!fAllAccounts && acentry.strAccount != strAccount)\n-\t    break;\n-\n-\tssValue >> acentry;\n-\tentries.push_back(acentry);\n-    }\n+\t    // Unserialize\n+\t    string strType;\n+\t    ssKey >> strType;\n+\t    if (strType != \"acentry\")\n+\t\tbreak;\n+\t    CAccountingEntry acentry;\n+\t    ssKey >> acentry.strAccount;\n+\t    if (!fAllAccounts && acentry.strAccount != strAccount)\n+\t\tbreak;\n+\n+\t    ssValue >> acentry;\n+\t    entries.push_back(acentry);\n+\t}\n \n     pcursor->close();\n }\n@@ -669,132 +669,132 @@ bool CWalletDB::LoadWallet()\n \n     //// todo: shouldn't we catch exceptions and try to recover and continue?\n     CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_mapKeys)\n-    {\n-\t// Get cursor\n-\tDbc* pcursor = GetCursor();\n-\tif (!pcursor)\n-\t    return false;\n-\n-\tloop\n+\tCRITICAL_BLOCK(cs_mapKeys)\n \t{\n-\t    // Read next record\n-\t    CDataStream ssKey;\n-\t    CDataStream ssValue;\n-\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-\t    if (ret == DB_NOTFOUND)\n-\t\tbreak;\n-\t    else if (ret != 0)\n+\t    // Get cursor\n+\t    Dbc* pcursor = GetCursor();\n+\t    if (!pcursor)\n \t\treturn false;\n \n-\t    // Unserialize\n-\t    // Taking advantage of the fact that pair serialization\n-\t    // is just the two items serialized one after the other\n-\t    string strType;\n-\t    ssKey >> strType;\n-\t    if (strType == \"name\")\n-\t    {\n-\t\tstring strAddress;\n-\t\tssKey >> strAddress;\n-\t\tssValue >> mapAddressBook[strAddress];\n-\t    }\n-\t    else if (strType == \"tx\")\n-\t    {\n-\t\tuint256 hash;\n-\t\tssKey >> hash;\n-\t\tCWalletTx& wtx = mapWallet[hash];\n-\t\tssValue >> wtx;\n-\n-\t\tif (wtx.GetHash() != hash)\n-\t\t    printf(\"Error in wallet.dat, hash mismatch\\n\");\n-\n-\t\t// Undo serialize changes in 31600\n-\t\tif (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+\t    loop\n \t\t{\n-\t\t    if (!ssValue.empty())\n-\t\t    {\n-\t\t\tchar fTmp;\n-\t\t\tchar fUnused;\n-\t\t\tssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n-\t\t\tprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\\n\", wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n-\t\t\twtx.fTimeReceivedIsTxTime = fTmp;\n-\t\t    }\n-\t\t    else\n-\t\t    {\n-\t\t\tprintf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n-\t\t\twtx.fTimeReceivedIsTxTime = 0;\n-\t\t    }\n-\t\t    vWalletUpgrade.push_back(hash);\n-\t\t}\n-\n-\t\t//// debug print\n-\t\t//printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n-\t\t//printf(\" %12I64d  %s  %s  %s\\n\",\n-\t\t//    wtx.vout[0].nValue,\n-\t\t//    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n-\t\t//    wtx.hashBlock.ToString().substr(0,20).c_str(),\n-\t\t//    wtx.mapValue[\"message\"].c_str());\n-\t    }\n-\t    else if (strType == \"acentry\")\n-\t    {\n-\t\tstring strAccount;\n-\t\tssKey >> strAccount;\n-\t\tuint64 nNumber;\n-\t\tssKey >> nNumber;\n-\t\tif (nNumber > nAccountingEntryNumber)\n-\t\t    nAccountingEntryNumber = nNumber;\n-\t    }\n-\t    else if (strType == \"key\" || strType == \"wkey\")\n-\t    {\n-\t\tvector<unsigned char> vchPubKey;\n-\t\tssKey >> vchPubKey;\n-\t\tCWalletKey wkey;\n-\t\tif (strType == \"key\")\n-\t\t    ssValue >> wkey.vchPrivKey;\n-\t\telse\n-\t\t    ssValue >> wkey;\n-\n-\t\tmapKeys[vchPubKey] = wkey.vchPrivKey;\n-\t\tmapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n-\t    }\n-\t    else if (strType == \"defaultkey\")\n-\t    {\n-\t\tssValue >> vchDefaultKey;\n-\t    }\n-\t    else if (strType == \"pool\")\n-\t    {\n-\t\tint64 nIndex;\n-\t\tssKey >> nIndex;\n-\t\tsetKeyPool.insert(nIndex);\n-\t    }\n-\t    else if (strType == \"version\")\n-\t    {\n-\t\tssValue >> nFileVersion;\n-\t\tif (nFileVersion == 10300)\n-\t\t    nFileVersion = 300;\n-\t    }\n-\t    else if (strType == \"setting\")\n-\t    {\n-\t\tstring strKey;\n-\t\tssKey >> strKey;\n-\n-\t\t// Options\n+\t\t    // Read next record\n+\t\t    CDataStream ssKey;\n+\t\t    CDataStream ssValue;\n+\t\t    int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+\t\t    if (ret == DB_NOTFOUND)\n+\t\t\tbreak;\n+\t\t    else if (ret != 0)\n+\t\t\treturn false;\n+\n+\t\t    // Unserialize\n+\t\t    // Taking advantage of the fact that pair serialization\n+\t\t    // is just the two items serialized one after the other\n+\t\t    string strType;\n+\t\t    ssKey >> strType;\n+\t\t    if (strType == \"name\")\n+\t\t\t{\n+\t\t\t    string strAddress;\n+\t\t\t    ssKey >> strAddress;\n+\t\t\t    ssValue >> mapAddressBook[strAddress];\n+\t\t\t}\n+\t\t    else if (strType == \"tx\")\n+\t\t\t{\n+\t\t\t    uint256 hash;\n+\t\t\t    ssKey >> hash;\n+\t\t\t    CWalletTx& wtx = mapWallet[hash];\n+\t\t\t    ssValue >> wtx;\n+\n+\t\t\t    if (wtx.GetHash() != hash)\n+\t\t\t\tprintf(\"Error in wallet.dat, hash mismatch\\n\");\n+\n+\t\t\t    // Undo serialize changes in 31600\n+\t\t\t    if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+\t\t\t\t{\n+\t\t\t\t    if (!ssValue.empty())\n+\t\t\t\t\t{\n+\t\t\t\t\t    char fTmp;\n+\t\t\t\t\t    char fUnused;\n+\t\t\t\t\t    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n+\t\t\t\t\t    printf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\\n\", wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n+\t\t\t\t\t    wtx.fTimeReceivedIsTxTime = fTmp;\n+\t\t\t\t\t}\n+\t\t\t\t    else\n+\t\t\t\t\t{\n+\t\t\t\t\t    printf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n+\t\t\t\t\t    wtx.fTimeReceivedIsTxTime = 0;\n+\t\t\t\t\t}\n+\t\t\t\t    vWalletUpgrade.push_back(hash);\n+\t\t\t\t}\n+\n+\t\t\t    //// debug print\n+\t\t\t    //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n+\t\t\t    //printf(\" %12I64d  %s  %s  %s\\n\",\n+\t\t\t    //    wtx.vout[0].nValue,\n+\t\t\t    //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n+\t\t\t    //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n+\t\t\t    //    wtx.mapValue[\"message\"].c_str());\n+\t\t\t}\n+\t\t    else if (strType == \"acentry\")\n+\t\t\t{\n+\t\t\t    string strAccount;\n+\t\t\t    ssKey >> strAccount;\n+\t\t\t    uint64 nNumber;\n+\t\t\t    ssKey >> nNumber;\n+\t\t\t    if (nNumber > nAccountingEntryNumber)\n+\t\t\t\tnAccountingEntryNumber = nNumber;\n+\t\t\t}\n+\t\t    else if (strType == \"key\" || strType == \"wkey\")\n+\t\t\t{\n+\t\t\t    vector<unsigned char> vchPubKey;\n+\t\t\t    ssKey >> vchPubKey;\n+\t\t\t    CWalletKey wkey;\n+\t\t\t    if (strType == \"key\")\n+\t\t\t\tssValue >> wkey.vchPrivKey;\n+\t\t\t    else\n+\t\t\t\tssValue >> wkey;\n+\n+\t\t\t    mapKeys[vchPubKey] = wkey.vchPrivKey;\n+\t\t\t    mapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n+\t\t\t}\n+\t\t    else if (strType == \"defaultkey\")\n+\t\t\t{\n+\t\t\t    ssValue >> vchDefaultKey;\n+\t\t\t}\n+\t\t    else if (strType == \"pool\")\n+\t\t\t{\n+\t\t\t    int64 nIndex;\n+\t\t\t    ssKey >> nIndex;\n+\t\t\t    setKeyPool.insert(nIndex);\n+\t\t\t}\n+\t\t    else if (strType == \"version\")\n+\t\t\t{\n+\t\t\t    ssValue >> nFileVersion;\n+\t\t\t    if (nFileVersion == 10300)\n+\t\t\t\tnFileVersion = 300;\n+\t\t\t}\n+\t\t    else if (strType == \"setting\")\n+\t\t\t{\n+\t\t\t    string strKey;\n+\t\t\t    ssKey >> strKey;\n+\n+\t\t\t    // Options\n #ifndef GUI\n-\t\tif (strKey == \"fGenerateBitcoins\")  ssValue >> fGenerateBitcoins;\n+\t\t\t    if (strKey == \"fGenerateBitcoins\")  ssValue >> fGenerateBitcoins;\n #endif\n-\t\tif (strKey == \"nTransactionFee\")    ssValue >> nTransactionFee;\n-\t\tif (strKey == \"addrIncoming\")       ssValue >> addrIncoming;\n-\t\tif (strKey == \"fLimitProcessors\")   ssValue >> fLimitProcessors;\n-\t\tif (strKey == \"nLimitProcessors\")   ssValue >> nLimitProcessors;\n-\t\tif (strKey == \"fMinimizeToTray\")    ssValue >> fMinimizeToTray;\n-\t\tif (strKey == \"fMinimizeOnClose\")   ssValue >> fMinimizeOnClose;\n-\t\tif (strKey == \"fUseProxy\")          ssValue >> fUseProxy;\n-\t\tif (strKey == \"addrProxy\")          ssValue >> addrProxy;\n-\t\tif (fHaveUPnP && strKey == \"fUseUPnP\")           ssValue >> fUseUPnP;\n-\t    }\n+\t\t\t    if (strKey == \"nTransactionFee\")    ssValue >> nTransactionFee;\n+\t\t\t    if (strKey == \"addrIncoming\")       ssValue >> addrIncoming;\n+\t\t\t    if (strKey == \"fLimitProcessors\")   ssValue >> fLimitProcessors;\n+\t\t\t    if (strKey == \"nLimitProcessors\")   ssValue >> nLimitProcessors;\n+\t\t\t    if (strKey == \"fMinimizeToTray\")    ssValue >> fMinimizeToTray;\n+\t\t\t    if (strKey == \"fMinimizeOnClose\")   ssValue >> fMinimizeOnClose;\n+\t\t\t    if (strKey == \"fUseProxy\")          ssValue >> fUseProxy;\n+\t\t\t    if (strKey == \"addrProxy\")          ssValue >> addrProxy;\n+\t\t\t    if (fHaveUPnP && strKey == \"fUseUPnP\")           ssValue >> fUseUPnP;\n+\t\t\t}\n+\t\t}\n+\t    pcursor->close();\n \t}\n-\tpcursor->close();\n-    }\n \n     foreach(uint256 hash, vWalletUpgrade)\n \tWriteTx(hash, mapWallet[hash]);\n@@ -813,13 +813,13 @@ bool CWalletDB::LoadWallet()\n \n     // Upgrade\n     if (nFileVersion < VERSION)\n-    {\n-\t// Get rid of old debug.log file in current directory\n-\tif (nFileVersion <= 105 && !pszSetDataDir[0])\n-\t    unlink(\"debug.log\");\n+\t{\n+\t    // Get rid of old debug.log file in current directory\n+\t    if (nFileVersion <= 105 && !pszSetDataDir[0])\n+\t\tunlink(\"debug.log\");\n \n-\tWriteVersion(VERSION);\n-    }\n+\t    WriteVersion(VERSION);\n+\t}\n \n \n     return true;\n@@ -833,22 +833,22 @@ bool LoadWallet(bool& fFirstRunRet)\n     fFirstRunRet = vchDefaultKey.empty();\n \n     if (mapKeys.count(vchDefaultKey))\n-    {\n-\t// Set keyUser\n-\tkeyUser.SetPubKey(vchDefaultKey);\n-\tkeyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n-    }\n+\t{\n+\t    // Set keyUser\n+\t    keyUser.SetPubKey(vchDefaultKey);\n+\t    keyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n+\t}\n     else\n-    {\n-\t// Create new keyUser and set as default key\n-\tRandAddSeedPerfmon();\n-\tkeyUser.MakeNewKey();\n-\tif (!AddKey(keyUser))\n-\t    return false;\n-\tif (!SetAddressBookName(PubKeyToAddress(keyUser.GetPubKey()), \"\"))\n-\t    return false;\n-\tCWalletDB().WriteDefaultKey(keyUser.GetPubKey());\n-    }\n+\t{\n+\t    // Create new keyUser and set as default key\n+\t    RandAddSeedPerfmon();\n+\t    keyUser.MakeNewKey();\n+\t    if (!AddKey(keyUser))\n+\t\treturn false;\n+\t    if (!SetAddressBookName(PubKeyToAddress(keyUser.GetPubKey()), \"\"))\n+\t\treturn false;\n+\t    CWalletDB().WriteDefaultKey(keyUser.GetPubKey());\n+\t}\n \n     CreateThread(ThreadFlushWalletDB, NULL);\n     return true;\n@@ -867,85 +867,85 @@ void ThreadFlushWalletDB(void* parg)\n     unsigned int nLastFlushed = nWalletDBUpdated;\n     int64 nLastWalletUpdate = GetTime();\n     while (!fShutdown)\n-    {\n-\tSleep(500);\n-\n-\tif (nLastSeen != nWalletDBUpdated)\n \t{\n-\t    nLastSeen = nWalletDBUpdated;\n-\t    nLastWalletUpdate = GetTime();\n-\t}\n+\t    Sleep(500);\n \n-\tif (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n-\t{\n-\t    TRY_CRITICAL_BLOCK(cs_db)\n-\t    {\n-\t\t// Don't do this if any databases are in use\n-\t\tint nRefCount = 0;\n-\t\tmap<string, int>::iterator mi = mapFileUseCount.begin();\n-\t\twhile (mi != mapFileUseCount.end())\n+\t    if (nLastSeen != nWalletDBUpdated)\n \t\t{\n-\t\t    nRefCount += (*mi).second;\n-\t\t    mi++;\n+\t\t    nLastSeen = nWalletDBUpdated;\n+\t\t    nLastWalletUpdate = GetTime();\n \t\t}\n \n-\t\tif (nRefCount == 0 && !fShutdown)\n+\t    if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n \t\t{\n-\t\t    string strFile = \"wallet.dat\";\n-\t\t    map<string, int>::iterator mi = mapFileUseCount.find(strFile);\n-\t\t    if (mi != mapFileUseCount.end())\n+\t\t    TRY_CRITICAL_BLOCK(cs_db)\n \t\t    {\n-\t\t\tprintf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-\t\t\tprintf(\"Flushing wallet.dat\\n\");\n-\t\t\tnLastFlushed = nWalletDBUpdated;\n-\t\t\tint64 nStart = GetTimeMillis();\n-\n-\t\t\t// Flush wallet.dat so it's self contained\n-\t\t\tCloseDb(strFile);\n-\t\t\tdbenv.txn_checkpoint(0, 0, 0);\n-\t\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n-\n-\t\t\tmapFileUseCount.erase(mi++);\n-\t\t\tprintf(\"Flushed wallet.dat %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+\t\t\t// Don't do this if any databases are in use\n+\t\t\tint nRefCount = 0;\n+\t\t\tmap<string, int>::iterator mi = mapFileUseCount.begin();\n+\t\t\twhile (mi != mapFileUseCount.end())\n+\t\t\t    {\n+\t\t\t\tnRefCount += (*mi).second;\n+\t\t\t\tmi++;\n+\t\t\t    }\n+\n+\t\t\tif (nRefCount == 0 && !fShutdown)\n+\t\t\t    {\n+\t\t\t\tstring strFile = \"wallet.dat\";\n+\t\t\t\tmap<string, int>::iterator mi = mapFileUseCount.find(strFile);\n+\t\t\t\tif (mi != mapFileUseCount.end())\n+\t\t\t\t    {\n+\t\t\t\t\tprintf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\t\t\t\t\tprintf(\"Flushing wallet.dat\\n\");\n+\t\t\t\t\tnLastFlushed = nWalletDBUpdated;\n+\t\t\t\t\tint64 nStart = GetTimeMillis();\n+\n+\t\t\t\t\t// Flush wallet.dat so it's self contained\n+\t\t\t\t\tCloseDb(strFile);\n+\t\t\t\t\tdbenv.txn_checkpoint(0, 0, 0);\n+\t\t\t\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n+\n+\t\t\t\t\tmapFileUseCount.erase(mi++);\n+\t\t\t\t\tprintf(\"Flushed wallet.dat %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+\t\t\t\t    }\n+\t\t\t    }\n \t\t    }\n \t\t}\n-\t    }\n \t}\n-    }\n }\n \n void BackupWallet(const string& strDest)\n {\n     while (!fShutdown)\n-    {\n-\tCRITICAL_BLOCK(cs_db)\n \t{\n-\t    const string strFile = \"wallet.dat\";\n-\t    if (!mapFileUseCount.count(strFile) || mapFileUseCount[strFile] == 0)\n+\t    CRITICAL_BLOCK(cs_db)\n \t    {\n-\t\t// Flush log data to the dat file\n-\t\tCloseDb(strFile);\n-\t\tdbenv.txn_checkpoint(0, 0, 0);\n-\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n-\t\tmapFileUseCount.erase(strFile);\n-\n-\t\t// Copy wallet.dat\n-\t\tfilesystem::path pathSrc(GetDataDir() + \"/\" + strFile);\n-\t\tfilesystem::path pathDest(strDest);\n-\t\tif (filesystem::is_directory(pathDest))\n-\t\t    pathDest = pathDest / strFile;\n+\t\tconst string strFile = \"wallet.dat\";\n+\t\tif (!mapFileUseCount.count(strFile) || mapFileUseCount[strFile] == 0)\n+\t\t    {\n+\t\t\t// Flush log data to the dat file\n+\t\t\tCloseDb(strFile);\n+\t\t\tdbenv.txn_checkpoint(0, 0, 0);\n+\t\t\tdbenv.lsn_reset(strFile.c_str(), 0);\n+\t\t\tmapFileUseCount.erase(strFile);\n+\n+\t\t\t// Copy wallet.dat\n+\t\t\tfilesystem::path pathSrc(GetDataDir() + \"/\" + strFile);\n+\t\t\tfilesystem::path pathDest(strDest);\n+\t\t\tif (filesystem::is_directory(pathDest))\n+\t\t\t    pathDest = pathDest / strFile;\n #if BOOST_VERSION >= 104000\n-\t\tfilesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n+\t\t\tfilesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n #else\n-\t\tfilesystem::copy_file(pathSrc, pathDest);\n+\t\t\tfilesystem::copy_file(pathSrc, pathDest);\n #endif\n-\t\tprintf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n+\t\t\tprintf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n \n-\t\treturn;\n+\t\t\treturn;\n+\t\t    }\n \t    }\n+\t    Sleep(100);\n \t}\n-\tSleep(100);\n-    }\n }\n \n \n@@ -987,10 +987,10 @@ void CWalletDB::KeepKey(int64 nIndex)\n {\n     // Remove from key pool\n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-\tErase(make_pair(string(\"pool\"), nIndex));\n-    }\n+\tCRITICAL_BLOCK(cs_mapWallet)\n+\t{\n+\t    Erase(make_pair(string(\"pool\"), nIndex));\n+\t}\n     printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n }\n "
      },
      {
        "sha": "7426f4f562ca76a1effdf5281e5d45de14498438",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 23,
        "deletions": 18,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef DB_H\n+#define DB_H\n+\n class CTransaction;\n class CTxIndex;\n class CDiskBlockIndex;\n@@ -167,16 +170,16 @@ class CDB\n \t// Read at cursor\n \tDbt datKey;\n \tif (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n-\t{\n-\t    datKey.set_data(&ssKey[0]);\n-\t    datKey.set_size(ssKey.size());\n-\t}\n+\t    {\n+\t\tdatKey.set_data(&ssKey[0]);\n+\t\tdatKey.set_size(ssKey.size());\n+\t    }\n \tDbt datValue;\n \tif (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n-\t{\n-\t    datValue.set_data(&ssValue[0]);\n-\t    datValue.set_size(ssValue.size());\n-\t}\n+\t    {\n+\t\tdatValue.set_data(&ssValue[0]);\n+\t\tdatValue.set_size(ssValue.size());\n+\t    }\n \tdatKey.set_flags(DB_DBT_MALLOC);\n \tdatValue.set_flags(DB_DBT_MALLOC);\n \tint ret = pcursor->get(&datKey, &datValue, fFlags);\n@@ -333,11 +336,11 @@ class CKeyPool\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (!(nType & SER_GETHASH))\n-\t    READWRITE(nVersion);\n-\tREADWRITE(nTime);\n-\tREADWRITE(vchPubKey);\n-    )\n+     if (!(nType & SER_GETHASH))\n+\t READWRITE(nVersion);\n+     READWRITE(nTime);\n+     READWRITE(vchPubKey);\n+     )\n };\n \n \n@@ -487,11 +490,11 @@ class CReserveKey\n     vector<unsigned char> GetReservedKey()\n     {\n \tif (nIndex == -1)\n-\t{\n-\t    CKeyPool keypool;\n-\t    CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n-\t    vchPubKey = keypool.vchPubKey;\n-\t}\n+\t    {\n+\t\tCKeyPool keypool;\n+\t\tCWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n+\t\tvchPubKey = keypool.vchPubKey;\n+\t    }\n \tassert(!vchPubKey.empty());\n \treturn vchPubKey;\n     }\n@@ -512,3 +515,5 @@ class CReserveKey\n \tvchPubKey.clear();\n     }\n };\n+\n+#endif // !DB_H"
      },
      {
        "sha": "8ec118ba37bbe4a629da4641adf88dcd3882c65b",
        "filename": "src/headers.h",
        "status": "modified",
        "additions": 57,
        "deletions": 40,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/headers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/headers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/headers.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,38 +2,49 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef HEADERS_H\n+#define HEADERS_H\n+\n #ifdef _MSC_VER\n-#pragma warning(disable:4786)\n-#pragma warning(disable:4804)\n-#pragma warning(disable:4805)\n-#pragma warning(disable:4717)\n+# pragma warning(disable:4786)\n+# pragma warning(disable:4804)\n+# pragma warning(disable:4805)\n+# pragma warning(disable:4717)\n #endif\n+\n #ifdef _WIN32_WINNT\n-#undef _WIN32_WINNT\n+# undef _WIN32_WINNT\n #endif\n+\n #define _WIN32_WINNT 0x0500\n+\n #ifdef _WIN32_IE\n-#undef _WIN32_IE\n+# undef _WIN32_IE\n #endif\n+\n #define _WIN32_IE 0x0400\n #define WIN32_LEAN_AND_MEAN 1\n #define __STDC_LIMIT_MACROS // to enable UINT64_MAX from stdint.h\n+\n #if (defined(__unix__) || defined(unix)) && !defined(USG)\n-#include <sys/param.h>  // to get BSD define\n+# include <sys/param.h>  // to get BSD define\n #endif\n+\n #ifdef __WXMAC_OSX__\n-#ifndef BSD\n-#define BSD 1\n-#endif\n+# ifndef BSD\n+#  define BSD 1\n+# endif\n #endif\n+\n #ifdef GUI\n-#include <wx/wx.h>\n-#include <wx/stdpaths.h>\n-#include <wx/snglinst.h>\n-#include <wx/utils.h>\n-#include <wx/clipbrd.h>\n-#include <wx/taskbar.h>\n+# include <wx/wx.h>\n+# include <wx/stdpaths.h>\n+# include <wx/snglinst.h>\n+# include <wx/utils.h>\n+# include <wx/clipbrd.h>\n+# include <wx/taskbar.h>\n #endif\n+\n #include <openssl/buffer.h>\n #include <openssl/ecdsa.h>\n #include <openssl/evp.h>\n@@ -81,34 +92,36 @@\n #include <boost/program_options/parsers.hpp>\n \n #ifdef __WXMSW__\n-#include <windows.h>\n-#include <winsock2.h>\n-#include <mswsock.h>\n-#include <shlobj.h>\n-#include <shlwapi.h>\n-#include <io.h>\n-#include <process.h>\n-#include <malloc.h>\n+# include <windows.h>\n+# include <winsock2.h>\n+# include <mswsock.h>\n+# include <shlobj.h>\n+# include <shlwapi.h>\n+# include <io.h>\n+# include <process.h>\n+# include <malloc.h>\n #else\n-#include <sys/time.h>\n-#include <sys/resource.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <arpa/inet.h>\n-#include <netdb.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <net/if.h>\n-#include <ifaddrs.h>\n-#include <fcntl.h>\n-#include <signal.h>\n+# include <sys/time.h>\n+# include <sys/resource.h>\n+# include <sys/socket.h>\n+# include <sys/stat.h>\n+# include <arpa/inet.h>\n+# include <netdb.h>\n+# include <unistd.h>\n+# include <errno.h>\n+# include <net/if.h>\n+# include <ifaddrs.h>\n+# include <fcntl.h>\n+# include <signal.h>\n #endif\n+\n #ifdef BSD\n-#include <netinet/in.h>\n+# include <netinet/in.h>\n #endif\n \n \n #pragma hdrstop\n+\n using namespace std;\n using namespace boost;\n \n@@ -125,12 +138,14 @@ using namespace boost;\n #include \"irc.h\"\n #include \"main.h\"\n #include \"rpc.h\"\n+\n #ifdef GUI\n-#include \"uibase.h\"\n-#include \"ui.h\"\n+# include \"uibase.h\"\n+# include \"ui.h\"\n #else\n-#include \"noui.h\"\n+# include \"noui.h\"\n #endif\n+\n #include \"init.h\"\n \n #include \"xpm/addressbook16.xpm\"\n@@ -145,3 +160,5 @@ using namespace boost;\n #include \"xpm/send16noshadow.xpm\"\n #include \"xpm/send20.xpm\"\n #include \"xpm/about.xpm\"\n+\n+#endif // !HEADERS_H"
      },
      {
        "sha": "8b7ab4c23b809aa5a798a143c21883e37d4caaa3",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 207,
        "deletions": 207,
        "changes": 414,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -35,26 +35,26 @@ void Shutdown(void* parg)\n     }\n     static bool fExit;\n     if (fFirstThread)\n-    {\n-\tfShutdown = true;\n-\tnTransactionsUpdated++;\n-\tDBFlush(false);\n-\tStopNode();\n-\tDBFlush(true);\n-\tboost::filesystem::remove(GetPidFile());\n-\tCreateThread(ExitTimeout, NULL);\n-\tSleep(50);\n-\tprintf(\"Bitcoin exiting\\n\\n\");\n-\tfExit = true;\n-\texit(0);\n-    }\n+\t{\n+\t    fShutdown = true;\n+\t    nTransactionsUpdated++;\n+\t    DBFlush(false);\n+\t    StopNode();\n+\t    DBFlush(true);\n+\t    boost::filesystem::remove(GetPidFile());\n+\t    CreateThread(ExitTimeout, NULL);\n+\t    Sleep(50);\n+\t    printf(\"Bitcoin exiting\\n\\n\");\n+\t    fExit = true;\n+\t    exit(0);\n+\t}\n     else\n-    {\n-\twhile (!fExit)\n-\t    Sleep(500);\n-\tSleep(100);\n-\tExitThread(0);\n-    }\n+\t{\n+\t    while (!fExit)\n+\t\tSleep(500);\n+\t    Sleep(100);\n+\t    ExitThread(0);\n+\t}\n }\n \n void HandleSIGTERM(int)\n@@ -89,9 +89,9 @@ bool AppInit(int argc, char* argv[])\n {\n     bool fRet = false;\n     try\n-    {\n-\tfRet = AppInit2(argc, argv);\n-    }\n+\t{\n+\t    fRet = AppInit2(argc, argv);\n+\t}\n     catch (std::exception& e) {\n \tPrintException(&e, \"AppInit()\");\n     } catch (...) {\n@@ -133,80 +133,80 @@ bool AppInit2(int argc, char* argv[])\n     ParseParameters(argc, argv);\n \n     if (mapArgs.count(\"-datadir\"))\n-    {\n-\tfilesystem::path pathDataDir = filesystem::system_complete(mapArgs[\"-datadir\"]);\n-\tstrlcpy(pszSetDataDir, pathDataDir.string().c_str(), sizeof(pszSetDataDir));\n-    }\n+\t{\n+\t    filesystem::path pathDataDir = filesystem::system_complete(mapArgs[\"-datadir\"]);\n+\t    strlcpy(pszSetDataDir, pathDataDir.string().c_str(), sizeof(pszSetDataDir));\n+\t}\n \n     ReadConfigFile(mapArgs, mapMultiArgs); // Must be done after processing datadir\n \n     if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n-    {\n-\tstring beta = VERSION_IS_BETA ? _(\" beta\") : \"\";\n-\tstring strUsage = string() +\n-\t  _(\"Bitcoin version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n-\t  _(\"Usage:\") + \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\" +\n-\t    \"  bitcoin [options]                   \\t  \" + \"\\n\" +\n-\t    \"  bitcoin [options] <command> [params]\\t  \" + _(\"Send command to -server or bitcoind\\n\") +\n-\t    \"  bitcoin [options] help              \\t\\t  \" + _(\"List commands\\n\") +\n-\t    \"  bitcoin [options] help <command>    \\t\\t  \" + _(\"Get help for a command\\n\") +\n-\t  _(\"Options:\\n\") +\n-\t    \"  -conf=<file>     \\t\\t  \" + _(\"Specify configuration file (default: bitcoin.conf)\\n\") +\n-\t    \"  -pid=<file>      \\t\\t  \" + _(\"Specify pid file (default: bitcoind.pid)\\n\") +\n-\t    \"  -gen             \\t\\t  \" + _(\"Generate coins\\n\") +\n-\t    \"  -gen=0           \\t\\t  \" + _(\"Don't generate coins\\n\") +\n-\t    \"  -min             \\t\\t  \" + _(\"Start minimized\\n\") +\n-\t    \"  -datadir=<dir>   \\t\\t  \" + _(\"Specify data directory\\n\") +\n-\t    \"  -proxy=<ip:port> \\t  \"   + _(\"Connect through socks4 proxy\\n\") +\n-\t    \"  -dns             \\t  \"   + _(\"Allow DNS lookups for addnode and connect\\n\") +\n-\t    \"  -addnode=<ip>    \\t  \"   + _(\"Add a node to connect to\\n\") +\n-\t    \"  -connect=<ip>    \\t\\t  \" + _(\"Connect only to the specified node\\n\") +\n-\t    \"  -nolisten        \\t  \"   + _(\"Don't accept connections from outside\\n\") +\n+\t{\n+\t    string beta = VERSION_IS_BETA ? _(\" beta\") : \"\";\n+\t    string strUsage = string() +\n+\t\t_(\"Bitcoin version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n+\t\t_(\"Usage:\") + \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\" +\n+\t\t\"  bitcoin [options]                   \\t  \" + \"\\n\" +\n+\t\t\"  bitcoin [options] <command> [params]\\t  \" + _(\"Send command to -server or bitcoind\\n\") +\n+\t\t\"  bitcoin [options] help              \\t\\t  \" + _(\"List commands\\n\") +\n+\t\t\"  bitcoin [options] help <command>    \\t\\t  \" + _(\"Get help for a command\\n\") +\n+\t\t_(\"Options:\\n\") +\n+\t\t\"  -conf=<file>     \\t\\t  \" + _(\"Specify configuration file (default: bitcoin.conf)\\n\") +\n+\t\t\"  -pid=<file>      \\t\\t  \" + _(\"Specify pid file (default: bitcoind.pid)\\n\") +\n+\t\t\"  -gen             \\t\\t  \" + _(\"Generate coins\\n\") +\n+\t\t\"  -gen=0           \\t\\t  \" + _(\"Don't generate coins\\n\") +\n+\t\t\"  -min             \\t\\t  \" + _(\"Start minimized\\n\") +\n+\t\t\"  -datadir=<dir>   \\t\\t  \" + _(\"Specify data directory\\n\") +\n+\t\t\"  -proxy=<ip:port> \\t  \"   + _(\"Connect through socks4 proxy\\n\") +\n+\t\t\"  -dns             \\t  \"   + _(\"Allow DNS lookups for addnode and connect\\n\") +\n+\t\t\"  -addnode=<ip>    \\t  \"   + _(\"Add a node to connect to\\n\") +\n+\t\t\"  -connect=<ip>    \\t\\t  \" + _(\"Connect only to the specified node\\n\") +\n+\t\t\"  -nolisten        \\t  \"   + _(\"Don't accept connections from outside\\n\") +\n #ifdef USE_UPNP\n #if USE_UPNP\n-\t    \"  -noupnp          \\t  \"   + _(\"Don't attempt to use UPnP to map the listening port\\n\") +\n+\t\t\"  -noupnp          \\t  \"   + _(\"Don't attempt to use UPnP to map the listening port\\n\") +\n #else\n-\t    \"  -upnp            \\t  \"   + _(\"Attempt to use UPnP to map the listening port\\n\") +\n+\t\t\"  -upnp            \\t  \"   + _(\"Attempt to use UPnP to map the listening port\\n\") +\n #endif\n #endif\n-\t    \"  -paytxfee=<amt>  \\t  \"   + _(\"Fee per KB to add to transactions you send\\n\") +\n+\t\t\"  -paytxfee=<amt>  \\t  \"   + _(\"Fee per KB to add to transactions you send\\n\") +\n #ifdef GUI\n-\t    \"  -server          \\t\\t  \" + _(\"Accept command line and JSON-RPC commands\\n\") +\n+\t\t\"  -server          \\t\\t  \" + _(\"Accept command line and JSON-RPC commands\\n\") +\n #endif\n #ifndef __WXMSW__\n-\t    \"  -daemon          \\t\\t  \" + _(\"Run in the background as a daemon and accept commands\\n\") +\n+\t\t\"  -daemon          \\t\\t  \" + _(\"Run in the background as a daemon and accept commands\\n\") +\n #endif\n-\t    \"  -testnet         \\t\\t  \" + _(\"Use the test network\\n\") +\n-\t    \"  -rpcuser=<user>  \\t  \"   + _(\"Username for JSON-RPC connections\\n\") +\n-\t    \"  -rpcpassword=<pw>\\t  \"   + _(\"Password for JSON-RPC connections\\n\") +\n-\t    \"  -rpcport=<port>  \\t\\t  \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332)\\n\") +\n-\t    \"  -rpcallowip=<ip> \\t\\t  \" + _(\"Allow JSON-RPC connections from specified IP address\\n\") +\n-\t    \"  -rpcconnect=<ip> \\t  \"   + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\\n\") +\n-\t    \"  -keypool=<n>     \\t  \"   + _(\"Set key pool size to <n> (default: 100)\\n\") +\n-\t    \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\");\n+\t\t\"  -testnet         \\t\\t  \" + _(\"Use the test network\\n\") +\n+\t\t\"  -rpcuser=<user>  \\t  \"   + _(\"Username for JSON-RPC connections\\n\") +\n+\t\t\"  -rpcpassword=<pw>\\t  \"   + _(\"Password for JSON-RPC connections\\n\") +\n+\t\t\"  -rpcport=<port>  \\t\\t  \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332)\\n\") +\n+\t\t\"  -rpcallowip=<ip> \\t\\t  \" + _(\"Allow JSON-RPC connections from specified IP address\\n\") +\n+\t\t\"  -rpcconnect=<ip> \\t  \"   + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\\n\") +\n+\t\t\"  -keypool=<n>     \\t  \"   + _(\"Set key pool size to <n> (default: 100)\\n\") +\n+\t\t\"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\");\n \n #ifdef USE_SSL\n-\tstrUsage += string() +\n-\t    _(\"\\nSSL options: (see the Bitcoin Wiki for SSL setup instructions)\\n\") +\n-\t    \"  -rpcssl                                \\t  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\\n\") +\n-\t    \"  -rpcsslcertificatechainfile=<file.cert>\\t  \" + _(\"Server certificate file (default: server.cert)\\n\") +\n-\t    \"  -rpcsslprivatekeyfile=<file.pem>       \\t  \" + _(\"Server private key (default: server.pem)\\n\") +\n-\t    \"  -rpcsslciphers=<ciphers>               \\t  \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\\n\");\n+\t    strUsage += string() +\n+\t\t_(\"\\nSSL options: (see the Bitcoin Wiki for SSL setup instructions)\\n\") +\n+\t\t\"  -rpcssl                                \\t  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\\n\") +\n+\t\t\"  -rpcsslcertificatechainfile=<file.cert>\\t  \" + _(\"Server certificate file (default: server.cert)\\n\") +\n+\t\t\"  -rpcsslprivatekeyfile=<file.pem>       \\t  \" + _(\"Server private key (default: server.pem)\\n\") +\n+\t\t\"  -rpcsslciphers=<ciphers>               \\t  \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\\n\");\n #endif\n \n-\tstrUsage += string() +\n-\t    \"  -?               \\t\\t  \" + _(\"This help message\\n\");\n+\t    strUsage += string() +\n+\t\t\"  -?               \\t\\t  \" + _(\"This help message\\n\");\n \n #if defined(__WXMSW__) && defined(GUI)\n-\t// Tabs make the columns line up in the message box\n-\twxMessageBox(strUsage, \"Bitcoin\", wxOK);\n+\t    // Tabs make the columns line up in the message box\n+\t    wxMessageBox(strUsage, \"Bitcoin\", wxOK);\n #else\n-\t// Remove tabs\n-\tstrUsage.erase(std::remove(strUsage.begin(), strUsage.end(), '\\t'), strUsage.end());\n-\tfprintf(stderr, \"%s\", strUsage.c_str());\n+\t    // Remove tabs\n+\t    strUsage.erase(std::remove(strUsage.begin(), strUsage.end(), '\\t'), strUsage.end());\n+\t    fprintf(stderr, \"%s\", strUsage.c_str());\n #endif\n-\treturn false;\n-    }\n+\t    return false;\n+\t}\n \n     fDebug = GetBoolArg(\"-debug\");\n     fAllowDNS = GetBoolArg(\"-dns\");\n@@ -239,31 +239,31 @@ bool AppInit2(int argc, char* argv[])\n \t    fCommandLine = true;\n \n     if (fCommandLine)\n-    {\n-\tint ret = CommandLineRPC(argc, argv);\n-\texit(ret);\n-    }\n+\t{\n+\t    int ret = CommandLineRPC(argc, argv);\n+\t    exit(ret);\n+\t}\n \n #ifndef __WXMSW__\n     if (fDaemon)\n-    {\n-\t// Daemonize\n-\tpid_t pid = fork();\n-\tif (pid < 0)\n \t{\n-\t    fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n-\t    return false;\n+\t    // Daemonize\n+\t    pid_t pid = fork();\n+\t    if (pid < 0)\n+\t\t{\n+\t\t    fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n+\t\t    return false;\n+\t\t}\n+\t    if (pid > 0)\n+\t\t{\n+\t\t    CreatePidFile(GetPidFile(), pid);\n+\t\t    return true;\n+\t\t}\n+\n+\t    pid_t sid = setsid();\n+\t    if (sid < 0)\n+\t\tfprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n \t}\n-\tif (pid > 0)\n-\t{\n-\t    CreatePidFile(GetPidFile(), pid);\n-\t    return true;\n-\t}\n-\n-\tpid_t sid = setsid();\n-\tif (sid < 0)\n-\t    fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n-    }\n #endif\n \n     if (!fDebug && !pszSetDataDir[0])\n@@ -278,12 +278,12 @@ bool AppInit2(int argc, char* argv[])\n     printf(\"Default data directory %s\\n\", GetDefaultDataDir().c_str());\n \n     if (GetBoolArg(\"-loadblockindextest\"))\n-    {\n-\tCTxDB txdb(\"r\");\n-\ttxdb.LoadBlockIndex();\n-\tPrintBlockTree();\n-\treturn false;\n-    }\n+\t{\n+\t    CTxDB txdb(\"r\");\n+\t    txdb.LoadBlockIndex();\n+\t    PrintBlockTree();\n+\t    return false;\n+\t}\n \n     //\n     // Limit to single instance per user\n@@ -297,32 +297,32 @@ bool AppInit2(int argc, char* argv[])\n \t    strMutexName[i] = '.';\n     wxSingleInstanceChecker* psingleinstancechecker = new wxSingleInstanceChecker(strMutexName);\n     if (psingleinstancechecker->IsAnotherRunning())\n-    {\n-\tprintf(\"Existing instance found\\n\");\n-\tunsigned int nStart = GetTime();\n-\tloop\n \t{\n-\t    // Show the previous instance and exit\n-\t    HWND hwndPrev = FindWindowA(\"wxWindowClassNR\", \"Bitcoin\");\n-\t    if (hwndPrev)\n-\t    {\n-\t\tif (IsIconic(hwndPrev))\n-\t\t    ShowWindow(hwndPrev, SW_RESTORE);\n-\t\tSetForegroundWindow(hwndPrev);\n-\t\treturn false;\n-\t    }\n-\n-\t    if (GetTime() > nStart + 60)\n-\t\treturn false;\n-\n-\t    // Resume this instance if the other exits\n-\t    delete psingleinstancechecker;\n-\t    Sleep(1000);\n-\t    psingleinstancechecker = new wxSingleInstanceChecker(strMutexName);\n-\t    if (!psingleinstancechecker->IsAnotherRunning())\n-\t\tbreak;\n+\t    printf(\"Existing instance found\\n\");\n+\t    unsigned int nStart = GetTime();\n+\t    loop\n+\t\t{\n+\t\t    // Show the previous instance and exit\n+\t\t    HWND hwndPrev = FindWindowA(\"wxWindowClassNR\", \"Bitcoin\");\n+\t\t    if (hwndPrev)\n+\t\t\t{\n+\t\t\t    if (IsIconic(hwndPrev))\n+\t\t\t\tShowWindow(hwndPrev, SW_RESTORE);\n+\t\t\t    SetForegroundWindow(hwndPrev);\n+\t\t\t    return false;\n+\t\t\t}\n+\n+\t\t    if (GetTime() > nStart + 60)\n+\t\t\treturn false;\n+\n+\t\t    // Resume this instance if the other exits\n+\t\t    delete psingleinstancechecker;\n+\t\t    Sleep(1000);\n+\t\t    psingleinstancechecker = new wxSingleInstanceChecker(strMutexName);\n+\t\t    if (!psingleinstancechecker->IsAnotherRunning())\n+\t\t\tbreak;\n+\t\t}\n \t}\n-    }\n #endif\n \n     // Make sure only a single bitcoin process is using the data directory.\n@@ -331,21 +331,21 @@ bool AppInit2(int argc, char* argv[])\n     if (file) fclose(file);\n     static boost::interprocess::file_lock lock(strLockFile.c_str());\n     if (!lock.try_lock())\n-    {\n-\twxMessageBox(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().c_str()), \"Bitcoin\");\n-\treturn false;\n-    }\n+\t{\n+\t    wxMessageBox(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().c_str()), \"Bitcoin\");\n+\t    return false;\n+\t}\n \n     // Bind to the port early so we can tell if another instance is already running.\n     string strErrors;\n     if (!fNoListen)\n-    {\n-\tif (!BindListenPort(strErrors))\n \t{\n-\t    wxMessageBox(strErrors, \"Bitcoin\");\n-\t    return false;\n+\t    if (!BindListenPort(strErrors))\n+\t\t{\n+\t\t    wxMessageBox(strErrors, \"Bitcoin\");\n+\t\t    return false;\n+\t\t}\n \t}\n-    }\n \n     //\n     // Load data files\n@@ -378,35 +378,35 @@ bool AppInit2(int argc, char* argv[])\n     if (GetBoolArg(\"-rescan\"))\n \tpindexRescan = pindexGenesisBlock;\n     else\n-    {\n-\tCWalletDB walletdb;\n-\tCBlockLocator locator;\n-\tif (walletdb.ReadBestBlock(locator))\n-\t    pindexRescan = locator.GetBlockIndex();\n-    }\n+\t{\n+\t    CWalletDB walletdb;\n+\t    CBlockLocator locator;\n+\t    if (walletdb.ReadBestBlock(locator))\n+\t\tpindexRescan = locator.GetBlockIndex();\n+\t}\n     if (pindexBest != pindexRescan)\n-    {\n-\tprintf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n-\tnStart = GetTimeMillis();\n-\tScanForWalletTransactions(pindexRescan);\n-\tprintf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n-    }\n+\t{\n+\t    printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n+\t    nStart = GetTimeMillis();\n+\t    ScanForWalletTransactions(pindexRescan);\n+\t    printf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+\t}\n \n     printf(\"Done loading\\n\");\n \n-\t//// debug print\n-\tprintf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n-\tprintf(\"nBestHeight = %d\\n\",            nBestHeight);\n-\tprintf(\"mapKeys.size() = %d\\n\",         mapKeys.size());\n-\tprintf(\"mapPubKeys.size() = %d\\n\",      mapPubKeys.size());\n-\tprintf(\"mapWallet.size() = %d\\n\",       mapWallet.size());\n-\tprintf(\"mapAddressBook.size() = %d\\n\",  mapAddressBook.size());\n+    //// debug print\n+    printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n+    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n+    printf(\"mapKeys.size() = %d\\n\",         mapKeys.size());\n+    printf(\"mapPubKeys.size() = %d\\n\",      mapPubKeys.size());\n+    printf(\"mapWallet.size() = %d\\n\",       mapWallet.size());\n+    printf(\"mapAddressBook.size() = %d\\n\",  mapAddressBook.size());\n \n     if (!strErrors.empty())\n-    {\n-\twxMessageBox(strErrors, \"Bitcoin\", wxOK | wxICON_ERROR);\n-\treturn false;\n-    }\n+\t{\n+\t    wxMessageBox(strErrors, \"Bitcoin\", wxOK | wxICON_ERROR);\n+\t    return false;\n+\t}\n \n     // Add wallet transactions that aren't already in a block to mapTransactions\n     ReacceptWalletTransactions();\n@@ -415,82 +415,82 @@ bool AppInit2(int argc, char* argv[])\n     // Parameters\n     //\n     if (GetBoolArg(\"-printblockindex\") || GetBoolArg(\"-printblocktree\"))\n-    {\n-\tPrintBlockTree();\n-\treturn false;\n-    }\n+\t{\n+\t    PrintBlockTree();\n+\t    return false;\n+\t}\n \n     if (mapArgs.count(\"-printblock\"))\n-    {\n-\tstring strMatch = mapArgs[\"-printblock\"];\n-\tint nFound = 0;\n-\tfor (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n \t{\n-\t    uint256 hash = (*mi).first;\n-\t    if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n-\t    {\n-\t\tCBlockIndex* pindex = (*mi).second;\n-\t\tCBlock block;\n-\t\tblock.ReadFromDisk(pindex);\n-\t\tblock.BuildMerkleTree();\n-\t\tblock.print();\n-\t\tprintf(\"\\n\");\n-\t\tnFound++;\n-\t    }\n+\t    string strMatch = mapArgs[\"-printblock\"];\n+\t    int nFound = 0;\n+\t    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n+\t\t{\n+\t\t    uint256 hash = (*mi).first;\n+\t\t    if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n+\t\t\t{\n+\t\t\t    CBlockIndex* pindex = (*mi).second;\n+\t\t\t    CBlock block;\n+\t\t\t    block.ReadFromDisk(pindex);\n+\t\t\t    block.BuildMerkleTree();\n+\t\t\t    block.print();\n+\t\t\t    printf(\"\\n\");\n+\t\t\t    nFound++;\n+\t\t\t}\n+\t\t}\n+\t    if (nFound == 0)\n+\t\tprintf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n+\t    return false;\n \t}\n-\tif (nFound == 0)\n-\t    printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n-\treturn false;\n-    }\n \n     fGenerateBitcoins = GetBoolArg(\"-gen\");\n \n     if (mapArgs.count(\"-proxy\"))\n-    {\n-\tfUseProxy = true;\n-\taddrProxy = CAddress(mapArgs[\"-proxy\"]);\n-\tif (!addrProxy.IsValid())\n \t{\n-\t    wxMessageBox(_(\"Invalid -proxy address\"), \"Bitcoin\");\n-\t    return false;\n+\t    fUseProxy = true;\n+\t    addrProxy = CAddress(mapArgs[\"-proxy\"]);\n+\t    if (!addrProxy.IsValid())\n+\t\t{\n+\t\t    wxMessageBox(_(\"Invalid -proxy address\"), \"Bitcoin\");\n+\t\t    return false;\n+\t\t}\n \t}\n-    }\n \n     if (mapArgs.count(\"-addnode\"))\n-    {\n-\tforeach(string strAddr, mapMultiArgs[\"-addnode\"])\n \t{\n-\t    CAddress addr(strAddr, fAllowDNS);\n-\t    addr.nTime = 0; // so it won't relay unless successfully connected\n-\t    if (addr.IsValid())\n-\t\tAddAddress(addr);\n+\t    foreach(string strAddr, mapMultiArgs[\"-addnode\"])\n+\t\t{\n+\t\t    CAddress addr(strAddr, fAllowDNS);\n+\t\t    addr.nTime = 0; // so it won't relay unless successfully connected\n+\t\t    if (addr.IsValid())\n+\t\t\tAddAddress(addr);\n+\t\t}\n \t}\n-    }\n \n     if (mapArgs.count(\"-dnsseed\"))\n \tDNSAddressSeed();\n \n     if (mapArgs.count(\"-paytxfee\"))\n-    {\n-\tif (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n \t{\n-\t    wxMessageBox(_(\"Invalid amount for -paytxfee=<amount>\"), \"Bitcoin\");\n-\t    return false;\n+\t    if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n+\t\t{\n+\t\t    wxMessageBox(_(\"Invalid amount for -paytxfee=<amount>\"), \"Bitcoin\");\n+\t\t    return false;\n+\t\t}\n+\t    if (nTransactionFee > 0.25 * COIN)\n+\t\twxMessageBox(_(\"Warning: -paytxfee is set very high.  This is the transaction fee you will pay if you send a transaction.\"), \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n \t}\n-\tif (nTransactionFee > 0.25 * COIN)\n-\t    wxMessageBox(_(\"Warning: -paytxfee is set very high.  This is the transaction fee you will pay if you send a transaction.\"), \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n-    }\n \n     if (fHaveUPnP)\n-    {\n+\t{\n #if USE_UPNP\n-    if (GetBoolArg(\"-noupnp\"))\n-\tfUseUPnP = false;\n+\t    if (GetBoolArg(\"-noupnp\"))\n+\t\tfUseUPnP = false;\n #else\n-    if (GetBoolArg(\"-upnp\"))\n-\tfUseUPnP = true;\n+\t    if (GetBoolArg(\"-upnp\"))\n+\t\tfUseUPnP = true;\n #endif\n-    }\n+\t}\n \n     //\n     // Create the main window and start the node"
      },
      {
        "sha": "fe8ae94dc2ca681ff53d76a2b72aa26591e46a87",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,11 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef INIT_H\n+#define INIT_H\n+\n void Shutdown(void* parg);\n bool AppInit(int argc, char* argv[]);\n bool AppInit2(int argc, char* argv[]);\n+\n+#endif // !INIT_H"
      },
      {
        "sha": "1e8d3c380d67c26784269e0a46cf54b0bb58b1b3",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 188,
        "deletions": 188,
        "changes": 376,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -57,12 +57,12 @@ static bool Send(SOCKET hSocket, const char* pszSend)\n     const char* psz = pszSend;\n     const char* pszEnd = psz + strlen(psz);\n     while (psz < pszEnd)\n-    {\n-\tint ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n-\tif (ret < 0)\n-\t    return false;\n-\tpsz += ret;\n-    }\n+\t{\n+\t    int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n+\t    if (ret < 0)\n+\t\treturn false;\n+\t    psz += ret;\n+\t}\n     return true;\n }\n \n@@ -120,44 +120,44 @@ bool RecvLine(SOCKET hSocket, string& strLine)\n bool RecvLineIRC(SOCKET hSocket, string& strLine)\n {\n     loop\n-    {\n-\tbool fRet = RecvLine(hSocket, strLine);\n-\tif (fRet)\n \t{\n-\t    if (fShutdown)\n-\t\treturn false;\n-\t    vector<string> vWords;\n-\t    ParseString(strLine, ' ', vWords);\n-\t    if (vWords.size() >= 1 && vWords[0] == \"PING\")\n-\t    {\n-\t\tstrLine[1] = 'O';\n-\t\tstrLine += '\\r';\n-\t\tSend(hSocket, strLine.c_str());\n-\t\tcontinue;\n-\t    }\n+\t    bool fRet = RecvLine(hSocket, strLine);\n+\t    if (fRet)\n+\t\t{\n+\t\t    if (fShutdown)\n+\t\t\treturn false;\n+\t\t    vector<string> vWords;\n+\t\t    ParseString(strLine, ' ', vWords);\n+\t\t    if (vWords.size() >= 1 && vWords[0] == \"PING\")\n+\t\t\t{\n+\t\t\t    strLine[1] = 'O';\n+\t\t\t    strLine += '\\r';\n+\t\t\t    Send(hSocket, strLine.c_str());\n+\t\t\t    continue;\n+\t\t\t}\n+\t\t}\n+\t    return fRet;\n \t}\n-\treturn fRet;\n-    }\n }\n \n int RecvUntil(SOCKET hSocket, const char* psz1, const char* psz2=NULL, const char* psz3=NULL, const char* psz4=NULL)\n {\n     loop\n-    {\n-\tstring strLine;\n-\tstrLine.reserve(10000);\n-\tif (!RecvLineIRC(hSocket, strLine))\n-\t    return 0;\n-\tprintf(\"IRC %s\\n\", strLine.c_str());\n-\tif (psz1 && strLine.find(psz1) != -1)\n-\t    return 1;\n-\tif (psz2 && strLine.find(psz2) != -1)\n-\t    return 2;\n-\tif (psz3 && strLine.find(psz3) != -1)\n-\t    return 3;\n-\tif (psz4 && strLine.find(psz4) != -1)\n-\t    return 4;\n-    }\n+\t{\n+\t    string strLine;\n+\t    strLine.reserve(10000);\n+\t    if (!RecvLineIRC(hSocket, strLine))\n+\t\treturn 0;\n+\t    printf(\"IRC %s\\n\", strLine.c_str());\n+\t    if (psz1 && strLine.find(psz1) != -1)\n+\t\treturn 1;\n+\t    if (psz2 && strLine.find(psz2) != -1)\n+\t\treturn 2;\n+\t    if (psz3 && strLine.find(psz3) != -1)\n+\t\treturn 3;\n+\t    if (psz4 && strLine.find(psz4) != -1)\n+\t\treturn 4;\n+\t}\n }\n \n bool Wait(int nSeconds)\n@@ -178,23 +178,23 @@ bool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n {\n     strRet.clear();\n     loop\n-    {\n-\tstring strLine;\n-\tif (!RecvLineIRC(hSocket, strLine))\n-\t    return false;\n+\t{\n+\t    string strLine;\n+\t    if (!RecvLineIRC(hSocket, strLine))\n+\t\treturn false;\n \n-\tvector<string> vWords;\n-\tParseString(strLine, ' ', vWords);\n-\tif (vWords.size() < 2)\n-\t    continue;\n+\t    vector<string> vWords;\n+\t    ParseString(strLine, ' ', vWords);\n+\t    if (vWords.size() < 2)\n+\t\tcontinue;\n \n-\tif (vWords[1] == psz1)\n-\t{\n-\t    printf(\"IRC %s\\n\", strLine.c_str());\n-\t    strRet = strLine;\n-\t    return true;\n+\t    if (vWords[1] == psz1)\n+\t\t{\n+\t\t    printf(\"IRC %s\\n\", strLine.c_str());\n+\t\t    strRet = strLine;\n+\t\t    return true;\n+\t\t}\n \t}\n-    }\n }\n \n bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n@@ -234,9 +234,9 @@ void ThreadIRCSeed(void* parg)\n {\n     IMPLEMENT_RANDOMIZE_STACK(ThreadIRCSeed(parg));\n     try\n-    {\n-\tThreadIRCSeed2(parg);\n-    }\n+\t{\n+\t    ThreadIRCSeed2(parg);\n+\t}\n     catch (std::exception& e) {\n \tPrintExceptionContinue(&e, \"ThreadIRCSeed()\");\n     } catch (...) {\n@@ -260,152 +260,152 @@ void ThreadIRCSeed2(void* parg)\n     bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n \n     while (!fShutdown)\n-    {\n-\t//CAddress addrConnect(\"216.155.130.130:6667\"); // chat.freenode.net\n-\tCAddress addrConnect(\"92.243.23.21:6667\"); // irc.lfnet.org\n-\tif (!fTOR)\n-\t{\n-\t    //struct hostent* phostent = gethostbyname(\"chat.freenode.net\");\n-\t    CAddress addrIRC(\"irc.lfnet.org:6667\", 0, true);\n-\t    if (addrIRC.IsValid())\n-\t\taddrConnect = addrIRC;\n-\t}\n-\n-\tSOCKET hSocket;\n-\tif (!ConnectSocket(addrConnect, hSocket))\n-\t{\n-\t    printf(\"IRC connect failed\\n\");\n-\t    nErrorWait = nErrorWait * 11 / 10;\n-\t    if (Wait(nErrorWait += 60))\n-\t\tcontinue;\n-\t    else\n-\t\treturn;\n-\t}\n-\n-\tif (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n \t{\n-\t    closesocket(hSocket);\n-\t    hSocket = INVALID_SOCKET;\n-\t    nErrorWait = nErrorWait * 11 / 10;\n-\t    if (Wait(nErrorWait += 60))\n-\t\tcontinue;\n-\t    else\n-\t\treturn;\n-\t}\n-\n-\tstring strMyName;\n-\tif (addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n-\t    strMyName = EncodeAddress(addrLocalHost);\n-\telse\n-\t    strMyName = strprintf(\"x%u\", GetRand(1000000000));\n+\t    //CAddress addrConnect(\"216.155.130.130:6667\"); // chat.freenode.net\n+\t    CAddress addrConnect(\"92.243.23.21:6667\"); // irc.lfnet.org\n+\t    if (!fTOR)\n+\t\t{\n+\t\t    //struct hostent* phostent = gethostbyname(\"chat.freenode.net\");\n+\t\t    CAddress addrIRC(\"irc.lfnet.org:6667\", 0, true);\n+\t\t    if (addrIRC.IsValid())\n+\t\t\taddrConnect = addrIRC;\n+\t\t}\n \n-\tSend(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n-\tSend(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n+\t    SOCKET hSocket;\n+\t    if (!ConnectSocket(addrConnect, hSocket))\n+\t\t{\n+\t\t    printf(\"IRC connect failed\\n\");\n+\t\t    nErrorWait = nErrorWait * 11 / 10;\n+\t\t    if (Wait(nErrorWait += 60))\n+\t\t\tcontinue;\n+\t\t    else\n+\t\t\treturn;\n+\t\t}\n \n-\tint nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n-\tif (nRet != 1)\n-\t{\n-\t    closesocket(hSocket);\n-\t    hSocket = INVALID_SOCKET;\n-\t    if (nRet == 2)\n-\t    {\n-\t\tprintf(\"IRC name already in use\\n\");\n-\t\tfNameInUse = true;\n-\t\tWait(10);\n-\t\tcontinue;\n-\t    }\n-\t    nErrorWait = nErrorWait * 11 / 10;\n-\t    if (Wait(nErrorWait += 60))\n-\t\tcontinue;\n-\t    else\n-\t\treturn;\n-\t}\n-\tSleep(500);\n+\t    if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n+\t\t{\n+\t\t    closesocket(hSocket);\n+\t\t    hSocket = INVALID_SOCKET;\n+\t\t    nErrorWait = nErrorWait * 11 / 10;\n+\t\t    if (Wait(nErrorWait += 60))\n+\t\t\tcontinue;\n+\t\t    else\n+\t\t\treturn;\n+\t\t}\n \n-\t// Get our external IP from the IRC server and re-nick before joining the channel\n-\tCAddress addrFromIRC;\n-\tif (GetIPFromIRC(hSocket, strMyName, addrFromIRC.ip))\n-\t{\n-\t    printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToStringIP().c_str());\n-\t    if (!fUseProxy && addrFromIRC.IsRoutable())\n-\t    {\n-\t\t// IRC lets you to re-nick\n-\t\tfGotExternalIP = true;\n-\t\taddrLocalHost.ip = addrFromIRC.ip;\n+\t    string strMyName;\n+\t    if (addrLocalHost.IsRoutable() && !fUseProxy && !fNameInUse)\n \t\tstrMyName = EncodeAddress(addrLocalHost);\n-\t\tSend(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n-\t    }\n-\t}\n-\n-\tSend(hSocket, fTestNet ? \"JOIN #bitcoinTEST\\r\" : \"JOIN #bitcoin\\r\");\n-\tSend(hSocket, fTestNet ? \"WHO #bitcoinTEST\\r\"  : \"WHO #bitcoin\\r\");\n-\n-\tint64 nStart = GetTime();\n-\tstring strLine;\n-\tstrLine.reserve(10000);\n-\twhile (!fShutdown && RecvLineIRC(hSocket, strLine))\n-\t{\n-\t    if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n-\t\tcontinue;\n+\t    else\n+\t\tstrMyName = strprintf(\"x%u\", GetRand(1000000000));\n \n-\t    vector<string> vWords;\n-\t    ParseString(strLine, ' ', vWords);\n-\t    if (vWords.size() < 2)\n-\t\tcontinue;\n+\t    Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n+\t    Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n \n-\t    char pszName[10000];\n-\t    pszName[0] = '\\0';\n+\t    int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n+\t    if (nRet != 1)\n+\t\t{\n+\t\t    closesocket(hSocket);\n+\t\t    hSocket = INVALID_SOCKET;\n+\t\t    if (nRet == 2)\n+\t\t\t{\n+\t\t\t    printf(\"IRC name already in use\\n\");\n+\t\t\t    fNameInUse = true;\n+\t\t\t    Wait(10);\n+\t\t\t    continue;\n+\t\t\t}\n+\t\t    nErrorWait = nErrorWait * 11 / 10;\n+\t\t    if (Wait(nErrorWait += 60))\n+\t\t\tcontinue;\n+\t\t    else\n+\t\t\treturn;\n+\t\t}\n+\t    Sleep(500);\n \n-\t    if (vWords[1] == \"352\" && vWords.size() >= 8)\n-\t    {\n-\t\t// index 7 is limited to 16 characters\n-\t\t// could get full length name at index 10, but would be different from join messages\n-\t\tstrlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n-\t\tprintf(\"IRC got who\\n\");\n-\t    }\n+\t    // Get our external IP from the IRC server and re-nick before joining the channel\n+\t    CAddress addrFromIRC;\n+\t    if (GetIPFromIRC(hSocket, strMyName, addrFromIRC.ip))\n+\t\t{\n+\t\t    printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToStringIP().c_str());\n+\t\t    if (!fUseProxy && addrFromIRC.IsRoutable())\n+\t\t\t{\n+\t\t\t    // IRC lets you to re-nick\n+\t\t\t    fGotExternalIP = true;\n+\t\t\t    addrLocalHost.ip = addrFromIRC.ip;\n+\t\t\t    strMyName = EncodeAddress(addrLocalHost);\n+\t\t\t    Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n+\t\t\t}\n+\t\t}\n \n-\t    if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n-\t    {\n-\t\t// :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n-\t\tstrlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n-\t\tif (strchr(pszName, '!'))\n-\t\t    *strchr(pszName, '!') = '\\0';\n-\t\tprintf(\"IRC got join\\n\");\n-\t    }\n+\t    Send(hSocket, fTestNet ? \"JOIN #bitcoinTEST\\r\" : \"JOIN #bitcoin\\r\");\n+\t    Send(hSocket, fTestNet ? \"WHO #bitcoinTEST\\r\"  : \"WHO #bitcoin\\r\");\n \n-\t    if (pszName[0] == 'u')\n-\t    {\n-\t\tCAddress addr;\n-\t\tif (DecodeAddress(pszName, addr))\n+\t    int64 nStart = GetTime();\n+\t    string strLine;\n+\t    strLine.reserve(10000);\n+\t    while (!fShutdown && RecvLineIRC(hSocket, strLine))\n \t\t{\n-\t\t    addr.nTime = GetAdjustedTime();\n-\t\t    if (AddAddress(addr, 51 * 60))\n-\t\t\tprintf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n-\t\t    nGotIRCAddresses++;\n+\t\t    if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n+\t\t\tcontinue;\n+\n+\t\t    vector<string> vWords;\n+\t\t    ParseString(strLine, ' ', vWords);\n+\t\t    if (vWords.size() < 2)\n+\t\t\tcontinue;\n+\n+\t\t    char pszName[10000];\n+\t\t    pszName[0] = '\\0';\n+\n+\t\t    if (vWords[1] == \"352\" && vWords.size() >= 8)\n+\t\t\t{\n+\t\t\t    // index 7 is limited to 16 characters\n+\t\t\t    // could get full length name at index 10, but would be different from join messages\n+\t\t\t    strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n+\t\t\t    printf(\"IRC got who\\n\");\n+\t\t\t}\n+\n+\t\t    if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n+\t\t\t{\n+\t\t\t    // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n+\t\t\t    strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n+\t\t\t    if (strchr(pszName, '!'))\n+\t\t\t\t*strchr(pszName, '!') = '\\0';\n+\t\t\t    printf(\"IRC got join\\n\");\n+\t\t\t}\n+\n+\t\t    if (pszName[0] == 'u')\n+\t\t\t{\n+\t\t\t    CAddress addr;\n+\t\t\t    if (DecodeAddress(pszName, addr))\n+\t\t\t\t{\n+\t\t\t\t    addr.nTime = GetAdjustedTime();\n+\t\t\t\t    if (AddAddress(addr, 51 * 60))\n+\t\t\t\t\tprintf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n+\t\t\t\t    nGotIRCAddresses++;\n+\t\t\t\t}\n+\t\t\t    else\n+\t\t\t\t{\n+\t\t\t\t    printf(\"IRC decode failed\\n\");\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\telse\n+\t    closesocket(hSocket);\n+\t    hSocket = INVALID_SOCKET;\n+\n+\t    // IRC usually blocks TOR, so only try once\n+\t    if (fTOR)\n+\t\treturn;\n+\n+\t    if (GetTime() - nStart > 20 * 60)\n \t\t{\n-\t\t    printf(\"IRC decode failed\\n\");\n+\t\t    nErrorWait /= 3;\n+\t\t    nRetryWait /= 3;\n \t\t}\n-\t    }\n-\t}\n-\tclosesocket(hSocket);\n-\thSocket = INVALID_SOCKET;\n-\n-\t// IRC usually blocks TOR, so only try once\n-\tif (fTOR)\n-\t    return;\n \n-\tif (GetTime() - nStart > 20 * 60)\n-\t{\n-\t    nErrorWait /= 3;\n-\t    nRetryWait /= 3;\n+\t    nRetryWait = nRetryWait * 11 / 10;\n+\t    if (!Wait(nRetryWait += 60))\n+\t\treturn;\n \t}\n-\n-\tnRetryWait = nRetryWait * 11 / 10;\n-\tif (!Wait(nRetryWait += 60))\n-\t    return;\n-    }\n }\n \n \n@@ -422,10 +422,10 @@ int main(int argc, char *argv[])\n {\n     WSADATA wsadata;\n     if (WSAStartup(MAKEWORD(2,2), &wsadata) != NO_ERROR)\n-    {\n-\tprintf(\"Error at WSAStartup()\\n\");\n-\treturn false;\n-    }\n+\t{\n+\t    printf(\"Error at WSAStartup()\\n\");\n+\t    return false;\n+\t}\n \n     ThreadIRCSeed(NULL);\n "
      },
      {
        "sha": "ee405e48aa344452af011e8684c3f9b528c0fa1c",
        "filename": "src/irc.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/irc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/irc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,8 +2,13 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef IRC_H\n+#define IRC_H\n+\n bool RecvLine(SOCKET hSocket, string& strLine);\n void ThreadIRCSeed(void* parg);\n \n extern int nGotIRCAddresses;\n extern bool fGotExternalIP;\n+\n+#endif // !IRC_H"
      },
      {
        "sha": "69831e4d1de796c427a6a49f3976e5a2df09131b",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -26,7 +26,8 @@\n // see www.keylength.com\n // script supports up to 75 for single byte push\n \n-\n+#ifndef KEY_H\n+#define KEY_H\n \n class key_error : public std::runtime_error\n {\n@@ -166,3 +167,5 @@ class CKey\n \treturn key.Verify(hash, vchSig);\n     }\n };\n+\n+#endif // !KEY_H"
      },
      {
        "sha": "dfdcadb9cb030952aeeee2e9d28579c90f94965b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1899,
        "deletions": 1899,
        "changes": 3798,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f"
      },
      {
        "sha": "6080be77f389565a733c122b6d398db812721dc7",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 349,
        "deletions": 344,
        "changes": 693,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef MAIN_H\n+#define MAIN_H\n+\n class COutPoint;\n class CInPoint;\n class CDiskTxPos;\n@@ -253,10 +256,10 @@ class CTxIn\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(prevout);\n-\tREADWRITE(scriptSig);\n-\tREADWRITE(nSequence);\n-    )\n+     READWRITE(prevout);\n+     READWRITE(scriptSig);\n+     READWRITE(nSequence);\n+     )\n \n     bool IsFinal() const\n     {\n@@ -325,9 +328,9 @@ class CTxOut\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(nValue);\n-\tREADWRITE(scriptPubKey);\n-    )\n+     READWRITE(nValue);\n+     READWRITE(scriptPubKey);\n+     )\n \n     void SetNull()\n     {\n@@ -422,12 +425,12 @@ class CTransaction\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(this->nVersion);\n-\tnVersion = this->nVersion;\n-\tREADWRITE(vin);\n-\tREADWRITE(vout);\n-\tREADWRITE(nLockTime);\n-    )\n+     READWRITE(this->nVersion);\n+     nVersion = this->nVersion;\n+     READWRITE(vin);\n+     READWRITE(vout);\n+     READWRITE(nLockTime);\n+     )\n \n     void SetNull()\n     {\n@@ -475,21 +478,21 @@ class CTransaction\n \tbool fNewer = false;\n \tunsigned int nLowest = UINT_MAX;\n \tfor (int i = 0; i < vin.size(); i++)\n-\t{\n-\t    if (vin[i].nSequence != old.vin[i].nSequence)\n \t    {\n-\t\tif (vin[i].nSequence <= nLowest)\n-\t\t{\n-\t\t    fNewer = false;\n-\t\t    nLowest = vin[i].nSequence;\n-\t\t}\n-\t\tif (old.vin[i].nSequence < nLowest)\n-\t\t{\n-\t\t    fNewer = true;\n-\t\t    nLowest = old.vin[i].nSequence;\n-\t\t}\n+\t\tif (vin[i].nSequence != old.vin[i].nSequence)\n+\t\t    {\n+\t\t\tif (vin[i].nSequence <= nLowest)\n+\t\t\t    {\n+\t\t\t\tfNewer = false;\n+\t\t\t\tnLowest = vin[i].nSequence;\n+\t\t\t    }\n+\t\t\tif (old.vin[i].nSequence < nLowest)\n+\t\t\t    {\n+\t\t\t\tfNewer = true;\n+\t\t\t\tnLowest = old.vin[i].nSequence;\n+\t\t\t    }\n+\t\t    }\n \t    }\n-\t}\n \treturn fNewer;\n     }\n \n@@ -536,23 +539,23 @@ class CTransaction\n     {\n \tint64 nDebit = 0;\n \tforeach(const CTxIn& txin, vin)\n-\t{\n-\t    nDebit += txin.GetDebit();\n-\t    if (!MoneyRange(nDebit))\n-\t\tthrow runtime_error(\"CTransaction::GetDebit() : value out of range\");\n-\t}\n+\t    {\n+\t\tnDebit += txin.GetDebit();\n+\t\tif (!MoneyRange(nDebit))\n+\t\t    throw runtime_error(\"CTransaction::GetDebit() : value out of range\");\n+\t    }\n \treturn nDebit;\n     }\n \n     int64 GetCredit() const\n     {\n \tint64 nCredit = 0;\n \tforeach(const CTxOut& txout, vout)\n-\t{\n-\t    nCredit += txout.GetCredit();\n-\t    if (!MoneyRange(nCredit))\n-\t\tthrow runtime_error(\"CTransaction::GetCredit() : value out of range\");\n-\t}\n+\t    {\n+\t\tnCredit += txout.GetCredit();\n+\t\tif (!MoneyRange(nCredit))\n+\t\t    throw runtime_error(\"CTransaction::GetCredit() : value out of range\");\n+\t    }\n \treturn nCredit;\n     }\n \n@@ -562,23 +565,23 @@ class CTransaction\n \t    return 0;\n \tint64 nChange = 0;\n \tforeach(const CTxOut& txout, vout)\n-\t{\n-\t    nChange += txout.GetChange();\n-\t    if (!MoneyRange(nChange))\n-\t\tthrow runtime_error(\"CTransaction::GetChange() : value out of range\");\n-\t}\n+\t    {\n+\t\tnChange += txout.GetChange();\n+\t\tif (!MoneyRange(nChange))\n+\t\t    throw runtime_error(\"CTransaction::GetChange() : value out of range\");\n+\t    }\n \treturn nChange;\n     }\n \n     int64 GetValueOut() const\n     {\n \tint64 nValueOut = 0;\n \tforeach(const CTxOut& txout, vout)\n-\t{\n-\t    nValueOut += txout.nValue;\n-\t    if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n-\t\tthrow runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n-\t}\n+\t    {\n+\t\tnValueOut += txout.nValue;\n+\t\tif (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n+\t\t    throw runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n+\t    }\n \treturn nValueOut;\n     }\n \n@@ -597,21 +600,21 @@ class CTransaction\n \tint64 nMinFee = (1 + (int64)nBytes / 1000) * MIN_TX_FEE;\n \n \tif (fAllowFree)\n-\t{\n-\t    if (nBlockSize == 1)\n \t    {\n-\t\t// Transactions under 10K are free\n-\t\t// (about 4500bc if made of 50bc inputs)\n-\t\tif (nBytes < 10000)\n-\t\t    nMinFee = 0;\n+\t\tif (nBlockSize == 1)\n+\t\t    {\n+\t\t\t// Transactions under 10K are free\n+\t\t\t// (about 4500bc if made of 50bc inputs)\n+\t\t\tif (nBytes < 10000)\n+\t\t\t    nMinFee = 0;\n+\t\t    }\n+\t\telse\n+\t\t    {\n+\t\t\t// Free transaction area\n+\t\t\tif (nNewBlockSize < 27000)\n+\t\t\t    nMinFee = 0;\n+\t\t    }\n \t    }\n-\t    else\n-\t    {\n-\t\t// Free transaction area\n-\t\tif (nNewBlockSize < 27000)\n-\t\t    nMinFee = 0;\n-\t    }\n-\t}\n \n \t// To limit dust spam, require MIN_TX_FEE if any output is less than 0.01\n \tif (nMinFee < MIN_TX_FEE)\n@@ -621,11 +624,11 @@ class CTransaction\n \n \t// Raise the price as the block approaches full\n \tif (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n-\t{\n-\t    if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n-\t\treturn MAX_MONEY;\n-\t    nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n-\t}\n+\t    {\n+\t\tif (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n+\t\t    return MAX_MONEY;\n+\t\tnMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n+\t    }\n \n \tif (!MoneyRange(nMinFee))\n \t    nMinFee = MAX_MONEY;\n@@ -646,11 +649,11 @@ class CTransaction\n \n \t// Return file pointer\n \tif (pfileRet)\n-\t{\n-\t    if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n-\t\treturn error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n-\t    *pfileRet = filein.release();\n-\t}\n+\t    {\n+\t\tif (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n+\t\t    return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n+\t\t*pfileRet = filein.release();\n+\t    }\n \treturn true;\n     }\n \n@@ -672,11 +675,11 @@ class CTransaction\n     {\n \tstring str;\n \tstr += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%d, vout.size=%d, nLockTime=%d)\\n\",\n-\t    GetHash().ToString().substr(0,10).c_str(),\n-\t    nVersion,\n-\t    vin.size(),\n-\t    vout.size(),\n-\t    nLockTime);\n+\t\t\t GetHash().ToString().substr(0,10).c_str(),\n+\t\t\t nVersion,\n+\t\t\t vin.size(),\n+\t\t\t vout.size(),\n+\t\t\t nLockTime);\n \tfor (int i = 0; i < vin.size(); i++)\n \t    str += \"    \" + vin[i].ToString() + \"\\n\";\n \tfor (int i = 0; i < vout.size(); i++)\n@@ -748,12 +751,12 @@ class CMerkleTx : public CTransaction\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tnSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);\n-\tnVersion = this->nVersion;\n-\tREADWRITE(hashBlock);\n-\tREADWRITE(vMerkleBranch);\n-\tREADWRITE(nIndex);\n-    )\n+     nSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);\n+     nVersion = this->nVersion;\n+     READWRITE(hashBlock);\n+     READWRITE(vMerkleBranch);\n+     READWRITE(nIndex);\n+     )\n \n \n     int SetMerkleBranch(const CBlock* pblock=NULL);\n@@ -841,67 +844,67 @@ class CWalletTx : public CMerkleTx\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tCWalletTx* pthis = const_cast<CWalletTx*>(this);\n-\tif (fRead)\n-\t    pthis->Init();\n-\tchar fSpent = false;\n-\n-\tif (!fRead)\n-\t{\n-\t    pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n-\n-\t    string str;\n-\t    foreach(char f, vfSpent)\n-\t    {\n-\t\tstr += (f ? '1' : '0');\n-\t\tif (f)\n-\t\t    fSpent = true;\n-\t    }\n-\t    pthis->mapValue[\"spent\"] = str;\n-\t}\n-\n-\tnSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n-\tREADWRITE(vtxPrev);\n-\tREADWRITE(mapValue);\n-\tREADWRITE(vOrderForm);\n-\tREADWRITE(fTimeReceivedIsTxTime);\n-\tREADWRITE(nTimeReceived);\n-\tREADWRITE(fFromMe);\n-\tREADWRITE(fSpent);\n-\n-\tif (fRead)\n-\t{\n-\t    pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n-\n-\t    if (mapValue.count(\"spent\"))\n-\t\tforeach(char c, pthis->mapValue[\"spent\"])\n-\t\t    pthis->vfSpent.push_back(c != '0');\n-\t    else\n-\t\tpthis->vfSpent.assign(vout.size(), fSpent);\n-\t}\n-\n-\tpthis->mapValue.erase(\"fromaccount\");\n-\tpthis->mapValue.erase(\"version\");\n-\tpthis->mapValue.erase(\"spent\");\n-    )\n+     CWalletTx* pthis = const_cast<CWalletTx*>(this);\n+     if (fRead)\n+\t pthis->Init();\n+     char fSpent = false;\n+\n+     if (!fRead)\n+\t {\n+\t     pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n+\n+\t     string str;\n+\t     foreach(char f, vfSpent)\n+\t\t {\n+\t\t     str += (f ? '1' : '0');\n+\t\t     if (f)\n+\t\t\t fSpent = true;\n+\t\t }\n+\t     pthis->mapValue[\"spent\"] = str;\n+\t }\n+\n+     nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n+     READWRITE(vtxPrev);\n+     READWRITE(mapValue);\n+     READWRITE(vOrderForm);\n+     READWRITE(fTimeReceivedIsTxTime);\n+     READWRITE(nTimeReceived);\n+     READWRITE(fFromMe);\n+     READWRITE(fSpent);\n+\n+     if (fRead)\n+\t {\n+\t     pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n+\n+\t     if (mapValue.count(\"spent\"))\n+\t\t foreach(char c, pthis->mapValue[\"spent\"])\n+\t\t     pthis->vfSpent.push_back(c != '0');\n+\t     else\n+\t\t pthis->vfSpent.assign(vout.size(), fSpent);\n+\t }\n+\n+     pthis->mapValue.erase(\"fromaccount\");\n+     pthis->mapValue.erase(\"version\");\n+     pthis->mapValue.erase(\"spent\");\n+     )\n \n     // marks certain txout's as spent\n     // returns true if any update took place\n     bool UpdateSpent(const vector<char>& vfNewSpent)\n     {\n \tbool fReturn = false;\n \tfor (int i=0; i < vfNewSpent.size(); i++)\n-\t{\n-\t    if (i == vfSpent.size())\n-\t\tbreak;\n-\n-\t    if (vfNewSpent[i] && !vfSpent[i])\n \t    {\n-\t\tvfSpent[i] = true;\n-\t\tfReturn = true;\n-\t\tfAvailableCreditCached = false;\n+\t\tif (i == vfSpent.size())\n+\t\t    break;\n+\n+\t\tif (vfNewSpent[i] && !vfSpent[i])\n+\t\t    {\n+\t\t\tvfSpent[i] = true;\n+\t\t\tfReturn = true;\n+\t\t\tfAvailableCreditCached = false;\n+\t\t    }\n \t    }\n-\t}\n \treturn fReturn;\n     }\n \n@@ -919,10 +922,10 @@ class CWalletTx : public CMerkleTx\n \t    throw runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n \tvfSpent.resize(vout.size());\n \tif (!vfSpent[nOut])\n-\t{\n-\t    vfSpent[nOut] = true;\n-\t    fAvailableCreditCached = false;\n-\t}\n+\t    {\n+\t\tvfSpent[nOut] = true;\n+\t\tfAvailableCreditCached = false;\n+\t    }\n     }\n \n     bool IsSpent(unsigned int nOut) const\n@@ -970,15 +973,15 @@ class CWalletTx : public CMerkleTx\n \n \tint64 nCredit = 0;\n \tfor (int i = 0; i < vout.size(); i++)\n-\t{\n-\t    if (!IsSpent(i))\n \t    {\n-\t\tconst CTxOut &txout = vout[i];\n-\t\tnCredit += txout.GetCredit();\n-\t\tif (!MoneyRange(nCredit))\n-\t\t    throw runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+\t\tif (!IsSpent(i))\n+\t\t    {\n+\t\t\tconst CTxOut &txout = vout[i];\n+\t\t\tnCredit += txout.GetCredit();\n+\t\t\tif (!MoneyRange(nCredit))\n+\t\t\t    throw runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+\t\t    }\n \t    }\n-\t}\n \n \tnAvailableCreditCached = nCredit;\n \tfAvailableCreditCached = true;\n@@ -1023,27 +1026,27 @@ class CWalletTx : public CMerkleTx\n \tvWorkQueue.reserve(vtxPrev.size()+1);\n \tvWorkQueue.push_back(this);\n \tfor (int i = 0; i < vWorkQueue.size(); i++)\n-\t{\n-\t    const CMerkleTx* ptx = vWorkQueue[i];\n+\t    {\n+\t\tconst CMerkleTx* ptx = vWorkQueue[i];\n \n-\t    if (!ptx->IsFinal())\n-\t\treturn false;\n-\t    if (ptx->GetDepthInMainChain() >= 1)\n-\t\tcontinue;\n-\t    if (!ptx->IsFromMe())\n-\t\treturn false;\n+\t\tif (!ptx->IsFinal())\n+\t\t    return false;\n+\t\tif (ptx->GetDepthInMainChain() >= 1)\n+\t\t    continue;\n+\t\tif (!ptx->IsFromMe())\n+\t\t    return false;\n \n-\t    if (mapPrev.empty())\n-\t\tforeach(const CMerkleTx& tx, vtxPrev)\n-\t\t    mapPrev[tx.GetHash()] = &tx;\n+\t\tif (mapPrev.empty())\n+\t\t    foreach(const CMerkleTx& tx, vtxPrev)\n+\t\t\tmapPrev[tx.GetHash()] = &tx;\n \n-\t    foreach(const CTxIn& txin, ptx->vin)\n-\t    {\n-\t\tif (!mapPrev.count(txin.prevout.hash))\n-\t\t    return false;\n-\t\tvWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n+\t\tforeach(const CTxIn& txin, ptx->vin)\n+\t\t    {\n+\t\t\tif (!mapPrev.count(txin.prevout.hash))\n+\t\t\t    return false;\n+\t\t\tvWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n+\t\t    }\n \t    }\n-\t}\n \treturn true;\n     }\n \n@@ -1092,11 +1095,11 @@ class CTxIndex\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (!(nType & SER_GETHASH))\n-\t    READWRITE(nVersion);\n-\tREADWRITE(pos);\n-\tREADWRITE(vSpent);\n-    )\n+     if (!(nType & SER_GETHASH))\n+\t READWRITE(nVersion);\n+     READWRITE(pos);\n+     READWRITE(vSpent);\n+     )\n \n     void SetNull()\n     {\n@@ -1162,20 +1165,20 @@ class CBlock\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(this->nVersion);\n-\tnVersion = this->nVersion;\n-\tREADWRITE(hashPrevBlock);\n-\tREADWRITE(hashMerkleRoot);\n-\tREADWRITE(nTime);\n-\tREADWRITE(nBits);\n-\tREADWRITE(nNonce);\n-\n-\t// ConnectBlock depends on vtx being last so it can calculate offset\n-\tif (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n-\t    READWRITE(vtx);\n-\telse if (fRead)\n-\t    const_cast<CBlock*>(this)->vtx.clear();\n-    )\n+     READWRITE(this->nVersion);\n+     nVersion = this->nVersion;\n+     READWRITE(hashPrevBlock);\n+     READWRITE(hashMerkleRoot);\n+     READWRITE(nTime);\n+     READWRITE(nBits);\n+     READWRITE(nNonce);\n+\n+     // ConnectBlock depends on vtx being last so it can calculate offset\n+     if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n+\t READWRITE(vtx);\n+     else if (fRead)\n+\t const_cast<CBlock*>(this)->vtx.clear();\n+     )\n \n     void SetNull()\n     {\n@@ -1220,15 +1223,15 @@ class CBlock\n \t    vMerkleTree.push_back(tx.GetHash());\n \tint j = 0;\n \tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-\t{\n-\t    for (int i = 0; i < nSize; i += 2)\n \t    {\n-\t\tint i2 = min(i+1, nSize-1);\n-\t\tvMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n-\t\t\t\t\t   BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n+\t\tfor (int i = 0; i < nSize; i += 2)\n+\t\t    {\n+\t\t\tint i2 = min(i+1, nSize-1);\n+\t\t\tvMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n+\t\t\t\t\t\t   BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n+\t\t    }\n+\t\tj += nSize;\n \t    }\n-\t    j += nSize;\n-\t}\n \treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n     }\n \n@@ -1239,12 +1242,12 @@ class CBlock\n \tvector<uint256> vMerkleBranch;\n \tint j = 0;\n \tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-\t{\n-\t    int i = min(nIndex^1, nSize-1);\n-\t    vMerkleBranch.push_back(vMerkleTree[j+i]);\n-\t    nIndex >>= 1;\n-\t    j += nSize;\n-\t}\n+\t    {\n+\t\tint i = min(nIndex^1, nSize-1);\n+\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);\n+\t\tnIndex >>= 1;\n+\t\tj += nSize;\n+\t    }\n \treturn vMerkleBranch;\n     }\n \n@@ -1253,13 +1256,13 @@ class CBlock\n \tif (nIndex == -1)\n \t    return 0;\n \tforeach(const uint256& otherside, vMerkleBranch)\n-\t{\n-\t    if (nIndex & 1)\n-\t\thash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n-\t    else\n-\t\thash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n-\t    nIndex >>= 1;\n-\t}\n+\t    {\n+\t\tif (nIndex & 1)\n+\t\t    hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n+\t\telse\n+\t\t    hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n+\t\tnIndex >>= 1;\n+\t    }\n \treturn hash;\n     }\n \n@@ -1284,13 +1287,13 @@ class CBlock\n \t// Flush stdio buffers and commit to disk before returning\n \tfflush(fileout);\n \tif (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n-\t{\n+\t    {\n #ifdef __WXMSW__\n-\t    _commit(_fileno(fileout));\n+\t\t_commit(_fileno(fileout));\n #else\n-\t    fsync(fileno(fileout));\n+\t\tfsync(fileno(fileout));\n #endif\n-\t}\n+\t    }\n \n \treturn true;\n     }\n@@ -1321,17 +1324,17 @@ class CBlock\n     void print() const\n     {\n \tprintf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%d)\\n\",\n-\t    GetHash().ToString().substr(0,20).c_str(),\n-\t    nVersion,\n-\t    hashPrevBlock.ToString().substr(0,20).c_str(),\n-\t    hashMerkleRoot.ToString().substr(0,10).c_str(),\n-\t    nTime, nBits, nNonce,\n-\t    vtx.size());\n+\t       GetHash().ToString().substr(0,20).c_str(),\n+\t       nVersion,\n+\t       hashPrevBlock.ToString().substr(0,20).c_str(),\n+\t       hashMerkleRoot.ToString().substr(0,10).c_str(),\n+\t       nTime, nBits, nNonce,\n+\t       vtx.size());\n \tfor (int i = 0; i < vtx.size(); i++)\n-\t{\n-\t    printf(\"  \");\n-\t    vtx[i].print();\n-\t}\n+\t    {\n+\t\tprintf(\"  \");\n+\t\tvtx[i].print();\n+\t    }\n \tprintf(\"  vMerkleTree: \");\n \tfor (int i = 0; i < vMerkleTree.size(); i++)\n \t    printf(\"%s \", vMerkleTree[i].ToString().substr(0,10).c_str());\n@@ -1491,11 +1494,11 @@ class CBlockIndex\n     {\n \tconst CBlockIndex* pindex = this;\n \tfor (int i = 0; i < nMedianTimeSpan/2; i++)\n-\t{\n-\t    if (!pindex->pnext)\n-\t\treturn GetBlockTime();\n-\t    pindex = pindex->pnext;\n-\t}\n+\t    {\n+\t\tif (!pindex->pnext)\n+\t\t    return GetBlockTime();\n+\t\tpindex = pindex->pnext;\n+\t    }\n \treturn pindex->GetMedianTimePast();\n     }\n \n@@ -1504,9 +1507,9 @@ class CBlockIndex\n     string ToString() const\n     {\n \treturn strprintf(\"CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%-6d nHeight=%d, merkle=%s, hashBlock=%s)\",\n-\t    pprev, pnext, nFile, nBlockPos, nHeight,\n-\t    hashMerkleRoot.ToString().substr(0,10).c_str(),\n-\t    GetBlockHash().ToString().substr(0,20).c_str());\n+\t\t\t pprev, pnext, nFile, nBlockPos, nHeight,\n+\t\t\t hashMerkleRoot.ToString().substr(0,10).c_str(),\n+\t\t\t GetBlockHash().ToString().substr(0,20).c_str());\n     }\n \n     void print() const\n@@ -1540,22 +1543,22 @@ class CDiskBlockIndex : public CBlockIndex\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (!(nType & SER_GETHASH))\n-\t    READWRITE(nVersion);\n-\n-\tREADWRITE(hashNext);\n-\tREADWRITE(nFile);\n-\tREADWRITE(nBlockPos);\n-\tREADWRITE(nHeight);\n-\n-\t// block header\n-\tREADWRITE(this->nVersion);\n-\tREADWRITE(hashPrev);\n-\tREADWRITE(hashMerkleRoot);\n-\tREADWRITE(nTime);\n-\tREADWRITE(nBits);\n-\tREADWRITE(nNonce);\n-    )\n+     if (!(nType & SER_GETHASH))\n+\t READWRITE(nVersion);\n+\n+     READWRITE(hashNext);\n+     READWRITE(nFile);\n+     READWRITE(nBlockPos);\n+     READWRITE(nHeight);\n+\n+     // block header\n+     READWRITE(this->nVersion);\n+     READWRITE(hashPrev);\n+     READWRITE(hashMerkleRoot);\n+     READWRITE(nTime);\n+     READWRITE(nBits);\n+     READWRITE(nNonce);\n+     )\n \n     uint256 GetBlockHash() const\n     {\n@@ -1575,9 +1578,9 @@ class CDiskBlockIndex : public CBlockIndex\n \tstring str = \"CDiskBlockIndex(\";\n \tstr += CBlockIndex::ToString();\n \tstr += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n-\t    GetBlockHash().ToString().c_str(),\n-\t    hashPrev.ToString().substr(0,20).c_str(),\n-\t    hashNext.ToString().substr(0,20).c_str());\n+\t\t\t GetBlockHash().ToString().c_str(),\n+\t\t\t hashPrev.ToString().substr(0,20).c_str(),\n+\t\t\t hashNext.ToString().substr(0,20).c_str());\n \treturn str;\n     }\n \n@@ -1623,10 +1626,10 @@ class CBlockLocator\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (!(nType & SER_GETHASH))\n-\t    READWRITE(nVersion);\n-\tREADWRITE(vHave);\n-    )\n+     if (!(nType & SER_GETHASH))\n+\t READWRITE(nVersion);\n+     READWRITE(vHave);\n+     )\n \n     void SetNull()\n     {\n@@ -1643,15 +1646,15 @@ class CBlockLocator\n \tvHave.clear();\n \tint nStep = 1;\n \twhile (pindex)\n-\t{\n-\t    vHave.push_back(pindex->GetBlockHash());\n-\n-\t    // Exponentially larger steps back\n-\t    for (int i = 0; pindex && i < nStep; i++)\n-\t\tpindex = pindex->pprev;\n-\t    if (vHave.size() > 10)\n-\t\tnStep *= 2;\n-\t}\n+\t    {\n+\t\tvHave.push_back(pindex->GetBlockHash());\n+\n+\t\t// Exponentially larger steps back\n+\t\tfor (int i = 0; pindex && i < nStep; i++)\n+\t\t    pindex = pindex->pprev;\n+\t\tif (vHave.size() > 10)\n+\t\t    nStep *= 2;\n+\t    }\n \tvHave.push_back(hashGenesisBlock);\n     }\n \n@@ -1661,50 +1664,50 @@ class CBlockLocator\n \tint nDistance = 0;\n \tint nStep = 1;\n \tforeach(const uint256& hash, vHave)\n-\t{\n-\t    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-\t    if (mi != mapBlockIndex.end())\n \t    {\n-\t\tCBlockIndex* pindex = (*mi).second;\n-\t\tif (pindex->IsInMainChain())\n-\t\t    return nDistance;\n+\t\tmap<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+\t\tif (mi != mapBlockIndex.end())\n+\t\t    {\n+\t\t\tCBlockIndex* pindex = (*mi).second;\n+\t\t\tif (pindex->IsInMainChain())\n+\t\t\t    return nDistance;\n+\t\t    }\n+\t\tnDistance += nStep;\n+\t\tif (nDistance > 10)\n+\t\t    nStep *= 2;\n \t    }\n-\t    nDistance += nStep;\n-\t    if (nDistance > 10)\n-\t\tnStep *= 2;\n-\t}\n \treturn nDistance;\n     }\n \n     CBlockIndex* GetBlockIndex()\n     {\n \t// Find the first block the caller has in the main chain\n \tforeach(const uint256& hash, vHave)\n-\t{\n-\t    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-\t    if (mi != mapBlockIndex.end())\n \t    {\n-\t\tCBlockIndex* pindex = (*mi).second;\n-\t\tif (pindex->IsInMainChain())\n-\t\t    return pindex;\n+\t\tmap<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+\t\tif (mi != mapBlockIndex.end())\n+\t\t    {\n+\t\t\tCBlockIndex* pindex = (*mi).second;\n+\t\t\tif (pindex->IsInMainChain())\n+\t\t\t    return pindex;\n+\t\t    }\n \t    }\n-\t}\n \treturn pindexGenesisBlock;\n     }\n \n     uint256 GetBlockHash()\n     {\n \t// Find the first block the caller has in the main chain\n \tforeach(const uint256& hash, vHave)\n-\t{\n-\t    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-\t    if (mi != mapBlockIndex.end())\n \t    {\n-\t\tCBlockIndex* pindex = (*mi).second;\n-\t\tif (pindex->IsInMainChain())\n-\t\t    return hash;\n+\t\tmap<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+\t\tif (mi != mapBlockIndex.end())\n+\t\t    {\n+\t\t\tCBlockIndex* pindex = (*mi).second;\n+\t\t\tif (pindex->IsInMainChain())\n+\t\t\t    return hash;\n+\t\t    }\n \t    }\n-\t}\n \treturn hashGenesisBlock;\n     }\n \n@@ -1743,13 +1746,13 @@ class CWalletKey\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (!(nType & SER_GETHASH))\n-\t    READWRITE(nVersion);\n-\tREADWRITE(vchPrivKey);\n-\tREADWRITE(nTimeCreated);\n-\tREADWRITE(nTimeExpires);\n-\tREADWRITE(strComment);\n-    )\n+     if (!(nType & SER_GETHASH))\n+\t READWRITE(nVersion);\n+     READWRITE(vchPrivKey);\n+     READWRITE(nTimeCreated);\n+     READWRITE(nTimeExpires);\n+     READWRITE(strComment);\n+     )\n };\n \n \n@@ -1815,14 +1818,14 @@ class CAccountingEntry\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (!(nType & SER_GETHASH))\n-\t    READWRITE(nVersion);\n-\t// Note: strAccount is serialized as part of the key, not here.\n-\tREADWRITE(nCreditDebit);\n-\tREADWRITE(nTime);\n-\tREADWRITE(strOtherAccount);\n-\tREADWRITE(strComment);\n-    )\n+     if (!(nType & SER_GETHASH))\n+\t READWRITE(nVersion);\n+     // Note: strAccount is serialized as part of the key, not here.\n+     READWRITE(nCreditDebit);\n+     READWRITE(nTime);\n+     READWRITE(strOtherAccount);\n+     READWRITE(strComment);\n+     )\n };\n \n \n@@ -1861,22 +1864,22 @@ class CUnsignedAlert\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(this->nVersion);\n-\tnVersion = this->nVersion;\n-\tREADWRITE(nRelayUntil);\n-\tREADWRITE(nExpiration);\n-\tREADWRITE(nID);\n-\tREADWRITE(nCancel);\n-\tREADWRITE(setCancel);\n-\tREADWRITE(nMinVer);\n-\tREADWRITE(nMaxVer);\n-\tREADWRITE(setSubVer);\n-\tREADWRITE(nPriority);\n-\n-\tREADWRITE(strComment);\n-\tREADWRITE(strStatusBar);\n-\tREADWRITE(strReserved);\n-    )\n+     READWRITE(this->nVersion);\n+     nVersion = this->nVersion;\n+     READWRITE(nRelayUntil);\n+     READWRITE(nExpiration);\n+     READWRITE(nID);\n+     READWRITE(nCancel);\n+     READWRITE(setCancel);\n+     READWRITE(nMinVer);\n+     READWRITE(nMaxVer);\n+     READWRITE(setSubVer);\n+     READWRITE(nPriority);\n+\n+     READWRITE(strComment);\n+     READWRITE(strStatusBar);\n+     READWRITE(strReserved);\n+     )\n \n     void SetNull()\n     {\n@@ -1905,32 +1908,32 @@ class CUnsignedAlert\n \tforeach(string str, setSubVer)\n \t    strSetSubVer += \"\\\"\" + str + \"\\\" \";\n \treturn strprintf(\n-\t\t\"CAlert(\\n\"\n-\t\t\"    nVersion     = %d\\n\"\n-\t\t\"    nRelayUntil  = %\"PRI64d\"\\n\"\n-\t\t\"    nExpiration  = %\"PRI64d\"\\n\"\n-\t\t\"    nID          = %d\\n\"\n-\t\t\"    nCancel      = %d\\n\"\n-\t\t\"    setCancel    = %s\\n\"\n-\t\t\"    nMinVer      = %d\\n\"\n-\t\t\"    nMaxVer      = %d\\n\"\n-\t\t\"    setSubVer    = %s\\n\"\n-\t\t\"    nPriority    = %d\\n\"\n-\t\t\"    strComment   = \\\"%s\\\"\\n\"\n-\t\t\"    strStatusBar = \\\"%s\\\"\\n\"\n-\t\t\")\\n\",\n-\t    nVersion,\n-\t    nRelayUntil,\n-\t    nExpiration,\n-\t    nID,\n-\t    nCancel,\n-\t    strSetCancel.c_str(),\n-\t    nMinVer,\n-\t    nMaxVer,\n-\t    strSetSubVer.c_str(),\n-\t    nPriority,\n-\t    strComment.c_str(),\n-\t    strStatusBar.c_str());\n+\t\t\t \"CAlert(\\n\"\n+\t\t\t \"    nVersion     = %d\\n\"\n+\t\t\t \"    nRelayUntil  = %\"PRI64d\"\\n\"\n+\t\t\t \"    nExpiration  = %\"PRI64d\"\\n\"\n+\t\t\t \"    nID          = %d\\n\"\n+\t\t\t \"    nCancel      = %d\\n\"\n+\t\t\t \"    setCancel    = %s\\n\"\n+\t\t\t \"    nMinVer      = %d\\n\"\n+\t\t\t \"    nMaxVer      = %d\\n\"\n+\t\t\t \"    setSubVer    = %s\\n\"\n+\t\t\t \"    nPriority    = %d\\n\"\n+\t\t\t \"    strComment   = \\\"%s\\\"\\n\"\n+\t\t\t \"    strStatusBar = \\\"%s\\\"\\n\"\n+\t\t\t \")\\n\",\n+\t\t\t nVersion,\n+\t\t\t nRelayUntil,\n+\t\t\t nExpiration,\n+\t\t\t nID,\n+\t\t\t nCancel,\n+\t\t\t strSetCancel.c_str(),\n+\t\t\t nMinVer,\n+\t\t\t nMaxVer,\n+\t\t\t strSetSubVer.c_str(),\n+\t\t\t nPriority,\n+\t\t\t strComment.c_str(),\n+\t\t\t strStatusBar.c_str());\n     }\n \n     void print() const\n@@ -1952,9 +1955,9 @@ class CAlert : public CUnsignedAlert\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(vchMsg);\n-\tREADWRITE(vchSig);\n-    )\n+     READWRITE(vchMsg);\n+     READWRITE(vchSig);\n+     )\n \n     void SetNull()\n     {\n@@ -2003,15 +2006,15 @@ class CAlert : public CUnsignedAlert\n \t    return false;\n \t// returns true if wasn't already contained in the set\n \tif (pnode->setKnown.insert(GetHash()).second)\n-\t{\n-\t    if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n-\t\tAppliesToMe() ||\n-\t\tGetAdjustedTime() < nRelayUntil)\n \t    {\n-\t\tpnode->PushMessage(\"alert\", *this);\n-\t\treturn true;\n+\t\tif (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n+\t\t    AppliesToMe() ||\n+\t\t    GetAdjustedTime() < nRelayUntil)\n+\t\t    {\n+\t\t\tpnode->PushMessage(\"alert\", *this);\n+\t\t\treturn true;\n+\t\t    }\n \t    }\n-\t}\n \treturn false;\n     }\n \n@@ -2049,3 +2052,5 @@ extern map<vector<unsigned char>, CPrivKey> mapKeys;\n extern map<uint160, vector<unsigned char> > mapPubKeys;\n extern CCriticalSection cs_mapKeys;\n extern CKey keyUser;\n+\n+#endif // !MAIN_H"
      },
      {
        "sha": "637899ef4225894322c9b53992defa014a697b2b",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 803,
        "deletions": 803,
        "changes": 1606,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -86,41 +86,41 @@ bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet)\n     struct sockaddr_in sockaddr = (fProxy ? addrProxy.GetSockAddr() : addrConnect.GetSockAddr());\n \n     if (connect(hSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n-    {\n-\tclosesocket(hSocket);\n-\treturn false;\n-    }\n-\n-    if (fProxy)\n-    {\n-\tprintf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n-\tchar pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n-\tmemcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n-\tmemcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n-\tchar* pszSocks4 = pszSocks4IP;\n-\tint nSize = sizeof(pszSocks4IP);\n-\n-\tint ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n-\tif (ret != nSize)\n \t{\n \t    closesocket(hSocket);\n-\t    return error(\"Error sending to proxy\");\n-\t}\n-\tchar pchRet[8];\n-\tif (recv(hSocket, pchRet, 8, 0) != 8)\n-\t{\n-\t    closesocket(hSocket);\n-\t    return error(\"Error reading proxy response\");\n+\t    return false;\n \t}\n-\tif (pchRet[1] != 0x5a)\n+\n+    if (fProxy)\n \t{\n-\t    closesocket(hSocket);\n-\t    if (pchRet[1] != 0x5b)\n-\t\tprintf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n-\t    return false;\n+\t    printf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n+\t    char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n+\t    memcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n+\t    memcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n+\t    char* pszSocks4 = pszSocks4IP;\n+\t    int nSize = sizeof(pszSocks4IP);\n+\n+\t    int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n+\t    if (ret != nSize)\n+\t\t{\n+\t\t    closesocket(hSocket);\n+\t\t    return error(\"Error sending to proxy\");\n+\t\t}\n+\t    char pchRet[8];\n+\t    if (recv(hSocket, pchRet, 8, 0) != 8)\n+\t\t{\n+\t\t    closesocket(hSocket);\n+\t\t    return error(\"Error reading proxy response\");\n+\t\t}\n+\t    if (pchRet[1] != 0x5a)\n+\t\t{\n+\t\t    closesocket(hSocket);\n+\t\t    if (pchRet[1] != 0x5b)\n+\t\t\tprintf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n+\t\t    return false;\n+\t\t}\n+\t    printf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n \t}\n-\tprintf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n-    }\n \n     hSocketRet = hSocket;\n     return true;\n@@ -137,33 +137,33 @@ bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMa\n     char *pszHost = psz;\n     strlcpy(psz, pszName, sizeof(psz));\n     if (fAllowPort)\n-    {\n-\tchar* pszColon = strrchr(psz+1,':');\n-\tchar *pszPortEnd = NULL;\n-\tint portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n-\tif (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n \t{\n-\t    if (psz[0] == '[' && pszColon[-1] == ']')\n-\t    {\n-\t\t// Future: enable IPv6 colon-notation inside []\n-\t\tpszHost = psz+1;\n-\t\tpszColon[-1] = 0;\n-\t    }\n-\t    else\n-\t\tpszColon[0] = 0;\n-\t    port = portParsed;\n-\t    if (port < 0 || port > USHRT_MAX)\n-\t\tport = USHRT_MAX;\n+\t    char* pszColon = strrchr(psz+1,':');\n+\t    char *pszPortEnd = NULL;\n+\t    int portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n+\t    if (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n+\t\t{\n+\t\t    if (psz[0] == '[' && pszColon[-1] == ']')\n+\t\t\t{\n+\t\t\t    // Future: enable IPv6 colon-notation inside []\n+\t\t\t    pszHost = psz+1;\n+\t\t\t    pszColon[-1] = 0;\n+\t\t\t}\n+\t\t    else\n+\t\t\tpszColon[0] = 0;\n+\t\t    port = portParsed;\n+\t\t    if (port < 0 || port > USHRT_MAX)\n+\t\t\tport = USHRT_MAX;\n+\t\t}\n \t}\n-    }\n \n     unsigned int addrIP = inet_addr(pszHost);\n     if (addrIP != INADDR_NONE)\n-    {\n-\t// valid IP address passed\n-\tvaddr.push_back(CAddress(addrIP, port, nServices));\n-\treturn true;\n-    }\n+\t{\n+\t    // valid IP address passed\n+\t    vaddr.push_back(CAddress(addrIP, port, nServices));\n+\t    return true;\n+\t}\n \n     if (!fAllowLookup)\n \treturn false;\n@@ -177,12 +177,12 @@ bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMa\n \n     char** ppAddr = phostent->h_addr_list;\n     while (*ppAddr != NULL && vaddr.size() != nMaxSolutions)\n-    {\n-\tCAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n-\tif (addr.IsValid())\n-\t    vaddr.push_back(addr);\n-\tppAddr++;\n-    }\n+\t{\n+\t    CAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n+\t    if (addr.IsValid())\n+\t\tvaddr.push_back(addr);\n+\t    ppAddr++;\n+\t}\n \n     return (vaddr.size() > 0);\n }\n@@ -207,38 +207,38 @@ bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const cha\n \n     string strLine;\n     while (RecvLine(hSocket, strLine))\n-    {\n-\tif (strLine.empty()) // HTTP response is separated from headers by blank line\n \t{\n-\t    loop\n-\t    {\n-\t\tif (!RecvLine(hSocket, strLine))\n+\t    if (strLine.empty()) // HTTP response is separated from headers by blank line\n \t\t{\n+\t\t    loop\n+\t\t\t{\n+\t\t\t    if (!RecvLine(hSocket, strLine))\n+\t\t\t\t{\n+\t\t\t\t    closesocket(hSocket);\n+\t\t\t\t    return false;\n+\t\t\t\t}\n+\t\t\t    if (pszKeyword == NULL)\n+\t\t\t\tbreak;\n+\t\t\t    if (strLine.find(pszKeyword) != -1)\n+\t\t\t\t{\n+\t\t\t\t    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n+\t\t\t\t    break;\n+\t\t\t\t}\n+\t\t\t}\n \t\t    closesocket(hSocket);\n-\t\t    return false;\n-\t\t}\n-\t\tif (pszKeyword == NULL)\n-\t\t    break;\n-\t\tif (strLine.find(pszKeyword) != -1)\n-\t\t{\n-\t\t    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n-\t\t    break;\n+\t\t    if (strLine.find(\"<\") != -1)\n+\t\t\tstrLine = strLine.substr(0, strLine.find(\"<\"));\n+\t\t    strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n+\t\t    while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n+\t\t\tstrLine.resize(strLine.size()-1);\n+\t\t    CAddress addr(strLine,0,true);\n+\t\t    printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n+\t\t    if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n+\t\t\treturn false;\n+\t\t    ipRet = addr.ip;\n+\t\t    return true;\n \t\t}\n-\t    }\n-\t    closesocket(hSocket);\n-\t    if (strLine.find(\"<\") != -1)\n-\t\tstrLine = strLine.substr(0, strLine.find(\"<\"));\n-\t    strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n-\t    while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n-\t\tstrLine.resize(strLine.size()-1);\n-\t    CAddress addr(strLine,0,true);\n-\t    printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n-\t    if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n-\t\treturn false;\n-\t    ipRet = addr.ip;\n-\t    return true;\n \t}\n-    }\n     closesocket(hSocket);\n     return error(\"GetMyExternalIP() : connection closed\");\n }\n@@ -254,54 +254,54 @@ bool GetMyExternalIP(unsigned int& ipRet)\n \treturn false;\n \n     for (int nLookup = 0; nLookup <= 1; nLookup++)\n-    for (int nHost = 1; nHost <= 2; nHost++)\n-    {\n-\t// We should be phasing out our use of sites like these.  If we need\n-\t// replacements, we should ask for volunteers to put this simple\n-\t// php file on their webserver that prints the client IP:\n-\t//  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n-\tif (nHost == 1)\n-\t{\n-\t    addrConnect = CAddress(\"91.198.22.70\",80); // checkip.dyndns.org\n-\n-\t    if (nLookup == 1)\n+\tfor (int nHost = 1; nHost <= 2; nHost++)\n \t    {\n-\t\tCAddress addrIP(\"checkip.dyndns.org\", 80, true);\n-\t\tif (addrIP.IsValid())\n-\t\t    addrConnect = addrIP;\n-\t    }\n+\t\t// We should be phasing out our use of sites like these.  If we need\n+\t\t// replacements, we should ask for volunteers to put this simple\n+\t\t// php file on their webserver that prints the client IP:\n+\t\t//  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n+\t\tif (nHost == 1)\n+\t\t    {\n+\t\t\taddrConnect = CAddress(\"91.198.22.70\",80); // checkip.dyndns.org\n \n-\t    pszGet = \"GET / HTTP/1.1\\r\\n\"\n-\t\t     \"Host: checkip.dyndns.org\\r\\n\"\n-\t\t     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n-\t\t     \"Connection: close\\r\\n\"\n-\t\t     \"\\r\\n\";\n+\t\t\tif (nLookup == 1)\n+\t\t\t    {\n+\t\t\t\tCAddress addrIP(\"checkip.dyndns.org\", 80, true);\n+\t\t\t\tif (addrIP.IsValid())\n+\t\t\t\t    addrConnect = addrIP;\n+\t\t\t    }\n \n-\t    pszKeyword = \"Address:\";\n-\t}\n-\telse if (nHost == 2)\n-\t{\n-\t    addrConnect = CAddress(\"74.208.43.192\", 80); // www.showmyip.com\n+\t\t\tpszGet = \"GET / HTTP/1.1\\r\\n\"\n+\t\t\t    \"Host: checkip.dyndns.org\\r\\n\"\n+\t\t\t    \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n+\t\t\t    \"Connection: close\\r\\n\"\n+\t\t\t    \"\\r\\n\";\n \n-\t    if (nLookup == 1)\n-\t    {\n-\t\tCAddress addrIP(\"www.showmyip.com\", 80, true);\n-\t\tif (addrIP.IsValid())\n-\t\t    addrConnect = addrIP;\n-\t    }\n+\t\t\tpszKeyword = \"Address:\";\n+\t\t    }\n+\t\telse if (nHost == 2)\n+\t\t    {\n+\t\t\taddrConnect = CAddress(\"74.208.43.192\", 80); // www.showmyip.com\n \n-\t    pszGet = \"GET /simple/ HTTP/1.1\\r\\n\"\n-\t\t     \"Host: www.showmyip.com\\r\\n\"\n-\t\t     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n-\t\t     \"Connection: close\\r\\n\"\n-\t\t     \"\\r\\n\";\n+\t\t\tif (nLookup == 1)\n+\t\t\t    {\n+\t\t\t\tCAddress addrIP(\"www.showmyip.com\", 80, true);\n+\t\t\t\tif (addrIP.IsValid())\n+\t\t\t\t    addrConnect = addrIP;\n+\t\t\t    }\n \n-\t    pszKeyword = NULL; // Returns just IP address\n-\t}\n+\t\t\tpszGet = \"GET /simple/ HTTP/1.1\\r\\n\"\n+\t\t\t    \"Host: www.showmyip.com\\r\\n\"\n+\t\t\t    \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n+\t\t\t    \"Connection: close\\r\\n\"\n+\t\t\t    \"\\r\\n\";\n \n-\tif (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n-\t    return true;\n-    }\n+\t\t\tpszKeyword = NULL; // Returns just IP address\n+\t\t    }\n+\n+\t\tif (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n+\t\t    return true;\n+\t    }\n \n     return false;\n }\n@@ -310,30 +310,30 @@ void ThreadGetMyExternalIP(void* parg)\n {\n     // Wait for IRC to get it first\n     if (!GetBoolArg(\"-noirc\"))\n-    {\n-\tfor (int i = 0; i < 2 * 60; i++)\n \t{\n-\t    Sleep(1000);\n-\t    if (fGotExternalIP || fShutdown)\n-\t\treturn;\n+\t    for (int i = 0; i < 2 * 60; i++)\n+\t\t{\n+\t\t    Sleep(1000);\n+\t\t    if (fGotExternalIP || fShutdown)\n+\t\t\treturn;\n+\t\t}\n \t}\n-    }\n \n     // Fallback in case IRC fails to get it\n     if (GetMyExternalIP(addrLocalHost.ip))\n-    {\n-\tprintf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n-\tif (addrLocalHost.IsRoutable())\n \t{\n-\t    // If we already connected to a few before we had our IP, go back and addr them.\n-\t    // setAddrKnown automatically filters any duplicate sends.\n-\t    CAddress addr(addrLocalHost);\n-\t    addr.nTime = GetAdjustedTime();\n-\t    CRITICAL_BLOCK(cs_vNodes)\n-\t\tforeach(CNode* pnode, vNodes)\n-\t\t    pnode->PushAddress(addr);\n+\t    printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n+\t    if (addrLocalHost.IsRoutable())\n+\t\t{\n+\t\t    // If we already connected to a few before we had our IP, go back and addr them.\n+\t\t    // setAddrKnown automatically filters any duplicate sends.\n+\t\t    CAddress addr(addrLocalHost);\n+\t\t    addr.nTime = GetAdjustedTime();\n+\t\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\t\tforeach(CNode* pnode, vNodes)\n+\t\t\tpnode->PushAddress(addr);\n+\t\t}\n \t}\n-    }\n }\n \n \n@@ -390,17 +390,17 @@ void AddressCurrentlyConnected(const CAddress& addr)\n \t// Only if it's been published already\n \tmap<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());\n \tif (it != mapAddresses.end())\n-\t{\n-\t    CAddress& addrFound = (*it).second;\n-\t    int64 nUpdateInterval = 20 * 60;\n-\t    if (addrFound.nTime < GetAdjustedTime() - nUpdateInterval)\n \t    {\n-\t\t// Periodically update most recently seen time\n-\t\taddrFound.nTime = GetAdjustedTime();\n-\t\tCAddrDB addrdb;\n-\t\taddrdb.WriteAddress(addrFound);\n+\t\tCAddress& addrFound = (*it).second;\n+\t\tint64 nUpdateInterval = 20 * 60;\n+\t\tif (addrFound.nTime < GetAdjustedTime() - nUpdateInterval)\n+\t\t    {\n+\t\t\t// Periodically update most recently seen time\n+\t\t\taddrFound.nTime = GetAdjustedTime();\n+\t\t\tCAddrDB addrdb;\n+\t\t\taddrdb.WriteAddress(addrFound);\n+\t\t    }\n \t    }\n-\t}\n     }\n }\n \n@@ -452,8 +452,8 @@ bool AnySubscribed(unsigned int nChannel)\n \treturn true;\n     CRITICAL_BLOCK(cs_vNodes)\n \tforeach(CNode* pnode, vNodes)\n-\t    if (pnode->IsSubscribed(nChannel))\n-\t\treturn true;\n+\tif (pnode->IsSubscribed(nChannel))\n+\t    return true;\n     return false;\n }\n \n@@ -470,13 +470,13 @@ void CNode::Subscribe(unsigned int nChannel, unsigned int nHops)\n \treturn;\n \n     if (!AnySubscribed(nChannel))\n-    {\n-\t// Relay subscribe\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t    foreach(CNode* pnode, vNodes)\n+\t{\n+\t    // Relay subscribe\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tforeach(CNode* pnode, vNodes)\n \t\tif (pnode != this)\n \t\t    pnode->PushMessage(\"subscribe\", nChannel, nHops);\n-    }\n+\t}\n \n     vfSubscribe[nChannel] = true;\n }\n@@ -492,13 +492,13 @@ void CNode::CancelSubscribe(unsigned int nChannel)\n     vfSubscribe[nChannel] = false;\n \n     if (!AnySubscribed(nChannel))\n-    {\n-\t// Relay subscription cancel\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t    foreach(CNode* pnode, vNodes)\n+\t{\n+\t    // Relay subscription cancel\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tforeach(CNode* pnode, vNodes)\n \t\tif (pnode != this)\n \t\t    pnode->PushMessage(\"sub-cancel\", nChannel);\n-    }\n+\t}\n }\n \n \n@@ -539,69 +539,69 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n     // Look for an existing connection\n     CNode* pnode = FindNode(addrConnect.ip);\n     if (pnode)\n-    {\n-\tif (nTimeout != 0)\n-\t    pnode->AddRef(nTimeout);\n-\telse\n-\t    pnode->AddRef();\n-\treturn pnode;\n-    }\n+\t{\n+\t    if (nTimeout != 0)\n+\t\tpnode->AddRef(nTimeout);\n+\t    else\n+\t\tpnode->AddRef();\n+\t    return pnode;\n+\t}\n \n     /// debug print\n     printf(\"trying connection %s lastseen=%.1fhrs lasttry=%.1fhrs\\n\",\n-\taddrConnect.ToString().c_str(),\n-\t(double)(addrConnect.nTime - GetAdjustedTime())/3600.0,\n-\t(double)(addrConnect.nLastTry - GetAdjustedTime())/3600.0);\n+\t   addrConnect.ToString().c_str(),\n+\t   (double)(addrConnect.nTime - GetAdjustedTime())/3600.0,\n+\t   (double)(addrConnect.nLastTry - GetAdjustedTime())/3600.0);\n \n     CRITICAL_BLOCK(cs_mapAddresses)\n \tmapAddresses[addrConnect.GetKey()].nLastTry = GetAdjustedTime();\n \n     // Connect\n     SOCKET hSocket;\n     if (ConnectSocket(addrConnect, hSocket))\n-    {\n-\t/// debug print\n-\tprintf(\"connected %s\\n\", addrConnect.ToString().c_str());\n+\t{\n+\t    /// debug print\n+\t    printf(\"connected %s\\n\", addrConnect.ToString().c_str());\n \n-\t// Set to nonblocking\n+\t    // Set to nonblocking\n #ifdef __WXMSW__\n-\tu_long nOne = 1;\n-\tif (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n-\t    printf(\"ConnectSocket() : ioctlsocket nonblocking setting failed, error %d\\n\", WSAGetLastError());\n+\t    u_long nOne = 1;\n+\t    if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n+\t\tprintf(\"ConnectSocket() : ioctlsocket nonblocking setting failed, error %d\\n\", WSAGetLastError());\n #else\n-\tif (fcntl(hSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n-\t    printf(\"ConnectSocket() : fcntl nonblocking setting failed, error %d\\n\", errno);\n+\t    if (fcntl(hSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n+\t\tprintf(\"ConnectSocket() : fcntl nonblocking setting failed, error %d\\n\", errno);\n #endif\n \n-\t// Add node\n-\tCNode* pnode = new CNode(hSocket, addrConnect, false);\n-\tif (nTimeout != 0)\n-\t    pnode->AddRef(nTimeout);\n-\telse\n-\t    pnode->AddRef();\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t    vNodes.push_back(pnode);\n+\t    // Add node\n+\t    CNode* pnode = new CNode(hSocket, addrConnect, false);\n+\t    if (nTimeout != 0)\n+\t\tpnode->AddRef(nTimeout);\n+\t    else\n+\t\tpnode->AddRef();\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tvNodes.push_back(pnode);\n \n-\tpnode->nTimeConnected = GetTime();\n-\treturn pnode;\n-    }\n+\t    pnode->nTimeConnected = GetTime();\n+\t    return pnode;\n+\t}\n     else\n-    {\n-\treturn NULL;\n-    }\n+\t{\n+\t    return NULL;\n+\t}\n }\n \n void CNode::CloseSocketDisconnect()\n {\n     fDisconnect = true;\n     if (hSocket != INVALID_SOCKET)\n-    {\n-\tif (fDebug)\n-\t    printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-\tprintf(\"disconnecting node %s\\n\", addr.ToString().c_str());\n-\tclosesocket(hSocket);\n-\thSocket = INVALID_SOCKET;\n-    }\n+\t{\n+\t    if (fDebug)\n+\t\tprintf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\t    printf(\"disconnecting node %s\\n\", addr.ToString().c_str());\n+\t    closesocket(hSocket);\n+\t    hSocket = INVALID_SOCKET;\n+\t}\n }\n \n void CNode::Cleanup()\n@@ -631,11 +631,11 @@ void ThreadSocketHandler(void* parg)\n {\n     IMPLEMENT_RANDOMIZE_STACK(ThreadSocketHandler(parg));\n     try\n-    {\n-\tvnThreadsRunning[0]++;\n-\tThreadSocketHandler2(parg);\n-\tvnThreadsRunning[0]--;\n-    }\n+\t{\n+\t    vnThreadsRunning[0]++;\n+\t    ThreadSocketHandler2(parg);\n+\t    vnThreadsRunning[0]--;\n+\t}\n     catch (std::exception& e) {\n \tvnThreadsRunning[0]--;\n \tPrintException(&e, \"ThreadSocketHandler()\");\n@@ -653,280 +653,280 @@ void ThreadSocketHandler2(void* parg)\n     int nPrevNodeCount = 0;\n \n     loop\n-    {\n-\t//\n-\t// Disconnect nodes\n-\t//\n-\tCRITICAL_BLOCK(cs_vNodes)\n \t{\n-\t    // Disconnect unused nodes\n-\t    vector<CNode*> vNodesCopy = vNodes;\n-\t    foreach(CNode* pnode, vNodesCopy)\n+\t    //\n+\t    // Disconnect nodes\n+\t    //\n+\t    CRITICAL_BLOCK(cs_vNodes)\n \t    {\n-\t\tif (pnode->fDisconnect ||\n-\t\t    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n-\t\t{\n-\t\t    // remove from vNodes\n-\t\t    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n-\n-\t\t    // close socket and cleanup\n-\t\t    pnode->CloseSocketDisconnect();\n-\t\t    pnode->Cleanup();\n-\n-\t\t    // hold in disconnected pool until all refs are released\n-\t\t    pnode->nReleaseTime = max(pnode->nReleaseTime, GetTime() + 15 * 60);\n-\t\t    if (pnode->fNetworkNode || pnode->fInbound)\n-\t\t\tpnode->Release();\n-\t\t    vNodesDisconnected.push_back(pnode);\n-\t\t}\n-\t    }\n+\t\t// Disconnect unused nodes\n+\t\tvector<CNode*> vNodesCopy = vNodes;\n+\t\tforeach(CNode* pnode, vNodesCopy)\n+\t\t    {\n+\t\t\tif (pnode->fDisconnect ||\n+\t\t\t    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n+\t\t\t    {\n+\t\t\t\t// remove from vNodes\n+\t\t\t\tvNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n-\t    // Delete disconnected nodes\n-\t    list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-\t    foreach(CNode* pnode, vNodesDisconnectedCopy)\n-\t    {\n-\t\t// wait until threads are done using it\n-\t\tif (pnode->GetRefCount() <= 0)\n-\t\t{\n-\t\t    bool fDelete = false;\n-\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-\t\t     TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-\t\t      TRY_CRITICAL_BLOCK(pnode->cs_mapRequests)\n-\t\t       TRY_CRITICAL_BLOCK(pnode->cs_inventory)\n-\t\t\tfDelete = true;\n-\t\t    if (fDelete)\n+\t\t\t\t// close socket and cleanup\n+\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t\tpnode->Cleanup();\n+\n+\t\t\t\t// hold in disconnected pool until all refs are released\n+\t\t\t\tpnode->nReleaseTime = max(pnode->nReleaseTime, GetTime() + 15 * 60);\n+\t\t\t\tif (pnode->fNetworkNode || pnode->fInbound)\n+\t\t\t\t    pnode->Release();\n+\t\t\t\tvNodesDisconnected.push_back(pnode);\n+\t\t\t    }\n+\t\t    }\n+\n+\t\t// Delete disconnected nodes\n+\t\tlist<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n+\t\tforeach(CNode* pnode, vNodesDisconnectedCopy)\n \t\t    {\n-\t\t\tvNodesDisconnected.remove(pnode);\n-\t\t\tdelete pnode;\n+\t\t\t// wait until threads are done using it\n+\t\t\tif (pnode->GetRefCount() <= 0)\n+\t\t\t    {\n+\t\t\t\tbool fDelete = false;\n+\t\t\t\tTRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t\t\t\t    TRY_CRITICAL_BLOCK(pnode->cs_mapRequests)\n+\t\t\t\t    TRY_CRITICAL_BLOCK(pnode->cs_inventory)\n+\t\t\t\t    fDelete = true;\n+\t\t\t\tif (fDelete)\n+\t\t\t\t    {\n+\t\t\t\t\tvNodesDisconnected.remove(pnode);\n+\t\t\t\t\tdelete pnode;\n+\t\t\t\t    }\n+\t\t\t    }\n \t\t    }\n-\t\t}\n \t    }\n-\t}\n-\tif (vNodes.size() != nPrevNodeCount)\n-\t{\n-\t    nPrevNodeCount = vNodes.size();\n-\t    MainFrameRepaint();\n-\t}\n+\t    if (vNodes.size() != nPrevNodeCount)\n+\t\t{\n+\t\t    nPrevNodeCount = vNodes.size();\n+\t\t    MainFrameRepaint();\n+\t\t}\n \n \n-\t//\n-\t// Find which sockets have data to receive\n-\t//\n-\tstruct timeval timeout;\n-\ttimeout.tv_sec  = 0;\n-\ttimeout.tv_usec = 50000; // frequency to poll pnode->vSend\n-\n-\tfd_set fdsetRecv;\n-\tfd_set fdsetSend;\n-\tfd_set fdsetError;\n-\tFD_ZERO(&fdsetRecv);\n-\tFD_ZERO(&fdsetSend);\n-\tFD_ZERO(&fdsetError);\n-\tSOCKET hSocketMax = 0;\n-\n-\tif(hListenSocket != INVALID_SOCKET)\n-\t    FD_SET(hListenSocket, &fdsetRecv);\n-\thSocketMax = max(hSocketMax, hListenSocket);\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t{\n-\t    foreach(CNode* pnode, vNodes)\n-\t    {\n-\t\tif (pnode->hSocket == INVALID_SOCKET || pnode->hSocket < 0)\n-\t\t    continue;\n-\t\tFD_SET(pnode->hSocket, &fdsetRecv);\n-\t\tFD_SET(pnode->hSocket, &fdsetError);\n-\t\thSocketMax = max(hSocketMax, pnode->hSocket);\n-\t\tTRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-\t\t    if (!pnode->vSend.empty())\n-\t\t\tFD_SET(pnode->hSocket, &fdsetSend);\n-\t    }\n-\t}\n-\n-\tvnThreadsRunning[0]--;\n-\tint nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-\tvnThreadsRunning[0]++;\n-\tif (fShutdown)\n-\t    return;\n-\tif (nSelect == SOCKET_ERROR)\n-\t{\n-\t    int nErr = WSAGetLastError();\n-\t    printf(\"socket select error %d\\n\", nErr);\n-\t    for (int i = 0; i <= hSocketMax; i++)\n-\t\tFD_SET(i, &fdsetRecv);\n+\t    //\n+\t    // Find which sockets have data to receive\n+\t    //\n+\t    struct timeval timeout;\n+\t    timeout.tv_sec  = 0;\n+\t    timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n+\n+\t    fd_set fdsetRecv;\n+\t    fd_set fdsetSend;\n+\t    fd_set fdsetError;\n+\t    FD_ZERO(&fdsetRecv);\n \t    FD_ZERO(&fdsetSend);\n \t    FD_ZERO(&fdsetError);\n-\t    Sleep(timeout.tv_usec/1000);\n-\t}\n-\n-\n-\t//\n-\t// Accept new connections\n-\t//\n-\tif (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n-\t{\n-\t    struct sockaddr_in sockaddr;\n-\t    socklen_t len = sizeof(sockaddr);\n-\t    SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n-\t    CAddress addr(sockaddr);\n-\t    int nInbound = 0;\n+\t    SOCKET hSocketMax = 0;\n \n+\t    if(hListenSocket != INVALID_SOCKET)\n+\t\tFD_SET(hListenSocket, &fdsetRecv);\n+\t    hSocketMax = max(hSocketMax, hListenSocket);\n \t    CRITICAL_BLOCK(cs_vNodes)\n-\t\tforeach(CNode* pnode, vNodes)\n-\t\tif (pnode->fInbound)\n-\t\t    nInbound++;\n-\t    if (hSocket == INVALID_SOCKET)\n \t    {\n-\t\tif (WSAGetLastError() != WSAEWOULDBLOCK)\n-\t\t    printf(\"socket error accept failed: %d\\n\", WSAGetLastError());\n-\t    }\n-\t    else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n-\t    {\n-\t\tclosesocket(hSocket);\n-\t    }\n-\t    else\n-\t    {\n-\t\tprintf(\"accepted connection %s\\n\", addr.ToString().c_str());\n-\t\tCNode* pnode = new CNode(hSocket, addr, true);\n-\t\tpnode->AddRef();\n-\t\tCRITICAL_BLOCK(cs_vNodes)\n-\t\t    vNodes.push_back(pnode);\n+\t\tforeach(CNode* pnode, vNodes)\n+\t\t    {\n+\t\t\tif (pnode->hSocket == INVALID_SOCKET || pnode->hSocket < 0)\n+\t\t\t    continue;\n+\t\t\tFD_SET(pnode->hSocket, &fdsetRecv);\n+\t\t\tFD_SET(pnode->hSocket, &fdsetError);\n+\t\t\thSocketMax = max(hSocketMax, pnode->hSocket);\n+\t\t\tTRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t\t    if (!pnode->vSend.empty())\n+\t\t\t\tFD_SET(pnode->hSocket, &fdsetSend);\n+\t\t    }\n \t    }\n-\t}\n-\n \n-\t//\n-\t// Service each socket\n-\t//\n-\tvector<CNode*> vNodesCopy;\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t{\n-\t    vNodesCopy = vNodes;\n-\t    foreach(CNode* pnode, vNodesCopy)\n-\t\tpnode->AddRef();\n-\t}\n-\tforeach(CNode* pnode, vNodesCopy)\n-\t{\n+\t    vnThreadsRunning[0]--;\n+\t    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+\t    vnThreadsRunning[0]++;\n \t    if (fShutdown)\n \t\treturn;\n+\t    if (nSelect == SOCKET_ERROR)\n+\t\t{\n+\t\t    int nErr = WSAGetLastError();\n+\t\t    printf(\"socket select error %d\\n\", nErr);\n+\t\t    for (int i = 0; i <= hSocketMax; i++)\n+\t\t\tFD_SET(i, &fdsetRecv);\n+\t\t    FD_ZERO(&fdsetSend);\n+\t\t    FD_ZERO(&fdsetError);\n+\t\t    Sleep(timeout.tv_usec/1000);\n+\t\t}\n+\n \n \t    //\n-\t    // Receive\n+\t    // Accept new connections\n \t    //\n-\t    if (pnode->hSocket == INVALID_SOCKET)\n-\t\tcontinue;\n-\t    if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n-\t    {\n-\t\tTRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t    if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n \t\t{\n-\t\t    CDataStream& vRecv = pnode->vRecv;\n-\t\t    unsigned int nPos = vRecv.size();\n+\t\t    struct sockaddr_in sockaddr;\n+\t\t    socklen_t len = sizeof(sockaddr);\n+\t\t    SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n+\t\t    CAddress addr(sockaddr);\n+\t\t    int nInbound = 0;\n \n-\t\t    if (nPos > 1000*GetArg(\"-maxreceivebuffer\", 10*1000)) {\n-\t\t\tif (!pnode->fDisconnect)\n-\t\t\t    printf(\"socket recv flood control disconnect (%d bytes)\\n\", vRecv.size());\n-\t\t\tpnode->CloseSocketDisconnect();\n-\t\t    }\n-\t\t    else {\n-\t\t\t// typical socket buffer is 8K-64K\n-\t\t\tchar pchBuf[0x10000];\n-\t\t\tint nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n-\t\t\tif (nBytes > 0)\n+\t\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\t\tforeach(CNode* pnode, vNodes)\n+\t\t\tif (pnode->fInbound)\n+\t\t\t    nInbound++;\n+\t\t    if (hSocket == INVALID_SOCKET)\n \t\t\t{\n-\t\t\t    vRecv.resize(nPos + nBytes);\n-\t\t\t    memcpy(&vRecv[nPos], pchBuf, nBytes);\n-\t\t\t    pnode->nLastRecv = GetTime();\n+\t\t\t    if (WSAGetLastError() != WSAEWOULDBLOCK)\n+\t\t\t\tprintf(\"socket error accept failed: %d\\n\", WSAGetLastError());\n \t\t\t}\n-\t\t\telse if (nBytes == 0)\n+\t\t    else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n \t\t\t{\n-\t\t\t    // socket closed gracefully\n-\t\t\t    if (!pnode->fDisconnect)\n-\t\t\t\tprintf(\"socket closed\\n\");\n-\t\t\t    pnode->CloseSocketDisconnect();\n+\t\t\t    closesocket(hSocket);\n \t\t\t}\n-\t\t\telse if (nBytes < 0)\n+\t\t    else\n \t\t\t{\n-\t\t\t    // error\n-\t\t\t    int nErr = WSAGetLastError();\n-\t\t\t    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-\t\t\t    {\n-\t\t\t\tif (!pnode->fDisconnect)\n-\t\t\t\t    printf(\"socket recv error %d\\n\", nErr);\n-\t\t\t\tpnode->CloseSocketDisconnect();\n-\t\t\t    }\n+\t\t\t    printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n+\t\t\t    CNode* pnode = new CNode(hSocket, addr, true);\n+\t\t\t    pnode->AddRef();\n+\t\t\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\t\t\tvNodes.push_back(pnode);\n \t\t\t}\n-\t\t    }\n \t\t}\n-\t    }\n+\n \n \t    //\n-\t    // Send\n+\t    // Service each socket\n \t    //\n-\t    if (pnode->hSocket == INVALID_SOCKET)\n-\t\tcontinue;\n-\t    if (FD_ISSET(pnode->hSocket, &fdsetSend))\n+\t    vector<CNode*> vNodesCopy;\n+\t    CRITICAL_BLOCK(cs_vNodes)\n \t    {\n-\t\tTRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\tvNodesCopy = vNodes;\n+\t\tforeach(CNode* pnode, vNodesCopy)\n+\t\t    pnode->AddRef();\n+\t    }\n+\t    foreach(CNode* pnode, vNodesCopy)\n \t\t{\n-\t\t    CDataStream& vSend = pnode->vSend;\n-\t\t    if (!vSend.empty())\n-\t\t    {\n-\t\t\tint nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n-\t\t\tif (nBytes > 0)\n+\t\t    if (fShutdown)\n+\t\t\treturn;\n+\n+\t\t    //\n+\t\t    // Receive\n+\t\t    //\n+\t\t    if (pnode->hSocket == INVALID_SOCKET)\n+\t\t\tcontinue;\n+\t\t    if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n \t\t\t{\n-\t\t\t    vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n-\t\t\t    pnode->nLastSend = GetTime();\n+\t\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t\t\t\t{\n+\t\t\t\t    CDataStream& vRecv = pnode->vRecv;\n+\t\t\t\t    unsigned int nPos = vRecv.size();\n+\n+\t\t\t\t    if (nPos > 1000*GetArg(\"-maxreceivebuffer\", 10*1000)) {\n+\t\t\t\t\tif (!pnode->fDisconnect)\n+\t\t\t\t\t    printf(\"socket recv flood control disconnect (%d bytes)\\n\", vRecv.size());\n+\t\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t\t    }\n+\t\t\t\t    else {\n+\t\t\t\t\t// typical socket buffer is 8K-64K\n+\t\t\t\t\tchar pchBuf[0x10000];\n+\t\t\t\t\tint nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n+\t\t\t\t\tif (nBytes > 0)\n+\t\t\t\t\t    {\n+\t\t\t\t\t\tvRecv.resize(nPos + nBytes);\n+\t\t\t\t\t\tmemcpy(&vRecv[nPos], pchBuf, nBytes);\n+\t\t\t\t\t\tpnode->nLastRecv = GetTime();\n+\t\t\t\t\t    }\n+\t\t\t\t\telse if (nBytes == 0)\n+\t\t\t\t\t    {\n+\t\t\t\t\t\t// socket closed gracefully\n+\t\t\t\t\t\tif (!pnode->fDisconnect)\n+\t\t\t\t\t\t    printf(\"socket closed\\n\");\n+\t\t\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t\t\t    }\n+\t\t\t\t\telse if (nBytes < 0)\n+\t\t\t\t\t    {\n+\t\t\t\t\t\t// error\n+\t\t\t\t\t\tint nErr = WSAGetLastError();\n+\t\t\t\t\t\tif (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+\t\t\t\t\t\t    {\n+\t\t\t\t\t\t\tif (!pnode->fDisconnect)\n+\t\t\t\t\t\t\t    printf(\"socket recv error %d\\n\", nErr);\n+\t\t\t\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t\t\t\t    }\n+\t\t\t\t\t    }\n+\t\t\t\t    }\n+\t\t\t\t}\n \t\t\t}\n-\t\t\telse if (nBytes < 0)\n+\n+\t\t    //\n+\t\t    // Send\n+\t\t    //\n+\t\t    if (pnode->hSocket == INVALID_SOCKET)\n+\t\t\tcontinue;\n+\t\t    if (FD_ISSET(pnode->hSocket, &fdsetSend))\n \t\t\t{\n-\t\t\t    // error\n-\t\t\t    int nErr = WSAGetLastError();\n-\t\t\t    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-\t\t\t    {\n-\t\t\t\tprintf(\"socket send error %d\\n\", nErr);\n-\t\t\t\tpnode->CloseSocketDisconnect();\n-\t\t\t    }\n+\t\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t\t\t{\n+\t\t\t\t    CDataStream& vSend = pnode->vSend;\n+\t\t\t\t    if (!vSend.empty())\n+\t\t\t\t\t{\n+\t\t\t\t\t    int nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n+\t\t\t\t\t    if (nBytes > 0)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t    vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n+\t\t\t\t\t\t    pnode->nLastSend = GetTime();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t    else if (nBytes < 0)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t    // error\n+\t\t\t\t\t\t    int nErr = WSAGetLastError();\n+\t\t\t\t\t\t    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t    printf(\"socket send error %d\\n\", nErr);\n+\t\t\t\t\t\t\t    pnode->CloseSocketDisconnect();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t    if (vSend.size() > 1000*GetArg(\"-maxsendbuffer\", 10*1000)) {\n+\t\t\t\t\t\tif (!pnode->fDisconnect)\n+\t\t\t\t\t\t    printf(\"socket send flood control disconnect (%d bytes)\\n\", vSend.size());\n+\t\t\t\t\t\tpnode->CloseSocketDisconnect();\n+\t\t\t\t\t    }\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tif (vSend.size() > 1000*GetArg(\"-maxsendbuffer\", 10*1000)) {\n-\t\t\t    if (!pnode->fDisconnect)\n-\t\t\t\tprintf(\"socket send flood control disconnect (%d bytes)\\n\", vSend.size());\n-\t\t\t    pnode->CloseSocketDisconnect();\n+\n+\t\t    //\n+\t\t    // Inactivity checking\n+\t\t    //\n+\t\t    if (pnode->vSend.empty())\n+\t\t\tpnode->nLastSendEmpty = GetTime();\n+\t\t    if (GetTime() - pnode->nTimeConnected > 60)\n+\t\t\t{\n+\t\t\t    if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n+\t\t\t\t{\n+\t\t\t\t    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n+\t\t\t\t    pnode->fDisconnect = true;\n+\t\t\t\t}\n+\t\t\t    else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n+\t\t\t\t{\n+\t\t\t\t    printf(\"socket not sending\\n\");\n+\t\t\t\t    pnode->fDisconnect = true;\n+\t\t\t\t}\n+\t\t\t    else if (GetTime() - pnode->nLastRecv > 90*60)\n+\t\t\t\t{\n+\t\t\t\t    printf(\"socket inactivity timeout\\n\");\n+\t\t\t\t    pnode->fDisconnect = true;\n+\t\t\t\t}\n \t\t\t}\n-\t\t    }\n \t\t}\n-\t    }\n-\n-\t    //\n-\t    // Inactivity checking\n-\t    //\n-\t    if (pnode->vSend.empty())\n-\t\tpnode->nLastSendEmpty = GetTime();\n-\t    if (GetTime() - pnode->nTimeConnected > 60)\n+\t    CRITICAL_BLOCK(cs_vNodes)\n \t    {\n-\t\tif (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n-\t\t{\n-\t\t    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n-\t\t    pnode->fDisconnect = true;\n-\t\t}\n-\t\telse if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n-\t\t{\n-\t\t    printf(\"socket not sending\\n\");\n-\t\t    pnode->fDisconnect = true;\n-\t\t}\n-\t\telse if (GetTime() - pnode->nLastRecv > 90*60)\n-\t\t{\n-\t\t    printf(\"socket inactivity timeout\\n\");\n-\t\t    pnode->fDisconnect = true;\n-\t\t}\n+\t\tforeach(CNode* pnode, vNodesCopy)\n+\t\t    pnode->Release();\n \t    }\n-\t}\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t{\n-\t    foreach(CNode* pnode, vNodesCopy)\n-\t\tpnode->Release();\n-\t}\n \n-\tSleep(10);\n-    }\n+\t    Sleep(10);\n+\t}\n }\n \n \n@@ -942,11 +942,11 @@ void ThreadMapPort(void* parg)\n {\n     IMPLEMENT_RANDOMIZE_STACK(ThreadMapPort(parg));\n     try\n-    {\n-\tvnThreadsRunning[5]++;\n-\tThreadMapPort2(parg);\n-\tvnThreadsRunning[5]--;\n-    }\n+\t{\n+\t    vnThreadsRunning[5]++;\n+\t    ThreadMapPort2(parg);\n+\t    vnThreadsRunning[5]--;\n+\t}\n     catch (std::exception& e) {\n \tvnThreadsRunning[5]--;\n \tPrintException(&e, \"ThreadMapPort()\");\n@@ -978,34 +978,34 @@ void ThreadMapPort2(void* parg)\n \n     r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n     if (r == 1)\n-    {\n-\tchar intClient[16];\n-\tchar intPort[6];\n+\t{\n+\t    char intClient[16];\n+\t    char intPort[6];\n \n #ifndef __WXMSW__\n-\tr = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-\t\t\t\tport, port, lanaddr, 0, \"TCP\", 0);\n+\t    r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n+\t\t\t\t    port, port, lanaddr, 0, \"TCP\", 0);\n #else\n-\tr = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-\t\t\t\tport, port, lanaddr, 0, \"TCP\", 0, \"0\");\n+\t    r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n+\t\t\t\t    port, port, lanaddr, 0, \"TCP\", 0, \"0\");\n #endif\n-\tif(r!=UPNPCOMMAND_SUCCESS)\n-\t    printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n-\t\tport, port, lanaddr, r, strupnperror(r));\n-\telse\n-\t    printf(\"UPnP Port Mapping successful.\\n\");\n-\tloop {\n-\t    if (fShutdown || !fUseUPnP)\n-\t    {\n-\t\tr = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port, \"TCP\", 0);\n-\t\tprintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n-\t\tfreeUPNPDevlist(devlist); devlist = 0;\n-\t\tFreeUPNPUrls(&urls);\n-\t\treturn;\n+\t    if(r!=UPNPCOMMAND_SUCCESS)\n+\t\tprintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n+\t\t       port, port, lanaddr, r, strupnperror(r));\n+\t    else\n+\t\tprintf(\"UPnP Port Mapping successful.\\n\");\n+\t    loop {\n+\t\tif (fShutdown || !fUseUPnP)\n+\t\t    {\n+\t\t\tr = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port, \"TCP\", 0);\n+\t\t\tprintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+\t\t\tfreeUPNPDevlist(devlist); devlist = 0;\n+\t\t\tFreeUPNPUrls(&urls);\n+\t\t\treturn;\n+\t\t    }\n+\t\tSleep(2000);\n \t    }\n-\t    Sleep(2000);\n-\t}\n-    } else {\n+\t} else {\n \tprintf(\"No valid UPnP IGDs found\\n\");\n \tfreeUPNPDevlist(devlist); devlist = 0;\n \tif (r != 0)\n@@ -1021,15 +1021,15 @@ void ThreadMapPort2(void* parg)\n void MapPort(bool fMapPort)\n {\n     if (fUseUPnP != fMapPort)\n-    {\n-\tfUseUPnP = fMapPort;\n-\tCWalletDB().WriteSetting(\"fUseUPnP\", fUseUPnP);\n-    }\n+\t{\n+\t    fUseUPnP = fMapPort;\n+\t    CWalletDB().WriteSetting(\"fUseUPnP\", fUseUPnP);\n+\t}\n     if (fUseUPnP && vnThreadsRunning[5] < 1)\n-    {\n-\tif (!CreateThread(ThreadMapPort, NULL))\n-\t    printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n-    }\n+\t{\n+\t    if (!CreateThread(ThreadMapPort, NULL))\n+\t\tprintf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n+\t}\n }\n #endif\n \n@@ -1056,17 +1056,17 @@ void DNSAddressSeed()\n     for (int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n \tvector<CAddress> vaddr;\n \tif (Lookup(strDNSSeed[seed_idx], vaddr, NODE_NETWORK, true))\n-\t{\n-\t    foreach (CAddress& addr, vaddr)\n \t    {\n-\t\tif (addr.GetByte(3) != 127)\n-\t\t{\n-\t\t    addr.nTime = 0;\n-\t\t    AddAddress(addr);\n-\t\t    found++;\n-\t\t}\n+\t\tforeach (CAddress& addr, vaddr)\n+\t\t    {\n+\t\t\tif (addr.GetByte(3) != 127)\n+\t\t\t    {\n+\t\t\t\taddr.nTime = 0;\n+\t\t\t\tAddAddress(addr);\n+\t\t\t\tfound++;\n+\t\t\t    }\n+\t\t    }\n \t    }\n-\t}\n     }\n \n     printf(\"%d addresses found from DNS seeds\\n\", found);\n@@ -1075,60 +1075,60 @@ void DNSAddressSeed()\n \n \n unsigned int pnSeed[] =\n-{\n-    0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,\n-    0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,\n-    0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,\n-    0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,\n-    0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,\n-    0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,\n-    0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,\n-    0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,\n-    0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,\n-    0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,\n-    0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,\n-    0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,\n-    0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,\n-    0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,\n-    0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,\n-    0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,\n-    0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,\n-    0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,\n-    0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,\n-    0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,\n-    0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,\n-    0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,\n-    0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,\n-    0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,\n-    0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,\n-    0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,\n-    0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,\n-    0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,\n-    0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,\n-    0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,\n-    0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,\n-    0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,\n-    0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,\n-    0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,\n-    0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,\n-    0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,\n-    0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,\n-    0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,\n-    0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,\n-    0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,\n-};\n+    {\n+\t0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,\n+\t0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,\n+\t0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,\n+\t0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,\n+\t0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,\n+\t0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,\n+\t0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,\n+\t0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,\n+\t0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,\n+\t0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,\n+\t0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,\n+\t0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,\n+\t0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,\n+\t0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,\n+\t0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,\n+\t0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,\n+\t0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,\n+\t0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,\n+\t0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,\n+\t0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,\n+\t0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,\n+\t0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,\n+\t0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,\n+\t0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,\n+\t0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,\n+\t0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,\n+\t0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,\n+\t0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,\n+\t0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,\n+\t0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,\n+\t0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,\n+\t0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,\n+\t0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,\n+\t0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,\n+\t0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,\n+\t0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,\n+\t0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,\n+\t0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,\n+\t0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,\n+\t0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,\n+    };\n \n \n \n void ThreadOpenConnections(void* parg)\n {\n     IMPLEMENT_RANDOMIZE_STACK(ThreadOpenConnections(parg));\n     try\n-    {\n-\tvnThreadsRunning[1]++;\n-\tThreadOpenConnections2(parg);\n-\tvnThreadsRunning[1]--;\n-    }\n+\t{\n+\t    vnThreadsRunning[1]++;\n+\t    ThreadOpenConnections2(parg);\n+\t    vnThreadsRunning[1]--;\n+\t}\n     catch (std::exception& e) {\n \tvnThreadsRunning[1]--;\n \tPrintException(&e, \"ThreadOpenConnections()\");\n@@ -1145,186 +1145,186 @@ void ThreadOpenConnections2(void* parg)\n \n     // Connect to specific addresses\n     if (mapArgs.count(\"-connect\"))\n-    {\n-\tfor (int64 nLoop = 0;; nLoop++)\n \t{\n-\t    foreach(string strAddr, mapMultiArgs[\"-connect\"])\n-\t    {\n-\t\tCAddress addr(strAddr, fAllowDNS);\n-\t\tif (addr.IsValid())\n-\t\t    OpenNetworkConnection(addr);\n-\t\tfor (int i = 0; i < 10 && i < nLoop; i++)\n+\t    for (int64 nLoop = 0;; nLoop++)\n \t\t{\n-\t\t    Sleep(500);\n-\t\t    if (fShutdown)\n-\t\t\treturn;\n+\t\t    foreach(string strAddr, mapMultiArgs[\"-connect\"])\n+\t\t\t{\n+\t\t\t    CAddress addr(strAddr, fAllowDNS);\n+\t\t\t    if (addr.IsValid())\n+\t\t\t\tOpenNetworkConnection(addr);\n+\t\t\t    for (int i = 0; i < 10 && i < nLoop; i++)\n+\t\t\t\t{\n+\t\t\t\t    Sleep(500);\n+\t\t\t\t    if (fShutdown)\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t    }\n \t}\n-    }\n \n     // Connect to manually added nodes first\n     if (mapArgs.count(\"-addnode\"))\n-    {\n-\tforeach(string strAddr, mapMultiArgs[\"-addnode\"])\n \t{\n-\t    CAddress addr(strAddr, fAllowDNS);\n-\t    if (addr.IsValid())\n-\t    {\n-\t\tOpenNetworkConnection(addr);\n-\t\tSleep(500);\n-\t\tif (fShutdown)\n-\t\t    return;\n-\t    }\n+\t    foreach(string strAddr, mapMultiArgs[\"-addnode\"])\n+\t\t{\n+\t\t    CAddress addr(strAddr, fAllowDNS);\n+\t\t    if (addr.IsValid())\n+\t\t\t{\n+\t\t\t    OpenNetworkConnection(addr);\n+\t\t\t    Sleep(500);\n+\t\t\t    if (fShutdown)\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n \t}\n-    }\n \n     // Initiate network connections\n     int64 nStart = GetTime();\n     loop\n-    {\n-\t// Limit outbound connections\n-\tvnThreadsRunning[1]--;\n-\tSleep(500);\n-\tloop\n-\t{\n-\t    int nOutbound = 0;\n-\t    CRITICAL_BLOCK(cs_vNodes)\n-\t\tforeach(CNode* pnode, vNodes)\n-\t\t    if (!pnode->fInbound)\n-\t\t\tnOutbound++;\n-\t    int nMaxOutboundConnections = MAX_OUTBOUND_CONNECTIONS;\n-\t    nMaxOutboundConnections = min(nMaxOutboundConnections, (int)GetArg(\"-maxconnections\", 125));\n-\t    if (nOutbound < nMaxOutboundConnections)\n-\t\tbreak;\n-\t    Sleep(2000);\n-\t    if (fShutdown)\n-\t\treturn;\n-\t}\n-\tvnThreadsRunning[1]++;\n-\tif (fShutdown)\n-\t    return;\n-\n-\tCRITICAL_BLOCK(cs_mapAddresses)\n \t{\n-\t    // Add seed nodes if IRC isn't working\n-\t    static bool fSeedUsed;\n-\t    bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n-\t    if (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n-\t    {\n-\t\tfor (int i = 0; i < ARRAYLEN(pnSeed); i++)\n-\t\t{\n-\t\t    // It'll only connect to one or two seed nodes because once it connects,\n-\t\t    // it'll get a pile of addresses with newer timestamps.\n-\t\t    CAddress addr;\n-\t\t    addr.ip = pnSeed[i];\n-\t\t    addr.nTime = 0;\n-\t\t    AddAddress(addr);\n-\t\t}\n-\t\tfSeedUsed = true;\n-\t    }\n-\n-\t    if (fSeedUsed && mapAddresses.size() > ARRAYLEN(pnSeed) + 100)\n-\t    {\n-\t\t// Disconnect seed nodes\n-\t\tset<unsigned int> setSeed(pnSeed, pnSeed + ARRAYLEN(pnSeed));\n-\t\tstatic int64 nSeedDisconnected;\n-\t\tif (nSeedDisconnected == 0)\n+\t    // Limit outbound connections\n+\t    vnThreadsRunning[1]--;\n+\t    Sleep(500);\n+\t    loop\n \t\t{\n-\t\t    nSeedDisconnected = GetTime();\n+\t\t    int nOutbound = 0;\n \t\t    CRITICAL_BLOCK(cs_vNodes)\n \t\t\tforeach(CNode* pnode, vNodes)\n-\t\t\t    if (setSeed.count(pnode->addr.ip))\n-\t\t\t\tpnode->fDisconnect = true;\n+\t\t\tif (!pnode->fInbound)\n+\t\t\t    nOutbound++;\n+\t\t    int nMaxOutboundConnections = MAX_OUTBOUND_CONNECTIONS;\n+\t\t    nMaxOutboundConnections = min(nMaxOutboundConnections, (int)GetArg(\"-maxconnections\", 125));\n+\t\t    if (nOutbound < nMaxOutboundConnections)\n+\t\t\tbreak;\n+\t\t    Sleep(2000);\n+\t\t    if (fShutdown)\n+\t\t\treturn;\n \t\t}\n+\t    vnThreadsRunning[1]++;\n+\t    if (fShutdown)\n+\t\treturn;\n \n-\t\t// Keep setting timestamps to 0 so they won't reconnect\n-\t\tif (GetTime() - nSeedDisconnected < 60 * 60)\n-\t\t{\n-\t\t    foreach(PAIRTYPE(const vector<unsigned char>, CAddress)& item, mapAddresses)\n+\t    CRITICAL_BLOCK(cs_mapAddresses)\n+\t    {\n+\t\t// Add seed nodes if IRC isn't working\n+\t\tstatic bool fSeedUsed;\n+\t\tbool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n+\t\tif (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n \t\t    {\n-\t\t\tif (setSeed.count(item.second.ip) && item.second.nTime != 0)\n-\t\t\t{\n-\t\t\t    item.second.nTime = 0;\n-\t\t\t    CAddrDB().WriteAddress(item.second);\n-\t\t\t}\n+\t\t\tfor (int i = 0; i < ARRAYLEN(pnSeed); i++)\n+\t\t\t    {\n+\t\t\t\t// It'll only connect to one or two seed nodes because once it connects,\n+\t\t\t\t// it'll get a pile of addresses with newer timestamps.\n+\t\t\t\tCAddress addr;\n+\t\t\t\taddr.ip = pnSeed[i];\n+\t\t\t\taddr.nTime = 0;\n+\t\t\t\tAddAddress(addr);\n+\t\t\t    }\n+\t\t\tfSeedUsed = true;\n+\t\t    }\n+\n+\t\tif (fSeedUsed && mapAddresses.size() > ARRAYLEN(pnSeed) + 100)\n+\t\t    {\n+\t\t\t// Disconnect seed nodes\n+\t\t\tset<unsigned int> setSeed(pnSeed, pnSeed + ARRAYLEN(pnSeed));\n+\t\t\tstatic int64 nSeedDisconnected;\n+\t\t\tif (nSeedDisconnected == 0)\n+\t\t\t    {\n+\t\t\t\tnSeedDisconnected = GetTime();\n+\t\t\t\tCRITICAL_BLOCK(cs_vNodes)\n+\t\t\t\t    foreach(CNode* pnode, vNodes)\n+\t\t\t\t    if (setSeed.count(pnode->addr.ip))\n+\t\t\t\t\tpnode->fDisconnect = true;\n+\t\t\t    }\n+\n+\t\t\t// Keep setting timestamps to 0 so they won't reconnect\n+\t\t\tif (GetTime() - nSeedDisconnected < 60 * 60)\n+\t\t\t    {\n+\t\t\t\tforeach(PAIRTYPE(const vector<unsigned char>, CAddress)& item, mapAddresses)\n+\t\t\t\t    {\n+\t\t\t\t\tif (setSeed.count(item.second.ip) && item.second.nTime != 0)\n+\t\t\t\t\t    {\n+\t\t\t\t\t\titem.second.nTime = 0;\n+\t\t\t\t\t\tCAddrDB().WriteAddress(item.second);\n+\t\t\t\t\t    }\n+\t\t\t\t    }\n+\t\t\t    }\n \t\t    }\n-\t\t}\n \t    }\n-\t}\n \n \n-\t//\n-\t// Choose an address to connect to based on most recently seen\n-\t//\n-\tCAddress addrConnect;\n-\tint64 nBest = INT64_MIN;\n+\t    //\n+\t    // Choose an address to connect to based on most recently seen\n+\t    //\n+\t    CAddress addrConnect;\n+\t    int64 nBest = INT64_MIN;\n \n-\t// Only connect to one address per a.b.?.? range.\n-\t// Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n-\tset<unsigned int> setConnected;\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t    foreach(CNode* pnode, vNodes)\n+\t    // Only connect to one address per a.b.?.? range.\n+\t    // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n+\t    set<unsigned int> setConnected;\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t\tforeach(CNode* pnode, vNodes)\n \t\tsetConnected.insert(pnode->addr.ip & 0x0000ffff);\n \n-\tCRITICAL_BLOCK(cs_mapAddresses)\n-\t{\n-\t    foreach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n+\t    CRITICAL_BLOCK(cs_mapAddresses)\n \t    {\n-\t\tconst CAddress& addr = item.second;\n-\t\tif (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.ip & 0x0000ffff))\n-\t\t    continue;\n-\t\tint64 nSinceLastSeen = GetAdjustedTime() - addr.nTime;\n-\t\tint64 nSinceLastTry = GetAdjustedTime() - addr.nLastTry;\n-\n-\t\t// Randomize the order in a deterministic way, putting the standard port first\n-\t\tint64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n-\t\tif (addr.port != htons(GetDefaultPort()))\n-\t\t    nRandomizer += 2 * 60 * 60;\n-\n-\t\t// Last seen  Base retry frequency\n-\t\t//   <1 hour   10 min\n-\t\t//    1 hour    1 hour\n-\t\t//    4 hours   2 hours\n-\t\t//   24 hours   5 hours\n-\t\t//   48 hours   7 hours\n-\t\t//    7 days   13 hours\n-\t\t//   30 days   27 hours\n-\t\t//   90 days   46 hours\n-\t\t//  365 days   93 hours\n-\t\tint64 nDelay = (int64)(3600.0 * sqrt(fabs((double)nSinceLastSeen) / 3600.0) + nRandomizer);\n-\n-\t\t// Fast reconnect for one hour after last seen\n-\t\tif (nSinceLastSeen < 60 * 60)\n-\t\t    nDelay = 10 * 60;\n-\n-\t\t// Limit retry frequency\n-\t\tif (nSinceLastTry < nDelay)\n-\t\t    continue;\n-\n-\t\t// If we have IRC, we'll be notified when they first come online,\n-\t\t// and again every 24 hours by the refresh broadcast.\n-\t\tif (nGotIRCAddresses > 0 && vNodes.size() >= 2 && nSinceLastSeen > 24 * 60 * 60)\n-\t\t    continue;\n-\n-\t\t// Only try the old stuff if we don't have enough connections\n-\t\tif (vNodes.size() >= 8 && nSinceLastSeen > 24 * 60 * 60)\n-\t\t    continue;\n-\n-\t\t// If multiple addresses are ready, prioritize by time since\n-\t\t// last seen and time since last tried.\n-\t\tint64 nScore = min(nSinceLastTry, (int64)24 * 60 * 60) - nSinceLastSeen - nRandomizer;\n-\t\tif (nScore > nBest)\n-\t\t{\n-\t\t    nBest = nScore;\n-\t\t    addrConnect = addr;\n-\t\t}\n+\t\tforeach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n+\t\t    {\n+\t\t\tconst CAddress& addr = item.second;\n+\t\t\tif (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.ip & 0x0000ffff))\n+\t\t\t    continue;\n+\t\t\tint64 nSinceLastSeen = GetAdjustedTime() - addr.nTime;\n+\t\t\tint64 nSinceLastTry = GetAdjustedTime() - addr.nLastTry;\n+\n+\t\t\t// Randomize the order in a deterministic way, putting the standard port first\n+\t\t\tint64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n+\t\t\tif (addr.port != htons(GetDefaultPort()))\n+\t\t\t    nRandomizer += 2 * 60 * 60;\n+\n+\t\t\t// Last seen  Base retry frequency\n+\t\t\t//   <1 hour   10 min\n+\t\t\t//    1 hour    1 hour\n+\t\t\t//    4 hours   2 hours\n+\t\t\t//   24 hours   5 hours\n+\t\t\t//   48 hours   7 hours\n+\t\t\t//    7 days   13 hours\n+\t\t\t//   30 days   27 hours\n+\t\t\t//   90 days   46 hours\n+\t\t\t//  365 days   93 hours\n+\t\t\tint64 nDelay = (int64)(3600.0 * sqrt(fabs((double)nSinceLastSeen) / 3600.0) + nRandomizer);\n+\n+\t\t\t// Fast reconnect for one hour after last seen\n+\t\t\tif (nSinceLastSeen < 60 * 60)\n+\t\t\t    nDelay = 10 * 60;\n+\n+\t\t\t// Limit retry frequency\n+\t\t\tif (nSinceLastTry < nDelay)\n+\t\t\t    continue;\n+\n+\t\t\t// If we have IRC, we'll be notified when they first come online,\n+\t\t\t// and again every 24 hours by the refresh broadcast.\n+\t\t\tif (nGotIRCAddresses > 0 && vNodes.size() >= 2 && nSinceLastSeen > 24 * 60 * 60)\n+\t\t\t    continue;\n+\n+\t\t\t// Only try the old stuff if we don't have enough connections\n+\t\t\tif (vNodes.size() >= 8 && nSinceLastSeen > 24 * 60 * 60)\n+\t\t\t    continue;\n+\n+\t\t\t// If multiple addresses are ready, prioritize by time since\n+\t\t\t// last seen and time since last tried.\n+\t\t\tint64 nScore = min(nSinceLastTry, (int64)24 * 60 * 60) - nSinceLastSeen - nRandomizer;\n+\t\t\tif (nScore > nBest)\n+\t\t\t    {\n+\t\t\t\tnBest = nScore;\n+\t\t\t\taddrConnect = addr;\n+\t\t\t    }\n+\t\t    }\n \t    }\n-\t}\n \n-\tif (addrConnect.IsValid())\n-\t    OpenNetworkConnection(addrConnect);\n-    }\n+\t    if (addrConnect.IsValid())\n+\t\tOpenNetworkConnection(addrConnect);\n+\t}\n }\n \n bool OpenNetworkConnection(const CAddress& addrConnect)\n@@ -1380,51 +1380,51 @@ void ThreadMessageHandler2(void* parg)\n     printf(\"ThreadMessageHandler started\\n\");\n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n     while (!fShutdown)\n-    {\n-\tvector<CNode*> vNodesCopy;\n-\tCRITICAL_BLOCK(cs_vNodes)\n \t{\n-\t    vNodesCopy = vNodes;\n+\t    vector<CNode*> vNodesCopy;\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t    {\n+\t\tvNodesCopy = vNodes;\n+\t\tforeach(CNode* pnode, vNodesCopy)\n+\t\t    pnode->AddRef();\n+\t    }\n+\n+\t    // Poll the connected nodes for messages\n+\t    CNode* pnodeTrickle = NULL;\n+\t    if (!vNodesCopy.empty())\n+\t\tpnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n \t    foreach(CNode* pnode, vNodesCopy)\n-\t\tpnode->AddRef();\n-\t}\n+\t\t{\n+\t\t    // Receive messages\n+\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+\t\t\tProcessMessages(pnode);\n+\t\t    if (fShutdown)\n+\t\t\treturn;\n \n-\t// Poll the connected nodes for messages\n-\tCNode* pnodeTrickle = NULL;\n-\tif (!vNodesCopy.empty())\n-\t    pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n-\tforeach(CNode* pnode, vNodesCopy)\n-\t{\n-\t    // Receive messages\n-\t    TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-\t\tProcessMessages(pnode);\n-\t    if (fShutdown)\n-\t\treturn;\n+\t\t    // Send messages\n+\t\t    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+\t\t\tSendMessages(pnode, pnode == pnodeTrickle);\n+\t\t    if (fShutdown)\n+\t\t\treturn;\n+\t\t}\n+\n+\t    CRITICAL_BLOCK(cs_vNodes)\n+\t    {\n+\t\tforeach(CNode* pnode, vNodesCopy)\n+\t\t    pnode->Release();\n+\t    }\n \n-\t    // Send messages\n-\t    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-\t\tSendMessages(pnode, pnode == pnodeTrickle);\n+\t    // Wait and allow messages to bunch up.\n+\t    // Reduce vnThreadsRunning so StopNode has permission to exit while\n+\t    // we're sleeping, but we must always check fShutdown after doing this.\n+\t    vnThreadsRunning[2]--;\n+\t    Sleep(100);\n+\t    if (fRequestShutdown)\n+\t\tShutdown(NULL);\n+\t    vnThreadsRunning[2]++;\n \t    if (fShutdown)\n \t\treturn;\n \t}\n-\n-\tCRITICAL_BLOCK(cs_vNodes)\n-\t{\n-\t    foreach(CNode* pnode, vNodesCopy)\n-\t\tpnode->Release();\n-\t}\n-\n-\t// Wait and allow messages to bunch up.\n-\t// Reduce vnThreadsRunning so StopNode has permission to exit while\n-\t// we're sleeping, but we must always check fShutdown after doing this.\n-\tvnThreadsRunning[2]--;\n-\tSleep(100);\n-\tif (fRequestShutdown)\n-\t    Shutdown(NULL);\n-\tvnThreadsRunning[2]++;\n-\tif (fShutdown)\n-\t    return;\n-    }\n }\n \n \n@@ -1446,21 +1446,21 @@ bool BindListenPort(string& strError)\n     WSADATA wsadata;\n     int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n     if (ret != NO_ERROR)\n-    {\n-\tstrError = strprintf(\"Error: TCP/IP socket library failed to start (WSAStartup returned error %d)\", ret);\n-\tprintf(\"%s\\n\", strError.c_str());\n-\treturn false;\n-    }\n+\t{\n+\t    strError = strprintf(\"Error: TCP/IP socket library failed to start (WSAStartup returned error %d)\", ret);\n+\t    printf(\"%s\\n\", strError.c_str());\n+\t    return false;\n+\t}\n #endif\n \n     // Create socket for listening for incoming connections\n     hListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n     if (hListenSocket == INVALID_SOCKET)\n-    {\n-\tstrError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n-\tprintf(\"%s\\n\", strError.c_str());\n-\treturn false;\n-    }\n+\t{\n+\t    strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n+\t    printf(\"%s\\n\", strError.c_str());\n+\t    return false;\n+\t}\n \n #ifdef BSD\n     // Different way of disabling SIGPIPE on BSD\n@@ -1477,13 +1477,13 @@ bool BindListenPort(string& strError)\n     // Set to nonblocking, incoming connections will also inherit this\n     if (ioctlsocket(hListenSocket, FIONBIO, (u_long*)&nOne) == SOCKET_ERROR)\n #else\n-    if (fcntl(hListenSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n+\tif (fcntl(hListenSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n #endif\n-    {\n-\tstrError = strprintf(\"Error: Couldn't set properties on socket for incoming connections (error %d)\", WSAGetLastError());\n-\tprintf(\"%s\\n\", strError.c_str());\n-\treturn false;\n-    }\n+\t    {\n+\t\tstrError = strprintf(\"Error: Couldn't set properties on socket for incoming connections (error %d)\", WSAGetLastError());\n+\t\tprintf(\"%s\\n\", strError.c_str());\n+\t\treturn false;\n+\t    }\n \n     // The sockaddr_in structure specifies the address family,\n     // IP address, and port for the socket that is being bound\n@@ -1493,24 +1493,24 @@ bool BindListenPort(string& strError)\n     sockaddr.sin_addr.s_addr = INADDR_ANY; // bind to all IPs on this computer\n     sockaddr.sin_port = htons(GetDefaultPort());\n     if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n-    {\n-\tint nErr = WSAGetLastError();\n-\tif (nErr == WSAEADDRINUSE)\n-\t    strError = strprintf(_(\"Unable to bind to port %d on this computer.  Bitcoin is probably already running.\"), ntohs(sockaddr.sin_port));\n-\telse\n-\t    strError = strprintf(\"Error: Unable to bind to port %d on this computer (bind returned error %d)\", ntohs(sockaddr.sin_port), nErr);\n-\tprintf(\"%s\\n\", strError.c_str());\n-\treturn false;\n-    }\n+\t{\n+\t    int nErr = WSAGetLastError();\n+\t    if (nErr == WSAEADDRINUSE)\n+\t\tstrError = strprintf(_(\"Unable to bind to port %d on this computer.  Bitcoin is probably already running.\"), ntohs(sockaddr.sin_port));\n+\t    else\n+\t\tstrError = strprintf(\"Error: Unable to bind to port %d on this computer (bind returned error %d)\", ntohs(sockaddr.sin_port), nErr);\n+\t    printf(\"%s\\n\", strError.c_str());\n+\t    return false;\n+\t}\n     printf(\"Bound to port %d\\n\", ntohs(sockaddr.sin_port));\n \n     // Listen for incoming connections\n     if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n-    {\n-\tstrError = strprintf(\"Error: Listening for incoming connections failed (listen returned error %d)\", WSAGetLastError());\n-\tprintf(\"%s\\n\", strError.c_str());\n-\treturn false;\n-    }\n+\t{\n+\t    strError = strprintf(\"Error: Listening for incoming connections failed (listen returned error %d)\", WSAGetLastError());\n+\t    printf(\"%s\\n\", strError.c_str());\n+\t    return false;\n+\t}\n \n     return true;\n }\n@@ -1524,64 +1524,64 @@ void StartNode(void* parg)\n     // Get local host ip\n     char pszHostName[1000] = \"\";\n     if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n-    {\n-\tvector<CAddress> vaddr;\n-\tif (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n-\t    foreach (const CAddress &addr, vaddr)\n-\t\tif (addr.GetByte(3) != 127)\n-\t\t{\n-\t\t    addrLocalHost = addr;\n-\t\t    break;\n-\t\t}\n-    }\n+\t{\n+\t    vector<CAddress> vaddr;\n+\t    if (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n+\t\tforeach (const CAddress &addr, vaddr)\n+\t\t    if (addr.GetByte(3) != 127)\n+\t\t\t{\n+\t\t\t    addrLocalHost = addr;\n+\t\t\t    break;\n+\t\t\t}\n+\t}\n #else\n     // Get local host ip\n     struct ifaddrs* myaddrs;\n     if (getifaddrs(&myaddrs) == 0)\n-    {\n-\tfor (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n \t{\n-\t    if (ifa->ifa_addr == NULL) continue;\n-\t    if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n-\t    if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n-\t    if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n-\t    char pszIP[100];\n-\t    if (ifa->ifa_addr->sa_family == AF_INET)\n-\t    {\n-\t\tstruct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n-\t\tif (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s4->sin_addr), pszIP, sizeof(pszIP)) != NULL)\n-\t\t    printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n-\n-\t\t// Take the first IP that isn't loopback 127.x.x.x\n-\t\tCAddress addr(*(unsigned int*)&s4->sin_addr, 0, nLocalServices);\n-\t\tif (addr.IsValid() && addr.GetByte(3) != 127)\n+\t    for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n \t\t{\n-\t\t    addrLocalHost = addr;\n-\t\t    break;\n+\t\t    if (ifa->ifa_addr == NULL) continue;\n+\t\t    if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n+\t\t    if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n+\t\t    if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n+\t\t    char pszIP[100];\n+\t\t    if (ifa->ifa_addr->sa_family == AF_INET)\n+\t\t\t{\n+\t\t\t    struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n+\t\t\t    if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s4->sin_addr), pszIP, sizeof(pszIP)) != NULL)\n+\t\t\t\tprintf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n+\n+\t\t\t    // Take the first IP that isn't loopback 127.x.x.x\n+\t\t\t    CAddress addr(*(unsigned int*)&s4->sin_addr, 0, nLocalServices);\n+\t\t\t    if (addr.IsValid() && addr.GetByte(3) != 127)\n+\t\t\t\t{\n+\t\t\t\t    addrLocalHost = addr;\n+\t\t\t\t    break;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t    else if (ifa->ifa_addr->sa_family == AF_INET6)\n+\t\t\t{\n+\t\t\t    struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n+\t\t\t    if (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s6->sin6_addr), pszIP, sizeof(pszIP)) != NULL)\n+\t\t\t\tprintf(\"ipv6 %s: %s\\n\", ifa->ifa_name, pszIP);\n+\t\t\t}\n \t\t}\n-\t    }\n-\t    else if (ifa->ifa_addr->sa_family == AF_INET6)\n-\t    {\n-\t\tstruct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n-\t\tif (inet_ntop(ifa->ifa_addr->sa_family, (void*)&(s6->sin6_addr), pszIP, sizeof(pszIP)) != NULL)\n-\t\t    printf(\"ipv6 %s: %s\\n\", ifa->ifa_name, pszIP);\n-\t    }\n+\t    freeifaddrs(myaddrs);\n \t}\n-\tfreeifaddrs(myaddrs);\n-    }\n #endif\n     printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n \n     if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n-    {\n-\t// Proxies can't take incoming connections\n-\taddrLocalHost.ip = CAddress(\"0.0.0.0\").ip;\n-\tprintf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n-    }\n+\t{\n+\t    // Proxies can't take incoming connections\n+\t    addrLocalHost.ip = CAddress(\"0.0.0.0\").ip;\n+\t    printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n+\t}\n     else\n-    {\n-\tCreateThread(ThreadGetMyExternalIP, NULL);\n-    }\n+\t{\n+\t    CreateThread(ThreadGetMyExternalIP, NULL);\n+\t}\n \n     //\n     // Start threads\n@@ -1618,14 +1618,14 @@ bool StopNode()\n     int64 nStart = GetTime();\n     while (vnThreadsRunning[0] > 0 || vnThreadsRunning[2] > 0 || vnThreadsRunning[3] > 0 || vnThreadsRunning[4] > 0\n #ifdef USE_UPNP\n-\t|| vnThreadsRunning[5] > 0\n+\t   || vnThreadsRunning[5] > 0\n #endif\n-    )\n-    {\n-\tif (GetTime() - nStart > 20)\n-\t    break;\n-\tSleep(20);\n-    }\n+\t   )\n+\t{\n+\t    if (GetTime() - nStart > 20)\n+\t\tbreak;\n+\t    Sleep(20);\n+\t}\n     if (vnThreadsRunning[0] > 0) printf(\"ThreadSocketHandler still running\\n\");\n     if (vnThreadsRunning[1] > 0) printf(\"ThreadOpenConnections still running\\n\");\n     if (vnThreadsRunning[2] > 0) printf(\"ThreadMessageHandler still running\\n\");\n@@ -1661,4 +1661,4 @@ class CNetCleanup\n #endif\n     }\n }\n-instance_of_cnetcleanup;\n+    instance_of_cnetcleanup;"
      },
      {
        "sha": "5af72c9f791dfa32593bd015a31b7f864b5a2d5b",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 181,
        "deletions": 178,
        "changes": 359,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef NET_H\n+#define NET_H\n+\n class CMessageHeader;\n class CAddress;\n class CInv;\n@@ -15,9 +18,9 @@ extern int nBestHeight;\n inline unsigned short GetDefaultPort() { return fTestNet ? 18333 : 8333; }\n static const unsigned int PUBLISH_HOPS = 5;\n enum\n-{\n-    NODE_NETWORK = (1 << 0),\n-};\n+    {\n+\tNODE_NETWORK = (1 << 0),\n+    };\n \n \n \n@@ -82,12 +85,12 @@ class CMessageHeader\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(FLATDATA(pchMessageStart));\n-\tREADWRITE(FLATDATA(pchCommand));\n-\tREADWRITE(nMessageSize);\n-\tif (nVersion >= 209)\n-\t    READWRITE(nChecksum);\n-    )\n+     READWRITE(FLATDATA(pchMessageStart));\n+     READWRITE(FLATDATA(pchCommand));\n+     READWRITE(nMessageSize);\n+     if (nVersion >= 209)\n+\t READWRITE(nChecksum);\n+     )\n \n     string GetCommand()\n     {\n@@ -105,24 +108,24 @@ class CMessageHeader\n \n \t// Check the command string for errors\n \tfor (char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n-\t{\n-\t    if (*p1 == 0)\n \t    {\n-\t\t// Must be all zeros after the first zero\n-\t\tfor (; p1 < pchCommand + COMMAND_SIZE; p1++)\n-\t\t    if (*p1 != 0)\n-\t\t\treturn false;\n+\t\tif (*p1 == 0)\n+\t\t    {\n+\t\t\t// Must be all zeros after the first zero\n+\t\t\tfor (; p1 < pchCommand + COMMAND_SIZE; p1++)\n+\t\t\t    if (*p1 != 0)\n+\t\t\t\treturn false;\n+\t\t    }\n+\t\telse if (*p1 < ' ' || *p1 > 0x7E)\n+\t\t    return false;\n \t    }\n-\t    else if (*p1 < ' ' || *p1 > 0x7E)\n-\t\treturn false;\n-\t}\n \n \t// Message size\n \tif (nMessageSize > MAX_SIZE)\n-\t{\n-\t    printf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n-\t    return false;\n-\t}\n+\t    {\n+\t\tprintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n+\t\treturn false;\n+\t    }\n \n \treturn true;\n     }\n@@ -206,17 +209,17 @@ class CAddress\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tif (fRead)\n-\t    const_cast<CAddress*>(this)->Init();\n-\tif (nType & SER_DISK)\n-\t    READWRITE(nVersion);\n-\tif ((nType & SER_DISK) || (nVersion >= 31402 && !(nType & SER_GETHASH)))\n-\t    READWRITE(nTime);\n-\tREADWRITE(nServices);\n-\tREADWRITE(FLATDATA(pchReserved)); // for IPv6\n-\tREADWRITE(ip);\n-\tREADWRITE(port);\n-    )\n+     if (fRead)\n+\t const_cast<CAddress*>(this)->Init();\n+     if (nType & SER_DISK)\n+\t READWRITE(nVersion);\n+     if ((nType & SER_DISK) || (nVersion >= 31402 && !(nType & SER_GETHASH)))\n+\t READWRITE(nTime);\n+     READWRITE(nServices);\n+     READWRITE(FLATDATA(pchReserved)); // for IPv6\n+     READWRITE(ip);\n+     READWRITE(port);\n+     )\n \n     friend inline bool operator==(const CAddress& a, const CAddress& b)\n     {\n@@ -236,12 +239,12 @@ class CAddress\n \tif (ret < 0)\n \t    return true;\n \telse if (ret == 0)\n-\t{\n-\t    if (ntohl(a.ip) < ntohl(b.ip))\n-\t\treturn true;\n-\t    else if (a.ip == b.ip)\n-\t\treturn ntohs(a.port) < ntohs(b.port);\n-\t}\n+\t    {\n+\t\tif (ntohl(a.ip) < ntohl(b.ip))\n+\t\t    return true;\n+\t\telse if (a.ip == b.ip)\n+\t\t    return ntohs(a.port) < ntohs(b.port);\n+\t    }\n \treturn false;\n     }\n \n@@ -251,11 +254,11 @@ class CAddress\n \tss.reserve(18);\n \tss << FLATDATA(pchReserved) << ip << port;\n \n-\t#if defined(_MSC_VER) && _MSC_VER < 1300\n+#if defined(_MSC_VER) && _MSC_VER < 1300\n \treturn vector<unsigned char>((unsigned char*)&ss.begin()[0], (unsigned char*)&ss.end()[0]);\n-\t#else\n+#else\n \treturn vector<unsigned char>(ss.begin(), ss.end());\n-\t#endif\n+#endif\n     }\n \n     struct sockaddr_in GetSockAddr() const\n@@ -334,17 +337,17 @@ class CAddress\n \n \n enum\n-{\n-    MSG_TX = 1,\n-    MSG_BLOCK,\n-};\n+    {\n+\tMSG_TX = 1,\n+\tMSG_BLOCK,\n+    };\n \n static const char* ppszTypeName[] =\n-{\n-    \"ERROR\",\n-    \"tx\",\n-    \"block\",\n-};\n+    {\n+\t\"ERROR\",\n+\t\"tx\",\n+\t\"block\",\n+    };\n \n class CInv\n {\n@@ -368,23 +371,23 @@ class CInv\n     {\n \tint i;\n \tfor (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n-\t{\n-\t    if (strType == ppszTypeName[i])\n \t    {\n-\t\ttype = i;\n-\t\tbreak;\n+\t\tif (strType == ppszTypeName[i])\n+\t\t    {\n+\t\t\ttype = i;\n+\t\t\tbreak;\n+\t\t    }\n \t    }\n-\t}\n \tif (i == ARRAYLEN(ppszTypeName))\n \t    throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n \thash = hashIn;\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n-\tREADWRITE(type);\n-\tREADWRITE(hash);\n-    )\n+     READWRITE(type);\n+     READWRITE(hash);\n+     )\n \n     friend inline bool operator<(const CInv& a, const CInv& b)\n     {\n@@ -528,10 +531,10 @@ class CNode\n \tvRecv.SetVersion(0);\n \t// Version 0.2 obsoletes 20 Feb 2012\n \tif (GetTime() > 1329696000)\n-\t{\n-\t    vSend.SetVersion(209);\n-\t    vRecv.SetVersion(209);\n-\t}\n+\t    {\n+\t\tvSend.SetVersion(209);\n+\t\tvRecv.SetVersion(209);\n+\t    }\n \tnLastSend = 0;\n \tnLastRecv = 0;\n \tnLastSendEmpty = GetTime();\n@@ -563,10 +566,10 @@ class CNode\n     ~CNode()\n     {\n \tif (hSocket != INVALID_SOCKET)\n-\t{\n-\t    closesocket(hSocket);\n-\t    hSocket = INVALID_SOCKET;\n-\t}\n+\t    {\n+\t\tclosesocket(hSocket);\n+\t\thSocket = INVALID_SOCKET;\n+\t    }\n     }\n \n private:\n@@ -670,11 +673,11 @@ class CNode\n     void EndMessage()\n     {\n \tif (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n-\t{\n-\t    printf(\"dropmessages DROPPING SEND MESSAGE\\n\");\n-\t    AbortMessage();\n-\t    return;\n-\t}\n+\t    {\n+\t\tprintf(\"dropmessages DROPPING SEND MESSAGE\\n\");\n+\t\tAbortMessage();\n+\t\treturn;\n+\t    }\n \n \tif (nHeaderStart == -1)\n \t    return;\n@@ -685,13 +688,13 @@ class CNode\n \n \t// Set the checksum\n \tif (vSend.GetVersion() >= 209)\n-\t{\n-\t    uint256 hash = Hash(vSend.begin() + nMessageStart, vSend.end());\n-\t    unsigned int nChecksum = 0;\n-\t    memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-\t    assert(nMessageStart - nHeaderStart >= offsetof(CMessageHeader, nChecksum) + sizeof(nChecksum));\n-\t    memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nChecksum), &nChecksum, sizeof(nChecksum));\n-\t}\n+\t    {\n+\t\tuint256 hash = Hash(vSend.begin() + nMessageStart, vSend.end());\n+\t\tunsigned int nChecksum = 0;\n+\t\tmemcpy(&nChecksum, &hash, sizeof(nChecksum));\n+\t\tassert(nMessageStart - nHeaderStart >= offsetof(CMessageHeader, nChecksum) + sizeof(nChecksum));\n+\t\tmemcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nChecksum), &nChecksum, sizeof(nChecksum));\n+\t    }\n \n \tprintf(\"(%d bytes) \", nSize);\n \tprintf(\"\\n\");\n@@ -722,7 +725,7 @@ class CNode\n \tCAddress addrMe = (fUseProxy ? CAddress(\"0.0.0.0\") : addrLocalHost);\n \tRAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n \tPushMessage(\"version\", VERSION, nLocalServices, nTime, addrYou, addrMe,\n-\t\tnLocalHostNonce, string(pszSubVer), nBestHeight);\n+\t\t    nLocalHostNonce, string(pszSubVer), nBestHeight);\n     }\n \n \n@@ -731,159 +734,159 @@ class CNode\n     void PushMessage(const char* pszCommand)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1>\n     void PushMessage(const char* pszCommand, const T1& a1)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3 << a4;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3 << a4;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3 << a4 << a5;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3 << a4 << a5;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3 << a4 << a5 << a6;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3 << a4 << a5 << a6;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3 << a4 << a5 << a6 << a7;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8, const T9& a9)\n     {\n \ttry\n-\t{\n-\t    BeginMessage(pszCommand);\n-\t    vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8 << a9;\n-\t    EndMessage();\n-\t}\n+\t    {\n+\t\tBeginMessage(pszCommand);\n+\t\tvSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8 << a9;\n+\t\tEndMessage();\n+\t    }\n \tcatch (...)\n-\t{\n-\t    AbortMessage();\n-\t    throw;\n-\t}\n+\t    {\n+\t\tAbortMessage();\n+\t\tthrow;\n+\t    }\n     }\n \n \n@@ -949,7 +952,7 @@ inline void RelayInventory(const CInv& inv)\n     // Put on lists to offer to the other nodes\n     CRITICAL_BLOCK(cs_vNodes)\n \tforeach(CNode* pnode, vNodes)\n-\t    pnode->PushInventory(inv);\n+\tpnode->PushInventory(inv);\n }\n \n template<typename T>\n@@ -968,10 +971,10 @@ inline void RelayMessage<>(const CInv& inv, const CDataStream& ss)\n     {\n \t// Expire old relay messages\n \twhile (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n-\t{\n-\t    mapRelay.erase(vRelayExpiration.front().second);\n-\t    vRelayExpiration.pop_front();\n-\t}\n+\t    {\n+\t\tmapRelay.erase(vRelayExpiration.front().second);\n+\t\tvRelayExpiration.pop_front();\n+\t    }\n \n \t// Save original serialized message so newer versions are preserved\n \tmapRelay[inv] = ss;\n@@ -1008,8 +1011,8 @@ void AdvertStartPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops,\n     // Relay\n     CRITICAL_BLOCK(cs_vNodes)\n \tforeach(CNode* pnode, vNodes)\n-\t    if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n-\t\tpnode->PushMessage(\"publish\", nChannel, nHops, obj);\n+\tif (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n+\t    pnode->PushMessage(\"publish\", nChannel, nHops, obj);\n }\n \n template<typename T>\n@@ -1019,8 +1022,8 @@ void AdvertStopPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops,\n \n     CRITICAL_BLOCK(cs_vNodes)\n \tforeach(CNode* pnode, vNodes)\n-\t    if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n-\t\tpnode->PushMessage(\"pub-cancel\", nChannel, nHops, hash);\n+\tif (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))\n+\t    pnode->PushMessage(\"pub-cancel\", nChannel, nHops, hash);\n \n     AdvertErase(obj);\n }"
      },
      {
        "sha": "44e297a591fd58d42dc920ead61a840d27649ca3",
        "filename": "src/noui.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/noui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/noui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,8 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef NOUI_H\n+#define NOUI_H\n \n typedef void wxWindow;\n #define wxYES                   0x00000002\n@@ -60,3 +62,5 @@ inline void UIThreadCall(boost::function0<void> fn)\n inline void MainFrameRepaint()\n {\n }\n+\n+#endif // !NOUI_H"
      },
      {
        "sha": "f8e9a3830edb1bf109d80a8848b7b2888f37c19d",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 856,
        "deletions": 856,
        "changes": 1712,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -47,10 +47,10 @@ void PrintConsole(const char* format, ...)\n     int ret = _vsnprintf(buffer, limit, format, arg_ptr);\n     va_end(arg_ptr);\n     if (ret < 0 || ret >= limit)\n-    {\n-\tret = limit - 1;\n-\tbuffer[limit-1] = 0;\n-    }\n+\t{\n+\t    ret = limit - 1;\n+\t    buffer[limit-1] = 0;\n+\t}\n     printf(\"%s\", buffer);\n #if defined(__WXMSW__) && defined(GUI)\n     MyMessageBox(buffer, \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n@@ -104,8 +104,8 @@ Value help(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 1)\n \tthrow runtime_error(\n-\t    \"help [command]\\n\"\n-\t    \"List commands, or get help for a command.\");\n+\t\t\t    \"help [command]\\n\"\n+\t\t\t    \"List commands, or get help for a command.\");\n \n     string strCommand;\n     if (params.size() > 0)\n@@ -114,32 +114,32 @@ Value help(const Array& params, bool fHelp)\n     string strRet;\n     set<rpcfn_type> setDone;\n     for (map<string, rpcfn_type>::iterator mi = mapCallTable.begin(); mi != mapCallTable.end(); ++mi)\n-    {\n-\tstring strMethod = (*mi).first;\n-\t// We already filter duplicates, but these deprecated screw up the sort order\n-\tif (strMethod == \"getamountreceived\" ||\n-\t    strMethod == \"getallreceived\" ||\n-\t    (strMethod.find(\"label\") != string::npos))\n-\t    continue;\n-\tif (strCommand != \"\" && strMethod != strCommand)\n-\t    continue;\n-\ttry\n \t{\n-\t    Array params;\n-\t    rpcfn_type pfn = (*mi).second;\n-\t    if (setDone.insert(pfn).second)\n-\t\t(*pfn)(params, true);\n-\t}\n-\tcatch (std::exception& e)\n-\t{\n-\t    // Help text is returned in an exception\n-\t    string strHelp = string(e.what());\n-\t    if (strCommand == \"\")\n-\t\tif (strHelp.find('\\n') != -1)\n-\t\t    strHelp = strHelp.substr(0, strHelp.find('\\n'));\n-\t    strRet += strHelp + \"\\n\";\n+\t    string strMethod = (*mi).first;\n+\t    // We already filter duplicates, but these deprecated screw up the sort order\n+\t    if (strMethod == \"getamountreceived\" ||\n+\t\tstrMethod == \"getallreceived\" ||\n+\t\t(strMethod.find(\"label\") != string::npos))\n+\t\tcontinue;\n+\t    if (strCommand != \"\" && strMethod != strCommand)\n+\t\tcontinue;\n+\t    try\n+\t\t{\n+\t\t    Array params;\n+\t\t    rpcfn_type pfn = (*mi).second;\n+\t\t    if (setDone.insert(pfn).second)\n+\t\t\t(*pfn)(params, true);\n+\t\t}\n+\t    catch (std::exception& e)\n+\t\t{\n+\t\t    // Help text is returned in an exception\n+\t\t    string strHelp = string(e.what());\n+\t\t    if (strCommand == \"\")\n+\t\t\tif (strHelp.find('\\n') != -1)\n+\t\t\t    strHelp = strHelp.substr(0, strHelp.find('\\n'));\n+\t\t    strRet += strHelp + \"\\n\";\n+\t\t}\n \t}\n-    }\n     if (strRet == \"\")\n \tstrRet = strprintf(\"help: unknown command: %s\\n\", strCommand.c_str());\n     strRet = strRet.substr(0,strRet.size()-1);\n@@ -151,8 +151,8 @@ Value stop(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"stop\\n\"\n-\t    \"Stop bitcoin server.\");\n+\t\t\t    \"stop\\n\"\n+\t\t\t    \"Stop bitcoin server.\");\n \n     // Shutdown will take long enough that the response should get back\n     CreateThread(Shutdown, NULL);\n@@ -164,8 +164,8 @@ Value getblockcount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"getblockcount\\n\"\n-\t    \"Returns the number of blocks in the longest block chain.\");\n+\t\t\t    \"getblockcount\\n\"\n+\t\t\t    \"Returns the number of blocks in the longest block chain.\");\n \n     return nBestHeight;\n }\n@@ -175,8 +175,8 @@ Value getblocknumber(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"getblocknumber\\n\"\n-\t    \"Returns the block number of the latest block in the longest block chain.\");\n+\t\t\t    \"getblocknumber\\n\"\n+\t\t\t    \"Returns the block number of the latest block in the longest block chain.\");\n \n     return nBestHeight;\n }\n@@ -186,8 +186,8 @@ Value getconnectioncount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"getconnectioncount\\n\"\n-\t    \"Returns the number of connections to other nodes.\");\n+\t\t\t    \"getconnectioncount\\n\"\n+\t\t\t    \"Returns the number of connections to other nodes.\");\n \n     return (int)vNodes.size();\n }\n@@ -209,8 +209,8 @@ Value getdifficulty(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"getdifficulty\\n\"\n-\t    \"Returns the proof-of-work difficulty as a multiple of the minimum difficulty.\");\n+\t\t\t    \"getdifficulty\\n\"\n+\t\t\t    \"Returns the proof-of-work difficulty as a multiple of the minimum difficulty.\");\n \n     return GetDifficulty();\n }\n@@ -220,8 +220,8 @@ Value getgenerate(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"getgenerate\\n\"\n-\t    \"Returns true or false.\");\n+\t\t\t    \"getgenerate\\n\"\n+\t\t\t    \"Returns true or false.\");\n \n     return (bool)fGenerateBitcoins;\n }\n@@ -231,24 +231,24 @@ Value setgenerate(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"setgenerate <generate> [genproclimit]\\n\"\n-\t    \"<generate> is true or false to turn generation on or off.\\n\"\n-\t    \"Generation is limited to [genproclimit] processors, -1 is unlimited.\");\n+\t\t\t    \"setgenerate <generate> [genproclimit]\\n\"\n+\t\t\t    \"<generate> is true or false to turn generation on or off.\\n\"\n+\t\t\t    \"Generation is limited to [genproclimit] processors, -1 is unlimited.\");\n \n     bool fGenerate = true;\n     if (params.size() > 0)\n \tfGenerate = params[0].get_bool();\n \n     if (params.size() > 1)\n-    {\n-\tint nGenProcLimit = params[1].get_int();\n-\tfLimitProcessors = (nGenProcLimit != -1);\n-\tCWalletDB().WriteSetting(\"fLimitProcessors\", fLimitProcessors);\n-\tif (nGenProcLimit != -1)\n-\t    CWalletDB().WriteSetting(\"nLimitProcessors\", nLimitProcessors = nGenProcLimit);\n-\tif (nGenProcLimit == 0)\n-\t    fGenerate = false;\n-    }\n+\t{\n+\t    int nGenProcLimit = params[1].get_int();\n+\t    fLimitProcessors = (nGenProcLimit != -1);\n+\t    CWalletDB().WriteSetting(\"fLimitProcessors\", fLimitProcessors);\n+\t    if (nGenProcLimit != -1)\n+\t\tCWalletDB().WriteSetting(\"nLimitProcessors\", nLimitProcessors = nGenProcLimit);\n+\t    if (nGenProcLimit == 0)\n+\t\tfGenerate = false;\n+\t}\n \n     GenerateBitcoins(fGenerate);\n     return Value::null;\n@@ -259,8 +259,8 @@ Value gethashespersec(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"gethashespersec\\n\"\n-\t    \"Returns a recent hashes per second performance measurement while generating.\");\n+\t\t\t    \"gethashespersec\\n\"\n+\t\t\t    \"Returns a recent hashes per second performance measurement while generating.\");\n \n     if (GetTimeMillis() - nHPSTimerStart > 8000)\n \treturn (boost::int64_t)0;\n@@ -272,8 +272,8 @@ Value getinfo(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n \tthrow runtime_error(\n-\t    \"getinfo\\n\"\n-\t    \"Returns an object containing various state info.\");\n+\t\t\t    \"getinfo\\n\"\n+\t\t\t    \"Returns an object containing various state info.\");\n \n     Object obj;\n     obj.push_back(Pair(\"version\",       (int)VERSION));\n@@ -297,10 +297,10 @@ Value getnewaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 1)\n \tthrow runtime_error(\n-\t    \"getnewaddress [account]\\n\"\n-\t    \"Returns a new bitcoin address for receiving payments.  \"\n-\t    \"If [account] is specified (recommended), it is added to the address book \"\n-\t    \"so payments received with the address will be credited to [account].\");\n+\t\t\t    \"getnewaddress [account]\\n\"\n+\t\t\t    \"Returns a new bitcoin address for receiving payments.  \"\n+\t\t\t    \"If [account] is specified (recommended), it is added to the address book \"\n+\t\t\t    \"so payments received with the address will be credited to [account].\");\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount;\n@@ -328,28 +328,28 @@ string GetAccountAddress(string strAccount, bool bForceNew=false)\n \n     // Check if the current key has been used\n     if (!account.vchPubKey.empty())\n-    {\n-\tCScript scriptPubKey;\n-\tscriptPubKey.SetBitcoinAddress(account.vchPubKey);\n-\tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n-\t     it != mapWallet.end() && !account.vchPubKey.empty();\n-\t     ++it)\n \t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tif (txout.scriptPubKey == scriptPubKey)\n-\t\t    account.vchPubKey.clear();\n+\t    CScript scriptPubKey;\n+\t    scriptPubKey.SetBitcoinAddress(account.vchPubKey);\n+\t    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n+\t\t it != mapWallet.end() && !account.vchPubKey.empty();\n+\t\t ++it)\n+\t\t{\n+\t\t    const CWalletTx& wtx = (*it).second;\n+\t\t    foreach(const CTxOut& txout, wtx.vout)\n+\t\t\tif (txout.scriptPubKey == scriptPubKey)\n+\t\t\t    account.vchPubKey.clear();\n+\t\t}\n \t}\n-    }\n \n     // Generate a new key\n     if (account.vchPubKey.empty() || bForceNew)\n-    {\n-\taccount.vchPubKey = GetKeyFromKeyPool();\n-\tstring strAddress = PubKeyToAddress(account.vchPubKey);\n-\tSetAddressBookName(strAddress, strAccount);\n-\twalletdb.WriteAccount(strAccount, account);\n-    }\n+\t{\n+\t    account.vchPubKey = GetKeyFromKeyPool();\n+\t    string strAddress = PubKeyToAddress(account.vchPubKey);\n+\t    SetAddressBookName(strAddress, strAccount);\n+\t    walletdb.WriteAccount(strAccount, account);\n+\t}\n \n     walletdb.TxnCommit();\n     strAddress = PubKeyToAddress(account.vchPubKey);\n@@ -361,19 +361,19 @@ Value getaccountaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n \tthrow runtime_error(\n-\t    \"getaccountaddress <account>\\n\"\n-\t    \"Returns the current bitcoin address for receiving payments to this account.\");\n+\t\t\t    \"getaccountaddress <account>\\n\"\n+\t\t\t    \"Returns the current bitcoin address for receiving payments to this account.\");\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount = AccountFromValue(params[0]);\n \n     Value ret;\n \n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-\tret = GetAccountAddress(strAccount);\n-    }\n+\tCRITICAL_BLOCK(cs_mapWallet)\n+\t{\n+\t    ret = GetAccountAddress(strAccount);\n+\t}\n \n     return ret;\n }\n@@ -384,8 +384,8 @@ Value setaccount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"setaccount <bitcoinaddress> <account>\\n\"\n-\t    \"Sets the account associated with the given address.\");\n+\t\t\t    \"setaccount <bitcoinaddress> <account>\\n\"\n+\t\t\t    \"Sets the account associated with the given address.\");\n \n     string strAddress = params[0].get_str();\n     uint160 hash160;\n@@ -400,16 +400,16 @@ Value setaccount(const Array& params, bool fHelp)\n \n     // Detect when changing the account of an address that is the 'unused current key' of another account:\n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n-    {\n-\tif (mapAddressBook.count(strAddress))\n+\tCRITICAL_BLOCK(cs_mapWallet)\n+\tCRITICAL_BLOCK(cs_mapAddressBook)\n \t{\n-\t    string strOldAccount = mapAddressBook[strAddress];\n-\t    if (strAddress == GetAccountAddress(strOldAccount))\n-\t\tGetAccountAddress(strOldAccount, true);\n+\t    if (mapAddressBook.count(strAddress))\n+\t\t{\n+\t\t    string strOldAccount = mapAddressBook[strAddress];\n+\t\t    if (strAddress == GetAccountAddress(strOldAccount))\n+\t\t\tGetAccountAddress(strOldAccount, true);\n+\t\t}\n \t}\n-    }\n \n     SetAddressBookName(strAddress, strAccount);\n     return Value::null;\n@@ -420,8 +420,8 @@ Value getaccount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n \tthrow runtime_error(\n-\t    \"getaccount <bitcoinaddress>\\n\"\n-\t    \"Returns the account associated with the given address.\");\n+\t\t\t    \"getaccount <bitcoinaddress>\\n\"\n+\t\t\t    \"Returns the account associated with the given address.\");\n \n     string strAddress = params[0].get_str();\n \n@@ -440,8 +440,8 @@ Value getaddressesbyaccount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n \tthrow runtime_error(\n-\t    \"getaddressesbyaccount <account>\\n\"\n-\t    \"Returns the list of addresses for the given account.\");\n+\t\t\t    \"getaddressesbyaccount <account>\\n\"\n+\t\t\t    \"Returns the list of addresses for the given account.\");\n \n     string strAccount = AccountFromValue(params[0]);\n \n@@ -450,17 +450,17 @@ Value getaddressesbyaccount(const Array& params, bool fHelp)\n     CRITICAL_BLOCK(cs_mapAddressBook)\n     {\n \tforeach(const PAIRTYPE(string, string)& item, mapAddressBook)\n-\t{\n-\t    const string& strAddress = item.first;\n-\t    const string& strName = item.second;\n-\t    if (strName == strAccount)\n \t    {\n-\t\t// We're only adding valid bitcoin addresses and not ip addresses\n-\t\tCScript scriptPubKey;\n-\t\tif (scriptPubKey.SetBitcoinAddress(strAddress))\n-\t\t    ret.push_back(strAddress);\n+\t\tconst string& strAddress = item.first;\n+\t\tconst string& strName = item.second;\n+\t\tif (strName == strAccount)\n+\t\t    {\n+\t\t\t// We're only adding valid bitcoin addresses and not ip addresses\n+\t\t\tCScript scriptPubKey;\n+\t\t\tif (scriptPubKey.SetBitcoinAddress(strAddress))\n+\t\t\t    ret.push_back(strAddress);\n+\t\t    }\n \t    }\n-\t}\n     }\n     return ret;\n }\n@@ -469,8 +469,8 @@ Value settxfee(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 1)\n \tthrow runtime_error(\n-\t    \"settxfee <amount>\\n\"\n-\t    \"<amount> is a real and is rounded to the nearest 0.00000001\");\n+\t\t\t    \"settxfee <amount>\\n\"\n+\t\t\t    \"<amount> is a real and is rounded to the nearest 0.00000001\");\n \n     // Amount\n     int64 nAmount = 0;\n@@ -485,8 +485,8 @@ Value sendtoaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 4)\n \tthrow runtime_error(\n-\t    \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n-\t    \"<amount> is a real and is rounded to the nearest 0.00000001\");\n+\t\t\t    \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n+\t\t\t    \"<amount> is a real and is rounded to the nearest 0.00000001\");\n \n     string strAddress = params[0].get_str();\n \n@@ -515,8 +515,8 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"getreceivedbyaddress <bitcoinaddress> [minconf=1]\\n\"\n-\t    \"Returns the total amount received by <bitcoinaddress> in transactions with at least [minconf] confirmations.\");\n+\t\t\t    \"getreceivedbyaddress <bitcoinaddress> [minconf=1]\\n\"\n+\t\t\t    \"Returns the total amount received by <bitcoinaddress> in transactions with at least [minconf] confirmations.\");\n \n     // Bitcoin address\n     string strAddress = params[0].get_str();\n@@ -536,16 +536,16 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n \tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    if (wtx.IsCoinBase() || !wtx.IsFinal())\n-\t\tcontinue;\n+\t    {\n+\t\tconst CWalletTx& wtx = (*it).second;\n+\t\tif (wtx.IsCoinBase() || !wtx.IsFinal())\n+\t\t    continue;\n \n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tif (txout.scriptPubKey == scriptPubKey)\n-\t\t    if (wtx.GetDepthInMainChain() >= nMinDepth)\n-\t\t\tnAmount += txout.nValue;\n-\t}\n+\t\tforeach(const CTxOut& txout, wtx.vout)\n+\t\t    if (txout.scriptPubKey == scriptPubKey)\n+\t\t\tif (wtx.GetDepthInMainChain() >= nMinDepth)\n+\t\t\t    nAmount += txout.nValue;\n+\t    }\n     }\n \n     return  ValueFromAmount(nAmount);\n@@ -557,18 +557,18 @@ void GetAccountPubKeys(string strAccount, set<CScript>& setPubKey)\n     CRITICAL_BLOCK(cs_mapAddressBook)\n     {\n \tforeach(const PAIRTYPE(string, string)& item, mapAddressBook)\n-\t{\n-\t    const string& strAddress = item.first;\n-\t    const string& strName = item.second;\n-\t    if (strName == strAccount)\n \t    {\n-\t\t// We're only counting our own valid bitcoin addresses and not ip addresses\n-\t\tCScript scriptPubKey;\n-\t\tif (scriptPubKey.SetBitcoinAddress(strAddress))\n-\t\t    if (IsMine(scriptPubKey))\n-\t\t\tsetPubKey.insert(scriptPubKey);\n+\t\tconst string& strAddress = item.first;\n+\t\tconst string& strName = item.second;\n+\t\tif (strName == strAccount)\n+\t\t    {\n+\t\t\t// We're only counting our own valid bitcoin addresses and not ip addresses\n+\t\t\tCScript scriptPubKey;\n+\t\t\tif (scriptPubKey.SetBitcoinAddress(strAddress))\n+\t\t\t    if (IsMine(scriptPubKey))\n+\t\t\t\tsetPubKey.insert(scriptPubKey);\n+\t\t    }\n \t    }\n-\t}\n     }\n }\n \n@@ -577,8 +577,8 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"getreceivedbyaccount <account> [minconf=1]\\n\"\n-\t    \"Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\");\n+\t\t\t    \"getreceivedbyaccount <account> [minconf=1]\\n\"\n+\t\t\t    \"Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\");\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -595,16 +595,16 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n \tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    if (wtx.IsCoinBase() || !wtx.IsFinal())\n-\t\tcontinue;\n+\t    {\n+\t\tconst CWalletTx& wtx = (*it).second;\n+\t\tif (wtx.IsCoinBase() || !wtx.IsFinal())\n+\t\t    continue;\n \n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tif (setPubKey.count(txout.scriptPubKey))\n-\t\t    if (wtx.GetDepthInMainChain() >= nMinDepth)\n-\t\t\tnAmount += txout.nValue;\n-\t}\n+\t\tforeach(const CTxOut& txout, wtx.vout)\n+\t\t    if (setPubKey.count(txout.scriptPubKey))\n+\t\t\tif (wtx.GetDepthInMainChain() >= nMinDepth)\n+\t\t\t    nAmount += txout.nValue;\n+\t    }\n     }\n \n     return (double)nAmount / (double)COIN;\n@@ -618,18 +618,18 @@ int64 GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinD\n     {\n \t// Tally wallet transactions\n \tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    if (!wtx.IsFinal())\n-\t\tcontinue;\n+\t    {\n+\t\tconst CWalletTx& wtx = (*it).second;\n+\t\tif (!wtx.IsFinal())\n+\t\t    continue;\n \n-\t    int64 nGenerated, nReceived, nSent, nFee;\n-\t    wtx.GetAccountAmounts(strAccount, nGenerated, nReceived, nSent, nFee);\n+\t\tint64 nGenerated, nReceived, nSent, nFee;\n+\t\twtx.GetAccountAmounts(strAccount, nGenerated, nReceived, nSent, nFee);\n \n-\t    if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-\t\tnBalance += nReceived;\n-\t    nBalance += nGenerated - nSent - nFee;\n-\t}\n+\t\tif (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n+\t\t    nBalance += nReceived;\n+\t\tnBalance += nGenerated - nSent - nFee;\n+\t    }\n \n \t// Tally internal accounting entries\n \tnBalance += walletdb.GetAccountCreditDebit(strAccount);\n@@ -649,9 +649,9 @@ Value getbalance(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 0 || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"getbalance [account] [minconf=1]\\n\"\n-\t    \"If [account] is not specified, returns the server's total available balance.\\n\"\n-\t    \"If [account] is specified, returns the balance in the account.\");\n+\t\t\t    \"getbalance [account] [minconf=1]\\n\"\n+\t\t\t    \"If [account] is not specified, returns the server's total available balance.\\n\"\n+\t\t\t    \"If [account] is specified, returns the balance in the account.\");\n \n     if (params.size() == 0)\n \treturn  ValueFromAmount(GetBalance());\n@@ -666,25 +666,25 @@ Value getbalance(const Array& params, bool fHelp)\n \t// getbalance and getbalance '*' should always return the same number.\n \tint64 nBalance = 0;\n \tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    if (!wtx.IsFinal())\n-\t\tcontinue;\n+\t    {\n+\t\tconst CWalletTx& wtx = (*it).second;\n+\t\tif (!wtx.IsFinal())\n+\t\t    continue;\n \n-\t    int64 allGeneratedImmature, allGeneratedMature, allFee;\n-\t    allGeneratedImmature = allGeneratedMature = allFee = 0;\n-\t    string strSentAccount;\n-\t    list<pair<string, int64> > listReceived;\n-\t    list<pair<string, int64> > listSent;\n-\t    wtx.GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n-\t    if (wtx.GetDepthInMainChain() >= nMinDepth)\n-\t\tforeach(const PAIRTYPE(string,int64)& r, listReceived)\n-\t\t    nBalance += r.second;\n-\t    foreach(const PAIRTYPE(string,int64)& r, listSent)\n-\t\tnBalance -= r.second;\n-\t    nBalance -= allFee;\n-\t    nBalance += allGeneratedMature;\n-\t}\n+\t\tint64 allGeneratedImmature, allGeneratedMature, allFee;\n+\t\tallGeneratedImmature = allGeneratedMature = allFee = 0;\n+\t\tstring strSentAccount;\n+\t\tlist<pair<string, int64> > listReceived;\n+\t\tlist<pair<string, int64> > listSent;\n+\t\twtx.GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n+\t\tif (wtx.GetDepthInMainChain() >= nMinDepth)\n+\t\t    foreach(const PAIRTYPE(string,int64)& r, listReceived)\n+\t\t\tnBalance += r.second;\n+\t\tforeach(const PAIRTYPE(string,int64)& r, listSent)\n+\t\t    nBalance -= r.second;\n+\t\tnBalance -= allFee;\n+\t\tnBalance += allGeneratedMature;\n+\t    }\n \treturn  ValueFromAmount(nBalance);\n     }\n \n@@ -700,8 +700,8 @@ Value movecmd(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 3 || params.size() > 5)\n \tthrow runtime_error(\n-\t    \"move <fromaccount> <toaccount> <amount> [minconf=1] [comment]\\n\"\n-\t    \"Move from one account in your wallet to another.\");\n+\t\t\t    \"move <fromaccount> <toaccount> <amount> [minconf=1] [comment]\\n\"\n+\t\t\t    \"Move from one account in your wallet to another.\");\n \n     string strFrom = AccountFromValue(params[0]);\n     string strTo = AccountFromValue(params[1]);\n@@ -748,8 +748,8 @@ Value sendfrom(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 3 || params.size() > 6)\n \tthrow runtime_error(\n-\t    \"sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]\\n\"\n-\t    \"<amount> is a real and is rounded to the nearest 0.00000001\");\n+\t\t\t    \"sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]\\n\"\n+\t\t\t    \"<amount> is a real and is rounded to the nearest 0.00000001\");\n \n     string strAccount = AccountFromValue(params[0]);\n     string strAddress = params[1].get_str();\n@@ -766,18 +766,18 @@ Value sendfrom(const Array& params, bool fHelp)\n \twtx.mapValue[\"to\"]      = params[5].get_str();\n \n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-\t// Check funds\n-\tint64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-\tif (nAmount > nBalance)\n-\t    throw JSONRPCError(-6, \"Account has insufficient funds\");\n-\n-\t// Send\n-\tstring strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n-\tif (strError != \"\")\n-\t    throw JSONRPCError(-4, strError);\n-    }\n+\tCRITICAL_BLOCK(cs_mapWallet)\n+\t{\n+\t    // Check funds\n+\t    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+\t    if (nAmount > nBalance)\n+\t\tthrow JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+\t    // Send\n+\t    string strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n+\t    if (strError != \"\")\n+\t\tthrow JSONRPCError(-4, strError);\n+\t}\n \n     return wtx.GetHash().GetHex();\n }\n@@ -786,8 +786,8 @@ Value sendmany(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 4)\n \tthrow runtime_error(\n-\t    \"sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]\\n\"\n-\t    \"amounts are double-precision floating point numbers\");\n+\t\t\t    \"sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]\\n\"\n+\t\t\t    \"amounts are double-precision floating point numbers\");\n \n     string strAccount = AccountFromValue(params[0]);\n     Object sendTo = params[1].get_obj();\n@@ -805,44 +805,44 @@ Value sendmany(const Array& params, bool fHelp)\n \n     int64 totalAmount = 0;\n     foreach(const Pair& s, sendTo)\n-    {\n-\tuint160 hash160;\n-\tstring strAddress = s.name_;\n+\t{\n+\t    uint160 hash160;\n+\t    string strAddress = s.name_;\n \n-\tif (setAddress.count(strAddress))\n-\t    throw JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+strAddress);\n-\tsetAddress.insert(strAddress);\n+\t    if (setAddress.count(strAddress))\n+\t\tthrow JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+strAddress);\n+\t    setAddress.insert(strAddress);\n \n-\tCScript scriptPubKey;\n-\tif (!scriptPubKey.SetBitcoinAddress(strAddress))\n-\t    throw JSONRPCError(-5, string(\"Invalid bitcoin address:\")+strAddress);\n-\tint64 nAmount = AmountFromValue(s.value_);\n-\ttotalAmount += nAmount;\n+\t    CScript scriptPubKey;\n+\t    if (!scriptPubKey.SetBitcoinAddress(strAddress))\n+\t\tthrow JSONRPCError(-5, string(\"Invalid bitcoin address:\")+strAddress);\n+\t    int64 nAmount = AmountFromValue(s.value_);\n+\t    totalAmount += nAmount;\n \n-\tvecSend.push_back(make_pair(scriptPubKey, nAmount));\n-    }\n+\t    vecSend.push_back(make_pair(scriptPubKey, nAmount));\n+\t}\n \n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-\t// Check funds\n-\tint64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-\tif (totalAmount > nBalance)\n-\t    throw JSONRPCError(-6, \"Account has insufficient funds\");\n-\n-\t// Send\n-\tCReserveKey keyChange;\n-\tint64 nFeeRequired = 0;\n-\tbool fCreated = CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n-\tif (!fCreated)\n+\tCRITICAL_BLOCK(cs_mapWallet)\n \t{\n-\t    if (totalAmount + nFeeRequired > GetBalance())\n-\t\tthrow JSONRPCError(-6, \"Insufficient funds\");\n-\t    throw JSONRPCError(-4, \"Transaction creation failed\");\n+\t    // Check funds\n+\t    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+\t    if (totalAmount > nBalance)\n+\t\tthrow JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+\t    // Send\n+\t    CReserveKey keyChange;\n+\t    int64 nFeeRequired = 0;\n+\t    bool fCreated = CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n+\t    if (!fCreated)\n+\t\t{\n+\t\t    if (totalAmount + nFeeRequired > GetBalance())\n+\t\t\tthrow JSONRPCError(-6, \"Insufficient funds\");\n+\t\t    throw JSONRPCError(-4, \"Transaction creation failed\");\n+\t\t}\n+\t    if (!CommitTransaction(wtx, keyChange))\n+\t\tthrow JSONRPCError(-4, \"Transaction commit failed\");\n \t}\n-\tif (!CommitTransaction(wtx, keyChange))\n-\t    throw JSONRPCError(-4, \"Transaction commit failed\");\n-    }\n \n     return wtx.GetHash().GetHex();\n }\n@@ -876,27 +876,27 @@ Value ListReceived(const Array& params, bool fByAccounts)\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n \tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    if (wtx.IsCoinBase() || !wtx.IsFinal())\n-\t\tcontinue;\n-\n-\t    int nDepth = wtx.GetDepthInMainChain();\n-\t    if (nDepth < nMinDepth)\n-\t\tcontinue;\n-\n-\t    foreach(const CTxOut& txout, wtx.vout)\n \t    {\n-\t\t// Only counting our own bitcoin addresses and not ip addresses\n-\t\tuint160 hash160 = txout.scriptPubKey.GetBitcoinAddressHash160();\n-\t\tif (hash160 == 0 || !mapPubKeys.count(hash160)) // IsMine\n+\t\tconst CWalletTx& wtx = (*it).second;\n+\t\tif (wtx.IsCoinBase() || !wtx.IsFinal())\n \t\t    continue;\n \n-\t\ttallyitem& item = mapTally[hash160];\n-\t\titem.nAmount += txout.nValue;\n-\t\titem.nConf = min(item.nConf, nDepth);\n+\t\tint nDepth = wtx.GetDepthInMainChain();\n+\t\tif (nDepth < nMinDepth)\n+\t\t    continue;\n+\n+\t\tforeach(const CTxOut& txout, wtx.vout)\n+\t\t    {\n+\t\t\t// Only counting our own bitcoin addresses and not ip addresses\n+\t\t\tuint160 hash160 = txout.scriptPubKey.GetBitcoinAddressHash160();\n+\t\t\tif (hash160 == 0 || !mapPubKeys.count(hash160)) // IsMine\n+\t\t\t    continue;\n+\n+\t\t\ttallyitem& item = mapTally[hash160];\n+\t\t\titem.nAmount += txout.nValue;\n+\t\t\titem.nConf = min(item.nConf, nDepth);\n+\t\t    }\n \t    }\n-\t}\n     }\n \n     // Reply\n@@ -905,57 +905,57 @@ Value ListReceived(const Array& params, bool fByAccounts)\n     CRITICAL_BLOCK(cs_mapAddressBook)\n     {\n \tforeach(const PAIRTYPE(string, string)& item, mapAddressBook)\n-\t{\n-\t    const string& strAddress = item.first;\n-\t    const string& strAccount = item.second;\n-\t    uint160 hash160;\n-\t    if (!AddressToHash160(strAddress, hash160))\n-\t\tcontinue;\n-\t    map<uint160, tallyitem>::iterator it = mapTally.find(hash160);\n-\t    if (it == mapTally.end() && !fIncludeEmpty)\n-\t\tcontinue;\n-\n-\t    int64 nAmount = 0;\n-\t    int nConf = INT_MAX;\n-\t    if (it != mapTally.end())\n \t    {\n-\t\tnAmount = (*it).second.nAmount;\n-\t\tnConf = (*it).second.nConf;\n-\t    }\n+\t\tconst string& strAddress = item.first;\n+\t\tconst string& strAccount = item.second;\n+\t\tuint160 hash160;\n+\t\tif (!AddressToHash160(strAddress, hash160))\n+\t\t    continue;\n+\t\tmap<uint160, tallyitem>::iterator it = mapTally.find(hash160);\n+\t\tif (it == mapTally.end() && !fIncludeEmpty)\n+\t\t    continue;\n \n-\t    if (fByAccounts)\n-\t    {\n-\t\ttallyitem& item = mapAccountTally[strAccount];\n-\t\titem.nAmount += nAmount;\n-\t\titem.nConf = min(item.nConf, nConf);\n-\t    }\n-\t    else\n-\t    {\n-\t\tObject obj;\n-\t\tobj.push_back(Pair(\"address\",       strAddress));\n-\t\tobj.push_back(Pair(\"account\",       strAccount));\n-\t\tobj.push_back(Pair(\"label\",         strAccount)); // deprecated\n-\t\tobj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-\t\tobj.push_back(Pair(\"confirmations\", (nConf == INT_MAX ? 0 : nConf)));\n-\t\tret.push_back(obj);\n+\t\tint64 nAmount = 0;\n+\t\tint nConf = INT_MAX;\n+\t\tif (it != mapTally.end())\n+\t\t    {\n+\t\t\tnAmount = (*it).second.nAmount;\n+\t\t\tnConf = (*it).second.nConf;\n+\t\t    }\n+\n+\t\tif (fByAccounts)\n+\t\t    {\n+\t\t\ttallyitem& item = mapAccountTally[strAccount];\n+\t\t\titem.nAmount += nAmount;\n+\t\t\titem.nConf = min(item.nConf, nConf);\n+\t\t    }\n+\t\telse\n+\t\t    {\n+\t\t\tObject obj;\n+\t\t\tobj.push_back(Pair(\"address\",       strAddress));\n+\t\t\tobj.push_back(Pair(\"account\",       strAccount));\n+\t\t\tobj.push_back(Pair(\"label\",         strAccount)); // deprecated\n+\t\t\tobj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+\t\t\tobj.push_back(Pair(\"confirmations\", (nConf == INT_MAX ? 0 : nConf)));\n+\t\t\tret.push_back(obj);\n+\t\t    }\n \t    }\n-\t}\n     }\n \n     if (fByAccounts)\n-    {\n-\tfor (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n \t{\n-\t    int64 nAmount = (*it).second.nAmount;\n-\t    int nConf = (*it).second.nConf;\n-\t    Object obj;\n-\t    obj.push_back(Pair(\"account\",       (*it).first));\n-\t    obj.push_back(Pair(\"label\",         (*it).first)); // deprecated\n-\t    obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-\t    obj.push_back(Pair(\"confirmations\", (nConf == INT_MAX ? 0 : nConf)));\n-\t    ret.push_back(obj);\n+\t    for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n+\t\t{\n+\t\t    int64 nAmount = (*it).second.nAmount;\n+\t\t    int nConf = (*it).second.nConf;\n+\t\t    Object obj;\n+\t\t    obj.push_back(Pair(\"account\",       (*it).first));\n+\t\t    obj.push_back(Pair(\"label\",         (*it).first)); // deprecated\n+\t\t    obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+\t\t    obj.push_back(Pair(\"confirmations\", (nConf == INT_MAX ? 0 : nConf)));\n+\t\t    ret.push_back(obj);\n+\t\t}\n \t}\n-    }\n \n     return ret;\n }\n@@ -964,14 +964,14 @@ Value listreceivedbyaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"listreceivedbyaddress [minconf=1] [includeempty=false]\\n\"\n-\t    \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n-\t    \"[includeempty] whether to include addresses that haven't received any payments.\\n\"\n-\t    \"Returns an array of objects containing:\\n\"\n-\t    \"  \\\"address\\\" : receiving address\\n\"\n-\t    \"  \\\"account\\\" : the account of the receiving address\\n\"\n-\t    \"  \\\"amount\\\" : total amount received by the address\\n\"\n-\t    \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n+\t\t\t    \"listreceivedbyaddress [minconf=1] [includeempty=false]\\n\"\n+\t\t\t    \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n+\t\t\t    \"[includeempty] whether to include addresses that haven't received any payments.\\n\"\n+\t\t\t    \"Returns an array of objects containing:\\n\"\n+\t\t\t    \"  \\\"address\\\" : receiving address\\n\"\n+\t\t\t    \"  \\\"account\\\" : the account of the receiving address\\n\"\n+\t\t\t    \"  \\\"amount\\\" : total amount received by the address\\n\"\n+\t\t\t    \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n \n     return ListReceived(params, false);\n }\n@@ -980,13 +980,13 @@ Value listreceivedbyaccount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 2)\n \tthrow runtime_error(\n-\t    \"listreceivedbyaccount [minconf=1] [includeempty=false]\\n\"\n-\t    \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n-\t    \"[includeempty] whether to include accounts that haven't received any payments.\\n\"\n-\t    \"Returns an array of objects containing:\\n\"\n-\t    \"  \\\"account\\\" : the account of the receiving addresses\\n\"\n-\t    \"  \\\"amount\\\" : total amount received by addresses with this account\\n\"\n-\t    \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n+\t\t\t    \"listreceivedbyaccount [minconf=1] [includeempty=false]\\n\"\n+\t\t\t    \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n+\t\t\t    \"[includeempty] whether to include accounts that haven't received any payments.\\n\"\n+\t\t\t    \"Returns an array of objects containing:\\n\"\n+\t\t\t    \"  \\\"account\\\" : the account of the receiving addresses\\n\"\n+\t\t\t    \"  \\\"amount\\\" : total amount received by addresses with this account\\n\"\n+\t\t\t    \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n \n     return ListReceived(params, true);\n }\n@@ -1003,62 +1003,62 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n \n     // Generated blocks assigned to account \"\"\n     if ((nGeneratedMature+nGeneratedImmature) != 0 && (fAllAccounts || strAccount == \"\"))\n-    {\n-\tObject entry;\n-\tentry.push_back(Pair(\"account\", string(\"\")));\n-\tif (nGeneratedImmature)\n-\t{\n-\t    entry.push_back(Pair(\"category\", wtx.GetDepthInMainChain() ? \"immature\" : \"orphan\"));\n-\t    entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedImmature)));\n-\t}\n-\telse\n \t{\n-\t    entry.push_back(Pair(\"category\", \"generate\"));\n-\t    entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedMature)));\n+\t    Object entry;\n+\t    entry.push_back(Pair(\"account\", string(\"\")));\n+\t    if (nGeneratedImmature)\n+\t\t{\n+\t\t    entry.push_back(Pair(\"category\", wtx.GetDepthInMainChain() ? \"immature\" : \"orphan\"));\n+\t\t    entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedImmature)));\n+\t\t}\n+\t    else\n+\t\t{\n+\t\t    entry.push_back(Pair(\"category\", \"generate\"));\n+\t\t    entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedMature)));\n+\t\t}\n+\t    if (fLong)\n+\t\tWalletTxToJSON(wtx, entry);\n+\t    ret.push_back(entry);\n \t}\n-\tif (fLong)\n-\t    WalletTxToJSON(wtx, entry);\n-\tret.push_back(entry);\n-    }\n \n     // Sent\n     if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n-    {\n-\tforeach(const PAIRTYPE(string, int64)& s, listSent)\n \t{\n-\t    Object entry;\n-\t    entry.push_back(Pair(\"account\", strSentAccount));\n-\t    entry.push_back(Pair(\"address\", s.first));\n-\t    entry.push_back(Pair(\"category\", \"send\"));\n-\t    entry.push_back(Pair(\"amount\", ValueFromAmount(-s.second)));\n-\t    entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n-\t    if (fLong)\n-\t\tWalletTxToJSON(wtx, entry);\n-\t    ret.push_back(entry);\n+\t    foreach(const PAIRTYPE(string, int64)& s, listSent)\n+\t\t{\n+\t\t    Object entry;\n+\t\t    entry.push_back(Pair(\"account\", strSentAccount));\n+\t\t    entry.push_back(Pair(\"address\", s.first));\n+\t\t    entry.push_back(Pair(\"category\", \"send\"));\n+\t\t    entry.push_back(Pair(\"amount\", ValueFromAmount(-s.second)));\n+\t\t    entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n+\t\t    if (fLong)\n+\t\t\tWalletTxToJSON(wtx, entry);\n+\t\t    ret.push_back(entry);\n+\t\t}\n \t}\n-    }\n \n     // Received\n     if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n \tCRITICAL_BLOCK(cs_mapAddressBook)\n \t{\n \t    foreach(const PAIRTYPE(string, int64)& r, listReceived)\n-\t    {\n-\t\tstring account;\n-\t\tif (mapAddressBook.count(r.first))\n-\t\t    account = mapAddressBook[r.first];\n-\t\tif (fAllAccounts || (account == strAccount))\n \t\t{\n-\t\t    Object entry;\n-\t\t    entry.push_back(Pair(\"account\", account));\n-\t\t    entry.push_back(Pair(\"address\", r.first));\n-\t\t    entry.push_back(Pair(\"category\", \"receive\"));\n-\t\t    entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n-\t\t    if (fLong)\n-\t\t\tWalletTxToJSON(wtx, entry);\n-\t\t    ret.push_back(entry);\n+\t\t    string account;\n+\t\t    if (mapAddressBook.count(r.first))\n+\t\t\taccount = mapAddressBook[r.first];\n+\t\t    if (fAllAccounts || (account == strAccount))\n+\t\t\t{\n+\t\t\t    Object entry;\n+\t\t\t    entry.push_back(Pair(\"account\", account));\n+\t\t\t    entry.push_back(Pair(\"address\", r.first));\n+\t\t\t    entry.push_back(Pair(\"category\", \"receive\"));\n+\t\t\t    entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n+\t\t\t    if (fLong)\n+\t\t\t\tWalletTxToJSON(wtx, entry);\n+\t\t\t    ret.push_back(entry);\n+\t\t\t}\n \t\t}\n-\t    }\n \t}\n \n }\n@@ -1068,24 +1068,24 @@ void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, Ar\n     bool fAllAccounts = (strAccount == string(\"*\"));\n \n     if (fAllAccounts || acentry.strAccount == strAccount)\n-    {\n-\tObject entry;\n-\tentry.push_back(Pair(\"account\", acentry.strAccount));\n-\tentry.push_back(Pair(\"category\", \"move\"));\n-\tentry.push_back(Pair(\"time\", (boost::int64_t)acentry.nTime));\n-\tentry.push_back(Pair(\"amount\", ValueFromAmount(acentry.nCreditDebit)));\n-\tentry.push_back(Pair(\"otheraccount\", acentry.strOtherAccount));\n-\tentry.push_back(Pair(\"comment\", acentry.strComment));\n-\tret.push_back(entry);\n-    }\n+\t{\n+\t    Object entry;\n+\t    entry.push_back(Pair(\"account\", acentry.strAccount));\n+\t    entry.push_back(Pair(\"category\", \"move\"));\n+\t    entry.push_back(Pair(\"time\", (boost::int64_t)acentry.nTime));\n+\t    entry.push_back(Pair(\"amount\", ValueFromAmount(acentry.nCreditDebit)));\n+\t    entry.push_back(Pair(\"otheraccount\", acentry.strOtherAccount));\n+\t    entry.push_back(Pair(\"comment\", acentry.strComment));\n+\t    ret.push_back(entry);\n+\t}\n }\n \n Value listtransactions(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 3)\n \tthrow runtime_error(\n-\t    \"listtransactions [account] [count=10] [from=0]\\n\"\n-\t    \"Returns up to [count] most recent transactions skipping the first [from] transactions for account [account].\");\n+\t\t\t    \"listtransactions [account] [count=10] [from=0]\\n\"\n+\t\t\t    \"Returns up to [count] most recent transactions skipping the first [from] transactions for account [account].\");\n \n     string strAccount = \"*\";\n     if (params.size() > 0)\n@@ -1108,40 +1108,40 @@ Value listtransactions(const Array& params, bool fHelp)\n \tTxItems txByTime;\n \n \tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t{\n-\t    CWalletTx* wtx = &((*it).second);\n-\t    txByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n-\t}\n+\t    {\n+\t\tCWalletTx* wtx = &((*it).second);\n+\t\ttxByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n+\t    }\n \tlist<CAccountingEntry> acentries;\n \twalletdb.ListAccountCreditDebit(strAccount, acentries);\n \tforeach(CAccountingEntry& entry, acentries)\n-\t{\n-\t    txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n-\t}\n+\t    {\n+\t\ttxByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+\t    }\n \n \t// Now: iterate backwards until we have nCount items to return:\n \tTxItems::reverse_iterator it = txByTime.rbegin();\n \tfor (std::advance(it, nFrom); it != txByTime.rend(); ++it)\n-\t{\n-\t    CWalletTx *const pwtx = (*it).second.first;\n-\t    if (pwtx != 0)\n-\t\tListTransactions(*pwtx, strAccount, 0, true, ret);\n-\t    CAccountingEntry *const pacentry = (*it).second.second;\n-\t    if (pacentry != 0)\n-\t\tAcentryToJSON(*pacentry, strAccount, ret);\n-\n-\t    if (ret.size() >= nCount) break;\n-\t}\n+\t    {\n+\t\tCWalletTx *const pwtx = (*it).second.first;\n+\t\tif (pwtx != 0)\n+\t\t    ListTransactions(*pwtx, strAccount, 0, true, ret);\n+\t\tCAccountingEntry *const pacentry = (*it).second.second;\n+\t\tif (pacentry != 0)\n+\t\t    AcentryToJSON(*pacentry, strAccount, ret);\n+\n+\t\tif (ret.size() >= nCount) break;\n+\t    }\n \t// ret is now newest to oldest\n     }\n \n     // Make sure we return only last nCount items (sends-to-self might give us an extra):\n     if (ret.size() > nCount)\n-    {\n-\tArray::iterator last = ret.begin();\n-\tstd::advance(last, nCount);\n-\tret.erase(last, ret.end());\n-    }\n+\t{\n+\t    Array::iterator last = ret.begin();\n+\t    std::advance(last, nCount);\n+\t    ret.erase(last, ret.end());\n+\t}\n     std::reverse(ret.begin(), ret.end()); // oldest to newest\n \n     return ret;\n@@ -1151,45 +1151,45 @@ Value listaccounts(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 1)\n \tthrow runtime_error(\n-\t    \"listaccounts [minconf=1]\\n\"\n-\t    \"Returns Object that has account names as keys, account balances as values.\");\n+\t\t\t    \"listaccounts [minconf=1]\\n\"\n+\t\t\t    \"Returns Object that has account names as keys, account balances as values.\");\n \n     int nMinDepth = 1;\n     if (params.size() > 0)\n \tnMinDepth = params[0].get_int();\n \n     map<string, int64> mapAccountBalances;\n     CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n-    {\n-\tforeach(const PAIRTYPE(string, string)& entry, mapAddressBook) {\n-\t    uint160 hash160;\n-\t    if(AddressToHash160(entry.first, hash160) && mapPubKeys.count(hash160)) // This address belongs to me\n-\t\tmapAccountBalances[entry.second] = 0;\n-\t}\n-\n-\tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\tCRITICAL_BLOCK(cs_mapAddressBook)\n \t{\n-\t    const CWalletTx& wtx = (*it).second;\n-\t    int64 nGeneratedImmature, nGeneratedMature, nFee;\n-\t    string strSentAccount;\n-\t    list<pair<string, int64> > listReceived;\n-\t    list<pair<string, int64> > listSent;\n-\t    wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n-\t    mapAccountBalances[strSentAccount] -= nFee;\n-\t    foreach(const PAIRTYPE(string, int64)& s, listSent)\n-\t\tmapAccountBalances[strSentAccount] -= s.second;\n-\t    if (wtx.GetDepthInMainChain() >= nMinDepth)\n-\t    {\n-\t\tmapAccountBalances[\"\"] += nGeneratedMature;\n-\t\tforeach(const PAIRTYPE(string, int64)& r, listReceived)\n-\t\t    if (mapAddressBook.count(r.first))\n-\t\t\tmapAccountBalances[mapAddressBook[r.first]] += r.second;\n-\t\t    else\n-\t\t\tmapAccountBalances[\"\"] += r.second;\n+\t    foreach(const PAIRTYPE(string, string)& entry, mapAddressBook) {\n+\t\tuint160 hash160;\n+\t\tif(AddressToHash160(entry.first, hash160) && mapPubKeys.count(hash160)) // This address belongs to me\n+\t\t    mapAccountBalances[entry.second] = 0;\n \t    }\n+\n+\t    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\t\t{\n+\t\t    const CWalletTx& wtx = (*it).second;\n+\t\t    int64 nGeneratedImmature, nGeneratedMature, nFee;\n+\t\t    string strSentAccount;\n+\t\t    list<pair<string, int64> > listReceived;\n+\t\t    list<pair<string, int64> > listSent;\n+\t\t    wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n+\t\t    mapAccountBalances[strSentAccount] -= nFee;\n+\t\t    foreach(const PAIRTYPE(string, int64)& s, listSent)\n+\t\t\tmapAccountBalances[strSentAccount] -= s.second;\n+\t\t    if (wtx.GetDepthInMainChain() >= nMinDepth)\n+\t\t\t{\n+\t\t\t    mapAccountBalances[\"\"] += nGeneratedMature;\n+\t\t\t    foreach(const PAIRTYPE(string, int64)& r, listReceived)\n+\t\t\t\tif (mapAddressBook.count(r.first))\n+\t\t\t\t    mapAccountBalances[mapAddressBook[r.first]] += r.second;\n+\t\t\t\telse\n+\t\t\t\t    mapAccountBalances[\"\"] += r.second;\n+\t\t\t}\n+\t\t}\n \t}\n-    }\n \n     list<CAccountingEntry> acentries;\n     CWalletDB().ListAccountCreditDebit(\"*\", acentries);\n@@ -1207,8 +1207,8 @@ Value gettransaction(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n \tthrow runtime_error(\n-\t    \"gettransaction <txid>\\n\"\n-\t    \"Get detailed information about <txid>\");\n+\t\t\t    \"gettransaction <txid>\\n\"\n+\t\t\t    \"Get detailed information about <txid>\");\n \n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n@@ -1244,8 +1244,8 @@ Value backupwallet(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n \tthrow runtime_error(\n-\t    \"backupwallet <destination>\\n\"\n-\t    \"Safely copies wallet.dat to destination, which can be a directory or a path with filename.\");\n+\t\t\t    \"backupwallet <destination>\\n\"\n+\t\t\t    \"Safely copies wallet.dat to destination, which can be a directory or a path with filename.\");\n \n     string strDest = params[0].get_str();\n     BackupWallet(strDest);\n@@ -1258,8 +1258,8 @@ Value validateaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n \tthrow runtime_error(\n-\t    \"validateaddress <bitcoinaddress>\\n\"\n-\t    \"Return information about <bitcoinaddress>.\");\n+\t\t\t    \"validateaddress <bitcoinaddress>\\n\"\n+\t\t\t    \"Return information about <bitcoinaddress>.\");\n \n     string strAddress = params[0].get_str();\n     uint160 hash160;\n@@ -1268,18 +1268,18 @@ Value validateaddress(const Array& params, bool fHelp)\n     Object ret;\n     ret.push_back(Pair(\"isvalid\", isValid));\n     if (isValid)\n-    {\n-\t// Call Hash160ToAddress() so we always return current ADDRESSVERSION\n-\t// version of the address:\n-\tstring currentAddress = Hash160ToAddress(hash160);\n-\tret.push_back(Pair(\"address\", currentAddress));\n-\tret.push_back(Pair(\"ismine\", (mapPubKeys.count(hash160) > 0)));\n-\tCRITICAL_BLOCK(cs_mapAddressBook)\n \t{\n-\t    if (mapAddressBook.count(currentAddress))\n-\t\tret.push_back(Pair(\"account\", mapAddressBook[currentAddress]));\n+\t    // Call Hash160ToAddress() so we always return current ADDRESSVERSION\n+\t    // version of the address:\n+\t    string currentAddress = Hash160ToAddress(hash160);\n+\t    ret.push_back(Pair(\"address\", currentAddress));\n+\t    ret.push_back(Pair(\"ismine\", (mapPubKeys.count(hash160) > 0)));\n+\t    CRITICAL_BLOCK(cs_mapAddressBook)\n+\t    {\n+\t\tif (mapAddressBook.count(currentAddress))\n+\t\t    ret.push_back(Pair(\"account\", mapAddressBook[currentAddress]));\n+\t    }\n \t}\n-    }\n     return ret;\n }\n \n@@ -1288,13 +1288,13 @@ Value getwork(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 1)\n \tthrow runtime_error(\n-\t    \"getwork [data]\\n\"\n-\t    \"If [data] is not specified, returns formatted hash data to work on:\\n\"\n-\t    \"  \\\"midstate\\\" : precomputed hash state after hashing the first half of the data\\n\"\n-\t    \"  \\\"data\\\" : block data\\n\"\n-\t    \"  \\\"hash1\\\" : formatted hash buffer for second hash\\n\"\n-\t    \"  \\\"target\\\" : little endian hash target\\n\"\n-\t    \"If [data] is specified, tries to solve the block and returns true if it was successful.\");\n+\t\t\t    \"getwork [data]\\n\"\n+\t\t\t    \"If [data] is not specified, returns formatted hash data to work on:\\n\"\n+\t\t\t    \"  \\\"midstate\\\" : precomputed hash state after hashing the first half of the data\\n\"\n+\t\t\t    \"  \\\"data\\\" : block data\\n\"\n+\t\t\t    \"  \\\"hash1\\\" : formatted hash buffer for second hash\\n\"\n+\t\t\t    \"  \\\"target\\\" : little endian hash target\\n\"\n+\t\t\t    \"If [data] is specified, tries to solve the block and returns true if it was successful.\");\n \n     if (vNodes.empty())\n \tthrow JSONRPCError(-9, \"Bitcoin is not connected!\");\n@@ -1307,86 +1307,86 @@ Value getwork(const Array& params, bool fHelp)\n     static CReserveKey reservekey;\n \n     if (params.size() == 0)\n-    {\n-\t// Update block\n-\tstatic unsigned int nTransactionsUpdatedLast;\n-\tstatic CBlockIndex* pindexPrev;\n-\tstatic int64 nStart;\n-\tstatic CBlock* pblock;\n-\tif (pindexPrev != pindexBest ||\n-\t    (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n \t{\n-\t    if (pindexPrev != pindexBest)\n-\t    {\n-\t\t// Deallocate old blocks since they're obsolete now\n-\t\tmapNewBlock.clear();\n-\t\tforeach(CBlock* pblock, vNewBlock)\n-\t\t    delete pblock;\n-\t\tvNewBlock.clear();\n-\t    }\n-\t    nTransactionsUpdatedLast = nTransactionsUpdated;\n-\t    pindexPrev = pindexBest;\n-\t    nStart = GetTime();\n-\n-\t    // Create new block\n-\t    pblock = CreateNewBlock(reservekey);\n-\t    if (!pblock)\n-\t\tthrow JSONRPCError(-7, \"Out of memory\");\n-\t    vNewBlock.push_back(pblock);\n-\t}\n+\t    // Update block\n+\t    static unsigned int nTransactionsUpdatedLast;\n+\t    static CBlockIndex* pindexPrev;\n+\t    static int64 nStart;\n+\t    static CBlock* pblock;\n+\t    if (pindexPrev != pindexBest ||\n+\t\t(nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n+\t\t{\n+\t\t    if (pindexPrev != pindexBest)\n+\t\t\t{\n+\t\t\t    // Deallocate old blocks since they're obsolete now\n+\t\t\t    mapNewBlock.clear();\n+\t\t\t    foreach(CBlock* pblock, vNewBlock)\n+\t\t\t\tdelete pblock;\n+\t\t\t    vNewBlock.clear();\n+\t\t\t}\n+\t\t    nTransactionsUpdatedLast = nTransactionsUpdated;\n+\t\t    pindexPrev = pindexBest;\n+\t\t    nStart = GetTime();\n+\n+\t\t    // Create new block\n+\t\t    pblock = CreateNewBlock(reservekey);\n+\t\t    if (!pblock)\n+\t\t\tthrow JSONRPCError(-7, \"Out of memory\");\n+\t\t    vNewBlock.push_back(pblock);\n+\t\t}\n \n-\t// Update nTime\n-\tpblock->nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n-\tpblock->nNonce = 0;\n+\t    // Update nTime\n+\t    pblock->nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n+\t    pblock->nNonce = 0;\n \n-\t// Update nExtraNonce\n-\tstatic unsigned int nExtraNonce = 0;\n-\tstatic int64 nPrevTime = 0;\n-\tIncrementExtraNonce(pblock, pindexPrev, nExtraNonce, nPrevTime);\n+\t    // Update nExtraNonce\n+\t    static unsigned int nExtraNonce = 0;\n+\t    static int64 nPrevTime = 0;\n+\t    IncrementExtraNonce(pblock, pindexPrev, nExtraNonce, nPrevTime);\n \n-\t// Save\n-\tmapNewBlock[pblock->hashMerkleRoot] = make_pair(pblock, nExtraNonce);\n+\t    // Save\n+\t    mapNewBlock[pblock->hashMerkleRoot] = make_pair(pblock, nExtraNonce);\n \n-\t// Prebuild hash buffers\n-\tchar pmidstate[32];\n-\tchar pdata[128];\n-\tchar phash1[64];\n-\tFormatHashBuffers(pblock, pmidstate, pdata, phash1);\n+\t    // Prebuild hash buffers\n+\t    char pmidstate[32];\n+\t    char pdata[128];\n+\t    char phash1[64];\n+\t    FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n \n-\tuint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n+\t    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n \n-\tObject result;\n-\tresult.push_back(Pair(\"midstate\", HexStr(BEGIN(pmidstate), END(pmidstate))));\n-\tresult.push_back(Pair(\"data\",     HexStr(BEGIN(pdata), END(pdata))));\n-\tresult.push_back(Pair(\"hash1\",    HexStr(BEGIN(phash1), END(phash1))));\n-\tresult.push_back(Pair(\"target\",   HexStr(BEGIN(hashTarget), END(hashTarget))));\n-\treturn result;\n-    }\n+\t    Object result;\n+\t    result.push_back(Pair(\"midstate\", HexStr(BEGIN(pmidstate), END(pmidstate))));\n+\t    result.push_back(Pair(\"data\",     HexStr(BEGIN(pdata), END(pdata))));\n+\t    result.push_back(Pair(\"hash1\",    HexStr(BEGIN(phash1), END(phash1))));\n+\t    result.push_back(Pair(\"target\",   HexStr(BEGIN(hashTarget), END(hashTarget))));\n+\t    return result;\n+\t}\n     else\n-    {\n-\t// Parse parameters\n-\tvector<unsigned char> vchData = ParseHex(params[0].get_str());\n-\tif (vchData.size() != 128)\n-\t    throw JSONRPCError(-8, \"Invalid parameter\");\n-\tCBlock* pdata = (CBlock*)&vchData[0];\n-\n-\t// Byte reverse\n-\tfor (int i = 0; i < 128/4; i++)\n-\t    ((unsigned int*)pdata)[i] = CryptoPP::ByteReverse(((unsigned int*)pdata)[i]);\n-\n-\t// Get saved block\n-\tif (!mapNewBlock.count(pdata->hashMerkleRoot))\n-\t    return false;\n-\tCBlock* pblock = mapNewBlock[pdata->hashMerkleRoot].first;\n-\tunsigned int nExtraNonce = mapNewBlock[pdata->hashMerkleRoot].second;\n-\n-\tpblock->nTime = pdata->nTime;\n-\tpblock->nNonce = pdata->nNonce;\n-\tpblock->vtx[0].vin[0].scriptSig = CScript() << pblock->nBits << CBigNum(nExtraNonce);\n-\tpblock->hashMerkleRoot = pblock->BuildMerkleTree();\n-\n-\treturn CheckWork(pblock, reservekey);\n-    }\n+\t{\n+\t    // Parse parameters\n+\t    vector<unsigned char> vchData = ParseHex(params[0].get_str());\n+\t    if (vchData.size() != 128)\n+\t\tthrow JSONRPCError(-8, \"Invalid parameter\");\n+\t    CBlock* pdata = (CBlock*)&vchData[0];\n+\n+\t    // Byte reverse\n+\t    for (int i = 0; i < 128/4; i++)\n+\t\t((unsigned int*)pdata)[i] = CryptoPP::ByteReverse(((unsigned int*)pdata)[i]);\n+\n+\t    // Get saved block\n+\t    if (!mapNewBlock.count(pdata->hashMerkleRoot))\n+\t\treturn false;\n+\t    CBlock* pblock = mapNewBlock[pdata->hashMerkleRoot].first;\n+\t    unsigned int nExtraNonce = mapNewBlock[pdata->hashMerkleRoot].second;\n+\n+\t    pblock->nTime = pdata->nTime;\n+\t    pblock->nNonce = pdata->nNonce;\n+\t    pblock->vtx[0].vin[0].scriptSig = CScript() << pblock->nBits << CBigNum(nExtraNonce);\n+\t    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n+\n+\t    return CheckWork(pblock, reservekey);\n+\t}\n }\n \n \n@@ -1404,71 +1404,71 @@ Value getwork(const Array& params, bool fHelp)\n //\n \n pair<string, rpcfn_type> pCallTable[] =\n-{\n-    make_pair(\"help\",                  &help),\n-    make_pair(\"stop\",                  &stop),\n-    make_pair(\"getblockcount\",         &getblockcount),\n-    make_pair(\"getblocknumber\",        &getblocknumber),\n-    make_pair(\"getconnectioncount\",    &getconnectioncount),\n-    make_pair(\"getdifficulty\",         &getdifficulty),\n-    make_pair(\"getgenerate\",           &getgenerate),\n-    make_pair(\"setgenerate\",           &setgenerate),\n-    make_pair(\"gethashespersec\",       &gethashespersec),\n-    make_pair(\"getinfo\",               &getinfo),\n-    make_pair(\"getnewaddress\",         &getnewaddress),\n-    make_pair(\"getaccountaddress\",     &getaccountaddress),\n-    make_pair(\"setaccount\",            &setaccount),\n-    make_pair(\"setlabel\",              &setaccount), // deprecated\n-    make_pair(\"getaccount\",            &getaccount),\n-    make_pair(\"getlabel\",              &getaccount), // deprecated\n-    make_pair(\"getaddressesbyaccount\", &getaddressesbyaccount),\n-    make_pair(\"getaddressesbylabel\",   &getaddressesbyaccount), // deprecated\n-    make_pair(\"sendtoaddress\",         &sendtoaddress),\n-    make_pair(\"getamountreceived\",     &getreceivedbyaddress), // deprecated, renamed to getreceivedbyaddress\n-    make_pair(\"getallreceived\",        &listreceivedbyaddress), // deprecated, renamed to listreceivedbyaddress\n-    make_pair(\"getreceivedbyaddress\",  &getreceivedbyaddress),\n-    make_pair(\"getreceivedbyaccount\",  &getreceivedbyaccount),\n-    make_pair(\"getreceivedbylabel\",    &getreceivedbyaccount), // deprecated\n-    make_pair(\"listreceivedbyaddress\", &listreceivedbyaddress),\n-    make_pair(\"listreceivedbyaccount\", &listreceivedbyaccount),\n-    make_pair(\"listreceivedbylabel\",   &listreceivedbyaccount), // deprecated\n-    make_pair(\"backupwallet\",          &backupwallet),\n-    make_pair(\"validateaddress\",       &validateaddress),\n-    make_pair(\"getbalance\",            &getbalance),\n-    make_pair(\"move\",                  &movecmd),\n-    make_pair(\"sendfrom\",              &sendfrom),\n-    make_pair(\"sendmany\",              &sendmany),\n-    make_pair(\"gettransaction\",        &gettransaction),\n-    make_pair(\"listtransactions\",      &listtransactions),\n-    make_pair(\"getwork\",               &getwork),\n-    make_pair(\"listaccounts\",          &listaccounts),\n-    make_pair(\"settxfee\",              &settxfee),\n-};\n+    {\n+\tmake_pair(\"help\",                  &help),\n+\tmake_pair(\"stop\",                  &stop),\n+\tmake_pair(\"getblockcount\",         &getblockcount),\n+\tmake_pair(\"getblocknumber\",        &getblocknumber),\n+\tmake_pair(\"getconnectioncount\",    &getconnectioncount),\n+\tmake_pair(\"getdifficulty\",         &getdifficulty),\n+\tmake_pair(\"getgenerate\",           &getgenerate),\n+\tmake_pair(\"setgenerate\",           &setgenerate),\n+\tmake_pair(\"gethashespersec\",       &gethashespersec),\n+\tmake_pair(\"getinfo\",               &getinfo),\n+\tmake_pair(\"getnewaddress\",         &getnewaddress),\n+\tmake_pair(\"getaccountaddress\",     &getaccountaddress),\n+\tmake_pair(\"setaccount\",            &setaccount),\n+\tmake_pair(\"setlabel\",              &setaccount), // deprecated\n+\tmake_pair(\"getaccount\",            &getaccount),\n+\tmake_pair(\"getlabel\",              &getaccount), // deprecated\n+\tmake_pair(\"getaddressesbyaccount\", &getaddressesbyaccount),\n+\tmake_pair(\"getaddressesbylabel\",   &getaddressesbyaccount), // deprecated\n+\tmake_pair(\"sendtoaddress\",         &sendtoaddress),\n+\tmake_pair(\"getamountreceived\",     &getreceivedbyaddress), // deprecated, renamed to getreceivedbyaddress\n+\tmake_pair(\"getallreceived\",        &listreceivedbyaddress), // deprecated, renamed to listreceivedbyaddress\n+\tmake_pair(\"getreceivedbyaddress\",  &getreceivedbyaddress),\n+\tmake_pair(\"getreceivedbyaccount\",  &getreceivedbyaccount),\n+\tmake_pair(\"getreceivedbylabel\",    &getreceivedbyaccount), // deprecated\n+\tmake_pair(\"listreceivedbyaddress\", &listreceivedbyaddress),\n+\tmake_pair(\"listreceivedbyaccount\", &listreceivedbyaccount),\n+\tmake_pair(\"listreceivedbylabel\",   &listreceivedbyaccount), // deprecated\n+\tmake_pair(\"backupwallet\",          &backupwallet),\n+\tmake_pair(\"validateaddress\",       &validateaddress),\n+\tmake_pair(\"getbalance\",            &getbalance),\n+\tmake_pair(\"move\",                  &movecmd),\n+\tmake_pair(\"sendfrom\",              &sendfrom),\n+\tmake_pair(\"sendmany\",              &sendmany),\n+\tmake_pair(\"gettransaction\",        &gettransaction),\n+\tmake_pair(\"listtransactions\",      &listtransactions),\n+\tmake_pair(\"getwork\",               &getwork),\n+\tmake_pair(\"listaccounts\",          &listaccounts),\n+\tmake_pair(\"settxfee\",              &settxfee),\n+    };\n map<string, rpcfn_type> mapCallTable(pCallTable, pCallTable + sizeof(pCallTable)/sizeof(pCallTable[0]));\n \n string pAllowInSafeMode[] =\n-{\n-    \"help\",\n-    \"stop\",\n-    \"getblockcount\",\n-    \"getblocknumber\",\n-    \"getconnectioncount\",\n-    \"getdifficulty\",\n-    \"getgenerate\",\n-    \"setgenerate\",\n-    \"gethashespersec\",\n-    \"getinfo\",\n-    \"getnewaddress\",\n-    \"getaccountaddress\",\n-    \"setlabel\",\n-    \"getaccount\",\n-    \"getlabel\", // deprecated\n-    \"getaddressesbyaccount\",\n-    \"getaddressesbylabel\", // deprecated\n-    \"backupwallet\",\n-    \"validateaddress\",\n-    \"getwork\",\n-};\n+    {\n+\t\"help\",\n+\t\"stop\",\n+\t\"getblockcount\",\n+\t\"getblocknumber\",\n+\t\"getconnectioncount\",\n+\t\"getdifficulty\",\n+\t\"getgenerate\",\n+\t\"setgenerate\",\n+\t\"gethashespersec\",\n+\t\"getinfo\",\n+\t\"getnewaddress\",\n+\t\"getaccountaddress\",\n+\t\"setlabel\",\n+\t\"getaccount\",\n+\t\"getlabel\", // deprecated\n+\t\"getaddressesbyaccount\",\n+\t\"getaddressesbylabel\", // deprecated\n+\t\"backupwallet\",\n+\t\"validateaddress\",\n+\t\"getwork\",\n+    };\n set<string> setAllowInSafeMode(pAllowInSafeMode, pAllowInSafeMode + sizeof(pAllowInSafeMode)/sizeof(pAllowInSafeMode[0]));\n \n \n@@ -1514,41 +1514,41 @@ string HTTPReply(int nStatus, const string& strMsg)\n {\n     if (nStatus == 401)\n \treturn strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n-\t    \"Date: %s\\r\\n\"\n-\t    \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-\t    \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n-\t    \"Content-Type: text/html\\r\\n\"\n-\t    \"Content-Length: 296\\r\\n\"\n-\t    \"\\r\\n\"\n-\t    \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n-\t    \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n-\t    \"<HTML>\\r\\n\"\n-\t    \"<HEAD>\\r\\n\"\n-\t    \"<TITLE>Error</TITLE>\\r\\n\"\n-\t    \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n-\t    \"</HEAD>\\r\\n\"\n-\t    \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n-\t    \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n+\t\t\t \"Date: %s\\r\\n\"\n+\t\t\t \"Server: bitcoin-json-rpc/%s\\r\\n\"\n+\t\t\t \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n+\t\t\t \"Content-Type: text/html\\r\\n\"\n+\t\t\t \"Content-Length: 296\\r\\n\"\n+\t\t\t \"\\r\\n\"\n+\t\t\t \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n+\t\t\t \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n+\t\t\t \"<HTML>\\r\\n\"\n+\t\t\t \"<HEAD>\\r\\n\"\n+\t\t\t \"<TITLE>Error</TITLE>\\r\\n\"\n+\t\t\t \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n+\t\t\t \"</HEAD>\\r\\n\"\n+\t\t\t \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n+\t\t\t \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n     string strStatus;\n-\t if (nStatus == 200) strStatus = \"OK\";\n+    if (nStatus == 200) strStatus = \"OK\";\n     else if (nStatus == 400) strStatus = \"Bad Request\";\n     else if (nStatus == 404) strStatus = \"Not Found\";\n     else if (nStatus == 500) strStatus = \"Internal Server Error\";\n     return strprintf(\n-\t    \"HTTP/1.1 %d %s\\r\\n\"\n-\t    \"Date: %s\\r\\n\"\n-\t    \"Connection: close\\r\\n\"\n-\t    \"Content-Length: %d\\r\\n\"\n-\t    \"Content-Type: application/json\\r\\n\"\n-\t    \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-\t    \"\\r\\n\"\n-\t    \"%s\",\n-\tnStatus,\n-\tstrStatus.c_str(),\n-\trfc1123Time().c_str(),\n-\tstrMsg.size(),\n-\tFormatFullVersion().c_str(),\n-\tstrMsg.c_str());\n+\t\t     \"HTTP/1.1 %d %s\\r\\n\"\n+\t\t     \"Date: %s\\r\\n\"\n+\t\t     \"Connection: close\\r\\n\"\n+\t\t     \"Content-Length: %d\\r\\n\"\n+\t\t     \"Content-Type: application/json\\r\\n\"\n+\t\t     \"Server: bitcoin-json-rpc/%s\\r\\n\"\n+\t\t     \"\\r\\n\"\n+\t\t     \"%s\",\n+\t\t     nStatus,\n+\t\t     strStatus.c_str(),\n+\t\t     rfc1123Time().c_str(),\n+\t\t     strMsg.size(),\n+\t\t     FormatFullVersion().c_str(),\n+\t\t     strMsg.c_str());\n }\n \n int ReadHTTPStatus(std::basic_istream<char>& stream)\n@@ -1566,24 +1566,24 @@ int ReadHTTPHeader(std::basic_istream<char>& stream, map<string, string>& mapHea\n {\n     int nLen = 0;\n     loop\n-    {\n-\tstring str;\n-\tstd::getline(stream, str);\n-\tif (str.empty() || str == \"\\r\")\n-\t    break;\n-\tstring::size_type nColon = str.find(\":\");\n-\tif (nColon != string::npos)\n \t{\n-\t    string strHeader = str.substr(0, nColon);\n-\t    boost::trim(strHeader);\n-\t    boost::to_lower(strHeader);\n-\t    string strValue = str.substr(nColon+1);\n-\t    boost::trim(strValue);\n-\t    mapHeadersRet[strHeader] = strValue;\n-\t    if (strHeader == \"content-length\")\n-\t\tnLen = atoi(strValue.c_str());\n+\t    string str;\n+\t    std::getline(stream, str);\n+\t    if (str.empty() || str == \"\\r\")\n+\t\tbreak;\n+\t    string::size_type nColon = str.find(\":\");\n+\t    if (nColon != string::npos)\n+\t\t{\n+\t\t    string strHeader = str.substr(0, nColon);\n+\t\t    boost::trim(strHeader);\n+\t\t    boost::to_lower(strHeader);\n+\t\t    string strValue = str.substr(nColon+1);\n+\t\t    boost::trim(strValue);\n+\t\t    mapHeadersRet[strHeader] = strValue;\n+\t\t    if (strHeader == \"content-length\")\n+\t\t\tnLen = atoi(strValue.c_str());\n+\t\t}\n \t}\n-    }\n     return nLen;\n }\n \n@@ -1602,11 +1602,11 @@ int ReadHTTP(std::basic_istream<char>& stream, map<string, string>& mapHeadersRe\n \n     // Read message\n     if (nLen > 0)\n-    {\n-\tvector<char> vch(nLen);\n-\tstream.read(&vch[0], nLen);\n-\tstrMessageRet = string(vch.begin(), vch.end());\n-    }\n+\t{\n+\t    vector<char> vch(nLen);\n+\t    stream.read(&vch[0], nLen);\n+\t    strMessageRet = string(vch.begin(), vch.end());\n+\t}\n \n     return nStatus;\n }\n@@ -1754,10 +1754,10 @@ class SSLIOStreamDevice : public iostreams::device<iostreams::bidirectional> {\n \tip::tcp::resolver::iterator end;\n \tboost::system::error_code error = asio::error::host_not_found;\n \twhile (error && endpoint_iterator != end)\n-\t{\n-\t    stream.lowest_layer().close();\n-\t    stream.lowest_layer().connect(*endpoint_iterator++, error);\n-\t}\n+\t    {\n+\t\tstream.lowest_layer().close();\n+\t\tstream.lowest_layer().connect(*endpoint_iterator++, error);\n+\t    }\n \tif (error)\n \t    return false;\n \treturn true;\n@@ -1794,20 +1794,20 @@ void ThreadRPCServer2(void* parg)\n     printf(\"ThreadRPCServer started\\n\");\n \n     if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n-    {\n-\tstring strWhatAmI = \"To use bitcoind\";\n-\tif (mapArgs.count(\"-server\"))\n-\t    strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n-\telse if (mapArgs.count(\"-daemon\"))\n-\t    strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n-\tPrintConsole(\n-\t    _(\"Warning: %s, you must set rpcpassword=<password>\\nin the configuration file: %s\\n\"\n-\t      \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"),\n-\t\tstrWhatAmI.c_str(),\n-\t\tGetConfigFile().c_str());\n-\tCreateThread(Shutdown, NULL);\n-\treturn;\n-    }\n+\t{\n+\t    string strWhatAmI = \"To use bitcoind\";\n+\t    if (mapArgs.count(\"-server\"))\n+\t\tstrWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n+\t    else if (mapArgs.count(\"-daemon\"))\n+\t\tstrWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n+\t    PrintConsole(\n+\t\t\t _(\"Warning: %s, you must set rpcpassword=<password>\\nin the configuration file: %s\\n\"\n+\t\t\t   \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"),\n+\t\t\t strWhatAmI.c_str(),\n+\t\t\t GetConfigFile().c_str());\n+\t    CreateThread(Shutdown, NULL);\n+\t    return;\n+\t}\n \n     bool fUseSSL = GetBoolArg(\"-rpcssl\");\n     asio::ip::address bindAddress = mapArgs.count(\"-rpcallowip\") ? asio::ip::address_v4::any() : asio::ip::address_v4::loopback();\n@@ -1821,145 +1821,145 @@ void ThreadRPCServer2(void* parg)\n #ifdef USE_SSL\n     ssl::context context(io_service, ssl::context::sslv23);\n     if (fUseSSL)\n-    {\n-\tcontext.set_options(ssl::context::no_sslv2);\n-\tfilesystem::path certfile = GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\");\n-\tif (!certfile.is_complete()) certfile = filesystem::path(GetDataDir()) / certfile;\n-\tif (filesystem::exists(certfile)) context.use_certificate_chain_file(certfile.string().c_str());\n-\telse printf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", certfile.string().c_str());\n-\tfilesystem::path pkfile = GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\");\n-\tif (!pkfile.is_complete()) pkfile = filesystem::path(GetDataDir()) / pkfile;\n-\tif (filesystem::exists(pkfile)) context.use_private_key_file(pkfile.string().c_str(), ssl::context::pem);\n-\telse printf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pkfile.string().c_str());\n-\n-\tstring ciphers = GetArg(\"-rpcsslciphers\",\n-\t\t\t\t\t \"TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\");\n-\tSSL_CTX_set_cipher_list(context.impl(), ciphers.c_str());\n-    }\n+\t{\n+\t    context.set_options(ssl::context::no_sslv2);\n+\t    filesystem::path certfile = GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\");\n+\t    if (!certfile.is_complete()) certfile = filesystem::path(GetDataDir()) / certfile;\n+\t    if (filesystem::exists(certfile)) context.use_certificate_chain_file(certfile.string().c_str());\n+\t    else printf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", certfile.string().c_str());\n+\t    filesystem::path pkfile = GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\");\n+\t    if (!pkfile.is_complete()) pkfile = filesystem::path(GetDataDir()) / pkfile;\n+\t    if (filesystem::exists(pkfile)) context.use_private_key_file(pkfile.string().c_str(), ssl::context::pem);\n+\t    else printf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pkfile.string().c_str());\n+\n+\t    string ciphers = GetArg(\"-rpcsslciphers\",\n+\t\t\t\t    \"TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\");\n+\t    SSL_CTX_set_cipher_list(context.impl(), ciphers.c_str());\n+\t}\n #else\n     if (fUseSSL)\n \tthrow runtime_error(\"-rpcssl=1, but bitcoin compiled without full openssl libraries.\");\n #endif\n \n     loop\n-    {\n-\t// Accept connection\n+\t{\n+\t    // Accept connection\n #ifdef USE_SSL\n-\tSSLStream sslStream(io_service, context);\n-\tSSLIOStreamDevice d(sslStream, fUseSSL);\n-\tiostreams::stream<SSLIOStreamDevice> stream(d);\n+\t    SSLStream sslStream(io_service, context);\n+\t    SSLIOStreamDevice d(sslStream, fUseSSL);\n+\t    iostreams::stream<SSLIOStreamDevice> stream(d);\n #else\n-\tip::tcp::iostream stream;\n+\t    ip::tcp::iostream stream;\n #endif\n \n-\tip::tcp::endpoint peer;\n-\tvnThreadsRunning[4]--;\n+\t    ip::tcp::endpoint peer;\n+\t    vnThreadsRunning[4]--;\n #ifdef USE_SSL\n-\tacceptor.accept(sslStream.lowest_layer(), peer);\n+\t    acceptor.accept(sslStream.lowest_layer(), peer);\n #else\n-\tacceptor.accept(*stream.rdbuf(), peer);\n+\t    acceptor.accept(*stream.rdbuf(), peer);\n #endif\n-\tvnThreadsRunning[4]++;\n-\tif (fShutdown)\n-\t    return;\n-\n-\t// Restrict callers by IP\n-\tif (!ClientAllowed(peer.address().to_string()))\n-\t    continue;\n+\t    vnThreadsRunning[4]++;\n+\t    if (fShutdown)\n+\t\treturn;\n \n-\tmap<string, string> mapHeaders;\n-\tstring strRequest;\n-\n-\tboost::thread api_caller(ReadHTTP, boost::ref(stream), boost::ref(mapHeaders), boost::ref(strRequest));\n-\tif (!api_caller.timed_join(boost::posix_time::seconds(GetArg(\"-rpctimeout\", 30))))\n-\t{   // Timed out:\n-\t    acceptor.cancel();\n-\t    printf(\"ThreadRPCServer ReadHTTP timeout\\n\");\n-\t    continue;\n-\t}\n-\n-\t// Check authorization\n-\tif (mapHeaders.count(\"authorization\") == 0)\n-\t{\n-\t    stream << HTTPReply(401, \"\") << std::flush;\n-\t    continue;\n-\t}\n-\tif (!HTTPAuthorized(mapHeaders))\n-\t{\n-\t    // Deter brute-forcing short passwords\n-\t    if (mapArgs[\"-rpcpassword\"].size() < 15)\n-\t\tSleep(50);\n+\t    // Restrict callers by IP\n+\t    if (!ClientAllowed(peer.address().to_string()))\n+\t\tcontinue;\n \n-\t    stream << HTTPReply(401, \"\") << std::flush;\n-\t    printf(\"ThreadRPCServer incorrect password attempt\\n\");\n-\t    continue;\n-\t}\n+\t    map<string, string> mapHeaders;\n+\t    string strRequest;\n \n-\tValue id = Value::null;\n-\ttry\n-\t{\n-\t    // Parse request\n-\t    Value valRequest;\n-\t    if (!read_string(strRequest, valRequest) || valRequest.type() != obj_type)\n-\t\tthrow JSONRPCError(-32700, \"Parse error\");\n-\t    const Object& request = valRequest.get_obj();\n-\n-\t    // Parse id now so errors from here on will have the id\n-\t    id = find_value(request, \"id\");\n-\n-\t    // Parse method\n-\t    Value valMethod = find_value(request, \"method\");\n-\t    if (valMethod.type() == null_type)\n-\t\tthrow JSONRPCError(-32600, \"Missing method\");\n-\t    if (valMethod.type() != str_type)\n-\t\tthrow JSONRPCError(-32600, \"Method must be a string\");\n-\t    string strMethod = valMethod.get_str();\n-\t    if (strMethod != \"getwork\")\n-\t\tprintf(\"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n-\n-\t    // Parse params\n-\t    Value valParams = find_value(request, \"params\");\n-\t    Array params;\n-\t    if (valParams.type() == array_type)\n-\t\tparams = valParams.get_array();\n-\t    else if (valParams.type() == null_type)\n-\t\tparams = Array();\n-\t    else\n-\t\tthrow JSONRPCError(-32600, \"Params must be an array\");\n+\t    boost::thread api_caller(ReadHTTP, boost::ref(stream), boost::ref(mapHeaders), boost::ref(strRequest));\n+\t    if (!api_caller.timed_join(boost::posix_time::seconds(GetArg(\"-rpctimeout\", 30))))\n+\t\t{   // Timed out:\n+\t\t    acceptor.cancel();\n+\t\t    printf(\"ThreadRPCServer ReadHTTP timeout\\n\");\n+\t\t    continue;\n+\t\t}\n \n-\t    // Find method\n-\t    map<string, rpcfn_type>::iterator mi = mapCallTable.find(strMethod);\n-\t    if (mi == mapCallTable.end())\n-\t\tthrow JSONRPCError(-32601, \"Method not found\");\n+\t    // Check authorization\n+\t    if (mapHeaders.count(\"authorization\") == 0)\n+\t\t{\n+\t\t    stream << HTTPReply(401, \"\") << std::flush;\n+\t\t    continue;\n+\t\t}\n+\t    if (!HTTPAuthorized(mapHeaders))\n+\t\t{\n+\t\t    // Deter brute-forcing short passwords\n+\t\t    if (mapArgs[\"-rpcpassword\"].size() < 15)\n+\t\t\tSleep(50);\n \n-\t    // Observe safe mode\n-\t    string strWarning = GetWarnings(\"rpc\");\n-\t    if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\") && !setAllowInSafeMode.count(strMethod))\n-\t\tthrow JSONRPCError(-2, string(\"Safe mode: \") + strWarning);\n+\t\t    stream << HTTPReply(401, \"\") << std::flush;\n+\t\t    printf(\"ThreadRPCServer incorrect password attempt\\n\");\n+\t\t    continue;\n+\t\t}\n \n+\t    Value id = Value::null;\n \t    try\n-\t    {\n-\t\t// Execute\n-\t\tValue result = (*(*mi).second)(params, false);\n-\n-\t\t// Send reply\n-\t\tstring strReply = JSONRPCReply(result, Value::null, id);\n-\t\tstream << HTTPReply(200, strReply) << std::flush;\n-\t    }\n+\t\t{\n+\t\t    // Parse request\n+\t\t    Value valRequest;\n+\t\t    if (!read_string(strRequest, valRequest) || valRequest.type() != obj_type)\n+\t\t\tthrow JSONRPCError(-32700, \"Parse error\");\n+\t\t    const Object& request = valRequest.get_obj();\n+\n+\t\t    // Parse id now so errors from here on will have the id\n+\t\t    id = find_value(request, \"id\");\n+\n+\t\t    // Parse method\n+\t\t    Value valMethod = find_value(request, \"method\");\n+\t\t    if (valMethod.type() == null_type)\n+\t\t\tthrow JSONRPCError(-32600, \"Missing method\");\n+\t\t    if (valMethod.type() != str_type)\n+\t\t\tthrow JSONRPCError(-32600, \"Method must be a string\");\n+\t\t    string strMethod = valMethod.get_str();\n+\t\t    if (strMethod != \"getwork\")\n+\t\t\tprintf(\"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n+\n+\t\t    // Parse params\n+\t\t    Value valParams = find_value(request, \"params\");\n+\t\t    Array params;\n+\t\t    if (valParams.type() == array_type)\n+\t\t\tparams = valParams.get_array();\n+\t\t    else if (valParams.type() == null_type)\n+\t\t\tparams = Array();\n+\t\t    else\n+\t\t\tthrow JSONRPCError(-32600, \"Params must be an array\");\n+\n+\t\t    // Find method\n+\t\t    map<string, rpcfn_type>::iterator mi = mapCallTable.find(strMethod);\n+\t\t    if (mi == mapCallTable.end())\n+\t\t\tthrow JSONRPCError(-32601, \"Method not found\");\n+\n+\t\t    // Observe safe mode\n+\t\t    string strWarning = GetWarnings(\"rpc\");\n+\t\t    if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\") && !setAllowInSafeMode.count(strMethod))\n+\t\t\tthrow JSONRPCError(-2, string(\"Safe mode: \") + strWarning);\n+\n+\t\t    try\n+\t\t\t{\n+\t\t\t    // Execute\n+\t\t\t    Value result = (*(*mi).second)(params, false);\n+\n+\t\t\t    // Send reply\n+\t\t\t    string strReply = JSONRPCReply(result, Value::null, id);\n+\t\t\t    stream << HTTPReply(200, strReply) << std::flush;\n+\t\t\t}\n+\t\t    catch (std::exception& e)\n+\t\t\t{\n+\t\t\t    ErrorReply(stream, JSONRPCError(-1, e.what()), id);\n+\t\t\t}\n+\t\t}\n+\t    catch (Object& objError)\n+\t\t{\n+\t\t    ErrorReply(stream, objError, id);\n+\t\t}\n \t    catch (std::exception& e)\n-\t    {\n-\t\tErrorReply(stream, JSONRPCError(-1, e.what()), id);\n-\t    }\n-\t}\n-\tcatch (Object& objError)\n-\t{\n-\t    ErrorReply(stream, objError, id);\n-\t}\n-\tcatch (std::exception& e)\n-\t{\n-\t    ErrorReply(stream, JSONRPCError(-32700, e.what()), id);\n+\t\t{\n+\t\t    ErrorReply(stream, JSONRPCError(-32700, e.what()), id);\n+\t\t}\n \t}\n-    }\n }\n \n \n@@ -1969,9 +1969,9 @@ Object CallRPC(const string& strMethod, const Array& params)\n {\n     if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n \tthrow runtime_error(strprintf(\n-\t    _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n-\t      \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n-\t\tGetConfigFile().c_str()));\n+\t\t\t\t      _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n+\t\t\t\t\t\"If the file does not exist, create it with owner-readable-only file permissions.\"),\n+\t\t\t\t      GetConfigFile().c_str()));\n \n     // Connect to localhost\n     bool fUseSSL = GetBoolArg(\"-rpcssl\");\n@@ -2033,126 +2033,126 @@ template<typename T>\n void ConvertTo(Value& value)\n {\n     if (value.type() == str_type)\n-    {\n-\t// reinterpret string as unquoted json value\n-\tValue value2;\n-\tif (!read_string(value.get_str(), value2))\n-\t    throw runtime_error(\"type mismatch\");\n-\tvalue = value2.get_value<T>();\n-    }\n+\t{\n+\t    // reinterpret string as unquoted json value\n+\t    Value value2;\n+\t    if (!read_string(value.get_str(), value2))\n+\t\tthrow runtime_error(\"type mismatch\");\n+\t    value = value2.get_value<T>();\n+\t}\n     else\n-    {\n-\tvalue = value.get_value<T>();\n-    }\n+\t{\n+\t    value = value.get_value<T>();\n+\t}\n }\n \n int CommandLineRPC(int argc, char *argv[])\n {\n     string strPrint;\n     int nRet = 0;\n     try\n-    {\n-\t// Skip switches\n-\twhile (argc > 1 && IsSwitchChar(argv[1][0]))\n \t{\n-\t    argc--;\n-\t    argv++;\n-\t}\n+\t    // Skip switches\n+\t    while (argc > 1 && IsSwitchChar(argv[1][0]))\n+\t\t{\n+\t\t    argc--;\n+\t\t    argv++;\n+\t\t}\n \n-\t// Method\n-\tif (argc < 2)\n-\t    throw runtime_error(\"too few parameters\");\n-\tstring strMethod = argv[1];\n-\n-\t// Parameters default to strings\n-\tArray params;\n-\tfor (int i = 2; i < argc; i++)\n-\t    params.push_back(argv[i]);\n-\tint n = params.size();\n-\n-\t//\n-\t// Special case non-string parameter types\n-\t//\n-\tif (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n-\tif (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-\tif (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n-\tif (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n-\tif (strMethod == \"getamountreceived\"      && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n-\tif (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-\tif (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-\tif (strMethod == \"getreceivedbylabel\"     && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n-\tif (strMethod == \"getallreceived\"         && n > 0) ConvertTo<boost::int64_t>(params[0]); // deprecated\n-\tif (strMethod == \"getallreceived\"         && n > 1) ConvertTo<bool>(params[1]);\n-\tif (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-\tif (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n-\tif (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-\tif (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n-\tif (strMethod == \"listreceivedbylabel\"    && n > 0) ConvertTo<boost::int64_t>(params[0]); // deprecated\n-\tif (strMethod == \"listreceivedbylabel\"    && n > 1) ConvertTo<bool>(params[1]); // deprecated\n-\tif (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-\tif (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n-\tif (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n-\tif (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n-\tif (strMethod == \"sendfrom\"               && n > 3) ConvertTo<boost::int64_t>(params[3]);\n-\tif (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-\tif (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n-\tif (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-\tif (strMethod == \"sendmany\"               && n > 1)\n-\t{\n-\t    string s = params[1].get_str();\n-\t    Value v;\n-\t    if (!read_string(s, v) || v.type() != obj_type)\n-\t\tthrow runtime_error(\"type mismatch\");\n-\t    params[1] = v.get_obj();\n-\t}\n-\tif (strMethod == \"sendmany\"                && n > 2) ConvertTo<boost::int64_t>(params[2]);\n+\t    // Method\n+\t    if (argc < 2)\n+\t\tthrow runtime_error(\"too few parameters\");\n+\t    string strMethod = argv[1];\n \n-\t// Execute\n-\tObject reply = CallRPC(strMethod, params);\n+\t    // Parameters default to strings\n+\t    Array params;\n+\t    for (int i = 2; i < argc; i++)\n+\t\tparams.push_back(argv[i]);\n+\t    int n = params.size();\n+\n+\t    //\n+\t    // Special case non-string parameter types\n+\t    //\n+\t    if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n+\t    if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+\t    if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n+\t    if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n+\t    if (strMethod == \"getamountreceived\"      && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n+\t    if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+\t    if (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+\t    if (strMethod == \"getreceivedbylabel\"     && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated\n+\t    if (strMethod == \"getallreceived\"         && n > 0) ConvertTo<boost::int64_t>(params[0]); // deprecated\n+\t    if (strMethod == \"getallreceived\"         && n > 1) ConvertTo<bool>(params[1]);\n+\t    if (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+\t    if (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n+\t    if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+\t    if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n+\t    if (strMethod == \"listreceivedbylabel\"    && n > 0) ConvertTo<boost::int64_t>(params[0]); // deprecated\n+\t    if (strMethod == \"listreceivedbylabel\"    && n > 1) ConvertTo<bool>(params[1]); // deprecated\n+\t    if (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+\t    if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n+\t    if (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n+\t    if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n+\t    if (strMethod == \"sendfrom\"               && n > 3) ConvertTo<boost::int64_t>(params[3]);\n+\t    if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+\t    if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n+\t    if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+\t    if (strMethod == \"sendmany\"               && n > 1)\n+\t\t{\n+\t\t    string s = params[1].get_str();\n+\t\t    Value v;\n+\t\t    if (!read_string(s, v) || v.type() != obj_type)\n+\t\t\tthrow runtime_error(\"type mismatch\");\n+\t\t    params[1] = v.get_obj();\n+\t\t}\n+\t    if (strMethod == \"sendmany\"                && n > 2) ConvertTo<boost::int64_t>(params[2]);\n \n-\t// Parse reply\n-\tconst Value& result = find_value(reply, \"result\");\n-\tconst Value& error  = find_value(reply, \"error\");\n-\tconst Value& id     = find_value(reply, \"id\");\n+\t    // Execute\n+\t    Object reply = CallRPC(strMethod, params);\n \n-\tif (error.type() != null_type)\n-\t{\n-\t    // Error\n-\t    strPrint = \"error: \" + write_string(error, false);\n-\t    int code = find_value(error.get_obj(), \"code\").get_int();\n-\t    nRet = abs(code);\n-\t}\n-\telse\n-\t{\n-\t    // Result\n-\t    if (result.type() == null_type)\n-\t\tstrPrint = \"\";\n-\t    else if (result.type() == str_type)\n-\t\tstrPrint = result.get_str();\n+\t    // Parse reply\n+\t    const Value& result = find_value(reply, \"result\");\n+\t    const Value& error  = find_value(reply, \"error\");\n+\t    const Value& id     = find_value(reply, \"id\");\n+\n+\t    if (error.type() != null_type)\n+\t\t{\n+\t\t    // Error\n+\t\t    strPrint = \"error: \" + write_string(error, false);\n+\t\t    int code = find_value(error.get_obj(), \"code\").get_int();\n+\t\t    nRet = abs(code);\n+\t\t}\n \t    else\n-\t\tstrPrint = write_string(result, true);\n+\t\t{\n+\t\t    // Result\n+\t\t    if (result.type() == null_type)\n+\t\t\tstrPrint = \"\";\n+\t\t    else if (result.type() == str_type)\n+\t\t\tstrPrint = result.get_str();\n+\t\t    else\n+\t\t\tstrPrint = write_string(result, true);\n+\t\t}\n \t}\n-    }\n     catch (std::exception& e)\n-    {\n-\tstrPrint = string(\"error: \") + e.what();\n-\tnRet = 87;\n-    }\n+\t{\n+\t    strPrint = string(\"error: \") + e.what();\n+\t    nRet = 87;\n+\t}\n     catch (...)\n-    {\n-\tPrintException(NULL, \"CommandLineRPC()\");\n-    }\n+\t{\n+\t    PrintException(NULL, \"CommandLineRPC()\");\n+\t}\n \n     if (strPrint != \"\")\n-    {\n+\t{\n #if defined(__WXMSW__) && defined(GUI)\n-\t// Windows GUI apps can't print to command line,\n-\t// so settle for a message box yuck\n-\tMyMessageBox(strPrint, \"Bitcoin\", wxOK);\n+\t    // Windows GUI apps can't print to command line,\n+\t    // so settle for a message box yuck\n+\t    MyMessageBox(strPrint, \"Bitcoin\", wxOK);\n #else\n-\tfprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n+\t    fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n #endif\n-    }\n+\t}\n     return nRet;\n }\n \n@@ -2172,17 +2172,17 @@ int main(int argc, char *argv[])\n     setbuf(stderr, NULL);\n \n     try\n-    {\n-\tif (argc >= 2 && string(argv[1]) == \"-server\")\n \t{\n-\t    printf(\"server ready\\n\");\n-\t    ThreadRPCServer(NULL);\n-\t}\n-\telse\n-\t{\n-\t    return CommandLineRPC(argc, argv);\n+\t    if (argc >= 2 && string(argv[1]) == \"-server\")\n+\t\t{\n+\t\t    printf(\"server ready\\n\");\n+\t\t    ThreadRPCServer(NULL);\n+\t\t}\n+\t    else\n+\t\t{\n+\t\t    return CommandLineRPC(argc, argv);\n+\t\t}\n \t}\n-    }\n     catch (std::exception& e) {\n \tPrintException(&e, \"main()\");\n     } catch (...) {"
      },
      {
        "sha": "a195643fee1aaa82b51dadbbd01c80ecfe3829e7",
        "filename": "src/rpc.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/rpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/rpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,5 +2,10 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef RPC_H\n+#define RPC_H\n+\n void ThreadRPCServer(void* parg);\n int CommandLineRPC(int argc, char *argv[]);\n+\n+#endif // !RPC_H"
      },
      {
        "sha": "e247838c0c0e4b539f0c966c722ae767eac938bf",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 894,
        "deletions": 894,
        "changes": 1788,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -30,15 +30,15 @@ CBigNum CastToBigNum(const valtype& vch)\n bool CastToBool(const valtype& vch)\n {\n     for (int i = 0; i < vch.size(); i++)\n-    {\n-\tif (vch[i] != 0)\n \t{\n-\t    // Can be negative zero\n-\t    if (i == vch.size()-1 && vch[i] == 0x80)\n-\t\treturn false;\n-\t    return true;\n+\t    if (vch[i] != 0)\n+\t\t{\n+\t\t    // Can be negative zero\n+\t\t    if (i == vch.size()-1 && vch[i] == 0x80)\n+\t\t\treturn false;\n+\t\t    return true;\n+\t\t}\n \t}\n-    }\n     return false;\n }\n \n@@ -83,775 +83,775 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n \n \n     try\n-    {\n-\twhile (pc < pend)\n \t{\n-\t    bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n-\n-\t    //\n-\t    // Read instruction\n-\t    //\n-\t    if (!script.GetOp(pc, opcode, vchPushValue))\n-\t\treturn false;\n-\t    if (vchPushValue.size() > 520)\n-\t\treturn false;\n-\t    if (opcode > OP_16 && ++nOpCount > 201)\n-\t\treturn false;\n-\n-\t    if (opcode == OP_CAT ||\n-\t\topcode == OP_SUBSTR ||\n-\t\topcode == OP_LEFT ||\n-\t\topcode == OP_RIGHT ||\n-\t\topcode == OP_INVERT ||\n-\t\topcode == OP_AND ||\n-\t\topcode == OP_OR ||\n-\t\topcode == OP_XOR ||\n-\t\topcode == OP_2MUL ||\n-\t\topcode == OP_2DIV ||\n-\t\topcode == OP_MUL ||\n-\t\topcode == OP_DIV ||\n-\t\topcode == OP_MOD ||\n-\t\topcode == OP_LSHIFT ||\n-\t\topcode == OP_RSHIFT)\n-\t\treturn false;\n-\n-\t    if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n-\t\tstack.push_back(vchPushValue);\n-\t    else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n-\t    switch (opcode)\n-\t    {\n-\t\t//\n-\t\t// Push value\n-\t\t//\n-\t\tcase OP_1NEGATE:\n-\t\tcase OP_1:\n-\t\tcase OP_2:\n-\t\tcase OP_3:\n-\t\tcase OP_4:\n-\t\tcase OP_5:\n-\t\tcase OP_6:\n-\t\tcase OP_7:\n-\t\tcase OP_8:\n-\t\tcase OP_9:\n-\t\tcase OP_10:\n-\t\tcase OP_11:\n-\t\tcase OP_12:\n-\t\tcase OP_13:\n-\t\tcase OP_14:\n-\t\tcase OP_15:\n-\t\tcase OP_16:\n-\t\t{\n-\t\t    // ( -- value)\n-\t\t    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n-\t\t    stack.push_back(bn.getvch());\n-\t\t}\n-\t\tbreak;\n-\n-\n-\t\t//\n-\t\t// Control\n-\t\t//\n-\t\tcase OP_NOP:\n-\t\tcase OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n-\t\tcase OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n-\t\tbreak;\n-\n-\t\tcase OP_IF:\n-\t\tcase OP_NOTIF:\n-\t\t{\n-\t\t    // <expression> if [statements] [else [statements]] endif\n-\t\t    bool fValue = false;\n-\t\t    if (fExec)\n-\t\t    {\n-\t\t\tif (stack.size() < 1)\n-\t\t\t    return false;\n-\t\t\tvaltype& vch = stacktop(-1);\n-\t\t\tfValue = CastToBool(vch);\n-\t\t\tif (opcode == OP_NOTIF)\n-\t\t\t    fValue = !fValue;\n-\t\t\tpopstack(stack);\n-\t\t    }\n-\t\t    vfExec.push_back(fValue);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_ELSE:\n-\t\t{\n-\t\t    if (vfExec.empty())\n-\t\t\treturn false;\n-\t\t    vfExec.back() = !vfExec.back();\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_ENDIF:\n-\t\t{\n-\t\t    if (vfExec.empty())\n-\t\t\treturn false;\n-\t\t    vfExec.pop_back();\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_VERIFY:\n-\t\t{\n-\t\t    // (true -- ) or\n-\t\t    // (false -- false) and return\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    bool fValue = CastToBool(stacktop(-1));\n-\t\t    if (fValue)\n-\t\t\tpopstack(stack);\n-\t\t    else\n-\t\t\treturn false;\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_RETURN:\n-\t\t{\n-\t\t    return false;\n-\t\t}\n-\t\tbreak;\n-\n-\n-\t\t//\n-\t\t// Stack ops\n-\t\t//\n-\t\tcase OP_TOALTSTACK:\n-\t\t{\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    altstack.push_back(stacktop(-1));\n-\t\t    popstack(stack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_FROMALTSTACK:\n-\t\t{\n-\t\t    if (altstack.size() < 1)\n-\t\t\treturn false;\n-\t\t    stack.push_back(altstacktop(-1));\n-\t\t    popstack(altstack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_2DROP:\n-\t\t{\n-\t\t    // (x1 x2 -- )\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_2DUP:\n-\t\t{\n-\t\t    // (x1 x2 -- x1 x2 x1 x2)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype vch1 = stacktop(-2);\n-\t\t    valtype vch2 = stacktop(-1);\n-\t\t    stack.push_back(vch1);\n-\t\t    stack.push_back(vch2);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_3DUP:\n-\t\t{\n-\t\t    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n-\t\t    if (stack.size() < 3)\n-\t\t\treturn false;\n-\t\t    valtype vch1 = stacktop(-3);\n-\t\t    valtype vch2 = stacktop(-2);\n-\t\t    valtype vch3 = stacktop(-1);\n-\t\t    stack.push_back(vch1);\n-\t\t    stack.push_back(vch2);\n-\t\t    stack.push_back(vch3);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_2OVER:\n-\t\t{\n-\t\t    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n-\t\t    if (stack.size() < 4)\n-\t\t\treturn false;\n-\t\t    valtype vch1 = stacktop(-4);\n-\t\t    valtype vch2 = stacktop(-3);\n-\t\t    stack.push_back(vch1);\n-\t\t    stack.push_back(vch2);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_2ROT:\n-\t\t{\n-\t\t    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n-\t\t    if (stack.size() < 6)\n-\t\t\treturn false;\n-\t\t    valtype vch1 = stacktop(-6);\n-\t\t    valtype vch2 = stacktop(-5);\n-\t\t    stack.erase(stack.end()-6, stack.end()-4);\n-\t\t    stack.push_back(vch1);\n-\t\t    stack.push_back(vch2);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_2SWAP:\n-\t\t{\n-\t\t    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n-\t\t    if (stack.size() < 4)\n-\t\t\treturn false;\n-\t\t    swap(stacktop(-4), stacktop(-2));\n-\t\t    swap(stacktop(-3), stacktop(-1));\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_IFDUP:\n-\t\t{\n-\t\t    // (x - 0 | x x)\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    valtype vch = stacktop(-1);\n-\t\t    if (CastToBool(vch))\n-\t\t\tstack.push_back(vch);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_DEPTH:\n-\t\t{\n-\t\t    // -- stacksize\n-\t\t    CBigNum bn(stack.size());\n-\t\t    stack.push_back(bn.getvch());\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_DROP:\n-\t\t{\n-\t\t    // (x -- )\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    popstack(stack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_DUP:\n-\t\t{\n-\t\t    // (x -- x x)\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    valtype vch = stacktop(-1);\n-\t\t    stack.push_back(vch);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_NIP:\n-\t\t{\n-\t\t    // (x1 x2 -- x2)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    stack.erase(stack.end() - 2);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_OVER:\n-\t\t{\n-\t\t    // (x1 x2 -- x1 x2 x1)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype vch = stacktop(-2);\n-\t\t    stack.push_back(vch);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_PICK:\n-\t\tcase OP_ROLL:\n-\t\t{\n-\t\t    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n-\t\t    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    int n = CastToBigNum(stacktop(-1)).getint();\n-\t\t    popstack(stack);\n-\t\t    if (n < 0 || n >= stack.size())\n-\t\t\treturn false;\n-\t\t    valtype vch = stacktop(-n-1);\n-\t\t    if (opcode == OP_ROLL)\n-\t\t\tstack.erase(stack.end()-n-1);\n-\t\t    stack.push_back(vch);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_ROT:\n-\t\t{\n-\t\t    // (x1 x2 x3 -- x2 x3 x1)\n-\t\t    //  x2 x1 x3  after first swap\n-\t\t    //  x2 x3 x1  after second swap\n-\t\t    if (stack.size() < 3)\n-\t\t\treturn false;\n-\t\t    swap(stacktop(-3), stacktop(-2));\n-\t\t    swap(stacktop(-2), stacktop(-1));\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_SWAP:\n-\t\t{\n-\t\t    // (x1 x2 -- x2 x1)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    swap(stacktop(-2), stacktop(-1));\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_TUCK:\n-\t\t{\n-\t\t    // (x1 x2 -- x2 x1 x2)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype vch = stacktop(-1);\n-\t\t    stack.insert(stack.end()-2, vch);\n-\t\t}\n-\t\tbreak;\n-\n-\n-\t\t//\n-\t\t// Splice ops\n-\t\t//\n-\t\tcase OP_CAT:\n-\t\t{\n-\t\t    // (x1 x2 -- out)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype& vch1 = stacktop(-2);\n-\t\t    valtype& vch2 = stacktop(-1);\n-\t\t    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n-\t\t    popstack(stack);\n-\t\t    if (stacktop(-1).size() > 520)\n-\t\t\treturn false;\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_SUBSTR:\n-\t\t{\n-\t\t    // (in begin size -- out)\n-\t\t    if (stack.size() < 3)\n-\t\t\treturn false;\n-\t\t    valtype& vch = stacktop(-3);\n-\t\t    int nBegin = CastToBigNum(stacktop(-2)).getint();\n-\t\t    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n-\t\t    if (nBegin < 0 || nEnd < nBegin)\n-\t\t\treturn false;\n-\t\t    if (nBegin > vch.size())\n-\t\t\tnBegin = vch.size();\n-\t\t    if (nEnd > vch.size())\n-\t\t\tnEnd = vch.size();\n-\t\t    vch.erase(vch.begin() + nEnd, vch.end());\n-\t\t    vch.erase(vch.begin(), vch.begin() + nBegin);\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_LEFT:\n-\t\tcase OP_RIGHT:\n-\t\t{\n-\t\t    // (in size -- out)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype& vch = stacktop(-2);\n-\t\t    int nSize = CastToBigNum(stacktop(-1)).getint();\n-\t\t    if (nSize < 0)\n-\t\t\treturn false;\n-\t\t    if (nSize > vch.size())\n-\t\t\tnSize = vch.size();\n-\t\t    if (opcode == OP_LEFT)\n-\t\t\tvch.erase(vch.begin() + nSize, vch.end());\n-\t\t    else\n-\t\t\tvch.erase(vch.begin(), vch.end() - nSize);\n-\t\t    popstack(stack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_SIZE:\n-\t\t{\n-\t\t    // (in -- in size)\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    CBigNum bn(stacktop(-1).size());\n-\t\t    stack.push_back(bn.getvch());\n-\t\t}\n-\t\tbreak;\n-\n-\n-\t\t//\n-\t\t// Bitwise logic\n-\t\t//\n-\t\tcase OP_INVERT:\n-\t\t{\n-\t\t    // (in - out)\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    valtype& vch = stacktop(-1);\n-\t\t    for (int i = 0; i < vch.size(); i++)\n-\t\t\tvch[i] = ~vch[i];\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_AND:\n-\t\tcase OP_OR:\n-\t\tcase OP_XOR:\n-\t\t{\n-\t\t    // (x1 x2 - out)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype& vch1 = stacktop(-2);\n-\t\t    valtype& vch2 = stacktop(-1);\n-\t\t    MakeSameSize(vch1, vch2);\n-\t\t    if (opcode == OP_AND)\n-\t\t    {\n-\t\t\tfor (int i = 0; i < vch1.size(); i++)\n-\t\t\t    vch1[i] &= vch2[i];\n-\t\t    }\n-\t\t    else if (opcode == OP_OR)\n-\t\t    {\n-\t\t\tfor (int i = 0; i < vch1.size(); i++)\n-\t\t\t    vch1[i] |= vch2[i];\n-\t\t    }\n-\t\t    else if (opcode == OP_XOR)\n-\t\t    {\n-\t\t\tfor (int i = 0; i < vch1.size(); i++)\n-\t\t\t    vch1[i] ^= vch2[i];\n-\t\t    }\n-\t\t    popstack(stack);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_EQUAL:\n-\t\tcase OP_EQUALVERIFY:\n-\t\t//case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n-\t\t{\n-\t\t    // (x1 x2 - bool)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    valtype& vch1 = stacktop(-2);\n-\t\t    valtype& vch2 = stacktop(-1);\n-\t\t    bool fEqual = (vch1 == vch2);\n-\t\t    // OP_NOTEQUAL is disabled because it would be too easy to say\n-\t\t    // something like n != 1 and have some wiseguy pass in 1 with extra\n-\t\t    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n-\t\t    //if (opcode == OP_NOTEQUAL)\n-\t\t    //    fEqual = !fEqual;\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t    stack.push_back(fEqual ? vchTrue : vchFalse);\n-\t\t    if (opcode == OP_EQUALVERIFY)\n-\t\t    {\n-\t\t\tif (fEqual)\n-\t\t\t    popstack(stack);\n-\t\t\telse\n-\t\t\t    return false;\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\n-\t\t//\n-\t\t// Numeric\n-\t\t//\n-\t\tcase OP_1ADD:\n-\t\tcase OP_1SUB:\n-\t\tcase OP_2MUL:\n-\t\tcase OP_2DIV:\n-\t\tcase OP_NEGATE:\n-\t\tcase OP_ABS:\n-\t\tcase OP_NOT:\n-\t\tcase OP_0NOTEQUAL:\n-\t\t{\n-\t\t    // (in -- out)\n-\t\t    if (stack.size() < 1)\n-\t\t\treturn false;\n-\t\t    CBigNum bn = CastToBigNum(stacktop(-1));\n-\t\t    switch (opcode)\n-\t\t    {\n-\t\t    case OP_1ADD:       bn += bnOne; break;\n-\t\t    case OP_1SUB:       bn -= bnOne; break;\n-\t\t    case OP_2MUL:       bn <<= 1; break;\n-\t\t    case OP_2DIV:       bn >>= 1; break;\n-\t\t    case OP_NEGATE:     bn = -bn; break;\n-\t\t    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n-\t\t    case OP_NOT:        bn = (bn == bnZero); break;\n-\t\t    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n-\t\t    }\n-\t\t    popstack(stack);\n-\t\t    stack.push_back(bn.getvch());\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_ADD:\n-\t\tcase OP_SUB:\n-\t\tcase OP_MUL:\n-\t\tcase OP_DIV:\n-\t\tcase OP_MOD:\n-\t\tcase OP_LSHIFT:\n-\t\tcase OP_RSHIFT:\n-\t\tcase OP_BOOLAND:\n-\t\tcase OP_BOOLOR:\n-\t\tcase OP_NUMEQUAL:\n-\t\tcase OP_NUMEQUALVERIFY:\n-\t\tcase OP_NUMNOTEQUAL:\n-\t\tcase OP_LESSTHAN:\n-\t\tcase OP_GREATERTHAN:\n-\t\tcase OP_LESSTHANOREQUAL:\n-\t\tcase OP_GREATERTHANOREQUAL:\n-\t\tcase OP_MIN:\n-\t\tcase OP_MAX:\n-\t\t{\n-\t\t    // (x1 x2 -- out)\n-\t\t    if (stack.size() < 2)\n-\t\t\treturn false;\n-\t\t    CBigNum bn1 = CastToBigNum(stacktop(-2));\n-\t\t    CBigNum bn2 = CastToBigNum(stacktop(-1));\n-\t\t    CBigNum bn;\n-\t\t    switch (opcode)\n-\t\t    {\n-\t\t    case OP_ADD:\n-\t\t\tbn = bn1 + bn2;\n-\t\t\tbreak;\n-\n-\t\t    case OP_SUB:\n-\t\t\tbn = bn1 - bn2;\n-\t\t\tbreak;\n-\n-\t\t    case OP_MUL:\n-\t\t\tif (!BN_mul(&bn, &bn1, &bn2, pctx))\n-\t\t\t    return false;\n-\t\t\tbreak;\n-\n-\t\t    case OP_DIV:\n-\t\t\tif (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n-\t\t\t    return false;\n-\t\t\tbreak;\n-\n-\t\t    case OP_MOD:\n-\t\t\tif (!BN_mod(&bn, &bn1, &bn2, pctx))\n-\t\t\t    return false;\n-\t\t\tbreak;\n-\n-\t\t    case OP_LSHIFT:\n-\t\t\tif (bn2 < bnZero || bn2 > CBigNum(2048))\n-\t\t\t    return false;\n-\t\t\tbn = bn1 << bn2.getulong();\n-\t\t\tbreak;\n-\n-\t\t    case OP_RSHIFT:\n-\t\t\tif (bn2 < bnZero || bn2 > CBigNum(2048))\n-\t\t\t    return false;\n-\t\t\tbn = bn1 >> bn2.getulong();\n-\t\t\tbreak;\n-\n-\t\t    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n-\t\t    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n-\t\t    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n-\t\t    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n-\t\t    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n-\t\t    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n-\t\t    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n-\t\t    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n-\t\t    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n-\t\t    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n-\t\t    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n-\t\t    }\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t    stack.push_back(bn.getvch());\n-\n-\t\t    if (opcode == OP_NUMEQUALVERIFY)\n-\t\t    {\n-\t\t\tif (CastToBool(stacktop(-1)))\n-\t\t\t    popstack(stack);\n-\t\t\telse\n-\t\t\t    return false;\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_WITHIN:\n+\t    while (pc < pend)\n \t\t{\n-\t\t    // (x min max -- out)\n-\t\t    if (stack.size() < 3)\n-\t\t\treturn false;\n-\t\t    CBigNum bn1 = CastToBigNum(stacktop(-3));\n-\t\t    CBigNum bn2 = CastToBigNum(stacktop(-2));\n-\t\t    CBigNum bn3 = CastToBigNum(stacktop(-1));\n-\t\t    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t    stack.push_back(fValue ? vchTrue : vchFalse);\n-\t\t}\n-\t\tbreak;\n+\t\t    bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n \n-\n-\t\t//\n-\t\t// Crypto\n-\t\t//\n-\t\tcase OP_RIPEMD160:\n-\t\tcase OP_SHA1:\n-\t\tcase OP_SHA256:\n-\t\tcase OP_HASH160:\n-\t\tcase OP_HASH256:\n-\t\t{\n-\t\t    // (in -- hash)\n-\t\t    if (stack.size() < 1)\n+\t\t    //\n+\t\t    // Read instruction\n+\t\t    //\n+\t\t    if (!script.GetOp(pc, opcode, vchPushValue))\n \t\t\treturn false;\n-\t\t    valtype& vch = stacktop(-1);\n-\t\t    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n-\t\t    if (opcode == OP_RIPEMD160)\n-\t\t\tRIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n-\t\t    else if (opcode == OP_SHA1)\n-\t\t\tSHA1(&vch[0], vch.size(), &vchHash[0]);\n-\t\t    else if (opcode == OP_SHA256)\n-\t\t\tSHA256(&vch[0], vch.size(), &vchHash[0]);\n-\t\t    else if (opcode == OP_HASH160)\n-\t\t    {\n-\t\t\tuint160 hash160 = Hash160(vch);\n-\t\t\tmemcpy(&vchHash[0], &hash160, sizeof(hash160));\n-\t\t    }\n-\t\t    else if (opcode == OP_HASH256)\n-\t\t    {\n-\t\t\tuint256 hash = Hash(vch.begin(), vch.end());\n-\t\t\tmemcpy(&vchHash[0], &hash, sizeof(hash));\n-\t\t    }\n-\t\t    popstack(stack);\n-\t\t    stack.push_back(vchHash);\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_CODESEPARATOR:\n-\t\t{\n-\t\t    // Hash starts after the code separator\n-\t\t    pbegincodehash = pc;\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_CHECKSIG:\n-\t\tcase OP_CHECKSIGVERIFY:\n-\t\t{\n-\t\t    // (sig pubkey -- bool)\n-\t\t    if (stack.size() < 2)\n+\t\t    if (vchPushValue.size() > 520)\n \t\t\treturn false;\n-\n-\t\t    valtype& vchSig    = stacktop(-2);\n-\t\t    valtype& vchPubKey = stacktop(-1);\n-\n-\t\t    ////// debug print\n-\t\t    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n-\t\t    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n-\n-\t\t    // Subset of script starting at the most recent codeseparator\n-\t\t    CScript scriptCode(pbegincodehash, pend);\n-\n-\t\t    // Drop the signature, since there's no way for a signature to sign itself\n-\t\t    scriptCode.FindAndDelete(CScript(vchSig));\n-\n-\t\t    bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n-\n-\t\t    popstack(stack);\n-\t\t    popstack(stack);\n-\t\t    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-\t\t    if (opcode == OP_CHECKSIGVERIFY)\n-\t\t    {\n-\t\t\tif (fSuccess)\n-\t\t\t    popstack(stack);\n-\t\t\telse\n-\t\t\t    return false;\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\t\tcase OP_CHECKMULTISIG:\n-\t\tcase OP_CHECKMULTISIGVERIFY:\n-\t\t{\n-\t\t    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n-\n-\t\t    int i = 1;\n-\t\t    if (stack.size() < i)\n+\t\t    if (opcode > OP_16 && ++nOpCount > 201)\n \t\t\treturn false;\n \n-\t\t    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n-\t\t    if (nKeysCount < 0 || nKeysCount > 20)\n-\t\t\treturn false;\n-\t\t    nOpCount += nKeysCount;\n-\t\t    if (nOpCount > 201)\n-\t\t\treturn false;\n-\t\t    int ikey = ++i;\n-\t\t    i += nKeysCount;\n-\t\t    if (stack.size() < i)\n+\t\t    if (opcode == OP_CAT ||\n+\t\t\topcode == OP_SUBSTR ||\n+\t\t\topcode == OP_LEFT ||\n+\t\t\topcode == OP_RIGHT ||\n+\t\t\topcode == OP_INVERT ||\n+\t\t\topcode == OP_AND ||\n+\t\t\topcode == OP_OR ||\n+\t\t\topcode == OP_XOR ||\n+\t\t\topcode == OP_2MUL ||\n+\t\t\topcode == OP_2DIV ||\n+\t\t\topcode == OP_MUL ||\n+\t\t\topcode == OP_DIV ||\n+\t\t\topcode == OP_MOD ||\n+\t\t\topcode == OP_LSHIFT ||\n+\t\t\topcode == OP_RSHIFT)\n \t\t\treturn false;\n \n-\t\t    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n-\t\t    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n-\t\t\treturn false;\n-\t\t    int isig = ++i;\n-\t\t    i += nSigsCount;\n-\t\t    if (stack.size() < i)\n+\t\t    if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n+\t\t\tstack.push_back(vchPushValue);\n+\t\t    else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n+\t\t\tswitch (opcode)\n+\t\t\t    {\n+\t\t\t\t//\n+\t\t\t\t// Push value\n+\t\t\t\t//\n+\t\t\t    case OP_1NEGATE:\n+\t\t\t    case OP_1:\n+\t\t\t    case OP_2:\n+\t\t\t    case OP_3:\n+\t\t\t    case OP_4:\n+\t\t\t    case OP_5:\n+\t\t\t    case OP_6:\n+\t\t\t    case OP_7:\n+\t\t\t    case OP_8:\n+\t\t\t    case OP_9:\n+\t\t\t    case OP_10:\n+\t\t\t    case OP_11:\n+\t\t\t    case OP_12:\n+\t\t\t    case OP_13:\n+\t\t\t    case OP_14:\n+\t\t\t    case OP_15:\n+\t\t\t    case OP_16:\n+\t\t\t\t{\n+\t\t\t\t    // ( -- value)\n+\t\t\t\t    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n+\t\t\t\t    stack.push_back(bn.getvch());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\n+\t\t\t\t//\n+\t\t\t\t// Control\n+\t\t\t\t//\n+\t\t\t    case OP_NOP:\n+\t\t\t    case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n+\t\t\t    case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_IF:\n+\t\t\t    case OP_NOTIF:\n+\t\t\t\t{\n+\t\t\t\t    // <expression> if [statements] [else [statements]] endif\n+\t\t\t\t    bool fValue = false;\n+\t\t\t\t    if (fExec)\n+\t\t\t\t\t{\n+\t\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t    valtype& vch = stacktop(-1);\n+\t\t\t\t\t    fValue = CastToBool(vch);\n+\t\t\t\t\t    if (opcode == OP_NOTIF)\n+\t\t\t\t\t\tfValue = !fValue;\n+\t\t\t\t\t    popstack(stack);\n+\t\t\t\t\t}\n+\t\t\t\t    vfExec.push_back(fValue);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_ELSE:\n+\t\t\t\t{\n+\t\t\t\t    if (vfExec.empty())\n+\t\t\t\t\treturn false;\n+\t\t\t\t    vfExec.back() = !vfExec.back();\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_ENDIF:\n+\t\t\t\t{\n+\t\t\t\t    if (vfExec.empty())\n+\t\t\t\t\treturn false;\n+\t\t\t\t    vfExec.pop_back();\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_VERIFY:\n+\t\t\t\t{\n+\t\t\t\t    // (true -- ) or\n+\t\t\t\t    // (false -- false) and return\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    bool fValue = CastToBool(stacktop(-1));\n+\t\t\t\t    if (fValue)\n+\t\t\t\t\tpopstack(stack);\n+\t\t\t\t    else\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_RETURN:\n+\t\t\t\t{\n+\t\t\t\t    return false;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\n+\t\t\t\t//\n+\t\t\t\t// Stack ops\n+\t\t\t\t//\n+\t\t\t    case OP_TOALTSTACK:\n+\t\t\t\t{\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    altstack.push_back(stacktop(-1));\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_FROMALTSTACK:\n+\t\t\t\t{\n+\t\t\t\t    if (altstack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    stack.push_back(altstacktop(-1));\n+\t\t\t\t    popstack(altstack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_2DROP:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- )\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_2DUP:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- x1 x2 x1 x2)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch1 = stacktop(-2);\n+\t\t\t\t    valtype vch2 = stacktop(-1);\n+\t\t\t\t    stack.push_back(vch1);\n+\t\t\t\t    stack.push_back(vch2);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_3DUP:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n+\t\t\t\t    if (stack.size() < 3)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch1 = stacktop(-3);\n+\t\t\t\t    valtype vch2 = stacktop(-2);\n+\t\t\t\t    valtype vch3 = stacktop(-1);\n+\t\t\t\t    stack.push_back(vch1);\n+\t\t\t\t    stack.push_back(vch2);\n+\t\t\t\t    stack.push_back(vch3);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_2OVER:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n+\t\t\t\t    if (stack.size() < 4)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch1 = stacktop(-4);\n+\t\t\t\t    valtype vch2 = stacktop(-3);\n+\t\t\t\t    stack.push_back(vch1);\n+\t\t\t\t    stack.push_back(vch2);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_2ROT:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n+\t\t\t\t    if (stack.size() < 6)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch1 = stacktop(-6);\n+\t\t\t\t    valtype vch2 = stacktop(-5);\n+\t\t\t\t    stack.erase(stack.end()-6, stack.end()-4);\n+\t\t\t\t    stack.push_back(vch1);\n+\t\t\t\t    stack.push_back(vch2);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_2SWAP:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n+\t\t\t\t    if (stack.size() < 4)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    swap(stacktop(-4), stacktop(-2));\n+\t\t\t\t    swap(stacktop(-3), stacktop(-1));\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_IFDUP:\n+\t\t\t\t{\n+\t\t\t\t    // (x - 0 | x x)\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch = stacktop(-1);\n+\t\t\t\t    if (CastToBool(vch))\n+\t\t\t\t\tstack.push_back(vch);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_DEPTH:\n+\t\t\t\t{\n+\t\t\t\t    // -- stacksize\n+\t\t\t\t    CBigNum bn(stack.size());\n+\t\t\t\t    stack.push_back(bn.getvch());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_DROP:\n+\t\t\t\t{\n+\t\t\t\t    // (x -- )\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_DUP:\n+\t\t\t\t{\n+\t\t\t\t    // (x -- x x)\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch = stacktop(-1);\n+\t\t\t\t    stack.push_back(vch);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_NIP:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- x2)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    stack.erase(stack.end() - 2);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_OVER:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- x1 x2 x1)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch = stacktop(-2);\n+\t\t\t\t    stack.push_back(vch);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_PICK:\n+\t\t\t    case OP_ROLL:\n+\t\t\t\t{\n+\t\t\t\t    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n+\t\t\t\t    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    int n = CastToBigNum(stacktop(-1)).getint();\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    if (n < 0 || n >= stack.size())\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch = stacktop(-n-1);\n+\t\t\t\t    if (opcode == OP_ROLL)\n+\t\t\t\t\tstack.erase(stack.end()-n-1);\n+\t\t\t\t    stack.push_back(vch);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_ROT:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 x3 -- x2 x3 x1)\n+\t\t\t\t    //  x2 x1 x3  after first swap\n+\t\t\t\t    //  x2 x3 x1  after second swap\n+\t\t\t\t    if (stack.size() < 3)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    swap(stacktop(-3), stacktop(-2));\n+\t\t\t\t    swap(stacktop(-2), stacktop(-1));\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_SWAP:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- x2 x1)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    swap(stacktop(-2), stacktop(-1));\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_TUCK:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- x2 x1 x2)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype vch = stacktop(-1);\n+\t\t\t\t    stack.insert(stack.end()-2, vch);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\n+\t\t\t\t//\n+\t\t\t\t// Splice ops\n+\t\t\t\t//\n+\t\t\t    case OP_CAT:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- out)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch1 = stacktop(-2);\n+\t\t\t\t    valtype& vch2 = stacktop(-1);\n+\t\t\t\t    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    if (stacktop(-1).size() > 520)\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_SUBSTR:\n+\t\t\t\t{\n+\t\t\t\t    // (in begin size -- out)\n+\t\t\t\t    if (stack.size() < 3)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch = stacktop(-3);\n+\t\t\t\t    int nBegin = CastToBigNum(stacktop(-2)).getint();\n+\t\t\t\t    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n+\t\t\t\t    if (nBegin < 0 || nEnd < nBegin)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    if (nBegin > vch.size())\n+\t\t\t\t\tnBegin = vch.size();\n+\t\t\t\t    if (nEnd > vch.size())\n+\t\t\t\t\tnEnd = vch.size();\n+\t\t\t\t    vch.erase(vch.begin() + nEnd, vch.end());\n+\t\t\t\t    vch.erase(vch.begin(), vch.begin() + nBegin);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_LEFT:\n+\t\t\t    case OP_RIGHT:\n+\t\t\t\t{\n+\t\t\t\t    // (in size -- out)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch = stacktop(-2);\n+\t\t\t\t    int nSize = CastToBigNum(stacktop(-1)).getint();\n+\t\t\t\t    if (nSize < 0)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    if (nSize > vch.size())\n+\t\t\t\t\tnSize = vch.size();\n+\t\t\t\t    if (opcode == OP_LEFT)\n+\t\t\t\t\tvch.erase(vch.begin() + nSize, vch.end());\n+\t\t\t\t    else\n+\t\t\t\t\tvch.erase(vch.begin(), vch.end() - nSize);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_SIZE:\n+\t\t\t\t{\n+\t\t\t\t    // (in -- in size)\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    CBigNum bn(stacktop(-1).size());\n+\t\t\t\t    stack.push_back(bn.getvch());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\n+\t\t\t\t//\n+\t\t\t\t// Bitwise logic\n+\t\t\t\t//\n+\t\t\t    case OP_INVERT:\n+\t\t\t\t{\n+\t\t\t\t    // (in - out)\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch = stacktop(-1);\n+\t\t\t\t    for (int i = 0; i < vch.size(); i++)\n+\t\t\t\t\tvch[i] = ~vch[i];\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_AND:\n+\t\t\t    case OP_OR:\n+\t\t\t    case OP_XOR:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 - out)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch1 = stacktop(-2);\n+\t\t\t\t    valtype& vch2 = stacktop(-1);\n+\t\t\t\t    MakeSameSize(vch1, vch2);\n+\t\t\t\t    if (opcode == OP_AND)\n+\t\t\t\t\t{\n+\t\t\t\t\t    for (int i = 0; i < vch1.size(); i++)\n+\t\t\t\t\t\tvch1[i] &= vch2[i];\n+\t\t\t\t\t}\n+\t\t\t\t    else if (opcode == OP_OR)\n+\t\t\t\t\t{\n+\t\t\t\t\t    for (int i = 0; i < vch1.size(); i++)\n+\t\t\t\t\t\tvch1[i] |= vch2[i];\n+\t\t\t\t\t}\n+\t\t\t\t    else if (opcode == OP_XOR)\n+\t\t\t\t\t{\n+\t\t\t\t\t    for (int i = 0; i < vch1.size(); i++)\n+\t\t\t\t\t\tvch1[i] ^= vch2[i];\n+\t\t\t\t\t}\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_EQUAL:\n+\t\t\t    case OP_EQUALVERIFY:\n+\t\t\t\t//case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 - bool)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch1 = stacktop(-2);\n+\t\t\t\t    valtype& vch2 = stacktop(-1);\n+\t\t\t\t    bool fEqual = (vch1 == vch2);\n+\t\t\t\t    // OP_NOTEQUAL is disabled because it would be too easy to say\n+\t\t\t\t    // something like n != 1 and have some wiseguy pass in 1 with extra\n+\t\t\t\t    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n+\t\t\t\t    //if (opcode == OP_NOTEQUAL)\n+\t\t\t\t    //    fEqual = !fEqual;\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    stack.push_back(fEqual ? vchTrue : vchFalse);\n+\t\t\t\t    if (opcode == OP_EQUALVERIFY)\n+\t\t\t\t\t{\n+\t\t\t\t\t    if (fEqual)\n+\t\t\t\t\t\tpopstack(stack);\n+\t\t\t\t\t    else\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\n+\t\t\t\t//\n+\t\t\t\t// Numeric\n+\t\t\t\t//\n+\t\t\t    case OP_1ADD:\n+\t\t\t    case OP_1SUB:\n+\t\t\t    case OP_2MUL:\n+\t\t\t    case OP_2DIV:\n+\t\t\t    case OP_NEGATE:\n+\t\t\t    case OP_ABS:\n+\t\t\t    case OP_NOT:\n+\t\t\t    case OP_0NOTEQUAL:\n+\t\t\t\t{\n+\t\t\t\t    // (in -- out)\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    CBigNum bn = CastToBigNum(stacktop(-1));\n+\t\t\t\t    switch (opcode)\n+\t\t\t\t\t{\n+\t\t\t\t\tcase OP_1ADD:       bn += bnOne; break;\n+\t\t\t\t\tcase OP_1SUB:       bn -= bnOne; break;\n+\t\t\t\t\tcase OP_2MUL:       bn <<= 1; break;\n+\t\t\t\t\tcase OP_2DIV:       bn >>= 1; break;\n+\t\t\t\t\tcase OP_NEGATE:     bn = -bn; break;\n+\t\t\t\t\tcase OP_ABS:        if (bn < bnZero) bn = -bn; break;\n+\t\t\t\t\tcase OP_NOT:        bn = (bn == bnZero); break;\n+\t\t\t\t\tcase OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n+\t\t\t\t\t}\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    stack.push_back(bn.getvch());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_ADD:\n+\t\t\t    case OP_SUB:\n+\t\t\t    case OP_MUL:\n+\t\t\t    case OP_DIV:\n+\t\t\t    case OP_MOD:\n+\t\t\t    case OP_LSHIFT:\n+\t\t\t    case OP_RSHIFT:\n+\t\t\t    case OP_BOOLAND:\n+\t\t\t    case OP_BOOLOR:\n+\t\t\t    case OP_NUMEQUAL:\n+\t\t\t    case OP_NUMEQUALVERIFY:\n+\t\t\t    case OP_NUMNOTEQUAL:\n+\t\t\t    case OP_LESSTHAN:\n+\t\t\t    case OP_GREATERTHAN:\n+\t\t\t    case OP_LESSTHANOREQUAL:\n+\t\t\t    case OP_GREATERTHANOREQUAL:\n+\t\t\t    case OP_MIN:\n+\t\t\t    case OP_MAX:\n+\t\t\t\t{\n+\t\t\t\t    // (x1 x2 -- out)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    CBigNum bn1 = CastToBigNum(stacktop(-2));\n+\t\t\t\t    CBigNum bn2 = CastToBigNum(stacktop(-1));\n+\t\t\t\t    CBigNum bn;\n+\t\t\t\t    switch (opcode)\n+\t\t\t\t\t{\n+\t\t\t\t\tcase OP_ADD:\n+\t\t\t\t\t    bn = bn1 + bn2;\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_SUB:\n+\t\t\t\t\t    bn = bn1 - bn2;\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_MUL:\n+\t\t\t\t\t    if (!BN_mul(&bn, &bn1, &bn2, pctx))\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_DIV:\n+\t\t\t\t\t    if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_MOD:\n+\t\t\t\t\t    if (!BN_mod(&bn, &bn1, &bn2, pctx))\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_LSHIFT:\n+\t\t\t\t\t    if (bn2 < bnZero || bn2 > CBigNum(2048))\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t    bn = bn1 << bn2.getulong();\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_RSHIFT:\n+\t\t\t\t\t    if (bn2 < bnZero || bn2 > CBigNum(2048))\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t    bn = bn1 >> bn2.getulong();\n+\t\t\t\t\t    break;\n+\n+\t\t\t\t\tcase OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n+\t\t\t\t\tcase OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n+\t\t\t\t\tcase OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n+\t\t\t\t\tcase OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n+\t\t\t\t\tcase OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n+\t\t\t\t\tcase OP_LESSTHAN:            bn = (bn1 < bn2); break;\n+\t\t\t\t\tcase OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n+\t\t\t\t\tcase OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n+\t\t\t\t\tcase OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n+\t\t\t\t\tcase OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n+\t\t\t\t\tcase OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n+\t\t\t\t\t}\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    stack.push_back(bn.getvch());\n+\n+\t\t\t\t    if (opcode == OP_NUMEQUALVERIFY)\n+\t\t\t\t\t{\n+\t\t\t\t\t    if (CastToBool(stacktop(-1)))\n+\t\t\t\t\t\tpopstack(stack);\n+\t\t\t\t\t    else\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_WITHIN:\n+\t\t\t\t{\n+\t\t\t\t    // (x min max -- out)\n+\t\t\t\t    if (stack.size() < 3)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    CBigNum bn1 = CastToBigNum(stacktop(-3));\n+\t\t\t\t    CBigNum bn2 = CastToBigNum(stacktop(-2));\n+\t\t\t\t    CBigNum bn3 = CastToBigNum(stacktop(-1));\n+\t\t\t\t    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    stack.push_back(fValue ? vchTrue : vchFalse);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\n+\t\t\t\t//\n+\t\t\t\t// Crypto\n+\t\t\t\t//\n+\t\t\t    case OP_RIPEMD160:\n+\t\t\t    case OP_SHA1:\n+\t\t\t    case OP_SHA256:\n+\t\t\t    case OP_HASH160:\n+\t\t\t    case OP_HASH256:\n+\t\t\t\t{\n+\t\t\t\t    // (in -- hash)\n+\t\t\t\t    if (stack.size() < 1)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    valtype& vch = stacktop(-1);\n+\t\t\t\t    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n+\t\t\t\t    if (opcode == OP_RIPEMD160)\n+\t\t\t\t\tRIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n+\t\t\t\t    else if (opcode == OP_SHA1)\n+\t\t\t\t\tSHA1(&vch[0], vch.size(), &vchHash[0]);\n+\t\t\t\t    else if (opcode == OP_SHA256)\n+\t\t\t\t\tSHA256(&vch[0], vch.size(), &vchHash[0]);\n+\t\t\t\t    else if (opcode == OP_HASH160)\n+\t\t\t\t\t{\n+\t\t\t\t\t    uint160 hash160 = Hash160(vch);\n+\t\t\t\t\t    memcpy(&vchHash[0], &hash160, sizeof(hash160));\n+\t\t\t\t\t}\n+\t\t\t\t    else if (opcode == OP_HASH256)\n+\t\t\t\t\t{\n+\t\t\t\t\t    uint256 hash = Hash(vch.begin(), vch.end());\n+\t\t\t\t\t    memcpy(&vchHash[0], &hash, sizeof(hash));\n+\t\t\t\t\t}\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    stack.push_back(vchHash);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_CODESEPARATOR:\n+\t\t\t\t{\n+\t\t\t\t    // Hash starts after the code separator\n+\t\t\t\t    pbegincodehash = pc;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_CHECKSIG:\n+\t\t\t    case OP_CHECKSIGVERIFY:\n+\t\t\t\t{\n+\t\t\t\t    // (sig pubkey -- bool)\n+\t\t\t\t    if (stack.size() < 2)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t    valtype& vchSig    = stacktop(-2);\n+\t\t\t\t    valtype& vchPubKey = stacktop(-1);\n+\n+\t\t\t\t    ////// debug print\n+\t\t\t\t    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n+\t\t\t\t    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n+\n+\t\t\t\t    // Subset of script starting at the most recent codeseparator\n+\t\t\t\t    CScript scriptCode(pbegincodehash, pend);\n+\n+\t\t\t\t    // Drop the signature, since there's no way for a signature to sign itself\n+\t\t\t\t    scriptCode.FindAndDelete(CScript(vchSig));\n+\n+\t\t\t\t    bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    popstack(stack);\n+\t\t\t\t    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+\t\t\t\t    if (opcode == OP_CHECKSIGVERIFY)\n+\t\t\t\t\t{\n+\t\t\t\t\t    if (fSuccess)\n+\t\t\t\t\t\tpopstack(stack);\n+\t\t\t\t\t    else\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    case OP_CHECKMULTISIG:\n+\t\t\t    case OP_CHECKMULTISIGVERIFY:\n+\t\t\t\t{\n+\t\t\t\t    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n+\n+\t\t\t\t    int i = 1;\n+\t\t\t\t    if (stack.size() < i)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n+\t\t\t\t    if (nKeysCount < 0 || nKeysCount > 20)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    nOpCount += nKeysCount;\n+\t\t\t\t    if (nOpCount > 201)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    int ikey = ++i;\n+\t\t\t\t    i += nKeysCount;\n+\t\t\t\t    if (stack.size() < i)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n+\t\t\t\t    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n+\t\t\t\t\treturn false;\n+\t\t\t\t    int isig = ++i;\n+\t\t\t\t    i += nSigsCount;\n+\t\t\t\t    if (stack.size() < i)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t    // Subset of script starting at the most recent codeseparator\n+\t\t\t\t    CScript scriptCode(pbegincodehash, pend);\n+\n+\t\t\t\t    // Drop the signatures, since there's no way for a signature to sign itself\n+\t\t\t\t    for (int k = 0; k < nSigsCount; k++)\n+\t\t\t\t\t{\n+\t\t\t\t\t    valtype& vchSig = stacktop(-isig-k);\n+\t\t\t\t\t    scriptCode.FindAndDelete(CScript(vchSig));\n+\t\t\t\t\t}\n+\n+\t\t\t\t    bool fSuccess = true;\n+\t\t\t\t    while (fSuccess && nSigsCount > 0)\n+\t\t\t\t\t{\n+\t\t\t\t\t    valtype& vchSig    = stacktop(-isig);\n+\t\t\t\t\t    valtype& vchPubKey = stacktop(-ikey);\n+\n+\t\t\t\t\t    // Check signature\n+\t\t\t\t\t    if (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t    isig++;\n+\t\t\t\t\t\t    nSigsCount--;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t    ikey++;\n+\t\t\t\t\t    nKeysCount--;\n+\n+\t\t\t\t\t    // If there are more signatures left than keys left,\n+\t\t\t\t\t    // then too many signatures have failed\n+\t\t\t\t\t    if (nSigsCount > nKeysCount)\n+\t\t\t\t\t\tfSuccess = false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t    while (i-- > 0)\n+\t\t\t\t\tpopstack(stack);\n+\t\t\t\t    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+\n+\t\t\t\t    if (opcode == OP_CHECKMULTISIGVERIFY)\n+\t\t\t\t\t{\n+\t\t\t\t\t    if (fSuccess)\n+\t\t\t\t\t\tpopstack(stack);\n+\t\t\t\t\t    else\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t    default:\n+\t\t\t\treturn false;\n+\t\t\t    }\n+\n+\t\t    // Size limits\n+\t\t    if (stack.size() + altstack.size() > 1000)\n \t\t\treturn false;\n-\n-\t\t    // Subset of script starting at the most recent codeseparator\n-\t\t    CScript scriptCode(pbegincodehash, pend);\n-\n-\t\t    // Drop the signatures, since there's no way for a signature to sign itself\n-\t\t    for (int k = 0; k < nSigsCount; k++)\n-\t\t    {\n-\t\t\tvaltype& vchSig = stacktop(-isig-k);\n-\t\t\tscriptCode.FindAndDelete(CScript(vchSig));\n-\t\t    }\n-\n-\t\t    bool fSuccess = true;\n-\t\t    while (fSuccess && nSigsCount > 0)\n-\t\t    {\n-\t\t\tvaltype& vchSig    = stacktop(-isig);\n-\t\t\tvaltype& vchPubKey = stacktop(-ikey);\n-\n-\t\t\t// Check signature\n-\t\t\tif (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n-\t\t\t{\n-\t\t\t    isig++;\n-\t\t\t    nSigsCount--;\n-\t\t\t}\n-\t\t\tikey++;\n-\t\t\tnKeysCount--;\n-\n-\t\t\t// If there are more signatures left than keys left,\n-\t\t\t// then too many signatures have failed\n-\t\t\tif (nSigsCount > nKeysCount)\n-\t\t\t    fSuccess = false;\n-\t\t    }\n-\n-\t\t    while (i-- > 0)\n-\t\t\tpopstack(stack);\n-\t\t    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-\n-\t\t    if (opcode == OP_CHECKMULTISIGVERIFY)\n-\t\t    {\n-\t\t\tif (fSuccess)\n-\t\t\t    popstack(stack);\n-\t\t\telse\n-\t\t\t    return false;\n-\t\t    }\n \t\t}\n-\t\tbreak;\n-\n-\t\tdefault:\n-\t\t    return false;\n-\t    }\n-\n-\t    // Size limits\n-\t    if (stack.size() + altstack.size() > 1000)\n-\t\treturn false;\n \t}\n-    }\n     catch (...)\n-    {\n-\treturn false;\n-    }\n+\t{\n+\t    return false;\n+\t}\n \n \n     if (!vfExec.empty())\n@@ -871,10 +871,10 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     if (nIn >= txTo.vin.size())\n-    {\n-\tprintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n-\treturn 1;\n-    }\n+\t{\n+\t    printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+\t    return 1;\n+\t}\n     CTransaction txTmp(txTo);\n \n     // In case concatenating two scripts ends up with two codeseparators,\n@@ -888,40 +888,40 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n \n     // Blank out some of the outputs\n     if ((nHashType & 0x1f) == SIGHASH_NONE)\n-    {\n-\t// Wildcard payee\n-\ttxTmp.vout.clear();\n+\t{\n+\t    // Wildcard payee\n+\t    txTmp.vout.clear();\n \n-\t// Let the others update at will\n-\tfor (int i = 0; i < txTmp.vin.size(); i++)\n-\t    if (i != nIn)\n-\t\ttxTmp.vin[i].nSequence = 0;\n-    }\n+\t    // Let the others update at will\n+\t    for (int i = 0; i < txTmp.vin.size(); i++)\n+\t\tif (i != nIn)\n+\t\t    txTmp.vin[i].nSequence = 0;\n+\t}\n     else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n-    {\n-\t// Only lockin the txout payee at same index as txin\n-\tunsigned int nOut = nIn;\n-\tif (nOut >= txTmp.vout.size())\n \t{\n-\t    printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n-\t    return 1;\n+\t    // Only lockin the txout payee at same index as txin\n+\t    unsigned int nOut = nIn;\n+\t    if (nOut >= txTmp.vout.size())\n+\t\t{\n+\t\t    printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n+\t\t    return 1;\n+\t\t}\n+\t    txTmp.vout.resize(nOut+1);\n+\t    for (int i = 0; i < nOut; i++)\n+\t\ttxTmp.vout[i].SetNull();\n+\n+\t    // Let the others update at will\n+\t    for (int i = 0; i < txTmp.vin.size(); i++)\n+\t\tif (i != nIn)\n+\t\t    txTmp.vin[i].nSequence = 0;\n \t}\n-\ttxTmp.vout.resize(nOut+1);\n-\tfor (int i = 0; i < nOut; i++)\n-\t    txTmp.vout[i].SetNull();\n-\n-\t// Let the others update at will\n-\tfor (int i = 0; i < txTmp.vin.size(); i++)\n-\t    if (i != nIn)\n-\t\ttxTmp.vin[i].nSequence = 0;\n-    }\n \n     // Blank out other inputs completely, not recommended for open transactions\n     if (nHashType & SIGHASH_ANYONECANPAY)\n-    {\n-\ttxTmp.vin[0] = txTmp.vin[nIn];\n-\ttxTmp.vin.resize(1);\n-    }\n+\t{\n+\t    txTmp.vin[0] = txTmp.vin[nIn];\n+\t    txTmp.vin.resize(1);\n+\t}\n \n     // Serialize and hash\n     CDataStream ss(SER_GETHASH);\n@@ -964,55 +964,55 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n     // Templates\n     static vector<CScript> vTemplates;\n     if (vTemplates.empty())\n-    {\n-\t// Standard tx, sender provides pubkey, receiver adds signature\n-\tvTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);\n+\t{\n+\t    // Standard tx, sender provides pubkey, receiver adds signature\n+\t    vTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);\n \n-\t// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-\tvTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n-    }\n+\t    // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n+\t    vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n+\t}\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n     foreach(const CScript& script2, vTemplates)\n-    {\n-\tvSolutionRet.clear();\n-\topcodetype opcode1, opcode2;\n-\tvector<unsigned char> vch1, vch2;\n-\n-\t// Compare\n-\tCScript::const_iterator pc1 = script1.begin();\n-\tCScript::const_iterator pc2 = script2.begin();\n-\tloop\n \t{\n-\t    if (pc1 == script1.end() && pc2 == script2.end())\n-\t    {\n-\t\t// Found a match\n-\t\treverse(vSolutionRet.begin(), vSolutionRet.end());\n-\t\treturn true;\n-\t    }\n-\t    if (!script1.GetOp(pc1, opcode1, vch1))\n-\t\tbreak;\n-\t    if (!script2.GetOp(pc2, opcode2, vch2))\n-\t\tbreak;\n-\t    if (opcode2 == OP_PUBKEY)\n-\t    {\n-\t\tif (vch1.size() < 33 || vch1.size() > 120)\n-\t\t    break;\n-\t\tvSolutionRet.push_back(make_pair(opcode2, vch1));\n-\t    }\n-\t    else if (opcode2 == OP_PUBKEYHASH)\n-\t    {\n-\t\tif (vch1.size() != sizeof(uint160))\n-\t\t    break;\n-\t\tvSolutionRet.push_back(make_pair(opcode2, vch1));\n-\t    }\n-\t    else if (opcode1 != opcode2 || vch1 != vch2)\n-\t    {\n-\t\tbreak;\n-\t    }\n+\t    vSolutionRet.clear();\n+\t    opcodetype opcode1, opcode2;\n+\t    vector<unsigned char> vch1, vch2;\n+\n+\t    // Compare\n+\t    CScript::const_iterator pc1 = script1.begin();\n+\t    CScript::const_iterator pc2 = script2.begin();\n+\t    loop\n+\t\t{\n+\t\t    if (pc1 == script1.end() && pc2 == script2.end())\n+\t\t\t{\n+\t\t\t    // Found a match\n+\t\t\t    reverse(vSolutionRet.begin(), vSolutionRet.end());\n+\t\t\t    return true;\n+\t\t\t}\n+\t\t    if (!script1.GetOp(pc1, opcode1, vch1))\n+\t\t\tbreak;\n+\t\t    if (!script2.GetOp(pc2, opcode2, vch2))\n+\t\t\tbreak;\n+\t\t    if (opcode2 == OP_PUBKEY)\n+\t\t\t{\n+\t\t\t    if (vch1.size() < 33 || vch1.size() > 120)\n+\t\t\t\tbreak;\n+\t\t\t    vSolutionRet.push_back(make_pair(opcode2, vch1));\n+\t\t\t}\n+\t\t    else if (opcode2 == OP_PUBKEYHASH)\n+\t\t\t{\n+\t\t\t    if (vch1.size() != sizeof(uint160))\n+\t\t\t\tbreak;\n+\t\t\t    vSolutionRet.push_back(make_pair(opcode2, vch1));\n+\t\t\t}\n+\t\t    else if (opcode1 != opcode2 || vch1 != vch2)\n+\t\t\t{\n+\t\t\t    break;\n+\t\t\t}\n+\t\t}\n \t}\n-    }\n \n     vSolutionRet.clear();\n     return false;\n@@ -1031,45 +1031,45 @@ bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& s\n     CRITICAL_BLOCK(cs_mapKeys)\n     {\n \tforeach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n-\t{\n-\t    if (item.first == OP_PUBKEY)\n-\t    {\n-\t\t// Sign\n-\t\tconst valtype& vchPubKey = item.second;\n-\t\tif (!mapKeys.count(vchPubKey))\n-\t\t    return false;\n-\t\tif (hash != 0)\n-\t\t{\n-\t\t    vector<unsigned char> vchSig;\n-\t\t    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n-\t\t\treturn false;\n-\t\t    vchSig.push_back((unsigned char)nHashType);\n-\t\t    scriptSigRet << vchSig;\n-\t\t}\n-\t    }\n-\t    else if (item.first == OP_PUBKEYHASH)\n \t    {\n-\t\t// Sign and give pubkey\n-\t\tmap<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n-\t\tif (mi == mapPubKeys.end())\n-\t\t    return false;\n-\t\tconst vector<unsigned char>& vchPubKey = (*mi).second;\n-\t\tif (!mapKeys.count(vchPubKey))\n-\t\t    return false;\n-\t\tif (hash != 0)\n-\t\t{\n-\t\t    vector<unsigned char> vchSig;\n-\t\t    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+\t\tif (item.first == OP_PUBKEY)\n+\t\t    {\n+\t\t\t// Sign\n+\t\t\tconst valtype& vchPubKey = item.second;\n+\t\t\tif (!mapKeys.count(vchPubKey))\n+\t\t\t    return false;\n+\t\t\tif (hash != 0)\n+\t\t\t    {\n+\t\t\t\tvector<unsigned char> vchSig;\n+\t\t\t\tif (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+\t\t\t\t    return false;\n+\t\t\t\tvchSig.push_back((unsigned char)nHashType);\n+\t\t\t\tscriptSigRet << vchSig;\n+\t\t\t    }\n+\t\t    }\n+\t\telse if (item.first == OP_PUBKEYHASH)\n+\t\t    {\n+\t\t\t// Sign and give pubkey\n+\t\t\tmap<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n+\t\t\tif (mi == mapPubKeys.end())\n+\t\t\t    return false;\n+\t\t\tconst vector<unsigned char>& vchPubKey = (*mi).second;\n+\t\t\tif (!mapKeys.count(vchPubKey))\n+\t\t\t    return false;\n+\t\t\tif (hash != 0)\n+\t\t\t    {\n+\t\t\t\tvector<unsigned char> vchSig;\n+\t\t\t\tif (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+\t\t\t\t    return false;\n+\t\t\t\tvchSig.push_back((unsigned char)nHashType);\n+\t\t\t\tscriptSigRet << vchSig << vchPubKey;\n+\t\t\t    }\n+\t\t    }\n+\t\telse\n+\t\t    {\n \t\t\treturn false;\n-\t\t    vchSig.push_back((unsigned char)nHashType);\n-\t\t    scriptSigRet << vchSig << vchPubKey;\n-\t\t}\n-\t    }\n-\t    else\n-\t    {\n-\t\treturn false;\n+\t\t    }\n \t    }\n-\t}\n     }\n \n     return true;\n@@ -1101,25 +1101,25 @@ bool ExtractPubKey(const CScript& scriptPubKey, bool fMineOnly, vector<unsigned\n     CRITICAL_BLOCK(cs_mapKeys)\n     {\n \tforeach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n-\t{\n-\t    valtype vchPubKey;\n-\t    if (item.first == OP_PUBKEY)\n-\t    {\n-\t\tvchPubKey = item.second;\n-\t    }\n-\t    else if (item.first == OP_PUBKEYHASH)\n-\t    {\n-\t\tmap<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n-\t\tif (mi == mapPubKeys.end())\n-\t\t    continue;\n-\t\tvchPubKey = (*mi).second;\n-\t    }\n-\t    if (!fMineOnly || mapKeys.count(vchPubKey))\n \t    {\n-\t\tvchPubKeyRet = vchPubKey;\n-\t\treturn true;\n+\t\tvaltype vchPubKey;\n+\t\tif (item.first == OP_PUBKEY)\n+\t\t    {\n+\t\t\tvchPubKey = item.second;\n+\t\t    }\n+\t\telse if (item.first == OP_PUBKEYHASH)\n+\t\t    {\n+\t\t\tmap<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n+\t\t\tif (mi == mapPubKeys.end())\n+\t\t\t    continue;\n+\t\t\tvchPubKey = (*mi).second;\n+\t\t    }\n+\t\tif (!fMineOnly || mapKeys.count(vchPubKey))\n+\t\t    {\n+\t\t\tvchPubKeyRet = vchPubKey;\n+\t\t\treturn true;\n+\t\t    }\n \t    }\n-\t}\n     }\n     return false;\n }\n@@ -1134,13 +1134,13 @@ bool ExtractHash160(const CScript& scriptPubKey, uint160& hash160Ret)\n \treturn false;\n \n     foreach(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n-    {\n-\tif (item.first == OP_PUBKEYHASH)\n \t{\n-\t    hash160Ret = uint160(item.second);\n-\t    return true;\n+\t    if (item.first == OP_PUBKEYHASH)\n+\t\t{\n+\t\t    hash160Ret = uint160(item.second);\n+\t\t    return true;\n+\t\t}\n \t}\n-    }\n     return false;\n }\n "
      },
      {
        "sha": "0972dcced862323fba0c5e6e31f77f3cf3578756",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 396,
        "deletions": 391,
        "changes": 787,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,160 +2,163 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef SCRIPT_H\n+#define SCRIPT_H\n+\n class CTransaction;\n \n enum\n-{\n-    SIGHASH_ALL = 1,\n-    SIGHASH_NONE = 2,\n-    SIGHASH_SINGLE = 3,\n-    SIGHASH_ANYONECANPAY = 0x80,\n-};\n+    {\n+\tSIGHASH_ALL = 1,\n+\tSIGHASH_NONE = 2,\n+\tSIGHASH_SINGLE = 3,\n+\tSIGHASH_ANYONECANPAY = 0x80,\n+    };\n \n \n \n enum opcodetype\n-{\n-    // push value\n-    OP_0=0,\n-    OP_FALSE=OP_0,\n-    OP_PUSHDATA1=76,\n-    OP_PUSHDATA2,\n-    OP_PUSHDATA4,\n-    OP_1NEGATE,\n-    OP_RESERVED,\n-    OP_1,\n-    OP_TRUE=OP_1,\n-    OP_2,\n-    OP_3,\n-    OP_4,\n-    OP_5,\n-    OP_6,\n-    OP_7,\n-    OP_8,\n-    OP_9,\n-    OP_10,\n-    OP_11,\n-    OP_12,\n-    OP_13,\n-    OP_14,\n-    OP_15,\n-    OP_16,\n-\n-    // control\n-    OP_NOP,\n-    OP_VER,\n-    OP_IF,\n-    OP_NOTIF,\n-    OP_VERIF,\n-    OP_VERNOTIF,\n-    OP_ELSE,\n-    OP_ENDIF,\n-    OP_VERIFY,\n-    OP_RETURN,\n-\n-    // stack ops\n-    OP_TOALTSTACK,\n-    OP_FROMALTSTACK,\n-    OP_2DROP,\n-    OP_2DUP,\n-    OP_3DUP,\n-    OP_2OVER,\n-    OP_2ROT,\n-    OP_2SWAP,\n-    OP_IFDUP,\n-    OP_DEPTH,\n-    OP_DROP,\n-    OP_DUP,\n-    OP_NIP,\n-    OP_OVER,\n-    OP_PICK,\n-    OP_ROLL,\n-    OP_ROT,\n-    OP_SWAP,\n-    OP_TUCK,\n-\n-    // splice ops\n-    OP_CAT,\n-    OP_SUBSTR,\n-    OP_LEFT,\n-    OP_RIGHT,\n-    OP_SIZE,\n-\n-    // bit logic\n-    OP_INVERT,\n-    OP_AND,\n-    OP_OR,\n-    OP_XOR,\n-    OP_EQUAL,\n-    OP_EQUALVERIFY,\n-    OP_RESERVED1,\n-    OP_RESERVED2,\n-\n-    // numeric\n-    OP_1ADD,\n-    OP_1SUB,\n-    OP_2MUL,\n-    OP_2DIV,\n-    OP_NEGATE,\n-    OP_ABS,\n-    OP_NOT,\n-    OP_0NOTEQUAL,\n-\n-    OP_ADD,\n-    OP_SUB,\n-    OP_MUL,\n-    OP_DIV,\n-    OP_MOD,\n-    OP_LSHIFT,\n-    OP_RSHIFT,\n-\n-    OP_BOOLAND,\n-    OP_BOOLOR,\n-    OP_NUMEQUAL,\n-    OP_NUMEQUALVERIFY,\n-    OP_NUMNOTEQUAL,\n-    OP_LESSTHAN,\n-    OP_GREATERTHAN,\n-    OP_LESSTHANOREQUAL,\n-    OP_GREATERTHANOREQUAL,\n-    OP_MIN,\n-    OP_MAX,\n-\n-    OP_WITHIN,\n-\n-    // crypto\n-    OP_RIPEMD160,\n-    OP_SHA1,\n-    OP_SHA256,\n-    OP_HASH160,\n-    OP_HASH256,\n-    OP_CODESEPARATOR,\n-    OP_CHECKSIG,\n-    OP_CHECKSIGVERIFY,\n-    OP_CHECKMULTISIG,\n-    OP_CHECKMULTISIGVERIFY,\n-\n-    // expansion\n-    OP_NOP1,\n-    OP_NOP2,\n-    OP_NOP3,\n-    OP_NOP4,\n-    OP_NOP5,\n-    OP_NOP6,\n-    OP_NOP7,\n-    OP_NOP8,\n-    OP_NOP9,\n-    OP_NOP10,\n-\n-\n-\n-    // template matching params\n-    OP_PUBKEYHASH = 0xfd,\n-    OP_PUBKEY = 0xfe,\n-\n-    OP_INVALIDOPCODE = 0xff,\n-};\n+    {\n+\t// push value\n+\tOP_0=0,\n+\tOP_FALSE=OP_0,\n+\tOP_PUSHDATA1=76,\n+\tOP_PUSHDATA2,\n+\tOP_PUSHDATA4,\n+\tOP_1NEGATE,\n+\tOP_RESERVED,\n+\tOP_1,\n+\tOP_TRUE=OP_1,\n+\tOP_2,\n+\tOP_3,\n+\tOP_4,\n+\tOP_5,\n+\tOP_6,\n+\tOP_7,\n+\tOP_8,\n+\tOP_9,\n+\tOP_10,\n+\tOP_11,\n+\tOP_12,\n+\tOP_13,\n+\tOP_14,\n+\tOP_15,\n+\tOP_16,\n+\n+\t// control\n+\tOP_NOP,\n+\tOP_VER,\n+\tOP_IF,\n+\tOP_NOTIF,\n+\tOP_VERIF,\n+\tOP_VERNOTIF,\n+\tOP_ELSE,\n+\tOP_ENDIF,\n+\tOP_VERIFY,\n+\tOP_RETURN,\n+\n+\t// stack ops\n+\tOP_TOALTSTACK,\n+\tOP_FROMALTSTACK,\n+\tOP_2DROP,\n+\tOP_2DUP,\n+\tOP_3DUP,\n+\tOP_2OVER,\n+\tOP_2ROT,\n+\tOP_2SWAP,\n+\tOP_IFDUP,\n+\tOP_DEPTH,\n+\tOP_DROP,\n+\tOP_DUP,\n+\tOP_NIP,\n+\tOP_OVER,\n+\tOP_PICK,\n+\tOP_ROLL,\n+\tOP_ROT,\n+\tOP_SWAP,\n+\tOP_TUCK,\n+\n+\t// splice ops\n+\tOP_CAT,\n+\tOP_SUBSTR,\n+\tOP_LEFT,\n+\tOP_RIGHT,\n+\tOP_SIZE,\n+\n+\t// bit logic\n+\tOP_INVERT,\n+\tOP_AND,\n+\tOP_OR,\n+\tOP_XOR,\n+\tOP_EQUAL,\n+\tOP_EQUALVERIFY,\n+\tOP_RESERVED1,\n+\tOP_RESERVED2,\n+\n+\t// numeric\n+\tOP_1ADD,\n+\tOP_1SUB,\n+\tOP_2MUL,\n+\tOP_2DIV,\n+\tOP_NEGATE,\n+\tOP_ABS,\n+\tOP_NOT,\n+\tOP_0NOTEQUAL,\n+\n+\tOP_ADD,\n+\tOP_SUB,\n+\tOP_MUL,\n+\tOP_DIV,\n+\tOP_MOD,\n+\tOP_LSHIFT,\n+\tOP_RSHIFT,\n+\n+\tOP_BOOLAND,\n+\tOP_BOOLOR,\n+\tOP_NUMEQUAL,\n+\tOP_NUMEQUALVERIFY,\n+\tOP_NUMNOTEQUAL,\n+\tOP_LESSTHAN,\n+\tOP_GREATERTHAN,\n+\tOP_LESSTHANOREQUAL,\n+\tOP_GREATERTHANOREQUAL,\n+\tOP_MIN,\n+\tOP_MAX,\n+\n+\tOP_WITHIN,\n+\n+\t// crypto\n+\tOP_RIPEMD160,\n+\tOP_SHA1,\n+\tOP_SHA256,\n+\tOP_HASH160,\n+\tOP_HASH256,\n+\tOP_CODESEPARATOR,\n+\tOP_CHECKSIG,\n+\tOP_CHECKSIGVERIFY,\n+\tOP_CHECKMULTISIG,\n+\tOP_CHECKMULTISIGVERIFY,\n+\n+\t// expansion\n+\tOP_NOP1,\n+\tOP_NOP2,\n+\tOP_NOP3,\n+\tOP_NOP4,\n+\tOP_NOP5,\n+\tOP_NOP6,\n+\tOP_NOP7,\n+\tOP_NOP8,\n+\tOP_NOP9,\n+\tOP_NOP10,\n+\n+\n+\n+\t// template matching params\n+\tOP_PUBKEYHASH = 0xfd,\n+\tOP_PUBKEY = 0xfe,\n+\n+\tOP_INVALIDOPCODE = 0xff,\n+    };\n \n \n \n@@ -167,144 +170,144 @@ enum opcodetype\n inline const char* GetOpName(opcodetype opcode)\n {\n     switch (opcode)\n-    {\n-    // push value\n-    case OP_0                      : return \"0\";\n-    case OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n-    case OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n-    case OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n-    case OP_1NEGATE                : return \"-1\";\n-    case OP_RESERVED               : return \"OP_RESERVED\";\n-    case OP_1                      : return \"1\";\n-    case OP_2                      : return \"2\";\n-    case OP_3                      : return \"3\";\n-    case OP_4                      : return \"4\";\n-    case OP_5                      : return \"5\";\n-    case OP_6                      : return \"6\";\n-    case OP_7                      : return \"7\";\n-    case OP_8                      : return \"8\";\n-    case OP_9                      : return \"9\";\n-    case OP_10                     : return \"10\";\n-    case OP_11                     : return \"11\";\n-    case OP_12                     : return \"12\";\n-    case OP_13                     : return \"13\";\n-    case OP_14                     : return \"14\";\n-    case OP_15                     : return \"15\";\n-    case OP_16                     : return \"16\";\n-\n-    // control\n-    case OP_NOP                    : return \"OP_NOP\";\n-    case OP_VER                    : return \"OP_VER\";\n-    case OP_IF                     : return \"OP_IF\";\n-    case OP_NOTIF                  : return \"OP_NOTIF\";\n-    case OP_VERIF                  : return \"OP_VERIF\";\n-    case OP_VERNOTIF               : return \"OP_VERNOTIF\";\n-    case OP_ELSE                   : return \"OP_ELSE\";\n-    case OP_ENDIF                  : return \"OP_ENDIF\";\n-    case OP_VERIFY                 : return \"OP_VERIFY\";\n-    case OP_RETURN                 : return \"OP_RETURN\";\n-\n-    // stack ops\n-    case OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n-    case OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n-    case OP_2DROP                  : return \"OP_2DROP\";\n-    case OP_2DUP                   : return \"OP_2DUP\";\n-    case OP_3DUP                   : return \"OP_3DUP\";\n-    case OP_2OVER                  : return \"OP_2OVER\";\n-    case OP_2ROT                   : return \"OP_2ROT\";\n-    case OP_2SWAP                  : return \"OP_2SWAP\";\n-    case OP_IFDUP                  : return \"OP_IFDUP\";\n-    case OP_DEPTH                  : return \"OP_DEPTH\";\n-    case OP_DROP                   : return \"OP_DROP\";\n-    case OP_DUP                    : return \"OP_DUP\";\n-    case OP_NIP                    : return \"OP_NIP\";\n-    case OP_OVER                   : return \"OP_OVER\";\n-    case OP_PICK                   : return \"OP_PICK\";\n-    case OP_ROLL                   : return \"OP_ROLL\";\n-    case OP_ROT                    : return \"OP_ROT\";\n-    case OP_SWAP                   : return \"OP_SWAP\";\n-    case OP_TUCK                   : return \"OP_TUCK\";\n-\n-    // splice ops\n-    case OP_CAT                    : return \"OP_CAT\";\n-    case OP_SUBSTR                 : return \"OP_SUBSTR\";\n-    case OP_LEFT                   : return \"OP_LEFT\";\n-    case OP_RIGHT                  : return \"OP_RIGHT\";\n-    case OP_SIZE                   : return \"OP_SIZE\";\n-\n-    // bit logic\n-    case OP_INVERT                 : return \"OP_INVERT\";\n-    case OP_AND                    : return \"OP_AND\";\n-    case OP_OR                     : return \"OP_OR\";\n-    case OP_XOR                    : return \"OP_XOR\";\n-    case OP_EQUAL                  : return \"OP_EQUAL\";\n-    case OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n-    case OP_RESERVED1              : return \"OP_RESERVED1\";\n-    case OP_RESERVED2              : return \"OP_RESERVED2\";\n-\n-    // numeric\n-    case OP_1ADD                   : return \"OP_1ADD\";\n-    case OP_1SUB                   : return \"OP_1SUB\";\n-    case OP_2MUL                   : return \"OP_2MUL\";\n-    case OP_2DIV                   : return \"OP_2DIV\";\n-    case OP_NEGATE                 : return \"OP_NEGATE\";\n-    case OP_ABS                    : return \"OP_ABS\";\n-    case OP_NOT                    : return \"OP_NOT\";\n-    case OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n-    case OP_ADD                    : return \"OP_ADD\";\n-    case OP_SUB                    : return \"OP_SUB\";\n-    case OP_MUL                    : return \"OP_MUL\";\n-    case OP_DIV                    : return \"OP_DIV\";\n-    case OP_MOD                    : return \"OP_MOD\";\n-    case OP_LSHIFT                 : return \"OP_LSHIFT\";\n-    case OP_RSHIFT                 : return \"OP_RSHIFT\";\n-    case OP_BOOLAND                : return \"OP_BOOLAND\";\n-    case OP_BOOLOR                 : return \"OP_BOOLOR\";\n-    case OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n-    case OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n-    case OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n-    case OP_LESSTHAN               : return \"OP_LESSTHAN\";\n-    case OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n-    case OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n-    case OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n-    case OP_MIN                    : return \"OP_MIN\";\n-    case OP_MAX                    : return \"OP_MAX\";\n-    case OP_WITHIN                 : return \"OP_WITHIN\";\n-\n-    // crypto\n-    case OP_RIPEMD160              : return \"OP_RIPEMD160\";\n-    case OP_SHA1                   : return \"OP_SHA1\";\n-    case OP_SHA256                 : return \"OP_SHA256\";\n-    case OP_HASH160                : return \"OP_HASH160\";\n-    case OP_HASH256                : return \"OP_HASH256\";\n-    case OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n-    case OP_CHECKSIG               : return \"OP_CHECKSIG\";\n-    case OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n-    case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n-    case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n-\n-    // expanson\n-    case OP_NOP1                   : return \"OP_NOP1\";\n-    case OP_NOP2                   : return \"OP_NOP2\";\n-    case OP_NOP3                   : return \"OP_NOP3\";\n-    case OP_NOP4                   : return \"OP_NOP4\";\n-    case OP_NOP5                   : return \"OP_NOP5\";\n-    case OP_NOP6                   : return \"OP_NOP6\";\n-    case OP_NOP7                   : return \"OP_NOP7\";\n-    case OP_NOP8                   : return \"OP_NOP8\";\n-    case OP_NOP9                   : return \"OP_NOP9\";\n-    case OP_NOP10                  : return \"OP_NOP10\";\n-\n-\n-\n-    // template matching params\n-    case OP_PUBKEYHASH             : return \"OP_PUBKEYHASH\";\n-    case OP_PUBKEY                 : return \"OP_PUBKEY\";\n-\n-    case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n-    default:\n-\treturn \"OP_UNKNOWN\";\n-    }\n+\t{\n+\t    // push value\n+\tcase OP_0                      : return \"0\";\n+\tcase OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n+\tcase OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n+\tcase OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n+\tcase OP_1NEGATE                : return \"-1\";\n+\tcase OP_RESERVED               : return \"OP_RESERVED\";\n+\tcase OP_1                      : return \"1\";\n+\tcase OP_2                      : return \"2\";\n+\tcase OP_3                      : return \"3\";\n+\tcase OP_4                      : return \"4\";\n+\tcase OP_5                      : return \"5\";\n+\tcase OP_6                      : return \"6\";\n+\tcase OP_7                      : return \"7\";\n+\tcase OP_8                      : return \"8\";\n+\tcase OP_9                      : return \"9\";\n+\tcase OP_10                     : return \"10\";\n+\tcase OP_11                     : return \"11\";\n+\tcase OP_12                     : return \"12\";\n+\tcase OP_13                     : return \"13\";\n+\tcase OP_14                     : return \"14\";\n+\tcase OP_15                     : return \"15\";\n+\tcase OP_16                     : return \"16\";\n+\n+\t    // control\n+\tcase OP_NOP                    : return \"OP_NOP\";\n+\tcase OP_VER                    : return \"OP_VER\";\n+\tcase OP_IF                     : return \"OP_IF\";\n+\tcase OP_NOTIF                  : return \"OP_NOTIF\";\n+\tcase OP_VERIF                  : return \"OP_VERIF\";\n+\tcase OP_VERNOTIF               : return \"OP_VERNOTIF\";\n+\tcase OP_ELSE                   : return \"OP_ELSE\";\n+\tcase OP_ENDIF                  : return \"OP_ENDIF\";\n+\tcase OP_VERIFY                 : return \"OP_VERIFY\";\n+\tcase OP_RETURN                 : return \"OP_RETURN\";\n+\n+\t    // stack ops\n+\tcase OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n+\tcase OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n+\tcase OP_2DROP                  : return \"OP_2DROP\";\n+\tcase OP_2DUP                   : return \"OP_2DUP\";\n+\tcase OP_3DUP                   : return \"OP_3DUP\";\n+\tcase OP_2OVER                  : return \"OP_2OVER\";\n+\tcase OP_2ROT                   : return \"OP_2ROT\";\n+\tcase OP_2SWAP                  : return \"OP_2SWAP\";\n+\tcase OP_IFDUP                  : return \"OP_IFDUP\";\n+\tcase OP_DEPTH                  : return \"OP_DEPTH\";\n+\tcase OP_DROP                   : return \"OP_DROP\";\n+\tcase OP_DUP                    : return \"OP_DUP\";\n+\tcase OP_NIP                    : return \"OP_NIP\";\n+\tcase OP_OVER                   : return \"OP_OVER\";\n+\tcase OP_PICK                   : return \"OP_PICK\";\n+\tcase OP_ROLL                   : return \"OP_ROLL\";\n+\tcase OP_ROT                    : return \"OP_ROT\";\n+\tcase OP_SWAP                   : return \"OP_SWAP\";\n+\tcase OP_TUCK                   : return \"OP_TUCK\";\n+\n+\t    // splice ops\n+\tcase OP_CAT                    : return \"OP_CAT\";\n+\tcase OP_SUBSTR                 : return \"OP_SUBSTR\";\n+\tcase OP_LEFT                   : return \"OP_LEFT\";\n+\tcase OP_RIGHT                  : return \"OP_RIGHT\";\n+\tcase OP_SIZE                   : return \"OP_SIZE\";\n+\n+\t    // bit logic\n+\tcase OP_INVERT                 : return \"OP_INVERT\";\n+\tcase OP_AND                    : return \"OP_AND\";\n+\tcase OP_OR                     : return \"OP_OR\";\n+\tcase OP_XOR                    : return \"OP_XOR\";\n+\tcase OP_EQUAL                  : return \"OP_EQUAL\";\n+\tcase OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n+\tcase OP_RESERVED1              : return \"OP_RESERVED1\";\n+\tcase OP_RESERVED2              : return \"OP_RESERVED2\";\n+\n+\t    // numeric\n+\tcase OP_1ADD                   : return \"OP_1ADD\";\n+\tcase OP_1SUB                   : return \"OP_1SUB\";\n+\tcase OP_2MUL                   : return \"OP_2MUL\";\n+\tcase OP_2DIV                   : return \"OP_2DIV\";\n+\tcase OP_NEGATE                 : return \"OP_NEGATE\";\n+\tcase OP_ABS                    : return \"OP_ABS\";\n+\tcase OP_NOT                    : return \"OP_NOT\";\n+\tcase OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n+\tcase OP_ADD                    : return \"OP_ADD\";\n+\tcase OP_SUB                    : return \"OP_SUB\";\n+\tcase OP_MUL                    : return \"OP_MUL\";\n+\tcase OP_DIV                    : return \"OP_DIV\";\n+\tcase OP_MOD                    : return \"OP_MOD\";\n+\tcase OP_LSHIFT                 : return \"OP_LSHIFT\";\n+\tcase OP_RSHIFT                 : return \"OP_RSHIFT\";\n+\tcase OP_BOOLAND                : return \"OP_BOOLAND\";\n+\tcase OP_BOOLOR                 : return \"OP_BOOLOR\";\n+\tcase OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n+\tcase OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n+\tcase OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n+\tcase OP_LESSTHAN               : return \"OP_LESSTHAN\";\n+\tcase OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n+\tcase OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n+\tcase OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n+\tcase OP_MIN                    : return \"OP_MIN\";\n+\tcase OP_MAX                    : return \"OP_MAX\";\n+\tcase OP_WITHIN                 : return \"OP_WITHIN\";\n+\n+\t    // crypto\n+\tcase OP_RIPEMD160              : return \"OP_RIPEMD160\";\n+\tcase OP_SHA1                   : return \"OP_SHA1\";\n+\tcase OP_SHA256                 : return \"OP_SHA256\";\n+\tcase OP_HASH160                : return \"OP_HASH160\";\n+\tcase OP_HASH256                : return \"OP_HASH256\";\n+\tcase OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n+\tcase OP_CHECKSIG               : return \"OP_CHECKSIG\";\n+\tcase OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n+\tcase OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n+\tcase OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n+\n+\t    // expanson\n+\tcase OP_NOP1                   : return \"OP_NOP1\";\n+\tcase OP_NOP2                   : return \"OP_NOP2\";\n+\tcase OP_NOP3                   : return \"OP_NOP3\";\n+\tcase OP_NOP4                   : return \"OP_NOP4\";\n+\tcase OP_NOP5                   : return \"OP_NOP5\";\n+\tcase OP_NOP6                   : return \"OP_NOP6\";\n+\tcase OP_NOP7                   : return \"OP_NOP7\";\n+\tcase OP_NOP8                   : return \"OP_NOP8\";\n+\tcase OP_NOP9                   : return \"OP_NOP9\";\n+\tcase OP_NOP10                  : return \"OP_NOP10\";\n+\n+\n+\n+\t    // template matching params\n+\tcase OP_PUBKEYHASH             : return \"OP_PUBKEYHASH\";\n+\tcase OP_PUBKEY                 : return \"OP_PUBKEY\";\n+\n+\tcase OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n+\tdefault:\n+\t    return \"OP_UNKNOWN\";\n+\t}\n };\n \n \n@@ -322,11 +325,11 @@ inline string StackString(const vector<vector<unsigned char> >& vStack)\n {\n     string str;\n     foreach(const vector<unsigned char>& vch, vStack)\n-    {\n-\tif (!str.empty())\n-\t    str += \" \";\n-\tstr += ValueString(vch);\n-    }\n+\t{\n+\t    if (!str.empty())\n+\t\tstr += \" \";\n+\t    str += ValueString(vch);\n+\t}\n     return str;\n }\n \n@@ -344,28 +347,28 @@ class CScript : public vector<unsigned char>\n     CScript& push_int64(int64 n)\n     {\n \tif (n == -1 || (n >= 1 && n <= 16))\n-\t{\n-\t    push_back(n + (OP_1 - 1));\n-\t}\n+\t    {\n+\t\tpush_back(n + (OP_1 - 1));\n+\t    }\n \telse\n-\t{\n-\t    CBigNum bn(n);\n-\t    *this << bn.getvch();\n-\t}\n+\t    {\n+\t\tCBigNum bn(n);\n+\t\t*this << bn.getvch();\n+\t    }\n \treturn *this;\n     }\n \n     CScript& push_uint64(uint64 n)\n     {\n \tif (n >= 1 && n <= 16)\n-\t{\n-\t    push_back(n + (OP_1 - 1));\n-\t}\n+\t    {\n+\t\tpush_back(n + (OP_1 - 1));\n+\t    }\n \telse\n-\t{\n-\t    CBigNum bn(n);\n-\t    *this << bn.getvch();\n-\t}\n+\t    {\n+\t\tCBigNum bn(n);\n+\t\t*this << bn.getvch();\n+\t    }\n \treturn *this;\n     }\n \n@@ -450,26 +453,26 @@ class CScript : public vector<unsigned char>\n     CScript& operator<<(const vector<unsigned char>& b)\n     {\n \tif (b.size() < OP_PUSHDATA1)\n-\t{\n-\t    insert(end(), (unsigned char)b.size());\n-\t}\n+\t    {\n+\t\tinsert(end(), (unsigned char)b.size());\n+\t    }\n \telse if (b.size() <= 0xff)\n-\t{\n-\t    insert(end(), OP_PUSHDATA1);\n-\t    insert(end(), (unsigned char)b.size());\n-\t}\n+\t    {\n+\t\tinsert(end(), OP_PUSHDATA1);\n+\t\tinsert(end(), (unsigned char)b.size());\n+\t    }\n \telse if (b.size() <= 0xffff)\n-\t{\n-\t    insert(end(), OP_PUSHDATA2);\n-\t    unsigned short nSize = b.size();\n-\t    insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-\t}\n+\t    {\n+\t\tinsert(end(), OP_PUSHDATA2);\n+\t\tunsigned short nSize = b.size();\n+\t\tinsert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+\t    }\n \telse\n-\t{\n-\t    insert(end(), OP_PUSHDATA4);\n-\t    unsigned int nSize = b.size();\n-\t    insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-\t}\n+\t    {\n+\t\tinsert(end(), OP_PUSHDATA4);\n+\t\tunsigned int nSize = b.size();\n+\t\tinsert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+\t    }\n \tinsert(end(), b.begin(), b.end());\n \treturn *this;\n     }\n@@ -485,19 +488,19 @@ class CScript : public vector<unsigned char>\n \n     bool GetOp(iterator& pc, opcodetype& opcodeRet, vector<unsigned char>& vchRet)\n     {\n-\t // Wrapper so it can be called with either iterator or const_iterator\n-\t const_iterator pc2 = pc;\n-\t bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n-\t pc = begin() + (pc2 - begin());\n-\t return fRet;\n+\t// Wrapper so it can be called with either iterator or const_iterator\n+\tconst_iterator pc2 = pc;\n+\tbool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n+\tpc = begin() + (pc2 - begin());\n+\treturn fRet;\n     }\n \n     bool GetOp(iterator& pc, opcodetype& opcodeRet)\n     {\n-\t const_iterator pc2 = pc;\n-\t bool fRet = GetOp2(pc2, opcodeRet, NULL);\n-\t pc = begin() + (pc2 - begin());\n-\t return fRet;\n+\tconst_iterator pc2 = pc;\n+\tbool fRet = GetOp2(pc2, opcodeRet, NULL);\n+\tpc = begin() + (pc2 - begin());\n+\treturn fRet;\n     }\n \n     bool GetOp(const_iterator& pc, opcodetype& opcodeRet, vector<unsigned char>& vchRet) const\n@@ -525,39 +528,39 @@ class CScript : public vector<unsigned char>\n \n \t// Immediate operand\n \tif (opcode <= OP_PUSHDATA4)\n-\t{\n-\t    unsigned int nSize;\n-\t    if (opcode < OP_PUSHDATA1)\n-\t    {\n-\t\tnSize = opcode;\n-\t    }\n-\t    else if (opcode == OP_PUSHDATA1)\n-\t    {\n-\t\tif (end() - pc < 1)\n-\t\t    return false;\n-\t\tnSize = *pc++;\n-\t    }\n-\t    else if (opcode == OP_PUSHDATA2)\n \t    {\n-\t\tif (end() - pc < 2)\n+\t\tunsigned int nSize;\n+\t\tif (opcode < OP_PUSHDATA1)\n+\t\t    {\n+\t\t\tnSize = opcode;\n+\t\t    }\n+\t\telse if (opcode == OP_PUSHDATA1)\n+\t\t    {\n+\t\t\tif (end() - pc < 1)\n+\t\t\t    return false;\n+\t\t\tnSize = *pc++;\n+\t\t    }\n+\t\telse if (opcode == OP_PUSHDATA2)\n+\t\t    {\n+\t\t\tif (end() - pc < 2)\n+\t\t\t    return false;\n+\t\t\tnSize = 0;\n+\t\t\tmemcpy(&nSize, &pc[0], 2);\n+\t\t\tpc += 2;\n+\t\t    }\n+\t\telse if (opcode == OP_PUSHDATA4)\n+\t\t    {\n+\t\t\tif (end() - pc < 4)\n+\t\t\t    return false;\n+\t\t\tmemcpy(&nSize, &pc[0], 4);\n+\t\t\tpc += 4;\n+\t\t    }\n+\t\tif (end() - pc < nSize)\n \t\t    return false;\n-\t\tnSize = 0;\n-\t\tmemcpy(&nSize, &pc[0], 2);\n-\t\tpc += 2;\n+\t\tif (pvchRet)\n+\t\t    pvchRet->assign(pc, pc + nSize);\n+\t\tpc += nSize;\n \t    }\n-\t    else if (opcode == OP_PUSHDATA4)\n-\t    {\n-\t\tif (end() - pc < 4)\n-\t\t    return false;\n-\t\tmemcpy(&nSize, &pc[0], 4);\n-\t\tpc += 4;\n-\t    }\n-\t    if (end() - pc < nSize)\n-\t\treturn false;\n-\t    if (pvchRet)\n-\t\tpvchRet->assign(pc, pc + nSize);\n-\t    pc += nSize;\n-\t}\n \n \topcodeRet = (opcodetype)opcode;\n \treturn true;\n@@ -571,10 +574,10 @@ class CScript : public vector<unsigned char>\n \titerator pc = begin();\n \topcodetype opcode;\n \tdo\n-\t{\n-\t    while (end() - pc >= b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n-\t\terase(pc, pc + b.size());\n-\t}\n+\t    {\n+\t\twhile (end() - pc >= b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n+\t\t    erase(pc, pc + b.size());\n+\t    }\n \twhile (GetOp(pc, opcode));\n     }\n \n@@ -584,15 +587,15 @@ class CScript : public vector<unsigned char>\n \tint n = 0;\n \tconst_iterator pc = begin();\n \twhile (pc < end())\n-\t{\n-\t    opcodetype opcode;\n-\t    if (!GetOp(pc, opcode))\n-\t\tbreak;\n-\t    if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n-\t\tn++;\n-\t    else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n-\t\tn += 20;\n-\t}\n+\t    {\n+\t\topcodetype opcode;\n+\t\tif (!GetOp(pc, opcode))\n+\t\t    break;\n+\t\tif (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n+\t\t    n++;\n+\t\telse if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n+\t\t    n += 20;\n+\t    }\n \treturn n;\n     }\n \n@@ -603,13 +606,13 @@ class CScript : public vector<unsigned char>\n \t    return false;\n \tconst_iterator pc = begin();\n \twhile (pc < end())\n-\t{\n-\t    opcodetype opcode;\n-\t    if (!GetOp(pc, opcode))\n-\t\treturn false;\n-\t    if (opcode > OP_16)\n-\t\treturn false;\n-\t}\n+\t    {\n+\t\topcodetype opcode;\n+\t\tif (!GetOp(pc, opcode))\n+\t\t    return false;\n+\t\tif (opcode > OP_16)\n+\t\t    return false;\n+\t    }\n \treturn true;\n     }\n \n@@ -671,19 +674,19 @@ class CScript : public vector<unsigned char>\n \tvector<unsigned char> vch;\n \tconst_iterator pc = begin();\n \twhile (pc < end())\n-\t{\n-\t    if (!str.empty())\n-\t\tstr += \" \";\n-\t    if (!GetOp(pc, opcode, vch))\n \t    {\n-\t\tstr += \"[error]\";\n-\t\treturn str;\n+\t\tif (!str.empty())\n+\t\t    str += \" \";\n+\t\tif (!GetOp(pc, opcode, vch))\n+\t\t    {\n+\t\t\tstr += \"[error]\";\n+\t\t\treturn str;\n+\t\t    }\n+\t\tif (0 <= opcode && opcode <= OP_PUSHDATA4)\n+\t\t    str += ValueString(vch);\n+\t\telse\n+\t\t    str += GetOpName(opcode);\n \t    }\n-\t    if (0 <= opcode && opcode <= OP_PUSHDATA4)\n-\t\tstr += ValueString(vch);\n-\t    else\n-\t\tstr += GetOpName(opcode);\n-\t}\n \treturn str;\n     }\n \n@@ -707,3 +710,5 @@ bool ExtractPubKey(const CScript& scriptPubKey, bool fMineOnly, vector<unsigned\n bool ExtractHash160(const CScript& scriptPubKey, uint160& hash160Ret);\n bool SignSignature(const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL, CScript scriptPrereq=CScript());\n bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType=0);\n+\n+#endif // !SCRIPT_H"
      },
      {
        "sha": "045e7212223d98c5f15580920f3d4981b02d4212",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 165,
        "deletions": 159,
        "changes": 324,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef SERIALIZE_H\n+#define SERIALIZE_H\n+\n #include <string>\n #include <vector>\n #include <map>\n@@ -10,6 +13,7 @@\n #include <boost/tuple/tuple.hpp>\n #include <boost/tuple/tuple_comparison.hpp>\n #include <boost/tuple/tuple_io.hpp>\n+\n #if defined(_MSC_VER) || defined(__BORLANDC__)\n typedef __int64  int64;\n typedef unsigned __int64  uint64;\n@@ -41,50 +45,50 @@ static const bool VERSION_IS_BETA = true;\n //\n \n enum\n-{\n-    // primary actions\n-    SER_NETWORK         = (1 << 0),\n-    SER_DISK            = (1 << 1),\n-    SER_GETHASH         = (1 << 2),\n-\n-    // modifiers\n-    SER_SKIPSIG         = (1 << 16),\n-    SER_BLOCKHEADERONLY = (1 << 17),\n-};\n-\n-#define IMPLEMENT_SERIALIZE(statements)    \\\n-    unsigned int GetSerializeSize(int nType=0, int nVersion=VERSION) const  \\\n-    {                                           \\\n-\tCSerActionGetSerializeSize ser_action;  \\\n-\tconst bool fGetSize = true;             \\\n-\tconst bool fWrite = false;              \\\n-\tconst bool fRead = false;               \\\n-\tunsigned int nSerSize = 0;              \\\n-\tser_streamplaceholder s;                \\\n-\ts.nType = nType;                        \\\n-\ts.nVersion = nVersion;                  \\\n-\t{statements}                            \\\n-\treturn nSerSize;                        \\\n-    }                                           \\\n-    template<typename Stream>                   \\\n+    {\n+\t// primary actions\n+\tSER_NETWORK         = (1 << 0),\n+\tSER_DISK            = (1 << 1),\n+\tSER_GETHASH         = (1 << 2),\n+\n+\t// modifiers\n+\tSER_SKIPSIG         = (1 << 16),\n+\tSER_BLOCKHEADERONLY = (1 << 17),\n+    };\n+\n+#define IMPLEMENT_SERIALIZE(statements)\t\t\t\t\t\\\n+    unsigned int GetSerializeSize(int nType=0, int nVersion=VERSION) const \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tCSerActionGetSerializeSize ser_action;\t\t\t\t\\\n+\tconst bool fGetSize = true;\t\t\t\t\t\\\n+\tconst bool fWrite = false;\t\t\t\t\t\\\n+\tconst bool fRead = false;\t\t\t\t\t\\\n+\tunsigned int nSerSize = 0;\t\t\t\t\t\\\n+\tser_streamplaceholder s;\t\t\t\t\t\\\n+\ts.nType = nType;\t\t\t\t\t\t\\\n+\ts.nVersion = nVersion;\t\t\t\t\t\t\\\n+\t{statements}\t\t\t\t\t\t\t\\\n+\treturn nSerSize;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    template<typename Stream>\t\t\t\t\t\t\\\n     void Serialize(Stream& s, int nType=0, int nVersion=VERSION) const  \\\n-    {                                           \\\n-\tCSerActionSerialize ser_action;         \\\n-\tconst bool fGetSize = false;            \\\n-\tconst bool fWrite = true;               \\\n-\tconst bool fRead = false;               \\\n-\tunsigned int nSerSize = 0;              \\\n-\t{statements}                            \\\n-    }                                           \\\n-    template<typename Stream>                   \\\n-    void Unserialize(Stream& s, int nType=0, int nVersion=VERSION)  \\\n-    {                                           \\\n-\tCSerActionUnserialize ser_action;       \\\n-\tconst bool fGetSize = false;            \\\n-\tconst bool fWrite = false;              \\\n-\tconst bool fRead = true;                \\\n-\tunsigned int nSerSize = 0;              \\\n-\t{statements}                            \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tCSerActionSerialize ser_action;\t\t\t\t\t\\\n+\tconst bool fGetSize = false;\t\t\t\t\t\\\n+\tconst bool fWrite = true;\t\t\t\t\t\\\n+\tconst bool fRead = false;\t\t\t\t\t\\\n+\tunsigned int nSerSize = 0;\t\t\t\t\t\\\n+\t{statements}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    template<typename Stream>\t\t\t\t\t\t\\\n+    void Unserialize(Stream& s, int nType=0, int nVersion=VERSION)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tCSerActionUnserialize ser_action;\t\t\t\t\\\n+\tconst bool fGetSize = false;\t\t\t\t\t\\\n+\tconst bool fWrite = false;\t\t\t\t\t\\\n+\tconst bool fRead = true;\t\t\t\t\t\\\n+\tunsigned int nSerSize = 0;\t\t\t\t\t\\\n+\t{statements}\t\t\t\t\t\t\t\\\n     }\n \n #define READWRITE(obj)      (nSerSize += ::SerReadWrite(s, (obj), nType, nVersion, ser_action))\n@@ -170,31 +174,31 @@ template<typename Stream>\n void WriteCompactSize(Stream& os, uint64 nSize)\n {\n     if (nSize < 253)\n-    {\n-\tunsigned char chSize = nSize;\n-\tWRITEDATA(os, chSize);\n-    }\n+\t{\n+\t    unsigned char chSize = nSize;\n+\t    WRITEDATA(os, chSize);\n+\t}\n     else if (nSize <= USHRT_MAX)\n-    {\n-\tunsigned char chSize = 253;\n-\tunsigned short xSize = nSize;\n-\tWRITEDATA(os, chSize);\n-\tWRITEDATA(os, xSize);\n-    }\n+\t{\n+\t    unsigned char chSize = 253;\n+\t    unsigned short xSize = nSize;\n+\t    WRITEDATA(os, chSize);\n+\t    WRITEDATA(os, xSize);\n+\t}\n     else if (nSize <= UINT_MAX)\n-    {\n-\tunsigned char chSize = 254;\n-\tunsigned int xSize = nSize;\n-\tWRITEDATA(os, chSize);\n-\tWRITEDATA(os, xSize);\n-    }\n+\t{\n+\t    unsigned char chSize = 254;\n+\t    unsigned int xSize = nSize;\n+\t    WRITEDATA(os, chSize);\n+\t    WRITEDATA(os, xSize);\n+\t}\n     else\n-    {\n-\tunsigned char chSize = 255;\n-\tuint64 xSize = nSize;\n-\tWRITEDATA(os, chSize);\n-\tWRITEDATA(os, xSize);\n-    }\n+\t{\n+\t    unsigned char chSize = 255;\n+\t    uint64 xSize = nSize;\n+\t    WRITEDATA(os, chSize);\n+\t    WRITEDATA(os, xSize);\n+\t}\n     return;\n }\n \n@@ -205,27 +209,27 @@ uint64 ReadCompactSize(Stream& is)\n     READDATA(is, chSize);\n     uint64 nSizeRet = 0;\n     if (chSize < 253)\n-    {\n-\tnSizeRet = chSize;\n-    }\n+\t{\n+\t    nSizeRet = chSize;\n+\t}\n     else if (chSize == 253)\n-    {\n-\tunsigned short xSize;\n-\tREADDATA(is, xSize);\n-\tnSizeRet = xSize;\n-    }\n+\t{\n+\t    unsigned short xSize;\n+\t    READDATA(is, xSize);\n+\t    nSizeRet = xSize;\n+\t}\n     else if (chSize == 254)\n-    {\n-\tunsigned int xSize;\n-\tREADDATA(is, xSize);\n-\tnSizeRet = xSize;\n-    }\n+\t{\n+\t    unsigned int xSize;\n+\t    READDATA(is, xSize);\n+\t    nSizeRet = xSize;\n+\t}\n     else\n-    {\n-\tuint64 xSize;\n-\tREADDATA(is, xSize);\n-\tnSizeRet = xSize;\n-    }\n+\t{\n+\t    uint64 xSize;\n+\t    READDATA(is, xSize);\n+\t    nSizeRet = xSize;\n+\t}\n     if (nSizeRet > (uint64)MAX_SIZE)\n \tthrow std::ios_base::failure(\"ReadCompactSize() : size too large\");\n     return nSizeRet;\n@@ -482,12 +486,12 @@ void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion,\n     unsigned int nSize = ReadCompactSize(is);\n     unsigned int i = 0;\n     while (i < nSize)\n-    {\n-\tunsigned int blk = min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n-\tv.resize(i + blk);\n-\tis.read((char*)&v[i], blk * sizeof(T));\n-\ti += blk;\n-    }\n+\t{\n+\t    unsigned int blk = min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n+\t    v.resize(i + blk);\n+\t    is.read((char*)&v[i], blk * sizeof(T));\n+\t    i += blk;\n+\t}\n }\n \n template<typename Stream, typename T, typename A>\n@@ -503,14 +507,14 @@ void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion,\n     unsigned int i = 0;\n     unsigned int nMid = 0;\n     while (nMid < nSize)\n-    {\n-\tnMid += 5000000 / sizeof(T);\n-\tif (nMid > nSize)\n-\t    nMid = nSize;\n-\tv.resize(nMid);\n-\tfor (; i < nMid; i++)\n-\t    Unserialize(is, v[i], nType, nVersion);\n-    }\n+\t{\n+\t    nMid += 5000000 / sizeof(T);\n+\t    if (nMid > nSize)\n+\t\tnMid = nSize;\n+\t    v.resize(nMid);\n+\t    for (; i < nMid; i++)\n+\t\tUnserialize(is, v[i], nType, nVersion);\n+\t}\n }\n \n template<typename Stream, typename T, typename A>\n@@ -660,11 +664,11 @@ void Unserialize(Stream& is, std::map<K, T, Pred, A>& m, int nType, int nVersion\n     unsigned int nSize = ReadCompactSize(is);\n     typename std::map<K, T, Pred, A>::iterator mi = m.begin();\n     for (unsigned int i = 0; i < nSize; i++)\n-    {\n-\tpair<K, T> item;\n-\tUnserialize(is, item, nType, nVersion);\n-\tmi = m.insert(mi, item);\n-    }\n+\t{\n+\t    pair<K, T> item;\n+\t    Unserialize(is, item, nType, nVersion);\n+\t    mi = m.insert(mi, item);\n+\t}\n }\n \n \n@@ -696,11 +700,11 @@ void Unserialize(Stream& is, std::set<K, Pred, A>& m, int nType, int nVersion)\n     unsigned int nSize = ReadCompactSize(is);\n     typename std::set<K, Pred, A>::iterator it = m.begin();\n     for (unsigned int i = 0; i < nSize; i++)\n-    {\n-\tK key;\n-\tUnserialize(is, key, nType, nVersion);\n-\tit = m.insert(it, key);\n-    }\n+\t{\n+\t    K key;\n+\t    Unserialize(is, key, nType, nVersion);\n+\t    it = m.insert(it, key);\n+\t}\n }\n \n \n@@ -886,23 +890,23 @@ class CDataStream\n     void insert(iterator it, const_iterator first, const_iterator last)\n     {\n \tif (it == vch.begin() + nReadPos && last - first <= nReadPos)\n-\t{\n-\t    // special case for inserting at the front when there's room\n-\t    nReadPos -= (last - first);\n-\t    memcpy(&vch[nReadPos], &first[0], last - first);\n-\t}\n+\t    {\n+\t\t// special case for inserting at the front when there's room\n+\t\tnReadPos -= (last - first);\n+\t\tmemcpy(&vch[nReadPos], &first[0], last - first);\n+\t    }\n \telse\n \t    vch.insert(it, first, last);\n     }\n \n     void insert(iterator it, vector<char>::const_iterator first, vector<char>::const_iterator last)\n     {\n \tif (it == vch.begin() + nReadPos && last - first <= nReadPos)\n-\t{\n-\t    // special case for inserting at the front when there's room\n-\t    nReadPos -= (last - first);\n-\t    memcpy(&vch[nReadPos], &first[0], last - first);\n-\t}\n+\t    {\n+\t\t// special case for inserting at the front when there's room\n+\t\tnReadPos -= (last - first);\n+\t\tmemcpy(&vch[nReadPos], &first[0], last - first);\n+\t    }\n \telse\n \t    vch.insert(it, first, last);\n     }\n@@ -911,11 +915,11 @@ class CDataStream\n     void insert(iterator it, const char* first, const char* last)\n     {\n \tif (it == vch.begin() + nReadPos && last - first <= nReadPos)\n-\t{\n-\t    // special case for inserting at the front when there's room\n-\t    nReadPos -= (last - first);\n-\t    memcpy(&vch[nReadPos], &first[0], last - first);\n-\t}\n+\t    {\n+\t\t// special case for inserting at the front when there's room\n+\t\tnReadPos -= (last - first);\n+\t\tmemcpy(&vch[nReadPos], &first[0], last - first);\n+\t    }\n \telse\n \t    vch.insert(it, first, last);\n     }\n@@ -924,36 +928,36 @@ class CDataStream\n     iterator erase(iterator it)\n     {\n \tif (it == vch.begin() + nReadPos)\n-\t{\n-\t    // special case for erasing from the front\n-\t    if (++nReadPos >= vch.size())\n \t    {\n-\t\t// whenever we reach the end, we take the opportunity to clear the buffer\n-\t\tnReadPos = 0;\n-\t\treturn vch.erase(vch.begin(), vch.end());\n+\t\t// special case for erasing from the front\n+\t\tif (++nReadPos >= vch.size())\n+\t\t    {\n+\t\t\t// whenever we reach the end, we take the opportunity to clear the buffer\n+\t\t\tnReadPos = 0;\n+\t\t\treturn vch.erase(vch.begin(), vch.end());\n+\t\t    }\n+\t\treturn vch.begin() + nReadPos;\n \t    }\n-\t    return vch.begin() + nReadPos;\n-\t}\n \telse\n \t    return vch.erase(it);\n     }\n \n     iterator erase(iterator first, iterator last)\n     {\n \tif (first == vch.begin() + nReadPos)\n-\t{\n-\t    // special case for erasing from the front\n-\t    if (last == vch.end())\n-\t    {\n-\t\tnReadPos = 0;\n-\t\treturn vch.erase(vch.begin(), vch.end());\n-\t    }\n-\t    else\n \t    {\n-\t\tnReadPos = (last - vch.begin());\n-\t\treturn last;\n+\t\t// special case for erasing from the front\n+\t\tif (last == vch.end())\n+\t\t    {\n+\t\t\tnReadPos = 0;\n+\t\t\treturn vch.erase(vch.begin(), vch.end());\n+\t\t    }\n+\t\telse\n+\t\t    {\n+\t\t\tnReadPos = (last - vch.begin());\n+\t\t\treturn last;\n+\t\t    }\n \t    }\n-\t}\n \telse\n \t    return vch.erase(first, last);\n     }\n@@ -1006,18 +1010,18 @@ class CDataStream\n \tassert(nSize >= 0);\n \tunsigned int nReadPosNext = nReadPos + nSize;\n \tif (nReadPosNext >= vch.size())\n-\t{\n-\t    if (nReadPosNext > vch.size())\n \t    {\n-\t\tsetstate(ios::failbit, \"CDataStream::read() : end of data\");\n-\t\tmemset(pch, 0, nSize);\n-\t\tnSize = vch.size() - nReadPos;\n+\t\tif (nReadPosNext > vch.size())\n+\t\t    {\n+\t\t\tsetstate(ios::failbit, \"CDataStream::read() : end of data\");\n+\t\t\tmemset(pch, 0, nSize);\n+\t\t\tnSize = vch.size() - nReadPos;\n+\t\t    }\n+\t\tmemcpy(pch, &vch[nReadPos], nSize);\n+\t\tnReadPos = 0;\n+\t\tvch.clear();\n+\t\treturn (*this);\n \t    }\n-\t    memcpy(pch, &vch[nReadPos], nSize);\n-\t    nReadPos = 0;\n-\t    vch.clear();\n-\t    return (*this);\n-\t}\n \tmemcpy(pch, &vch[nReadPos], nSize);\n \tnReadPos = nReadPosNext;\n \treturn (*this);\n@@ -1029,16 +1033,16 @@ class CDataStream\n \tassert(nSize >= 0);\n \tunsigned int nReadPosNext = nReadPos + nSize;\n \tif (nReadPosNext >= vch.size())\n-\t{\n-\t    if (nReadPosNext > vch.size())\n \t    {\n-\t\tsetstate(ios::failbit, \"CDataStream::ignore() : end of data\");\n-\t\tnSize = vch.size() - nReadPos;\n+\t\tif (nReadPosNext > vch.size())\n+\t\t    {\n+\t\t\tsetstate(ios::failbit, \"CDataStream::ignore() : end of data\");\n+\t\t\tnSize = vch.size() - nReadPos;\n+\t\t    }\n+\t\tnReadPos = 0;\n+\t\tvch.clear();\n+\t\treturn (*this);\n \t    }\n-\t    nReadPos = 0;\n-\t    vch.clear();\n-\t    return (*this);\n-\t}\n \tnReadPos = nReadPosNext;\n \treturn (*this);\n     }\n@@ -1259,3 +1263,5 @@ class CAutoFile\n \treturn (*this);\n     }\n };\n+\n+#endif // !SERIALIZE_H"
      },
      {
        "sha": "a7e675d5cdfb33e4e9f038e59c08c5cb3be1f639",
        "filename": "src/strlcpy.h",
        "status": "modified",
        "additions": 22,
        "deletions": 17,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/strlcpy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/strlcpy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/strlcpy.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -14,6 +14,9 @@\n  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n  */\n \n+#ifndef STRLCPY_H\n+#define STRLCPY_H\n+\n /*\n  * Copy src to string dst of size siz.  At most siz-1 characters\n  * will be copied.  Always NUL terminates (unless siz == 0).\n@@ -27,22 +30,22 @@ inline size_t strlcpy(char *dst, const char *src, size_t siz)\n \n     /* Copy as many bytes as will fit */\n     if (n != 0)\n-    {\n-\twhile (--n != 0)\n \t{\n-\t    if ((*d++ = *s++) == '\\0')\n-\t\tbreak;\n+\t    while (--n != 0)\n+\t\t{\n+\t\t    if ((*d++ = *s++) == '\\0')\n+\t\t\tbreak;\n+\t\t}\n \t}\n-    }\n \n     /* Not enough room in dst, add NUL and traverse rest of src */\n     if (n == 0)\n-    {\n-\tif (siz != 0)\n-\t    *d = '\\0';  /* NUL-terminate dst */\n-\twhile (*s++)\n-\t    ;\n-    }\n+\t{\n+\t    if (siz != 0)\n+\t\t*d = '\\0';  /* NUL-terminate dst */\n+\t    while (*s++)\n+\t\t;\n+\t}\n \n     return(s - src - 1); /* count does not include NUL */\n }\n@@ -70,15 +73,17 @@ inline size_t strlcat(char *dst, const char *src, size_t siz)\n     if (n == 0)\n \treturn(dlen + strlen(s));\n     while (*s != '\\0')\n-    {\n-\tif (n != 1)\n \t{\n-\t    *d++ = *s;\n-\t    n--;\n+\t    if (n != 1)\n+\t\t{\n+\t\t    *d++ = *s;\n+\t\t    n--;\n+\t\t}\n+\t    s++;\n \t}\n-\ts++;\n-    }\n     *d = '\\0';\n \n     return(dlen + (s - src)); /* count does not include NUL */\n }\n+\n+#endif // !STRLCPY_H"
      },
      {
        "sha": "8237cccf6d0f4254b5cf49ca85306b71f54d88b5",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 1053,
        "deletions": 1053,
        "changes": 2106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -136,29 +136,29 @@ string HtmlEscape(const char* psz, bool fMultiLine=false)\n {\n     int len = 0;\n     for (const char* p = psz; *p; p++)\n-    {\n-\t     if (*p == '<') len += 4;\n-\telse if (*p == '>') len += 4;\n-\telse if (*p == '&') len += 5;\n-\telse if (*p == '\"') len += 6;\n-\telse if (*p == ' ' && p > psz && p[-1] == ' ' && p[1] == ' ') len += 6;\n-\telse if (*p == '\\n' && fMultiLine) len += 5;\n-\telse\n-\t    len++;\n-    }\n+\t{\n+\t    if (*p == '<') len += 4;\n+\t    else if (*p == '>') len += 4;\n+\t    else if (*p == '&') len += 5;\n+\t    else if (*p == '\"') len += 6;\n+\t    else if (*p == ' ' && p > psz && p[-1] == ' ' && p[1] == ' ') len += 6;\n+\t    else if (*p == '\\n' && fMultiLine) len += 5;\n+\t    else\n+\t\tlen++;\n+\t}\n     string str;\n     str.reserve(len);\n     for (const char* p = psz; *p; p++)\n-    {\n-\t     if (*p == '<') str += \"&lt;\";\n-\telse if (*p == '>') str += \"&gt;\";\n-\telse if (*p == '&') str += \"&amp;\";\n-\telse if (*p == '\"') str += \"&quot;\";\n-\telse if (*p == ' ' && p > psz && p[-1] == ' ' && p[1] == ' ') str += \"&nbsp;\";\n-\telse if (*p == '\\n' && fMultiLine) str += \"<br>\\n\";\n-\telse\n-\t    str += *p;\n-    }\n+\t{\n+\t    if (*p == '<') str += \"&lt;\";\n+\t    else if (*p == '>') str += \"&gt;\";\n+\t    else if (*p == '&') str += \"&amp;\";\n+\t    else if (*p == '\"') str += \"&quot;\";\n+\t    else if (*p == ' ' && p > psz && p[-1] == ' ' && p[1] == ' ') str += \"&nbsp;\";\n+\t    else if (*p == '\\n' && fMultiLine) str += \"<br>\\n\";\n+\t    else\n+\t\tstr += *p;\n+\t}\n     return str;\n }\n \n@@ -179,18 +179,18 @@ int ThreadSafeMessageBox(const string& message, const string& caption, int style\n     return wxMessageBox(message, caption, style, parent, x, y);\n #else\n     if (wxThread::IsMain() || fDaemon)\n-    {\n-\treturn wxMessageBox(message, caption, style, parent, x, y);\n-    }\n+\t{\n+\t    return wxMessageBox(message, caption, style, parent, x, y);\n+\t}\n     else\n-    {\n-\tint nRet = 0;\n-\tbool fDone = false;\n-\tUIThreadCall(bind(CalledMessageBox, message, caption, style, parent, x, y, &nRet, &fDone));\n-\twhile (!fDone)\n-\t    Sleep(100);\n-\treturn nRet;\n-    }\n+\t{\n+\t    int nRet = 0;\n+\t    bool fDone = false;\n+\t    UIThreadCall(bind(CalledMessageBox, message, caption, style, parent, x, y, &nRet, &fDone));\n+\t    while (!fDone)\n+\t\tSleep(100);\n+\t    return nRet;\n+\t}\n #endif\n }\n \n@@ -199,10 +199,10 @@ bool ThreadSafeAskFee(int64 nFeeRequired, const string& strCaption, wxWindow* pa\n     if (nFeeRequired < MIN_TX_FEE || nFeeRequired <= nTransactionFee || fDaemon)\n \treturn true;\n     string strMessage = strprintf(\n-\t_(\"This transaction is over the size limit.  You can still send it for a fee of %s, \"\n-\t  \"which goes to the nodes that process your transaction and helps to support the network.  \"\n-\t  \"Do you want to pay the fee?\"),\n-\tFormatMoney(nFeeRequired).c_str());\n+\t\t\t\t  _(\"This transaction is over the size limit.  You can still send it for a fee of %s, \"\n+\t\t\t\t    \"which goes to the nodes that process your transaction and helps to support the network.  \"\n+\t\t\t\t    \"Do you want to pay the fee?\"),\n+\t\t\t\t  FormatMoney(nFeeRequired).c_str());\n     return (ThreadSafeMessageBox(strMessage, strCaption, wxYES_NO, parent) == wxYES);\n }\n \n@@ -220,15 +220,15 @@ void SetDefaultReceivingAddress(const string& strAddress)\n     if (pframeMain == NULL)\n \treturn;\n     if (strAddress != pframeMain->m_textCtrlAddress->GetValue())\n-    {\n-\tuint160 hash160;\n-\tif (!AddressToHash160(strAddress, hash160))\n-\t    return;\n-\tif (!mapPubKeys.count(hash160))\n-\t    return;\n-\tCWalletDB().WriteDefaultKey(mapPubKeys[hash160]);\n-\tpframeMain->m_textCtrlAddress->SetValue(strAddress);\n-    }\n+\t{\n+\t    uint160 hash160;\n+\t    if (!AddressToHash160(strAddress, hash160))\n+\t\treturn;\n+\t    if (!mapPubKeys.count(hash160))\n+\t\treturn;\n+\t    CWalletDB().WriteDefaultKey(mapPubKeys[hash160]);\n+\t    pframeMain->m_textCtrlAddress->SetValue(strAddress);\n+\t}\n }\n \n \n@@ -295,15 +295,15 @@ CMainFrame::CMainFrame(wxWindow* parent) : CMainFrameBase(parent)\n #endif\n     wxListCtrl* pplistCtrl[] = {m_listCtrlAll, m_listCtrlSentReceived, m_listCtrlSent, m_listCtrlReceived};\n     foreach(wxListCtrl* p, pplistCtrl)\n-    {\n-\tp->InsertColumn(0, \"\",               wxLIST_FORMAT_LEFT,  dResize * 0);\n-\tp->InsertColumn(1, \"\",               wxLIST_FORMAT_LEFT,  dResize * 0);\n-\tp->InsertColumn(2, _(\"Status\"),      wxLIST_FORMAT_LEFT,  dResize * 112);\n-\tp->InsertColumn(3, _(\"Date\"),        wxLIST_FORMAT_LEFT,  dResize * nDateWidth);\n-\tp->InsertColumn(4, _(\"Description\"), wxLIST_FORMAT_LEFT,  dResize * 409 - nDateWidth);\n-\tp->InsertColumn(5, _(\"Debit\"),       wxLIST_FORMAT_RIGHT, dResize * 79);\n-\tp->InsertColumn(6, _(\"Credit\"),      wxLIST_FORMAT_RIGHT, dResize * 79);\n-    }\n+\t{\n+\t    p->InsertColumn(0, \"\",               wxLIST_FORMAT_LEFT,  dResize * 0);\n+\t    p->InsertColumn(1, \"\",               wxLIST_FORMAT_LEFT,  dResize * 0);\n+\t    p->InsertColumn(2, _(\"Status\"),      wxLIST_FORMAT_LEFT,  dResize * 112);\n+\t    p->InsertColumn(3, _(\"Date\"),        wxLIST_FORMAT_LEFT,  dResize * nDateWidth);\n+\t    p->InsertColumn(4, _(\"Description\"), wxLIST_FORMAT_LEFT,  dResize * 409 - nDateWidth);\n+\t    p->InsertColumn(5, _(\"Debit\"),       wxLIST_FORMAT_RIGHT, dResize * 79);\n+\t    p->InsertColumn(6, _(\"Credit\"),      wxLIST_FORMAT_RIGHT, dResize * 79);\n+\t}\n \n     // Init status bar\n     int pnWidths[3] = { -100, 88, 300 };\n@@ -334,51 +334,51 @@ void CMainFrame::OnNotebookPageChanged(wxNotebookEvent& event)\n     event.Skip();\n     nPage = event.GetSelection();\n     if (nPage == ALL)\n-    {\n-\tm_listCtrl = m_listCtrlAll;\n-\tfShowGenerated = true;\n-\tfShowSent = true;\n-\tfShowReceived = true;\n-    }\n+\t{\n+\t    m_listCtrl = m_listCtrlAll;\n+\t    fShowGenerated = true;\n+\t    fShowSent = true;\n+\t    fShowReceived = true;\n+\t}\n     else if (nPage == SENTRECEIVED)\n-    {\n-\tm_listCtrl = m_listCtrlSentReceived;\n-\tfShowGenerated = false;\n-\tfShowSent = true;\n-\tfShowReceived = true;\n-    }\n+\t{\n+\t    m_listCtrl = m_listCtrlSentReceived;\n+\t    fShowGenerated = false;\n+\t    fShowSent = true;\n+\t    fShowReceived = true;\n+\t}\n     else if (nPage == SENT)\n-    {\n-\tm_listCtrl = m_listCtrlSent;\n-\tfShowGenerated = false;\n-\tfShowSent = true;\n-\tfShowReceived = false;\n-    }\n+\t{\n+\t    m_listCtrl = m_listCtrlSent;\n+\t    fShowGenerated = false;\n+\t    fShowSent = true;\n+\t    fShowReceived = false;\n+\t}\n     else if (nPage == RECEIVED)\n-    {\n-\tm_listCtrl = m_listCtrlReceived;\n-\tfShowGenerated = false;\n-\tfShowSent = false;\n-\tfShowReceived = true;\n-    }\n+\t{\n+\t    m_listCtrl = m_listCtrlReceived;\n+\t    fShowGenerated = false;\n+\t    fShowSent = false;\n+\t    fShowReceived = true;\n+\t}\n     RefreshListCtrl();\n     m_listCtrl->SetFocus();\n }\n \n void CMainFrame::OnClose(wxCloseEvent& event)\n {\n     if (fMinimizeOnClose && event.CanVeto() && !IsIconized())\n-    {\n-\t// Divert close to minimize\n-\tevent.Veto();\n-\tfClosedToTray = true;\n-\tIconize(true);\n-    }\n+\t{\n+\t    // Divert close to minimize\n+\t    event.Veto();\n+\t    fClosedToTray = true;\n+\t    Iconize(true);\n+\t}\n     else\n-    {\n-\tDestroy();\n-\tCreateThread(Shutdown, NULL);\n-    }\n+\t{\n+\t    Destroy();\n+\t    CreateThread(Shutdown, NULL);\n+\t}\n }\n \n void CMainFrame::OnIconize(wxIconizeEvent& event)\n@@ -393,13 +393,13 @@ void CMainFrame::OnIconize(wxIconizeEvent& event)\n #if defined(__WXGTK__) || defined(__WXMAC_OSX__)\n     if (GetBoolArg(\"-minimizetotray\")) {\n #endif\n-    // The tray icon sometimes disappears on ubuntu karmic\n-    // Hiding the taskbar button doesn't work cleanly on ubuntu lucid\n-    // Reports of CPU peg on 64-bit linux\n-    if (fMinimizeToTray && event.Iconized())\n-\tfClosedToTray = true;\n-    Show(!fClosedToTray);\n-    ptaskbaricon->Show(fMinimizeToTray || fClosedToTray);\n+\t// The tray icon sometimes disappears on ubuntu karmic\n+\t// Hiding the taskbar button doesn't work cleanly on ubuntu lucid\n+\t// Reports of CPU peg on 64-bit linux\n+\tif (fMinimizeToTray && event.Iconized())\n+\t    fClosedToTray = true;\n+\tShow(!fClosedToTray);\n+\tptaskbaricon->Show(fMinimizeToTray || fClosedToTray);\n #if defined(__WXGTK__) || defined(__WXMAC_OSX__)\n     }\n #endif\n@@ -435,13 +435,13 @@ int CMainFrame::GetSortIndex(const string& strSort)\n     int low = 0;\n     int high = m_listCtrl->GetItemCount();\n     while (low < high)\n-    {\n-\tint mid = low + ((high - low) / 2);\n-\tif (strSort.compare(m_listCtrl->GetItemText(mid).c_str()) >= 0)\n-\t    high = mid;\n-\telse\n-\t    low = mid + 1;\n-    }\n+\t{\n+\t    int mid = low + ((high - low) / 2);\n+\t    if (strSort.compare(m_listCtrl->GetItemText(mid).c_str()) >= 0)\n+\t\thigh = mid;\n+\t    else\n+\t\tlow = mid + 1;\n+\t}\n     return low;\n #endif\n }\n@@ -453,27 +453,27 @@ void CMainFrame::InsertLine(bool fNew, int nIndex, uint256 hashKey, string strSo\n \n     // Find item\n     if (!fNew && nIndex == -1)\n-    {\n-\tstring strHash = \" \" + hashKey.ToString();\n-\twhile ((nIndex = m_listCtrl->FindItem(nIndex, nData)) != -1)\n-\t    if (GetItemText(m_listCtrl, nIndex, 1) == strHash)\n-\t\tbreak;\n-    }\n+\t{\n+\t    string strHash = \" \" + hashKey.ToString();\n+\t    while ((nIndex = m_listCtrl->FindItem(nIndex, nData)) != -1)\n+\t\tif (GetItemText(m_listCtrl, nIndex, 1) == strHash)\n+\t\t    break;\n+\t}\n \n     // fNew is for blind insert, only use if you're sure it's new\n     if (fNew || nIndex == -1)\n-    {\n-\tnIndex = m_listCtrl->InsertItem(GetSortIndex(strSort), strSort);\n-    }\n-    else\n-    {\n-\t// If sort key changed, must delete and reinsert to make it relocate\n-\tif (GetItemText(m_listCtrl, nIndex, 0) != strSort)\n \t{\n-\t    m_listCtrl->DeleteItem(nIndex);\n \t    nIndex = m_listCtrl->InsertItem(GetSortIndex(strSort), strSort);\n \t}\n-    }\n+    else\n+\t{\n+\t    // If sort key changed, must delete and reinsert to make it relocate\n+\t    if (GetItemText(m_listCtrl, nIndex, 0) != strSort)\n+\t\t{\n+\t\t    m_listCtrl->DeleteItem(nIndex);\n+\t\t    nIndex = m_listCtrl->InsertItem(GetSortIndex(strSort), strSort);\n+\t\t}\n+\t}\n \n     m_listCtrl->SetItem(nIndex, 1, \" \" + hashKey.ToString());\n     m_listCtrl->SetItem(nIndex, 2, str2);\n@@ -506,42 +506,42 @@ string FormatTxStatus(const CWalletTx& wtx)\n {\n     // Status\n     if (!wtx.IsFinal())\n-    {\n-\tif (wtx.nLockTime < 500000000)\n-\t    return strprintf(_(\"Open for %d blocks\"), nBestHeight - wtx.nLockTime);\n-\telse\n-\t    return strprintf(_(\"Open until %s\"), DateTimeStr(wtx.nLockTime).c_str());\n-    }\n+\t{\n+\t    if (wtx.nLockTime < 500000000)\n+\t\treturn strprintf(_(\"Open for %d blocks\"), nBestHeight - wtx.nLockTime);\n+\t    else\n+\t\treturn strprintf(_(\"Open until %s\"), DateTimeStr(wtx.nLockTime).c_str());\n+\t}\n     else\n-    {\n-\tint nDepth = wtx.GetDepthInMainChain();\n-\tif (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n-\t    return strprintf(_(\"%d/offline?\"), nDepth);\n-\telse if (nDepth < 6)\n-\t    return strprintf(_(\"%d/unconfirmed\"), nDepth);\n-\telse\n-\t    return strprintf(_(\"%d confirmations\"), nDepth);\n-    }\n+\t{\n+\t    int nDepth = wtx.GetDepthInMainChain();\n+\t    if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+\t\treturn strprintf(_(\"%d/offline?\"), nDepth);\n+\t    else if (nDepth < 6)\n+\t\treturn strprintf(_(\"%d/unconfirmed\"), nDepth);\n+\t    else\n+\t\treturn strprintf(_(\"%d confirmations\"), nDepth);\n+\t}\n }\n \n string SingleLine(const string& strIn)\n {\n     string strOut;\n     bool fOneSpace = false;\n     foreach(unsigned char c, strIn)\n-    {\n-\tif (isspace(c))\n-\t{\n-\t    fOneSpace = true;\n-\t}\n-\telse if (c > ' ')\n \t{\n-\t    if (fOneSpace && !strOut.empty())\n-\t\tstrOut += ' ';\n-\t    strOut += c;\n-\t    fOneSpace = false;\n+\t    if (isspace(c))\n+\t\t{\n+\t\t    fOneSpace = true;\n+\t\t}\n+\t    else if (c > ' ')\n+\t\t{\n+\t\t    if (fOneSpace && !strOut.empty())\n+\t\t\tstrOut += ' ';\n+\t\t    strOut += c;\n+\t\t    fOneSpace = false;\n+\t\t}\n \t}\n-    }\n     return strOut;\n }\n \n@@ -561,27 +561,27 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n \n     // Filter\n     if (wtx.IsCoinBase())\n-    {\n-\t// Don't show generated coin until confirmed by at least one block after it\n-\t// so we don't get the user's hopes up until it looks like it's probably accepted.\n-\t//\n-\t// It is not an error when generated blocks are not accepted.  By design,\n-\t// some percentage of blocks, like 10% or more, will end up not accepted.\n-\t// This is the normal mechanism by which the network copes with latency.\n-\t//\n-\t// We display regular transactions right away before any confirmation\n-\t// because they can always get into some block eventually.  Generated coins\n-\t// are special because if their block is not accepted, they are not valid.\n-\t//\n-\tif (wtx.GetDepthInMainChain() < 2)\n \t{\n-\t    wtx.nLinesDisplayed = 0;\n-\t    return false;\n-\t}\n+\t    // Don't show generated coin until confirmed by at least one block after it\n+\t    // so we don't get the user's hopes up until it looks like it's probably accepted.\n+\t    //\n+\t    // It is not an error when generated blocks are not accepted.  By design,\n+\t    // some percentage of blocks, like 10% or more, will end up not accepted.\n+\t    // This is the normal mechanism by which the network copes with latency.\n+\t    //\n+\t    // We display regular transactions right away before any confirmation\n+\t    // because they can always get into some block eventually.  Generated coins\n+\t    // are special because if their block is not accepted, they are not valid.\n+\t    //\n+\t    if (wtx.GetDepthInMainChain() < 2)\n+\t\t{\n+\t\t    wtx.nLinesDisplayed = 0;\n+\t\t    return false;\n+\t\t}\n \n-\tif (!fShowGenerated)\n-\t    return false;\n-    }\n+\t    if (!fShowGenerated)\n+\t\treturn false;\n+\t}\n \n     // Find the block the tx is in\n     CBlockIndex* pindex = NULL;\n@@ -591,204 +591,204 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n \n     // Sort order, unrecorded transactions sort to the top\n     string strSort = strprintf(\"%010d-%01d-%010u\",\n-\t(pindex ? pindex->nHeight : INT_MAX),\n-\t(wtx.IsCoinBase() ? 1 : 0),\n-\twtx.nTimeReceived);\n+\t\t\t       (pindex ? pindex->nHeight : INT_MAX),\n+\t\t\t       (wtx.IsCoinBase() ? 1 : 0),\n+\t\t\t       wtx.nTimeReceived);\n \n     // Insert line\n     if (nNet > 0 || wtx.IsCoinBase())\n-    {\n-\t//\n-\t// Credit\n-\t//\n-\tstring strDescription;\n-\tif (wtx.IsCoinBase())\n \t{\n-\t    // Generated\n-\t    strDescription = _(\"Generated\");\n-\t    if (nCredit == 0)\n-\t    {\n-\t\tint64 nUnmatured = 0;\n-\t\tforeach(const CTxOut& txout, wtx.vout)\n-\t\t    nUnmatured += txout.GetCredit();\n-\t\tif (wtx.IsInMainChain())\n+\t    //\n+\t    // Credit\n+\t    //\n+\t    string strDescription;\n+\t    if (wtx.IsCoinBase())\n \t\t{\n-\t\t    strDescription = strprintf(_(\"Generated (%s matures in %d more blocks)\"), FormatMoney(nUnmatured).c_str(), wtx.GetBlocksToMaturity());\n-\n-\t\t    // Check if the block was requested by anyone\n-\t\t    if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n-\t\t\tstrDescription = _(\"Generated - Warning: This block was not received by any other nodes and will probably not be accepted!\");\n+\t\t    // Generated\n+\t\t    strDescription = _(\"Generated\");\n+\t\t    if (nCredit == 0)\n+\t\t\t{\n+\t\t\t    int64 nUnmatured = 0;\n+\t\t\t    foreach(const CTxOut& txout, wtx.vout)\n+\t\t\t\tnUnmatured += txout.GetCredit();\n+\t\t\t    if (wtx.IsInMainChain())\n+\t\t\t\t{\n+\t\t\t\t    strDescription = strprintf(_(\"Generated (%s matures in %d more blocks)\"), FormatMoney(nUnmatured).c_str(), wtx.GetBlocksToMaturity());\n+\n+\t\t\t\t    // Check if the block was requested by anyone\n+\t\t\t\t    if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+\t\t\t\t\tstrDescription = _(\"Generated - Warning: This block was not received by any other nodes and will probably not be accepted!\");\n+\t\t\t\t}\n+\t\t\t    else\n+\t\t\t\t{\n+\t\t\t\t    strDescription = _(\"Generated (not accepted)\");\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\telse\n+\t    else if (!mapValue[\"from\"].empty() || !mapValue[\"message\"].empty())\n \t\t{\n-\t\t    strDescription = _(\"Generated (not accepted)\");\n+\t\t    // Received by IP connection\n+\t\t    if (!fShowReceived)\n+\t\t\treturn false;\n+\t\t    if (!mapValue[\"from\"].empty())\n+\t\t\tstrDescription += _(\"From: \") + mapValue[\"from\"];\n+\t\t    if (!mapValue[\"message\"].empty())\n+\t\t\t{\n+\t\t\t    if (!strDescription.empty())\n+\t\t\t\tstrDescription += \" - \";\n+\t\t\t    strDescription += mapValue[\"message\"];\n+\t\t\t}\n \t\t}\n-\t    }\n-\t}\n-\telse if (!mapValue[\"from\"].empty() || !mapValue[\"message\"].empty())\n-\t{\n-\t    // Received by IP connection\n-\t    if (!fShowReceived)\n-\t\treturn false;\n-\t    if (!mapValue[\"from\"].empty())\n-\t\tstrDescription += _(\"From: \") + mapValue[\"from\"];\n-\t    if (!mapValue[\"message\"].empty())\n-\t    {\n-\t\tif (!strDescription.empty())\n-\t\t    strDescription += \" - \";\n-\t\tstrDescription += mapValue[\"message\"];\n-\t    }\n-\t}\n-\telse\n-\t{\n-\t    // Received by Bitcoin Address\n-\t    if (!fShowReceived)\n-\t\treturn false;\n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t    {\n-\t\tif (txout.IsMine())\n+\t    else\n \t\t{\n-\t\t    vector<unsigned char> vchPubKey;\n-\t\t    if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))\n-\t\t    {\n-\t\t\tCRITICAL_BLOCK(cs_mapAddressBook)\n+\t\t    // Received by Bitcoin Address\n+\t\t    if (!fShowReceived)\n+\t\t\treturn false;\n+\t\t    foreach(const CTxOut& txout, wtx.vout)\n \t\t\t{\n-\t\t\t    //strDescription += _(\"Received payment to \");\n-\t\t\t    //strDescription += _(\"Received with address \");\n-\t\t\t    strDescription += _(\"Received with: \");\n-\t\t\t    string strAddress = PubKeyToAddress(vchPubKey);\n-\t\t\t    map<string, string>::iterator mi = mapAddressBook.find(strAddress);\n-\t\t\t    if (mi != mapAddressBook.end() && !(*mi).second.empty())\n-\t\t\t    {\n-\t\t\t\tstring strLabel = (*mi).second;\n-\t\t\t\tstrDescription += strAddress.substr(0,12) + \"... \";\n-\t\t\t\tstrDescription += \"(\" + strLabel + \")\";\n-\t\t\t    }\n-\t\t\t    else\n-\t\t\t\tstrDescription += strAddress;\n+\t\t\t    if (txout.IsMine())\n+\t\t\t\t{\n+\t\t\t\t    vector<unsigned char> vchPubKey;\n+\t\t\t\t    if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))\n+\t\t\t\t\t{\n+\t\t\t\t\t    CRITICAL_BLOCK(cs_mapAddressBook)\n+\t\t\t\t\t    {\n+\t\t\t\t\t\t//strDescription += _(\"Received payment to \");\n+\t\t\t\t\t\t//strDescription += _(\"Received with address \");\n+\t\t\t\t\t\tstrDescription += _(\"Received with: \");\n+\t\t\t\t\t\tstring strAddress = PubKeyToAddress(vchPubKey);\n+\t\t\t\t\t\tmap<string, string>::iterator mi = mapAddressBook.find(strAddress);\n+\t\t\t\t\t\tif (mi != mapAddressBook.end() && !(*mi).second.empty())\n+\t\t\t\t\t\t    {\n+\t\t\t\t\t\t\tstring strLabel = (*mi).second;\n+\t\t\t\t\t\t\tstrDescription += strAddress.substr(0,12) + \"... \";\n+\t\t\t\t\t\t\tstrDescription += \"(\" + strLabel + \")\";\n+\t\t\t\t\t\t    }\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t    strDescription += strAddress;\n+\t\t\t\t\t    }\n+\t\t\t\t\t}\n+\t\t\t\t    break;\n+\t\t\t\t}\n \t\t\t}\n-\t\t    }\n-\t\t    break;\n \t\t}\n-\t    }\n-\t}\n \n-\tstring strCredit = FormatMoney(nNet, true);\n-\tif (!fConfirmed)\n-\t    strCredit = \"[\" + strCredit + \"]\";\n+\t    string strCredit = FormatMoney(nNet, true);\n+\t    if (!fConfirmed)\n+\t\tstrCredit = \"[\" + strCredit + \"]\";\n \n-\tInsertLine(fNew, nIndex, hash, strSort, colour,\n-\t\t   strStatus,\n-\t\t   nTime ? DateTimeStr(nTime) : \"\",\n-\t\t   SingleLine(strDescription),\n-\t\t   \"\",\n-\t\t   strCredit);\n-    }\n-    else\n-    {\n-\tbool fAllFromMe = true;\n-\tforeach(const CTxIn& txin, wtx.vin)\n-\t    fAllFromMe = fAllFromMe && txin.IsMine();\n-\n-\tbool fAllToMe = true;\n-\tforeach(const CTxOut& txout, wtx.vout)\n-\t    fAllToMe = fAllToMe && txout.IsMine();\n-\n-\tif (fAllFromMe && fAllToMe)\n-\t{\n-\t    // Payment to self\n-\t    int64 nChange = wtx.GetChange();\n \t    InsertLine(fNew, nIndex, hash, strSort, colour,\n \t\t       strStatus,\n \t\t       nTime ? DateTimeStr(nTime) : \"\",\n-\t\t       _(\"Payment to yourself\"),\n-\t\t       FormatMoney(-(nDebit - nChange), true),\n-\t\t       FormatMoney(nCredit - nChange, true));\n+\t\t       SingleLine(strDescription),\n+\t\t       \"\",\n+\t\t       strCredit);\n \t}\n-\telse if (fAllFromMe)\n+    else\n \t{\n-\t    //\n-\t    // Debit\n-\t    //\n-\t    if (!fShowSent)\n-\t\treturn false;\n-\n-\t    int64 nTxFee = nDebit - wtx.GetValueOut();\n-\t    wtx.nLinesDisplayed = 0;\n-\t    for (int nOut = 0; nOut < wtx.vout.size(); nOut++)\n-\t    {\n-\t\tconst CTxOut& txout = wtx.vout[nOut];\n-\t\tif (txout.IsMine())\n-\t\t    continue;\n+\t    bool fAllFromMe = true;\n+\t    foreach(const CTxIn& txin, wtx.vin)\n+\t\tfAllFromMe = fAllFromMe && txin.IsMine();\n \n-\t\tstring strAddress;\n-\t\tif (!mapValue[\"to\"].empty())\n-\t\t{\n-\t\t    // Sent to IP\n-\t\t    strAddress = mapValue[\"to\"];\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t    // Sent to Bitcoin Address\n-\t\t    uint160 hash160;\n-\t\t    if (ExtractHash160(txout.scriptPubKey, hash160))\n-\t\t\tstrAddress = Hash160ToAddress(hash160);\n-\t\t}\n+\t    bool fAllToMe = true;\n+\t    foreach(const CTxOut& txout, wtx.vout)\n+\t\tfAllToMe = fAllToMe && txout.IsMine();\n \n-\t\tstring strDescription = _(\"To: \");\n-\t\tCRITICAL_BLOCK(cs_mapAddressBook)\n-\t\t    if (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n-\t\t\tstrDescription += mapAddressBook[strAddress] + \" \";\n-\t\tstrDescription += strAddress;\n-\t\tif (!mapValue[\"message\"].empty())\n+\t    if (fAllFromMe && fAllToMe)\n \t\t{\n-\t\t    if (!strDescription.empty())\n-\t\t\tstrDescription += \" - \";\n-\t\t    strDescription += mapValue[\"message\"];\n+\t\t    // Payment to self\n+\t\t    int64 nChange = wtx.GetChange();\n+\t\t    InsertLine(fNew, nIndex, hash, strSort, colour,\n+\t\t\t       strStatus,\n+\t\t\t       nTime ? DateTimeStr(nTime) : \"\",\n+\t\t\t       _(\"Payment to yourself\"),\n+\t\t\t       FormatMoney(-(nDebit - nChange), true),\n+\t\t\t       FormatMoney(nCredit - nChange, true));\n \t\t}\n-\t\telse if (!mapValue[\"comment\"].empty())\n+\t    else if (fAllFromMe)\n \t\t{\n-\t\t    if (!strDescription.empty())\n-\t\t\tstrDescription += \" - \";\n-\t\t    strDescription += mapValue[\"comment\"];\n+\t\t    //\n+\t\t    // Debit\n+\t\t    //\n+\t\t    if (!fShowSent)\n+\t\t\treturn false;\n+\n+\t\t    int64 nTxFee = nDebit - wtx.GetValueOut();\n+\t\t    wtx.nLinesDisplayed = 0;\n+\t\t    for (int nOut = 0; nOut < wtx.vout.size(); nOut++)\n+\t\t\t{\n+\t\t\t    const CTxOut& txout = wtx.vout[nOut];\n+\t\t\t    if (txout.IsMine())\n+\t\t\t\tcontinue;\n+\n+\t\t\t    string strAddress;\n+\t\t\t    if (!mapValue[\"to\"].empty())\n+\t\t\t\t{\n+\t\t\t\t    // Sent to IP\n+\t\t\t\t    strAddress = mapValue[\"to\"];\n+\t\t\t\t}\n+\t\t\t    else\n+\t\t\t\t{\n+\t\t\t\t    // Sent to Bitcoin Address\n+\t\t\t\t    uint160 hash160;\n+\t\t\t\t    if (ExtractHash160(txout.scriptPubKey, hash160))\n+\t\t\t\t\tstrAddress = Hash160ToAddress(hash160);\n+\t\t\t\t}\n+\n+\t\t\t    string strDescription = _(\"To: \");\n+\t\t\t    CRITICAL_BLOCK(cs_mapAddressBook)\n+\t\t\t\tif (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n+\t\t\t\t    strDescription += mapAddressBook[strAddress] + \" \";\n+\t\t\t    strDescription += strAddress;\n+\t\t\t    if (!mapValue[\"message\"].empty())\n+\t\t\t\t{\n+\t\t\t\t    if (!strDescription.empty())\n+\t\t\t\t\tstrDescription += \" - \";\n+\t\t\t\t    strDescription += mapValue[\"message\"];\n+\t\t\t\t}\n+\t\t\t    else if (!mapValue[\"comment\"].empty())\n+\t\t\t\t{\n+\t\t\t\t    if (!strDescription.empty())\n+\t\t\t\t\tstrDescription += \" - \";\n+\t\t\t\t    strDescription += mapValue[\"comment\"];\n+\t\t\t\t}\n+\n+\t\t\t    int64 nValue = txout.nValue;\n+\t\t\t    if (nTxFee > 0)\n+\t\t\t\t{\n+\t\t\t\t    nValue += nTxFee;\n+\t\t\t\t    nTxFee = 0;\n+\t\t\t\t}\n+\n+\t\t\t    InsertLine(fNew, nIndex, hash, strprintf(\"%s-%d\", strSort.c_str(), nOut), colour,\n+\t\t\t\t       strStatus,\n+\t\t\t\t       nTime ? DateTimeStr(nTime) : \"\",\n+\t\t\t\t       SingleLine(strDescription),\n+\t\t\t\t       FormatMoney(-nValue, true),\n+\t\t\t\t       \"\");\n+\t\t\t    nIndex = -1;\n+\t\t\t    wtx.nLinesDisplayed++;\n+\t\t\t}\n \t\t}\n-\n-\t\tint64 nValue = txout.nValue;\n-\t\tif (nTxFee > 0)\n+\t    else\n \t\t{\n-\t\t    nValue += nTxFee;\n-\t\t    nTxFee = 0;\n+\t\t    //\n+\t\t    // Mixed debit transaction, can't break down payees\n+\t\t    //\n+\t\t    bool fAllMine = true;\n+\t\t    foreach(const CTxOut& txout, wtx.vout)\n+\t\t\tfAllMine = fAllMine && txout.IsMine();\n+\t\t    foreach(const CTxIn& txin, wtx.vin)\n+\t\t\tfAllMine = fAllMine && txin.IsMine();\n+\n+\t\t    InsertLine(fNew, nIndex, hash, strSort, colour,\n+\t\t\t       strStatus,\n+\t\t\t       nTime ? DateTimeStr(nTime) : \"\",\n+\t\t\t       \"\",\n+\t\t\t       FormatMoney(nNet, true),\n+\t\t\t       \"\");\n \t\t}\n-\n-\t\tInsertLine(fNew, nIndex, hash, strprintf(\"%s-%d\", strSort.c_str(), nOut), colour,\n-\t\t\t   strStatus,\n-\t\t\t   nTime ? DateTimeStr(nTime) : \"\",\n-\t\t\t   SingleLine(strDescription),\n-\t\t\t   FormatMoney(-nValue, true),\n-\t\t\t   \"\");\n-\t\tnIndex = -1;\n-\t\twtx.nLinesDisplayed++;\n-\t    }\n \t}\n-\telse\n-\t{\n-\t    //\n-\t    // Mixed debit transaction, can't break down payees\n-\t    //\n-\t    bool fAllMine = true;\n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tfAllMine = fAllMine && txout.IsMine();\n-\t    foreach(const CTxIn& txin, wtx.vin)\n-\t\tfAllMine = fAllMine && txin.IsMine();\n-\n-\t    InsertLine(fNew, nIndex, hash, strSort, colour,\n-\t\t       strStatus,\n-\t\t       nTime ? DateTimeStr(nTime) : \"\",\n-\t\t       \"\",\n-\t\t       FormatMoney(nNet, true),\n-\t\t       \"\");\n-\t}\n-    }\n \n     return true;\n }\n@@ -802,73 +802,73 @@ void CMainFrame::RefreshListCtrl()\n void CMainFrame::OnIdle(wxIdleEvent& event)\n {\n     if (fRefreshListCtrl)\n-    {\n-\t// Collect list of wallet transactions and sort newest first\n-\tbool fEntered = false;\n-\tvector<pair<unsigned int, uint256> > vSorted;\n-\tTRY_CRITICAL_BLOCK(cs_mapWallet)\n-\t{\n-\t    printf(\"RefreshListCtrl starting\\n\");\n-\t    fEntered = true;\n-\t    fRefreshListCtrl = false;\n-\t    vWalletUpdated.clear();\n-\n-\t    // Do the newest transactions first\n-\t    vSorted.reserve(mapWallet.size());\n-\t    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-\t    {\n-\t\tconst CWalletTx& wtx = (*it).second;\n-\t\tunsigned int nTime = UINT_MAX - wtx.GetTxTime();\n-\t\tvSorted.push_back(make_pair(nTime, (*it).first));\n-\t    }\n-\t    m_listCtrl->DeleteAllItems();\n-\t}\n-\tif (!fEntered)\n-\t    return;\n-\n-\tsort(vSorted.begin(), vSorted.end());\n-\n-\t// Fill list control\n-\tfor (int i = 0; i < vSorted.size();)\n \t{\n-\t    if (fShutdown)\n-\t\treturn;\n+\t    // Collect list of wallet transactions and sort newest first\n \t    bool fEntered = false;\n+\t    vector<pair<unsigned int, uint256> > vSorted;\n \t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n \t    {\n+\t\tprintf(\"RefreshListCtrl starting\\n\");\n \t\tfEntered = true;\n-\t\tuint256& hash = vSorted[i++].second;\n-\t\tmap<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-\t\tif (mi != mapWallet.end())\n-\t\t    InsertTransaction((*mi).second, true);\n+\t\tfRefreshListCtrl = false;\n+\t\tvWalletUpdated.clear();\n+\n+\t\t// Do the newest transactions first\n+\t\tvSorted.reserve(mapWallet.size());\n+\t\tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\t\t    {\n+\t\t\tconst CWalletTx& wtx = (*it).second;\n+\t\t\tunsigned int nTime = UINT_MAX - wtx.GetTxTime();\n+\t\t\tvSorted.push_back(make_pair(nTime, (*it).first));\n+\t\t    }\n+\t\tm_listCtrl->DeleteAllItems();\n \t    }\n-\t    if (!fEntered || i == 100 || i % 500 == 0)\n-\t\twxYield();\n-\t}\n+\t    if (!fEntered)\n+\t\treturn;\n \n-\tprintf(\"RefreshListCtrl done\\n\");\n+\t    sort(vSorted.begin(), vSorted.end());\n \n-\t// Update transaction total display\n-\tMainFrameRepaint();\n-    }\n+\t    // Fill list control\n+\t    for (int i = 0; i < vSorted.size();)\n+\t\t{\n+\t\t    if (fShutdown)\n+\t\t\treturn;\n+\t\t    bool fEntered = false;\n+\t\t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n+\t\t    {\n+\t\t\tfEntered = true;\n+\t\t\tuint256& hash = vSorted[i++].second;\n+\t\t\tmap<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n+\t\t\tif (mi != mapWallet.end())\n+\t\t\t    InsertTransaction((*mi).second, true);\n+\t\t    }\n+\t\t    if (!fEntered || i == 100 || i % 500 == 0)\n+\t\t\twxYield();\n+\t\t}\n+\n+\t    printf(\"RefreshListCtrl done\\n\");\n+\n+\t    // Update transaction total display\n+\t    MainFrameRepaint();\n+\t}\n     else\n-    {\n-\t// Check for time updates\n-\tstatic int64 nLastTime;\n-\tif (GetTime() > nLastTime + 30)\n \t{\n-\t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n-\t    {\n-\t\tnLastTime = GetTime();\n-\t\tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\t    // Check for time updates\n+\t    static int64 nLastTime;\n+\t    if (GetTime() > nLastTime + 30)\n \t\t{\n-\t\t    CWalletTx& wtx = (*it).second;\n-\t\t    if (wtx.nTimeDisplayed && wtx.nTimeDisplayed != wtx.GetTxTime())\n-\t\t\tInsertTransaction(wtx, false);\n+\t\t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n+\t\t    {\n+\t\t\tnLastTime = GetTime();\n+\t\t\tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\t\t\t    {\n+\t\t\t\tCWalletTx& wtx = (*it).second;\n+\t\t\t\tif (wtx.nTimeDisplayed && wtx.nTimeDisplayed != wtx.GetTxTime())\n+\t\t\t\t    InsertTransaction(wtx, false);\n+\t\t\t    }\n+\t\t    }\n \t\t}\n-\t    }\n \t}\n-    }\n }\n \n void CMainFrame::RefreshStatusColumn()\n@@ -887,50 +887,50 @@ void CMainFrame::RefreshStatusColumn()\n \tint nEnd = min(nStart + 100, m_listCtrl->GetItemCount());\n \n \tif (pindexLastBest == pindexBest && nLastRefreshed == nListViewUpdated)\n-\t{\n-\t    // If no updates, only need to do the part that moved onto the screen\n-\t    if (nStart >= nLastTop && nStart < nLastTop + 100)\n-\t\tnStart = nLastTop + 100;\n-\t    if (nEnd >= nLastTop && nEnd < nLastTop + 100)\n-\t\tnEnd = nLastTop;\n-\t}\n+\t    {\n+\t\t// If no updates, only need to do the part that moved onto the screen\n+\t\tif (nStart >= nLastTop && nStart < nLastTop + 100)\n+\t\t    nStart = nLastTop + 100;\n+\t\tif (nEnd >= nLastTop && nEnd < nLastTop + 100)\n+\t\t    nEnd = nLastTop;\n+\t    }\n \tnLastTop = nTop;\n \tpindexLastBest = pindexBest;\n \tnLastRefreshed = nListViewUpdated;\n \n \tfor (int nIndex = nStart; nIndex < min(nEnd, m_listCtrl->GetItemCount()); nIndex++)\n-\t{\n-\t    uint256 hash((string)GetItemText(m_listCtrl, nIndex, 1));\n-\t    map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-\t    if (mi == mapWallet.end())\n-\t    {\n-\t\tprintf(\"CMainFrame::RefreshStatusColumn() : tx not found in mapWallet\\n\");\n-\t\tcontinue;\n-\t    }\n-\t    CWalletTx& wtx = (*mi).second;\n-\t    if (wtx.IsCoinBase() ||\n-\t\twtx.GetTxTime() != wtx.nTimeDisplayed ||\n-\t\twtx.IsConfirmed() != wtx.fConfirmedDisplayed)\n-\t    {\n-\t\tif (!InsertTransaction(wtx, false, nIndex))\n-\t\t    m_listCtrl->DeleteItem(nIndex--);\n-\t    }\n-\t    else\n \t    {\n-\t\tm_listCtrl->SetItem(nIndex, 2, FormatTxStatus(wtx));\n+\t\tuint256 hash((string)GetItemText(m_listCtrl, nIndex, 1));\n+\t\tmap<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n+\t\tif (mi == mapWallet.end())\n+\t\t    {\n+\t\t\tprintf(\"CMainFrame::RefreshStatusColumn() : tx not found in mapWallet\\n\");\n+\t\t\tcontinue;\n+\t\t    }\n+\t\tCWalletTx& wtx = (*mi).second;\n+\t\tif (wtx.IsCoinBase() ||\n+\t\t    wtx.GetTxTime() != wtx.nTimeDisplayed ||\n+\t\t    wtx.IsConfirmed() != wtx.fConfirmedDisplayed)\n+\t\t    {\n+\t\t\tif (!InsertTransaction(wtx, false, nIndex))\n+\t\t\t    m_listCtrl->DeleteItem(nIndex--);\n+\t\t    }\n+\t\telse\n+\t\t    {\n+\t\t\tm_listCtrl->SetItem(nIndex, 2, FormatTxStatus(wtx));\n+\t\t    }\n \t    }\n-\t}\n     }\n }\n \n void CMainFrame::OnPaint(wxPaintEvent& event)\n {\n     event.Skip();\n     if (fRefresh)\n-    {\n-\tfRefresh = false;\n-\tRefresh();\n-    }\n+\t{\n+\t    fRefresh = false;\n+\t    Refresh();\n+\t}\n }\n \n \n@@ -942,42 +942,42 @@ int64 nRepaintInterval = 500;\n void ThreadDelayedRepaint(void* parg)\n {\n     while (!fShutdown)\n-    {\n-\tif (nLastRepaint != nNeedRepaint && GetTimeMillis() - nLastRepaintTime >= nRepaintInterval)\n \t{\n-\t    nLastRepaint = nNeedRepaint;\n-\t    if (pframeMain)\n-\t    {\n-\t\tprintf(\"DelayedRepaint\\n\");\n-\t\twxPaintEvent event;\n-\t\tpframeMain->fRefresh = true;\n-\t\tpframeMain->GetEventHandler()->AddPendingEvent(event);\n-\t    }\n+\t    if (nLastRepaint != nNeedRepaint && GetTimeMillis() - nLastRepaintTime >= nRepaintInterval)\n+\t\t{\n+\t\t    nLastRepaint = nNeedRepaint;\n+\t\t    if (pframeMain)\n+\t\t\t{\n+\t\t\t    printf(\"DelayedRepaint\\n\");\n+\t\t\t    wxPaintEvent event;\n+\t\t\t    pframeMain->fRefresh = true;\n+\t\t\t    pframeMain->GetEventHandler()->AddPendingEvent(event);\n+\t\t\t}\n+\t\t}\n+\t    Sleep(nRepaintInterval);\n \t}\n-\tSleep(nRepaintInterval);\n-    }\n }\n \n void MainFrameRepaint()\n {\n     // This is called by network code that shouldn't access pframeMain\n     // directly because it could still be running after the UI is closed.\n     if (pframeMain)\n-    {\n-\t// Don't repaint too often\n-\tstatic int64 nLastRepaintRequest;\n-\tif (GetTimeMillis() - nLastRepaintRequest < 100)\n \t{\n-\t    nNeedRepaint++;\n-\t    return;\n-\t}\n-\tnLastRepaintRequest = GetTimeMillis();\n+\t    // Don't repaint too often\n+\t    static int64 nLastRepaintRequest;\n+\t    if (GetTimeMillis() - nLastRepaintRequest < 100)\n+\t\t{\n+\t\t    nNeedRepaint++;\n+\t\t    return;\n+\t\t}\n+\t    nLastRepaintRequest = GetTimeMillis();\n \n-\tprintf(\"MainFrameRepaint\\n\");\n-\twxPaintEvent event;\n-\tpframeMain->fRefresh = true;\n-\tpframeMain->GetEventHandler()->AddPendingEvent(event);\n-    }\n+\t    printf(\"MainFrameRepaint\\n\");\n+\t    wxPaintEvent event;\n+\t    pframeMain->fRefresh = true;\n+\t    pframeMain->GetEventHandler()->AddPendingEvent(event);\n+\t}\n }\n \n void CMainFrame::OnPaintListCtrl(wxPaintEvent& event)\n@@ -994,45 +994,45 @@ void CMainFrame::OnPaintListCtrl(wxPaintEvent& event)\n     static int nTransactionCount;\n     bool fPaintedBalance = false;\n     if (GetTimeMillis() - nLastRepaintTime >= nRepaintInterval)\n-    {\n-\tnLastRepaint = nNeedRepaint;\n-\tnLastRepaintTime = GetTimeMillis();\n-\n-\t// Update listctrl contents\n-\tif (!vWalletUpdated.empty())\n \t{\n-\t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n-\t    {\n-\t\tstring strTop;\n-\t\tif (m_listCtrl->GetItemCount())\n-\t\t    strTop = (string)m_listCtrl->GetItemText(0);\n-\t\tforeach(uint256 hash, vWalletUpdated)\n+\t    nLastRepaint = nNeedRepaint;\n+\t    nLastRepaintTime = GetTimeMillis();\n+\n+\t    // Update listctrl contents\n+\t    if (!vWalletUpdated.empty())\n \t\t{\n-\t\t    map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-\t\t    if (mi != mapWallet.end())\n-\t\t\tInsertTransaction((*mi).second, false);\n+\t\t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n+\t\t    {\n+\t\t\tstring strTop;\n+\t\t\tif (m_listCtrl->GetItemCount())\n+\t\t\t    strTop = (string)m_listCtrl->GetItemText(0);\n+\t\t\tforeach(uint256 hash, vWalletUpdated)\n+\t\t\t    {\n+\t\t\t\tmap<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n+\t\t\t\tif (mi != mapWallet.end())\n+\t\t\t\t    InsertTransaction((*mi).second, false);\n+\t\t\t    }\n+\t\t\tvWalletUpdated.clear();\n+\t\t\tif (m_listCtrl->GetItemCount() && strTop != (string)m_listCtrl->GetItemText(0))\n+\t\t\t    m_listCtrl->ScrollList(0, INT_MIN/2);\n+\t\t    }\n \t\t}\n-\t\tvWalletUpdated.clear();\n-\t\tif (m_listCtrl->GetItemCount() && strTop != (string)m_listCtrl->GetItemText(0))\n-\t\t    m_listCtrl->ScrollList(0, INT_MIN/2);\n-\t    }\n-\t}\n-\n-\t// Balance total\n-\tTRY_CRITICAL_BLOCK(cs_mapWallet)\n-\t{\n-\t    fPaintedBalance = true;\n-\t    m_staticTextBalance->SetLabel(FormatMoney(GetBalance()) + \"  \");\n \n-\t    // Count hidden and multi-line transactions\n-\t    nTransactionCount = 0;\n-\t    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\t    // Balance total\n+\t    TRY_CRITICAL_BLOCK(cs_mapWallet)\n \t    {\n-\t\tCWalletTx& wtx = (*it).second;\n-\t\tnTransactionCount += wtx.nLinesDisplayed;\n+\t\tfPaintedBalance = true;\n+\t\tm_staticTextBalance->SetLabel(FormatMoney(GetBalance()) + \"  \");\n+\n+\t\t// Count hidden and multi-line transactions\n+\t\tnTransactionCount = 0;\n+\t\tfor (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+\t\t    {\n+\t\t\tCWalletTx& wtx = (*it).second;\n+\t\t\tnTransactionCount += wtx.nLinesDisplayed;\n+\t\t    }\n \t    }\n \t}\n-    }\n     if (!vWalletUpdated.empty() || !fPaintedBalance)\n \tnNeedRepaint++;\n \n@@ -1074,11 +1074,11 @@ void UIThreadCall(boost::function0<void> fn)\n     //  UIThreadCall(bind(wxMessageBox, wxT(\"Message\"), wxT(\"Title\"), wxOK, (wxWindow*)NULL, -1, -1));\n     //  UIThreadCall(bind(&CMainFrame::OnMenuHelpAbout, pframeMain, event));\n     if (pframeMain)\n-    {\n-\twxCommandEvent event(wxEVT_UITHREADCALL);\n-\tevent.SetClientData((void*)new boost::function0<void>(fn));\n-\tpframeMain->GetEventHandler()->AddPendingEvent(event);\n-    }\n+\t{\n+\t    wxCommandEvent event(wxEVT_UITHREADCALL);\n+\t    event.SetClientData((void*)new boost::function0<void>(fn));\n+\t    pframeMain->GetEventHandler()->AddPendingEvent(event);\n+\t}\n }\n \n void CMainFrame::OnUIThreadCall(wxCommandEvent& event)\n@@ -1133,11 +1133,11 @@ void CMainFrame::OnButtonAddressBook(wxCommandEvent& event)\n     // Toolbar: Address Book\n     CAddressBookDialog dialogAddr(this, \"\", CAddressBookDialog::SENDING, false);\n     if (dialogAddr.ShowModal() == 2)\n-    {\n-\t// Send\n-\tCSendDialog dialogSend(this, dialogAddr.GetSelectedAddress());\n-\tdialogSend.ShowModal();\n-    }\n+\t{\n+\t    // Send\n+\t    CSendDialog dialogSend(this, dialogAddr.GetSelectedAddress());\n+\t    dialogSend.ShowModal();\n+\t}\n }\n \n void CMainFrame::OnSetFocusAddress(wxFocusEvent& event)\n@@ -1160,9 +1160,9 @@ void CMainFrame::OnButtonNew(wxCommandEvent& event)\n {\n     // Ask name\n     CGetTextFromUserDialog dialog(this,\n-\t_(\"New Receiving Address\"),\n-\t_(\"You should use a new address for each payment you receive.\\n\\nLabel\"),\n-\t\"\");\n+\t\t\t\t  _(\"New Receiving Address\"),\n+\t\t\t\t  _(\"You should use a new address for each payment you receive.\\n\\nLabel\"),\n+\t\t\t\t  \"\");\n     if (!dialog.ShowModal())\n \treturn;\n     string strName = dialog.GetValue();\n@@ -1179,10 +1179,10 @@ void CMainFrame::OnButtonCopy(wxCommandEvent& event)\n {\n     // Copy address box to clipboard\n     if (wxTheClipboard->Open())\n-    {\n-\twxTheClipboard->SetData(new wxTextDataObject(m_textCtrlAddress->GetValue()));\n-\twxTheClipboard->Close();\n-    }\n+\t{\n+\t    wxTheClipboard->SetData(new wxTextDataObject(m_textCtrlAddress->GetValue()));\n+\t    wxTheClipboard->Close();\n+\t}\n }\n \n void CMainFrame::OnListItemActivated(wxListEvent& event)\n@@ -1193,10 +1193,10 @@ void CMainFrame::OnListItemActivated(wxListEvent& event)\n     {\n \tmap<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n \tif (mi == mapWallet.end())\n-\t{\n-\t    printf(\"CMainFrame::OnListItemActivated() : tx not found in mapWallet\\n\");\n-\t    return;\n-\t}\n+\t    {\n+\t\tprintf(\"CMainFrame::OnListItemActivated() : tx not found in mapWallet\\n\");\n+\t\treturn;\n+\t    }\n \twtx = (*mi).second;\n     }\n     CTxDetailsDialog dialog(this, wtx);\n@@ -1233,14 +1233,14 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n \tstrHTML += _(\"<b>Status:</b> \") + FormatTxStatus(wtx);\n \tint nRequests = wtx.GetRequestCount();\n \tif (nRequests != -1)\n-\t{\n-\t    if (nRequests == 0)\n-\t\tstrHTML += _(\", has not been successfully broadcast yet\");\n-\t    else if (nRequests == 1)\n-\t\tstrHTML += strprintf(_(\", broadcast through %d node\"), nRequests);\n-\t    else\n-\t\tstrHTML += strprintf(_(\", broadcast through %d nodes\"), nRequests);\n-\t}\n+\t    {\n+\t\tif (nRequests == 0)\n+\t\t    strHTML += _(\", has not been successfully broadcast yet\");\n+\t\telse if (nRequests == 1)\n+\t\t    strHTML += strprintf(_(\", broadcast through %d node\"), nRequests);\n+\t\telse\n+\t\t    strHTML += strprintf(_(\", broadcast through %d nodes\"), nRequests);\n+\t    }\n \tstrHTML += \"<br>\";\n \n \tstrHTML += _(\"<b>Date:</b> \") + (nTime ? DateTimeStr(nTime) : \"\") + \"<br>\";\n@@ -1250,152 +1250,152 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n \t// From\n \t//\n \tif (wtx.IsCoinBase())\n-\t{\n-\t    strHTML += _(\"<b>Source:</b> Generated<br>\");\n-\t}\n+\t    {\n+\t\tstrHTML += _(\"<b>Source:</b> Generated<br>\");\n+\t    }\n \telse if (!wtx.mapValue[\"from\"].empty())\n-\t{\n-\t    // Online transaction\n-\t    if (!wtx.mapValue[\"from\"].empty())\n-\t\tstrHTML += _(\"<b>From:</b> \") + HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n-\t}\n+\t    {\n+\t\t// Online transaction\n+\t\tif (!wtx.mapValue[\"from\"].empty())\n+\t\t    strHTML += _(\"<b>From:</b> \") + HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n+\t    }\n \telse\n-\t{\n-\t    // Offline transaction\n-\t    if (nNet > 0)\n \t    {\n-\t\t// Credit\n-\t\tforeach(const CTxOut& txout, wtx.vout)\n-\t\t{\n-\t\t    if (txout.IsMine())\n+\t\t// Offline transaction\n+\t\tif (nNet > 0)\n \t\t    {\n-\t\t\tvector<unsigned char> vchPubKey;\n-\t\t\tif (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))\n-\t\t\t{\n-\t\t\t    string strAddress = PubKeyToAddress(vchPubKey);\n-\t\t\t    if (mapAddressBook.count(strAddress))\n+\t\t\t// Credit\n+\t\t\tforeach(const CTxOut& txout, wtx.vout)\n \t\t\t    {\n-\t\t\t\tstrHTML += string() + _(\"<b>From:</b> \") + _(\"unknown\") + \"<br>\";\n-\t\t\t\tstrHTML += _(\"<b>To:</b> \");\n-\t\t\t\tstrHTML += HtmlEscape(strAddress);\n-\t\t\t\tif (!mapAddressBook[strAddress].empty())\n-\t\t\t\t    strHTML += _(\" (yours, label: \") + mapAddressBook[strAddress] + \")\";\n-\t\t\t\telse\n-\t\t\t\t    strHTML += _(\" (yours)\");\n-\t\t\t\tstrHTML += \"<br>\";\n+\t\t\t\tif (txout.IsMine())\n+\t\t\t\t    {\n+\t\t\t\t\tvector<unsigned char> vchPubKey;\n+\t\t\t\t\tif (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))\n+\t\t\t\t\t    {\n+\t\t\t\t\t\tstring strAddress = PubKeyToAddress(vchPubKey);\n+\t\t\t\t\t\tif (mapAddressBook.count(strAddress))\n+\t\t\t\t\t\t    {\n+\t\t\t\t\t\t\tstrHTML += string() + _(\"<b>From:</b> \") + _(\"unknown\") + \"<br>\";\n+\t\t\t\t\t\t\tstrHTML += _(\"<b>To:</b> \");\n+\t\t\t\t\t\t\tstrHTML += HtmlEscape(strAddress);\n+\t\t\t\t\t\t\tif (!mapAddressBook[strAddress].empty())\n+\t\t\t\t\t\t\t    strHTML += _(\" (yours, label: \") + mapAddressBook[strAddress] + \")\";\n+\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t    strHTML += _(\" (yours)\");\n+\t\t\t\t\t\t\tstrHTML += \"<br>\";\n+\t\t\t\t\t\t    }\n+\t\t\t\t\t    }\n+\t\t\t\t\tbreak;\n+\t\t\t\t    }\n \t\t\t    }\n-\t\t\t}\n-\t\t\tbreak;\n \t\t    }\n-\t\t}\n \t    }\n-\t}\n \n \n \t//\n \t// To\n \t//\n \tstring strAddress;\n \tif (!wtx.mapValue[\"to\"].empty())\n-\t{\n-\t    // Online transaction\n-\t    strAddress = wtx.mapValue[\"to\"];\n-\t    strHTML += _(\"<b>To:</b> \");\n-\t    if (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n-\t\tstrHTML += mapAddressBook[strAddress] + \" \";\n-\t    strHTML += HtmlEscape(strAddress) + \"<br>\";\n-\t}\n+\t    {\n+\t\t// Online transaction\n+\t\tstrAddress = wtx.mapValue[\"to\"];\n+\t\tstrHTML += _(\"<b>To:</b> \");\n+\t\tif (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n+\t\t    strHTML += mapAddressBook[strAddress] + \" \";\n+\t\tstrHTML += HtmlEscape(strAddress) + \"<br>\";\n+\t    }\n \n \n \t//\n \t// Amount\n \t//\n \tif (wtx.IsCoinBase() && nCredit == 0)\n-\t{\n-\t    //\n-\t    // Coinbase\n-\t    //\n-\t    int64 nUnmatured = 0;\n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tnUnmatured += txout.GetCredit();\n-\t    strHTML += _(\"<b>Credit:</b> \");\n-\t    if (wtx.IsInMainChain())\n-\t\tstrHTML += strprintf(_(\"(%s matures in %d more blocks)\"), FormatMoney(nUnmatured).c_str(), wtx.GetBlocksToMaturity());\n-\t    else\n-\t\tstrHTML += _(\"(not accepted)\");\n-\t    strHTML += \"<br>\";\n-\t}\n-\telse if (nNet > 0)\n-\t{\n-\t    //\n-\t    // Credit\n-\t    //\n-\t    strHTML += _(\"<b>Credit:</b> \") + FormatMoney(nNet) + \"<br>\";\n-\t}\n-\telse\n-\t{\n-\t    bool fAllFromMe = true;\n-\t    foreach(const CTxIn& txin, wtx.vin)\n-\t\tfAllFromMe = fAllFromMe && txin.IsMine();\n-\n-\t    bool fAllToMe = true;\n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tfAllToMe = fAllToMe && txout.IsMine();\n-\n-\t    if (fAllFromMe)\n \t    {\n \t\t//\n-\t\t// Debit\n+\t\t// Coinbase\n \t\t//\n+\t\tint64 nUnmatured = 0;\n \t\tforeach(const CTxOut& txout, wtx.vout)\n-\t\t{\n-\t\t    if (txout.IsMine())\n-\t\t\tcontinue;\n-\n-\t\t    if (wtx.mapValue[\"to\"].empty())\n-\t\t    {\n-\t\t\t// Offline transaction\n-\t\t\tuint160 hash160;\n-\t\t\tif (ExtractHash160(txout.scriptPubKey, hash160))\n-\t\t\t{\n-\t\t\t    string strAddress = Hash160ToAddress(hash160);\n-\t\t\t    strHTML += _(\"<b>To:</b> \");\n-\t\t\t    if (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n-\t\t\t\tstrHTML += mapAddressBook[strAddress] + \" \";\n-\t\t\t    strHTML += strAddress;\n-\t\t\t    strHTML += \"<br>\";\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    strHTML += _(\"<b>Debit:</b> \") + FormatMoney(-txout.nValue) + \"<br>\";\n-\t\t}\n-\n-\t\tif (fAllToMe)\n-\t\t{\n-\t\t    // Payment to self\n-\t\t    int64 nChange = wtx.GetChange();\n-\t\t    int64 nValue = nCredit - nChange;\n-\t\t    strHTML += _(\"<b>Debit:</b> \") + FormatMoney(-nValue) + \"<br>\";\n-\t\t    strHTML += _(\"<b>Credit:</b> \") + FormatMoney(nValue) + \"<br>\";\n-\t\t}\n-\n-\t\tint64 nTxFee = nDebit - wtx.GetValueOut();\n-\t\tif (nTxFee > 0)\n-\t\t    strHTML += _(\"<b>Transaction fee:</b> \") + FormatMoney(-nTxFee) + \"<br>\";\n+\t\t    nUnmatured += txout.GetCredit();\n+\t\tstrHTML += _(\"<b>Credit:</b> \");\n+\t\tif (wtx.IsInMainChain())\n+\t\t    strHTML += strprintf(_(\"(%s matures in %d more blocks)\"), FormatMoney(nUnmatured).c_str(), wtx.GetBlocksToMaturity());\n+\t\telse\n+\t\t    strHTML += _(\"(not accepted)\");\n+\t\tstrHTML += \"<br>\";\n \t    }\n-\t    else\n+\telse if (nNet > 0)\n \t    {\n \t\t//\n-\t\t// Mixed debit transaction\n+\t\t// Credit\n \t\t//\n+\t\tstrHTML += _(\"<b>Credit:</b> \") + FormatMoney(nNet) + \"<br>\";\n+\t    }\n+\telse\n+\t    {\n+\t\tbool fAllFromMe = true;\n \t\tforeach(const CTxIn& txin, wtx.vin)\n-\t\t    if (txin.IsMine())\n-\t\t\tstrHTML += _(\"<b>Debit:</b> \") + FormatMoney(-txin.GetDebit()) + \"<br>\";\n+\t\t    fAllFromMe = fAllFromMe && txin.IsMine();\n+\n+\t\tbool fAllToMe = true;\n \t\tforeach(const CTxOut& txout, wtx.vout)\n-\t\t    if (txout.IsMine())\n-\t\t\tstrHTML += _(\"<b>Credit:</b> \") + FormatMoney(txout.GetCredit()) + \"<br>\";\n+\t\t    fAllToMe = fAllToMe && txout.IsMine();\n+\n+\t\tif (fAllFromMe)\n+\t\t    {\n+\t\t\t//\n+\t\t\t// Debit\n+\t\t\t//\n+\t\t\tforeach(const CTxOut& txout, wtx.vout)\n+\t\t\t    {\n+\t\t\t\tif (txout.IsMine())\n+\t\t\t\t    continue;\n+\n+\t\t\t\tif (wtx.mapValue[\"to\"].empty())\n+\t\t\t\t    {\n+\t\t\t\t\t// Offline transaction\n+\t\t\t\t\tuint160 hash160;\n+\t\t\t\t\tif (ExtractHash160(txout.scriptPubKey, hash160))\n+\t\t\t\t\t    {\n+\t\t\t\t\t\tstring strAddress = Hash160ToAddress(hash160);\n+\t\t\t\t\t\tstrHTML += _(\"<b>To:</b> \");\n+\t\t\t\t\t\tif (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n+\t\t\t\t\t\t    strHTML += mapAddressBook[strAddress] + \" \";\n+\t\t\t\t\t\tstrHTML += strAddress;\n+\t\t\t\t\t\tstrHTML += \"<br>\";\n+\t\t\t\t\t    }\n+\t\t\t\t    }\n+\n+\t\t\t\tstrHTML += _(\"<b>Debit:</b> \") + FormatMoney(-txout.nValue) + \"<br>\";\n+\t\t\t    }\n+\n+\t\t\tif (fAllToMe)\n+\t\t\t    {\n+\t\t\t\t// Payment to self\n+\t\t\t\tint64 nChange = wtx.GetChange();\n+\t\t\t\tint64 nValue = nCredit - nChange;\n+\t\t\t\tstrHTML += _(\"<b>Debit:</b> \") + FormatMoney(-nValue) + \"<br>\";\n+\t\t\t\tstrHTML += _(\"<b>Credit:</b> \") + FormatMoney(nValue) + \"<br>\";\n+\t\t\t    }\n+\n+\t\t\tint64 nTxFee = nDebit - wtx.GetValueOut();\n+\t\t\tif (nTxFee > 0)\n+\t\t\t    strHTML += _(\"<b>Transaction fee:</b> \") + FormatMoney(-nTxFee) + \"<br>\";\n+\t\t    }\n+\t\telse\n+\t\t    {\n+\t\t\t//\n+\t\t\t// Mixed debit transaction\n+\t\t\t//\n+\t\t\tforeach(const CTxIn& txin, wtx.vin)\n+\t\t\t    if (txin.IsMine())\n+\t\t\t\tstrHTML += _(\"<b>Debit:</b> \") + FormatMoney(-txin.GetDebit()) + \"<br>\";\n+\t\t\tforeach(const CTxOut& txout, wtx.vout)\n+\t\t\t    if (txout.IsMine())\n+\t\t\t\tstrHTML += _(\"<b>Credit:</b> \") + FormatMoney(txout.GetCredit()) + \"<br>\";\n+\t\t    }\n \t    }\n-\t}\n \n \tstrHTML += _(\"<b>Net amount:</b> \") + FormatMoney(nNet, true) + \"<br>\";\n \n@@ -1416,38 +1416,38 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n \t// Debug view\n \t//\n \tif (fDebug)\n-\t{\n-\t    strHTML += \"<hr><br>debug print<br><br>\";\n-\t    foreach(const CTxIn& txin, wtx.vin)\n-\t\tif (txin.IsMine())\n-\t\t    strHTML += \"<b>Debit:</b> \" + FormatMoney(-txin.GetDebit()) + \"<br>\";\n-\t    foreach(const CTxOut& txout, wtx.vout)\n-\t\tif (txout.IsMine())\n-\t\t    strHTML += \"<b>Credit:</b> \" + FormatMoney(txout.GetCredit()) + \"<br>\";\n-\n-\t    strHTML += \"<br><b>Transaction:</b><br>\";\n-\t    strHTML += HtmlEscape(wtx.ToString(), true);\n-\n-\t    strHTML += \"<br><b>Inputs:</b><br>\";\n-\t    CRITICAL_BLOCK(cs_mapWallet)\n \t    {\n+\t\tstrHTML += \"<hr><br>debug print<br><br>\";\n \t\tforeach(const CTxIn& txin, wtx.vin)\n+\t\t    if (txin.IsMine())\n+\t\t\tstrHTML += \"<b>Debit:</b> \" + FormatMoney(-txin.GetDebit()) + \"<br>\";\n+\t\tforeach(const CTxOut& txout, wtx.vout)\n+\t\t    if (txout.IsMine())\n+\t\t\tstrHTML += \"<b>Credit:</b> \" + FormatMoney(txout.GetCredit()) + \"<br>\";\n+\n+\t\tstrHTML += \"<br><b>Transaction:</b><br>\";\n+\t\tstrHTML += HtmlEscape(wtx.ToString(), true);\n+\n+\t\tstrHTML += \"<br><b>Inputs:</b><br>\";\n+\t\tCRITICAL_BLOCK(cs_mapWallet)\n \t\t{\n-\t\t    COutPoint prevout = txin.prevout;\n-\t\t    map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n-\t\t    if (mi != mapWallet.end())\n-\t\t    {\n-\t\t\tconst CWalletTx& prev = (*mi).second;\n-\t\t\tif (prevout.n < prev.vout.size())\n+\t\t    foreach(const CTxIn& txin, wtx.vin)\n \t\t\t{\n-\t\t\t    strHTML += HtmlEscape(prev.ToString(), true);\n-\t\t\t    strHTML += \" &nbsp;&nbsp; \" + FormatTxStatus(prev) + \", \";\n-\t\t\t    strHTML = strHTML + \"IsMine=\" + (prev.vout[prevout.n].IsMine() ? \"true\" : \"false\") + \"<br>\";\n+\t\t\t    COutPoint prevout = txin.prevout;\n+\t\t\t    map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n+\t\t\t    if (mi != mapWallet.end())\n+\t\t\t\t{\n+\t\t\t\t    const CWalletTx& prev = (*mi).second;\n+\t\t\t\t    if (prevout.n < prev.vout.size())\n+\t\t\t\t\t{\n+\t\t\t\t\t    strHTML += HtmlEscape(prev.ToString(), true);\n+\t\t\t\t\t    strHTML += \" &nbsp;&nbsp; \" + FormatTxStatus(prev) + \", \";\n+\t\t\t\t\t    strHTML = strHTML + \"IsMine=\" + (prev.vout[prevout.n].IsMine() ? \"true\" : \"false\") + \"<br>\";\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t    }\n \t\t}\n \t    }\n-\t}\n \n \n \n@@ -1490,45 +1490,45 @@ void SetStartOnSystemStartup(bool fAutoStart)\n     remove(StartupShortcutPath().c_str());\n \n     if (fAutoStart)\n-    {\n-\tCoInitialize(NULL);\n-\n-\t// Get a pointer to the IShellLink interface.\n-\tIShellLink* psl = NULL;\n-\tHRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,\n-\t\t\t\tCLSCTX_INPROC_SERVER, IID_IShellLink,\n-\t\t\t\treinterpret_cast<void**>(&psl));\n-\n-\tif (SUCCEEDED(hres))\n-\t{\n-\t    // Get the current executable path\n-\t    TCHAR pszExePath[MAX_PATH];\n-\t    GetModuleFileName(NULL, pszExePath, sizeof(pszExePath));\n-\n-\t    // Set the path to the shortcut target\n-\t    psl->SetPath(pszExePath);\n-\t    PathRemoveFileSpec(pszExePath);\n-\t    psl->SetWorkingDirectory(pszExePath);\n-\t    psl->SetShowCmd(SW_SHOWMINNOACTIVE);\n-\n-\t    // Query IShellLink for the IPersistFile interface for\n-\t    // saving the shortcut in persistent storage.\n-\t    IPersistFile* ppf = NULL;\n-\t    hres = psl->QueryInterface(IID_IPersistFile,\n-\t\t\t\t       reinterpret_cast<void**>(&ppf));\n+\t{\n+\t    CoInitialize(NULL);\n+\n+\t    // Get a pointer to the IShellLink interface.\n+\t    IShellLink* psl = NULL;\n+\t    HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,\n+\t\t\t\t\t    CLSCTX_INPROC_SERVER, IID_IShellLink,\n+\t\t\t\t\t    reinterpret_cast<void**>(&psl));\n+\n \t    if (SUCCEEDED(hres))\n-\t    {\n-\t\tWCHAR pwsz[MAX_PATH];\n-\t\t// Ensure that the string is ANSI.\n-\t\tMultiByteToWideChar(CP_ACP, 0, StartupShortcutPath().c_str(), -1, pwsz, MAX_PATH);\n-\t\t// Save the link by calling IPersistFile::Save.\n-\t\thres = ppf->Save(pwsz, TRUE);\n-\t\tppf->Release();\n-\t    }\n-\t    psl->Release();\n+\t\t{\n+\t\t    // Get the current executable path\n+\t\t    TCHAR pszExePath[MAX_PATH];\n+\t\t    GetModuleFileName(NULL, pszExePath, sizeof(pszExePath));\n+\n+\t\t    // Set the path to the shortcut target\n+\t\t    psl->SetPath(pszExePath);\n+\t\t    PathRemoveFileSpec(pszExePath);\n+\t\t    psl->SetWorkingDirectory(pszExePath);\n+\t\t    psl->SetShowCmd(SW_SHOWMINNOACTIVE);\n+\n+\t\t    // Query IShellLink for the IPersistFile interface for\n+\t\t    // saving the shortcut in persistent storage.\n+\t\t    IPersistFile* ppf = NULL;\n+\t\t    hres = psl->QueryInterface(IID_IPersistFile,\n+\t\t\t\t\t       reinterpret_cast<void**>(&ppf));\n+\t\t    if (SUCCEEDED(hres))\n+\t\t\t{\n+\t\t\t    WCHAR pwsz[MAX_PATH];\n+\t\t\t    // Ensure that the string is ANSI.\n+\t\t\t    MultiByteToWideChar(CP_ACP, 0, StartupShortcutPath().c_str(), -1, pwsz, MAX_PATH);\n+\t\t\t    // Save the link by calling IPersistFile::Save.\n+\t\t\t    hres = ppf->Save(pwsz, TRUE);\n+\t\t\t    ppf->Release();\n+\t\t\t}\n+\t\t    psl->Release();\n+\t\t}\n+\t    CoUninitialize();\n \t}\n-\tCoUninitialize();\n-    }\n }\n \n #elif defined(__WXGTK__)\n@@ -1560,12 +1560,12 @@ bool GetStartOnSystemStartup()\n     // Scan through file for \"Hidden=true\":\n     string line;\n     while (!optionFile.eof())\n-    {\n-\tgetline(optionFile, line);\n-\tif (line.find(\"Hidden\") != string::npos &&\n-\t    line.find(\"true\") != string::npos)\n-\t    return false;\n-    }\n+\t{\n+\t    getline(optionFile, line);\n+\t    if (line.find(\"Hidden\") != string::npos &&\n+\t\tline.find(\"true\") != string::npos)\n+\t\treturn false;\n+\t}\n     optionFile.close();\n \n     return true;\n@@ -1574,33 +1574,33 @@ bool GetStartOnSystemStartup()\n void SetStartOnSystemStartup(bool fAutoStart)\n {\n     if (!fAutoStart)\n-    {\n-\tunlink(GetAutostartFilePath().native_file_string().c_str());\n-    }\n+\t{\n+\t    unlink(GetAutostartFilePath().native_file_string().c_str());\n+\t}\n     else\n-    {\n-\tchar pszExePath[MAX_PATH+1];\n-\tmemset(pszExePath, 0, sizeof(pszExePath));\n-\tif (readlink(\"/proc/self/exe\", pszExePath, sizeof(pszExePath)-1) == -1)\n-\t    return;\n+\t{\n+\t    char pszExePath[MAX_PATH+1];\n+\t    memset(pszExePath, 0, sizeof(pszExePath));\n+\t    if (readlink(\"/proc/self/exe\", pszExePath, sizeof(pszExePath)-1) == -1)\n+\t\treturn;\n \n-\tboost::filesystem::create_directories(GetAutostartDir());\n+\t    boost::filesystem::create_directories(GetAutostartDir());\n \n-\tboost::filesystem::ofstream optionFile(GetAutostartFilePath(), ios_base::out|ios_base::trunc);\n-\tif (!optionFile.good())\n-\t{\n-\t    wxMessageBox(_(\"Cannot write autostart/bitcoin.desktop file\"), \"Bitcoin\");\n-\t    return;\n+\t    boost::filesystem::ofstream optionFile(GetAutostartFilePath(), ios_base::out|ios_base::trunc);\n+\t    if (!optionFile.good())\n+\t\t{\n+\t\t    wxMessageBox(_(\"Cannot write autostart/bitcoin.desktop file\"), \"Bitcoin\");\n+\t\t    return;\n+\t\t}\n+\t    // Write a bitcoin.desktop file to the autostart directory:\n+\t    optionFile << \"[Desktop Entry]\\n\";\n+\t    optionFile << \"Type=Application\\n\";\n+\t    optionFile << \"Name=Bitcoin\\n\";\n+\t    optionFile << \"Exec=\" << pszExePath << \"\\n\";\n+\t    optionFile << \"Terminal=false\\n\";\n+\t    optionFile << \"Hidden=false\\n\";\n+\t    optionFile.close();\n \t}\n-\t// Write a bitcoin.desktop file to the autostart directory:\n-\toptionFile << \"[Desktop Entry]\\n\";\n-\toptionFile << \"Type=Application\\n\";\n-\toptionFile << \"Name=Bitcoin\\n\";\n-\toptionFile << \"Exec=\" << pszExePath << \"\\n\";\n-\toptionFile << \"Terminal=false\\n\";\n-\toptionFile << \"Hidden=false\\n\";\n-\toptionFile.close();\n-    }\n }\n #else\n \n@@ -1635,13 +1635,13 @@ COptionsDialog::COptionsDialog(wxWindow* parent) : COptionsDialogBase(parent)\n #if defined(__WXGTK__) || defined(__WXMAC_OSX__)\n     m_checkBoxStartOnSystemStartup->SetLabel(_(\"&Start Bitcoin on window system startup\"));\n     if (!GetBoolArg(\"-minimizetotray\"))\n-    {\n-\t// Minimize to tray is just too buggy on Linux\n-\tfMinimizeToTray = false;\n-\tm_checkBoxMinimizeToTray->SetValue(false);\n-\tm_checkBoxMinimizeToTray->Enable(false);\n-\tm_checkBoxMinimizeOnClose->SetLabel(_(\"&Minimize on close\"));\n-    }\n+\t{\n+\t    // Minimize to tray is just too buggy on Linux\n+\t    fMinimizeToTray = false;\n+\t    m_checkBoxMinimizeToTray->SetValue(false);\n+\t    m_checkBoxMinimizeToTray->Enable(false);\n+\t    m_checkBoxMinimizeOnClose->SetLabel(_(\"&Minimize on close\"));\n+\t}\n #endif\n #ifdef __WXMAC_OSX__\n     m_checkBoxStartOnSystemStartup->Enable(false); // not implemented yet\n@@ -1738,30 +1738,30 @@ void COptionsDialog::OnButtonApply(wxCommandEvent& event)\n \twalletdb.WriteSetting(\"nTransactionFee\", nTransactionFee);\n \n     if (fTmpStartOnSystemStartup != m_checkBoxStartOnSystemStartup->GetValue())\n-    {\n-\tfTmpStartOnSystemStartup = m_checkBoxStartOnSystemStartup->GetValue();\n-\tSetStartOnSystemStartup(fTmpStartOnSystemStartup);\n-    }\n+\t{\n+\t    fTmpStartOnSystemStartup = m_checkBoxStartOnSystemStartup->GetValue();\n+\t    SetStartOnSystemStartup(fTmpStartOnSystemStartup);\n+\t}\n \n     if (fMinimizeToTray != m_checkBoxMinimizeToTray->GetValue())\n-    {\n-\tfMinimizeToTray = m_checkBoxMinimizeToTray->GetValue();\n-\twalletdb.WriteSetting(\"fMinimizeToTray\", fMinimizeToTray);\n-\tptaskbaricon->Show(fMinimizeToTray || fClosedToTray);\n-    }\n+\t{\n+\t    fMinimizeToTray = m_checkBoxMinimizeToTray->GetValue();\n+\t    walletdb.WriteSetting(\"fMinimizeToTray\", fMinimizeToTray);\n+\t    ptaskbaricon->Show(fMinimizeToTray || fClosedToTray);\n+\t}\n \n     if (fMinimizeOnClose != m_checkBoxMinimizeOnClose->GetValue())\n-    {\n-\tfMinimizeOnClose = m_checkBoxMinimizeOnClose->GetValue();\n-\twalletdb.WriteSetting(\"fMinimizeOnClose\", fMinimizeOnClose);\n-    }\n+\t{\n+\t    fMinimizeOnClose = m_checkBoxMinimizeOnClose->GetValue();\n+\t    walletdb.WriteSetting(\"fMinimizeOnClose\", fMinimizeOnClose);\n+\t}\n \n     if (fHaveUPnP && fUseUPnP != m_checkBoxUseUPnP->GetValue())\n-    {\n-\tfUseUPnP = m_checkBoxUseUPnP->GetValue();\n-\twalletdb.WriteSetting(\"fUseUPnP\", fUseUPnP);\n-\tMapPort(fUseUPnP);\n-    }\n+\t{\n+\t    fUseUPnP = m_checkBoxUseUPnP->GetValue();\n+\t    walletdb.WriteSetting(\"fUseUPnP\", fUseUPnP);\n+\t    MapPort(fUseUPnP);\n+\t}\n \n     fUseProxy = m_checkBoxUseProxy->GetValue();\n     walletdb.WriteSetting(\"fUseProxy\", fUseProxy);\n@@ -1798,7 +1798,7 @@ CAboutDialog::CAboutDialog(wxWindow* parent) : CAboutDialogBase(parent)\n     // the wrap would be too small on Linux and it can't be changed at this point.\n     wxFont fontTmp = m_staticTextMain->GetFont();\n     if (fontTmp.GetPointSize() > 8);\n-\tfontTmp.SetPointSize(8);\n+    fontTmp.SetPointSize(8);\n     m_staticTextMain->SetFont(fontTmp);\n     SetSize(GetSize().GetWidth() + 44, GetSize().GetHeight() + 10);\n #endif\n@@ -1832,7 +1832,7 @@ CSendDialog::CSendDialog(wxWindow* parent, const wxString& strAddress) : CSendDi\n #ifndef __WXMSW__\n     wxFont fontTmp = m_staticTextInstructions->GetFont();\n     if (fontTmp.GetPointSize() > 9);\n-\tfontTmp.SetPointSize(9);\n+    fontTmp.SetPointSize(9);\n     m_staticTextInstructions->SetFont(fontTmp);\n     SetSize(725, 180);\n #endif\n@@ -1871,15 +1871,15 @@ void CSendDialog::OnButtonPaste(wxCommandEvent& event)\n {\n     // Copy clipboard to address box\n     if (wxTheClipboard->Open())\n-    {\n-\tif (wxTheClipboard->IsSupported(wxDF_TEXT))\n \t{\n-\t    wxTextDataObject data;\n-\t    wxTheClipboard->GetData(data);\n-\t    m_textCtrlAddress->SetValue(data.GetText());\n+\t    if (wxTheClipboard->IsSupported(wxDF_TEXT))\n+\t\t{\n+\t\t    wxTextDataObject data;\n+\t\t    wxTheClipboard->GetData(data);\n+\t\t    m_textCtrlAddress->SetValue(data.GetText());\n+\t\t}\n+\t    wxTheClipboard->Close();\n \t}\n-\twxTheClipboard->Close();\n-    }\n }\n \n void CSendDialog::OnButtonSend(wxCommandEvent& event)\n@@ -1892,65 +1892,65 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n \n \t// Parse amount\n \tint64 nValue = 0;\n-\tif (!ParseMoney(m_textCtrlAmount->GetValue(), nValue) || nValue <= 0)\n-\t{\n-\t    wxMessageBox(_(\"Error in amount  \"), _(\"Send Coins\"));\n-\t    return;\n-\t}\n+\tif (!ParseMoney(m_textCtrlAmount->GetValue(), nValue) || nValue <= 0)\n+\t    {\n+\t\twxMessageBox(_(\"Error in amount  \"), _(\"Send Coins\"));\n+\t\treturn;\n+\t    }\n \tif (nValue > GetBalance())\n-\t{\n-\t    wxMessageBox(_(\"Amount exceeds your balance  \"), _(\"Send Coins\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\twxMessageBox(_(\"Amount exceeds your balance  \"), _(\"Send Coins\"));\n+\t\treturn;\n+\t    }\n \tif (nValue + nTransactionFee > GetBalance())\n-\t{\n-\t    wxMessageBox(string(_(\"Total exceeds your balance when the \")) + FormatMoney(nTransactionFee) + _(\" transaction fee is included  \"), _(\"Send Coins\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\twxMessageBox(string(_(\"Total exceeds your balance when the \")) + FormatMoney(nTransactionFee) + _(\" transaction fee is included  \"), _(\"Send Coins\"));\n+\t\treturn;\n+\t    }\n \n \t// Parse bitcoin address\n \tuint160 hash160;\n \tbool fBitcoinAddress = AddressToHash160(strAddress, hash160);\n \n \tif (fBitcoinAddress)\n-\t{\n-\t    CRITICAL_BLOCK(cs_main)\n \t    {\n-\t\t// Send to bitcoin address\n-\t\tCScript scriptPubKey;\n-\t\tscriptPubKey << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n-\n-\t\tstring strError = SendMoney(scriptPubKey, nValue, wtx, true);\n-\t\tif (strError == \"\")\n-\t\t    wxMessageBox(_(\"Payment sent  \"), _(\"Sending...\"));\n-\t\telse if (strError == \"ABORTED\")\n-\t\t    return; // leave send dialog open\n-\t\telse\n+\t\tCRITICAL_BLOCK(cs_main)\n \t\t{\n-\t\t    wxMessageBox(strError + \"  \", _(\"Sending...\"));\n-\t\t    EndModal(false);\n-\t\t    return;\n+\t\t    // Send to bitcoin address\n+\t\t    CScript scriptPubKey;\n+\t\t    scriptPubKey << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+\t\t    string strError = SendMoney(scriptPubKey, nValue, wtx, true);\n+\t\t    if (strError == \"\")\n+\t\t\twxMessageBox(_(\"Payment sent  \"), _(\"Sending...\"));\n+\t\t    else if (strError == \"ABORTED\")\n+\t\t\treturn; // leave send dialog open\n+\t\t    else\n+\t\t\t{\n+\t\t\t    wxMessageBox(strError + \"  \", _(\"Sending...\"));\n+\t\t\t    EndModal(false);\n+\t\t\t    return;\n+\t\t\t}\n \t\t}\n \t    }\n-\t}\n \telse\n-\t{\n-\t    // Parse IP address\n-\t    CAddress addr(strAddress);\n-\t    if (!addr.IsValid())\n \t    {\n-\t\twxMessageBox(_(\"Invalid address  \"), _(\"Send Coins\"));\n-\t\treturn;\n-\t    }\n+\t\t// Parse IP address\n+\t\tCAddress addr(strAddress);\n+\t\tif (!addr.IsValid())\n+\t\t    {\n+\t\t\twxMessageBox(_(\"Invalid address  \"), _(\"Send Coins\"));\n+\t\t\treturn;\n+\t\t    }\n \n-\t    // Message\n-\t    wtx.mapValue[\"to\"] = strAddress;\n+\t\t// Message\n+\t\twtx.mapValue[\"to\"] = strAddress;\n \n-\t    // Send to IP address\n-\t    CSendingDialog* pdialog = new CSendingDialog(this, addr, nValue, wtx);\n-\t    if (!pdialog->ShowModal())\n-\t\treturn;\n-\t}\n+\t\t// Send to IP address\n+\t\tCSendingDialog* pdialog = new CSendingDialog(this, addr, nValue, wtx);\n+\t\tif (!pdialog->ShowModal())\n+\t\t    return;\n+\t    }\n \n \tCRITICAL_BLOCK(cs_mapAddressBook)\n \t    if (!mapAddressBook.count(strAddress))\n@@ -2024,15 +2024,15 @@ void CSendingDialog::Close()\n void CSendingDialog::OnClose(wxCloseEvent& event)\n {\n     if (!event.CanVeto() || fWorkDone || fAbort || !fCanCancel)\n-    {\n-\tClose();\n-    }\n+\t{\n+\t    Close();\n+\t}\n     else\n-    {\n-\tevent.Veto();\n-\twxCommandEvent cmdevent;\n-\tOnButtonCancel(cmdevent);\n-    }\n+\t{\n+\t    event.Veto();\n+\t    wxCommandEvent cmdevent;\n+\t    OnButtonCancel(cmdevent);\n+\t}\n }\n \n void CSendingDialog::OnButtonOK(wxCommandEvent& event)\n@@ -2058,21 +2058,21 @@ void CSendingDialog::OnPaint(wxPaintEvent& event)\n     if (!fCanCancel)\n \tm_buttonCancel->Enable(false);\n     if (fWorkDone)\n-    {\n-\tm_buttonOK->Enable(true);\n-\tm_buttonOK->SetFocus();\n-\tm_buttonCancel->Enable(false);\n-    }\n+\t{\n+\t    m_buttonOK->Enable(true);\n+\t    m_buttonOK->SetFocus();\n+\t    m_buttonCancel->Enable(false);\n+\t}\n     if (fAbort && fCanCancel && IsShown())\n-    {\n-\tstrcpy(pszStatus, _(\"CANCELLED\"));\n-\tm_buttonOK->Enable(true);\n-\tm_buttonOK->SetFocus();\n-\tm_buttonCancel->Enable(false);\n-\tm_buttonCancel->SetLabel(_(\"Cancelled\"));\n-\tClose();\n-\twxMessageBox(_(\"Transfer cancelled  \"), _(\"Sending...\"), wxOK, this);\n-    }\n+\t{\n+\t    strcpy(pszStatus, _(\"CANCELLED\"));\n+\t    m_buttonOK->Enable(true);\n+\t    m_buttonOK->SetFocus();\n+\t    m_buttonCancel->Enable(false);\n+\t    m_buttonCancel->SetLabel(_(\"Cancelled\"));\n+\t    Close();\n+\t    wxMessageBox(_(\"Transfer cancelled  \"), _(\"Sending...\"), wxOK, this);\n+\t}\n }\n \n \n@@ -2091,18 +2091,18 @@ void CSendingDialog::Repaint()\n bool CSendingDialog::Status()\n {\n     if (fUIDone)\n-    {\n-\tDestroy();\n-\treturn false;\n-    }\n+\t{\n+\t    Destroy();\n+\t    return false;\n+\t}\n     if (fAbort && fCanCancel)\n-    {\n-\tmemset(pszStatus, 0, 10);\n-\tstrcpy(pszStatus, _(\"CANCELLED\"));\n-\tRepaint();\n-\tfWorkDone = true;\n-\treturn false;\n-    }\n+\t{\n+\t    memset(pszStatus, 0, 10);\n+\t    strcpy(pszStatus, _(\"CANCELLED\"));\n+\t    Repaint();\n+\t    fWorkDone = true;\n+\t    return false;\n+\t}\n     return true;\n }\n \n@@ -2137,20 +2137,20 @@ void CSendingDialog::StartTransfer()\n {\n     // Make sure we have enough money\n     if (nPrice + nTransactionFee > GetBalance())\n-    {\n-\tError(_(\"Insufficient funds\"));\n-\treturn;\n-    }\n+\t{\n+\t    Error(_(\"Insufficient funds\"));\n+\t    return;\n+\t}\n \n     // We may have connected already for product details\n     if (!Status(_(\"Connecting...\")))\n \treturn;\n     CNode* pnode = ConnectNode(addr, 15 * 60);\n     if (!pnode)\n-    {\n-\tError(_(\"Unable to connect\"));\n-\treturn;\n-    }\n+\t{\n+\t    Error(_(\"Unable to connect\"));\n+\t    return;\n+\t}\n \n     // Send order to seller, with response going to OnReply2 via event handler\n     if (!Status(_(\"Requesting public key...\")))\n@@ -2171,94 +2171,94 @@ void CSendingDialog::OnReply2(CDataStream& vRecv)\n     CScript scriptPubKey;\n     int nRet;\n     try\n-    {\n-\tvRecv >> nRet;\n-\tif (nRet > 0)\n-\t{\n-\t    string strMessage;\n-\t    if (!vRecv.empty())\n-\t\tvRecv >> strMessage;\n-\t    if (nRet == 2)\n-\t\tError(_(\"Recipient is not accepting transactions sent by IP address\"));\n-\t    else\n-\t\tError(_(\"Transfer was not accepted\"));\n-\t    //// todo: enlarge the window and enable a hidden white box to put seller's message\n-\t    return;\n+\t{\n+\t    vRecv >> nRet;\n+\t    if (nRet > 0)\n+\t\t{\n+\t\t    string strMessage;\n+\t\t    if (!vRecv.empty())\n+\t\t\tvRecv >> strMessage;\n+\t\t    if (nRet == 2)\n+\t\t\tError(_(\"Recipient is not accepting transactions sent by IP address\"));\n+\t\t    else\n+\t\t\tError(_(\"Transfer was not accepted\"));\n+\t\t    //// todo: enlarge the window and enable a hidden white box to put seller's message\n+\t\t    return;\n+\t\t}\n+\t    vRecv >> scriptPubKey;\n \t}\n-\tvRecv >> scriptPubKey;\n-    }\n     catch (...)\n-    {\n-\t//// what do we want to do about this?\n-\tError(_(\"Invalid response received\"));\n-\treturn;\n-    }\n+\t{\n+\t    //// what do we want to do about this?\n+\t    Error(_(\"Invalid response received\"));\n+\t    return;\n+\t}\n \n     // Pause to give the user a chance to cancel\n     while (wxDateTime::UNow() < start + wxTimeSpan(0, 0, 0, 2 * 1000))\n-    {\n-\tSleep(200);\n-\tif (!Status())\n-\t    return;\n-    }\n+\t{\n+\t    Sleep(200);\n+\t    if (!Status())\n+\t\treturn;\n+\t}\n \n     CRITICAL_BLOCK(cs_main)\n     {\n \t// Pay\n \tif (!Status(_(\"Creating transaction...\")))\n \t    return;\n \tif (nPrice + nTransactionFee > GetBalance())\n-\t{\n-\t    Error(_(\"Insufficient funds\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\tError(_(\"Insufficient funds\"));\n+\t\treturn;\n+\t    }\n \tCReserveKey reservekey;\n \tint64 nFeeRequired;\n \tif (!CreateTransaction(scriptPubKey, nPrice, wtx, reservekey, nFeeRequired))\n-\t{\n-\t    if (nPrice + nFeeRequired > GetBalance())\n-\t\tError(strprintf(_(\"This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds\"), FormatMoney(nFeeRequired).c_str()));\n-\t    else\n-\t\tError(_(\"Transaction creation failed\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\tif (nPrice + nFeeRequired > GetBalance())\n+\t\t    Error(strprintf(_(\"This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds\"), FormatMoney(nFeeRequired).c_str()));\n+\t\telse\n+\t\t    Error(_(\"Transaction creation failed\"));\n+\t\treturn;\n+\t    }\n \n \t// Transaction fee\n \tif (!ThreadSafeAskFee(nFeeRequired, _(\"Sending...\"), this))\n-\t{\n-\t    Error(_(\"Transaction aborted\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\tError(_(\"Transaction aborted\"));\n+\t\treturn;\n+\t    }\n \n \t// Make sure we're still connected\n \tCNode* pnode = ConnectNode(addr, 2 * 60 * 60);\n \tif (!pnode)\n-\t{\n-\t    Error(_(\"Lost connection, transaction cancelled\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\tError(_(\"Lost connection, transaction cancelled\"));\n+\t\treturn;\n+\t    }\n \n \t// Last chance to cancel\n \tSleep(50);\n \tif (!Status())\n \t    return;\n \tfCanCancel = false;\n \tif (fAbort)\n-\t{\n-\t    fCanCancel = true;\n-\t    if (!Status())\n-\t\treturn;\n-\t    fCanCancel = false;\n-\t}\n+\t    {\n+\t\tfCanCancel = true;\n+\t\tif (!Status())\n+\t\t    return;\n+\t\tfCanCancel = false;\n+\t    }\n \tif (!Status(_(\"Sending payment...\")))\n \t    return;\n \n \t// Commit\n \tif (!CommitTransaction(wtx, reservekey))\n-\t{\n-\t    Error(_(\"The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n-\t    return;\n-\t}\n+\t    {\n+\t\tError(_(\"The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n+\t\treturn;\n+\t    }\n \n \t// Send payment tx to seller, with response going to OnReply3 via event handler\n \tCWalletTx wtxSend = wtx;\n@@ -2279,22 +2279,22 @@ void CSendingDialog::OnReply3(CDataStream& vRecv)\n {\n     int nRet;\n     try\n-    {\n-\tvRecv >> nRet;\n-\tif (nRet > 0)\n \t{\n-\t    Error(_(\"The payment was sent, but the recipient was unable to verify it.\\n\"\n-\t\t    \"The transaction is recorded and will credit to the recipient,\\n\"\n-\t\t    \"but the comment information will be blank.\"));\n-\t    return;\n+\t    vRecv >> nRet;\n+\t    if (nRet > 0)\n+\t\t{\n+\t\t    Error(_(\"The payment was sent, but the recipient was unable to verify it.\\n\"\n+\t\t\t    \"The transaction is recorded and will credit to the recipient,\\n\"\n+\t\t\t    \"but the comment information will be blank.\"));\n+\t\t    return;\n+\t\t}\n \t}\n-    }\n     catch (...)\n-    {\n-\t//// what do we want to do about this?\n-\tError(_(\"Payment was sent, but an invalid response was received\"));\n-\treturn;\n-    }\n+\t{\n+\t    //// what do we want to do about this?\n+\t    Error(_(\"Payment was sent, but an invalid response was received\"));\n+\t    return;\n+\t}\n \n     fSuccess = true;\n     fWorkDone = true;\n@@ -2338,21 +2338,21 @@ CAddressBookDialog::CAddressBookDialog(wxWindow* parent, const wxString& strInit\n \n     // Fill listctrl with address book data\n     CRITICAL_BLOCK(cs_mapKeys)\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n-    {\n-\tstring strDefaultReceiving = (string)pframeMain->m_textCtrlAddress->GetValue();\n-\tforeach(const PAIRTYPE(string, string)& item, mapAddressBook)\n+\tCRITICAL_BLOCK(cs_mapAddressBook)\n \t{\n-\t    string strAddress = item.first;\n-\t    string strName = item.second;\n-\t    uint160 hash160;\n-\t    bool fMine = (AddressToHash160(strAddress, hash160) && mapPubKeys.count(hash160));\n-\t    wxListCtrl* plistCtrl = fMine ? m_listCtrlReceiving : m_listCtrlSending;\n-\t    int nIndex = InsertLine(plistCtrl, strName, strAddress);\n-\t    if (strAddress == (fMine ? strDefaultReceiving : string(strInitSelected)))\n-\t\tplistCtrl->SetItemState(nIndex, wxLIST_STATE_SELECTED|wxLIST_STATE_FOCUSED, wxLIST_STATE_SELECTED|wxLIST_STATE_FOCUSED);\n+\t    string strDefaultReceiving = (string)pframeMain->m_textCtrlAddress->GetValue();\n+\t    foreach(const PAIRTYPE(string, string)& item, mapAddressBook)\n+\t\t{\n+\t\t    string strAddress = item.first;\n+\t\t    string strName = item.second;\n+\t\t    uint160 hash160;\n+\t\t    bool fMine = (AddressToHash160(strAddress, hash160) && mapPubKeys.count(hash160));\n+\t\t    wxListCtrl* plistCtrl = fMine ? m_listCtrlReceiving : m_listCtrlSending;\n+\t\t    int nIndex = InsertLine(plistCtrl, strName, strAddress);\n+\t\t    if (strAddress == (fMine ? strDefaultReceiving : string(strInitSelected)))\n+\t\t\tplistCtrl->SetItemState(nIndex, wxLIST_STATE_SELECTED|wxLIST_STATE_FOCUSED, wxLIST_STATE_SELECTED|wxLIST_STATE_FOCUSED);\n+\t\t}\n \t}\n-    }\n }\n \n wxString CAddressBookDialog::GetSelectedAddress()\n@@ -2415,11 +2415,11 @@ void CAddressBookDialog::OnListItemActivated(wxListEvent& event)\n {\n     event.Skip();\n     if (fDuringSend)\n-    {\n-\t// Doubleclick returns selection\n-\tEndModal(GetSelectedAddress() != \"\" ? 2 : 0);\n-\treturn;\n-    }\n+\t{\n+\t    // Doubleclick returns selection\n+\t    EndModal(GetSelectedAddress() != \"\" ? 2 : 0);\n+\t    return;\n+\t}\n \n     // Doubleclick edits item\n     wxCommandEvent event2;\n@@ -2431,25 +2431,25 @@ void CAddressBookDialog::OnButtonDelete(wxCommandEvent& event)\n     if (nPage != SENDING)\n \treturn;\n     for (int nIndex = m_listCtrl->GetItemCount()-1; nIndex >= 0; nIndex--)\n-    {\n-\tif (m_listCtrl->GetItemState(nIndex, wxLIST_STATE_SELECTED))\n \t{\n-\t    string strAddress = (string)GetItemText(m_listCtrl, nIndex, 1);\n-\t    CWalletDB().EraseName(strAddress);\n-\t    m_listCtrl->DeleteItem(nIndex);\n+\t    if (m_listCtrl->GetItemState(nIndex, wxLIST_STATE_SELECTED))\n+\t\t{\n+\t\t    string strAddress = (string)GetItemText(m_listCtrl, nIndex, 1);\n+\t\t    CWalletDB().EraseName(strAddress);\n+\t\t    m_listCtrl->DeleteItem(nIndex);\n+\t\t}\n \t}\n-    }\n     pframeMain->RefreshListCtrl();\n }\n \n void CAddressBookDialog::OnButtonCopy(wxCommandEvent& event)\n {\n     // Copy address box to clipboard\n     if (wxTheClipboard->Open())\n-    {\n-\twxTheClipboard->SetData(new wxTextDataObject(GetSelectedAddress()));\n-\twxTheClipboard->Close();\n-    }\n+\t{\n+\t    wxTheClipboard->SetData(new wxTextDataObject(GetSelectedAddress()));\n+\t    wxTheClipboard->Close();\n+\t}\n }\n \n bool CAddressBookDialog::CheckIfMine(const string& strAddress, const string& strTitle)\n@@ -2471,27 +2471,27 @@ void CAddressBookDialog::OnButtonEdit(wxCommandEvent& event)\n     string strAddressOrg = strAddress;\n \n     if (nPage == SENDING)\n-    {\n-\t// Ask name and address\n-\tdo\n \t{\n-\t    CGetTextFromUserDialog dialog(this, _(\"Edit Address\"), _(\"Name\"), strName, _(\"Address\"), strAddress);\n+\t    // Ask name and address\n+\t    do\n+\t\t{\n+\t\t    CGetTextFromUserDialog dialog(this, _(\"Edit Address\"), _(\"Name\"), strName, _(\"Address\"), strAddress);\n+\t\t    if (!dialog.ShowModal())\n+\t\t\treturn;\n+\t\t    strName = dialog.GetValue1();\n+\t\t    strAddress = dialog.GetValue2();\n+\t\t}\n+\t    while (CheckIfMine(strAddress, _(\"Edit Address\")));\n+\n+\t}\n+    else if (nPage == RECEIVING)\n+\t{\n+\t    // Ask name\n+\t    CGetTextFromUserDialog dialog(this, _(\"Edit Address Label\"), _(\"Label\"), strName);\n \t    if (!dialog.ShowModal())\n \t\treturn;\n-\t    strName = dialog.GetValue1();\n-\t    strAddress = dialog.GetValue2();\n+\t    strName = dialog.GetValue();\n \t}\n-\twhile (CheckIfMine(strAddress, _(\"Edit Address\")));\n-\n-    }\n-    else if (nPage == RECEIVING)\n-    {\n-\t// Ask name\n-\tCGetTextFromUserDialog dialog(this, _(\"Edit Address Label\"), _(\"Label\"), strName);\n-\tif (!dialog.ShowModal())\n-\t    return;\n-\tstrName = dialog.GetValue();\n-    }\n \n     // Write back\n     if (strAddress != strAddressOrg)\n@@ -2508,32 +2508,32 @@ void CAddressBookDialog::OnButtonNew(wxCommandEvent& event)\n     string strAddress;\n \n     if (nPage == SENDING)\n-    {\n-\t// Ask name and address\n-\tdo\n \t{\n-\t    CGetTextFromUserDialog dialog(this, _(\"Add Address\"), _(\"Name\"), strName, _(\"Address\"), strAddress);\n-\t    if (!dialog.ShowModal())\n-\t\treturn;\n-\t    strName = dialog.GetValue1();\n-\t    strAddress = dialog.GetValue2();\n+\t    // Ask name and address\n+\t    do\n+\t\t{\n+\t\t    CGetTextFromUserDialog dialog(this, _(\"Add Address\"), _(\"Name\"), strName, _(\"Address\"), strAddress);\n+\t\t    if (!dialog.ShowModal())\n+\t\t\treturn;\n+\t\t    strName = dialog.GetValue1();\n+\t\t    strAddress = dialog.GetValue2();\n+\t\t}\n+\t    while (CheckIfMine(strAddress, _(\"Add Address\")));\n \t}\n-\twhile (CheckIfMine(strAddress, _(\"Add Address\")));\n-    }\n     else if (nPage == RECEIVING)\n-    {\n-\t// Ask name\n-\tCGetTextFromUserDialog dialog(this,\n-\t    _(\"New Receiving Address\"),\n-\t    _(\"You should use a new address for each payment you receive.\\n\\nLabel\"),\n-\t    \"\");\n-\tif (!dialog.ShowModal())\n-\t    return;\n-\tstrName = dialog.GetValue();\n+\t{\n+\t    // Ask name\n+\t    CGetTextFromUserDialog dialog(this,\n+\t\t\t\t\t  _(\"New Receiving Address\"),\n+\t\t\t\t\t  _(\"You should use a new address for each payment you receive.\\n\\nLabel\"),\n+\t\t\t\t\t  \"\");\n+\t    if (!dialog.ShowModal())\n+\t\treturn;\n+\t    strName = dialog.GetValue();\n \n-\t// Generate new key\n-\tstrAddress = PubKeyToAddress(GetKeyFromKeyPool());\n-    }\n+\t    // Generate new key\n+\t    strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+\t}\n \n     // Add to list and select it\n     SetAddressBookName(strAddress, strName);\n@@ -2582,43 +2582,43 @@ enum\n };\n \n BEGIN_EVENT_TABLE(CMyTaskBarIcon, wxTaskBarIcon)\n-    EVT_TASKBAR_LEFT_DCLICK(CMyTaskBarIcon::OnLeftButtonDClick)\n-    EVT_MENU(ID_TASKBAR_RESTORE, CMyTaskBarIcon::OnMenuRestore)\n-    EVT_MENU(ID_TASKBAR_SEND, CMyTaskBarIcon::OnMenuSend)\n-    EVT_MENU(ID_TASKBAR_OPTIONS, CMyTaskBarIcon::OnMenuOptions)\n-    EVT_UPDATE_UI(ID_TASKBAR_GENERATE, CMyTaskBarIcon::OnUpdateUIGenerate)\n-    EVT_MENU(ID_TASKBAR_EXIT, CMyTaskBarIcon::OnMenuExit)\n+EVT_TASKBAR_LEFT_DCLICK(CMyTaskBarIcon::OnLeftButtonDClick)\n+EVT_MENU(ID_TASKBAR_RESTORE, CMyTaskBarIcon::OnMenuRestore)\n+EVT_MENU(ID_TASKBAR_SEND, CMyTaskBarIcon::OnMenuSend)\n+EVT_MENU(ID_TASKBAR_OPTIONS, CMyTaskBarIcon::OnMenuOptions)\n+EVT_UPDATE_UI(ID_TASKBAR_GENERATE, CMyTaskBarIcon::OnUpdateUIGenerate)\n+EVT_MENU(ID_TASKBAR_EXIT, CMyTaskBarIcon::OnMenuExit)\n END_EVENT_TABLE()\n \n void CMyTaskBarIcon::Show(bool fShow)\n {\n     static char pszPrevTip[200];\n     if (fShow)\n-    {\n-\tstring strTooltip = _(\"Bitcoin\");\n-\tif (fGenerateBitcoins)\n-\t    strTooltip = _(\"Bitcoin - Generating\");\n-\tif (fGenerateBitcoins && vNodes.empty())\n-\t    strTooltip = _(\"Bitcoin - (not connected)\");\n-\n-\t// Optimization, only update when changed, using char array to be reentrant\n-\tif (strncmp(pszPrevTip, strTooltip.c_str(), sizeof(pszPrevTip)-1) != 0)\n \t{\n-\t    strlcpy(pszPrevTip, strTooltip.c_str(), sizeof(pszPrevTip));\n+\t    string strTooltip = _(\"Bitcoin\");\n+\t    if (fGenerateBitcoins)\n+\t\tstrTooltip = _(\"Bitcoin - Generating\");\n+\t    if (fGenerateBitcoins && vNodes.empty())\n+\t\tstrTooltip = _(\"Bitcoin - (not connected)\");\n+\n+\t    // Optimization, only update when changed, using char array to be reentrant\n+\t    if (strncmp(pszPrevTip, strTooltip.c_str(), sizeof(pszPrevTip)-1) != 0)\n+\t\t{\n+\t\t    strlcpy(pszPrevTip, strTooltip.c_str(), sizeof(pszPrevTip));\n #ifdef __WXMSW__\n-\t    // somehow it'll choose the wrong size and scale it down if\n-\t    // we use the main icon, so we hand it one with only 16x16\n-\t    SetIcon(wxICON(favicon), strTooltip);\n+\t\t    // somehow it'll choose the wrong size and scale it down if\n+\t\t    // we use the main icon, so we hand it one with only 16x16\n+\t\t    SetIcon(wxICON(favicon), strTooltip);\n #else\n-\t    SetIcon(bitcoin80_xpm, strTooltip);\n+\t\t    SetIcon(bitcoin80_xpm, strTooltip);\n #endif\n+\t\t}\n \t}\n-    }\n     else\n-    {\n-\tstrlcpy(pszPrevTip, \"\", sizeof(pszPrevTip));\n-\tRemoveIcon();\n-    }\n+\t{\n+\t    strlcpy(pszPrevTip, \"\", sizeof(pszPrevTip));\n+\t    RemoveIcon();\n+\t}\n }\n \n void CMyTaskBarIcon::Hide()\n@@ -2751,55 +2751,55 @@ bool CMyApp::Initialize(int& argc, wxChar** argv)\n \t    fCommandLine = true;\n \n     if (!fCommandLine)\n-    {\n-\t// wxApp::Initialize will remove environment-specific parameters,\n-\t// so it's too early to call ParseParameters yet\n-\tfor (int i = 1; i < argc; i++)\n-\t{\n-\t    wxString str = argv[i];\n-\t    #ifdef __WXMSW__\n-\t    if (str.size() >= 1 && str[0] == '/')\n-\t\tstr[0] = '-';\n-\t    char pszLower[MAX_PATH];\n-\t    strlcpy(pszLower, str.c_str(), sizeof(pszLower));\n-\t    strlwr(pszLower);\n-\t    str = pszLower;\n-\t    #endif\n-\t    if (str == \"-daemon\")\n-\t\tfDaemon = true;\n+\t{\n+\t    // wxApp::Initialize will remove environment-specific parameters,\n+\t    // so it's too early to call ParseParameters yet\n+\t    for (int i = 1; i < argc; i++)\n+\t\t{\n+\t\t    wxString str = argv[i];\n+#ifdef __WXMSW__\n+\t\t    if (str.size() >= 1 && str[0] == '/')\n+\t\t\tstr[0] = '-';\n+\t\t    char pszLower[MAX_PATH];\n+\t\t    strlcpy(pszLower, str.c_str(), sizeof(pszLower));\n+\t\t    strlwr(pszLower);\n+\t\t    str = pszLower;\n+#endif\n+\t\t    if (str == \"-daemon\")\n+\t\t\tfDaemon = true;\n+\t\t}\n \t}\n-    }\n \n #ifdef __WXGTK__\n     if (fDaemon || fCommandLine)\n-    {\n-\t// Call the original Initialize while suppressing error messages\n-\t// and ignoring failure.  If unable to initialize GTK, it fails\n-\t// near the end so hopefully the last few things don't matter.\n-\t{\n-\t    wxLogNull logNo;\n-\t    wxApp::Initialize(argc, argv);\n-\t}\n-\n-\tif (fDaemon)\n \t{\n-\t    // Daemonize\n-\t    pid_t pid = fork();\n-\t    if (pid < 0)\n+\t    // Call the original Initialize while suppressing error messages\n+\t    // and ignoring failure.  If unable to initialize GTK, it fails\n+\t    // near the end so hopefully the last few things don't matter.\n \t    {\n-\t\tfprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n-\t\treturn false;\n+\t\twxLogNull logNo;\n+\t\twxApp::Initialize(argc, argv);\n \t    }\n-\t    if (pid > 0)\n-\t\tpthread_exit((void*)0);\n \n-\t    pid_t sid = setsid();\n-\t    if (sid < 0)\n-\t\tfprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n-\t}\n+\t    if (fDaemon)\n+\t\t{\n+\t\t    // Daemonize\n+\t\t    pid_t pid = fork();\n+\t\t    if (pid < 0)\n+\t\t\t{\n+\t\t\t    fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n+\t\t\t    return false;\n+\t\t\t}\n+\t\t    if (pid > 0)\n+\t\t\tpthread_exit((void*)0);\n \n-\treturn true;\n-    }\n+\t\t    pid_t sid = setsid();\n+\t\t    if (sid < 0)\n+\t\t\tfprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n+\t\t}\n+\n+\t    return true;\n+\t}\n #endif\n \n     return wxApp::Initialize(argc, argv);\n@@ -2854,47 +2854,47 @@ int CMyApp::OnExit()\n bool CMyApp::OnExceptionInMainLoop()\n {\n     try\n-    {\n-\tthrow;\n-    }\n+\t{\n+\t    throw;\n+\t}\n     catch (std::exception& e)\n-    {\n-\tPrintException(&e, \"CMyApp::OnExceptionInMainLoop()\");\n-\twxLogWarning(\"Exception %s %s\", typeid(e).name(), e.what());\n-\tSleep(1000);\n-\tthrow;\n-    }\n+\t{\n+\t    PrintException(&e, \"CMyApp::OnExceptionInMainLoop()\");\n+\t    wxLogWarning(\"Exception %s %s\", typeid(e).name(), e.what());\n+\t    Sleep(1000);\n+\t    throw;\n+\t}\n     catch (...)\n-    {\n-\tPrintException(NULL, \"CMyApp::OnExceptionInMainLoop()\");\n-\twxLogWarning(\"Unknown exception\");\n-\tSleep(1000);\n-\tthrow;\n-    }\n+\t{\n+\t    PrintException(NULL, \"CMyApp::OnExceptionInMainLoop()\");\n+\t    wxLogWarning(\"Unknown exception\");\n+\t    Sleep(1000);\n+\t    throw;\n+\t}\n     return true;\n }\n \n void CMyApp::OnUnhandledException()\n {\n     // this shows how we may let some exception propagate uncaught\n     try\n-    {\n-\tthrow;\n-    }\n+\t{\n+\t    throw;\n+\t}\n     catch (std::exception& e)\n-    {\n-\tPrintException(&e, \"CMyApp::OnUnhandledException()\");\n-\twxLogWarning(\"Exception %s %s\", typeid(e).name(), e.what());\n-\tSleep(1000);\n-\tthrow;\n-    }\n+\t{\n+\t    PrintException(&e, \"CMyApp::OnUnhandledException()\");\n+\t    wxLogWarning(\"Exception %s %s\", typeid(e).name(), e.what());\n+\t    Sleep(1000);\n+\t    throw;\n+\t}\n     catch (...)\n-    {\n-\tPrintException(NULL, \"CMyApp::OnUnhandledException()\");\n-\twxLogWarning(\"Unknown exception\");\n-\tSleep(1000);\n-\tthrow;\n-    }\n+\t{\n+\t    PrintException(NULL, \"CMyApp::OnUnhandledException()\");\n+\t    wxLogWarning(\"Unknown exception\");\n+\t    Sleep(1000);\n+\t    throw;\n+\t}\n }\n \n void CMyApp::OnFatalException()"
      },
      {
        "sha": "0e61f21c47a33e0e67c498587835ad1f867eafd1",
        "filename": "src/ui.h",
        "status": "modified",
        "additions": 23,
        "deletions": 18,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/ui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/ui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef UI_H\n+#define UI_H\n+\n DECLARE_EVENT_TYPE(wxEVT_UITHREADCALL, -1)\n \n \n@@ -75,12 +78,12 @@ class CMainFrame : public CMainFrameBase\n \n     // Custom\n     enum\n-    {\n-\tALL = 0,\n-\tSENTRECEIVED = 1,\n-\tSENT = 2,\n-\tRECEIVED = 3,\n-    };\n+\t{\n+\t    ALL = 0,\n+\t    SENTRECEIVED = 1,\n+\t    SENT = 2,\n+\t    RECEIVED = 3,\n+\t};\n     int nPage;\n     wxListCtrl* m_listCtrl;\n     bool fShowGenerated;\n@@ -246,10 +249,10 @@ class CAddressBookDialog : public CAddressBookDialogBase\n \n     // Custom\n     enum\n-    {\n-\tSENDING = 0,\n-\tRECEIVING = 1,\n-    };\n+\t{\n+\t    SENDING = 0,\n+\t    RECEIVING = 1,\n+\t};\n     int nPage;\n     wxListCtrl* m_listCtrl;\n     bool fDuringSend;\n@@ -293,13 +296,13 @@ class CGetTextFromUserDialog : public CGetTextFromUserDialogBase\n \tm_textCtrl1->SetValue(strValue1);\n \ty += wxString(strMessage1).Freq('\\n') * 14;\n \tif (!strMessage2.empty())\n-\t{\n-\t    m_staticTextMessage2->Show(true);\n-\t    m_staticTextMessage2->SetLabel(strMessage2);\n-\t    m_textCtrl2->Show(true);\n-\t    m_textCtrl2->SetValue(strValue2);\n-\t    y += 46 + wxString(strMessage2).Freq('\\n') * 14;\n-\t}\n+\t    {\n+\t\tm_staticTextMessage2->Show(true);\n+\t\tm_staticTextMessage2->SetLabel(strMessage2);\n+\t\tm_textCtrl2->Show(true);\n+\t\tm_textCtrl2->SetValue(strValue2);\n+\t\ty += 46 + wxString(strMessage2).Freq('\\n') * 14;\n+\t    }\n #ifndef __WXMSW__\n \tx = x * 114 / 100;\n \ty = y * 114 / 100;\n@@ -339,5 +342,7 @@ class CMyTaskBarIcon : public wxTaskBarIcon\n     void UpdateTooltip();\n     virtual wxMenu* CreatePopupMenu();\n \n-DECLARE_EVENT_TABLE()\n+    DECLARE_EVENT_TABLE()\n };\n+\n+#endif // !UI_H"
      },
      {
        "sha": "9c8a1067b33e215bc7b0d60d4c05eec7093bb2b3",
        "filename": "src/uibase.cpp",
        "status": "modified",
        "additions": 692,
        "deletions": 692,
        "changes": 1384,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/uibase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/uibase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uibase.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f"
      },
      {
        "sha": "4e078f222c17e9cbf63059ea9ccc55d36a843043",
        "filename": "src/uibase.h",
        "status": "modified",
        "additions": 228,
        "deletions": 228,
        "changes": 456,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/uibase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/uibase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uibase.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -68,62 +68,62 @@\n ///////////////////////////////////////////////////////////////////////////////\n class CMainFrameBase : public wxFrame\n {\n-\tprivate:\n-\n-\tprotected:\n-\t\twxMenuBar* m_menubar;\n-\t\twxMenu* m_menuFile;\n-\t\twxMenu* m_menuHelp;\n-\t\twxToolBar* m_toolBar;\n-\n-\t\twxStaticText* m_staticText32;\n-\t\twxButton* m_buttonNew;\n-\t\twxButton* m_buttonCopy;\n-\n-\t\twxStaticText* m_staticText41;\n-\t\twxStaticText* m_staticTextBalance;\n-\n-\t\twxChoice* m_choiceFilter;\n-\t\twxNotebook* m_notebook;\n-\t\twxPanel* m_panel9;\n-\t\twxPanel* m_panel91;\n-\t\twxPanel* m_panel92;\n-\t\twxPanel* m_panel93;\n-\n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnIconize( wxIconizeEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnIdle( wxIdleEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnMouseEvents( wxMouseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnPaint( wxPaintEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnMenuFileExit( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnMenuOptionsChangeYourAddress( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnMenuOptionsOptions( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnMenuHelpAbout( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonSend( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonAddressBook( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnMouseEventsAddress( wxMouseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnSetFocusAddress( wxFocusEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnNotebookPageChanged( wxNotebookEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListColBeginDrag( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnPaintListCtrl( wxPaintEvent& event ) { event.Skip(); }\n-\n-\n-\tpublic:\n-\t\twxMenu* m_menuOptions;\n-\t\twxStatusBar* m_statusBar;\n-\t\twxTextCtrl* m_textCtrlAddress;\n-\t\twxListCtrl* m_listCtrlAll;\n-\t\twxListCtrl* m_listCtrlSentReceived;\n-\t\twxListCtrl* m_listCtrlSent;\n-\t\twxListCtrl* m_listCtrlReceived;\n-\n-\t\tCMainFrameBase( wxWindow* parent, wxWindowID id = wxID_MAINFRAME, const wxString& title = _(\"Bitcoin\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 723,484 ), long style = wxDEFAULT_FRAME_STYLE|wxRESIZE_BORDER|wxTAB_TRAVERSAL );\n-\t\t~CMainFrameBase();\n+private:\n+\n+protected:\n+    wxMenuBar* m_menubar;\n+    wxMenu* m_menuFile;\n+    wxMenu* m_menuHelp;\n+    wxToolBar* m_toolBar;\n+\n+    wxStaticText* m_staticText32;\n+    wxButton* m_buttonNew;\n+    wxButton* m_buttonCopy;\n+\n+    wxStaticText* m_staticText41;\n+    wxStaticText* m_staticTextBalance;\n+\n+    wxChoice* m_choiceFilter;\n+    wxNotebook* m_notebook;\n+    wxPanel* m_panel9;\n+    wxPanel* m_panel91;\n+    wxPanel* m_panel92;\n+    wxPanel* m_panel93;\n+\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n+    virtual void OnIconize( wxIconizeEvent& event ) { event.Skip(); }\n+    virtual void OnIdle( wxIdleEvent& event ) { event.Skip(); }\n+    virtual void OnMouseEvents( wxMouseEvent& event ) { event.Skip(); }\n+    virtual void OnPaint( wxPaintEvent& event ) { event.Skip(); }\n+    virtual void OnMenuFileExit( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnMenuOptionsChangeYourAddress( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnMenuOptionsOptions( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnMenuHelpAbout( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonSend( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonAddressBook( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n+    virtual void OnMouseEventsAddress( wxMouseEvent& event ) { event.Skip(); }\n+    virtual void OnSetFocusAddress( wxFocusEvent& event ) { event.Skip(); }\n+    virtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnNotebookPageChanged( wxNotebookEvent& event ) { event.Skip(); }\n+    virtual void OnListColBeginDrag( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnPaintListCtrl( wxPaintEvent& event ) { event.Skip(); }\n+\n+\n+public:\n+    wxMenu* m_menuOptions;\n+    wxStatusBar* m_statusBar;\n+    wxTextCtrl* m_textCtrlAddress;\n+    wxListCtrl* m_listCtrlAll;\n+    wxListCtrl* m_listCtrlSentReceived;\n+    wxListCtrl* m_listCtrlSent;\n+    wxListCtrl* m_listCtrlReceived;\n+\n+    CMainFrameBase( wxWindow* parent, wxWindowID id = wxID_MAINFRAME, const wxString& title = _(\"Bitcoin\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 723,484 ), long style = wxDEFAULT_FRAME_STYLE|wxRESIZE_BORDER|wxTAB_TRAVERSAL );\n+    ~CMainFrameBase();\n \n };\n \n@@ -132,20 +132,20 @@ class CMainFrameBase : public wxFrame\n ///////////////////////////////////////////////////////////////////////////////\n class CTxDetailsDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n-\t\twxHtmlWindow* m_htmlWin;\n-\t\twxButton* m_buttonOK;\n+protected:\n+    wxHtmlWindow* m_htmlWin;\n+    wxButton* m_buttonOK;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n+public:\n \n-\t\tCTxDetailsDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Transaction Details\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 620,450 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n-\t\t~CTxDetailsDialogBase();\n+    CTxDetailsDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Transaction Details\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 620,450 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n+    ~CTxDetailsDialogBase();\n \n };\n \n@@ -154,50 +154,50 @@ class CTxDetailsDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class COptionsDialogBase : public wxDialog\n {\n-\tprivate:\n-\n-\tprotected:\n-\t\twxListBox* m_listBox;\n-\t\twxScrolledWindow* m_scrolledWindow;\n-\t\twxPanel* m_panelMain;\n-\n-\t\twxCheckBox* m_checkBoxStartOnSystemStartup;\n-\t\twxCheckBox* m_checkBoxMinimizeToTray;\n-\t\twxCheckBox* m_checkBoxUseUPnP;\n-\t\twxCheckBox* m_checkBoxMinimizeOnClose;\n-\t\twxCheckBox* m_checkBoxUseProxy;\n-\n-\t\twxStaticText* m_staticTextProxyIP;\n-\t\twxTextCtrl* m_textCtrlProxyIP;\n-\t\twxStaticText* m_staticTextProxyPort;\n-\t\twxTextCtrl* m_textCtrlProxyPort;\n-\n-\t\twxStaticText* m_staticText32;\n-\t\twxStaticText* m_staticText31;\n-\t\twxTextCtrl* m_textCtrlTransactionFee;\n-\t\twxPanel* m_panelTest2;\n-\n-\t\twxStaticText* m_staticText321;\n-\t\twxStaticText* m_staticText69;\n-\t\twxButton* m_buttonOK;\n-\t\twxButton* m_buttonCancel;\n-\t\twxButton* m_buttonApply;\n-\n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnListBox( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnCheckBoxMinimizeToTray( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnCheckBoxUseProxy( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnKillFocusProxy( wxFocusEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnKillFocusTransactionFee( wxFocusEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonApply( wxCommandEvent& event ) { event.Skip(); }\n-\n-\n-\tpublic:\n-\n-\t\tCOptionsDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Options\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 540,360 ), long style = wxDEFAULT_DIALOG_STYLE );\n-\t\t~COptionsDialogBase();\n+private:\n+\n+protected:\n+    wxListBox* m_listBox;\n+    wxScrolledWindow* m_scrolledWindow;\n+    wxPanel* m_panelMain;\n+\n+    wxCheckBox* m_checkBoxStartOnSystemStartup;\n+    wxCheckBox* m_checkBoxMinimizeToTray;\n+    wxCheckBox* m_checkBoxUseUPnP;\n+    wxCheckBox* m_checkBoxMinimizeOnClose;\n+    wxCheckBox* m_checkBoxUseProxy;\n+\n+    wxStaticText* m_staticTextProxyIP;\n+    wxTextCtrl* m_textCtrlProxyIP;\n+    wxStaticText* m_staticTextProxyPort;\n+    wxTextCtrl* m_textCtrlProxyPort;\n+\n+    wxStaticText* m_staticText32;\n+    wxStaticText* m_staticText31;\n+    wxTextCtrl* m_textCtrlTransactionFee;\n+    wxPanel* m_panelTest2;\n+\n+    wxStaticText* m_staticText321;\n+    wxStaticText* m_staticText69;\n+    wxButton* m_buttonOK;\n+    wxButton* m_buttonCancel;\n+    wxButton* m_buttonApply;\n+\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnListBox( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnCheckBoxMinimizeToTray( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnCheckBoxUseProxy( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnKillFocusProxy( wxFocusEvent& event ) { event.Skip(); }\n+    virtual void OnKillFocusTransactionFee( wxFocusEvent& event ) { event.Skip(); }\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonApply( wxCommandEvent& event ) { event.Skip(); }\n+\n+\n+public:\n+\n+    COptionsDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Options\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 540,360 ), long style = wxDEFAULT_DIALOG_STYLE );\n+    ~COptionsDialogBase();\n \n };\n \n@@ -206,27 +206,27 @@ class COptionsDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class CAboutDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n-\t\twxStaticBitmap* m_bitmap;\n+protected:\n+    wxStaticBitmap* m_bitmap;\n \n-\t\twxStaticText* m_staticText40;\n+    wxStaticText* m_staticText40;\n \n-\t\twxStaticText* m_staticTextMain;\n+    wxStaticText* m_staticTextMain;\n \n \n-\t\twxButton* m_buttonOK;\n+    wxButton* m_buttonOK;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n-\t\twxStaticText* m_staticTextVersion;\n+public:\n+    wxStaticText* m_staticTextVersion;\n \n-\t\tCAboutDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"About Bitcoin\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 532,333 ), long style = wxDEFAULT_DIALOG_STYLE );\n-\t\t~CAboutDialogBase();\n+    CAboutDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"About Bitcoin\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 532,333 ), long style = wxDEFAULT_DIALOG_STYLE );\n+    ~CAboutDialogBase();\n \n };\n \n@@ -235,42 +235,42 @@ class CAboutDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class CSendDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n+protected:\n \n \n-\t\twxStaticText* m_staticTextInstructions;\n+    wxStaticText* m_staticTextInstructions;\n \n-\t\twxStaticBitmap* m_bitmapCheckMark;\n-\t\twxStaticText* m_staticText36;\n-\t\twxTextCtrl* m_textCtrlAddress;\n-\t\twxButton* m_buttonPaste;\n-\t\twxButton* m_buttonAddress;\n-\t\twxStaticText* m_staticText19;\n-\t\twxTextCtrl* m_textCtrlAmount;\n-\t\twxStaticText* m_staticText20;\n-\t\twxChoice* m_choiceTransferType;\n+    wxStaticBitmap* m_bitmapCheckMark;\n+    wxStaticText* m_staticText36;\n+    wxTextCtrl* m_textCtrlAddress;\n+    wxButton* m_buttonPaste;\n+    wxButton* m_buttonAddress;\n+    wxStaticText* m_staticText19;\n+    wxTextCtrl* m_textCtrlAmount;\n+    wxStaticText* m_staticText20;\n+    wxChoice* m_choiceTransferType;\n \n \n \n-\t\twxButton* m_buttonSend;\n-\t\twxButton* m_buttonCancel;\n+    wxButton* m_buttonSend;\n+    wxButton* m_buttonCancel;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnTextAddress( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonPaste( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonAddressBook( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnKillFocusAmount( wxFocusEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonSend( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n+    virtual void OnTextAddress( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonPaste( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonAddressBook( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnKillFocusAmount( wxFocusEvent& event ) { event.Skip(); }\n+    virtual void OnButtonSend( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n+public:\n \n-\t\tCSendDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Send Coins\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 498,157 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n-\t\t~CSendDialogBase();\n+    CSendDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Send Coins\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 498,157 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n+    ~CSendDialogBase();\n \n };\n \n@@ -279,26 +279,26 @@ class CSendDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class CSendingDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n-\t\twxStaticText* m_staticTextSending;\n-\t\twxTextCtrl* m_textCtrlStatus;\n+protected:\n+    wxStaticText* m_staticTextSending;\n+    wxTextCtrl* m_textCtrlStatus;\n \n-\t\twxButton* m_buttonOK;\n-\t\twxButton* m_buttonCancel;\n+    wxButton* m_buttonOK;\n+    wxButton* m_buttonCancel;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnPaint( wxPaintEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n+    virtual void OnPaint( wxPaintEvent& event ) { event.Skip(); }\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n+public:\n \n-\t\tCSendingDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Sending...\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 442,151 ), long style = wxDEFAULT_DIALOG_STYLE );\n-\t\t~CSendingDialogBase();\n+    CSendingDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Sending...\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 442,151 ), long style = wxDEFAULT_DIALOG_STYLE );\n+    ~CSendingDialogBase();\n \n };\n \n@@ -307,35 +307,35 @@ class CSendingDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class CYourAddressDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n+protected:\n \n-\t\twxStaticText* m_staticText45;\n-\t\twxListCtrl* m_listCtrl;\n+    wxStaticText* m_staticText45;\n+    wxListCtrl* m_listCtrl;\n \n-\t\twxButton* m_buttonRename;\n-\t\twxButton* m_buttonNew;\n-\t\twxButton* m_buttonCopy;\n-\t\twxButton* m_buttonOK;\n-\t\twxButton* m_buttonCancel;\n+    wxButton* m_buttonRename;\n+    wxButton* m_buttonNew;\n+    wxButton* m_buttonCopy;\n+    wxButton* m_buttonOK;\n+    wxButton* m_buttonCancel;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListEndLabelEdit( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListItemSelected( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonRename( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n+    virtual void OnListEndLabelEdit( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnListItemSelected( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnButtonRename( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n+public:\n \n-\t\tCYourAddressDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Your Bitcoin Addresses\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 610,390 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n-\t\t~CYourAddressDialogBase();\n+    CYourAddressDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Your Bitcoin Addresses\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 610,390 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n+    ~CYourAddressDialogBase();\n \n };\n \n@@ -344,45 +344,45 @@ class CYourAddressDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class CAddressBookDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n-\t\twxNotebook* m_notebook;\n-\t\twxPanel* m_panelSending;\n+protected:\n+    wxNotebook* m_notebook;\n+    wxPanel* m_panelSending;\n \n-\t\twxStaticText* m_staticText55;\n-\t\twxListCtrl* m_listCtrlSending;\n-\t\twxPanel* m_panelReceiving;\n+    wxStaticText* m_staticText55;\n+    wxListCtrl* m_listCtrlSending;\n+    wxPanel* m_panelReceiving;\n \n-\t\twxStaticText* m_staticText45;\n+    wxStaticText* m_staticText45;\n \n-\t\twxListCtrl* m_listCtrlReceiving;\n+    wxListCtrl* m_listCtrlReceiving;\n \n-\t\twxButton* m_buttonDelete;\n-\t\twxButton* m_buttonCopy;\n-\t\twxButton* m_buttonEdit;\n-\t\twxButton* m_buttonNew;\n-\t\twxButton* m_buttonOK;\n+    wxButton* m_buttonDelete;\n+    wxButton* m_buttonCopy;\n+    wxButton* m_buttonEdit;\n+    wxButton* m_buttonNew;\n+    wxButton* m_buttonOK;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnNotebookPageChanged( wxNotebookEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListEndLabelEdit( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnListItemSelected( wxListEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonDelete( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonEdit( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n+    virtual void OnNotebookPageChanged( wxNotebookEvent& event ) { event.Skip(); }\n+    virtual void OnListEndLabelEdit( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnListItemActivated( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnListItemSelected( wxListEvent& event ) { event.Skip(); }\n+    virtual void OnButtonDelete( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCopy( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonEdit( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonNew( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n-\t\twxButton* m_buttonCancel;\n+public:\n+    wxButton* m_buttonCancel;\n \n-\t\tCAddressBookDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Address Book\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 610,390 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n-\t\t~CAddressBookDialogBase();\n+    CAddressBookDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _(\"Address Book\"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 610,390 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );\n+    ~CAddressBookDialogBase();\n \n };\n \n@@ -391,30 +391,30 @@ class CAddressBookDialogBase : public wxDialog\n ///////////////////////////////////////////////////////////////////////////////\n class CGetTextFromUserDialogBase : public wxDialog\n {\n-\tprivate:\n+private:\n \n-\tprotected:\n+protected:\n \n-\t\twxStaticText* m_staticTextMessage1;\n-\t\twxTextCtrl* m_textCtrl1;\n-\t\twxStaticText* m_staticTextMessage2;\n-\t\twxTextCtrl* m_textCtrl2;\n+    wxStaticText* m_staticTextMessage1;\n+    wxTextCtrl* m_textCtrl1;\n+    wxStaticText* m_staticTextMessage2;\n+    wxTextCtrl* m_textCtrl2;\n \n \n-\t\twxButton* m_buttonOK;\n-\t\twxButton* m_buttonCancel;\n+    wxButton* m_buttonOK;\n+    wxButton* m_buttonCancel;\n \n-\t\t// Virtual event handlers, overide them in your derived class\n-\t\tvirtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n-\t\tvirtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n+    // Virtual event handlers, overide them in your derived class\n+    virtual void OnClose( wxCloseEvent& event ) { event.Skip(); }\n+    virtual void OnKeyDown( wxKeyEvent& event ) { event.Skip(); }\n+    virtual void OnButtonOK( wxCommandEvent& event ) { event.Skip(); }\n+    virtual void OnButtonCancel( wxCommandEvent& event ) { event.Skip(); }\n \n \n-\tpublic:\n+public:\n \n-\t\tCGetTextFromUserDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = wxEmptyString, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 440,138 ), long style = wxDEFAULT_DIALOG_STYLE );\n-\t\t~CGetTextFromUserDialogBase();\n+    CGetTextFromUserDialogBase( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = wxEmptyString, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 440,138 ), long style = wxDEFAULT_DIALOG_STYLE );\n+    ~CGetTextFromUserDialogBase();\n \n };\n "
      },
      {
        "sha": "44f218865a3d11f6a49f99d0d4a27356d4a0dda8",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 69,
        "deletions": 64,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef UINT256_H\n+#define UINT256_H\n+\n #include <limits.h>\n #include <string>\n #if defined(_MSC_VER) || defined(__BORLANDC__)\n@@ -115,12 +118,12 @@ class base_uint\n \tint k = shift / 32;\n \tshift = shift % 32;\n \tfor (int i = 0; i < WIDTH; i++)\n-\t{\n-\t    if (i+k+1 < WIDTH && shift != 0)\n-\t\tpn[i+k+1] |= (a.pn[i] >> (32-shift));\n-\t    if (i+k < WIDTH)\n-\t\tpn[i+k] |= (a.pn[i] << shift);\n-\t}\n+\t    {\n+\t\tif (i+k+1 < WIDTH && shift != 0)\n+\t\t    pn[i+k+1] |= (a.pn[i] >> (32-shift));\n+\t\tif (i+k < WIDTH)\n+\t\t    pn[i+k] |= (a.pn[i] << shift);\n+\t    }\n \treturn *this;\n     }\n \n@@ -132,24 +135,24 @@ class base_uint\n \tint k = shift / 32;\n \tshift = shift % 32;\n \tfor (int i = 0; i < WIDTH; i++)\n-\t{\n-\t    if (i-k-1 >= 0 && shift != 0)\n-\t\tpn[i-k-1] |= (a.pn[i] << (32-shift));\n-\t    if (i-k >= 0)\n-\t\tpn[i-k] |= (a.pn[i] >> shift);\n-\t}\n+\t    {\n+\t\tif (i-k-1 >= 0 && shift != 0)\n+\t\t    pn[i-k-1] |= (a.pn[i] << (32-shift));\n+\t\tif (i-k >= 0)\n+\t\t    pn[i-k] |= (a.pn[i] >> shift);\n+\t    }\n \treturn *this;\n     }\n \n     base_uint& operator+=(const base_uint& b)\n     {\n \tuint64 carry = 0;\n \tfor (int i = 0; i < WIDTH; i++)\n-\t{\n-\t    uint64 n = carry + pn[i] + b.pn[i];\n-\t    pn[i] = n & 0xffffffff;\n-\t    carry = n >> 32;\n-\t}\n+\t    {\n+\t\tuint64 n = carry + pn[i] + b.pn[i];\n+\t\tpn[i] = n & 0xffffffff;\n+\t\tcarry = n >> 32;\n+\t    }\n \treturn *this;\n     }\n \n@@ -214,48 +217,48 @@ class base_uint\n     friend inline bool operator<(const base_uint& a, const base_uint& b)\n     {\n \tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n-\t{\n-\t    if (a.pn[i] < b.pn[i])\n-\t\treturn true;\n-\t    else if (a.pn[i] > b.pn[i])\n-\t\treturn false;\n-\t}\n+\t    {\n+\t\tif (a.pn[i] < b.pn[i])\n+\t\t    return true;\n+\t\telse if (a.pn[i] > b.pn[i])\n+\t\t    return false;\n+\t    }\n \treturn false;\n     }\n \n     friend inline bool operator<=(const base_uint& a, const base_uint& b)\n     {\n \tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n-\t{\n-\t    if (a.pn[i] < b.pn[i])\n-\t\treturn true;\n-\t    else if (a.pn[i] > b.pn[i])\n-\t\treturn false;\n-\t}\n+\t    {\n+\t\tif (a.pn[i] < b.pn[i])\n+\t\t    return true;\n+\t\telse if (a.pn[i] > b.pn[i])\n+\t\t    return false;\n+\t    }\n \treturn true;\n     }\n \n     friend inline bool operator>(const base_uint& a, const base_uint& b)\n     {\n \tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n-\t{\n-\t    if (a.pn[i] > b.pn[i])\n-\t\treturn true;\n-\t    else if (a.pn[i] < b.pn[i])\n-\t\treturn false;\n-\t}\n+\t    {\n+\t\tif (a.pn[i] > b.pn[i])\n+\t\t    return true;\n+\t\telse if (a.pn[i] < b.pn[i])\n+\t\t    return false;\n+\t    }\n \treturn false;\n     }\n \n     friend inline bool operator>=(const base_uint& a, const base_uint& b)\n     {\n \tfor (int i = base_uint::WIDTH-1; i >= 0; i--)\n-\t{\n-\t    if (a.pn[i] > b.pn[i])\n-\t\treturn true;\n-\t    else if (a.pn[i] < b.pn[i])\n-\t\treturn false;\n-\t}\n+\t    {\n+\t\tif (a.pn[i] > b.pn[i])\n+\t\t    return true;\n+\t\telse if (a.pn[i] < b.pn[i])\n+\t\t    return false;\n+\t    }\n \treturn true;\n     }\n \n@@ -321,14 +324,14 @@ class base_uint\n \tunsigned char* p1 = (unsigned char*)pn;\n \tunsigned char* pend = p1 + WIDTH * 4;\n \twhile (psz >= pbegin && p1 < pend)\n-\t{\n-\t    *p1 = phexdigit[(unsigned char)*psz--];\n-\t    if (psz >= pbegin)\n \t    {\n-\t\t*p1 |= (phexdigit[(unsigned char)*psz--] << 4);\n-\t\tp1++;\n+\t\t*p1 = phexdigit[(unsigned char)*psz--];\n+\t\tif (psz >= pbegin)\n+\t\t    {\n+\t\t\t*p1 |= (phexdigit[(unsigned char)*psz--] << 4);\n+\t\t\tp1++;\n+\t\t    }\n \t    }\n-\t}\n     }\n \n     void SetHex(const std::string& str)\n@@ -726,32 +729,34 @@ inline int Testuint256AdHoc(vector<string> vArg)\n     uint256 x2;\n     printf(\"%s\\n\", x1.ToString().c_str());\n     for (int i = 0; i < 270; i += 4)\n-    {\n-\tx2 = x1 << i;\n-\tprintf(\"%s\\n\", x2.ToString().c_str());\n-    }\n+\t{\n+\t    x2 = x1 << i;\n+\t    printf(\"%s\\n\", x2.ToString().c_str());\n+\t}\n \n     printf(\"\\n\");\n     printf(\"%s\\n\", x1.ToString().c_str());\n     for (int i = 0; i < 270; i += 4)\n-    {\n-\tx2 = x1;\n-\tx2 >>= i;\n-\tprintf(\"%s\\n\", x2.ToString().c_str());\n-    }\n+\t{\n+\t    x2 = x1;\n+\t    x2 >>= i;\n+\t    printf(\"%s\\n\", x2.ToString().c_str());\n+\t}\n \n \n     for (int i = 0; i < 100; i++)\n-    {\n-\tuint256 k = (~uint256(0) >> i);\n-\tprintf(\"%s\\n\", k.ToString().c_str());\n-    }\n+\t{\n+\t    uint256 k = (~uint256(0) >> i);\n+\t    printf(\"%s\\n\", k.ToString().c_str());\n+\t}\n \n     for (int i = 0; i < 100; i++)\n-    {\n-\tuint256 k = (~uint256(0) << i);\n-\tprintf(\"%s\\n\", k.ToString().c_str());\n-    }\n+\t{\n+\t    uint256 k = (~uint256(0) << i);\n+\t    printf(\"%s\\n\", k.ToString().c_str());\n+\t}\n \n     return (0);\n }\n+\n+#endif // !UINT256_H"
      },
      {
        "sha": "77c9df5c195b325c09728cddeacd2c82e3603291",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 278,
        "deletions": 278,
        "changes": 556,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -71,7 +71,7 @@ class CInit\n \tOPENSSL_free(ppmutexOpenSSL);\n     }\n }\n-instance_of_cinit;\n+    instance_of_cinit;\n \n \n \n@@ -107,11 +107,11 @@ void RandAddSeedPerfmon()\n     long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n     RegCloseKey(HKEY_PERFORMANCE_DATA);\n     if (ret == ERROR_SUCCESS)\n-    {\n-\tRAND_add(pdata, nSize, nSize/100.0);\n-\tmemset(pdata, 0, nSize);\n-\tprintf(\"%s RandAddSeed() %d bytes\\n\", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str(), nSize);\n-    }\n+\t{\n+\t    RAND_add(pdata, nSize, nSize/100.0);\n+\t    memset(pdata, 0, nSize);\n+\t    printf(\"%s RandAddSeed() %d bytes\\n\", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str(), nSize);\n+\t}\n #endif\n }\n \n@@ -149,86 +149,86 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n {\n     int ret = 0;\n     if (fPrintToConsole)\n-    {\n-\t// print to console\n-\tva_list arg_ptr;\n-\tva_start(arg_ptr, pszFormat);\n-\tret = vprintf(pszFormat, arg_ptr);\n-\tva_end(arg_ptr);\n-    }\n-    else\n-    {\n-\t// print to debug.log\n-\tstatic FILE* fileout = NULL;\n-\n-\tif (!fileout)\n \t{\n-\t    char pszFile[MAX_PATH+100];\n-\t    GetDataDir(pszFile);\n-\t    strlcat(pszFile, \"/debug.log\", sizeof(pszFile));\n-\t    fileout = fopen(pszFile, \"a\");\n-\t    if (fileout) setbuf(fileout, NULL); // unbuffered\n-\t}\n-\tif (fileout)\n-\t{\n-\t    static bool fStartedNewLine = true;\n-\n-\t    // Debug print useful for profiling\n-\t    if (fLogTimestamps && fStartedNewLine)\n-\t\tfprintf(fileout, \"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-\t    if (pszFormat[strlen(pszFormat) - 1] == '\\n')\n-\t\tfStartedNewLine = true;\n-\t    else\n-\t\tfStartedNewLine = false;\n-\n+\t    // print to console\n \t    va_list arg_ptr;\n \t    va_start(arg_ptr, pszFormat);\n-\t    ret = vfprintf(fileout, pszFormat, arg_ptr);\n+\t    ret = vprintf(pszFormat, arg_ptr);\n \t    va_end(arg_ptr);\n \t}\n-    }\n+    else\n+\t{\n+\t    // print to debug.log\n+\t    static FILE* fileout = NULL;\n+\n+\t    if (!fileout)\n+\t\t{\n+\t\t    char pszFile[MAX_PATH+100];\n+\t\t    GetDataDir(pszFile);\n+\t\t    strlcat(pszFile, \"/debug.log\", sizeof(pszFile));\n+\t\t    fileout = fopen(pszFile, \"a\");\n+\t\t    if (fileout) setbuf(fileout, NULL); // unbuffered\n+\t\t}\n+\t    if (fileout)\n+\t\t{\n+\t\t    static bool fStartedNewLine = true;\n+\n+\t\t    // Debug print useful for profiling\n+\t\t    if (fLogTimestamps && fStartedNewLine)\n+\t\t\tfprintf(fileout, \"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+\t\t    if (pszFormat[strlen(pszFormat) - 1] == '\\n')\n+\t\t\tfStartedNewLine = true;\n+\t\t    else\n+\t\t\tfStartedNewLine = false;\n+\n+\t\t    va_list arg_ptr;\n+\t\t    va_start(arg_ptr, pszFormat);\n+\t\t    ret = vfprintf(fileout, pszFormat, arg_ptr);\n+\t\t    va_end(arg_ptr);\n+\t\t}\n+\t}\n \n #ifdef __WXMSW__\n     if (fPrintToDebugger)\n-    {\n-\tstatic CCriticalSection cs_OutputDebugStringF;\n-\n-\t// accumulate a line at a time\n-\tCRITICAL_BLOCK(cs_OutputDebugStringF)\n \t{\n-\t    static char pszBuffer[50000];\n-\t    static char* pend;\n-\t    if (pend == NULL)\n-\t\tpend = pszBuffer;\n-\t    va_list arg_ptr;\n-\t    va_start(arg_ptr, pszFormat);\n-\t    int limit = END(pszBuffer) - pend - 2;\n-\t    int ret = _vsnprintf(pend, limit, pszFormat, arg_ptr);\n-\t    va_end(arg_ptr);\n-\t    if (ret < 0 || ret >= limit)\n-\t    {\n-\t\tpend = END(pszBuffer) - 2;\n-\t\t*pend++ = '\\n';\n-\t    }\n-\t    else\n-\t\tpend += ret;\n-\t    *pend = '\\0';\n-\t    char* p1 = pszBuffer;\n-\t    char* p2;\n-\t    while (p2 = strchr(p1, '\\n'))\n+\t    static CCriticalSection cs_OutputDebugStringF;\n+\n+\t    // accumulate a line at a time\n+\t    CRITICAL_BLOCK(cs_OutputDebugStringF)\n \t    {\n-\t\tp2++;\n-\t\tchar c = *p2;\n-\t\t*p2 = '\\0';\n-\t\tOutputDebugStringA(p1);\n-\t\t*p2 = c;\n-\t\tp1 = p2;\n+\t\tstatic char pszBuffer[50000];\n+\t\tstatic char* pend;\n+\t\tif (pend == NULL)\n+\t\t    pend = pszBuffer;\n+\t\tva_list arg_ptr;\n+\t\tva_start(arg_ptr, pszFormat);\n+\t\tint limit = END(pszBuffer) - pend - 2;\n+\t\tint ret = _vsnprintf(pend, limit, pszFormat, arg_ptr);\n+\t\tva_end(arg_ptr);\n+\t\tif (ret < 0 || ret >= limit)\n+\t\t    {\n+\t\t\tpend = END(pszBuffer) - 2;\n+\t\t\t*pend++ = '\\n';\n+\t\t    }\n+\t\telse\n+\t\t    pend += ret;\n+\t\t*pend = '\\0';\n+\t\tchar* p1 = pszBuffer;\n+\t\tchar* p2;\n+\t\twhile (p2 = strchr(p1, '\\n'))\n+\t\t    {\n+\t\t\tp2++;\n+\t\t\tchar c = *p2;\n+\t\t\t*p2 = '\\0';\n+\t\t\tOutputDebugStringA(p1);\n+\t\t\t*p2 = c;\n+\t\t\tp1 = p2;\n+\t\t    }\n+\t\tif (p1 != pszBuffer)\n+\t\t    memmove(pszBuffer, p1, pend - p1 + 1);\n+\t\tpend -= (p1 - pszBuffer);\n \t    }\n-\t    if (p1 != pszBuffer)\n-\t\tmemmove(pszBuffer, p1, pend - p1 + 1);\n-\t    pend -= (p1 - pszBuffer);\n \t}\n-    }\n #endif\n     return ret;\n }\n@@ -247,10 +247,10 @@ int my_snprintf(char* buffer, size_t limit, const char* format, ...)\n     int ret = _vsnprintf(buffer, limit, format, arg_ptr);\n     va_end(arg_ptr);\n     if (ret < 0 || ret >= limit)\n-    {\n-\tret = limit - 1;\n-\tbuffer[limit-1] = 0;\n-    }\n+\t{\n+\t    ret = limit - 1;\n+\t    buffer[limit-1] = 0;\n+\t}\n     return ret;\n }\n \n@@ -262,20 +262,20 @@ string strprintf(const char* format, ...)\n     int limit = sizeof(buffer);\n     int ret;\n     loop\n-    {\n-\tva_list arg_ptr;\n-\tva_start(arg_ptr, format);\n-\tret = _vsnprintf(p, limit, format, arg_ptr);\n-\tva_end(arg_ptr);\n-\tif (ret >= 0 && ret < limit)\n-\t    break;\n-\tif (p != buffer)\n-\t    delete p;\n-\tlimit *= 2;\n-\tp = new char[limit];\n-\tif (p == NULL)\n-\t    throw std::bad_alloc();\n-    }\n+\t{\n+\t    va_list arg_ptr;\n+\t    va_start(arg_ptr, format);\n+\t    ret = _vsnprintf(p, limit, format, arg_ptr);\n+\t    va_end(arg_ptr);\n+\t    if (ret >= 0 && ret < limit)\n+\t\tbreak;\n+\t    if (p != buffer)\n+\t\tdelete p;\n+\t    limit *= 2;\n+\t    p = new char[limit];\n+\t    if (p == NULL)\n+\t\tthrow std::bad_alloc();\n+\t}\n     string str(p, p+ret);\n     if (p != buffer)\n \tdelete p;\n@@ -292,10 +292,10 @@ bool error(const char* format, ...)\n     int ret = _vsnprintf(buffer, limit, format, arg_ptr);\n     va_end(arg_ptr);\n     if (ret < 0 || ret >= limit)\n-    {\n-\tret = limit - 1;\n-\tbuffer[limit-1] = 0;\n-    }\n+\t{\n+\t    ret = limit - 1;\n+\t    buffer[limit-1] = 0;\n+\t}\n     printf(\"ERROR: %s\\n\", buffer);\n     return false;\n }\n@@ -308,16 +308,16 @@ void ParseString(const string& str, char c, vector<string>& v)\n     string::size_type i1 = 0;\n     string::size_type i2;\n     loop\n-    {\n-\ti2 = str.find(c, i1);\n-\tif (i2 == str.npos)\n \t{\n-\t    v.push_back(str.substr(i1));\n-\t    return;\n+\t    i2 = str.find(c, i1);\n+\t    if (i2 == str.npos)\n+\t\t{\n+\t\t    v.push_back(str.substr(i1));\n+\t\t    return;\n+\t\t}\n+\t    v.push_back(str.substr(i1, i2-i1));\n+\t    i1 = i2+1;\n \t}\n-\tv.push_back(str.substr(i1, i2-i1));\n-\ti1 = i2+1;\n-    }\n }\n \n \n@@ -363,26 +363,26 @@ bool ParseMoney(const char* pszIn, int64& nRet)\n     while (isspace(*p))\n \tp++;\n     for (; *p; p++)\n-    {\n-\tif (*p == ',' && p > pszIn && isdigit(p[-1]) && isdigit(p[1]) && isdigit(p[2]) && isdigit(p[3]) && !isdigit(p[4]))\n-\t    continue;\n-\tif (*p == '.')\n \t{\n-\t    p++;\n-\t    int64 nMult = CENT*10;\n-\t    while (isdigit(*p) && (nMult > 0))\n-\t    {\n-\t\tnUnits += nMult * (*p++ - '0');\n-\t\tnMult /= 10;\n-\t    }\n-\t    break;\n+\t    if (*p == ',' && p > pszIn && isdigit(p[-1]) && isdigit(p[1]) && isdigit(p[2]) && isdigit(p[3]) && !isdigit(p[4]))\n+\t\tcontinue;\n+\t    if (*p == '.')\n+\t\t{\n+\t\t    p++;\n+\t\t    int64 nMult = CENT*10;\n+\t\t    while (isdigit(*p) && (nMult > 0))\n+\t\t\t{\n+\t\t\t    nUnits += nMult * (*p++ - '0');\n+\t\t\t    nMult /= 10;\n+\t\t\t}\n+\t\t    break;\n+\t\t}\n+\t    if (isspace(*p))\n+\t\tbreak;\n+\t    if (!isdigit(*p))\n+\t\treturn false;\n+\t    strWhole.insert(strWhole.end(), *p);\n \t}\n-\tif (isspace(*p))\n-\t    break;\n-\tif (!isdigit(*p))\n-\t    return false;\n-\tstrWhole.insert(strWhole.end(), *p);\n-    }\n     for (; *p; p++)\n \tif (!isspace(*p))\n \t    return false;\n@@ -401,39 +401,39 @@ bool ParseMoney(const char* pszIn, int64& nRet)\n vector<unsigned char> ParseHex(const char* psz)\n {\n     static char phexdigit[256] =\n-    { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n-      -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n+\t{ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n+\t  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+\t  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n \n     // convert hex dump to vector\n     vector<unsigned char> vch;\n     loop\n-    {\n-\twhile (isspace(*psz))\n-\t    psz++;\n-\tchar c = phexdigit[(unsigned char)*psz++];\n-\tif (c == (char)-1)\n-\t    break;\n-\tunsigned char n = (c << 4);\n-\tc = phexdigit[(unsigned char)*psz++];\n-\tif (c == (char)-1)\n-\t    break;\n-\tn |= c;\n-\tvch.push_back(n);\n-    }\n+\t{\n+\t    while (isspace(*psz))\n+\t\tpsz++;\n+\t    char c = phexdigit[(unsigned char)*psz++];\n+\t    if (c == (char)-1)\n+\t\tbreak;\n+\t    unsigned char n = (c << 4);\n+\t    c = phexdigit[(unsigned char)*psz++];\n+\t    if (c == (char)-1)\n+\t\tbreak;\n+\t    n |= c;\n+\t    vch.push_back(n);\n+\t}\n     return vch;\n }\n \n@@ -448,25 +448,25 @@ void ParseParameters(int argc, char* argv[])\n     mapArgs.clear();\n     mapMultiArgs.clear();\n     for (int i = 1; i < argc; i++)\n-    {\n-\tchar psz[10000];\n-\tstrlcpy(psz, argv[i], sizeof(psz));\n-\tchar* pszValue = (char*)\"\";\n-\tif (strchr(psz, '='))\n \t{\n-\t    pszValue = strchr(psz, '=');\n-\t    *pszValue++ = '\\0';\n+\t    char psz[10000];\n+\t    strlcpy(psz, argv[i], sizeof(psz));\n+\t    char* pszValue = (char*)\"\";\n+\t    if (strchr(psz, '='))\n+\t\t{\n+\t\t    pszValue = strchr(psz, '=');\n+\t\t    *pszValue++ = '\\0';\n+\t\t}\n+#ifdef __WXMSW__\n+\t    _strlwr(psz);\n+\t    if (psz[0] == '/')\n+\t\tpsz[0] = '-';\n+#endif\n+\t    if (psz[0] != '-')\n+\t\tbreak;\n+\t    mapArgs[psz] = pszValue;\n+\t    mapMultiArgs[psz].push_back(pszValue);\n \t}\n-\t#ifdef __WXMSW__\n-\t_strlwr(psz);\n-\tif (psz[0] == '/')\n-\t    psz[0] = '-';\n-\t#endif\n-\tif (psz[0] != '-')\n-\t    break;\n-\tmapArgs[psz] = pszValue;\n-\tmapMultiArgs[psz].push_back(pszValue);\n-    }\n }\n \n \n@@ -508,25 +508,25 @@ const char* wxGetTranslation(const char* pszEnglish)\n bool WildcardMatch(const char* psz, const char* mask)\n {\n     loop\n-    {\n-\tswitch (*mask)\n \t{\n-\tcase '\\0':\n-\t    return (*psz == '\\0');\n-\tcase '*':\n-\t    return WildcardMatch(psz, mask+1) || (*psz && WildcardMatch(psz+1, mask));\n-\tcase '?':\n-\t    if (*psz == '\\0')\n-\t\treturn false;\n-\t    break;\n-\tdefault:\n-\t    if (*psz != *mask)\n-\t\treturn false;\n-\t    break;\n+\t    switch (*mask)\n+\t\t{\n+\t\tcase '\\0':\n+\t\t    return (*psz == '\\0');\n+\t\tcase '*':\n+\t\t    return WildcardMatch(psz, mask+1) || (*psz && WildcardMatch(psz+1, mask));\n+\t\tcase '?':\n+\t\t    if (*psz == '\\0')\n+\t\t\treturn false;\n+\t\t    break;\n+\t\tdefault:\n+\t\t    if (*psz != *mask)\n+\t\t\treturn false;\n+\t\t    break;\n+\t\t}\n+\t    psz++;\n+\t    mask++;\n \t}\n-\tpsz++;\n-\tmask++;\n-    }\n }\n \n bool WildcardMatch(const string& str, const string& mask)\n@@ -552,10 +552,10 @@ void FormatException(char* pszMessage, std::exception* pex, const char* pszThrea\n #endif\n     if (pex)\n \tsnprintf(pszMessage, 1000,\n-\t    \"EXCEPTION: %s       \\n%s       \\n%s in %s       \\n\", typeid(*pex).name(), pex->what(), pszModule, pszThread);\n+\t\t \"EXCEPTION: %s       \\n%s       \\n%s in %s       \\n\", typeid(*pex).name(), pex->what(), pszModule, pszThread);\n     else\n \tsnprintf(pszMessage, 1000,\n-\t    \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n+\t\t \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n }\n \n void LogException(std::exception* pex, const char* pszThread)\n@@ -620,27 +620,27 @@ string MyGetSpecialFolderPath(int nFolder, bool fCreate)\n     // SHGetSpecialFolderPath isn't always available on old Windows versions\n     HMODULE hShell32 = LoadLibraryA(\"shell32.dll\");\n     if (hShell32)\n-    {\n-\tPSHGETSPECIALFOLDERPATHA pSHGetSpecialFolderPath =\n-\t    (PSHGETSPECIALFOLDERPATHA)GetProcAddress(hShell32, \"SHGetSpecialFolderPathA\");\n-\tif (pSHGetSpecialFolderPath)\n-\t    (*pSHGetSpecialFolderPath)(NULL, pszPath, nFolder, fCreate);\n-\tFreeModule(hShell32);\n-    }\n+\t{\n+\t    PSHGETSPECIALFOLDERPATHA pSHGetSpecialFolderPath =\n+\t\t(PSHGETSPECIALFOLDERPATHA)GetProcAddress(hShell32, \"SHGetSpecialFolderPathA\");\n+\t    if (pSHGetSpecialFolderPath)\n+\t\t(*pSHGetSpecialFolderPath)(NULL, pszPath, nFolder, fCreate);\n+\t    FreeModule(hShell32);\n+\t}\n \n     // Backup option\n     if (pszPath[0] == '\\0')\n-    {\n-\tif (nFolder == CSIDL_STARTUP)\n-\t{\n-\t    strcpy(pszPath, getenv(\"USERPROFILE\"));\n-\t    strcat(pszPath, \"\\\\Start Menu\\\\Programs\\\\Startup\");\n-\t}\n-\telse if (nFolder == CSIDL_APPDATA)\n \t{\n-\t    strcpy(pszPath, getenv(\"APPDATA\"));\n+\t    if (nFolder == CSIDL_STARTUP)\n+\t\t{\n+\t\t    strcpy(pszPath, getenv(\"USERPROFILE\"));\n+\t\t    strcat(pszPath, \"\\\\Start Menu\\\\Programs\\\\Startup\");\n+\t\t}\n+\t    else if (nFolder == CSIDL_APPDATA)\n+\t\t{\n+\t\t    strcpy(pszPath, getenv(\"APPDATA\"));\n+\t\t}\n \t}\n-    }\n \n     return pszPath;\n }\n@@ -678,34 +678,34 @@ void GetDataDir(char* pszDir)\n     // pszDir must be at least MAX_PATH length.\n     int nVariation;\n     if (pszSetDataDir[0] != 0)\n-    {\n-\tstrlcpy(pszDir, pszSetDataDir, MAX_PATH);\n-\tnVariation = 0;\n-    }\n+\t{\n+\t    strlcpy(pszDir, pszSetDataDir, MAX_PATH);\n+\t    nVariation = 0;\n+\t}\n     else\n-    {\n-\t// This can be called during exceptions by printf, so we cache the\n-\t// value so we don't have to do memory allocations after that.\n-\tstatic char pszCachedDir[MAX_PATH];\n-\tif (pszCachedDir[0] == 0)\n-\t    strlcpy(pszCachedDir, GetDefaultDataDir().c_str(), sizeof(pszCachedDir));\n-\tstrlcpy(pszDir, pszCachedDir, MAX_PATH);\n-\tnVariation = 1;\n-    }\n+\t{\n+\t    // This can be called during exceptions by printf, so we cache the\n+\t    // value so we don't have to do memory allocations after that.\n+\t    static char pszCachedDir[MAX_PATH];\n+\t    if (pszCachedDir[0] == 0)\n+\t\tstrlcpy(pszCachedDir, GetDefaultDataDir().c_str(), sizeof(pszCachedDir));\n+\t    strlcpy(pszDir, pszCachedDir, MAX_PATH);\n+\t    nVariation = 1;\n+\t}\n     if (fTestNet)\n-    {\n-\tchar* p = pszDir + strlen(pszDir);\n-\tif (p > pszDir && p[-1] != '/' && p[-1] != '\\\\')\n-\t    *p++ = '/';\n-\tstrcpy(p, \"testnet\");\n-\tnVariation += 2;\n-    }\n+\t{\n+\t    char* p = pszDir + strlen(pszDir);\n+\t    if (p > pszDir && p[-1] != '/' && p[-1] != '\\\\')\n+\t\t*p++ = '/';\n+\t    strcpy(p, \"testnet\");\n+\t    nVariation += 2;\n+\t}\n     static bool pfMkdir[4];\n     if (!pfMkdir[nVariation])\n-    {\n-\tpfMkdir[nVariation] = true;\n-\tfilesystem::create_directory(pszDir);\n-    }\n+\t{\n+\t    pfMkdir[nVariation] = true;\n+\t    filesystem::create_directory(pszDir);\n+\t}\n }\n \n string GetDataDir()\n@@ -738,13 +738,13 @@ void ReadConfigFile(map<string, string>& mapSettingsRet,\n     setOptions.insert(\"*\");\n \n     for (pod::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n-    {\n-\t// Don't overwrite existing settings so command line settings override bitcoin.conf\n-\tstring strKey = string(\"-\") + it->string_key;\n-\tif (mapSettingsRet.count(strKey) == 0)\n-\t    mapSettingsRet[strKey] = it->value[0];\n-\tmapMultiSettingsRet[strKey].push_back(it->value[0]);\n-    }\n+\t{\n+\t    // Don't overwrite existing settings so command line settings override bitcoin.conf\n+\t    string strKey = string(\"-\") + it->string_key;\n+\t    if (mapSettingsRet.count(strKey) == 0)\n+\t\tmapSettingsRet[strKey] = it->value[0];\n+\t    mapMultiSettingsRet[strKey].push_back(it->value[0]);\n+\t}\n }\n \n string GetPidFile()\n@@ -760,10 +760,10 @@ void CreatePidFile(string pidFile, pid_t pid)\n {\n     FILE* file;\n     if (file = fopen(pidFile.c_str(), \"w\"))\n-    {\n-\tfprintf(file, \"%d\\n\", pid);\n-\tfclose(file);\n-    }\n+\t{\n+\t    fprintf(file, \"%d\\n\", pid);\n+\t    fclose(file);\n+\t}\n }\n \n int GetFilesize(FILE* file)\n@@ -782,18 +782,18 @@ void ShrinkDebugFile()\n     string strFile = GetDataDir() + \"/debug.log\";\n     FILE* file = fopen(strFile.c_str(), \"r\");\n     if (file && GetFilesize(file) > 10 * 1000000)\n-    {\n-\t// Restart the file with some of the end\n-\tchar pch[200000];\n-\tfseek(file, -sizeof(pch), SEEK_END);\n-\tint nBytes = fread(pch, 1, sizeof(pch), file);\n-\tfclose(file);\n-\tif (file = fopen(strFile.c_str(), \"w\"))\n \t{\n-\t    fwrite(pch, 1, nBytes, file);\n+\t    // Restart the file with some of the end\n+\t    char pch[200000];\n+\t    fseek(file, -sizeof(pch), SEEK_END);\n+\t    int nBytes = fread(pch, 1, sizeof(pch), file);\n \t    fclose(file);\n+\t    if (file = fopen(strFile.c_str(), \"w\"))\n+\t\t{\n+\t\t    fwrite(pch, 1, nBytes, file);\n+\t\t    fclose(file);\n+\t\t}\n \t}\n-    }\n }\n \n \n@@ -838,41 +838,41 @@ void AddTimeData(unsigned int ip, int64 nTime)\n     vTimeOffsets.push_back(nOffsetSample);\n     printf(\"Added time data, samples %d, offset %+\"PRI64d\" (%+\"PRI64d\" minutes)\\n\", vTimeOffsets.size(), vTimeOffsets.back(), vTimeOffsets.back()/60);\n     if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n-    {\n-\tsort(vTimeOffsets.begin(), vTimeOffsets.end());\n-\tint64 nMedian = vTimeOffsets[vTimeOffsets.size()/2];\n-\t// Only let other nodes change our time by so much\n-\tif (abs64(nMedian) < 70 * 60)\n-\t{\n-\t    nTimeOffset = nMedian;\n-\t}\n-\telse\n \t{\n-\t    nTimeOffset = 0;\n-\n-\t    static bool fDone;\n-\t    if (!fDone)\n-\t    {\n-\t\t// If nobody has a time different than ours but within 5 minutes of ours, give a warning\n-\t\tbool fMatch = false;\n-\t\tforeach(int64 nOffset, vTimeOffsets)\n-\t\t    if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n-\t\t\tfMatch = true;\n-\n-\t\tif (!fMatch)\n+\t    sort(vTimeOffsets.begin(), vTimeOffsets.end());\n+\t    int64 nMedian = vTimeOffsets[vTimeOffsets.size()/2];\n+\t    // Only let other nodes change our time by so much\n+\t    if (abs64(nMedian) < 70 * 60)\n \t\t{\n-\t\t    fDone = true;\n-\t\t    string strMessage = _(\"Warning: Please check that your computer's date and time are correct.  If your clock is wrong Bitcoin will not work properly.\");\n-\t\t    strMiscWarning = strMessage;\n-\t\t    printf(\"*** %s\\n\", strMessage.c_str());\n-\t\t    boost::thread(boost::bind(ThreadSafeMessageBox, strMessage+\" \", string(\"Bitcoin\"), wxOK | wxICON_EXCLAMATION, (wxWindow*)NULL, -1, -1));\n+\t\t    nTimeOffset = nMedian;\n \t\t}\n-\t    }\n+\t    else\n+\t\t{\n+\t\t    nTimeOffset = 0;\n+\n+\t\t    static bool fDone;\n+\t\t    if (!fDone)\n+\t\t\t{\n+\t\t\t    // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n+\t\t\t    bool fMatch = false;\n+\t\t\t    foreach(int64 nOffset, vTimeOffsets)\n+\t\t\t\tif (nOffset != 0 && abs64(nOffset) < 5 * 60)\n+\t\t\t\t    fMatch = true;\n+\n+\t\t\t    if (!fMatch)\n+\t\t\t\t{\n+\t\t\t\t    fDone = true;\n+\t\t\t\t    string strMessage = _(\"Warning: Please check that your computer's date and time are correct.  If your clock is wrong Bitcoin will not work properly.\");\n+\t\t\t\t    strMiscWarning = strMessage;\n+\t\t\t\t    printf(\"*** %s\\n\", strMessage.c_str());\n+\t\t\t\t    boost::thread(boost::bind(ThreadSafeMessageBox, strMessage+\" \", string(\"Bitcoin\"), wxOK | wxICON_EXCLAMATION, (wxWindow*)NULL, -1, -1));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t    foreach(int64 n, vTimeOffsets)\n+\t\tprintf(\"%+\"PRI64d\"  \", n);\n+\t    printf(\"|  nTimeOffset = %+\"PRI64d\"  (%+\"PRI64d\" minutes)\\n\", nTimeOffset, nTimeOffset/60);\n \t}\n-\tforeach(int64 n, vTimeOffsets)\n-\t    printf(\"%+\"PRI64d\"  \", n);\n-\tprintf(\"|  nTimeOffset = %+\"PRI64d\"  (%+\"PRI64d\" minutes)\\n\", nTimeOffset, nTimeOffset/60);\n-    }\n }\n \n "
      },
      {
        "sha": "15fc2b00b8267da760b88baeb9b13abb06583498",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 37,
        "deletions": 33,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9957f8eea8c410a02bdf2c548024cd2534afdb7f/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "patch": "@@ -2,6 +2,8 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef UTIL_H\n+#define UTIL_H\n \n #if defined(_MSC_VER) || defined(__BORLANDC__)\n typedef __int64  int64;\n@@ -459,17 +461,17 @@ inline void heapchk()\n \tif (nLoops <= 0)                        \\\n \t    nLoops = GetRand(20) + 1;           \\\n \tif (nLoops-- > 1)                       \\\n-\t{                                       \\\n-\t    ThreadFn;                           \\\n-\t    return;                             \\\n-\t}                                       \\\n+\t    {\t\t\t\t\t\\\n+\t\tThreadFn;\t\t\t\\\n+\t\treturn;\t\t\t\t\\\n+\t    }\t\t\t\t\t\\\n     }\n \n-#define CATCH_PRINT_EXCEPTION(pszFn)     \\\n-    catch (std::exception& e) {          \\\n-\tPrintException(&e, (pszFn));     \\\n-    } catch (...) {                      \\\n-\tPrintException(NULL, (pszFn));   \\\n+#define CATCH_PRINT_EXCEPTION(pszFn)\t\t\\\n+    catch (std::exception& e) {\t\t\t\\\n+\tPrintException(&e, (pszFn));\t\t\\\n+    } catch (...) {\t\t\t\t\\\n+\tPrintException(NULL, (pszFn));\t\t\\\n     }\n \n \n@@ -567,22 +569,22 @@ inline pthread_t CreateThread(void(*pfn)(void*), void* parg, bool fWantHandle=fa\n     DWORD nUnused = 0;\n     HANDLE hthread =\n \tCreateThread(\n-\t    NULL,                        // default security\n-\t    0,                           // inherit stack size from parent\n-\t    (LPTHREAD_START_ROUTINE)pfn, // function pointer\n-\t    parg,                        // argument\n-\t    0,                           // creation option, start immediately\n-\t    &nUnused);                   // thread identifier\n+\t\t     NULL,                        // default security\n+\t\t     0,                           // inherit stack size from parent\n+\t\t     (LPTHREAD_START_ROUTINE)pfn, // function pointer\n+\t\t     parg,                        // argument\n+\t\t     0,                           // creation option, start immediately\n+\t\t     &nUnused);                   // thread identifier\n     if (hthread == NULL)\n-    {\n-\tprintf(\"Error: CreateThread() returned %d\\n\", GetLastError());\n-\treturn (pthread_t)0;\n-    }\n+\t{\n+\t    printf(\"Error: CreateThread() returned %d\\n\", GetLastError());\n+\t    return (pthread_t)0;\n+\t}\n     if (!fWantHandle)\n-    {\n-\tCloseHandle(hthread);\n-\treturn (pthread_t)-1;\n-    }\n+\t{\n+\t    CloseHandle(hthread);\n+\t    return (pthread_t)-1;\n+\t}\n     return hthread;\n }\n \n@@ -596,10 +598,10 @@ inline pthread_t CreateThread(void(*pfn)(void*), void* parg, bool fWantHandle=fa\n     pthread_t hthread = 0;\n     int ret = pthread_create(&hthread, NULL, (void*(*)(void*))pfn, parg);\n     if (ret != 0)\n-    {\n-\tprintf(\"Error: pthread_create() returned %d\\n\", ret);\n-\treturn (pthread_t)0;\n-    }\n+\t{\n+\t    printf(\"Error: pthread_create() returned %d\\n\", ret);\n+\t    return (pthread_t)0;\n+\t}\n     if (!fWantHandle)\n \treturn (pthread_t)-1;\n     return hthread;\n@@ -646,12 +648,14 @@ inline bool AffinityBugWorkaround(void(*pfn)(void*))\n     DWORD dwPrev1 = SetThreadAffinityMask(GetCurrentThread(), dwProcessAffinityMask);\n     DWORD dwPrev2 = SetThreadAffinityMask(GetCurrentThread(), dwProcessAffinityMask);\n     if (dwPrev2 != dwProcessAffinityMask)\n-    {\n-\tprintf(\"AffinityBugWorkaround() : SetThreadAffinityMask=%d, ProcessAffinityMask=%d, restarting thread\\n\", dwPrev2, dwProcessAffinityMask);\n-\tif (!CreateThread(pfn, NULL))\n-\t    printf(\"Error: CreateThread() failed\\n\");\n-\treturn true;\n-    }\n+\t{\n+\t    printf(\"AffinityBugWorkaround() : SetThreadAffinityMask=%d, ProcessAffinityMask=%d, restarting thread\\n\", dwPrev2, dwProcessAffinityMask);\n+\t    if (!CreateThread(pfn, NULL))\n+\t\tprintf(\"Error: CreateThread() failed\\n\");\n+\t    return true;\n+\t}\n #endif\n     return false;\n }\n+\n+#endif // !UTIL_H"
      }
    ]
  },
  {
    "sha": "01a5c3b41ce19c310460477bcb6a5eb8c0370128",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMWE1YzNiNDFjZTE5YzMxMDQ2MDQ3N2JjYjZhNWViOGMwMzcwMTI4",
    "commit": {
      "author": {
        "name": "Caner Candan",
        "email": "caner@candan.fr",
        "date": "2011-05-15T21:51:16Z"
      },
      "committer": {
        "name": "Caner Candan",
        "email": "caner@candan.fr",
        "date": "2011-05-15T21:51:16Z"
      },
      "message": "* indentations",
      "tree": {
        "sha": "2c042b319e88e0e01ddd0ffe54bbec2d263e8b6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c042b319e88e0e01ddd0ffe54bbec2d263e8b6c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/01a5c3b41ce19c310460477bcb6a5eb8c0370128",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01a5c3b41ce19c310460477bcb6a5eb8c0370128",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/01a5c3b41ce19c310460477bcb6a5eb8c0370128",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01a5c3b41ce19c310460477bcb6a5eb8c0370128/comments",
    "author": {
      "login": "canercandan",
      "id": 285572,
      "node_id": "MDQ6VXNlcjI4NTU3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/285572?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/canercandan",
      "html_url": "https://github.com/canercandan",
      "followers_url": "https://api.github.com/users/canercandan/followers",
      "following_url": "https://api.github.com/users/canercandan/following{/other_user}",
      "gists_url": "https://api.github.com/users/canercandan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/canercandan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/canercandan/subscriptions",
      "organizations_url": "https://api.github.com/users/canercandan/orgs",
      "repos_url": "https://api.github.com/users/canercandan/repos",
      "events_url": "https://api.github.com/users/canercandan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/canercandan/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "canercandan",
      "id": 285572,
      "node_id": "MDQ6VXNlcjI4NTU3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/285572?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/canercandan",
      "html_url": "https://github.com/canercandan",
      "followers_url": "https://api.github.com/users/canercandan/followers",
      "following_url": "https://api.github.com/users/canercandan/following{/other_user}",
      "gists_url": "https://api.github.com/users/canercandan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/canercandan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/canercandan/subscriptions",
      "organizations_url": "https://api.github.com/users/canercandan/orgs",
      "repos_url": "https://api.github.com/users/canercandan/repos",
      "events_url": "https://api.github.com/users/canercandan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/canercandan/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9957f8eea8c410a02bdf2c548024cd2534afdb7f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9957f8eea8c410a02bdf2c548024cd2534afdb7f"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "45d5d321a1ec535fbdc35638bbb9fa5ee491c8f7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01a5c3b41ce19c310460477bcb6a5eb8c0370128/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01a5c3b41ce19c310460477bcb6a5eb8c0370128/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=01a5c3b41ce19c310460477bcb6a5eb8c0370128",
        "patch": "@@ -1038,3 +1038,5 @@ void AdvertRemoveSource(CNode* pfrom, unsigned int nChannel, unsigned int nHops,\n     if (obj.setSources.empty())\n \tAdvertStopPublish(pfrom, nChannel, nHops, obj);\n }\n+\n+#endif // !NET_H"
      }
    ]
  }
]