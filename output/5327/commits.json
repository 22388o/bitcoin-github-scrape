[
  {
    "sha": "925c5eb1768d68a56f6ec45c65322ef6fa169e45",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjVjNWViMTc2OGQ2OGE1NmY2ZWM0NWM2NTMyMmVmNmZhMTY5ZTQ1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-20T13:52:54Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-20T13:52:54Z"
      },
      "message": "Demo of clang-format with maxline=100",
      "tree": {
        "sha": "5ce0540ff0d02310784cb708a8d01e007fdb44a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ce0540ff0d02310784cb708a8d01e007fdb44a8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/925c5eb1768d68a56f6ec45c65322ef6fa169e45",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/925c5eb1768d68a56f6ec45c65322ef6fa169e45",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/925c5eb1768d68a56f6ec45c65322ef6fa169e45",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/925c5eb1768d68a56f6ec45c65322ef6fa169e45/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9842ed465b44c8eaa8b307c18449dd9d8e04f217",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9842ed465b44c8eaa8b307c18449dd9d8e04f217",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9842ed465b44c8eaa8b307c18449dd9d8e04f217"
      }
    ],
    "stats": {
      "total": 3280,
      "additions": 1844,
      "deletions": 1436
    },
    "files": [
      {
        "sha": "0dbb6900bc144d7ba6f15fcb5840bd41bb965d1f",
        "filename": "src/.clang-format",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/.clang-format",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/.clang-format",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-format?ref=925c5eb1768d68a56f6ec45c65322ef6fa169e45",
        "patch": "@@ -13,7 +13,7 @@ BreakBeforeBinaryOperators: false\n BreakBeforeBraces: Linux\n BreakBeforeTernaryOperators: false\n BreakConstructorInitializersBeforeComma: false\n-ColumnLimit:     0\n+ColumnLimit:     100\n CommentPragmas:  '^ IWYU pragma:'\n ConstructorInitializerAllOnOneLineOrOnePerLine: false\n ConstructorInitializerIndentWidth: 4\n@@ -31,7 +31,7 @@ MaxEmptyLinesToKeep: 2\n NamespaceIndentation: None\n ObjCSpaceAfterProperty: false\n ObjCSpaceBeforeProtocolList: false\n-PenaltyBreakBeforeFirstCallParameter: 1\n+PenaltyBreakBeforeFirstCallParameter: 100\n PenaltyBreakComment: 300\n PenaltyBreakFirstLessLess: 120\n PenaltyBreakString: 1000"
      },
      {
        "sha": "7c1565b4f9054a9ded17dc3a1fcf5974f5822a7b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1404,
        "deletions": 1062,
        "changes": 2466,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=925c5eb1768d68a56f6ec45c65322ef6fa169e45"
      },
      {
        "sha": "51566564b71203eeef739560900596571f1decbb",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 199,
        "deletions": 133,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=925c5eb1768d68a56f6ec45c65322ef6fa169e45",
        "patch": "@@ -51,19 +51,20 @@ struct CNodeStateStats;\n \n /** The maximum allowed size for a serialized block, in bytes (network rule) */\n static const unsigned int MAX_BLOCK_SIZE = 1000000;\n-/** Default for -blockmaxsize and -blockminsize, which control the range of sizes the mining code will create **/\n+/** Default for -blockmaxsize and -blockminsize, which control the range of sizes the mining code\n+ * will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n /** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 50000;\n /** The maximum size for transactions we're willing to relay/mine */\n static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n-static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n+static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;\n /** Maxiumum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n-static const unsigned int MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;\n+static const unsigned int MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS / 5;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Default for -maxorphanblocks, maximum number of orphan blocks kept in memory */\n@@ -76,21 +77,24 @@ static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n-/** Threshold for nLockTime: below this value it is interpreted as block number, otherwise as UNIX timestamp. */\n+/** Threshold for nLockTime: below this value it is interpreted as block number, otherwise as UNIX\n+ * timestamp. */\n static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n /** Maximum number of script-checking threads allowed */\n static const int MAX_SCRIPTCHECK_THREADS = 16;\n /** -par default (number of script-checking threads, 0 = auto) */\n static const int DEFAULT_SCRIPTCHECK_THREADS = 0;\n /** Number of blocks that can be requested at any given time from a single peer. */\n static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16;\n-/** Timeout in seconds during which a peer must stall block download progress before being disconnected. */\n+/** Timeout in seconds during which a peer must stall block download progress before being\n+ * disconnected. */\n static const unsigned int BLOCK_STALLING_TIMEOUT = 2;\n /** Number of headers sent in one getheaders result. We rely on the assumption that if a peer sends\n  *  less than this number, we reached their tip. Changing this value is a protocol upgrade. */\n static const unsigned int MAX_HEADERS_RESULTS = 2000;\n /** Size of the \"block download window\": how far ahead of our current height do we fetch?\n- *  Larger windows tolerate larger download speed differences between peer, but increase the potential\n+ *  Larger windows tolerate larger download speed differences between peer, but increase the\n+ * potential\n  *  degree of disordering of blocks on disk (which make reindexing and in the future perhaps pruning\n  *  harder). We'll probably want to make this a per-peer adaptive value at some point. */\n static const unsigned int BLOCK_DOWNLOAD_WINDOW = 1024;\n@@ -130,7 +134,7 @@ extern unsigned int nCoinCacheSize;\n extern CFeeRate minRelayTxFee;\n \n // Best header we've seen so far (used for getheaders queries' starting points).\n-extern CBlockIndex *pindexBestHeader;\n+extern CBlockIndex* pindexBestHeader;\n \n // Minimum disk space required - used in CheckDiskSpace()\n static const uint64_t nMinDiskSpace = 52428800;\n@@ -152,23 +156,33 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n /** Process an incoming block. This only returns after the best known valid\n     block is made active. Note that it does not, however, guarantee that the\n     specific block passed to it has been checked for validity!\n-    @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state iff pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface - this will have its BlockChecked method called whenever *any* block completes validation.\n-    @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n+    @param[out]  state   This may be set to an Error state if any error occurred processing it,\n+   including during validation/connection/etc of otherwise unrelated blocks during reorganisation;\n+   or it may be set to an Invalid state iff pblock is itself invalid (but this is not guaranteed\n+   even when the block is checked). If you want to *possibly* get feedback on whether pblock is\n+   valid, you must also install a CValidationInterface - this will have its BlockChecked method\n+   called whenever *any* block completes validation.\n+    @param[in]   pfrom   The node which we are receiving the block from; it is added to\n+   mapBlockSource and may be penalised if the block is invalid.\n     @param[in]   pblock  The block we want to process.\n-    @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its location.\n+    @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its\n+   location.\n     @return True if state.IsValid()\n */\n-bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n+bool ProcessNewBlock(CValidationState& state,\n+                     CNode* pfrom,\n+                     CBlock* pblock,\n+                     CDiskBlockPos* dbp = NULL);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n-FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n+FILE* OpenBlockFile(const CDiskBlockPos& pos, bool fReadOnly = false);\n /** Open an undo file (rev?????.dat) */\n-FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n+FILE* OpenUndoFile(const CDiskBlockPos& pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n-boost::filesystem::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix);\n+boost::filesystem::path GetBlockPosFilename(const CDiskBlockPos& pos, const char* prefix);\n /** Import blocks from an external file */\n-bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp = NULL);\n+bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos* dbp = NULL);\n /** Initialize a new block tree database + block data on disk */\n bool InitBlockIndex();\n /** Load the block tree and coins database from disk */\n@@ -188,27 +202,35 @@ bool IsInitialBlockDownload();\n /** Format a string that describes several potential problems detected by the core */\n std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n-bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n+bool GetTransaction(const uint256& hash,\n+                    CTransaction& tx,\n+                    uint256& hashBlock,\n+                    bool fAllowSlow = false);\n /** Find the best known block, and make it the tip of the block chain */\n-bool ActivateBestChain(CValidationState &state, CBlock *pblock = NULL);\n+bool ActivateBestChain(CValidationState& state, CBlock* pblock = NULL);\n CAmount GetBlockValue(int nHeight, const CAmount& nFees);\n \n /** Create a new block index entry for a given block hash */\n-CBlockIndex * InsertBlockIndex(uint256 hash);\n+CBlockIndex* InsertBlockIndex(uint256 hash);\n /** Abort with a message */\n-bool AbortNode(const std::string &msg, const std::string &userMessage=\"\");\n+bool AbortNode(const std::string& msg, const std::string& userMessage = \"\");\n /** Get statistics from node state */\n-bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n+bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch);\n \n \n /** (try to) add transaction to memory pool **/\n-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, bool fRejectInsaneFee=false);\n+bool AcceptToMemoryPool(CTxMemPool& pool,\n+                        CValidationState& state,\n+                        const CTransaction& tx,\n+                        bool fLimitFree,\n+                        bool* pfMissingInputs,\n+                        bool fRejectInsaneFee = false);\n \n \n-struct CNodeStateStats {\n+struct CNodeStateStats\n+{\n     int nMisbehavior;\n     int nSyncHeight;\n     int nCommonHeight;\n@@ -222,19 +244,21 @@ struct CDiskTxPos : public CDiskBlockPos\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(*(CDiskBlockPos*)this);\n         READWRITE(VARINT(nTxOffset));\n     }\n \n-    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n+    CDiskTxPos(const CDiskBlockPos& blockIn, unsigned int nTxOffsetIn)\n+        : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn)\n+    {\n     }\n \n-    CDiskTxPos() {\n-        SetNull();\n-    }\n+    CDiskTxPos() { SetNull(); }\n \n-    void SetNull() {\n+    void SetNull()\n+    {\n         CDiskBlockPos::SetNull();\n         nTxOffset = 0;\n     }\n@@ -276,14 +300,24 @@ unsigned int GetLegacySigOpCount(const CTransaction& tx);\n unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n \n-// Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n+// Check whether all inputs of this transaction are valid (no double spends, scripts & sigs,\n+// amounts)\n // This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n // instead of being performed inline.\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks = NULL);\n+bool CheckInputs(const CTransaction& tx,\n+                 CValidationState& state,\n+                 const CCoinsViewCache& view,\n+                 bool fScriptChecks,\n+                 unsigned int flags,\n+                 bool cacheStore,\n+                 std::vector<CScriptCheck>* pvChecks = NULL);\n \n // Apply the effects of this transaction on the UTXO set represented by view\n-void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight);\n+void UpdateCoins(const CTransaction& tx,\n+                 CValidationState& state,\n+                 CCoinsViewCache& inputs,\n+                 CTxUndo& txundo,\n+                 int nHeight);\n \n // Context-independent validity checks\n bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n@@ -293,7 +327,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n */\n bool IsStandardTx(const CTransaction& tx, std::string& reason);\n \n-bool IsFinalTx(const CTransaction &tx, int nBlockHeight = 0, int64_t nBlockTime = 0);\n+bool IsFinalTx(const CTransaction& tx, int nBlockHeight = 0, int64_t nBlockTime = 0);\n \n /** Undo information for a CBlock */\n class CBlockUndo\n@@ -304,12 +338,13 @@ class CBlockUndo\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(vtxundo);\n     }\n \n-    bool WriteToDisk(CDiskBlockPos &pos, const uint256 &hashBlock);\n-    bool ReadFromDisk(const CDiskBlockPos &pos, const uint256 &hashBlock);\n+    bool WriteToDisk(CDiskBlockPos& pos, const uint256& hashBlock);\n+    bool ReadFromDisk(const CDiskBlockPos& pos, const uint256& hashBlock);\n };\n \n \n@@ -319,20 +354,27 @@ class CScriptCheck\n {\n private:\n     CScript scriptPubKey;\n-    const CTransaction *ptxTo;\n+    const CTransaction* ptxTo;\n     unsigned int nIn;\n     unsigned int nFlags;\n     bool cacheStore;\n \n public:\n-    CScriptCheck(): ptxTo(0), nIn(0), nFlags(0), cacheStore(false) {}\n-    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn) :\n-        scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey),\n-        ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn) { }\n+    CScriptCheck() : ptxTo(0), nIn(0), nFlags(0), cacheStore(false) {}\n+    CScriptCheck(const CCoins& txFromIn,\n+                 const CTransaction& txToIn,\n+                 unsigned int nInIn,\n+                 unsigned int nFlagsIn,\n+                 bool cacheIn)\n+        : scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey), ptxTo(&txToIn),\n+          nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn)\n+    {\n+    }\n \n     bool operator()() const;\n \n-    void swap(CScriptCheck &check) {\n+    void swap(CScriptCheck& check)\n+    {\n         scriptPubKey.swap(check.scriptPubKey);\n         std::swap(ptxTo, check.ptxTo);\n         std::swap(nIn, check.nIn);\n@@ -390,58 +432,65 @@ class CPartialMerkleTree\n     // flag set when encountering invalid data\n     bool fBad;\n \n-    // helper function to efficiently calculate the number of nodes at given height in the merkle tree\n-    unsigned int CalcTreeWidth(int height) {\n-        return (nTransactions+(1 << height)-1) >> height;\n-    }\n+    // helper function to efficiently calculate the number of nodes at given height in the merkle\n+    // tree\n+    unsigned int CalcTreeWidth(int height) { return (nTransactions + (1 << height) - 1) >> height; }\n \n     // calculate the hash of a node in the merkle tree (at leaf level: the txid's themself)\n-    uint256 CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid);\n+    uint256 CalcHash(int height, unsigned int pos, const std::vector<uint256>& vTxid);\n \n     // recursive function that traverses tree nodes, storing the data as bits and hashes\n-    void TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n+    void TraverseAndBuild(int height,\n+                          unsigned int pos,\n+                          const std::vector<uint256>& vTxid,\n+                          const std::vector<bool>& vMatch);\n \n-    // recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.\n+    // recursive function that traverses tree nodes, consuming the bits and hashes produced by\n+    // TraverseAndBuild.\n     // it returns the hash of the respective node.\n-    uint256 TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch);\n+    uint256 TraverseAndExtract(int height,\n+                               unsigned int pos,\n+                               unsigned int& nBitsUsed,\n+                               unsigned int& nHashUsed,\n+                               std::vector<uint256>& vMatch);\n \n public:\n-\n     // serialization implementation\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(nTransactions);\n         READWRITE(vHash);\n         std::vector<unsigned char> vBytes;\n         if (ser_action.ForRead()) {\n             READWRITE(vBytes);\n-            CPartialMerkleTree &us = *(const_cast<CPartialMerkleTree*>(this));\n+            CPartialMerkleTree& us = *(const_cast<CPartialMerkleTree*>(this));\n             us.vBits.resize(vBytes.size() * 8);\n             for (unsigned int p = 0; p < us.vBits.size(); p++)\n                 us.vBits[p] = (vBytes[p / 8] & (1 << (p % 8))) != 0;\n             us.fBad = false;\n         } else {\n-            vBytes.resize((vBits.size()+7)/8);\n+            vBytes.resize((vBits.size() + 7) / 8);\n             for (unsigned int p = 0; p < vBits.size(); p++)\n                 vBytes[p / 8] |= vBits[p] << (p % 8);\n             READWRITE(vBytes);\n         }\n     }\n \n-    // Construct a partial merkle tree from a list of transaction id's, and a mask that selects a subset of them\n-    CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n+    // Construct a partial merkle tree from a list of transaction id's, and a mask that selects a\n+    // subset of them\n+    CPartialMerkleTree(const std::vector<uint256>& vTxid, const std::vector<bool>& vMatch);\n \n     CPartialMerkleTree();\n \n     // extract the matching txid's represented by this partial merkle tree.\n     // returns the merkle root, or 0 in case of failure\n-    uint256 ExtractMatches(std::vector<uint256> &vMatch);\n+    uint256 ExtractMatches(std::vector<uint256>& vMatch);\n };\n \n \n-\n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos);\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos);\n@@ -454,20 +503,35 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex);\n  *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n  *  will be true if no problems were found. Otherwise, the return value will be false in case\n  *  of problems. Note that in any case, coins may be modified. */\n-bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool* pfClean = NULL);\n+bool DisconnectBlock(CBlock& block,\n+                     CValidationState& state,\n+                     CBlockIndex* pindex,\n+                     CCoinsViewCache& coins,\n+                     bool* pfClean = NULL);\n \n // Apply the effects of this block (with given index) on the UTXO set represented by coins\n-bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n+bool ConnectBlock(CBlock& block,\n+                  CValidationState& state,\n+                  CBlockIndex* pindex,\n+                  CCoinsViewCache& coins,\n+                  bool fJustCheck = false);\n \n // Context-independent validity checks\n bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);\n-bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n+bool CheckBlock(const CBlock& block,\n+                CValidationState& state,\n+                bool fCheckPOW = true,\n+                bool fCheckMerkleRoot = true);\n \n // Store block on disk\n // if dbp is provided, the file is known to already reside on disk\n-bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n-bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n-\n+bool AcceptBlock(CBlock& block,\n+                 CValidationState& state,\n+                 CBlockIndex** pindex,\n+                 CDiskBlockPos* dbp = NULL);\n+bool AcceptBlockHeader(const CBlockHeader& block,\n+                       CValidationState& state,\n+                       CBlockIndex** ppindex = NULL);\n \n \n class CBlockFileInfo\n@@ -478,13 +542,14 @@ class CBlockFileInfo\n     unsigned int nUndoSize;    // number of used bytes in the undo file\n     unsigned int nHeightFirst; // lowest height of block in file\n     unsigned int nHeightLast;  // highest height of block in file\n-    uint64_t nTimeFirst;         // earliest time of block in file\n-    uint64_t nTimeLast;          // latest time of block in file\n+    uint64_t nTimeFirst;       // earliest time of block in file\n+    uint64_t nTimeLast;        // latest time of block in file\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(VARINT(nBlocks));\n         READWRITE(VARINT(nSize));\n         READWRITE(VARINT(nUndoSize));\n@@ -494,38 +559,39 @@ class CBlockFileInfo\n         READWRITE(VARINT(nTimeLast));\n     }\n \n-     void SetNull() {\n-         nBlocks = 0;\n-         nSize = 0;\n-         nUndoSize = 0;\n-         nHeightFirst = 0;\n-         nHeightLast = 0;\n-         nTimeFirst = 0;\n-         nTimeLast = 0;\n-     }\n-\n-     CBlockFileInfo() {\n-         SetNull();\n-     }\n-\n-     std::string ToString() const;\n-\n-     // update statistics (does not update nSize)\n-     void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) {\n-         if (nBlocks==0 || nHeightFirst > nHeightIn)\n-             nHeightFirst = nHeightIn;\n-         if (nBlocks==0 || nTimeFirst > nTimeIn)\n-             nTimeFirst = nTimeIn;\n-         nBlocks++;\n-         if (nHeightIn > nHeightLast)\n-             nHeightLast = nHeightIn;\n-         if (nTimeIn > nTimeLast)\n-             nTimeLast = nTimeIn;\n-     }\n+    void SetNull()\n+    {\n+        nBlocks = 0;\n+        nSize = 0;\n+        nUndoSize = 0;\n+        nHeightFirst = 0;\n+        nHeightLast = 0;\n+        nTimeFirst = 0;\n+        nTimeLast = 0;\n+    }\n+\n+    CBlockFileInfo() { SetNull(); }\n+\n+    std::string ToString() const;\n+\n+    // update statistics (does not update nSize)\n+    void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn)\n+    {\n+        if (nBlocks == 0 || nHeightFirst > nHeightIn)\n+            nHeightFirst = nHeightIn;\n+        if (nBlocks == 0 || nTimeFirst > nTimeIn)\n+            nTimeFirst = nTimeIn;\n+        nBlocks++;\n+        if (nHeightIn > nHeightLast)\n+            nHeightLast = nHeightIn;\n+        if (nTimeIn > nTimeLast)\n+            nTimeLast = nTimeIn;\n+    }\n };\n \n /** Capture information about block/transaction validation */\n-class CValidationState {\n+class CValidationState\n+{\n private:\n     enum mode_state {\n         MODE_VALID,   // everything ok\n@@ -536,11 +602,15 @@ class CValidationState {\n     std::string strRejectReason;\n     unsigned char chRejectCode;\n     bool corruptionPossible;\n+\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n-             unsigned char chRejectCodeIn=0, std::string strRejectReasonIn=\"\",\n-             bool corruptionIn=false) {\n+    bool DoS(int level,\n+             bool ret = false,\n+             unsigned char chRejectCodeIn = 0,\n+             std::string strRejectReasonIn = \"\",\n+             bool corruptionIn = false)\n+    {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n@@ -551,48 +621,46 @@ class CValidationState {\n         return ret;\n     }\n     bool Invalid(bool ret = false,\n-                 unsigned char _chRejectCode=0, std::string _strRejectReason=\"\") {\n+                 unsigned char _chRejectCode = 0,\n+                 std::string _strRejectReason = \"\")\n+    {\n         return DoS(0, ret, _chRejectCode, _strRejectReason);\n     }\n-    bool Error(std::string strRejectReasonIn=\"\") {\n+    bool Error(std::string strRejectReasonIn = \"\")\n+    {\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;\n         mode = MODE_ERROR;\n         return false;\n     }\n-    bool Abort(const std::string &msg) {\n+    bool Abort(const std::string& msg)\n+    {\n         AbortNode(msg);\n         return Error(msg);\n     }\n-    bool IsValid() const {\n-        return mode == MODE_VALID;\n-    }\n-    bool IsInvalid() const {\n-        return mode == MODE_INVALID;\n-    }\n-    bool IsError() const {\n-        return mode == MODE_ERROR;\n-    }\n-    bool IsInvalid(int &nDoSOut) const {\n+    bool IsValid() const { return mode == MODE_VALID; }\n+    bool IsInvalid() const { return mode == MODE_INVALID; }\n+    bool IsError() const { return mode == MODE_ERROR; }\n+    bool IsInvalid(int& nDoSOut) const\n+    {\n         if (IsInvalid()) {\n             nDoSOut = nDoS;\n             return true;\n         }\n         return false;\n     }\n-    bool CorruptionPossible() const {\n-        return corruptionPossible;\n-    }\n+    bool CorruptionPossible() const { return corruptionPossible; }\n     unsigned char GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n };\n \n /** RAII wrapper for VerifyDB: Verify consistency of the block and coin databases */\n-class CVerifyDB {\n+class CVerifyDB\n+{\n public:\n     CVerifyDB();\n     ~CVerifyDB();\n-    bool VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth);\n+    bool VerifyDB(CCoinsView* coinsview, int nCheckLevel, int nCheckDepth);\n };\n \n /** Find the last common block between the parameter chain and a locator. */\n@@ -602,10 +670,10 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n extern CChain chainActive;\n \n /** Global variable that points to the active CCoinsView (protected by cs_main) */\n-extern CCoinsViewCache *pcoinsTip;\n+extern CCoinsViewCache* pcoinsTip;\n \n /** Global variable that points to the active block tree (protected by cs_main) */\n-extern CBlockTreeDB *pblocktree;\n+extern CBlockTreeDB* pblocktree;\n \n struct CBlockTemplate\n {\n@@ -615,10 +683,6 @@ struct CBlockTemplate\n };\n \n \n-\n-\n-\n-\n /** Used to relay blocks as header + vector<merkle branch>\n  * to filtered nodes.\n  */\n@@ -642,22 +706,24 @@ class CMerkleBlock\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(header);\n         READWRITE(txn);\n     }\n };\n \n \n-class CValidationInterface {\n+class CValidationInterface\n+{\n protected:\n-    virtual void SyncTransaction(const CTransaction &tx, const CBlock *pblock) {};\n-    virtual void EraseFromWallet(const uint256 &hash) {};\n-    virtual void SetBestChain(const CBlockLocator &locator) {};\n-    virtual void UpdatedTransaction(const uint256 &hash) {};\n-    virtual void Inventory(const uint256 &hash) {};\n-    virtual void ResendWalletTransactions() {};\n-    virtual void BlockChecked(const CBlock&, const CValidationState&) {};\n+    virtual void SyncTransaction(const CTransaction& tx, const CBlock* pblock){};\n+    virtual void EraseFromWallet(const uint256& hash){};\n+    virtual void SetBestChain(const CBlockLocator& locator){};\n+    virtual void UpdatedTransaction(const uint256& hash){};\n+    virtual void Inventory(const uint256& hash){};\n+    virtual void ResendWalletTransactions(){};\n+    virtual void BlockChecked(const CBlock&, const CValidationState&){};\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterAllValidationInterfaces();"
      },
      {
        "sha": "043d53b2241636645526af8d6d8c2274a5611390",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 165,
        "deletions": 184,
        "changes": 349,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=925c5eb1768d68a56f6ec45c65322ef6fa169e45",
        "patch": "@@ -26,13 +26,11 @@\n \n using namespace std;\n \n-WalletModel::WalletModel(CWallet *wallet, OptionsModel *optionsModel, QObject *parent) :\n-    QObject(parent), wallet(wallet), optionsModel(optionsModel), addressTableModel(0),\n-    transactionTableModel(0),\n-    recentRequestsTableModel(0),\n-    cachedBalance(0), cachedUnconfirmedBalance(0), cachedImmatureBalance(0),\n-    cachedEncryptionStatus(Unencrypted),\n-    cachedNumBlocks(0)\n+WalletModel::WalletModel(CWallet* wallet, OptionsModel* optionsModel, QObject* parent)\n+    : QObject(parent), wallet(wallet), optionsModel(optionsModel), addressTableModel(0),\n+      transactionTableModel(0), recentRequestsTableModel(0), cachedBalance(0),\n+      cachedUnconfirmedBalance(0), cachedImmatureBalance(0), cachedEncryptionStatus(Unencrypted),\n+      cachedNumBlocks(0)\n {\n     fHaveWatchOnly = wallet->HaveWatchOnly();\n     fForceCheckBalanceChanged = false;\n@@ -49,20 +47,16 @@ WalletModel::WalletModel(CWallet *wallet, OptionsModel *optionsModel, QObject *p\n     subscribeToCoreSignals();\n }\n \n-WalletModel::~WalletModel()\n-{\n-    unsubscribeFromCoreSignals();\n-}\n+WalletModel::~WalletModel() { unsubscribeFromCoreSignals(); }\n \n-CAmount WalletModel::getBalance(const CCoinControl *coinControl) const\n+CAmount WalletModel::getBalance(const CCoinControl* coinControl) const\n {\n-    if (coinControl)\n-    {\n+    if (coinControl) {\n         CAmount nBalance = 0;\n         std::vector<COutput> vCoins;\n         wallet->AvailableCoins(vCoins, true, coinControl);\n-        BOOST_FOREACH(const COutput& out, vCoins)\n-            if(out.fSpendable)\n+        BOOST_FOREACH (const COutput& out, vCoins)\n+            if (out.fSpendable)\n                 nBalance += out.tx->vout[out.i].nValue;\n \n         return nBalance;\n@@ -71,25 +65,13 @@ CAmount WalletModel::getBalance(const CCoinControl *coinControl) const\n     return wallet->GetBalance();\n }\n \n-CAmount WalletModel::getUnconfirmedBalance() const\n-{\n-    return wallet->GetUnconfirmedBalance();\n-}\n+CAmount WalletModel::getUnconfirmedBalance() const { return wallet->GetUnconfirmedBalance(); }\n \n-CAmount WalletModel::getImmatureBalance() const\n-{\n-    return wallet->GetImmatureBalance();\n-}\n+CAmount WalletModel::getImmatureBalance() const { return wallet->GetImmatureBalance(); }\n \n-bool WalletModel::haveWatchOnly() const\n-{\n-    return fHaveWatchOnly;\n-}\n+bool WalletModel::haveWatchOnly() const { return fHaveWatchOnly; }\n \n-CAmount WalletModel::getWatchBalance() const\n-{\n-    return wallet->GetWatchOnlyBalance();\n-}\n+CAmount WalletModel::getWatchBalance() const { return wallet->GetWatchOnlyBalance(); }\n \n CAmount WalletModel::getWatchUnconfirmedBalance() const\n {\n@@ -105,7 +87,7 @@ void WalletModel::updateStatus()\n {\n     EncryptionStatus newEncryptionStatus = getEncryptionStatus();\n \n-    if(cachedEncryptionStatus != newEncryptionStatus)\n+    if (cachedEncryptionStatus != newEncryptionStatus)\n         emit encryptionStatusChanged(newEncryptionStatus);\n }\n \n@@ -115,21 +97,20 @@ void WalletModel::pollBalanceChanged()\n     // periodical polls if the core is holding the locks for a longer time -\n     // for example, during a wallet rescan.\n     TRY_LOCK(cs_main, lockMain);\n-    if(!lockMain)\n+    if (!lockMain)\n         return;\n     TRY_LOCK(wallet->cs_wallet, lockWallet);\n-    if(!lockWallet)\n+    if (!lockWallet)\n         return;\n \n-    if(fForceCheckBalanceChanged || chainActive.Height() != cachedNumBlocks)\n-    {\n+    if (fForceCheckBalanceChanged || chainActive.Height() != cachedNumBlocks) {\n         fForceCheckBalanceChanged = false;\n \n         // Balance and number of transactions might have changed\n         cachedNumBlocks = chainActive.Height();\n \n         checkBalanceChanged();\n-        if(transactionTableModel)\n+        if (transactionTableModel)\n             transactionTableModel->updateConfirmations();\n     }\n }\n@@ -142,24 +123,29 @@ void WalletModel::checkBalanceChanged()\n     CAmount newWatchOnlyBalance = 0;\n     CAmount newWatchUnconfBalance = 0;\n     CAmount newWatchImmatureBalance = 0;\n-    if (haveWatchOnly())\n-    {\n+    if (haveWatchOnly()) {\n         newWatchOnlyBalance = getWatchBalance();\n         newWatchUnconfBalance = getWatchUnconfirmedBalance();\n         newWatchImmatureBalance = getWatchImmatureBalance();\n     }\n \n-    if(cachedBalance != newBalance || cachedUnconfirmedBalance != newUnconfirmedBalance || cachedImmatureBalance != newImmatureBalance ||\n-        cachedWatchOnlyBalance != newWatchOnlyBalance || cachedWatchUnconfBalance != newWatchUnconfBalance || cachedWatchImmatureBalance != newWatchImmatureBalance)\n-    {\n+    if (cachedBalance != newBalance || cachedUnconfirmedBalance != newUnconfirmedBalance ||\n+        cachedImmatureBalance != newImmatureBalance ||\n+        cachedWatchOnlyBalance != newWatchOnlyBalance ||\n+        cachedWatchUnconfBalance != newWatchUnconfBalance ||\n+        cachedWatchImmatureBalance != newWatchImmatureBalance) {\n         cachedBalance = newBalance;\n         cachedUnconfirmedBalance = newUnconfirmedBalance;\n         cachedImmatureBalance = newImmatureBalance;\n         cachedWatchOnlyBalance = newWatchOnlyBalance;\n         cachedWatchUnconfBalance = newWatchUnconfBalance;\n         cachedWatchImmatureBalance = newWatchImmatureBalance;\n-        emit balanceChanged(newBalance, newUnconfirmedBalance, newImmatureBalance,\n-                            newWatchOnlyBalance, newWatchUnconfBalance, newWatchImmatureBalance);\n+        emit balanceChanged(newBalance,\n+                            newUnconfirmedBalance,\n+                            newImmatureBalance,\n+                            newWatchOnlyBalance,\n+                            newWatchUnconfBalance,\n+                            newWatchImmatureBalance);\n     }\n }\n \n@@ -169,10 +155,13 @@ void WalletModel::updateTransaction()\n     fForceCheckBalanceChanged = true;\n }\n \n-void WalletModel::updateAddressBook(const QString &address, const QString &label,\n-        bool isMine, const QString &purpose, int status)\n+void WalletModel::updateAddressBook(const QString& address,\n+                                    const QString& label,\n+                                    bool isMine,\n+                                    const QString& purpose,\n+                                    int status)\n {\n-    if(addressTableModel)\n+    if (addressTableModel)\n         addressTableModel->updateEntry(address, label, isMine, purpose, status);\n }\n \n@@ -182,76 +171,68 @@ void WalletModel::updateWatchOnlyFlag(bool fHaveWatchonly)\n     emit notifyWatchonlyChanged(fHaveWatchonly);\n }\n \n-bool WalletModel::validateAddress(const QString &address)\n+bool WalletModel::validateAddress(const QString& address)\n {\n     CBitcoinAddress addressParsed(address.toStdString());\n     return addressParsed.IsValid();\n }\n \n-WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction &transaction, const CCoinControl *coinControl)\n+WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction& transaction,\n+                                                             const CCoinControl* coinControl)\n {\n     CAmount total = 0;\n     QList<SendCoinsRecipient> recipients = transaction.getRecipients();\n     std::vector<std::pair<CScript, CAmount> > vecSend;\n \n-    if(recipients.empty())\n-    {\n+    if (recipients.empty()) {\n         return OK;\n     }\n \n     QSet<QString> setAddress; // Used to detect duplicates\n     int nAddresses = 0;\n \n     // Pre-check input data for validity\n-    foreach(const SendCoinsRecipient &rcp, recipients)\n-    {\n-        if (rcp.paymentRequest.IsInitialized())\n-        {   // PaymentRequest...\n+    foreach (const SendCoinsRecipient& rcp, recipients) {\n+        if (rcp.paymentRequest.IsInitialized()) { // PaymentRequest...\n             CAmount subtotal = 0;\n             const payments::PaymentDetails& details = rcp.paymentRequest.getDetails();\n-            for (int i = 0; i < details.outputs_size(); i++)\n-            {\n+            for (int i = 0; i < details.outputs_size(); i++) {\n                 const payments::Output& out = details.outputs(i);\n-                if (out.amount() <= 0) continue;\n+                if (out.amount() <= 0)\n+                    continue;\n                 subtotal += out.amount();\n                 const unsigned char* scriptStr = (const unsigned char*)out.script().data();\n-                CScript scriptPubKey(scriptStr, scriptStr+out.script().size());\n+                CScript scriptPubKey(scriptStr, scriptStr + out.script().size());\n                 vecSend.push_back(std::pair<CScript, CAmount>(scriptPubKey, out.amount()));\n             }\n-            if (subtotal <= 0)\n-            {\n+            if (subtotal <= 0) {\n                 return InvalidAmount;\n             }\n             total += subtotal;\n-        }\n-        else\n-        {   // User-entered bitcoin address / amount:\n-            if(!validateAddress(rcp.address))\n-            {\n+        } else { // User-entered bitcoin address / amount:\n+            if (!validateAddress(rcp.address)) {\n                 return InvalidAddress;\n             }\n-            if(rcp.amount <= 0)\n-            {\n+            if (rcp.amount <= 0) {\n                 return InvalidAmount;\n             }\n             setAddress.insert(rcp.address);\n             ++nAddresses;\n \n-            CScript scriptPubKey = GetScriptForDestination(CBitcoinAddress(rcp.address.toStdString()).Get());\n+            CScript scriptPubKey =\n+                GetScriptForDestination(CBitcoinAddress(rcp.address.toStdString()).Get());\n             vecSend.push_back(std::pair<CScript, CAmount>(scriptPubKey, rcp.amount));\n \n             total += rcp.amount;\n         }\n     }\n-    if(setAddress.size() != nAddresses)\n-    {\n+    if (setAddress.size() != nAddresses) {\n         return DuplicateAddress;\n     }\n \n     CAmount nBalance = getBalance(coinControl);\n \n-    if(total > nBalance)\n-    {\n+    if (total > nBalance) {\n         return AmountExceedsBalance;\n     }\n \n@@ -262,18 +243,18 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         CAmount nFeeRequired = 0;\n         std::string strFailReason;\n \n-        CWalletTx *newTx = transaction.getTransaction();\n-        CReserveKey *keyChange = transaction.getPossibleKeyChange();\n-        bool fCreated = wallet->CreateTransaction(vecSend, *newTx, *keyChange, nFeeRequired, strFailReason, coinControl);\n+        CWalletTx* newTx = transaction.getTransaction();\n+        CReserveKey* keyChange = transaction.getPossibleKeyChange();\n+        bool fCreated = wallet->CreateTransaction(\n+            vecSend, *newTx, *keyChange, nFeeRequired, strFailReason, coinControl);\n         transaction.setTransactionFee(nFeeRequired);\n \n-        if(!fCreated)\n-        {\n-            if((total + nFeeRequired) > nBalance)\n-            {\n+        if (!fCreated) {\n+            if ((total + nFeeRequired) > nBalance) {\n                 return SendCoinsReturn(AmountWithFeeExceedsBalance);\n             }\n-            emit message(tr(\"Send Coins\"), QString::fromStdString(strFailReason),\n+            emit message(tr(\"Send Coins\"),\n+                         QString::fromStdString(strFailReason),\n                          CClientUIInterface::MSG_ERROR);\n             return TransactionCreationFailed;\n         }\n@@ -286,30 +267,28 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n     return SendCoinsReturn(OK);\n }\n \n-WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &transaction)\n+WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction& transaction)\n {\n     QByteArray transaction_array; /* store serialized transaction */\n \n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n-        CWalletTx *newTx = transaction.getTransaction();\n+        CWalletTx* newTx = transaction.getTransaction();\n \n         // Store PaymentRequests in wtx.vOrderForm in wallet.\n-        foreach(const SendCoinsRecipient &rcp, transaction.getRecipients())\n-        {\n-            if (rcp.paymentRequest.IsInitialized())\n-            {\n+        foreach (const SendCoinsRecipient& rcp, transaction.getRecipients()) {\n+            if (rcp.paymentRequest.IsInitialized()) {\n                 std::string key(\"PaymentRequest\");\n                 std::string value;\n                 rcp.paymentRequest.SerializeToString(&value);\n                 newTx->vOrderForm.push_back(make_pair(key, value));\n-            }\n-            else if (!rcp.message.isEmpty()) // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n+            } else if (!rcp.message.isEmpty()) // Message from normal bitcoin:URI\n+                                               // (bitcoin:123...?message=example)\n                 newTx->vOrderForm.push_back(make_pair(\"Message\", rcp.message.toStdString()));\n         }\n \n-        CReserveKey *keyChange = transaction.getPossibleKeyChange();\n-        if(!wallet->CommitTransaction(*newTx, *keyChange))\n+        CReserveKey* keyChange = transaction.getPossibleKeyChange();\n+        if (!wallet->CommitTransaction(*newTx, *keyChange))\n             return TransactionCommitFailed;\n \n         CTransaction* t = (CTransaction*)newTx;\n@@ -320,102 +299,79 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n \n     // Add addresses / update labels that we've sent to to the address book,\n     // and emit coinsSent signal for each recipient\n-    foreach(const SendCoinsRecipient &rcp, transaction.getRecipients())\n-    {\n+    foreach (const SendCoinsRecipient& rcp, transaction.getRecipients()) {\n         // Don't touch the address book when we have a payment request\n-        if (!rcp.paymentRequest.IsInitialized())\n-        {\n+        if (!rcp.paymentRequest.IsInitialized()) {\n             std::string strAddress = rcp.address.toStdString();\n             CTxDestination dest = CBitcoinAddress(strAddress).Get();\n             std::string strLabel = rcp.label.toStdString();\n             {\n                 LOCK(wallet->cs_wallet);\n \n-                std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(dest);\n+                std::map<CTxDestination, CAddressBookData>::iterator mi =\n+                    wallet->mapAddressBook.find(dest);\n \n                 // Check if we have a new address or an updated label\n-                if (mi == wallet->mapAddressBook.end())\n-                {\n+                if (mi == wallet->mapAddressBook.end()) {\n                     wallet->SetAddressBook(dest, strLabel, \"send\");\n-                }\n-                else if (mi->second.name != strLabel)\n-                {\n+                } else if (mi->second.name != strLabel) {\n                     wallet->SetAddressBook(dest, strLabel, \"\"); // \"\" means don't change purpose\n                 }\n             }\n         }\n         emit coinsSent(wallet, rcp, transaction_array);\n     }\n-    checkBalanceChanged(); // update balance immediately, otherwise there could be a short noticeable delay until pollBalanceChanged hits\n+    checkBalanceChanged(); // update balance immediately, otherwise there could be a short\n+                           // noticeable delay until pollBalanceChanged hits\n \n     return SendCoinsReturn(OK);\n }\n \n-OptionsModel *WalletModel::getOptionsModel()\n-{\n-    return optionsModel;\n-}\n+OptionsModel* WalletModel::getOptionsModel() { return optionsModel; }\n \n-AddressTableModel *WalletModel::getAddressTableModel()\n-{\n-    return addressTableModel;\n-}\n+AddressTableModel* WalletModel::getAddressTableModel() { return addressTableModel; }\n \n-TransactionTableModel *WalletModel::getTransactionTableModel()\n-{\n-    return transactionTableModel;\n-}\n+TransactionTableModel* WalletModel::getTransactionTableModel() { return transactionTableModel; }\n \n-RecentRequestsTableModel *WalletModel::getRecentRequestsTableModel()\n+RecentRequestsTableModel* WalletModel::getRecentRequestsTableModel()\n {\n     return recentRequestsTableModel;\n }\n \n WalletModel::EncryptionStatus WalletModel::getEncryptionStatus() const\n {\n-    if(!wallet->IsCrypted())\n-    {\n+    if (!wallet->IsCrypted()) {\n         return Unencrypted;\n-    }\n-    else if(wallet->IsLocked())\n-    {\n+    } else if (wallet->IsLocked()) {\n         return Locked;\n-    }\n-    else\n-    {\n+    } else {\n         return Unlocked;\n     }\n }\n \n-bool WalletModel::setWalletEncrypted(bool encrypted, const SecureString &passphrase)\n+bool WalletModel::setWalletEncrypted(bool encrypted, const SecureString& passphrase)\n {\n-    if(encrypted)\n-    {\n+    if (encrypted) {\n         // Encrypt\n         return wallet->EncryptWallet(passphrase);\n-    }\n-    else\n-    {\n+    } else {\n         // Decrypt -- TODO; not supported yet\n         return false;\n     }\n }\n \n-bool WalletModel::setWalletLocked(bool locked, const SecureString &passPhrase)\n+bool WalletModel::setWalletLocked(bool locked, const SecureString& passPhrase)\n {\n-    if(locked)\n-    {\n+    if (locked) {\n         // Lock\n         return wallet->Lock();\n-    }\n-    else\n-    {\n+    } else {\n         // Unlock\n         return wallet->Unlock(passPhrase);\n     }\n }\n \n-bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureString &newPass)\n+bool WalletModel::changePassphrase(const SecureString& oldPass, const SecureString& newPass)\n {\n     bool retval;\n     {\n@@ -426,63 +382,80 @@ bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureStri\n     return retval;\n }\n \n-bool WalletModel::backupWallet(const QString &filename)\n+bool WalletModel::backupWallet(const QString& filename)\n {\n     return BackupWallet(*wallet, filename.toLocal8Bit().data());\n }\n \n // Handlers for core signals\n-static void NotifyKeyStoreStatusChanged(WalletModel *walletmodel, CCryptoKeyStore *wallet)\n+static void NotifyKeyStoreStatusChanged(WalletModel* walletmodel, CCryptoKeyStore* wallet)\n {\n     qDebug() << \"NotifyKeyStoreStatusChanged\";\n     QMetaObject::invokeMethod(walletmodel, \"updateStatus\", Qt::QueuedConnection);\n }\n \n-static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n-        const CTxDestination &address, const std::string &label, bool isMine,\n-        const std::string &purpose, ChangeType status)\n+static void NotifyAddressBookChanged(WalletModel* walletmodel,\n+                                     CWallet* wallet,\n+                                     const CTxDestination& address,\n+                                     const std::string& label,\n+                                     bool isMine,\n+                                     const std::string& purpose,\n+                                     ChangeType status)\n {\n     QString strAddress = QString::fromStdString(CBitcoinAddress(address).ToString());\n     QString strLabel = QString::fromStdString(label);\n     QString strPurpose = QString::fromStdString(purpose);\n \n-    qDebug() << \"NotifyAddressBookChanged : \" + strAddress + \" \" + strLabel + \" isMine=\" + QString::number(isMine) + \" purpose=\" + strPurpose + \" status=\" + QString::number(status);\n-    QMetaObject::invokeMethod(walletmodel, \"updateAddressBook\", Qt::QueuedConnection,\n+    qDebug() << \"NotifyAddressBookChanged : \" + strAddress + \" \" + strLabel + \" isMine=\" +\n+                    QString::number(isMine) + \" purpose=\" + strPurpose + \" status=\" +\n+                    QString::number(status);\n+    QMetaObject::invokeMethod(walletmodel,\n+                              \"updateAddressBook\",\n+                              Qt::QueuedConnection,\n                               Q_ARG(QString, strAddress),\n                               Q_ARG(QString, strLabel),\n                               Q_ARG(bool, isMine),\n                               Q_ARG(QString, strPurpose),\n                               Q_ARG(int, status));\n }\n \n-static void NotifyTransactionChanged(WalletModel *walletmodel, CWallet *wallet, const uint256 &hash, ChangeType status)\n+static void NotifyTransactionChanged(WalletModel* walletmodel,\n+                                     CWallet* wallet,\n+                                     const uint256& hash,\n+                                     ChangeType status)\n {\n     Q_UNUSED(wallet);\n     Q_UNUSED(hash);\n     Q_UNUSED(status);\n     QMetaObject::invokeMethod(walletmodel, \"updateTransaction\", Qt::QueuedConnection);\n }\n \n-static void ShowProgress(WalletModel *walletmodel, const std::string &title, int nProgress)\n+static void ShowProgress(WalletModel* walletmodel, const std::string& title, int nProgress)\n {\n     // emits signal \"showProgress\"\n-    QMetaObject::invokeMethod(walletmodel, \"showProgress\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(walletmodel,\n+                              \"showProgress\",\n+                              Qt::QueuedConnection,\n                               Q_ARG(QString, QString::fromStdString(title)),\n                               Q_ARG(int, nProgress));\n }\n \n-static void NotifyWatchonlyChanged(WalletModel *walletmodel, bool fHaveWatchonly)\n+static void NotifyWatchonlyChanged(WalletModel* walletmodel, bool fHaveWatchonly)\n {\n-    QMetaObject::invokeMethod(walletmodel, \"updateWatchOnlyFlag\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(walletmodel,\n+                              \"updateWatchOnlyFlag\",\n+                              Qt::QueuedConnection,\n                               Q_ARG(bool, fHaveWatchonly));\n }\n \n void WalletModel::subscribeToCoreSignals()\n {\n     // Connect signals to wallet\n     wallet->NotifyStatusChanged.connect(boost::bind(&NotifyKeyStoreStatusChanged, this, _1));\n-    wallet->NotifyAddressBookChanged.connect(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n-    wallet->NotifyTransactionChanged.connect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n+    wallet->NotifyAddressBookChanged.connect(\n+        boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n+    wallet->NotifyTransactionChanged.connect(\n+        boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n     wallet->ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n     wallet->NotifyWatchonlyChanged.connect(boost::bind(NotifyWatchonlyChanged, this, _1));\n }\n@@ -491,8 +464,10 @@ void WalletModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from wallet\n     wallet->NotifyStatusChanged.disconnect(boost::bind(&NotifyKeyStoreStatusChanged, this, _1));\n-    wallet->NotifyAddressBookChanged.disconnect(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n-    wallet->NotifyTransactionChanged.disconnect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n+    wallet->NotifyAddressBookChanged.disconnect(\n+        boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n+    wallet->NotifyTransactionChanged.disconnect(\n+        boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n     wallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n     wallet->NotifyWatchonlyChanged.disconnect(boost::bind(NotifyWatchonlyChanged, this, _1));\n }\n@@ -501,8 +476,7 @@ void WalletModel::unsubscribeFromCoreSignals()\n WalletModel::UnlockContext WalletModel::requestUnlock()\n {\n     bool was_locked = getEncryptionStatus() == Locked;\n-    if(was_locked)\n-    {\n+    if (was_locked) {\n         // Request UI to unlock wallet\n         emit requireUnlock();\n     }\n@@ -512,17 +486,14 @@ WalletModel::UnlockContext WalletModel::requestUnlock()\n     return UnlockContext(this, valid, was_locked);\n }\n \n-WalletModel::UnlockContext::UnlockContext(WalletModel *wallet, bool valid, bool relock):\n-        wallet(wallet),\n-        valid(valid),\n-        relock(relock)\n+WalletModel::UnlockContext::UnlockContext(WalletModel* wallet, bool valid, bool relock)\n+    : wallet(wallet), valid(valid), relock(relock)\n {\n }\n \n WalletModel::UnlockContext::~UnlockContext()\n {\n-    if(valid && relock)\n-    {\n+    if (valid && relock) {\n         wallet->setWalletLocked(true);\n     }\n }\n@@ -534,20 +505,22 @@ void WalletModel::UnlockContext::CopyFrom(const UnlockContext& rhs)\n     rhs.relock = false;\n }\n \n-bool WalletModel::getPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+bool WalletModel::getPubKey(const CKeyID& address, CPubKey& vchPubKeyOut) const\n {\n     return wallet->GetPubKey(address, vchPubKeyOut);\n }\n \n // returns a list of COutputs from COutPoints\n-void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs)\n+void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints,\n+                             std::vector<COutput>& vOutputs)\n {\n     LOCK2(cs_main, wallet->cs_wallet);\n-    BOOST_FOREACH(const COutPoint& outpoint, vOutpoints)\n-    {\n-        if (!wallet->mapWallet.count(outpoint.hash)) continue;\n+    BOOST_FOREACH (const COutPoint& outpoint, vOutpoints) {\n+        if (!wallet->mapWallet.count(outpoint.hash))\n+            continue;\n         int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n-        if (nDepth < 0) continue;\n+        if (nDepth < 0)\n+            continue;\n         COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth, true);\n         vOutputs.push_back(out);\n     }\n@@ -559,7 +532,8 @@ bool WalletModel::isSpent(const COutPoint& outpoint) const\n     return wallet->IsSpent(outpoint.hash, outpoint.n);\n }\n \n-// AvailableCoins + LockedCoins grouped by wallet address (put change in one group with wallet address)\n+// AvailableCoins + LockedCoins grouped by wallet address (put change in one group with wallet\n+// address)\n void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const\n {\n     std::vector<COutput> vCoins;\n@@ -570,28 +544,33 @@ void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins)\n     wallet->ListLockedCoins(vLockedCoins);\n \n     // add locked coins\n-    BOOST_FOREACH(const COutPoint& outpoint, vLockedCoins)\n-    {\n-        if (!wallet->mapWallet.count(outpoint.hash)) continue;\n+    BOOST_FOREACH (const COutPoint& outpoint, vLockedCoins) {\n+        if (!wallet->mapWallet.count(outpoint.hash))\n+            continue;\n         int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n-        if (nDepth < 0) continue;\n+        if (nDepth < 0)\n+            continue;\n         COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth, true);\n-        if (outpoint.n < out.tx->vout.size() && wallet->IsMine(out.tx->vout[outpoint.n]) == ISMINE_SPENDABLE)\n+        if (outpoint.n < out.tx->vout.size() &&\n+            wallet->IsMine(out.tx->vout[outpoint.n]) == ISMINE_SPENDABLE)\n             vCoins.push_back(out);\n     }\n \n-    BOOST_FOREACH(const COutput& out, vCoins)\n-    {\n+    BOOST_FOREACH (const COutput& out, vCoins) {\n         COutput cout = out;\n \n-        while (wallet->IsChange(cout.tx->vout[cout.i]) && cout.tx->vin.size() > 0 && wallet->IsMine(cout.tx->vin[0]))\n-        {\n-            if (!wallet->mapWallet.count(cout.tx->vin[0].prevout.hash)) break;\n-            cout = COutput(&wallet->mapWallet[cout.tx->vin[0].prevout.hash], cout.tx->vin[0].prevout.n, 0, true);\n+        while (wallet->IsChange(cout.tx->vout[cout.i]) && cout.tx->vin.size() > 0 &&\n+               wallet->IsMine(cout.tx->vin[0])) {\n+            if (!wallet->mapWallet.count(cout.tx->vin[0].prevout.hash))\n+                break;\n+            cout = COutput(&wallet->mapWallet[cout.tx->vin[0].prevout.hash],\n+                           cout.tx->vin[0].prevout.n,\n+                           0,\n+                           true);\n         }\n \n         CTxDestination address;\n-        if(!out.fSpendable || !ExtractDestination(cout.tx->vout[cout.i].scriptPubKey, address))\n+        if (!out.fSpendable || !ExtractDestination(cout.tx->vout[cout.i].scriptPubKey, address))\n             continue;\n         mapCoins[QString::fromStdString(CBitcoinAddress(address).ToString())].push_back(out);\n     }\n@@ -624,13 +603,15 @@ void WalletModel::listLockedCoins(std::vector<COutPoint>& vOutpts)\n void WalletModel::loadReceiveRequests(std::vector<std::string>& vReceiveRequests)\n {\n     LOCK(wallet->cs_wallet);\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, wallet->mapAddressBook)\n-        BOOST_FOREACH(const PAIRTYPE(std::string, std::string)& item2, item.second.destdata)\n-            if (item2.first.size() > 2 && item2.first.substr(0,2) == \"rr\") // receive request\n+    BOOST_FOREACH (const PAIRTYPE(CTxDestination, CAddressBookData) & item, wallet->mapAddressBook)\n+        BOOST_FOREACH (const PAIRTYPE(std::string, std::string) & item2, item.second.destdata)\n+            if (item2.first.size() > 2 && item2.first.substr(0, 2) == \"rr\") // receive request\n                 vReceiveRequests.push_back(item2.second);\n }\n \n-bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest)\n+bool WalletModel::saveReceiveRequest(const std::string& sAddress,\n+                                     const int64_t nId,\n+                                     const std::string& sRequest)\n {\n     CTxDestination dest = CBitcoinAddress(sAddress).Get();\n "
      },
      {
        "sha": "8fa986be841bb59c056dd68f78e8da0b6a21d6d9",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 74,
        "deletions": 55,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/925c5eb1768d68a56f6ec45c65322ef6fa169e45/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=925c5eb1768d68a56f6ec45c65322ef6fa169e45",
        "patch": "@@ -36,9 +36,15 @@ QT_END_NAMESPACE\n class SendCoinsRecipient\n {\n public:\n-    explicit SendCoinsRecipient() : amount(0), nVersion(SendCoinsRecipient::CURRENT_VERSION) { }\n-    explicit SendCoinsRecipient(const QString &addr, const QString &label, const CAmount& amount, const QString &message):\n-        address(addr), label(label), amount(amount), message(message), nVersion(SendCoinsRecipient::CURRENT_VERSION) {}\n+    explicit SendCoinsRecipient() : amount(0), nVersion(SendCoinsRecipient::CURRENT_VERSION) {}\n+    explicit SendCoinsRecipient(const QString& addr,\n+                                const QString& label,\n+                                const CAmount& amount,\n+                                const QString& message)\n+        : address(addr), label(label), amount(amount), message(message),\n+          nVersion(SendCoinsRecipient::CURRENT_VERSION)\n+    {\n+    }\n \n     // If from an insecure payment request, this is used for storing\n     // the addresses, e.g. address-A<br />address-B<br />address-C.\n@@ -62,7 +68,8 @@ class SendCoinsRecipient\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         std::string sAddress = address.toStdString();\n         std::string sLabel = label.toStdString();\n         std::string sMessage = message.toStdString();\n@@ -80,13 +87,13 @@ class SendCoinsRecipient\n         READWRITE(sPaymentRequest);\n         READWRITE(sAuthenticatedMerchant);\n \n-        if (ser_action.ForRead())\n-        {\n+        if (ser_action.ForRead()) {\n             address = QString::fromStdString(sAddress);\n             label = QString::fromStdString(sLabel);\n             message = QString::fromStdString(sMessage);\n             if (!sPaymentRequest.empty())\n-                paymentRequest.parse(QByteArray::fromRawData(sPaymentRequest.data(), sPaymentRequest.size()));\n+                paymentRequest.parse(\n+                    QByteArray::fromRawData(sPaymentRequest.data(), sPaymentRequest.size()));\n             authenticatedMerchant = QString::fromStdString(sAuthenticatedMerchant);\n         }\n     }\n@@ -98,35 +105,32 @@ class WalletModel : public QObject\n     Q_OBJECT\n \n public:\n-    explicit WalletModel(CWallet *wallet, OptionsModel *optionsModel, QObject *parent = 0);\n+    explicit WalletModel(CWallet* wallet, OptionsModel* optionsModel, QObject* parent = 0);\n     ~WalletModel();\n \n     enum StatusCode // Returned by sendCoins\n-    {\n-        OK,\n-        InvalidAmount,\n-        InvalidAddress,\n-        AmountExceedsBalance,\n-        AmountWithFeeExceedsBalance,\n-        DuplicateAddress,\n-        TransactionCreationFailed, // Error returned when wallet is still locked\n-        TransactionCommitFailed,\n-        InsaneFee\n+    { OK,\n+      InvalidAmount,\n+      InvalidAddress,\n+      AmountExceedsBalance,\n+      AmountWithFeeExceedsBalance,\n+      DuplicateAddress,\n+      TransactionCreationFailed, // Error returned when wallet is still locked\n+      TransactionCommitFailed,\n+      InsaneFee };\n+\n+    enum EncryptionStatus {\n+        Unencrypted, // !wallet->IsCrypted()\n+        Locked,      // wallet->IsCrypted() && wallet->IsLocked()\n+        Unlocked     // wallet->IsCrypted() && !wallet->IsLocked()\n     };\n \n-    enum EncryptionStatus\n-    {\n-        Unencrypted,  // !wallet->IsCrypted()\n-        Locked,       // wallet->IsCrypted() && wallet->IsLocked()\n-        Unlocked      // wallet->IsCrypted() && !wallet->IsLocked()\n-    };\n-\n-    OptionsModel *getOptionsModel();\n-    AddressTableModel *getAddressTableModel();\n-    TransactionTableModel *getTransactionTableModel();\n-    RecentRequestsTableModel *getRecentRequestsTableModel();\n+    OptionsModel* getOptionsModel();\n+    AddressTableModel* getAddressTableModel();\n+    TransactionTableModel* getTransactionTableModel();\n+    RecentRequestsTableModel* getRecentRequestsTableModel();\n \n-    CAmount getBalance(const CCoinControl *coinControl = NULL) const;\n+    CAmount getBalance(const CCoinControl* coinControl = NULL) const;\n     CAmount getUnconfirmedBalance() const;\n     CAmount getImmatureBalance() const;\n     bool haveWatchOnly() const;\n@@ -136,44 +140,49 @@ class WalletModel : public QObject\n     EncryptionStatus getEncryptionStatus() const;\n \n     // Check address for validity\n-    bool validateAddress(const QString &address);\n+    bool validateAddress(const QString& address);\n \n     // Return status record for SendCoins, contains error id + information\n     struct SendCoinsReturn\n     {\n-        SendCoinsReturn(StatusCode status = OK):\n-            status(status) {}\n+        SendCoinsReturn(StatusCode status = OK) : status(status) {}\n         StatusCode status;\n     };\n \n     // prepare transaction for getting txfee before sending coins\n-    SendCoinsReturn prepareTransaction(WalletModelTransaction &transaction, const CCoinControl *coinControl = NULL);\n+    SendCoinsReturn prepareTransaction(WalletModelTransaction& transaction,\n+                                       const CCoinControl* coinControl = NULL);\n \n     // Send coins to a list of recipients\n-    SendCoinsReturn sendCoins(WalletModelTransaction &transaction);\n+    SendCoinsReturn sendCoins(WalletModelTransaction& transaction);\n \n     // Wallet encryption\n-    bool setWalletEncrypted(bool encrypted, const SecureString &passphrase);\n+    bool setWalletEncrypted(bool encrypted, const SecureString& passphrase);\n     // Passphrase only needed when unlocking\n-    bool setWalletLocked(bool locked, const SecureString &passPhrase=SecureString());\n-    bool changePassphrase(const SecureString &oldPass, const SecureString &newPass);\n+    bool setWalletLocked(bool locked, const SecureString& passPhrase = SecureString());\n+    bool changePassphrase(const SecureString& oldPass, const SecureString& newPass);\n     // Wallet backup\n-    bool backupWallet(const QString &filename);\n+    bool backupWallet(const QString& filename);\n \n     // RAI object for unlocking wallet, returned by requestUnlock()\n     class UnlockContext\n     {\n     public:\n-        UnlockContext(WalletModel *wallet, bool valid, bool relock);\n+        UnlockContext(WalletModel* wallet, bool valid, bool relock);\n         ~UnlockContext();\n \n         bool isValid() const { return valid; }\n \n         // Copy operator and constructor transfer the context\n         UnlockContext(const UnlockContext& obj) { CopyFrom(obj); }\n-        UnlockContext& operator=(const UnlockContext& rhs) { CopyFrom(rhs); return *this; }\n+        UnlockContext& operator=(const UnlockContext& rhs)\n+        {\n+            CopyFrom(rhs);\n+            return *this;\n+        }\n+\n     private:\n-        WalletModel *wallet;\n+        WalletModel* wallet;\n         bool valid;\n         mutable bool relock; // mutable, as it can be set to false by copying\n \n@@ -182,7 +191,7 @@ class WalletModel : public QObject\n \n     UnlockContext requestUnlock();\n \n-    bool getPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n+    bool getPubKey(const CKeyID& address, CPubKey& vchPubKeyOut) const;\n     void getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs);\n     bool isSpent(const COutPoint& outpoint) const;\n     void listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const;\n@@ -193,20 +202,22 @@ class WalletModel : public QObject\n     void listLockedCoins(std::vector<COutPoint>& vOutpts);\n \n     void loadReceiveRequests(std::vector<std::string>& vReceiveRequests);\n-    bool saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest);\n+    bool saveReceiveRequest(const std::string& sAddress,\n+                            const int64_t nId,\n+                            const std::string& sRequest);\n \n private:\n-    CWallet *wallet;\n+    CWallet* wallet;\n     bool fHaveWatchOnly;\n     bool fForceCheckBalanceChanged;\n \n     // Wallet has an options model for wallet-specific options\n     // (transaction fee, for example)\n-    OptionsModel *optionsModel;\n+    OptionsModel* optionsModel;\n \n-    AddressTableModel *addressTableModel;\n-    TransactionTableModel *transactionTableModel;\n-    RecentRequestsTableModel *recentRequestsTableModel;\n+    AddressTableModel* addressTableModel;\n+    TransactionTableModel* transactionTableModel;\n+    RecentRequestsTableModel* recentRequestsTableModel;\n \n     // Cache some values to be able to detect changes\n     CAmount cachedBalance;\n@@ -218,16 +229,20 @@ class WalletModel : public QObject\n     EncryptionStatus cachedEncryptionStatus;\n     int cachedNumBlocks;\n \n-    QTimer *pollTimer;\n+    QTimer* pollTimer;\n \n     void subscribeToCoreSignals();\n     void unsubscribeFromCoreSignals();\n     void checkBalanceChanged();\n \n signals:\n     // Signal that balance in wallet changed\n-    void balanceChanged(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n-                        const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n+    void balanceChanged(const CAmount& balance,\n+                        const CAmount& unconfirmedBalance,\n+                        const CAmount& immatureBalance,\n+                        const CAmount& watchOnlyBalance,\n+                        const CAmount& watchUnconfBalance,\n+                        const CAmount& watchImmatureBalance);\n \n     // Encryption status of wallet changed\n     void encryptionStatusChanged(int status);\n@@ -238,13 +253,13 @@ class WalletModel : public QObject\n     void requireUnlock();\n \n     // Fired when a message should be reported to the user\n-    void message(const QString &title, const QString &message, unsigned int style);\n+    void message(const QString& title, const QString& message, unsigned int style);\n \n     // Coins sent: from wallet, to recipient, in (serialized) transaction:\n     void coinsSent(CWallet* wallet, SendCoinsRecipient recipient, QByteArray transaction);\n \n     // Show progress dialog e.g. for rescan\n-    void showProgress(const QString &title, int nProgress);\n+    void showProgress(const QString& title, int nProgress);\n \n     // Watch-only address added\n     void notifyWatchonlyChanged(bool fHaveWatchonly);\n@@ -255,7 +270,11 @@ public slots:\n     /* New transaction, or transaction changed status */\n     void updateTransaction();\n     /* New, updated or removed address book entry */\n-    void updateAddressBook(const QString &address, const QString &label, bool isMine, const QString &purpose, int status);\n+    void updateAddressBook(const QString& address,\n+                           const QString& label,\n+                           bool isMine,\n+                           const QString& purpose,\n+                           int status);\n     /* Watch-only added */\n     void updateWatchOnlyFlag(bool fHaveWatchonly);\n     /* Current, immature or unconfirmed balance might have changed - emit 'balanceChanged' if so */"
      }
    ]
  }
]