[
  {
    "sha": "facbfa5816b5c947627f9c840169484605a5ca38",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWNiZmE1ODE2YjVjOTQ3NjI3ZjljODQwMTY5NDg0NjA1YTVjYTM4",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-10-01T16:44:54Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-12-02T15:32:00Z"
      },
      "message": "[qa] Get rid of duplicate code",
      "tree": {
        "sha": "275206718968d6aad879059233fde1a7a4fe35f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/275206718968d6aad879059233fde1a7a4fe35f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/facbfa5816b5c947627f9c840169484605a5ca38",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/facbfa5816b5c947627f9c840169484605a5ca38",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/facbfa5816b5c947627f9c840169484605a5ca38",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/facbfa5816b5c947627f9c840169484605a5ca38/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e22f409f18881b63a8e747036584a71217f40e6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e22f409f18881b63a8e747036584a71217f40e6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e22f409f18881b63a8e747036584a71217f40e6e"
      }
    ],
    "stats": {
      "total": 101,
      "additions": 19,
      "deletions": 82
    },
    "files": [
      {
        "sha": "83168a7ce7a4fe179dd1a3a70a214eb3e69a550d",
        "filename": "qa/rpc-tests/maxuploadtarget.py",
        "status": "modified",
        "additions": 2,
        "deletions": 36,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facbfa5816b5c947627f9c840169484605a5ca38/qa/rpc-tests/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facbfa5816b5c947627f9c840169484605a5ca38/qa/rpc-tests/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxuploadtarget.py?ref=facbfa5816b5c947627f9c840169484605a5ca38",
        "patch": "@@ -81,49 +81,16 @@ def received_pong():\n \n class MaxUploadTest(BitcoinTestFramework):\n  \n-    def add_options(self, parser):\n-        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"bitcoind binary to test\")\n-\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n \n-        self.utxo = []\n-        self.txouts = gen_return_txouts()\n-\n     def setup_network(self):\n         # Start a node with maxuploadtarget of 200 MB (/24h)\n         self.nodes = []\n         self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]))\n \n-    def mine_full_block(self, node, address):\n-        # Want to create a full block\n-        # We'll generate a 66k transaction below, and 14 of them is close to the 1MB block limit\n-        for j in range(14):\n-            if len(self.utxo) < 14:\n-                self.utxo = node.listunspent()\n-            inputs=[]\n-            outputs = {}\n-            t = self.utxo.pop()\n-            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n-            remchange = t[\"amount\"] - Decimal(\"0.001000\")\n-            outputs[address]=remchange\n-            # Create a basic transaction that will send change back to ourself after account for a fee\n-            # And then insert the 128 generated transaction outs in the middle rawtx[92] is where the #\n-            # of txouts is stored and is the only thing we overwrite from the original transaction\n-            rawtx = node.createrawtransaction(inputs, outputs)\n-            newtx = rawtx[0:92]\n-            newtx = newtx + self.txouts\n-            newtx = newtx + rawtx[94:]\n-            # Appears to be ever so slightly faster to sign with SIGHASH_NONE\n-            signresult = node.signrawtransaction(newtx,None,None,\"NONE\")\n-            txid = node.sendrawtransaction(signresult[\"hex\"], True)\n-        # Mine a full sized block which will be these transactions we just created\n-        node.generate(1)\n-\n     def run_test(self):\n         # Before we connect anything, we first set the time on the node\n         # to be in the past, otherwise things break because the CNode\n@@ -151,7 +118,7 @@ def run_test(self):\n         # Test logic begins here\n \n         # Now mine a big block\n-        self.mine_full_block(self.nodes[0], self.nodes[0].getnewaddress())\n+        mine_large_block(self.nodes[0])\n \n         # Store the hash; we'll request this later\n         big_old_block = self.nodes[0].getbestblockhash()\n@@ -162,11 +129,10 @@ def run_test(self):\n         self.nodes[0].setmocktime(int(time.time()) - 2*60*60*24)\n \n         # Mine one more block, so that the prior block looks old\n-        self.mine_full_block(self.nodes[0], self.nodes[0].getnewaddress())\n+        mine_large_block(self.nodes[0])\n \n         # We'll be requesting this new block too\n         big_new_block = self.nodes[0].getbestblockhash()\n-        new_block_size = self.nodes[0].getblock(big_new_block)['size']\n         big_new_block = int(big_new_block, 16)\n \n         # test_nodes[0] will test what happens if we just keep requesting the"
      },
      {
        "sha": "6635b0dff23150ef67835b684631305056da66f5",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "modified",
        "additions": 4,
        "deletions": 41,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facbfa5816b5c947627f9c840169484605a5ca38/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facbfa5816b5c947627f9c840169484605a5ca38/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=facbfa5816b5c947627f9c840169484605a5ca38",
        "patch": "@@ -24,10 +24,6 @@ def __init__(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n \n-        self.utxo = []\n-        self.address = [\"\",\"\"]\n-        self.txouts = gen_return_txouts()\n-\n     def setup_network(self):\n         self.nodes = []\n         self.is_network_split = False\n@@ -40,12 +36,6 @@ def setup_network(self):\n         self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n         self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n \n-        self.address[0] = self.nodes[0].getnewaddress()\n-        self.address[1] = self.nodes[1].getnewaddress()\n-\n-        # Determine default relay fee\n-        self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n-\n         connect_nodes(self.nodes[0], 1)\n         connect_nodes(self.nodes[1], 2)\n         connect_nodes(self.nodes[2], 0)\n@@ -58,7 +48,7 @@ def create_big_chain(self):\n         self.nodes[0].generate(150)\n         # Then mine enough full blocks to create more than 550MiB of data\n         for i in range(645):\n-            self.mine_full_block(self.nodes[0], self.address[0])\n+            mine_large_block(self.nodes[0])\n \n         sync_blocks(self.nodes[0:3])\n \n@@ -70,7 +60,7 @@ def test_height_min(self):\n         print(\"Mining 25 more blocks should cause the first block file to be pruned\")\n         # Pruning doesn't run until we're allocating another chunk, 20 full blocks past the height cutoff will ensure this\n         for i in range(25):\n-            self.mine_full_block(self.nodes[0],self.address[0])\n+            mine_large_block(self.nodes[0])\n \n         waitstart = time.time()\n         while os.path.isfile(self.prunedir+\"blk00000.dat\"):\n@@ -95,17 +85,15 @@ def create_chain_with_staleblocks(self):\n             stop_node(self.nodes[0],0)\n             self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n             # Mine 24 blocks in node 1\n-            self.utxo = self.nodes[1].listunspent()\n             for i in range(24):\n                 if j == 0:\n-                    self.mine_full_block(self.nodes[1],self.address[1])\n+                    mine_large_block(self.nodes[1])\n                 else:\n                     self.nodes[1].generate(1) #tx's already in mempool from previous disconnects\n \n             # Reorg back with 25 block chain from node 0\n-            self.utxo = self.nodes[0].listunspent()\n             for i in range(25):\n-                self.mine_full_block(self.nodes[0],self.address[0])\n+                mine_large_block(self.nodes[0])\n \n             # Create connections in the order so both nodes can see the reorg at the same time\n             connect_nodes(self.nodes[1], 0)\n@@ -217,31 +205,6 @@ def reorg_back(self):\n         # Verify we can now have the data for a block previously pruned\n         assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n \n-    def mine_full_block(self, node, address):\n-        # Want to create a full block\n-        # We'll generate a 66k transaction below, and 14 of them is close to the 1MB block limit\n-        for j in range(14):\n-            if len(self.utxo) < 14:\n-                self.utxo = node.listunspent()\n-            inputs=[]\n-            outputs = {}\n-            t = self.utxo.pop()\n-            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n-            remchange = t[\"amount\"] - 100*self.relayfee # Fee must be above min relay rate for 66kb tx\n-            outputs[address]=remchange\n-            # Create a basic transaction that will send change back to ourself after account for a fee\n-            # And then insert the 128 generated transaction outs in the middle rawtx[92] is where the #\n-            # of txouts is stored and is the only thing we overwrite from the original transaction\n-            rawtx = node.createrawtransaction(inputs, outputs)\n-            newtx = rawtx[0:92]\n-            newtx = newtx + self.txouts\n-            newtx = newtx + rawtx[94:]\n-            # Appears to be ever so slightly faster to sign with SIGHASH_NONE\n-            signresult = node.signrawtransaction(newtx,None,None,\"NONE\")\n-            txid = node.sendrawtransaction(signresult[\"hex\"], True)\n-        # Mine a full sized block which will be these transactions we just created\n-        node.generate(1)\n-\n \n     def run_test(self):\n         print(\"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\")"
      },
      {
        "sha": "2c428d1687c76b37a13a808541774aeb0daf8c59",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facbfa5816b5c947627f9c840169484605a5ca38/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facbfa5816b5c947627f9c840169484605a5ca38/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=facbfa5816b5c947627f9c840169484605a5ca38",
        "patch": "@@ -657,13 +657,12 @@ def create_tx(node, coinbase, to_address, amount):\n def create_lots_of_big_transactions(node, txouts, utxos, fee):\n     addr = node.getnewaddress()\n     txids = []\n-    for i in range(len(utxos)):\n+    for _ in range(len(utxos)):\n         t = utxos.pop()\n-        inputs = []\n-        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n+        inputs=[{ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]}]\n         outputs = {}\n-        send_value = t['amount'] - fee\n-        outputs[addr] = satoshi_round(send_value)\n+        change = t['amount'] - fee\n+        outputs[addr] = satoshi_round(change)\n         rawtx = node.createrawtransaction(inputs, outputs)\n         newtx = rawtx[0:92]\n         newtx = newtx + txouts\n@@ -673,6 +672,15 @@ def create_lots_of_big_transactions(node, txouts, utxos, fee):\n         txids.append(txid)\n     return txids\n \n+def mine_large_block(node):\n+    # generate a 66k transaction,\n+    # and 14 of them is close to the 1MB block limit\n+    txouts = gen_return_txouts()\n+    utxos = node.listunspent()[:14]\n+    fee = 100 * node.getnetworkinfo()[\"relayfee\"]\n+    create_lots_of_big_transactions(node, txouts, utxos, fee=fee)\n+    node.generate(1)\n+\n def get_bip9_status(node, key):\n     info = node.getblockchaininfo()\n     return info['bip9_softforks'][key]"
      }
    ]
  }
]