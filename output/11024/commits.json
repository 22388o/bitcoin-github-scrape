[
  {
    "sha": "a897d0e37a02d29907c3a3f0f6536a26a155751d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphODk3ZDBlMzdhMDJkMjk5MDdjM2EzZjBmNjUzNmEyNmExNTU3NTFk",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-08-11T07:24:26Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-08-14T15:52:06Z"
      },
      "message": "tests: Remove OldSetKeyFromPassphrase/OldEncrypt/OldDecrypt",
      "tree": {
        "sha": "cb1e3f8d5b7893ea173b3ad61ba326c6a67d0142",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb1e3f8d5b7893ea173b3ad61ba326c6a67d0142"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a897d0e37a02d29907c3a3f0f6536a26a155751d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a897d0e37a02d29907c3a3f0f6536a26a155751d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a897d0e37a02d29907c3a3f0f6536a26a155751d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a897d0e37a02d29907c3a3f0f6536a26a155751d/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "140de14a12228cf7af44f59f40a937c2910a0158",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/140de14a12228cf7af44f59f40a937c2910a0158",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/140de14a12228cf7af44f59f40a937c2910a0158"
      }
    ],
    "stats": {
      "total": 133,
      "additions": 11,
      "deletions": 122
    },
    "files": [
      {
        "sha": "cbd74b6f960f4a6d7c35de93a2aea39238c51099",
        "filename": "src/wallet/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 122,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a897d0e37a02d29907c3a3f0f6536a26a155751d/src/wallet/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a897d0e37a02d29907c3a3f0f6536a26a155751d/src/wallet/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/crypto_tests.cpp?ref=a897d0e37a02d29907c3a3f0f6536a26a155751d",
        "patch": "@@ -9,112 +9,25 @@\n #include <vector>\n \n #include <boost/test/unit_test.hpp>\n-#include <openssl/aes.h>\n-#include <openssl/evp.h>\n \n BOOST_FIXTURE_TEST_SUITE(wallet_crypto, BasicTestingSetup)\n \n-bool OldSetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod, unsigned char* chKey, unsigned char* chIV)\n-{\n-    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n-        return false;\n-\n-    int i = 0;\n-    if (nDerivationMethod == 0)\n-        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n-                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n-\n-    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n-    {\n-        memory_cleanse(chKey, WALLET_CRYPTO_KEY_SIZE);\n-        memory_cleanse(chIV, WALLET_CRYPTO_IV_SIZE);\n-        return false;\n-    }\n-    return true;\n-}\n-\n-bool OldEncrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext, const unsigned char chKey[32], const unsigned char chIV[16])\n-{\n-    // max ciphertext len for a n bytes of plaintext is\n-    // n + AES_BLOCK_SIZE - 1 bytes\n-    int nLen = vchPlaintext.size();\n-    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n-    vchCiphertext = std::vector<unsigned char> (nCLen);\n-\n-    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n-\n-    if (!ctx) return false;\n-\n-    bool fOk = true;\n-\n-    EVP_CIPHER_CTX_init(ctx);\n-    if (fOk) fOk = EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, chKey, chIV) != 0;\n-    if (fOk) fOk = EVP_EncryptUpdate(ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n-    if (fOk) fOk = EVP_EncryptFinal_ex(ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n-    EVP_CIPHER_CTX_cleanup(ctx);\n-\n-    EVP_CIPHER_CTX_free(ctx);\n-\n-    if (!fOk) return false;\n-\n-    vchCiphertext.resize(nCLen + nFLen);\n-    return true;\n-}\n-\n-bool OldDecrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext, const unsigned char chKey[32], const unsigned char chIV[16])\n-{\n-    // plaintext will always be equal to or lesser than length of ciphertext\n-    int nLen = vchCiphertext.size();\n-    int nPLen = nLen, nFLen = 0;\n-\n-    vchPlaintext = CKeyingMaterial(nPLen);\n-\n-    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n-\n-    if (!ctx) return false;\n-\n-    bool fOk = true;\n-\n-    EVP_CIPHER_CTX_init(ctx);\n-    if (fOk) fOk = EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, chKey, chIV) != 0;\n-    if (fOk) fOk = EVP_DecryptUpdate(ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n-    if (fOk) fOk = EVP_DecryptFinal_ex(ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n-    EVP_CIPHER_CTX_cleanup(ctx);\n-\n-    EVP_CIPHER_CTX_free(ctx);\n-\n-    if (!fOk) return false;\n-\n-    vchPlaintext.resize(nPLen + nFLen);\n-    return true;\n-}\n-\n class TestCrypter\n {\n public:\n static void TestPassphraseSingle(const std::vector<unsigned char>& vchSalt, const SecureString& passphrase, uint32_t rounds,\n                  const std::vector<unsigned char>& correctKey = std::vector<unsigned char>(),\n                  const std::vector<unsigned char>& correctIV=std::vector<unsigned char>())\n {\n-    unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n-    unsigned char chIV[WALLET_CRYPTO_IV_SIZE];\n-\n     CCrypter crypt;\n     crypt.SetKeyFromPassphrase(passphrase, vchSalt, rounds, 0);\n \n-    OldSetKeyFromPassphrase(passphrase, vchSalt, rounds, 0, chKey, chIV);\n-\n-    BOOST_CHECK_MESSAGE(memcmp(chKey, crypt.vchKey.data(), crypt.vchKey.size()) == 0, \\\n-        HexStr(chKey, chKey+sizeof(chKey)) + std::string(\" != \") + HexStr(crypt.vchKey));\n-    BOOST_CHECK_MESSAGE(memcmp(chIV, crypt.vchIV.data(), crypt.vchIV.size()) == 0, \\\n-        HexStr(chIV, chIV+sizeof(chIV)) + std::string(\" != \") + HexStr(crypt.vchIV));\n-\n     if(!correctKey.empty())\n-        BOOST_CHECK_MESSAGE(memcmp(chKey, &correctKey[0], sizeof(chKey)) == 0, \\\n-            HexStr(chKey, chKey+sizeof(chKey)) + std::string(\" != \") + HexStr(correctKey.begin(), correctKey.end()));\n+        BOOST_CHECK_MESSAGE(memcmp(crypt.vchKey.data(), correctKey.data(), crypt.vchKey.size()) == 0, \\\n+            HexStr(crypt.vchKey.begin(), crypt.vchKey.end()) + std::string(\" != \") + HexStr(correctKey.begin(), correctKey.end()));\n     if(!correctIV.empty())\n-        BOOST_CHECK_MESSAGE(memcmp(chIV, &correctIV[0], sizeof(chIV)) == 0,\n-            HexStr(chIV, chIV+sizeof(chIV)) + std::string(\" != \") + HexStr(correctIV.begin(), correctIV.end()));\n+        BOOST_CHECK_MESSAGE(memcmp(crypt.vchIV.data(), correctIV.data(), crypt.vchIV.size()) == 0,\n+            HexStr(crypt.vchIV.begin(), crypt.vchIV.end()) + std::string(\" != \") + HexStr(correctIV.begin(), correctIV.end()));\n }\n \n static void TestPassphrase(const std::vector<unsigned char>& vchSalt, const SecureString& passphrase, uint32_t rounds,\n@@ -126,50 +39,26 @@ static void TestPassphrase(const std::vector<unsigned char>& vchSalt, const Secu\n         TestPassphraseSingle(vchSalt, SecureString(i, passphrase.end()), rounds);\n }\n \n-\n static void TestDecrypt(const CCrypter& crypt, const std::vector<unsigned char>& vchCiphertext, \\\n                         const std::vector<unsigned char>& vchPlaintext = std::vector<unsigned char>())\n {\n-    CKeyingMaterial vchDecrypted1;\n-    CKeyingMaterial vchDecrypted2;\n-    int result1, result2;\n-    result1 = crypt.Decrypt(vchCiphertext, vchDecrypted1);\n-    result2 = OldDecrypt(vchCiphertext, vchDecrypted2, crypt.vchKey.data(), crypt.vchIV.data());\n-    BOOST_CHECK(result1 == result2);\n-\n-    // These two should be equal. However, OpenSSL 1.0.1j introduced a change\n-    // that would zero all padding except for the last byte for failed decrypts.\n-    // This behavior was reverted for 1.0.1k.\n-    if (vchDecrypted1 != vchDecrypted2 && vchDecrypted1.size() >= AES_BLOCK_SIZE && SSLeay() == 0x100010afL)\n-    {\n-        for(CKeyingMaterial::iterator it = vchDecrypted1.end() - AES_BLOCK_SIZE; it != vchDecrypted1.end() - 1; it++)\n-            *it = 0;\n-    }\n-\n-    BOOST_CHECK_MESSAGE(vchDecrypted1 == vchDecrypted2, HexStr(vchDecrypted1.begin(), vchDecrypted1.end()) + \" != \" + HexStr(vchDecrypted2.begin(), vchDecrypted2.end()));\n-\n+    CKeyingMaterial vchDecrypted;\n+    crypt.Decrypt(vchCiphertext, vchDecrypted);\n     if (vchPlaintext.size())\n-        BOOST_CHECK(CKeyingMaterial(vchPlaintext.begin(), vchPlaintext.end()) == vchDecrypted2);\n+        BOOST_CHECK(CKeyingMaterial(vchPlaintext.begin(), vchPlaintext.end()) == vchDecrypted);\n }\n \n static void TestEncryptSingle(const CCrypter& crypt, const CKeyingMaterial& vchPlaintext,\n                        const std::vector<unsigned char>& vchCiphertextCorrect = std::vector<unsigned char>())\n {\n-    std::vector<unsigned char> vchCiphertext1;\n-    std::vector<unsigned char> vchCiphertext2;\n-    int result1 = crypt.Encrypt(vchPlaintext, vchCiphertext1);\n-\n-    int result2 = OldEncrypt(vchPlaintext, vchCiphertext2, crypt.vchKey.data(), crypt.vchIV.data());\n-    BOOST_CHECK(result1 == result2);\n-    BOOST_CHECK(vchCiphertext1 == vchCiphertext2);\n+    std::vector<unsigned char> vchCiphertext;\n+    crypt.Encrypt(vchPlaintext, vchCiphertext);\n \n     if (!vchCiphertextCorrect.empty())\n-        BOOST_CHECK(vchCiphertext2 == vchCiphertextCorrect);\n+        BOOST_CHECK(vchCiphertext == vchCiphertextCorrect);\n \n     const std::vector<unsigned char> vchPlaintext2(vchPlaintext.begin(), vchPlaintext.end());\n-\n-    if(vchCiphertext1 == vchCiphertext2)\n-        TestDecrypt(crypt, vchCiphertext1, vchPlaintext2);\n+    TestDecrypt(crypt, vchCiphertext, vchPlaintext2);\n }\n \n static void TestEncrypt(const CCrypter& crypt, const std::vector<unsigned char>& vchPlaintextIn, \\"
      }
    ]
  }
]