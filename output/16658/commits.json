[
  {
    "sha": "6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZjY0NjVjZWZjZDU5OWM4OWMwMGY3YjUxZjQyYTRiODdhNWZmYjBi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-08-19T15:55:38Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-11-07T18:50:58Z"
      },
      "message": "scripted-diff: [validation] Rename CheckInputs to CheckInputScripts\n\nCheckInputs() used to check no double spends, scripts & sigs and amounts. Since\n832e0744cb8b1e1625cdb19b257f97316ac16a90, the double spend and amount checks\nhave been moved to CheckTxInputs(), and CheckInputs() now just validates\ninput scripts. Rename the function to CheckInputScripts().\n\n-BEGIN VERIFY SCRIPT-\nsed -i -E -e 's/CheckInputs\\b/CheckInputScripts/g' $(git grep -l CheckInputs | grep -v doc/)\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "9b57ba3019b860971c29794a499d067f27b8bdcf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b57ba3019b860971c29794a499d067f27b8bdcf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "270616228bc9a3856a0a82dea26ac3480b7585cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/270616228bc9a3856a0a82dea26ac3480b7585cd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/270616228bc9a3856a0a82dea26ac3480b7585cd"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 33,
      "deletions": 33
    },
    "files": [
      {
        "sha": "5931e82b9d3a6ea8d1b05c86fd34990a913d382f",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "patch": "@@ -47,7 +47,7 @@ extern unsigned nMaxDatacarrierBytes;\n  * but in the future other flags may be added, such as a soft-fork to enforce\n  * strict DER encoding.\n  *\n- * Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n+ * Failing one of these tests may trigger a DoS ban - see CheckInputScripts() for\n  * details.\n  */\n static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;"
      },
      {
        "sha": "61539637c13948767e866840f688369c3786b332",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "patch": "@@ -13,7 +13,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n \n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n@@ -97,8 +97,8 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK_EQUAL(mempool.size(), 0U);\n }\n \n-// Run CheckInputs (using CoinsTip()) on the given transaction, for all script\n-// flags.  Test that CheckInputs passes for all flags that don't overlap with\n+// Run CheckInputScripts (using CoinsTip()) on the given transaction, for all script\n+// flags.  Test that CheckInputScripts passes for all flags that don't overlap with\n // the failing_flags argument, but otherwise fails.\n // CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n // get reassigned) have an interaction with DISCOURAGE_UPGRADABLE_NOPS: if\n@@ -125,8 +125,8 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n             // WITNESS requires P2SH\n             test_flags |= SCRIPT_VERIFY_P2SH;\n         }\n-        bool ret = CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, nullptr);\n-        // CheckInputs should succeed iff test_flags doesn't intersect with\n+        bool ret = CheckInputScripts(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, nullptr);\n+        // CheckInputScripts should succeed iff test_flags doesn't intersect with\n         // failing_flags\n         bool expected_return_value = !(test_flags & failing_flags);\n         BOOST_CHECK_EQUAL(ret, expected_return_value);\n@@ -135,21 +135,21 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n         if (ret && add_to_cache) {\n             // Check that we get a cache hit if the tx was valid\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputScripts(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK(scriptchecks.empty());\n         } else {\n             // Check that we get script executions to check, if the transaction\n             // was invalid, or we didn't add to cache.\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputScripts(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n         }\n     }\n }\n \n BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n {\n-    // Test that passing CheckInputs with one set of script flags doesn't imply\n+    // Test that passing CheckInputScripts with one set of script flags doesn't imply\n     // that we would pass again with a different set of flags.\n     {\n         LOCK(cs_main);\n@@ -204,16 +204,16 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         TxValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputScripts(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputScripts(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n-        // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n+        // Test that CheckInputScripts returns true iff DERSIG-enforcing flags are\n         // not present.  Don't add these checks to the cache, so that we can\n         // test later that block validation works fine in the absence of cached\n         // successes.\n@@ -272,7 +272,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         TxValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputScripts(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -300,12 +300,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         TxValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputScripts(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n \n-    // Test that passing CheckInputs with a valid witness doesn't imply success\n+    // Test that passing CheckInputScripts with a valid witness doesn't imply success\n     // for the same tx with a different witness.\n     {\n         CMutableTransaction valid_with_witness_tx;\n@@ -362,12 +362,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         TxValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputScripts(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputScripts(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      },
      {
        "sha": "f142e683c575b85a6161bdd23d322832b83a0d0f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "patch": "@@ -183,7 +183,7 @@ std::unique_ptr<CBlockTreeDB> pblocktree;\n // See definition for documentation\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n+bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n@@ -399,15 +399,15 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationS\n \n     // pool.cs should be locked already, but go ahead and re-take the lock here\n     // to enforce that mempool doesn't change between when we check the view\n-    // and when we actually call through to CheckInputs\n+    // and when we actually call through to CheckInputScripts\n     LOCK(pool.cs);\n \n     assert(!tx.IsCoinBase());\n     for (const CTxIn& txin : tx.vin) {\n         const Coin& coin = view.AccessCoin(txin.prevout);\n \n         // At this point we haven't actually checked if the coins are all\n-        // available (or shouldn't assume we have, since CheckInputs does).\n+        // available (or shouldn't assume we have, since CheckInputScripts does).\n         // So we just return failure if the inputs are not available here,\n         // and then only have to check equivalence for available inputs.\n         if (coin.IsSpent()) return false;\n@@ -424,8 +424,8 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationS\n         }\n     }\n \n-    // Call CheckInputs() to cache signature and script validity against current tip consensus rules.\n-    return CheckInputs(tx, state, view, flags, /* cacheSigStore = */ true, /* cacheFullSciptStore = */ true, txdata);\n+    // Call CheckInputScripts() to cache signature and script validity against current tip consensus rules.\n+    return CheckInputScripts(tx, state, view, flags, /* cacheSigStore = */ true, /* cacheFullSciptStore = */ true, txdata);\n }\n \n namespace {\n@@ -911,18 +911,18 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n \n     // Check against previous transactions\n     // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-    if (!CheckInputs(tx, state, m_view, scriptVerifyFlags, true, false, txdata)) {\n+    if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, txdata)) {\n         // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n         // need to turn both off, and compare against just turning off CLEANSTACK\n         // to see if the failure is specifically due to witness validation.\n-        TxValidationState state_dummy; // Want reported failures to be from first CheckInputs\n-        if (!tx.HasWitness() && CheckInputs(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n-                !CheckInputs(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n+        TxValidationState state_dummy; // Want reported failures to be from first CheckInputScripts\n+        if (!tx.HasWitness() && CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n             // Only the witness is missing, so the transaction itself may be fine.\n             state.Invalid(TxValidationResult::TX_WITNESS_MUTATED,\n                     state.GetRejectReason(), state.GetDebugMessage());\n         }\n-        return false; // state filled in by CheckInputs\n+        return false; // state filled in by CheckInputScripts\n     }\n \n     return true;\n@@ -953,7 +953,7 @@ bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, Workspace& ws, Precomp\n     // transactions into the mempool can be exploited as a DoS attack.\n     unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(::ChainActive().Tip(), chainparams.GetConsensus());\n     if (!CheckInputsFromMempoolAndCache(tx, state, m_view, m_pool, currentBlockScriptVerifyFlags, txdata)) {\n-        return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputs failed against latest-block but not STANDARD flags %s, %s\",\n+        return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputScripts failed against latest-block but not STANDARD flags %s, %s\",\n                 __func__, hash.ToString(), FormatStateMessage(state));\n     }\n \n@@ -1485,7 +1485,7 @@ void InitScriptExecutionCache() {\n  *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (tx.IsCoinBase()) return true;\n \n@@ -2132,11 +2132,11 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n             TxValidationState tx_state;\n-            if (fScriptChecks && !CheckInputs(tx, tx_state, view, flags, fCacheResults, fCacheResults, txdata[i], g_parallel_script_checks ? &vChecks : nullptr)) {\n+            if (fScriptChecks && !CheckInputScripts(tx, tx_state, view, flags, fCacheResults, fCacheResults, txdata[i], g_parallel_script_checks ? &vChecks : nullptr)) {\n                 // Any transaction validation failure in ConnectBlock is a block consensus failure\n                 state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n                               tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n-                return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n+                return error(\"ConnectBlock(): CheckInputScripts on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             control.Add(vChecks);"
      },
      {
        "sha": "2c6f2e733b21ec1cdd3270d489181f1cc44ff207",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "patch": "@@ -135,7 +135,7 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputs on {} failed with non-mandatory-script-verify-flag (Negative locktime)'.format(block.vtx[-1].hash)]):\n+        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputScripts on {} failed with non-mandatory-script-verify-flag (Negative locktime)'.format(block.vtx[-1].hash)]):\n             self.nodes[0].p2p.send_and_ping(msg_block(block))\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n             self.nodes[0].p2p.sync_with_ping()"
      },
      {
        "sha": "27da49cf243e49f0e0513ff8fa53b704dc0cdb01",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "patch": "@@ -120,7 +120,7 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputs on {} failed with non-mandatory-script-verify-flag (Non-canonical DER signature)'.format(block.vtx[-1].hash)]):\n+        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputScripts on {} failed with non-mandatory-script-verify-flag (Non-canonical DER signature)'.format(block.vtx[-1].hash)]):\n             self.nodes[0].p2p.send_and_ping(msg_block(block))\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n             self.nodes[0].p2p.sync_with_ping()"
      }
    ]
  },
  {
    "sha": "3bd8db80d8d335ab63ece4f110b0fadd562e80b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYmQ4ZGI4MGQ4ZDMzNWFiNjNlY2U0ZjExMGIwZmFkZDU2MmU4MGI3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-08-19T16:10:45Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-11-07T18:51:02Z"
      },
      "message": "[validation] fix comments in CheckInputScripts()",
      "tree": {
        "sha": "5c1abca4053d42f5a3b021d3ecc2ac21d6bd32ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c1abca4053d42f5a3b021d3ecc2ac21d6bd32ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3bd8db80d8d335ab63ece4f110b0fadd562e80b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bd8db80d8d335ab63ece4f110b0fadd562e80b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3bd8db80d8d335ab63ece4f110b0fadd562e80b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bd8db80d8d335ab63ece4f110b0fadd562e80b7/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6f6465cefcd599c89c00f7b51f42a4b87a5ffb0b"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 9,
      "deletions": 7
    },
    "files": [
      {
        "sha": "7fb683f7765a914deac0c1d401ae1342972c7e9d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3bd8db80d8d335ab63ece4f110b0fadd562e80b7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3bd8db80d8d335ab63ece4f110b0fadd562e80b7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3bd8db80d8d335ab63ece4f110b0fadd562e80b7",
        "patch": "@@ -406,12 +406,12 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationS\n     for (const CTxIn& txin : tx.vin) {\n         const Coin& coin = view.AccessCoin(txin.prevout);\n \n-        // At this point we haven't actually checked if the coins are all\n-        // available (or shouldn't assume we have, since CheckInputScripts does).\n-        // So we just return failure if the inputs are not available here,\n-        // and then only have to check equivalence for available inputs.\n+        // AcceptToMemoryPoolWorker has already checked that the coins are\n+        // available, so this shouldn't fail. If the inputs are not available\n+        // here then return false.\n         if (coin.IsSpent()) return false;\n \n+        // Check equivalence for available inputs.\n         const CTransactionRef& txFrom = pool.get(txin.prevout.hash);\n         if (txFrom) {\n             assert(txFrom->GetHash() == txin.prevout.hash);\n@@ -909,7 +909,7 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n \n     constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n \n-    // Check against previous transactions\n+    // Check input scripts and signatures.\n     // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n     if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, txdata)) {\n         // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n@@ -1469,8 +1469,10 @@ void InitScriptExecutionCache() {\n }\n \n /**\n- * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n- * This does not modify the UTXO set.\n+ * Check whether all of this transaction's input scripts succeed.\n+ *\n+ * This involves ECDSA signature checks so can be computationally intensive. This function should\n+ * only be called after the cheap sanity checks in CheckTxInputs passed.\n  *\n  * If pvChecks is not nullptr, script checks are pushed onto it instead of being performed inline. Any\n  * script checks which are not necessary (eg due to script execution cache hits) are, obviously,"
      }
    ]
  }
]