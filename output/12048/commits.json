[
  {
    "sha": "1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZTBlZTkwOTVjZTg3YTNjZWUwYjQ0YTEyMGY2Mjk3YWM2NzJmNWQw",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2017-12-29T10:36:11Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2017-12-29T10:36:11Z"
      },
      "message": "Use best-fit strategy in Arena, now O(log(n)) instead O(n)\n\nThis replaces the first-fit algorithm used in the Arena with a best-fit. According to \"Dynamic Storage Allocation: A Survey and Critical Review\", Wilson et. al. 1995, http://www.scs.stanford.edu/14wi-cs140/sched/readings/wilson.pdf, both startegies work well in practice.\n\nThe advantage of using best-fit is that we can switch the slow O(n) algorithm to O(log(n)) operations. Additionally, some previously O(log(n)) operations are now replaced with O(1) operations by using a hash map. The end effect is that the benchmark runs about 2.5 times faster on my machine:\n\nold: BenchLockedPool, 5, 530, 5.25749, 0.00196938, 0.00199755, 0.00198172\nnew: BenchLockedPool, 5, 1300, 5.11313, 0.000781493, 0.000793314, 0.00078606\n\nI've run all unit tests and benchmarks.",
      "tree": {
        "sha": "36ac4110adf4859e426474a24cad4a7a69d4bad7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/36ac4110adf4859e426474a24cad4a7a69d4bad7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5180a86c96bc05d2a731f70f36aae28ab5a3fad4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5180a86c96bc05d2a731f70f36aae28ab5a3fad4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5180a86c96bc05d2a731f70f36aae28ab5a3fad4"
      }
    ],
    "stats": {
      "total": 91,
      "additions": 60,
      "deletions": 31
    },
    "files": [
      {
        "sha": "8b7fe5f60904885e28fdc7a90dfb424f2a3f0714",
        "filename": "src/bench/lockedpool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
        "patch": "@@ -43,4 +43,4 @@ static void BenchLockedPool(benchmark::State& state)\n     addr.clear();\n }\n \n-BENCHMARK(BenchLockedPool, 530);\n+BENCHMARK(BenchLockedPool, 1300);"
      },
      {
        "sha": "ddb84b6523d8b79ce61eb81b5953632cd15a5068",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 25,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
        "patch": "@@ -47,7 +47,9 @@ Arena::Arena(void *base_in, size_t size_in, size_t alignment_in):\n     base(static_cast<char*>(base_in)), end(static_cast<char*>(base_in) + size_in), alignment(alignment_in)\n {\n     // Start with one free chunk that covers the entire arena\n-    chunks_free.emplace(base, size_in);\n+    auto it = size_to_free_chunk.emplace(size_in, base);\n+    chunks_free.emplace(base, it);\n+    chunks_free_end.emplace(base + size_in, it);\n }\n \n Arena::~Arena()\n@@ -63,26 +65,30 @@ void* Arena::alloc(size_t size)\n     if (size == 0)\n         return nullptr;\n \n-    // Pick a large enough free-chunk\n-    auto it = std::find_if(chunks_free.begin(), chunks_free.end(),\n-        [=](const std::map<char*, size_t>::value_type& chunk){ return chunk.second >= size; });\n-    if (it == chunks_free.end())\n+    // Pick a large enough free-chunk. Returns an iterator pointing to the first element that is not less than key.\n+    // This allocation strategy is best-fit. According to \"Dynamic Storage Allocation: A Survey and Critical Review\",\n+    // Wilson et. al. 1995, http://www.scs.stanford.edu/14wi-cs140/sched/readings/wilson.pdf, best-fit and first-fit\n+    // policies seem to work well in practice.\n+    auto sizePtrIt = size_to_free_chunk.lower_bound(size);\n+    if (sizePtrIt == size_to_free_chunk.end())\n         return nullptr;\n \n     // Create the used-chunk, taking its space from the end of the free-chunk\n-    auto alloced = chunks_used.emplace(it->first + it->second - size, size).first;\n-    if (!(it->second -= size))\n-        chunks_free.erase(it);\n-    return reinterpret_cast<void*>(alloced->first);\n-}\n-\n-/* extend the Iterator if other begins at its end */\n-template <class Iterator, class Pair> bool extend(Iterator it, const Pair& other) {\n-    if (it->first + it->second == other.first) {\n-        it->second += other.second;\n-        return true;\n+    const size_t sizeRemaining = sizePtrIt->first - size;\n+    auto alloced = chunks_used.emplace(sizePtrIt->second + sizeRemaining, size).first;\n+    chunks_free_end.erase(sizePtrIt->second + sizePtrIt->first);\n+    if (sizePtrIt->first == size) {\n+        // whole chunk is used up\n+        chunks_free.erase(sizePtrIt->second);\n+    } else {\n+        // still some memory left in the chunk\n+        auto itRemaining = size_to_free_chunk.emplace(sizeRemaining, sizePtrIt->second);\n+        chunks_free[sizePtrIt->second] = itRemaining;\n+        chunks_free_end.emplace(sizePtrIt->second + sizeRemaining, itRemaining);\n     }\n-    return false;\n+    size_to_free_chunk.erase(sizePtrIt);\n+\n+    return reinterpret_cast<void*>(alloced->first);\n }\n \n void Arena::free(void *ptr)\n@@ -97,16 +103,30 @@ void Arena::free(void *ptr)\n     if (i == chunks_used.end()) {\n         throw std::runtime_error(\"Arena: invalid or double free\");\n     }\n-    auto freed = *i;\n+    std::pair<char*, size_t> freed = *i;\n     chunks_used.erase(i);\n \n-    // Add space to free map, coalescing contiguous chunks\n-    auto next = chunks_free.upper_bound(freed.first);\n-    auto prev = (next == chunks_free.begin()) ? chunks_free.end() : std::prev(next);\n-    if (prev == chunks_free.end() || !extend(prev, freed))\n-        prev = chunks_free.emplace_hint(next, freed);\n-    if (next != chunks_free.end() && extend(prev, *next))\n+    // Coalesc freed with previous chunk\n+    auto prev = chunks_free_end.find(freed.first);\n+    if (prev != chunks_free_end.end()) {\n+        freed.first -= prev->second->first;\n+        freed.second += prev->second->first;\n+        size_to_free_chunk.erase(prev->second);\n+        chunks_free_end.erase(prev);\n+    }\n+\n+    // Coalesc freed with chunk after freed\n+    auto next = chunks_free.find(freed.first + freed.second);\n+    if (next != chunks_free.end()) {\n+        freed.second += next->second->first;\n+        size_to_free_chunk.erase(next->second);\n         chunks_free.erase(next);\n+    }\n+\n+    // Add/set space with coalesced free chunk\n+    auto it = size_to_free_chunk.emplace(freed.second, freed.first);\n+    chunks_free[freed.first] = it;\n+    chunks_free_end[freed.first + freed.second] = it;\n }\n \n Arena::Stats Arena::stats() const\n@@ -115,7 +135,7 @@ Arena::Stats Arena::stats() const\n     for (const auto& chunk: chunks_used)\n         r.used += chunk.second;\n     for (const auto& chunk: chunks_free)\n-        r.free += chunk.second;\n+        r.free += chunk.second->first;\n     r.total = r.used + r.free;\n     return r;\n }"
      },
      {
        "sha": "3b6f82c6c70fabde5ed8f38cb20e3c17121e8914",
        "filename": "src/support/lockedpool.h",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/src/support/lockedpool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0/src/support/lockedpool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.h?ref=1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
        "patch": "@@ -10,6 +10,7 @@\n #include <map>\n #include <mutex>\n #include <memory>\n+#include <unordered_map>\n \n /**\n  * OS-dependent allocation and deallocation of locked/pinned memory pages.\n@@ -88,11 +89,19 @@ class Arena\n      */\n     bool addressInArena(void *ptr) const { return ptr >= base && ptr < end; }\n private:\n-    /** Map of chunk address to chunk information. This class makes use of the\n-     * sorted order to merge previous and next chunks during deallocation.\n-     */\n-    std::map<char*, size_t> chunks_free;\n-    std::map<char*, size_t> chunks_used;\n+    typedef std::multimap<size_t, char*> SizeToChunkSortedMap;\n+    /** Map to enable O(log(n)) best-fit allocation, as it's sorted by size */\n+    SizeToChunkSortedMap size_to_free_chunk;\n+\n+    typedef std::unordered_map<char*, SizeToChunkSortedMap::const_iterator> ChunkToSizeMap;\n+    /** Map from begin of free chunk to its node in size_to_free_chunk */\n+    ChunkToSizeMap chunks_free;\n+    /** Map from end of free chunk to its node in size_to_free_chunk */\n+    ChunkToSizeMap chunks_free_end;\n+\n+    /** Map from begin of used chunk to its size */\n+    std::unordered_map<char*, size_t> chunks_used;\n+\n     /** Base address of arena */\n     char* base;\n     /** End address of arena */"
      }
    ]
  },
  {
    "sha": "5fbf7c478a996974502d5d787b2ccf2fcc91ac78",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZmJmN2M0NzhhOTk2OTc0NTAyZDVkNzg3YjJjY2YyZmNjOTFhYzc4",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2018-01-06T08:13:41Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2018-01-06T08:13:41Z"
      },
      "message": "fix nits: variable naming, typos",
      "tree": {
        "sha": "0fffb9e9207a05bd2cd5867c9b1b70108276093e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0fffb9e9207a05bd2cd5867c9b1b70108276093e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5fbf7c478a996974502d5d787b2ccf2fcc91ac78",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fbf7c478a996974502d5d787b2ccf2fcc91ac78",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5fbf7c478a996974502d5d787b2ccf2fcc91ac78",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fbf7c478a996974502d5d787b2ccf2fcc91ac78/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1e0ee9095ce87a3cee0b44a120f6297ac672f5d0"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 13,
      "deletions": 13
    },
    "files": [
      {
        "sha": "195412985abde6866457257e3cb38662fc7ae4a5",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fbf7c478a996974502d5d787b2ccf2fcc91ac78/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fbf7c478a996974502d5d787b2ccf2fcc91ac78/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=5fbf7c478a996974502d5d787b2ccf2fcc91ac78",
        "patch": "@@ -69,24 +69,24 @@ void* Arena::alloc(size_t size)\n     // This allocation strategy is best-fit. According to \"Dynamic Storage Allocation: A Survey and Critical Review\",\n     // Wilson et. al. 1995, http://www.scs.stanford.edu/14wi-cs140/sched/readings/wilson.pdf, best-fit and first-fit\n     // policies seem to work well in practice.\n-    auto sizePtrIt = size_to_free_chunk.lower_bound(size);\n-    if (sizePtrIt == size_to_free_chunk.end())\n+    auto size_ptr_it = size_to_free_chunk.lower_bound(size);\n+    if (size_ptr_it == size_to_free_chunk.end())\n         return nullptr;\n \n     // Create the used-chunk, taking its space from the end of the free-chunk\n-    const size_t sizeRemaining = sizePtrIt->first - size;\n-    auto alloced = chunks_used.emplace(sizePtrIt->second + sizeRemaining, size).first;\n-    chunks_free_end.erase(sizePtrIt->second + sizePtrIt->first);\n-    if (sizePtrIt->first == size) {\n+    const size_t size_remaining = size_ptr_it->first - size;\n+    auto alloced = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;\n+    chunks_free_end.erase(size_ptr_it->second + size_ptr_it->first);\n+    if (size_ptr_it->first == size) {\n         // whole chunk is used up\n-        chunks_free.erase(sizePtrIt->second);\n+        chunks_free.erase(size_ptr_it->second);\n     } else {\n         // still some memory left in the chunk\n-        auto itRemaining = size_to_free_chunk.emplace(sizeRemaining, sizePtrIt->second);\n-        chunks_free[sizePtrIt->second] = itRemaining;\n-        chunks_free_end.emplace(sizePtrIt->second + sizeRemaining, itRemaining);\n+        auto it_remaining = size_to_free_chunk.emplace(size_remaining, size_ptr_it->second);\n+        chunks_free[size_ptr_it->second] = it_remaining;\n+        chunks_free_end.emplace(size_ptr_it->second + size_remaining, it_remaining);\n     }\n-    size_to_free_chunk.erase(sizePtrIt);\n+    size_to_free_chunk.erase(size_ptr_it);\n \n     return reinterpret_cast<void*>(alloced->first);\n }\n@@ -106,7 +106,7 @@ void Arena::free(void *ptr)\n     std::pair<char*, size_t> freed = *i;\n     chunks_used.erase(i);\n \n-    // Coalesc freed with previous chunk\n+    // coalesce freed with previous chunk\n     auto prev = chunks_free_end.find(freed.first);\n     if (prev != chunks_free_end.end()) {\n         freed.first -= prev->second->first;\n@@ -115,7 +115,7 @@ void Arena::free(void *ptr)\n         chunks_free_end.erase(prev);\n     }\n \n-    // Coalesc freed with chunk after freed\n+    // coalesce freed with chunk after freed\n     auto next = chunks_free.find(freed.first + freed.second);\n     if (next != chunks_free.end()) {\n         freed.second += next->second->first;"
      }
    ]
  }
]