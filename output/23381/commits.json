[
  {
    "sha": "0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
    "node_id": "C_kwDOABII59oAKDBhNzllYWJhNzI5ZTYwYTgzYjBlNjA0ZTZhMThlOWJhMWNhMWJjODg",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-07-20T09:41:00Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T14:57:26Z"
      },
      "message": "[validation] case-based constructors for ATMPArgs\n\nNo change in behavior.\nATMPArgs can continue to have granular rules like switching BIP125\non/off while we create an interface for the different sets of rules for\nsingle transactions vs multiple-testmempoolaccept vs package validation.\nThis is a cleaner interface than manually constructing the args, which\nmakes it easy to mix up ordering, use the wrong default, etc. It also\nmeans we don't need to edit ATMP/single transaction validation code\nevery time we update ATMPArgs for package validation.",
      "tree": {
        "sha": "6ce9e958531edbe9f1f228121b8bcb834465c417",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6ce9e958531edbe9f1f228121b8bcb834465c417"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ab25ef8c7f767258d5fe44f53b35ad8bd51ed5cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab25ef8c7f767258d5fe44f53b35ad8bd51ed5cd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ab25ef8c7f767258d5fe44f53b35ad8bd51ed5cd"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 32,
      "deletions": 6
    },
    "files": [
      {
        "sha": "66b65c320d123a2cd1136d26b25ddcc1b961bccf",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 6,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
        "patch": "@@ -450,7 +450,36 @@ class MemPoolAccept\n         /** Whether we allow transactions to replace mempool transactions by BIP125 rules. If false,\n          * any transaction spending the same inputs as a transaction in the mempool is considered\n          * a conflict. */\n-        const bool m_allow_bip125_replacement{true};\n+        const bool m_allow_bip125_replacement;\n+\n+        /** Parameters for single transaction mempool validation. */\n+        static ATMPArgs SingleAccept(const CChainParams& chainparams, int64_t accept_time,\n+                                     bool bypass_limits, std::vector<COutPoint>& coins_to_uncache,\n+                                     bool test_accept) {\n+            return ATMPArgs{/* m_chainparams */ chainparams,\n+                            /* m_accept_time */ accept_time,\n+                            /* m_bypass_limits */ bypass_limits,\n+                            /* m_coins_to_uncache */ coins_to_uncache,\n+                            /* m_test_accept */ test_accept,\n+                            /* m_allow_bip125_replacement */ true,\n+            };\n+        }\n+\n+        /** Parameters for test package mempool validation through testmempoolaccept. */\n+        static ATMPArgs PackageTestAccept(const CChainParams& chainparams, int64_t accept_time,\n+                                          std::vector<COutPoint>& coins_to_uncache) {\n+            return ATMPArgs{/* m_chainparams */ chainparams,\n+                            /* m_accept_time */ accept_time,\n+                            /* m_bypass_limits */ false,\n+                            /* m_coins_to_uncache */ coins_to_uncache,\n+                            /* m_test_accept */ true,\n+                            /* m_allow_bip125_replacement */ false,\n+            };\n+        }\n+\n+        // No default ctor to avoid exposing details to clients and allowing the possibility of\n+        // mixing up the order of the arguments. Use static functions above instead.\n+        ATMPArgs() = delete;\n     };\n \n     // Single transaction acceptance\n@@ -1019,9 +1048,7 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n                                                       EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits, coins_to_uncache,\n-                                   test_accept, /* m_allow_bip125_replacement */ true };\n-\n+    auto args = MemPoolAccept::ATMPArgs::SingleAccept(chainparams, nAcceptTime, bypass_limits, coins_to_uncache, test_accept);\n     const MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);\n     if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n         // Remove coins that were not present in the coins cache before calling\n@@ -1054,8 +1081,7 @@ PackageMempoolAcceptResult ProcessNewPackage(CChainState& active_chainstate, CTx\n \n     std::vector<COutPoint> coins_to_uncache;\n     const CChainParams& chainparams = Params();\n-    MemPoolAccept::ATMPArgs args { chainparams, GetTime(), /* bypass_limits */ false, coins_to_uncache,\n-                                   test_accept, /* m_allow_bip125_replacement */ false };\n+    auto args = MemPoolAccept::ATMPArgs::PackageTestAccept(chainparams, GetTime(), coins_to_uncache);\n     const PackageMempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptMultipleTransactions(package, args);\n \n     // Uncache coins pertaining to transactions that were not submitted to the mempool."
      }
    ]
  },
  {
    "sha": "cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
    "node_id": "C_kwDOABII59oAKGNiYjM1OThiNWNlMmJlYTU4YThjYjFhZDIxNjdkN2QxZDA3OWFjZjc",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-07-20T10:38:44Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T14:58:53Z"
      },
      "message": "[validation/refactor] store precomputed txdata in workspace\n\nWe want to be able to re-use the precomputed transaction data between\nPolicyScriptChecks and ConsensusScriptChecks in\nAcceptMultipleTransactions.",
      "tree": {
        "sha": "9e68c1545205f59645dc0ed55fa9a344b54fe00f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9e68c1545205f59645dc0ed55fa9a344b54fe00f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a79eaba729e60a83b0e604e6a18e9ba1ca1bc88"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 17,
      "deletions": 18
    },
    "files": [
      {
        "sha": "841aaebe0e01922848b2682f908a5506401a8505",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 18,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
        "patch": "@@ -513,6 +513,9 @@ class MemPoolAccept\n         const CTransactionRef& m_ptx;\n         const uint256& m_hash;\n         TxValidationState m_state;\n+        /** A temporary cache containing serialized transaction data for signature verification.\n+         * Reused across PolicyScriptChecks and ConsensusScriptChecks. */\n+        PrecomputedTransactionData m_precomputed_txdata;\n     };\n \n     // Run the policy checks on a given transaction, excluding any script checks.\n@@ -523,13 +526,13 @@ class MemPoolAccept\n \n     // Run the script checks using our policy flags. As this can be slow, we should\n     // only invoke this on transactions that have otherwise passed policy checks.\n-    bool PolicyScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool PolicyScriptChecks(const ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Re-run the script checks, using consensus flags, and try to cache the\n     // result in the scriptcache. This should be done after\n     // PolicyScriptChecks(). This requires that all inputs either be in our\n     // utxo set or in the mempool.\n-    bool ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Try to add the transaction to the mempool, removing any conflicts first.\n     // Returns true if the transaction is in the mempool after any size\n@@ -842,7 +845,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     return true;\n }\n \n-bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata)\n+bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs& args, Workspace& ws)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     TxValidationState& state = ws.m_state;\n@@ -851,13 +854,13 @@ bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs& args, Workspace& ws, Prec\n \n     // Check input scripts and signatures.\n     // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-    if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, txdata)) {\n+    if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, ws.m_precomputed_txdata)) {\n         // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n         // need to turn both off, and compare against just turning off CLEANSTACK\n         // to see if the failure is specifically due to witness validation.\n         TxValidationState state_dummy; // Want reported failures to be from first CheckInputScripts\n-        if (!tx.HasWitness() && CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n-                !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n+        if (!tx.HasWitness() && CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, ws.m_precomputed_txdata) &&\n+                !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, ws.m_precomputed_txdata)) {\n             // Only the witness is missing, so the transaction itself may be fine.\n             state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED,\n                     state.GetRejectReason(), state.GetDebugMessage());\n@@ -868,7 +871,7 @@ bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs& args, Workspace& ws, Prec\n     return true;\n }\n \n-bool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata)\n+bool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n@@ -891,7 +894,8 @@ bool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, P\n     // invalid blocks (using TestBlockValidity), however allowing such\n     // transactions into the mempool can be exploited as a DoS attack.\n     unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(m_active_chainstate.m_chain.Tip(), chainparams.GetConsensus());\n-    if (!CheckInputsFromMempoolAndCache(tx, state, m_view, m_pool, currentBlockScriptVerifyFlags, txdata, m_active_chainstate.CoinsTip())) {\n+    if (!CheckInputsFromMempoolAndCache(tx, state, m_view, m_pool, currentBlockScriptVerifyFlags,\n+                                        ws.m_precomputed_txdata, m_active_chainstate.CoinsTip())) {\n         return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputScripts failed against latest-block but not STANDARD flags %s, %s\",\n                 __func__, hash.ToString(), state.ToString());\n     }\n@@ -952,15 +956,11 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef\n \n     if (!PreChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);\n \n-    // Only compute the precomputed transaction data if we need to verify\n-    // scripts (ie, other policy checks pass). We perform the inexpensive\n-    // checks first and avoid hashing and signature verification unless those\n-    // checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n-    PrecomputedTransactionData txdata;\n+    // Perform the inexpensive checks first and avoid hashing and signature verification unless\n+    // those checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n+    if (!PolicyScriptChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);\n \n-    if (!PolicyScriptChecks(args, ws, txdata)) return MempoolAcceptResult::Failure(ws.m_state);\n-\n-    if (!ConsensusScriptChecks(args, ws, txdata)) return MempoolAcceptResult::Failure(ws.m_state);\n+    if (!ConsensusScriptChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);\n \n     // Tx was accepted, but not added\n     if (args.m_test_accept) {\n@@ -1020,8 +1020,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n     }\n \n     for (Workspace& ws : workspaces) {\n-        PrecomputedTransactionData txdata;\n-        if (!PolicyScriptChecks(args, ws, txdata)) {\n+        if (!PolicyScriptChecks(args, ws)) {\n             // Exit early to avoid doing pointless work. Update the failed tx result; the rest are unfinished.\n             package_state.Invalid(PackageValidationResult::PCKG_TX, \"transaction failed\");\n             results.emplace(ws.m_ptx->GetWitnessHash(), MempoolAcceptResult::Failure(ws.m_state));"
      }
    ]
  },
  {
    "sha": "8fa2936b34fda9c0bea963311fa80a04b4bf5867",
    "node_id": "C_kwDOABII59oAKDhmYTI5MzZiMzRmZGE5YzBiZWE5NjMzMTFmYTgwYTA0YjRiZjU4Njc",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T12:25:23Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T14:58:54Z"
      },
      "message": "[validation] re-introduce bool for whether a transaction is RBF\n\nThis bool was originally part of Workspace and was removed in #22539\nwhen it was no longer needed in Finalize(). Re-introducing it because,\nonce again, multiple functions will need to know whether we're doing an\nRBF. Member of MemPoolAccept so that we can use this to inform package\nRBF in the future.",
      "tree": {
        "sha": "fb848595955dfb27749b169bdeab1411f2a525c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb848595955dfb27749b169bdeab1411f2a525c6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8fa2936b34fda9c0bea963311fa80a04b4bf5867",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fa2936b34fda9c0bea963311fa80a04b4bf5867",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8fa2936b34fda9c0bea963311fa80a04b4bf5867",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fa2936b34fda9c0bea963311fa80a04b4bf5867/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cbb3598b5ce2bea58a8cb1ad2167d7d1d079acf7"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 5,
      "deletions": 2
    },
    "files": [
      {
        "sha": "c32309b21497bdeaeacc3568fc7e2ba283105fe9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fa2936b34fda9c0bea963311fa80a04b4bf5867/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fa2936b34fda9c0bea963311fa80a04b4bf5867/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8fa2936b34fda9c0bea963311fa80a04b4bf5867",
        "patch": "@@ -568,6 +568,9 @@ class MemPoolAccept\n     // in-mempool conflicts; see below).\n     size_t m_limit_descendants;\n     size_t m_limit_descendant_size;\n+\n+    /** Whether the transaction(s) would replace any mempool transactions. If so, RBF rules apply. */\n+    bool m_rbf{false};\n };\n \n bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n@@ -808,8 +811,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-spends-conflicting-tx\", *err_string);\n     }\n \n-\n-    if (!setConflicts.empty()) {\n+    m_rbf = !setConflicts.empty();\n+    if (m_rbf) {\n         CFeeRate newFeeRate(nModifiedFees, nSize);\n         // It's possible that the replacement pays more fees than its direct conflicts but not more\n         // than all conflicts (i.e. the direct conflicts have high-fee descendants). However, if the"
      }
    ]
  },
  {
    "sha": "36a8441912bf84b4da9c74826dcd42533d8abaaa",
    "node_id": "C_kwDOABII59oAKDM2YTg0NDE5MTJiZjg0YjRkYTljNzQ4MjZkY2Q0MjUzM2Q4YWJhYWE",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-09-02T12:09:11Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T14:58:54Z"
      },
      "message": "[validation/rpc] cache + use vsize calculated in PreChecks\n\nThis is not only cleaner but also helps make sure we are always using\nthe virtual size measure that includes the sigop weight heuristic (which\nis the vsize the mempool would return).",
      "tree": {
        "sha": "0d65ed2f257ad67ec05732e839fe7a4c8ba87c15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0d65ed2f257ad67ec05732e839fe7a4c8ba87c15"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36a8441912bf84b4da9c74826dcd42533d8abaaa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36a8441912bf84b4da9c74826dcd42533d8abaaa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/36a8441912bf84b4da9c74826dcd42533d8abaaa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36a8441912bf84b4da9c74826dcd42533d8abaaa/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8fa2936b34fda9c0bea963311fa80a04b4bf5867",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fa2936b34fda9c0bea963311fa80a04b4bf5867",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8fa2936b34fda9c0bea963311fa80a04b4bf5867"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 20,
      "deletions": 13
    },
    "files": [
      {
        "sha": "fd18d4c96d7a7f53062df05cb829a23046947241",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36a8441912bf84b4da9c74826dcd42533d8abaaa/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36a8441912bf84b4da9c74826dcd42533d8abaaa/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=36a8441912bf84b4da9c74826dcd42533d8abaaa",
        "patch": "@@ -977,7 +977,7 @@ static RPCHelpMan testmempoolaccept()\n         if (tx_result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             const CAmount fee = tx_result.m_base_fees.value();\n             // Check that fee does not exceed maximum fee\n-            const int64_t virtual_size = GetVirtualTransactionSize(*tx);\n+            const int64_t virtual_size = tx_result.m_vsize.value();\n             const CAmount max_raw_tx_fee = max_raw_tx_fee_rate.GetFee(virtual_size);\n             if (max_raw_tx_fee && fee > max_raw_tx_fee) {\n                 result_inner.pushKV(\"allowed\", false);"
      },
      {
        "sha": "266a0ac9e606cbbd9c9eacab3f65fb2a25534eb9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 8,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36a8441912bf84b4da9c74826dcd42533d8abaaa/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36a8441912bf84b4da9c74826dcd42533d8abaaa/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=36a8441912bf84b4da9c74826dcd42533d8abaaa",
        "patch": "@@ -503,6 +503,9 @@ class MemPoolAccept\n         std::unique_ptr<CTxMemPoolEntry> m_entry;\n         std::list<CTransactionRef> m_replaced_transactions;\n \n+        /** Virtual size of the transaction as used by the mempool, calculated using serialized size\n+         * of the transaction and sigops. */\n+        int64_t m_vsize;\n         CAmount m_base_fees;\n         CAmount m_modified_fees;\n         /** Total modified fees of all transactions being replaced. */\n@@ -732,15 +735,15 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     entry.reset(new CTxMemPoolEntry(ptx, ws.m_base_fees, nAcceptTime, m_active_chainstate.m_chain.Height(),\n             fSpendsCoinbase, nSigOpsCost, lp));\n-    unsigned int nSize = entry->GetTxSize();\n+    ws.m_vsize = entry->GetTxSize();\n \n     if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n         return state.Invalid(TxValidationResult::TX_NOT_STANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n     // No transactions are allowed below minRelayTxFee except from disconnected\n     // blocks\n-    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n+    if (!bypass_limits && !CheckFeeRate(ws.m_vsize, nModifiedFees, state)) return false;\n \n     const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n     // Calculate in-mempool ancestors, up to a limit.\n@@ -795,7 +798,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // to be secure by simply only having two immediately-spendable\n         // outputs - one for each counterparty. For more info on the uses for\n         // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-        if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n+        if (ws.m_vsize > EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n                 !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-mempool-chain\", errString);\n         }\n@@ -813,7 +816,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     m_rbf = !setConflicts.empty();\n     if (m_rbf) {\n-        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        CFeeRate newFeeRate(nModifiedFees, ws.m_vsize);\n         // It's possible that the replacement pays more fees than its direct conflicts but not more\n         // than all conflicts (i.e. the direct conflicts have high-fee descendants). However, if the\n         // replacement doesn't pay more fees than its direct conflicts, then we can be sure it's not\n@@ -841,7 +844,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             nConflictingFees += it->GetModifiedFee();\n             nConflictingSize += it->GetTxSize();\n         }\n-        if (const auto err_string{PaysForRBF(nConflictingFees, nModifiedFees, nSize, ::incrementalRelayFee, hash)}) {\n+        if (const auto err_string{PaysForRBF(nConflictingFees, nModifiedFees, ws.m_vsize,\n+                                             ::incrementalRelayFee, hash)}) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n         }\n     }\n@@ -967,14 +971,14 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef\n \n     // Tx was accepted, but not added\n     if (args.m_test_accept) {\n-        return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+        return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_vsize, ws.m_base_fees);\n     }\n \n     if (!Finalize(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);\n \n     GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());\n \n-    return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+    return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_vsize, ws.m_base_fees);\n }\n \n PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::vector<CTransactionRef>& txns, ATMPArgs& args)\n@@ -1033,7 +1037,8 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n             // When test_accept=true, transactions that pass PolicyScriptChecks are valid because there are\n             // no further mempool checks (passing PolicyScriptChecks implies passing ConsensusScriptChecks).\n             results.emplace(ws.m_ptx->GetWitnessHash(),\n-                            MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_base_fees));\n+                            MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions),\n+                                                         ws.m_vsize, ws.m_base_fees));\n         }\n     }\n "
      },
      {
        "sha": "256981224ac6348fcf7242cb49d9db3d29806445",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36a8441912bf84b4da9c74826dcd42533d8abaaa/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36a8441912bf84b4da9c74826dcd42533d8abaaa/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=36a8441912bf84b4da9c74826dcd42533d8abaaa",
        "patch": "@@ -158,14 +158,16 @@ struct MempoolAcceptResult {\n     // The following fields are only present when m_result_type = ResultType::VALID\n     /** Mempool transactions replaced by the tx per BIP 125 rules. */\n     const std::optional<std::list<CTransactionRef>> m_replaced_transactions;\n+    /** Virtual size as used by the mempool, calculated using serialized size and sigops. */\n+    const std::optional<int64_t> m_vsize;\n     /** Raw base fees in satoshis. */\n     const std::optional<CAmount> m_base_fees;\n     static MempoolAcceptResult Failure(TxValidationState state) {\n         return MempoolAcceptResult(state);\n     }\n \n-    static MempoolAcceptResult Success(std::list<CTransactionRef>&& replaced_txns, CAmount fees) {\n-        return MempoolAcceptResult(std::move(replaced_txns), fees);\n+    static MempoolAcceptResult Success(std::list<CTransactionRef>&& replaced_txns, int64_t vsize, CAmount fees) {\n+        return MempoolAcceptResult(std::move(replaced_txns), vsize, fees);\n     }\n \n // Private constructors. Use static methods MempoolAcceptResult::Success, etc. to construct.\n@@ -177,9 +179,9 @@ struct MempoolAcceptResult {\n         }\n \n     /** Constructor for success case */\n-    explicit MempoolAcceptResult(std::list<CTransactionRef>&& replaced_txns, CAmount fees)\n+    explicit MempoolAcceptResult(std::list<CTransactionRef>&& replaced_txns, int64_t vsize, CAmount fees)\n         : m_result_type(ResultType::VALID),\n-        m_replaced_transactions(std::move(replaced_txns)), m_base_fees(fees) {}\n+        m_replaced_transactions(std::move(replaced_txns)), m_vsize{vsize}, m_base_fees(fees) {}\n };\n \n /**"
      }
    ]
  },
  {
    "sha": "3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
    "node_id": "C_kwDOABII59oAKDNkM2U0NTk4YjZlNTcwYjFmODI0OGIxZWU0M2VjNTkxNjVhM2ZmNWM",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T15:09:33Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T16:38:11Z"
      },
      "message": "[validation] cache iterators to mempool conflicts",
      "tree": {
        "sha": "05880ed139990176499ae8f11dff3842948e2d15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05880ed139990176499ae8f11dff3842948e2d15"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "36a8441912bf84b4da9c74826dcd42533d8abaaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36a8441912bf84b4da9c74826dcd42533d8abaaa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/36a8441912bf84b4da9c74826dcd42533d8abaaa"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 7,
      "deletions": 6
    },
    "files": [
      {
        "sha": "00a2b034115a247b641290cd7e22ab314d1eab15",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
        "patch": "@@ -498,6 +498,7 @@ class MemPoolAccept\n     struct Workspace {\n         explicit Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n         std::set<uint256> m_conflicts;\n+        CTxMemPool::setEntries m_iters_conflicting;\n         CTxMemPool::setEntries m_all_conflicting;\n         CTxMemPool::setEntries m_ancestors;\n         std::unique_ptr<CTxMemPoolEntry> m_entry;\n@@ -745,7 +746,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // blocks\n     if (!bypass_limits && !CheckFeeRate(ws.m_vsize, nModifiedFees, state)) return false;\n \n-    const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n+    ws.m_iters_conflicting = m_pool.GetIterSet(setConflicts);\n     // Calculate in-mempool ancestors, up to a limit.\n     if (setConflicts.size() == 1) {\n         // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n@@ -775,8 +776,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // the ancestor limits should be the same for both our new transaction and any conflicts).\n         // We don't bother incrementing m_limit_descendants by the full removal count as that limit never comes\n         // into force here (as we're only adding a single transaction).\n-        assert(setIterConflicting.size() == 1);\n-        CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+        assert(ws.m_iters_conflicting.size() == 1);\n+        CTxMemPool::txiter conflict = *ws.m_iters_conflicting.begin();\n \n         m_limit_descendants += 1;\n         m_limit_descendant_size += conflict->GetSizeWithDescendants();\n@@ -823,17 +824,17 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // more economically rational to mine. Before we go digging through the mempool for all\n         // transactions that would need to be removed (direct conflicts and all descendants), check\n         // that the replacement transaction pays more than its direct conflicts.\n-        if (const auto err_string{PaysMoreThanConflicts(setIterConflicting, newFeeRate, hash)}) {\n+        if (const auto err_string{PaysMoreThanConflicts(ws.m_iters_conflicting, newFeeRate, hash)}) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n         }\n \n         // Calculate all conflicting entries and enforce BIP125 Rule #5.\n-        if (const auto err_string{GetEntriesForConflicts(tx, m_pool, setIterConflicting, allConflicting)}) {\n+        if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, allConflicting)}) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n                                  \"too many potential replacements\", *err_string);\n         }\n         // Enforce BIP125 Rule #2.\n-        if (const auto err_string{HasNoNewUnconfirmed(tx, m_pool, setIterConflicting)}) {\n+        if (const auto err_string{HasNoNewUnconfirmed(tx, m_pool, ws.m_iters_conflicting)}) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n                                  \"replacement-adds-unconfirmed\", *err_string);\n         }"
      }
    ]
  },
  {
    "sha": "fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
    "node_id": "C_kwDOABII59oAKGZkOTJiMGMzOTg2YjllYjQxY2UyOGViNjAyZjU2ZDQwNWJkZDNjZDc",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T16:23:32Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T16:38:13Z"
      },
      "message": "document workspace members",
      "tree": {
        "sha": "290ed4addb63a54a4e5af2395a18f88985d122d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/290ed4addb63a54a4e5af2395a18f88985d122d6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3d3e4598b6e570b1f8248b1ee43ec59165a3ff5c"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c444b65f27c14cc406e03e48e646a4c236c99ba0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
        "patch": "@@ -497,24 +497,37 @@ class MemPoolAccept\n     // of checking a given transaction.\n     struct Workspace {\n         explicit Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        /** Txids of mempool transactions that this transaction directly conflicts with. */\n         std::set<uint256> m_conflicts;\n+        /** Iterators to mempool entries that this transaction directly conflicts with. */\n         CTxMemPool::setEntries m_iters_conflicting;\n+        /** Iterators to all mempool entries that would be replaced by this transaction, including\n+         * those it directly conflicts with and their descendants. */\n         CTxMemPool::setEntries m_all_conflicting;\n+        /** All mempool ancestors of this transaction. */\n         CTxMemPool::setEntries m_ancestors;\n+        /** Mempool entry constructed for this transaction. Constructed in PreChecks() but not\n+         * inserted into the mempool until Finalize(). */\n         std::unique_ptr<CTxMemPoolEntry> m_entry;\n+        /** Pointers to the transactions that have been removed from the mempool and replaced by\n+         * this transaction, used to return to the MemPoolAccept caller. Only populated if\n+         * validation is successful and the original transactions are removed. */\n         std::list<CTransactionRef> m_replaced_transactions;\n \n         /** Virtual size of the transaction as used by the mempool, calculated using serialized size\n          * of the transaction and sigops. */\n         int64_t m_vsize;\n+        /** Fees paid by this transaction: total input amounts subtracted by total output amounts. */\n         CAmount m_base_fees;\n+        /** Base fees + any fee delta set by the user with prioritisetransaction. */\n         CAmount m_modified_fees;\n         /** Total modified fees of all transactions being replaced. */\n         CAmount m_conflicting_fees{0};\n         /** Total virtual size of all transactions being replaced. */\n         size_t m_conflicting_size{0};\n \n         const CTransactionRef& m_ptx;\n+        /** Txid. */\n         const uint256& m_hash;\n         TxValidationState m_state;\n         /** A temporary cache containing serialized transaction data for signature verification."
      }
    ]
  },
  {
    "sha": "9e910d8152e08d26ecce6592870adbe5dabd159e",
    "node_id": "C_kwDOABII59oAKDllOTEwZDgxNTJlMDhkMjZlY2NlNjU5Mjg3MGFkYmU1ZGFiZDE1OWU",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-08-03T10:54:42Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T18:54:03Z"
      },
      "message": "scripted-diff: clean up MemPoolAccept aliases\n\nThe aliases are leftover from a previous MOVEONLY refactor - they are\nunnecessary and removing them reduces the diff for splitting out mempool\nChecks from PreChecks, making RBF variables MemPoolAccept-wide, etc.\n\n-BEGIN VERIFY SCRIPT-\n\nunalias() { sed -i \"s:\\<$1\\>:$2:g\" src/validation.cpp; sed -i \"/$2 = $2/d\" src/validation.cpp; }\n\nunalias nModifiedFees \t\t  ws.m_modified_fees\nunalias nConflictingFees      \t  ws.m_conflicting_fees\nunalias nConflictingSize          ws.m_conflicting_size\nunalias setConflicts \t          ws.m_conflicts\nunalias allConflicting\t\t  ws.m_all_conflicting\nunalias setAncestors\t          ws.m_ancestors\n\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "422b3596c98fa1041db0522c568e345da84d0608",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/422b3596c98fa1041db0522c568e345da84d0608"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e910d8152e08d26ecce6592870adbe5dabd159e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e910d8152e08d26ecce6592870adbe5dabd159e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e910d8152e08d26ecce6592870adbe5dabd159e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e910d8152e08d26ecce6592870adbe5dabd159e/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd92b0c3986b9eb41ce28eb602f56d405bdd3cd7"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 25,
      "deletions": 36
    },
    "files": [
      {
        "sha": "138306a193a4faeb7b41e27bec21b1d733d205fb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 36,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e910d8152e08d26ecce6592870adbe5dabd159e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e910d8152e08d26ecce6592870adbe5dabd159e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=9e910d8152e08d26ecce6592870adbe5dabd159e",
        "patch": "@@ -603,13 +603,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Alias what we need out of ws\n     TxValidationState& state = ws.m_state;\n-    std::set<uint256>& setConflicts = ws.m_conflicts;\n-    CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n-    CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n     std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;\n-    CAmount& nModifiedFees = ws.m_modified_fees;\n-    CAmount& nConflictingFees = ws.m_conflicting_fees;\n-    size_t& nConflictingSize = ws.m_conflicting_size;\n \n     if (!CheckTransaction(tx, state)) {\n         return false; // state filled in by CheckTransaction\n@@ -655,7 +649,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 // Transaction conflicts with a mempool tx, but we're not allowing replacements.\n                 return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"bip125-replacement-disallowed\");\n             }\n-            if (!setConflicts.count(ptxConflicting->GetHash()))\n+            if (!ws.m_conflicts.count(ptxConflicting->GetHash()))\n             {\n                 // Transactions that don't explicitly signal replaceability are\n                 // *not* replaceable with the current logic, even if one of their\n@@ -668,7 +662,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                     return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"txn-mempool-conflict\");\n                 }\n \n-                setConflicts.insert(ptxConflicting->GetHash());\n+                ws.m_conflicts.insert(ptxConflicting->GetHash());\n             }\n         }\n     }\n@@ -732,9 +726,9 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-    nModifiedFees = ws.m_base_fees;\n-    m_pool.ApplyDelta(hash, nModifiedFees);\n+    // ws.m_modified_fees includes any fee deltas from PrioritiseTransaction\n+    ws.m_modified_fees = ws.m_base_fees;\n+    m_pool.ApplyDelta(hash, ws.m_modified_fees);\n \n     // Keep track of transactions that spend a coinbase, which we re-scan\n     // during reorgs to ensure COINBASE_MATURITY is still met.\n@@ -757,11 +751,11 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // No transactions are allowed below minRelayTxFee except from disconnected\n     // blocks\n-    if (!bypass_limits && !CheckFeeRate(ws.m_vsize, nModifiedFees, state)) return false;\n+    if (!bypass_limits && !CheckFeeRate(ws.m_vsize, ws.m_modified_fees, state)) return false;\n \n-    ws.m_iters_conflicting = m_pool.GetIterSet(setConflicts);\n+    ws.m_iters_conflicting = m_pool.GetIterSet(ws.m_conflicts);\n     // Calculate in-mempool ancestors, up to a limit.\n-    if (setConflicts.size() == 1) {\n+    if (ws.m_conflicts.size() == 1) {\n         // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n         // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n         // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n@@ -797,8 +791,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     }\n \n     std::string errString;\n-    if (!m_pool.CalculateMemPoolAncestors(*entry, setAncestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, errString)) {\n-        setAncestors.clear();\n+    if (!m_pool.CalculateMemPoolAncestors(*entry, ws.m_ancestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, errString)) {\n+        ws.m_ancestors.clear();\n         // If CalculateMemPoolAncestors fails second time, we want the original error string.\n         std::string dummy_err_string;\n         // Contracting/payment channels CPFP carve-out:\n@@ -813,24 +807,24 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // outputs - one for each counterparty. For more info on the uses for\n         // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n         if (ws.m_vsize > EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n+                !m_pool.CalculateMemPoolAncestors(*entry, ws.m_ancestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-mempool-chain\", errString);\n         }\n     }\n \n     // A transaction that spends outputs that would be replaced by it is invalid. Now\n     // that we have the set of all ancestors we can detect this\n-    // pathological case by making sure setConflicts and setAncestors don't\n+    // pathological case by making sure ws.m_conflicts and ws.m_ancestors don't\n     // intersect.\n-    if (const auto err_string{EntriesAndTxidsDisjoint(setAncestors, setConflicts, hash)}) {\n+    if (const auto err_string{EntriesAndTxidsDisjoint(ws.m_ancestors, ws.m_conflicts, hash)}) {\n         // We classify this as a consensus error because a transaction depending on something it\n         // conflicts with would be inconsistent.\n         return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-spends-conflicting-tx\", *err_string);\n     }\n \n-    m_rbf = !setConflicts.empty();\n+    m_rbf = !ws.m_conflicts.empty();\n     if (m_rbf) {\n-        CFeeRate newFeeRate(nModifiedFees, ws.m_vsize);\n+        CFeeRate newFeeRate(ws.m_modified_fees, ws.m_vsize);\n         // It's possible that the replacement pays more fees than its direct conflicts but not more\n         // than all conflicts (i.e. the direct conflicts have high-fee descendants). However, if the\n         // replacement doesn't pay more fees than its direct conflicts, then we can be sure it's not\n@@ -842,7 +836,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         }\n \n         // Calculate all conflicting entries and enforce BIP125 Rule #5.\n-        if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, allConflicting)}) {\n+        if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, ws.m_all_conflicting)}) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n                                  \"too many potential replacements\", *err_string);\n         }\n@@ -854,11 +848,11 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n         // Check if it's economically rational to mine this transaction rather than the ones it\n         // replaces and pays for its own relay fees. Enforce BIP125 Rules #3 and #4.\n-        for (CTxMemPool::txiter it : allConflicting) {\n-            nConflictingFees += it->GetModifiedFee();\n-            nConflictingSize += it->GetTxSize();\n+        for (CTxMemPool::txiter it : ws.m_all_conflicting) {\n+            ws.m_conflicting_fees += it->GetModifiedFee();\n+            ws.m_conflicting_size += it->GetTxSize();\n         }\n-        if (const auto err_string{PaysForRBF(nConflictingFees, nModifiedFees, ws.m_vsize,\n+        if (const auto err_string{PaysForRBF(ws.m_conflicting_fees, ws.m_modified_fees, ws.m_vsize,\n                                              ::incrementalRelayFee, hash)}) {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n         }\n@@ -931,24 +925,19 @@ bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)\n     TxValidationState& state = ws.m_state;\n     const bool bypass_limits = args.m_bypass_limits;\n \n-    CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n-    CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n-    const CAmount& nModifiedFees = ws.m_modified_fees;\n-    const CAmount& nConflictingFees = ws.m_conflicting_fees;\n-    const size_t& nConflictingSize = ws.m_conflicting_size;\n     std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;\n \n     // Remove conflicting transactions from the mempool\n-    for (CTxMemPool::txiter it : allConflicting)\n+    for (CTxMemPool::txiter it : ws.m_all_conflicting)\n     {\n         LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s additional fees, %d delta bytes\\n\",\n                 it->GetTx().GetHash().ToString(),\n                 hash.ToString(),\n-                FormatMoney(nModifiedFees - nConflictingFees),\n-                (int)entry->GetTxSize() - (int)nConflictingSize);\n+                FormatMoney(ws.m_modified_fees - ws.m_conflicting_fees),\n+                (int)entry->GetTxSize() - (int)ws.m_conflicting_size);\n         ws.m_replaced_transactions.push_back(it->GetSharedTx());\n     }\n-    m_pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n+    m_pool.RemoveStaged(ws.m_all_conflicting, false, MemPoolRemovalReason::REPLACED);\n \n     // This transaction should only count for fee estimation if:\n     // - it's not being re-added during a reorg which bypasses typical mempool fee limits\n@@ -957,7 +946,7 @@ bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)\n     bool validForFeeEstimation = !bypass_limits && IsCurrentForFeeEstimation(m_active_chainstate) && m_pool.HasNoInputsOf(tx);\n \n     // Store transaction in memory\n-    m_pool.addUnchecked(*entry, setAncestors, validForFeeEstimation);\n+    m_pool.addUnchecked(*entry, ws.m_ancestors, validForFeeEstimation);\n \n     // trim mempool and check if tx was trimmed\n     if (!bypass_limits) {"
      }
    ]
  },
  {
    "sha": "c9b1439ca9ab691f4672d2cbf33d9381f2985466",
    "node_id": "C_kwDOABII59oAKGM5YjE0MzljYTlhYjY5MWY0NjcyZDJjYmYzM2Q5MzgxZjI5ODU0NjY",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-08-09T10:56:57Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T18:55:12Z"
      },
      "message": "MOVEONLY: mempool checks to their own functions\n\nNo change in behavior, because package transactions would not be going\nthrough the rbf logic in PreChecks anyway (BIP125 is currently disabled\nfor package acceptance, see ATMPArgs).\n\nWe draw the line here because each individual transaction in package\nvalidation still goes through all PreChecks. For example, checking that\none's own conflicts and dependencies are disjoint (a consensus check)\nand individual transaction mempool ancestor/descendant limits.",
      "tree": {
        "sha": "cac73565d4a961fdbd835b0c7742d5762d61890e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cac73565d4a961fdbd835b0c7742d5762d61890e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9b1439ca9ab691f4672d2cbf33d9381f2985466",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9b1439ca9ab691f4672d2cbf33d9381f2985466",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c9b1439ca9ab691f4672d2cbf33d9381f2985466",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9b1439ca9ab691f4672d2cbf33d9381f2985466/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e910d8152e08d26ecce6592870adbe5dabd159e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e910d8152e08d26ecce6592870adbe5dabd159e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e910d8152e08d26ecce6592870adbe5dabd159e"
      }
    ],
    "stats": {
      "total": 103,
      "additions": 66,
      "deletions": 37
    },
    "files": [
      {
        "sha": "9a3375fea959a23ae3a6176958a84b22ae38aeed",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 37,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9b1439ca9ab691f4672d2cbf33d9381f2985466/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9b1439ca9ab691f4672d2cbf33d9381f2985466/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=c9b1439ca9ab691f4672d2cbf33d9381f2985466",
        "patch": "@@ -541,6 +541,14 @@ class MemPoolAccept\n     // only tests that are fast should be done here (to avoid CPU DoS).\n     bool PreChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n+    // Run checks for mempool replace-by-fee.\n+    bool ReplacementChecks(Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Enforce package mempool ancestor/descendant limits (distinct from individual\n+    // ancestor/descendant limits done in PreChecks).\n+    bool PackageMempoolChecks(const std::vector<CTransactionRef>& txns,\n+                              PackageValidationState& package_state) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n     // Run the script checks using our policy flags. As this can be slow, we should\n     // only invoke this on transactions that have otherwise passed policy checks.\n     bool PolicyScriptChecks(const ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n@@ -823,43 +831,67 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     }\n \n     m_rbf = !ws.m_conflicts.empty();\n-    if (m_rbf) {\n-        CFeeRate newFeeRate(ws.m_modified_fees, ws.m_vsize);\n-        // It's possible that the replacement pays more fees than its direct conflicts but not more\n-        // than all conflicts (i.e. the direct conflicts have high-fee descendants). However, if the\n-        // replacement doesn't pay more fees than its direct conflicts, then we can be sure it's not\n-        // more economically rational to mine. Before we go digging through the mempool for all\n-        // transactions that would need to be removed (direct conflicts and all descendants), check\n-        // that the replacement transaction pays more than its direct conflicts.\n-        if (const auto err_string{PaysMoreThanConflicts(ws.m_iters_conflicting, newFeeRate, hash)}) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n-        }\n+    return true;\n+}\n \n-        // Calculate all conflicting entries and enforce BIP125 Rule #5.\n-        if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, ws.m_all_conflicting)}) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n-                                 \"too many potential replacements\", *err_string);\n-        }\n-        // Enforce BIP125 Rule #2.\n-        if (const auto err_string{HasNoNewUnconfirmed(tx, m_pool, ws.m_iters_conflicting)}) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n-                                 \"replacement-adds-unconfirmed\", *err_string);\n-        }\n+bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(m_pool.cs);\n \n-        // Check if it's economically rational to mine this transaction rather than the ones it\n-        // replaces and pays for its own relay fees. Enforce BIP125 Rules #3 and #4.\n-        for (CTxMemPool::txiter it : ws.m_all_conflicting) {\n-            ws.m_conflicting_fees += it->GetModifiedFee();\n-            ws.m_conflicting_size += it->GetTxSize();\n-        }\n-        if (const auto err_string{PaysForRBF(ws.m_conflicting_fees, ws.m_modified_fees, ws.m_vsize,\n-                                             ::incrementalRelayFee, hash)}) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n-        }\n+    const CTransaction& tx = *ws.m_ptx;\n+    const uint256& hash = ws.m_hash;\n+    TxValidationState& state = ws.m_state;\n+\n+    CFeeRate newFeeRate(ws.m_modified_fees, ws.m_vsize);\n+    // It's possible that the replacement pays more fees than its direct conflicts but not more\n+    // than all conflicts (i.e. the direct conflicts have high-fee descendants). However, if the\n+    // replacement doesn't pay more fees than its direct conflicts, then we can be sure it's not\n+    // more economically rational to mine. Before we go digging through the mempool for all\n+    // transactions that would need to be removed (direct conflicts and all descendants), check\n+    // that the replacement transaction pays more than its direct conflicts.\n+    if (const auto err_string{PaysMoreThanConflicts(ws.m_iters_conflicting, newFeeRate, hash)}) {\n+        return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n+    }\n+\n+    // Calculate all conflicting entries and enforce BIP125 Rule #5.\n+    if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, ws.m_all_conflicting)}) {\n+        return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n+                             \"too many potential replacements\", *err_string);\n+    }\n+    // Enforce BIP125 Rule #2.\n+    if (const auto err_string{HasNoNewUnconfirmed(tx, m_pool, ws.m_iters_conflicting)}) {\n+        return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n+                             \"replacement-adds-unconfirmed\", *err_string);\n+    }\n+    // Check if it's economically rational to mine this transaction rather than the ones it\n+    // replaces and pays for its own relay fees. Enforce BIP125 Rules #3 and #4.\n+    for (CTxMemPool::txiter it : ws.m_all_conflicting) {\n+        ws.m_conflicting_fees += it->GetModifiedFee();\n+        ws.m_conflicting_size += it->GetTxSize();\n+    }\n+    if (const auto err_string{PaysForRBF(ws.m_conflicting_fees, ws.m_modified_fees, ws.m_vsize,\n+                                         ::incrementalRelayFee, hash)}) {\n+        return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n     }\n     return true;\n }\n \n+bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txns,\n+                                         PackageValidationState& package_state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(m_pool.cs);\n+\n+    std::string err_string;\n+    if (!m_pool.CheckPackageLimits(txns, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants,\n+                                   m_limit_descendant_size, err_string)) {\n+        // This is a package-wide error, separate from an individual transaction error.\n+        return package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-mempool-limits\", err_string);\n+    }\n+   return true;\n+}\n+\n bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs& args, Workspace& ws)\n {\n     const CTransaction& tx = *ws.m_ptx;\n@@ -966,6 +998,8 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef\n \n     if (!PreChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);\n \n+    if (m_rbf && !ReplacementChecks(ws)) return MempoolAcceptResult::Failure(ws.m_state);\n+\n     // Perform the inexpensive checks first and avoid hashing and signature verification unless\n     // those checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n     if (!PolicyScriptChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);\n@@ -1020,12 +1054,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n     // because it's unnecessary. Also, CPFP carve out can increase the limit for individual\n     // transactions, but this exemption is not extended to packages in CheckPackageLimits().\n     std::string err_string;\n-    if (txns.size() > 1 &&\n-        !m_pool.CheckPackageLimits(txns, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants,\n-                                   m_limit_descendant_size, err_string)) {\n-        // All transactions must have individually passed mempool ancestor and descendant limits\n-        // inside of PreChecks(), so this is separate from an individual transaction error.\n-        package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-mempool-limits\", err_string);\n+    if (txns.size() > 1 && !PackageMempoolChecks(txns, package_state)) {\n         return PackageMempoolAcceptResult(package_state, std::move(results));\n     }\n "
      }
    ]
  },
  {
    "sha": "68763783658f004efd9117fa7a69b0e271c4eaaa",
    "node_id": "C_kwDOABII59oAKDY4NzYzNzgzNjU4ZjAwNGVmZDkxMTdmYTdhNjliMGUyNzFjNGVhYWE",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T11:54:19Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T18:55:12Z"
      },
      "message": "MOVEONLY: move package unit tests to their own file",
      "tree": {
        "sha": "2f8c2a168236c2596f343e898944257eca5b82d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f8c2a168236c2596f343e898944257eca5b82d2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/68763783658f004efd9117fa7a69b0e271c4eaaa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68763783658f004efd9117fa7a69b0e271c4eaaa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/68763783658f004efd9117fa7a69b0e271c4eaaa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68763783658f004efd9117fa7a69b0e271c4eaaa/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c9b1439ca9ab691f4672d2cbf33d9381f2985466",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9b1439ca9ab691f4672d2cbf33d9381f2985466",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c9b1439ca9ab691f4672d2cbf33d9381f2985466"
      }
    ],
    "stats": {
      "total": 209,
      "additions": 114,
      "deletions": 95
    },
    "files": [
      {
        "sha": "2b82a7428ef9cbc7dfb69bdd1a9862670a213669",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68763783658f004efd9117fa7a69b0e271c4eaaa/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68763783658f004efd9117fa7a69b0e271c4eaaa/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=68763783658f004efd9117fa7a69b0e271c4eaaa",
        "patch": "@@ -139,6 +139,7 @@ BITCOIN_TESTS =\\\n   test/transaction_tests.cpp \\\n   test/txindex_tests.cpp \\\n   test/txrequest_tests.cpp \\\n+  test/txpackage_tests.cpp \\\n   test/txvalidation_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n   test/uint256_tests.cpp \\"
      },
      {
        "sha": "3d19e2d5d1dcf73bfafb8fc31d41a834a5739eac",
        "filename": "src/test/txpackage_tests.cpp",
        "status": "added",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68763783658f004efd9117fa7a69b0e271c4eaaa/src/test/txpackage_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68763783658f004efd9117fa7a69b0e271c4eaaa/src/test/txpackage_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txpackage_tests.cpp?ref=68763783658f004efd9117fa7a69b0e271c4eaaa",
        "patch": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <key_io.h>\n+#include <policy/packages.h>\n+#include <policy/policy.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(txpackage_tests)\n+\n+// Create placeholder transactions that have no meaning.\n+inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outputs)\n+{\n+    CMutableTransaction mtx = CMutableTransaction();\n+    mtx.vin.resize(num_inputs);\n+    mtx.vout.resize(num_outputs);\n+    auto random_script = CScript() << ToByteVector(InsecureRand256()) << ToByteVector(InsecureRand256());\n+    for (size_t i{0}; i < num_inputs; ++i) {\n+        mtx.vin[i].prevout.hash = InsecureRand256();\n+        mtx.vin[i].prevout.n = 0;\n+        mtx.vin[i].scriptSig = random_script;\n+    }\n+    for (size_t o{0}; o < num_outputs; ++o) {\n+        mtx.vout[o].nValue = 1 * CENT;\n+        mtx.vout[o].scriptPubKey = random_script;\n+    }\n+    return MakeTransactionRef(mtx);\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_validation_tests, TestChain100Setup)\n+{\n+    LOCK(cs_main);\n+    unsigned int initialPoolSize = m_node.mempool->size();\n+\n+    // Parent and Child Package\n+    CKey parent_key;\n+    parent_key.MakeNewKey(true);\n+    CScript parent_locking_script = GetScriptForDestination(PKHash(parent_key.GetPubKey()));\n+    auto mtx_parent = CreateValidMempoolTransaction(/* input_transaction */ m_coinbase_txns[0], /* vout */ 0,\n+                                                    /* input_height */ 0, /* input_signing_key */ coinbaseKey,\n+                                                    /* output_destination */ parent_locking_script,\n+                                                    /* output_amount */ CAmount(49 * COIN), /* submit */ false);\n+    CTransactionRef tx_parent = MakeTransactionRef(mtx_parent);\n+\n+    CKey child_key;\n+    child_key.MakeNewKey(true);\n+    CScript child_locking_script = GetScriptForDestination(PKHash(child_key.GetPubKey()));\n+    auto mtx_child = CreateValidMempoolTransaction(/* input_transaction */ tx_parent, /* vout */ 0,\n+                                                   /* input_height */ 101, /* input_signing_key */ parent_key,\n+                                                   /* output_destination */ child_locking_script,\n+                                                   /* output_amount */ CAmount(48 * COIN), /* submit */ false);\n+    CTransactionRef tx_child = MakeTransactionRef(mtx_child);\n+    const auto result_parent_child = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {tx_parent, tx_child}, /* test_accept */ true);\n+    BOOST_CHECK_MESSAGE(result_parent_child.m_state.IsValid(),\n+                        \"Package validation unexpectedly failed: \" << result_parent_child.m_state.GetRejectReason());\n+    auto it_parent = result_parent_child.m_tx_results.find(tx_parent->GetWitnessHash());\n+    auto it_child = result_parent_child.m_tx_results.find(tx_child->GetWitnessHash());\n+    BOOST_CHECK(it_parent != result_parent_child.m_tx_results.end());\n+    BOOST_CHECK_MESSAGE(it_parent->second.m_state.IsValid(),\n+                        \"Package validation unexpectedly failed: \" << it_parent->second.m_state.GetRejectReason());\n+    BOOST_CHECK(it_child != result_parent_child.m_tx_results.end());\n+    BOOST_CHECK_MESSAGE(it_child->second.m_state.IsValid(),\n+                        \"Package validation unexpectedly failed: \" << it_child->second.m_state.GetRejectReason());\n+\n+    // Packages can't have more than 25 transactions.\n+    Package package_too_many;\n+    package_too_many.reserve(MAX_PACKAGE_COUNT + 1);\n+    for (size_t i{0}; i < MAX_PACKAGE_COUNT + 1; ++i) {\n+        package_too_many.emplace_back(create_placeholder_tx(1, 1));\n+    }\n+    auto result_too_many = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package_too_many, /* test_accept */ true);\n+    BOOST_CHECK(result_too_many.m_state.IsInvalid());\n+    BOOST_CHECK_EQUAL(result_too_many.m_state.GetResult(), PackageValidationResult::PCKG_POLICY);\n+    BOOST_CHECK_EQUAL(result_too_many.m_state.GetRejectReason(), \"package-too-many-transactions\");\n+\n+    // Packages can't have a total size of more than 101KvB.\n+    CTransactionRef large_ptx = create_placeholder_tx(150, 150);\n+    Package package_too_large;\n+    auto size_large = GetVirtualTransactionSize(*large_ptx);\n+    size_t total_size{0};\n+    while (total_size <= MAX_PACKAGE_SIZE * 1000) {\n+        package_too_large.push_back(large_ptx);\n+        total_size += size_large;\n+    }\n+    BOOST_CHECK(package_too_large.size() <= MAX_PACKAGE_COUNT);\n+    auto result_too_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package_too_large, /* test_accept */ true);\n+    BOOST_CHECK(result_too_large.m_state.IsInvalid());\n+    BOOST_CHECK_EQUAL(result_too_large.m_state.GetResult(), PackageValidationResult::PCKG_POLICY);\n+    BOOST_CHECK_EQUAL(result_too_large.m_state.GetRejectReason(), \"package-too-large\");\n+\n+    // A single, giant transaction submitted through ProcessNewPackage fails on single tx policy.\n+    CTransactionRef giant_ptx = create_placeholder_tx(999, 999);\n+    BOOST_CHECK(GetVirtualTransactionSize(*giant_ptx) > MAX_PACKAGE_SIZE * 1000);\n+    auto result_single_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {giant_ptx}, /* test_accept */ true);\n+    BOOST_CHECK(result_single_large.m_state.IsInvalid());\n+    BOOST_CHECK_EQUAL(result_single_large.m_state.GetResult(), PackageValidationResult::PCKG_TX);\n+    BOOST_CHECK_EQUAL(result_single_large.m_state.GetRejectReason(), \"transaction failed\");\n+    auto it_giant_tx = result_single_large.m_tx_results.find(giant_ptx->GetWitnessHash());\n+    BOOST_CHECK(it_giant_tx != result_single_large.m_tx_results.end());\n+    BOOST_CHECK_EQUAL(it_giant_tx->second.m_state.GetRejectReason(), \"tx-size\");\n+\n+    // Check that mempool size hasn't changed.\n+    BOOST_CHECK_EQUAL(m_node.mempool->size(), initialPoolSize);\n+}\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "8d25f5331d0407d8ce1282e7fc0da2d30d53bd44",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 95,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68763783658f004efd9117fa7a69b0e271c4eaaa/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68763783658f004efd9117fa7a69b0e271c4eaaa/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=68763783658f004efd9117fa7a69b0e271c4eaaa",
        "patch": "@@ -50,99 +50,4 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n     BOOST_CHECK_EQUAL(result.m_state.GetRejectReason(), \"coinbase\");\n     BOOST_CHECK(result.m_state.GetResult() == TxValidationResult::TX_CONSENSUS);\n }\n-\n-// Create placeholder transactions that have no meaning.\n-inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outputs)\n-{\n-    CMutableTransaction mtx = CMutableTransaction();\n-    mtx.vin.resize(num_inputs);\n-    mtx.vout.resize(num_outputs);\n-    auto random_script = CScript() << ToByteVector(InsecureRand256()) << ToByteVector(InsecureRand256());\n-    for (size_t i{0}; i < num_inputs; ++i) {\n-        mtx.vin[i].prevout.hash = InsecureRand256();\n-        mtx.vin[i].prevout.n = 0;\n-        mtx.vin[i].scriptSig = random_script;\n-    }\n-    for (size_t o{0}; o < num_outputs; ++o) {\n-        mtx.vout[o].nValue = 1 * CENT;\n-        mtx.vout[o].scriptPubKey = random_script;\n-    }\n-    return MakeTransactionRef(mtx);\n-}\n-\n-BOOST_FIXTURE_TEST_CASE(package_tests, TestChain100Setup)\n-{\n-    LOCK(cs_main);\n-    unsigned int initialPoolSize = m_node.mempool->size();\n-\n-    // Parent and Child Package\n-    CKey parent_key;\n-    parent_key.MakeNewKey(true);\n-    CScript parent_locking_script = GetScriptForDestination(PKHash(parent_key.GetPubKey()));\n-    auto mtx_parent = CreateValidMempoolTransaction(/* input_transaction */ m_coinbase_txns[0], /* vout */ 0,\n-                                                    /* input_height */ 0, /* input_signing_key */ coinbaseKey,\n-                                                    /* output_destination */ parent_locking_script,\n-                                                    /* output_amount */ CAmount(49 * COIN), /* submit */ false);\n-    CTransactionRef tx_parent = MakeTransactionRef(mtx_parent);\n-\n-    CKey child_key;\n-    child_key.MakeNewKey(true);\n-    CScript child_locking_script = GetScriptForDestination(PKHash(child_key.GetPubKey()));\n-    auto mtx_child = CreateValidMempoolTransaction(/* input_transaction */ tx_parent, /* vout */ 0,\n-                                                   /* input_height */ 101, /* input_signing_key */ parent_key,\n-                                                   /* output_destination */ child_locking_script,\n-                                                   /* output_amount */ CAmount(48 * COIN), /* submit */ false);\n-    CTransactionRef tx_child = MakeTransactionRef(mtx_child);\n-    const auto result_parent_child = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {tx_parent, tx_child}, /* test_accept */ true);\n-    BOOST_CHECK_MESSAGE(result_parent_child.m_state.IsValid(),\n-                        \"Package validation unexpectedly failed: \" << result_parent_child.m_state.GetRejectReason());\n-    auto it_parent = result_parent_child.m_tx_results.find(tx_parent->GetWitnessHash());\n-    auto it_child = result_parent_child.m_tx_results.find(tx_child->GetWitnessHash());\n-    BOOST_CHECK(it_parent != result_parent_child.m_tx_results.end());\n-    BOOST_CHECK_MESSAGE(it_parent->second.m_state.IsValid(),\n-                        \"Package validation unexpectedly failed: \" << it_parent->second.m_state.GetRejectReason());\n-    BOOST_CHECK(it_child != result_parent_child.m_tx_results.end());\n-    BOOST_CHECK_MESSAGE(it_child->second.m_state.IsValid(),\n-                        \"Package validation unexpectedly failed: \" << it_child->second.m_state.GetRejectReason());\n-\n-    // Packages can't have more than 25 transactions.\n-    Package package_too_many;\n-    package_too_many.reserve(MAX_PACKAGE_COUNT + 1);\n-    for (size_t i{0}; i < MAX_PACKAGE_COUNT + 1; ++i) {\n-        package_too_many.emplace_back(create_placeholder_tx(1, 1));\n-    }\n-    auto result_too_many = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package_too_many, /* test_accept */ true);\n-    BOOST_CHECK(result_too_many.m_state.IsInvalid());\n-    BOOST_CHECK_EQUAL(result_too_many.m_state.GetResult(), PackageValidationResult::PCKG_POLICY);\n-    BOOST_CHECK_EQUAL(result_too_many.m_state.GetRejectReason(), \"package-too-many-transactions\");\n-\n-    // Packages can't have a total size of more than 101KvB.\n-    CTransactionRef large_ptx = create_placeholder_tx(150, 150);\n-    Package package_too_large;\n-    auto size_large = GetVirtualTransactionSize(*large_ptx);\n-    size_t total_size{0};\n-    while (total_size <= MAX_PACKAGE_SIZE * 1000) {\n-        package_too_large.push_back(large_ptx);\n-        total_size += size_large;\n-    }\n-    BOOST_CHECK(package_too_large.size() <= MAX_PACKAGE_COUNT);\n-    auto result_too_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package_too_large, /* test_accept */ true);\n-    BOOST_CHECK(result_too_large.m_state.IsInvalid());\n-    BOOST_CHECK_EQUAL(result_too_large.m_state.GetResult(), PackageValidationResult::PCKG_POLICY);\n-    BOOST_CHECK_EQUAL(result_too_large.m_state.GetRejectReason(), \"package-too-large\");\n-\n-    // A single, giant transaction submitted through ProcessNewPackage fails on single tx policy.\n-    CTransactionRef giant_ptx = create_placeholder_tx(999, 999);\n-    BOOST_CHECK(GetVirtualTransactionSize(*giant_ptx) > MAX_PACKAGE_SIZE * 1000);\n-    auto result_single_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, {giant_ptx}, /* test_accept */ true);\n-    BOOST_CHECK(result_single_large.m_state.IsInvalid());\n-    BOOST_CHECK_EQUAL(result_single_large.m_state.GetResult(), PackageValidationResult::PCKG_TX);\n-    BOOST_CHECK_EQUAL(result_single_large.m_state.GetRejectReason(), \"transaction failed\");\n-    auto it_giant_tx = result_single_large.m_tx_results.find(giant_ptx->GetWitnessHash());\n-    BOOST_CHECK(it_giant_tx != result_single_large.m_tx_results.end());\n-    BOOST_CHECK_EQUAL(it_giant_tx->second.m_state.GetRejectReason(), \"tx-size\");\n-\n-    // Check that mempool size hasn't changed.\n-    BOOST_CHECK_EQUAL(m_node.mempool->size(), initialPoolSize);\n-}\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "14cd7bf793547fa5143acece564482271f5c30bc",
    "node_id": "C_kwDOABII59oAKDE0Y2Q3YmY3OTM1NDdmYTUxNDNhY2VjZTU2NDQ4MjI3MWY1YzMwYmM",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-10-28T11:58:11Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2021-11-04T18:55:12Z"
      },
      "message": "[test] call CheckPackage for package sanitization checks\n\nMakes the test more minimal. We're just trying to test that our package\nsanitization logic is correct. Now that this code lives in its own\nfunction (rather than inside of AcceptMultipleTransactions), there's no\nneed to call ProcessNewPackage to test this.",
      "tree": {
        "sha": "49c9646ebfaef919beab6e97a7933a97c07bd0e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49c9646ebfaef919beab6e97a7933a97c07bd0e3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14cd7bf793547fa5143acece564482271f5c30bc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14cd7bf793547fa5143acece564482271f5c30bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/14cd7bf793547fa5143acece564482271f5c30bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14cd7bf793547fa5143acece564482271f5c30bc/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "68763783658f004efd9117fa7a69b0e271c4eaaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68763783658f004efd9117fa7a69b0e271c4eaaa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/68763783658f004efd9117fa7a69b0e271c4eaaa"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 29,
      "deletions": 25
    },
    "files": [
      {
        "sha": "537a6ccea109e076c32628350c4c1b1a95430971",
        "filename": "src/test/txpackage_tests.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 25,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14cd7bf793547fa5143acece564482271f5c30bc/src/test/txpackage_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14cd7bf793547fa5143acece564482271f5c30bc/src/test/txpackage_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txpackage_tests.cpp?ref=14cd7bf793547fa5143acece564482271f5c30bc",
        "patch": "@@ -35,6 +35,35 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+BOOST_FIXTURE_TEST_CASE(package_sanitization_tests, TestChain100Setup)\n+{\n+    // Packages can't have more than 25 transactions.\n+    Package package_too_many;\n+    package_too_many.reserve(MAX_PACKAGE_COUNT + 1);\n+    for (size_t i{0}; i < MAX_PACKAGE_COUNT + 1; ++i) {\n+        package_too_many.emplace_back(create_placeholder_tx(1, 1));\n+    }\n+    PackageValidationState state_too_many;\n+    BOOST_CHECK(!CheckPackage(package_too_many, state_too_many));\n+    BOOST_CHECK_EQUAL(state_too_many.GetResult(), PackageValidationResult::PCKG_POLICY);\n+    BOOST_CHECK_EQUAL(state_too_many.GetRejectReason(), \"package-too-many-transactions\");\n+\n+    // Packages can't have a total size of more than 101KvB.\n+    CTransactionRef large_ptx = create_placeholder_tx(150, 150);\n+    Package package_too_large;\n+    auto size_large = GetVirtualTransactionSize(*large_ptx);\n+    size_t total_size{0};\n+    while (total_size <= MAX_PACKAGE_SIZE * 1000) {\n+        package_too_large.push_back(large_ptx);\n+        total_size += size_large;\n+    }\n+    BOOST_CHECK(package_too_large.size() <= MAX_PACKAGE_COUNT);\n+    PackageValidationState state_too_large;\n+    BOOST_CHECK(!CheckPackage(package_too_large, state_too_large));\n+    BOOST_CHECK_EQUAL(state_too_large.GetResult(), PackageValidationResult::PCKG_POLICY);\n+    BOOST_CHECK_EQUAL(state_too_large.GetRejectReason(), \"package-too-large\");\n+}\n+\n BOOST_FIXTURE_TEST_CASE(package_validation_tests, TestChain100Setup)\n {\n     LOCK(cs_main);\n@@ -70,31 +99,6 @@ BOOST_FIXTURE_TEST_CASE(package_validation_tests, TestChain100Setup)\n     BOOST_CHECK_MESSAGE(it_child->second.m_state.IsValid(),\n                         \"Package validation unexpectedly failed: \" << it_child->second.m_state.GetRejectReason());\n \n-    // Packages can't have more than 25 transactions.\n-    Package package_too_many;\n-    package_too_many.reserve(MAX_PACKAGE_COUNT + 1);\n-    for (size_t i{0}; i < MAX_PACKAGE_COUNT + 1; ++i) {\n-        package_too_many.emplace_back(create_placeholder_tx(1, 1));\n-    }\n-    auto result_too_many = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package_too_many, /* test_accept */ true);\n-    BOOST_CHECK(result_too_many.m_state.IsInvalid());\n-    BOOST_CHECK_EQUAL(result_too_many.m_state.GetResult(), PackageValidationResult::PCKG_POLICY);\n-    BOOST_CHECK_EQUAL(result_too_many.m_state.GetRejectReason(), \"package-too-many-transactions\");\n-\n-    // Packages can't have a total size of more than 101KvB.\n-    CTransactionRef large_ptx = create_placeholder_tx(150, 150);\n-    Package package_too_large;\n-    auto size_large = GetVirtualTransactionSize(*large_ptx);\n-    size_t total_size{0};\n-    while (total_size <= MAX_PACKAGE_SIZE * 1000) {\n-        package_too_large.push_back(large_ptx);\n-        total_size += size_large;\n-    }\n-    BOOST_CHECK(package_too_large.size() <= MAX_PACKAGE_COUNT);\n-    auto result_too_large = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package_too_large, /* test_accept */ true);\n-    BOOST_CHECK(result_too_large.m_state.IsInvalid());\n-    BOOST_CHECK_EQUAL(result_too_large.m_state.GetResult(), PackageValidationResult::PCKG_POLICY);\n-    BOOST_CHECK_EQUAL(result_too_large.m_state.GetRejectReason(), \"package-too-large\");\n \n     // A single, giant transaction submitted through ProcessNewPackage fails on single tx policy.\n     CTransactionRef giant_ptx = create_placeholder_tx(999, 999);"
      }
    ]
  }
]