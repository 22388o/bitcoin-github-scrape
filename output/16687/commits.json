[
  {
    "sha": "461acf5c6c39610c55988eed7a50922aed732ded",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NjFhY2Y1YzZjMzk2MTBjNTU5ODhlZWQ3YTUwOTIyYWVkNzMyZGVk",
    "commit": {
      "author": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:04:57Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:04:57Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from b19c00006..e729cc7f5\n\ne729cc7f5 Merge #657: Fix a nit in the recovery tests\nb64a2e259 Fix a nit in the recovery tests\ne028aa33d Merge #650: secp256k1/src/tests.c:  Properly handle sscanf return value\nf1e11d363 Merge #654: Fix typo (\u221e)\nef83281c3 Merge pull request #656 from real-or-random/patch-1\n556caad2c Fix typo in docs for _context_set_illegal_callback\n786dfb49f Merge #583: JNI: fix use sig array\ne95f8ab09 Merge #644: Avoid optimizing out a verify_check\n384f55606 Merge #652: README.md: update instruction to run tests\nee56accd4 Merge #651: Fix typo in secp256k1_preallocated.h\n7b9b11723 Merge #640: scalar_impl.h: fix includes\nd99bec2e2 Merge #655: jni: Use only Guava for hex encoding and decoding\n2abcf951a jni: Use only Guava for hex encoding and decoding\n271582b3b Fix typo\nce6d43826 README.md: update instruction to run tests\nb1e68cb8e Fix typo in secp256k1_preallocated.h\na11c76c59 secp256k1/src/tests.c:  Properly handle sscanf return value\n94ae7cbf8 Moved a dereference so the null check will be before the dereferencing\n2cb73b106 scalar_impl.h: fix includes\nfa3301713 Merge #634: Add a descriptive comment for secp256k1_ecmult_const.\nee9e68cd3 Add a descriptive comment for secp256k1_ecmult_const.\nd0d738d32 Merge #631: typo in comment for secp256k1_ec_pubkey_tweak_mul ()\n6914c2527 typo in comment for secp256k1_ec_pubkey_tweak_mul ()\ne541a90ef Merge #629: Avoid calling _is_zero when _set_b32 fails.\nf34b0c3f3 Merge #630: Note intention of timing sidechannel freeness.\n8d1563b0f Note intention of timing sidechannel freeness.\n1669bb286 Merge #628: Fix ability to compile tests without -DVERIFY.\necc94abcc Merge #627: Guard memcmp in tests against mixed size inputs.\n544435fc9 Merge #578: Avoid implementation-defined and undefined behavior when dealing with sizes\n143dc6e9e Merge #595: Allow to use external default callbacks\ne49f7991c Add missing #(un)defines to base-config.h\n77defd2c3 Add secp256k1_ prefix to default callback functions\n908bdce64 Include stdio.h and stdlib.h explicitly in secp256k1.c\n5db782e65 Allow usage of external default callbacks\n6095a863f Replace CHECKs for no_precomp ctx by ARG_CHECKs without a return\ncd473e02c Avoid calling secp256k1_*_is_zero when secp256k1_*_set_b32 fails.\n6c36de7a3 Merge #600: scratch space: use single allocation\n98836b11f scratch: replace frames with \"checkpoint\" system\n7623cf2b9 scratch: save a couple bytes of unnecessarily-allocated memory\na7a164f2c scratch: rename `max_size` to `size`, document that extra will actually be allocated\n5a4bc0bb9 scratch: unify allocations\nc2b028a28 scratch space: thread `error_callback` into all scratch space functions\n0be1a4ae6 scratch: add magic bytes to beginning of structure\n92a48a764 scratch space: use single allocation\n40839e21b Merge #592: Use trivial algorithm in ecmult_multi if scratch space is small\ndcf392027 Fix ability to compile tests without -DVERIFY.\na484e0008 Merge #566: Enable context creation in preallocated memory\n0522caac8 Explain caller's obligations for preallocated memory\n238305fdb Move _preallocated functions to separate header\n695feb6fb Export _preallocated functions\n814cc78d7 Add tests for contexts in preallocated memory\nba12dd08d Check arguments of _preallocated functions\n5feadde46 Support cloning a context into preallocated memory\nc4fd5dab4 Switch to a single malloc call\nef020de16 Add size constants for preallocated memory\n1bf7c056b Prepare for manual memory management in preallocated memory\n248bffb05 Guard memcmp in tests against mixed size inputs.\n36698dcfe Merge #596: Make WINDOW_G configurable\na61a93ff5 Clean up ./configure help strings\n2842dc523 Make WINDOW_G configurable\n1a02d6ce5 Merge #626: Revert \"Merge #620: Install headers automatically\"\n662918cb2 Revert \"Merge #620: Install headers automatically\"\n14c7dbd44 Simplify control flow in DER parsing\nec8f20bab Avoid out-of-bound pointers and integer overflows in size comparisons\n01ee1b3b3 Parse DER-enconded length into a size_t instead of an int\n912680ed8 Merge #561: Respect LDFLAGS and #undef STATIC_PRECOMPUTATION if using basic config\n91fae3ace Merge #620: Install headers automatically\n5df77a0ed Merge #533: Make sure we're not using an uninitialized variable in secp256k1_wnaf_const(...)\n975e51e0d Merge #617: Pass scalar by reference in secp256k1_wnaf_const()\n735fbde04 Merge #619: Clear a copied secret key after negation\n16e86150d Install headers automatically\n069870d92 Clear a copied secret key after negation\n8979ec0d9 Pass scalar by reference in secp256k1_wnaf_const()\n84a808598 Merge #612: Allow field_10x26_arm.s to compile for ARMv7 architecture\nd4d270a59 Allow field_10x26_arm.s to compile for ARMv7 architecture\n248f04661 Make sure we're not using an uninitialized variable in secp256k1_wnaf_const(...)\n9ab96f7b1 Use trivial algorithm in ecmult_multi if scratch space is small\ndbed75d96 Undefine `STATIC_PRECOMPUTATION` if using the basic config\n310111e09 Keep LDFLAGS if `--coverage`\n74e2dbd68 JNI: fix use sig array\n3cb057f84 Fix possible integer overflow in DER parsing\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: e729cc7f5a76cb20cbe2317e8e8dad3e422740a0",
      "tree": {
        "sha": "5e54504a87f8707eeb3f95f57ede4503596341db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e54504a87f8707eeb3f95f57ede4503596341db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/461acf5c6c39610c55988eed7a50922aed732ded",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/461acf5c6c39610c55988eed7a50922aed732ded",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/461acf5c6c39610c55988eed7a50922aed732ded",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/461acf5c6c39610c55988eed7a50922aed732ded/comments",
    "author": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54245985fb3c89d72e285c4db39d38ed2f5fb0de"
      }
    ],
    "stats": {
      "total": 1367,
      "additions": 956,
      "deletions": 411
    },
    "files": [
      {
        "sha": "21df09f41fb350ee982307bd46a9e7692e09dbcb",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -8,6 +8,7 @@ else\n JNI_LIB =\n endif\n include_HEADERS = include/secp256k1.h\n+include_HEADERS += include/secp256k1_preallocated.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h"
      },
      {
        "sha": "a9f9296ed73a669a99596a48d5622c828a6ffd0d",
        "filename": "README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -45,8 +45,10 @@ Implementation details\n   * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n-  * Access the table with branch-free conditional moves so memory access is uniform.\n-  * No data-dependent branches\n+  * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)\n+    * Access the table with branch-free conditional moves so memory access is uniform.\n+    * No data-dependent branches\n+  * Optional runtime blinding which attempts to frustrate differential power analysis.\n   * The precomputed tables add and eventually subtract points for which no known scalar (private key) is known, preventing even an attacker with control over the private key used to control the data internally.\n \n Build steps\n@@ -57,5 +59,5 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ ./tests\n+    $ make check\n     $ sudo make install  # optional"
      },
      {
        "sha": "b8340b7de13c71a6cc8b44f83bd981eae6cda526",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 73,
        "deletions": 31,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -85,42 +85,42 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n     [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n-    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis [default=no]]),\n     [enable_coverage=$enableval],\n     [enable_coverage=no])\n \n AC_ARG_ENABLE(tests,\n-    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    AS_HELP_STRING([--enable-tests],[compile tests [default=yes]]),\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n     [enable_openssl_tests=$enableval],\n     [enable_openssl_tests=auto])\n \n AC_ARG_ENABLE(experimental,\n-    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n AC_ARG_ENABLE(exhaustive_tests,\n-    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests [default=yes]]),\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n \n AC_ARG_ENABLE(ecmult_static_precomputation,\n-    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n+    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n     [use_ecmult_static_precomputation=auto])\n \n@@ -130,33 +130,47 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_recovery,\n-    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n+    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(external_default_callbacks,\n+    AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions (default is no)]),\n+    [use_external_default_callbacks=$enableval],\n+    [use_external_default_callbacks=no])\n+\n AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni [default=no]]),\n     [use_jni=$enableval],\n     [use_jni=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n+[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n+[assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n-[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n+[window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n+[Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n+[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n+)],\n+[req_ecmult_window=$withval], [req_ecmult_window=auto])\n \n AC_CHECK_TYPES([__int128])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n     CFLAGS=\"$CFLAGS -O0 --coverage\"\n-    LDFLAGS=\"--coverage\"\n+    LDFLAGS=\"$LDFLAGS --coverage\"\n else\n     CFLAGS=\"$CFLAGS -O3\"\n fi\n@@ -387,6 +401,28 @@ case $set_scalar in\n   ;;\n esac\n \n+#set ecmult window size\n+if test x\"$req_ecmult_window\" = x\"auto\"; then\n+  set_ecmult_window=15\n+else\n+  set_ecmult_window=$req_ecmult_window\n+fi\n+\n+error_window_size=['window size for ecmult precomputation not an integer in range [2..24] or \"auto\"']\n+case $set_ecmult_window in\n+''|*[[!0-9]]*)\n+  # no valid integer\n+  AC_MSG_ERROR($error_window_size)\n+  ;;\n+*)\n+  if test \"$set_ecmult_window\" -lt 2 -o \"$set_ecmult_window\" -gt 24 ; then\n+    # not in range\n+    AC_MSG_ERROR($error_window_size)\n+  fi\n+  AC_DEFINE_UNQUOTED(ECMULT_WINDOW_SIZE, $set_ecmult_window, [Set window size for ecmult precomputation])\n+  ;;\n+esac\n+\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n@@ -462,6 +498,10 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n+if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n+fi\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -504,21 +544,23 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism   = $use_endomorphism\"\n-echo \"  with ecmult precomp = $set_precomp\"\n-echo \"  with jni            = $use_jni\"\n-echo \"  with benchmarks     = $use_benchmark\"\n-echo \"  with coverage       = $enable_coverage\"\n-echo \"  module ecdh         = $enable_module_ecdh\"\n-echo \"  module recovery     = $enable_module_recovery\"\n+echo \"  with endomorphism       = $use_endomorphism\"\n+echo \"  with ecmult precomp     = $set_precomp\"\n+echo \"  with external callbacks = $use_external_default_callbacks\"\n+echo \"  with jni                = $use_jni\"\n+echo \"  with benchmarks         = $use_benchmark\"\n+echo \"  with coverage           = $enable_coverage\"\n+echo \"  module ecdh             = $enable_module_ecdh\"\n+echo \"  module recovery         = $enable_module_recovery\"\n echo\n-echo \"  asm                 = $set_asm\"\n-echo \"  bignum              = $set_bignum\"\n-echo \"  field               = $set_field\"\n-echo \"  scalar              = $set_scalar\"\n+echo \"  asm                     = $set_asm\"\n+echo \"  bignum                  = $set_bignum\"\n+echo \"  field                   = $set_field\"\n+echo \"  scalar                  = $set_scalar\"\n+echo \"  ecmult window size      = $set_ecmult_window\"\n echo\n-echo \"  CC                  = $CC\"\n-echo \"  CFLAGS              = $CFLAGS\"\n-echo \"  CPPFLAGS            = $CPPFLAGS\"\n-echo \"  LDFLAGS             = $LDFLAGS\"\n+echo \"  CC                      = $CC\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n+echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  LDFLAGS                 = $LDFLAGS\"\n echo"
      },
      {
        "sha": "e177a0562dd2d2525a095c1dc3922b0ad5241ca5",
        "filename": "contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -32,7 +32,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         pos += lenbyte;\n@@ -51,7 +51,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {\n@@ -89,7 +89,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {"
      },
      {
        "sha": "fc27626dd825763b8988052994b4c8380c3c47ef",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 59,
        "deletions": 17,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -33,9 +33,10 @@ extern \"C\" {\n  *  verification).\n  *\n  *  A constructed context can safely be used from multiple threads\n- *  simultaneously, but API call that take a non-const pointer to a context\n+ *  simultaneously, but API calls that take a non-const pointer to a context\n  *  need exclusive access to it. In particular this is the case for\n- *  secp256k1_context_destroy and secp256k1_context_randomize.\n+ *  secp256k1_context_destroy, secp256k1_context_preallocated_destroy,\n+ *  and secp256k1_context_randomize.\n  *\n  *  Regarding randomization, either do it once at creation time (in which case\n  *  you do not need any locking for the other calls), or use a read-write lock.\n@@ -163,7 +164,8 @@ typedef int (*secp256k1_nonce_function)(\n #define SECP256K1_FLAGS_BIT_CONTEXT_SIGN (1 << 9)\n #define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)\n \n-/** Flags to pass to secp256k1_context_create. */\n+/** Flags to pass to secp256k1_context_create, secp256k1_context_preallocated_size, and\n+ *  secp256k1_context_preallocated_create. */\n #define SECP256K1_CONTEXT_VERIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)\n #define SECP256K1_CONTEXT_SIGN (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)\n #define SECP256K1_CONTEXT_NONE (SECP256K1_FLAGS_TYPE_CONTEXT)\n@@ -186,7 +188,11 @@ typedef int (*secp256k1_nonce_function)(\n  */\n SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n \n-/** Create a secp256k1 context object.\n+/** Create a secp256k1 context object (in dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n@@ -197,7 +203,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n ) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Copies a secp256k1 context object.\n+/** Copy a secp256k1 context object (into dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  Args:    ctx: an existing context to copy (cannot be NULL)\n@@ -206,10 +216,18 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Destroy a secp256k1 context object.\n+/** Destroy a secp256k1 context object (created in dynamically allocated memory).\n  *\n  *  The context pointer may not be used afterwards.\n- *  Args:   ctx: an existing context to destroy (cannot be NULL)\n+ *\n+ *  The context to destroy must have been created using secp256k1_context_create\n+ *  or secp256k1_context_clone. If the context has instead been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the\n+ *  behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must\n+ *  be used instead.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_create or secp256k1_context_clone\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n@@ -229,11 +247,28 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  to cause a crash, though its return value and output arguments are\n  *  undefined.\n  *\n+ *  When this function has not been called (or called with fn==NULL), then the\n+ *  default handler will be used.\u00a0The library provides a default handler which\n+ *  writes the message to stderr and calls abort. This default handler can be\n+ *  replaced at link time if the preprocessor macro\n+ *  USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build\n+ *  has been configured with --enable-external-default-callbacks. Then the\n+ *  following two symbols must be provided to link against:\n+ *   - void secp256k1_default_illegal_callback_fn(const char* message, void* data);\n+ *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n+ *  The library can call these default handlers even before a proper callback data\n+ *  pointer could have been set using secp256k1_context_set_illegal_callback or\n+ *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  fails. In this case, the corresponding default handler will be called with\n+ *  the data pointer argument set to NULL.\n+ *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n- *              passed to the API, taking a message and an opaque pointer\n- *              (NULL restores a default handler that calls abort).\n+ *              passed to the API, taking a message and an opaque pointer.\n+ *              (NULL restores the default handler.)\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_error_callback.\n  */\n SECP256K1_API void secp256k1_context_set_illegal_callback(\n     secp256k1_context* ctx,\n@@ -253,9 +288,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n- *              taking a message and an opaque pointer (NULL restores a default\n- *              handler that calls abort).\n+ *              taking a message and an opaque pointer (NULL restores the\n+ *              default handler, see secp256k1_context_set_illegal_callback\n+ *              for details).\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_illegal_callback.\n  */\n SECP256K1_API void secp256k1_context_set_error_callback(\n     secp256k1_context* ctx,\n@@ -267,21 +305,24 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n  *\n  *  Returns: a newly created scratch space.\n  *  Args: ctx:  an existing context object (cannot be NULL)\n- *  In:   max_size: maximum amount of memory to allocate\n+ *  In:   size: amount of memory to be available as scratch space. Some extra\n+ *              (<100 bytes) will be allocated for extra accounting.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n     const secp256k1_context* ctx,\n-    size_t max_size\n+    size_t size\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Destroy a secp256k1 scratch space.\n  *\n  *  The pointer may not be used afterwards.\n- *  Args:   scratch: space to destroy\n+ *  Args:       ctx: a secp256k1 context object.\n+ *          scratch: space to destroy\n  */\n SECP256K1_API void secp256k1_scratch_space_destroy(\n+    const secp256k1_context* ctx,\n     secp256k1_scratch_space* scratch\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Parse a variable-length public key into the pubkey object.\n  *\n@@ -605,7 +646,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n  * Args:    ctx:    pointer to a context object initialized for validation\n  *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key obkect.\n+ * In/Out:  pubkey: pointer to a public key object.\n  * In:      tweak:  pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n@@ -636,7 +677,8 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * contexts not initialized for signing; then it will have no effect and return 1.\n  *\n  * You should call this after secp256k1_context_create or\n- * secp256k1_context_clone, and may call this repeatedly afterwards.\n+ * secp256k1_context_clone (and secp256k1_context_preallocated_create or\n+ * secp256k1_context_clone, resp.), and you may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "a9ae15d5ae8d80264c5dd1e44b17ccf81a2456a4",
        "filename": "include/secp256k1_preallocated.h",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_preallocated.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -0,0 +1,128 @@\n+#ifndef SECP256K1_PREALLOCATED_H\n+#define SECP256K1_PREALLOCATED_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The module provided by this header file is intended for settings in which it\n+ * is not possible or desirable to rely on dynamic memory allocation. It provides\n+ * functions for creating, cloning, and destroying secp256k1 context objects in a\n+ * contiguous fixed-size block of memory provided by the caller.\n+ *\n+ * Context objects created by functions in this module can be used like contexts\n+ * objects created by functions in secp256k1.h, i.e., they can be passed to any\n+ * API function that expects a context object (see secp256k1.h for details). The\n+ * only exception is that context objects created by functions in this module\n+ * must be destroyed using secp256k1_context_preallocated_destroy (in this\n+ * module) instead of secp256k1_context_destroy (in secp256k1.h).\n+ *\n+ * It is guaranteed that functions in this module will not call malloc or its\n+ * friends realloc, calloc, and free.\n+ */\n+\n+/** Determine the memory size of a secp256k1 context object to be created in\n+ *  caller-provided memory.\n+ *\n+ *  The purpose of this function is to determine how much memory must be provided\n+ *  to secp256k1_context_preallocated_create.\n+ *\n+ *  Returns: the required size of the caller-provided memory block\n+ *  In:      flags:    which parts of the context to initialize.\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_size(\n+    unsigned int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Create a secp256k1 context object in caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, which begins with the call to this\n+ *  function and ends when a call to secp256k1_context_preallocated_destroy\n+ *  (which destroys the context object again) returns. During the lifetime of the\n+ *  context object, the caller is obligated not to access this block of memory,\n+ *  i.e., the caller may not read or write the memory, e.g., by copying the memory\n+ *  contents to a different location or trying to create a second context object\n+ *  in the memory. In simpler words, the prealloc pointer (or any pointer derived\n+ *  from it) should not be used during the lifetime of the context object.\n+ *\n+ *  Returns: a newly created context object.\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ *           flags:    which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize (in secp256k1.h)\n+ *  and secp256k1_context_preallocated_destroy.\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n+    void* prealloc,\n+    unsigned int flags\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Determine the memory size of a secp256k1 context object to be copied into\n+ *  caller-provided memory.\n+ *\n+ *  Returns: the required size of the caller-provided memory block.\n+ *  In:      ctx: an existing context to copy (cannot be NULL)\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n+    const secp256k1_context* ctx\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Copy a secp256k1 context object into caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, see the description of\n+ *  secp256k1_context_preallocated_create for details.\n+ *\n+ *  Returns: a newly created context object.\n+ *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n+    const secp256k1_context* ctx,\n+    void* prealloc\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Destroy a secp256k1 context object that has been created in\n+ *  caller-provided memory.\n+ *\n+ *  The context pointer may not be used afterwards.\n+ *\n+ *  The context to destroy must have been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone.\n+ *  If the context has instead been created using secp256k1_context_create or\n+ *  secp256k1_context_clone, the behaviour is undefined. In that case,\n+ *  secp256k1_context_destroy must be used instead.\n+ *\n+ *  If required, it is the responsibility of the caller to deallocate the block\n+ *  of memory properly after this function returns, e.g., by calling free on the\n+ *  preallocated pointer given to secp256k1_context_preallocated_create or\n+ *  secp256k1_context_preallocated_clone.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_preallocated_create or\n+ *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ */\n+SECP256K1_API void secp256k1_context_preallocated_destroy(\n+    secp256k1_context* ctx\n+);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_PREALLOCATED_H */"
      },
      {
        "sha": "9a5bd06721778da61e34ca16dcc60a10b0d20a36",
        "filename": "src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/asm/field_10x26_arm.s?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -16,15 +16,9 @@ Note:\n */\n \n \t.syntax unified\n-\t.arch armv7-a\n \t@ eabi attributes - see readelf -A\n-\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n-\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n-\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n \t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n \t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n-\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Aggressive Speed\n-\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n \t.text\n \n \t@ Field constants"
      },
      {
        "sha": "3a3969d3001d6ae1ec6e4dfd40f0c0ec22ad16ff",
        "filename": "src/basic-config.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/basic-config.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -10,7 +10,10 @@\n #ifdef USE_BASIC_CONFIG\n \n #undef USE_ASM_X86_64\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n #undef USE_ENDOMORPHISM\n+#undef USE_EXTERNAL_ASM\n+#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_10X26\n #undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n@@ -27,6 +30,7 @@\n #define USE_SCALAR_INV_BUILTIN 1\n #define USE_FIELD_10X26 1\n #define USE_SCALAR_8X32 1\n+#define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "7b5d185dce606b4d60a4d115a34cbbf7fd9432ee",
        "filename": "src/bench_ecmult.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -64,7 +64,7 @@ static void bench_ecmult(void* arg) {\n     size_t iter;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -154,7 +154,7 @@ int main(int argc, char **argv) {\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.scratch);\n+            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n             data.scratch = NULL;\n         } else {\n             fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n@@ -193,10 +193,10 @@ int main(int argc, char **argv) {\n             run_test(&data, i << p, 1);\n         }\n     }\n-    secp256k1_context_destroy(data.ctx);\n     if (data.scratch != NULL) {\n-        secp256k1_scratch_space_destroy(data.scratch);\n+        secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n     }\n+    secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n     free(data.seckeys);"
      },
      {
        "sha": "a8f4e9e12f6d1b9a62789dcd3d5e764efa430b0d",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -253,7 +253,7 @@ void bench_wnaf_const(void* arg) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n+        secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }"
      },
      {
        "sha": "eb099c87dc83fe0898814a8de5e4edaeeeb8f448",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 38,
        "deletions": 32,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -46,68 +46,73 @@ static const secp256k1_fe secp256k1_ecdsa_const_p_minus_order = SECP256K1_FE_CON\n     0, 0, 0, 1, 0x45512319UL, 0x50B75FC4UL, 0x402DA172UL, 0x2FC9BAEEUL\n );\n \n-static int secp256k1_der_read_len(const unsigned char **sigp, const unsigned char *sigend) {\n-    int lenleft, b1;\n-    size_t ret = 0;\n+static int secp256k1_der_read_len(size_t *len, const unsigned char **sigp, const unsigned char *sigend) {\n+    size_t lenleft;\n+    unsigned char b1;\n+    VERIFY_CHECK(len != NULL);\n+    *len = 0;\n     if (*sigp >= sigend) {\n-        return -1;\n+        return 0;\n     }\n     b1 = *((*sigp)++);\n     if (b1 == 0xFF) {\n         /* X.690-0207 8.1.3.5.c the value 0xFF shall not be used. */\n-        return -1;\n+        return 0;\n     }\n     if ((b1 & 0x80) == 0) {\n         /* X.690-0207 8.1.3.4 short form length octets */\n-        return b1;\n+        *len = b1;\n+        return 1;\n     }\n     if (b1 == 0x80) {\n         /* Indefinite length is not allowed in DER. */\n-        return -1;\n+        return 0;\n     }\n     /* X.690-207 8.1.3.5 long form length octets */\n-    lenleft = b1 & 0x7F;\n-    if (lenleft > sigend - *sigp) {\n-        return -1;\n+    lenleft = b1 & 0x7F; /* lenleft is at least 1 */\n+    if (lenleft > (size_t)(sigend - *sigp)) {\n+        return 0;\n     }\n     if (**sigp == 0) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    if ((size_t)lenleft > sizeof(size_t)) {\n+    if (lenleft > sizeof(size_t)) {\n         /* The resulting length would exceed the range of a size_t, so\n          * certainly longer than the passed array size.\n          */\n-        return -1;\n+        return 0;\n     }\n     while (lenleft > 0) {\n-        ret = (ret << 8) | **sigp;\n-        if (ret + lenleft > (size_t)(sigend - *sigp)) {\n-            /* Result exceeds the length of the passed array. */\n-            return -1;\n-        }\n+        *len = (*len << 8) | **sigp;\n         (*sigp)++;\n         lenleft--;\n     }\n-    if (ret < 128) {\n+    if (*len > (size_t)(sigend - *sigp)) {\n+        /* Result exceeds the length of the passed array. */\n+        return 0;\n+    }\n+    if (*len < 128) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    return ret;\n+    return 1;\n }\n \n static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char **sig, const unsigned char *sigend) {\n     int overflow = 0;\n     unsigned char ra[32] = {0};\n-    int rlen;\n+    size_t rlen;\n \n     if (*sig == sigend || **sig != 0x02) {\n         /* Not a primitive integer (X.690-0207 8.3.1). */\n         return 0;\n     }\n     (*sig)++;\n-    rlen = secp256k1_der_read_len(sig, sigend);\n-    if (rlen <= 0 || (*sig) + rlen > sigend) {\n+    if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n+        return 0;\n+    }\n+    if (rlen == 0 || *sig + rlen > sigend) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -123,8 +128,11 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         /* Negative. */\n         overflow = 1;\n     }\n-    while (rlen > 0 && **sig == 0) {\n-        /* Skip leading zero bytes */\n+    /* There is at most one leading zero byte:\n+     * if there were two leading zero bytes, we would have failed and returned 0\n+     * because of excessive 0x00 padding already. */\n+    if (rlen > 0 && **sig == 0) {\n+        /* Skip leading zero byte */\n         rlen--;\n         (*sig)++;\n     }\n@@ -144,18 +152,16 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *rr, secp256k1_scalar *rs, const unsigned char *sig, size_t size) {\n     const unsigned char *sigend = sig + size;\n-    int rlen;\n+    size_t rlen;\n     if (sig == sigend || *(sig++) != 0x30) {\n         /* The encoding doesn't start with a constructed sequence (X.690-0207 8.9.1). */\n         return 0;\n     }\n-    rlen = secp256k1_der_read_len(&sig, sigend);\n-    if (rlen < 0 || sig + rlen > sigend) {\n-        /* Tuple exceeds bounds */\n+    if (secp256k1_der_read_len(&rlen, &sig, sigend) == 0) {\n         return 0;\n     }\n-    if (sig + rlen != sigend) {\n-        /* Garbage after tuple. */\n+    if (rlen != (size_t)(sigend - sig)) {\n+        /* Tuple exceeds bounds or garage after tuple. */\n         return 0;\n     }\n "
      },
      {
        "sha": "c9b198239d88974078443897b099851f94a6d395",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -20,10 +20,10 @@ typedef struct {\n #endif\n } secp256k1_ecmult_context;\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb);\n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n \n@@ -43,6 +43,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "03bb33257d532f8a7345bd4b8f7b090ddb346a92",
        "filename": "src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -10,8 +10,11 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+/**\n+ * Multiply: R = q*A (in constant-time)\n+ * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion.\n+ */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "aaa576ada4cc22bb2bb3a784d0c2514e8aeccead",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 13,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -48,7 +48,7 @@\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n+static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -59,8 +59,12 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     int flip;\n     int bit;\n-    secp256k1_scalar neg_s;\n+    secp256k1_scalar s;\n     int not_neg_one;\n+\n+    VERIFY_CHECK(w > 0);\n+    VERIFY_CHECK(size > 0);\n+\n     /* Note that we cannot handle even numbers by negating them to be odd, as is\n      * done in other implementations, since if our scalars were specified to have\n      * width < 256 for performance reasons, their negations would have width 256\n@@ -75,12 +79,13 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n      * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n      * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n      * we need to special-case it in this logic. */\n-    flip = secp256k1_scalar_is_high(&s);\n+    flip = secp256k1_scalar_is_high(scalar);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ !secp256k1_scalar_is_even(&s);\n+    bit = flip ^ !secp256k1_scalar_is_even(scalar);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n-    secp256k1_scalar_negate(&neg_s, &s);\n-    not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n+    secp256k1_scalar_negate(&s, scalar);\n+    not_neg_one = !secp256k1_scalar_is_one(&s);\n+    s = *scalar;\n     secp256k1_scalar_cadd_bit(&s, bit, not_neg_one);\n     /* If we had negative one, flip == 1, s.d[0] == 0, bit == 1, so caller expects\n      * that we added two to it and flipped it. In fact for -1 these operations are\n@@ -93,7 +98,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < size) {\n+    do {\n         int sign;\n         int even;\n \n@@ -109,7 +114,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n         wnaf[word++] = u_last * global_sign;\n \n         u_last = u;\n-    }\n+    } while (word * w < size);\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n@@ -132,21 +137,20 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n-    secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n #ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n-        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n #endif\n     {\n-        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n #endif"
      },
      {
        "sha": "b136e94632ddf6196c93afcc5c88a16294a63675",
        "filename": "src/ecmult_gen.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -28,10 +28,10 @@ typedef struct {\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n+static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, const secp256k1_callback* cb);\n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context* src, const secp256k1_callback* cb);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);\n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context* ctx);\n static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context* ctx);\n "
      },
      {
        "sha": "0e2eafa71de307644041ce0076290eb7989e73b9",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 20,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -7,30 +7,40 @@\n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n \n+#include \"util.h\"\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n #include \"hash_impl.h\"\n #ifdef USE_ECMULT_STATIC_PRECOMPUTATION\n #include \"ecmult_static_context.h\"\n #endif\n+\n+#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = ROUND_TO_ALIGN(sizeof(*((secp256k1_ecmult_gen_context*) NULL)->prec));\n+#else\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = 0;\n+#endif\n+\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context *ctx) {\n     ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, const secp256k1_callback* cb) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, void **prealloc) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n     secp256k1_ge prec[1024];\n     secp256k1_gej gj;\n     secp256k1_gej nums_gej;\n     int i, j;\n+    size_t const prealloc_size = SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    void* const base = *prealloc;\n #endif\n \n     if (ctx->prec != NULL) {\n         return;\n     }\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*ctx->prec));\n+    ctx->prec = (secp256k1_ge_storage (*)[64][16])manual_alloc(prealloc, prealloc_size, base, prealloc_size);\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -85,7 +95,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n         }\n     }\n #else\n-    (void)cb;\n+    (void)prealloc;\n     ctx->prec = (secp256k1_ge_storage (*)[64][16])secp256k1_ecmult_static_context;\n #endif\n     secp256k1_ecmult_gen_blind(ctx, NULL);\n@@ -95,27 +105,18 @@ static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_cont\n     return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context *src, const secp256k1_callback* cb) {\n-    if (src->prec == NULL) {\n-        dst->prec = NULL;\n-    } else {\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context *src) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-        dst->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*dst->prec));\n-        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+    if (src->prec != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->prec = (secp256k1_ge_storage (*)[64][16])(void*)((unsigned char*)dst + ((unsigned char*)src->prec - (unsigned char*)src));\n+    }\n #else\n-        (void)cb;\n-        dst->prec = src->prec;\n+    (void)dst, (void)src;\n #endif\n-        dst->initial = src->initial;\n-        dst->blind = src->blind;\n-    }\n }\n \n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context *ctx) {\n-#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    free(ctx->prec);\n-#endif\n     secp256k1_scalar_clear(&ctx->blind);\n     secp256k1_gej_clear(&ctx->initial);\n     ctx->prec = NULL;\n@@ -186,7 +187,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     do {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n         retry = !secp256k1_fe_set_b32(&s, nonce32);\n-        retry |= secp256k1_fe_is_zero(&s);\n+        retry = retry || secp256k1_fe_is_zero(&s);\n     } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > Fp. */\n     /* Randomize the projection to defend against multiplier sidechannels. */\n     secp256k1_gej_rescale(&ctx->initial, &s);\n@@ -195,7 +196,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n         secp256k1_scalar_set_b32(&b, nonce32, &retry);\n         /* A blinding value of 0 works, but would undermine the projection hardening. */\n-        retry |= secp256k1_scalar_is_zero(&b);\n+        retry = retry || secp256k1_scalar_is_zero(&b);\n     } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > order. */\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n     memset(nonce32, 0, 32);"
      },
      {
        "sha": "d1a00f600bd48c2f7e7bd863d999f64d3aaa0e94",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 108,
        "deletions": 73,
        "changes": 181,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -10,6 +10,7 @@\n #include <string.h>\n #include <stdint.h>\n \n+#include \"util.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n@@ -30,16 +31,32 @@\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n-#define WINDOW_A 5\n-/** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. */\n-#ifdef USE_ENDOMORPHISM\n-/** Two tables for window size 15: 1.375 MiB. */\n-#define WINDOW_G 15\n-#else\n-/** One table for window size 16: 1.375 MiB. */\n-#define WINDOW_G 16\n+#  define WINDOW_A 5\n+/** Larger values for ECMULT_WINDOW_SIZE result in possibly better\n+ *  performance at the cost of an exponentially larger precomputed\n+ *  table. The exact table size is\n+ *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n+ *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n+ *  be larger due to platform-specific padding and alignment.\n+ *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n+ *  two tables of this size are used instead of only one.\n+ */\n+#  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n+\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * not tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #ifdef USE_ENDOMORPHISM\n@@ -294,15 +311,24 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n+    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#ifdef USE_ENDOMORPHISM\n+    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#endif\n+    ;\n+\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n #endif\n }\n \n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n     secp256k1_gej gj;\n+    void* const base = *prealloc;\n+    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n \n     if (ctx->pre_g != NULL) {\n         return;\n@@ -311,7 +337,12 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n-    ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+    {\n+        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n+    }\n \n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n@@ -321,7 +352,10 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         secp256k1_gej g_128j;\n         int i;\n \n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n \n         /* calculate 2^128*generator */\n         g_128j = gj;\n@@ -333,22 +367,14 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n #endif\n }\n \n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb) {\n-    if (src->pre_g == NULL) {\n-        dst->pre_g = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g, src->pre_g, size);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n+    if (src->pre_g != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n #ifdef USE_ENDOMORPHISM\n-    if (src->pre_g_128 == NULL) {\n-        dst->pre_g_128 = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    if (src->pre_g_128 != NULL) {\n+        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n #endif\n }\n@@ -358,10 +384,6 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n }\n \n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    free(ctx->pre_g);\n-#ifdef USE_ENDOMORPHISM\n-    free(ctx->pre_g_128);\n-#endif\n     secp256k1_ecmult_context_init(ctx);\n }\n \n@@ -373,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s = *a;\n+    secp256k1_scalar s;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -386,6 +408,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n+    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;\n@@ -418,7 +441,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     CHECK(carry == 0);\n     while (bit < 256) {\n         CHECK(secp256k1_scalar_get_bits(&s, bit++, 1) == 0);\n-    } \n+    }\n #endif\n     return last_set_bit + 1;\n }\n@@ -626,52 +649,55 @@ static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n     size_t i;\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n \n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n     }\n \n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n-        return 0;\n-    }\n-    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n-    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n-    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n-    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n #ifdef USE_ENDOMORPHISM\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n #else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n #endif\n-    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n \n     for (i = 0; i < n_points; i++) {\n         secp256k1_ge point;\n         if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n-static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n-    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(error_callback, scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n }\n \n /** Convert a number to WNAF notation.\n@@ -963,7 +989,8 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n@@ -988,15 +1015,21 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     }\n \n     bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n+    if (points == NULL || scalars == NULL || state_space == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n+\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, (1<<bucket_window) * sizeof(*buckets));\n+    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n \n     if (inp_g_sc != NULL) {\n         scalars[0] = *inp_g_sc;\n@@ -1010,7 +1043,7 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n \n     while (point_idx < n_points) {\n         if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         idx++;\n@@ -1034,22 +1067,22 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     for(i = 0; i < 1<<bucket_window; i++) {\n         secp256k1_gej_clear(&buckets[i]);\n     }\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n  * Returns the maximum number of points in addition to G that can be used with\n  * a given scratch space. The function ensures that fewer points may also be\n  * used.\n  */\n-static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n     int bucket_window;\n     size_t res = 0;\n \n@@ -1131,11 +1164,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1152,24 +1185,26 @@ static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp2\n         return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n \n-    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n-     * use pippenger. Otherwise use strauss */\n-    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n-        return 0;\n+    /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n+     * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n+     * As a first step check if there's enough space for Pippenger's algo (which requires less space\n+     * than Strauss' algo) and if not, use the simple algorithm. */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n-        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n-            return 0;\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n+            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "82c605c5d4f77245329ff3fbcc0a35e06ae1cf2c",
        "filename": "src/gen_context.c",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_context.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"basic-config.h\"\n #include \"include/secp256k1.h\"\n+#include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -26,6 +27,7 @@ static const secp256k1_callback default_error_callback = {\n \n int main(int argc, char **argv) {\n     secp256k1_ecmult_gen_context ctx;\n+    void *prealloc, *base;\n     int inner;\n     int outer;\n     FILE* fp;\n@@ -38,15 +40,17 @@ int main(int argc, char **argv) {\n         fprintf(stderr, \"Could not open src/ecmult_static_context.h for writing!\\n\");\n         return -1;\n     }\n-    \n+\n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n     fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n \n+    base = checked_malloc(&default_error_callback, SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE);\n+    prealloc = base;\n     secp256k1_ecmult_gen_context_init(&ctx);\n-    secp256k1_ecmult_gen_context_build(&ctx, &default_error_callback);\n+    secp256k1_ecmult_gen_context_build(&ctx, &prealloc);\n     for(outer = 0; outer != 64; outer++) {\n         fprintf(fp,\"{\\n\");\n         for(inner = 0; inner != 16; inner++) {\n@@ -65,10 +69,11 @@ int main(int argc, char **argv) {\n     }\n     fprintf(fp,\"};\\n\");\n     secp256k1_ecmult_gen_context_clear(&ctx);\n-    \n+    free(base);\n+\n     fprintf(fp, \"#undef SC\\n\");\n     fprintf(fp, \"#endif\\n\");\n     fclose(fp);\n-    \n+\n     return 0;\n }"
      },
      {
        "sha": "782f97216c284eff353a339fdd544c49ab2a7911",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -131,7 +131,8 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n-    while (bufsize + len >= 64) {\n+    VERIFY_CHECK(hash->bytes >= len);\n+    while (len >= 64 - bufsize) {\n         /* Fill the buffer, and process it. */\n         size_t chunk_len = 64 - bufsize;\n         memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);"
      },
      {
        "sha": "710d9f0bbfef3e50388a247baa712dc5acc74f0a",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -3,7 +3,6 @@\n import com.google.common.io.BaseEncoding;\n import java.util.Arrays;\n import java.math.BigInteger;\n-import javax.xml.bind.DatatypeConverter;\n import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n@@ -70,7 +69,7 @@ public static void testPubKeyCreatePos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String pubkeyString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n     }\n \n@@ -81,7 +80,7 @@ public static void testPubKeyCreateNeg() throws AssertFailException{\n        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       String pubkeyString = BaseEncoding.base16().encode(resultArr);\n        assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n     }\n \n@@ -94,7 +93,7 @@ public static void testSignPos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n     }\n \n@@ -106,7 +105,7 @@ public static void testSignNeg() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString, \"\" , \"testSignNeg\");\n     }\n \n@@ -118,7 +117,7 @@ public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n     }\n \n@@ -130,7 +129,7 @@ public static void testPrivKeyTweakMul_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n     }\n \n@@ -142,7 +141,7 @@ public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n     }\n \n@@ -154,7 +153,7 @@ public static void testPrivKeyTweakMul_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n     }\n \n@@ -173,7 +172,7 @@ public static void testCreateECDHSecret() throws AssertFailException{\n         byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String ecdhString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n     }\n "
      },
      {
        "sha": "b590256867c671372ab85ccb85383db592a4c775",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -81,15 +81,15 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n   jbyteArray sigArray, intsByteArray;\n   unsigned char intsarray[2];\n \n-  secp256k1_ecdsa_signature sig[72];\n+  secp256k1_ecdsa_signature sig;\n \n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n+  int ret = secp256k1_ecdsa_sign(ctx, &sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n \n   if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, &sig ); (void)ret2;\n   }\n \n   intsarray[0] = outputLen;"
      },
      {
        "sha": "ed356e53a5c8f7e6246a272765f290c49ebcc2f1",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -147,7 +147,7 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n+            if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }"
      },
      {
        "sha": "38a533a755fc9aada88ffc66e358aee2e505d419",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 0. */\n+         * and secret key 0 (which is not valid), resulting in recid 1. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "6b336d9d1a66d9c70a8c636b6ddad8b154613299",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n-#include \"group.h\"\n #include \"scalar.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "77b35d126bbe6b22c4a2e72311dd87f91039848e",
        "filename": "src/scratch.h",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -7,33 +7,36 @@\n #ifndef _SECP256K1_SCRATCH_\n #define _SECP256K1_SCRATCH_\n \n-#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n-\n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */\n typedef struct secp256k1_scratch_space_struct {\n-    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame;\n+    /** guard against interpreting this object as other types */\n+    unsigned char magic[8];\n+    /** actual allocated data */\n+    void *data;\n+    /** amount that has been allocated (i.e. `data + offset` is the next\n+     *  available pointer)  */\n+    size_t alloc_size;\n+    /** maximum size available to allocate */\n     size_t max_size;\n-    const secp256k1_callback* error_callback;\n } secp256k1_scratch;\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch);\n \n-/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+/** Returns an opaque object used to \"checkpoint\" a scratch space. Used\n+ *  with `secp256k1_scratch_apply_checkpoint` to undo allocations. */\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch);\n \n-/** Deallocates a stack frame */\n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+/** Applies a check point received from `secp256k1_scratch_checkpoint`,\n+ *  undoing all allocations since that point. */\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint);\n \n /** Returns the maximum allocation the scratch space will allow */\n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t n_objects);\n \n /** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t n);\n \n #endif"
      },
      {
        "sha": "4cee70000147b7b84e5759f00b0275fb9ead9107",
        "filename": "src/scratch_impl.h",
        "status": "modified",
        "additions": 47,
        "deletions": 45,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch_impl.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -7,78 +7,80 @@\n #ifndef _SECP256K1_SCRATCH_IMPL_H_\n #define _SECP256K1_SCRATCH_IMPL_H_\n \n+#include \"util.h\"\n #include \"scratch.h\"\n \n-/* Using 16 bytes alignment because common architectures never have alignment\n- * requirements above 8 for any of the types we care about. In addition we\n- * leave some room because currently we don't care about a few bytes.\n- * TODO: Determine this at configure time. */\n-#define ALIGNMENT 16\n-\n-static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n-    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n+    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    void *alloc = checked_malloc(error_callback, base_alloc + size);\n+    secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n         memset(ret, 0, sizeof(*ret));\n-        ret->max_size = max_size;\n-        ret->error_callback = error_callback;\n+        memcpy(ret->magic, \"scratch\", 8);\n+        ret->data = (void *) ((char *) alloc + base_alloc);\n+        ret->max_size = size;\n     }\n     return ret;\n }\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n-        VERIFY_CHECK(scratch->frame == 0);\n+        VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n+        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+            secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+            return;\n+        }\n+        memset(scratch->magic, 0, sizeof(scratch->magic));\n         free(scratch);\n     }\n }\n \n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n-    size_t i = 0;\n-    size_t allocated = 0;\n-    for (i = 0; i < scratch->frame; i++) {\n-        allocated += scratch->frame_size[i];\n-    }\n-    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n-    return scratch->max_size - allocated - objects * ALIGNMENT;\n+    return scratch->alloc_size;\n }\n \n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n-    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n-\n-    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n-        n += objects * ALIGNMENT;\n-        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n-        if (scratch->data[scratch->frame] == NULL) {\n-            return 0;\n-        }\n-        scratch->frame_size[scratch->frame] = n;\n-        scratch->offset[scratch->frame] = 0;\n-        scratch->frame++;\n-        return 1;\n-    } else {\n-        return 0;\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return;\n+    }\n+    if (checkpoint > scratch->alloc_size) {\n+        secp256k1_callback_call(error_callback, \"invalid checkpoint\");\n+        return;\n     }\n+    scratch->alloc_size = checkpoint;\n }\n \n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n-    VERIFY_CHECK(scratch->frame > 0);\n-    scratch->frame -= 1;\n-    free(scratch->data[scratch->frame]);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return 0;\n+    }\n+    if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n+        return 0;\n+    }\n+    return scratch->max_size - scratch->alloc_size - objects * (ALIGNMENT - 1);\n }\n \n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size_t frame = scratch->frame - 1;\n-    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    size = ROUND_TO_ALIGN(size);\n+\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return NULL;\n+    }\n \n-    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+    if (size > scratch->max_size - scratch->alloc_size) {\n         return NULL;\n     }\n-    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    ret = (void *) ((char *) scratch->data + scratch->alloc_size);\n     memset(ret, 0, size);\n-    scratch->offset[frame] += size;\n+    scratch->alloc_size += size;\n \n     return ret;\n }"
      },
      {
        "sha": "a3f446e507e20985d3d3d1f912f4a0203b44cc09",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 112,
        "deletions": 31,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -5,6 +5,7 @@\n  **********************************************************************/\n \n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n \n #include \"util.h\"\n #include \"num_impl.h\"\n@@ -26,28 +27,39 @@\n     } \\\n } while(0)\n \n-static void default_illegal_callback_fn(const char* str, void* data) {\n+#define ARG_CHECK_NO_RETURN(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n+    } \\\n+} while(0)\n+\n+#ifndef USE_EXTERNAL_DEFAULT_CALLBACKS\n+#include <stdlib.h>\n+#include <stdio.h>\n+static void secp256k1_default_illegal_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] illegal argument: %s\\n\", str);\n     abort();\n }\n-\n-static const secp256k1_callback default_illegal_callback = {\n-    default_illegal_callback_fn,\n-    NULL\n-};\n-\n-static void default_error_callback_fn(const char* str, void* data) {\n+static void secp256k1_default_error_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] internal consistency check failed: %s\\n\", str);\n     abort();\n }\n+#else\n+void secp256k1_default_illegal_callback_fn(const char* str, void* data);\n+void secp256k1_default_error_callback_fn(const char* str, void* data);\n+#endif\n \n-static const secp256k1_callback default_error_callback = {\n-    default_error_callback_fn,\n+static const secp256k1_callback default_illegal_callback = {\n+    secp256k1_default_illegal_callback_fn,\n     NULL\n };\n \n+static const secp256k1_callback default_error_callback = {\n+    secp256k1_default_error_callback_fn,\n+    NULL\n+};\n \n struct secp256k1_context_struct {\n     secp256k1_ecmult_context ecmult_ctx;\n@@ -59,68 +71,135 @@ struct secp256k1_context_struct {\n static const secp256k1_context secp256k1_context_no_precomp_ = {\n     { 0 },\n     { 0 },\n-    { default_illegal_callback_fn, 0 },\n-    { default_error_callback_fn, 0 }\n+    { secp256k1_default_illegal_callback_fn, 0 },\n+    { secp256k1_default_error_callback_fn, 0 }\n };\n const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n \n-secp256k1_context* secp256k1_context_create(unsigned int flags) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n+size_t secp256k1_context_preallocated_size(unsigned int flags) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+\n+    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n+            secp256k1_callback_call(&default_illegal_callback,\n+                                    \"Invalid flags\");\n+            return 0;\n+    }\n+\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    VERIFY_CHECK(ctx != NULL);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigned int flags) {\n+    void* const base = prealloc;\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+\n+    VERIFY_CHECK(prealloc != NULL);\n+    prealloc_size = secp256k1_context_preallocated_size(flags);\n+    ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&ret->illegal_callback,\n                                     \"Invalid flags\");\n-            free(ret);\n             return NULL;\n     }\n \n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n-        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &ret->error_callback);\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &ret->error_callback);\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n+    }\n+\n+    return (secp256k1_context*) ret;\n+}\n+\n+secp256k1_context* secp256k1_context_create(unsigned int flags) {\n+    size_t const prealloc_size = secp256k1_context_preallocated_size(flags);\n+    secp256k1_context* ctx = (secp256k1_context*)checked_malloc(&default_error_callback, prealloc_size);\n+    if (EXPECT(secp256k1_context_preallocated_create(ctx, flags) == NULL, 0)) {\n+        free(ctx);\n+        return NULL;\n     }\n \n+    return ctx;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context* ctx, void* prealloc) {\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prealloc != NULL);\n+\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)prealloc;\n+    memcpy(ret, ctx, prealloc_size);\n+    secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, sizeof(secp256k1_context));\n-    ret->illegal_callback = ctx->illegal_callback;\n-    ret->error_callback = ctx->error_callback;\n-    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx, &ctx->error_callback);\n-    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx, &ctx->error_callback);\n+    secp256k1_context* ret;\n+    size_t prealloc_size;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, prealloc_size);\n+    ret = secp256k1_context_preallocated_clone(ctx, ret);\n     return ret;\n }\n \n-void secp256k1_context_destroy(secp256k1_context* ctx) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+    }\n+}\n \n+void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    if (ctx != NULL) {\n+        secp256k1_context_preallocated_destroy(ctx);\n         free(ctx);\n     }\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_illegal_callback_fn;\n+        fun = secp256k1_default_illegal_callback_fn;\n     }\n     ctx->illegal_callback.fn = fun;\n     ctx->illegal_callback.data = data;\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_error_callback_fn;\n+        fun = secp256k1_default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n@@ -131,8 +210,9 @@ secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context*\n     return secp256k1_scratch_create(&ctx->error_callback, max_size);\n }\n \n-void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n-    secp256k1_scratch_destroy(scratch);\n+void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scratch_space* scratch) {\n+    VERIFY_CHECK(ctx != NULL);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n@@ -438,7 +518,7 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     ARG_CHECK(seckey != NULL);\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = (!overflow) & (!secp256k1_scalar_is_zero(&sec));\n+    ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n     if (ret) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n         secp256k1_ge_set_gej(&p, &pj);\n@@ -457,6 +537,7 @@ int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *sec\n     secp256k1_scalar_negate(&sec, &sec);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n+    secp256k1_scalar_clear(&sec);\n     return 1;\n }\n "
      },
      {
        "sha": "d408a5c30a48ac39114f952e5e86c54321a8c8f0",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 237,
        "deletions": 86,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"secp256k1.c\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n \n #ifdef ENABLE_OPENSSL_TESTS\n@@ -82,7 +83,9 @@ void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe_negate(&zero, &zero, 0);\n     secp256k1_fe_mul_int(&zero, n - 1);\n     secp256k1_fe_add(fe, &zero);\n-    VERIFY_CHECK(fe->magnitude == n);\n+#ifdef VERIFY\n+    CHECK(fe->magnitude == n);\n+#endif\n }\n \n void random_group_element_test(secp256k1_ge *ge) {\n@@ -137,23 +140,47 @@ void random_scalar_order(secp256k1_scalar *num) {\n     } while(1);\n }\n \n-void run_context_tests(void) {\n+void run_context_tests(int use_prealloc) {\n     secp256k1_pubkey pubkey;\n     secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n     int32_t ecount2;\n-    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n-    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n-    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n-    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *none;\n+    secp256k1_context *sign;\n+    secp256k1_context *vrfy;\n+    secp256k1_context *both;\n+    void *none_prealloc = NULL;\n+    void *sign_prealloc = NULL;\n+    void *vrfy_prealloc = NULL;\n+    void *both_prealloc = NULL;\n \n     secp256k1_gej pubj;\n     secp256k1_ge pub;\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    if (use_prealloc) {\n+        none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+        sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+        vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+        both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+        CHECK(none_prealloc != NULL);\n+        CHECK(sign_prealloc != NULL);\n+        CHECK(vrfy_prealloc != NULL);\n+        CHECK(both_prealloc != NULL);\n+        none = secp256k1_context_preallocated_create(none_prealloc, SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_preallocated_create(sign_prealloc, SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_preallocated_create(vrfy_prealloc, SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_preallocated_create(both_prealloc, SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    } else {\n+        none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    }\n+\n     memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n \n     ecount = 0;\n@@ -163,14 +190,57 @@ void run_context_tests(void) {\n     secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n     CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n \n+    /* check if sizes for cloning are consistent */\n+    CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+    CHECK(secp256k1_context_preallocated_clone_size(sign) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+    CHECK(secp256k1_context_preallocated_clone_size(vrfy) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+    CHECK(secp256k1_context_preallocated_clone_size(both) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+\n     /*** clone and destroy all of them to make sure cloning was complete ***/\n     {\n         secp256k1_context *ctx_tmp;\n \n-        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+        if (use_prealloc) {\n+            /* clone into a non-preallocated context and then again into a new preallocated one. */\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(none_prealloc); none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(none_prealloc != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, none_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(sign_prealloc); sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(sign_prealloc != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, sign_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(vrfy_prealloc); vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(vrfy_prealloc != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, vrfy_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(both_prealloc); both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(both_prealloc != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, both_prealloc); secp256k1_context_destroy(ctx_tmp);\n+        } else {\n+            /* clone into a preallocated context and then again into a new non-preallocated one. */\n+            void *prealloc_tmp;\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+        }\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n@@ -229,10 +299,6 @@ void run_context_tests(void) {\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n-    /* This shouldn't leak memory, due to already-set tests. */\n-    secp256k1_ecmult_gen_context_build(&sign->ecmult_gen_ctx, NULL);\n-    secp256k1_ecmult_context_build(&vrfy->ecmult_ctx, NULL);\n-\n     /* obtain a working nonce */\n     do {\n         random_scalar_order_test(&nonce);\n@@ -247,49 +313,95 @@ void run_context_tests(void) {\n     CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n-    secp256k1_context_destroy(none);\n-    secp256k1_context_destroy(sign);\n-    secp256k1_context_destroy(vrfy);\n-    secp256k1_context_destroy(both);\n+    if (use_prealloc) {\n+        secp256k1_context_preallocated_destroy(none);\n+        secp256k1_context_preallocated_destroy(sign);\n+        secp256k1_context_preallocated_destroy(vrfy);\n+        secp256k1_context_preallocated_destroy(both);\n+        free(none_prealloc);\n+        free(sign_prealloc);\n+        free(vrfy_prealloc);\n+        free(both_prealloc);\n+    } else {\n+        secp256k1_context_destroy(none);\n+        secp256k1_context_destroy(sign);\n+        secp256k1_context_destroy(vrfy);\n+        secp256k1_context_destroy(both);\n+    }\n     /* Defined as no-op. */\n     secp256k1_context_destroy(NULL);\n+    secp256k1_context_preallocated_destroy(NULL);\n+\n }\n \n void run_scratch_tests(void) {\n+    const size_t adj_alloc = ((500 + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n     int32_t ecount = 0;\n+    size_t checkpoint;\n+    size_t checkpoint_2;\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n     secp256k1_scratch_space *scratch;\n+    secp256k1_scratch_space local_scratch;\n \n     /* Test public API */\n     secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n \n     scratch = secp256k1_scratch_space_create(none, 1000);\n     CHECK(scratch != NULL);\n     CHECK(ecount == 0);\n \n     /* Test internal API */\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n-\n-    /* Allocating 500 bytes with no frame fails */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-\n-    /* ...but pushing a new stack frame does affect the max allocation */\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating 500 bytes succeeds */\n+    checkpoint = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating another 500 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* ...but it succeeds once we apply the checkpoint to undo it */\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(scratch->alloc_size != 0);\n+\n+    /* try to apply a bad checkpoint */\n+    checkpoint_2 = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(ecount == 0);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint_2); /* checkpoint_2 is after checkpoint */\n+    CHECK(ecount == 1);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, (size_t) -1); /* this is just wildly invalid */\n+    CHECK(ecount == 2);\n \n-    /* ...and this effect is undone by popping the frame */\n-    secp256k1_scratch_deallocate_frame(scratch);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    /* try to use badly initialized scratch space */\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    memset(&local_scratch, 0, sizeof(local_scratch));\n+    scratch = &local_scratch;\n+    CHECK(!secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0));\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(ecount == 4);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    CHECK(ecount == 5);\n \n     /* cleanup */\n-    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n }\n \n@@ -1709,24 +1821,32 @@ void run_field_misc(void) {\n         /* Test fe conditional move; z is not normalized here. */\n         q = x;\n         secp256k1_fe_cmov(&x, &z, 0);\n-        VERIFY_CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#endif\n         secp256k1_fe_cmov(&x, &x, 1);\n         CHECK(fe_memcmp(&x, &z) != 0);\n         CHECK(fe_memcmp(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n-        VERIFY_CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#endif\n         CHECK(fe_memcmp(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_normalize_var(&q);\n         secp256k1_fe_cmov(&q, &z, (i&1));\n-        VERIFY_CHECK(q.normalized && q.magnitude == 1);\n+#ifdef VERIFY\n+        CHECK(q.normalized && q.magnitude == 1);\n+#endif\n         for (j = 0; j < 6; j++) {\n             secp256k1_fe_negate(&z, &z, j+1);\n             secp256k1_fe_normalize_var(&q);\n             secp256k1_fe_cmov(&q, &z, (j&1));\n-            VERIFY_CHECK(!q.normalized && q.magnitude == (j+2));\n+#ifdef VERIFY\n+            CHECK(!q.normalized && q.magnitude == (j+2));\n+#endif\n         }\n         secp256k1_fe_normalize_var(&z);\n         /* Test storage conversion and conditional moves. */\n@@ -2120,7 +2240,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinitiy */\n+        /* randomly set half the points to infinity */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -2572,14 +2692,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_gej r;\n     secp256k1_gej r2;\n     ecmult_multi_data data;\n-    secp256k1_scratch *scratch_empty;\n \n     data.sc = sc;\n     data.pt = pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -2595,36 +2714,31 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         /* only G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n-        /* Try to multiply 1 point, but scratch space is empty */\n-        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n-        secp256k1_scratch_destroy(scratch_empty);\n-\n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2641,7 +2755,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2651,7 +2765,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2664,7 +2778,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -2677,7 +2791,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2692,7 +2806,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -2711,7 +2825,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2734,7 +2848,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2747,13 +2861,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -2798,7 +2912,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n                         secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -2809,6 +2923,24 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n }\n \n+void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Try to multiply 1 point, but scratch space is empty.*/\n+    scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n+}\n+\n void test_secp256k1_pippenger_bucket_window_inv(void) {\n     int i;\n \n@@ -2839,17 +2971,27 @@ void test_ecmult_multi_pippenger_max_points(void) {\n     int bucket_window = 0;\n \n     for(; scratch_size < max_size; scratch_size+=256) {\n+        size_t i;\n+        size_t total_alloc;\n+        size_t checkpoint;\n         scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n         CHECK(scratch != NULL);\n-        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        checkpoint = secp256k1_scratch_checkpoint(&ctx->error_callback, scratch);\n+        n_points_supported = secp256k1_pippenger_max_points(&ctx->error_callback, scratch);\n         if (n_points_supported == 0) {\n-            secp256k1_scratch_destroy(scratch);\n+            secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n             continue;\n         }\n         bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n-        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n-        secp256k1_scratch_deallocate_frame(scratch);\n-        secp256k1_scratch_destroy(scratch);\n+        /* allocate `total_alloc` bytes over `PIPPENGER_SCRATCH_OBJECTS` many allocations */\n+        total_alloc = secp256k1_pippenger_scratch_size(n_points_supported, bucket_window);\n+        for (i = 0; i < PIPPENGER_SCRATCH_OBJECTS - 1; i++) {\n+            CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, 1));\n+            total_alloc--;\n+        }\n+        CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, total_alloc));\n+        secp256k1_scratch_apply_checkpoint(&ctx->error_callback, scratch, checkpoint);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n }\n@@ -2932,19 +3074,25 @@ void test_ecmult_multi_batching(void) {\n     }\n     data.sc = sc;\n     data.pt = pt;\n+    secp256k1_gej_neg(&r2, &r2);\n \n-    /* Test with empty scratch space */\n+    /* Test with empty scratch space. It should compute the correct result using \n+     * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Test with space for 1 point in pippenger. That's not enough because\n-     * ecmult_multi selects strauss which requires more memory. */\n+     * ecmult_multi selects strauss which requires more memory. It should\n+     * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n-    secp256k1_gej_neg(&r2, &r2);\n     for(i = 1; i <= n_points; i++) {\n         if (i > ECMULT_PIPPENGER_THRESHOLD) {\n             int bucket_window = secp256k1_pippenger_bucket_window(i);\n@@ -2954,10 +3102,10 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n-        secp256k1_scratch_destroy(scratch);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     free(sc);\n     free(pt);\n@@ -2972,13 +3120,15 @@ void run_ecmult_multi_tests(void) {\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_pippenger_batch_single);\n     test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n-    secp256k1_scratch_destroy(scratch);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Run test_ecmult_multi with space for exactly one point */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     test_ecmult_multi_batch_size_helper();\n     test_ecmult_multi_batching();\n@@ -3050,7 +3200,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     }\n     bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n+    skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -4315,7 +4465,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0) << 14;\n+        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4356,7 +4506,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -5030,7 +5180,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if (sscanf(ch, \"%2hx\", &sh)) {\n+            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5062,7 +5212,8 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    run_context_tests();\n+    run_context_tests(0);\n+    run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {"
      },
      {
        "sha": "b44e357cb69c742b1eccb94695412960c82e6385",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -212,14 +212,14 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n                     }\n                 }\n             }\n         }\n     }\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {"
      },
      {
        "sha": "9deb61bc59d153c987ecc3a8fdca91962344e591",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/461acf5c6c39610c55988eed7a50922aed732ded/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/461acf5c6c39610c55988eed7a50922aed732ded/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=461acf5c6c39610c55988eed7a50922aed732ded",
        "patch": "@@ -84,6 +84,47 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n     return ret;\n }\n \n+#if defined(__BIGGEST_ALIGNMENT__)\n+#define ALIGNMENT __BIGGEST_ALIGNMENT__\n+#else\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes. */\n+#define ALIGNMENT 16\n+#endif\n+\n+#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+\n+/* Assume there is a contiguous memory object with bounds [base, base + max_size)\n+ * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n+ * where *prealloc_ptr is an aligned pointer. In that setting, this functions\n+ * reserves the subobject [*prealloc_ptr, *prealloc_ptr + alloc_size) of\n+ * alloc_size bytes by increasing *prealloc_ptr accordingly, taking into account\n+ * alignment requirements.\n+ *\n+ * The function returns an aligned pointer to the newly allocated subobject.\n+ *\n+ * This is useful for manual memory management: if we're simply given a block\n+ * [base, base + max_size), the caller can use this function to allocate memory\n+ * in this block and keep track of the current allocation state with *prealloc_ptr.\n+ *\n+ * It is VERIFY_CHECKed that there is enough space left in the memory object and\n+ * *prealloc_ptr is aligned relative to base.\n+ */\n+static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_size, void* base, size_t max_size) {\n+    size_t aligned_alloc_size = ROUND_TO_ALIGN(alloc_size);\n+    void* ret;\n+    VERIFY_CHECK(prealloc_ptr != NULL);\n+    VERIFY_CHECK(*prealloc_ptr != NULL);\n+    VERIFY_CHECK(base != NULL);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n+    VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    ret = *prealloc_ptr;\n+    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT"
      }
    ]
  },
  {
    "sha": "78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OGZiNThkMGI1Y2I1OGU2Njc5ZGYxNTVhY2Y3ZTA4NjFiYzA1YjJl",
    "commit": {
      "author": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:04:57Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:04:57Z"
      },
      "message": "Merge commit '461acf5c6c39610c55988eed7a50922aed732ded' into taproot-rebase-52b9797",
      "tree": {
        "sha": "9371f5e49e0859e3c1ab721c6201ef0c4884e68c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9371f5e49e0859e3c1ab721c6201ef0c4884e68c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e2UwZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf+FSD/kBZwSkf7wSqWofAea1632B\nbsf8tKR/TPNn0SG9iGgoETOdLH+l/8t7f0zEOdrP7aiuWbzlShEJtbHqCQeTwlQE\n7SS8E8ZjWvR46XlYv6l/qpJlNrslttYSKntn6bGtr6vpAnVmeleTnK+gCXUn9gUi\n8jhEo2G1BmMSIpZpmrVAl+yjAA3F/czx98PM+NnXI1T62D9aGJUoUb/VvxYTfUxV\nO7ohmvFV2MuA7cL1NflPVnInU1JUt3gIbdhsldcPYjhJCVtAjGTOYHySySrs9hVH\nfL0zhWKN14HI64f3kX4bralJEhuFrqvWbOZMxgTSI0bPiyAbQk0yL/R5UtmxMn2Z\nONgmbdkJsBbQJtFErZac3nrkHONcIpNBg5yczTfceMW1edrLrexKoJmb+Jd/NAvE\n40Q7tlCDMG7emjNjspsmZ5rH0y/O2k/iVzfJirAJEtN2INCfCEqBcZWkhtJIDHG0\nQHDji2HsiE44x2uAACiEpoIlmKk51aiktWfLCMhr4cCozJQhVqDpolhd+WSO+R8O\nVROXwDhXp0dirLF1LlO+zPwTwObeiWaXu6gKBHA9w6uLRWv4IiIeyUfExB3AQfcv\nJN0gM+RIDytqmsHWe9zc8dUpKY4kIDw/YTjUAtXbb14zgeLFtG5xva94n8VzO/Fd\nZl8YmMuSC6lxZDdrhlg6OQ==\n=NRte\n-----END PGP SIGNATURE-----",
        "payload": "tree 9371f5e49e0859e3c1ab721c6201ef0c4884e68c\nparent 52b9797119d5ee20b255efc68931ac7e158e325d\nparent 461acf5c6c39610c55988eed7a50922aed732ded\nauthor Elichai Turkel <elichai.turkel@gmail.com> 1566497097 -0400\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566497097 -0400\n\nMerge commit '461acf5c6c39610c55988eed7a50922aed732ded' into taproot-rebase-52b9797\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/comments",
    "author": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "52b9797119d5ee20b255efc68931ac7e158e325d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52b9797119d5ee20b255efc68931ac7e158e325d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52b9797119d5ee20b255efc68931ac7e158e325d"
      },
      {
        "sha": "461acf5c6c39610c55988eed7a50922aed732ded",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/461acf5c6c39610c55988eed7a50922aed732ded",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/461acf5c6c39610c55988eed7a50922aed732ded"
      }
    ],
    "stats": {
      "total": 1367,
      "additions": 956,
      "deletions": 411
    },
    "files": [
      {
        "sha": "21df09f41fb350ee982307bd46a9e7692e09dbcb",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -8,6 +8,7 @@ else\n JNI_LIB =\n endif\n include_HEADERS = include/secp256k1.h\n+include_HEADERS += include/secp256k1_preallocated.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h"
      },
      {
        "sha": "a9f9296ed73a669a99596a48d5622c828a6ffd0d",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -45,8 +45,10 @@ Implementation details\n   * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n-  * Access the table with branch-free conditional moves so memory access is uniform.\n-  * No data-dependent branches\n+  * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)\n+    * Access the table with branch-free conditional moves so memory access is uniform.\n+    * No data-dependent branches\n+  * Optional runtime blinding which attempts to frustrate differential power analysis.\n   * The precomputed tables add and eventually subtract points for which no known scalar (private key) is known, preventing even an attacker with control over the private key used to control the data internally.\n \n Build steps\n@@ -57,5 +59,5 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ ./tests\n+    $ make check\n     $ sudo make install  # optional"
      },
      {
        "sha": "b8340b7de13c71a6cc8b44f83bd981eae6cda526",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 73,
        "deletions": 31,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -85,42 +85,42 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n     [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n-    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis [default=no]]),\n     [enable_coverage=$enableval],\n     [enable_coverage=no])\n \n AC_ARG_ENABLE(tests,\n-    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    AS_HELP_STRING([--enable-tests],[compile tests [default=yes]]),\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n     [enable_openssl_tests=$enableval],\n     [enable_openssl_tests=auto])\n \n AC_ARG_ENABLE(experimental,\n-    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n AC_ARG_ENABLE(exhaustive_tests,\n-    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests [default=yes]]),\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n \n AC_ARG_ENABLE(ecmult_static_precomputation,\n-    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n+    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n     [use_ecmult_static_precomputation=auto])\n \n@@ -130,33 +130,47 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_recovery,\n-    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n+    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(external_default_callbacks,\n+    AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions (default is no)]),\n+    [use_external_default_callbacks=$enableval],\n+    [use_external_default_callbacks=no])\n+\n AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni [default=no]]),\n     [use_jni=$enableval],\n     [use_jni=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n+[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n+[assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n-[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n+[window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n+[Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n+[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n+)],\n+[req_ecmult_window=$withval], [req_ecmult_window=auto])\n \n AC_CHECK_TYPES([__int128])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n     CFLAGS=\"$CFLAGS -O0 --coverage\"\n-    LDFLAGS=\"--coverage\"\n+    LDFLAGS=\"$LDFLAGS --coverage\"\n else\n     CFLAGS=\"$CFLAGS -O3\"\n fi\n@@ -387,6 +401,28 @@ case $set_scalar in\n   ;;\n esac\n \n+#set ecmult window size\n+if test x\"$req_ecmult_window\" = x\"auto\"; then\n+  set_ecmult_window=15\n+else\n+  set_ecmult_window=$req_ecmult_window\n+fi\n+\n+error_window_size=['window size for ecmult precomputation not an integer in range [2..24] or \"auto\"']\n+case $set_ecmult_window in\n+''|*[[!0-9]]*)\n+  # no valid integer\n+  AC_MSG_ERROR($error_window_size)\n+  ;;\n+*)\n+  if test \"$set_ecmult_window\" -lt 2 -o \"$set_ecmult_window\" -gt 24 ; then\n+    # not in range\n+    AC_MSG_ERROR($error_window_size)\n+  fi\n+  AC_DEFINE_UNQUOTED(ECMULT_WINDOW_SIZE, $set_ecmult_window, [Set window size for ecmult precomputation])\n+  ;;\n+esac\n+\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n@@ -462,6 +498,10 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n+if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n+fi\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -504,21 +544,23 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism   = $use_endomorphism\"\n-echo \"  with ecmult precomp = $set_precomp\"\n-echo \"  with jni            = $use_jni\"\n-echo \"  with benchmarks     = $use_benchmark\"\n-echo \"  with coverage       = $enable_coverage\"\n-echo \"  module ecdh         = $enable_module_ecdh\"\n-echo \"  module recovery     = $enable_module_recovery\"\n+echo \"  with endomorphism       = $use_endomorphism\"\n+echo \"  with ecmult precomp     = $set_precomp\"\n+echo \"  with external callbacks = $use_external_default_callbacks\"\n+echo \"  with jni                = $use_jni\"\n+echo \"  with benchmarks         = $use_benchmark\"\n+echo \"  with coverage           = $enable_coverage\"\n+echo \"  module ecdh             = $enable_module_ecdh\"\n+echo \"  module recovery         = $enable_module_recovery\"\n echo\n-echo \"  asm                 = $set_asm\"\n-echo \"  bignum              = $set_bignum\"\n-echo \"  field               = $set_field\"\n-echo \"  scalar              = $set_scalar\"\n+echo \"  asm                     = $set_asm\"\n+echo \"  bignum                  = $set_bignum\"\n+echo \"  field                   = $set_field\"\n+echo \"  scalar                  = $set_scalar\"\n+echo \"  ecmult window size      = $set_ecmult_window\"\n echo\n-echo \"  CC                  = $CC\"\n-echo \"  CFLAGS              = $CFLAGS\"\n-echo \"  CPPFLAGS            = $CPPFLAGS\"\n-echo \"  LDFLAGS             = $LDFLAGS\"\n+echo \"  CC                      = $CC\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n+echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  LDFLAGS                 = $LDFLAGS\"\n echo"
      },
      {
        "sha": "e177a0562dd2d2525a095c1dc3922b0ad5241ca5",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -32,7 +32,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         pos += lenbyte;\n@@ -51,7 +51,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {\n@@ -89,7 +89,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {"
      },
      {
        "sha": "fc27626dd825763b8988052994b4c8380c3c47ef",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 59,
        "deletions": 17,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -33,9 +33,10 @@ extern \"C\" {\n  *  verification).\n  *\n  *  A constructed context can safely be used from multiple threads\n- *  simultaneously, but API call that take a non-const pointer to a context\n+ *  simultaneously, but API calls that take a non-const pointer to a context\n  *  need exclusive access to it. In particular this is the case for\n- *  secp256k1_context_destroy and secp256k1_context_randomize.\n+ *  secp256k1_context_destroy, secp256k1_context_preallocated_destroy,\n+ *  and secp256k1_context_randomize.\n  *\n  *  Regarding randomization, either do it once at creation time (in which case\n  *  you do not need any locking for the other calls), or use a read-write lock.\n@@ -163,7 +164,8 @@ typedef int (*secp256k1_nonce_function)(\n #define SECP256K1_FLAGS_BIT_CONTEXT_SIGN (1 << 9)\n #define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)\n \n-/** Flags to pass to secp256k1_context_create. */\n+/** Flags to pass to secp256k1_context_create, secp256k1_context_preallocated_size, and\n+ *  secp256k1_context_preallocated_create. */\n #define SECP256K1_CONTEXT_VERIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)\n #define SECP256K1_CONTEXT_SIGN (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)\n #define SECP256K1_CONTEXT_NONE (SECP256K1_FLAGS_TYPE_CONTEXT)\n@@ -186,7 +188,11 @@ typedef int (*secp256k1_nonce_function)(\n  */\n SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n \n-/** Create a secp256k1 context object.\n+/** Create a secp256k1 context object (in dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n@@ -197,7 +203,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n ) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Copies a secp256k1 context object.\n+/** Copy a secp256k1 context object (into dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  Args:    ctx: an existing context to copy (cannot be NULL)\n@@ -206,10 +216,18 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Destroy a secp256k1 context object.\n+/** Destroy a secp256k1 context object (created in dynamically allocated memory).\n  *\n  *  The context pointer may not be used afterwards.\n- *  Args:   ctx: an existing context to destroy (cannot be NULL)\n+ *\n+ *  The context to destroy must have been created using secp256k1_context_create\n+ *  or secp256k1_context_clone. If the context has instead been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the\n+ *  behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must\n+ *  be used instead.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_create or secp256k1_context_clone\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n@@ -229,11 +247,28 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  to cause a crash, though its return value and output arguments are\n  *  undefined.\n  *\n+ *  When this function has not been called (or called with fn==NULL), then the\n+ *  default handler will be used.\u00a0The library provides a default handler which\n+ *  writes the message to stderr and calls abort. This default handler can be\n+ *  replaced at link time if the preprocessor macro\n+ *  USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build\n+ *  has been configured with --enable-external-default-callbacks. Then the\n+ *  following two symbols must be provided to link against:\n+ *   - void secp256k1_default_illegal_callback_fn(const char* message, void* data);\n+ *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n+ *  The library can call these default handlers even before a proper callback data\n+ *  pointer could have been set using secp256k1_context_set_illegal_callback or\n+ *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  fails. In this case, the corresponding default handler will be called with\n+ *  the data pointer argument set to NULL.\n+ *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n- *              passed to the API, taking a message and an opaque pointer\n- *              (NULL restores a default handler that calls abort).\n+ *              passed to the API, taking a message and an opaque pointer.\n+ *              (NULL restores the default handler.)\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_error_callback.\n  */\n SECP256K1_API void secp256k1_context_set_illegal_callback(\n     secp256k1_context* ctx,\n@@ -253,9 +288,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n- *              taking a message and an opaque pointer (NULL restores a default\n- *              handler that calls abort).\n+ *              taking a message and an opaque pointer (NULL restores the\n+ *              default handler, see secp256k1_context_set_illegal_callback\n+ *              for details).\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_illegal_callback.\n  */\n SECP256K1_API void secp256k1_context_set_error_callback(\n     secp256k1_context* ctx,\n@@ -267,21 +305,24 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n  *\n  *  Returns: a newly created scratch space.\n  *  Args: ctx:  an existing context object (cannot be NULL)\n- *  In:   max_size: maximum amount of memory to allocate\n+ *  In:   size: amount of memory to be available as scratch space. Some extra\n+ *              (<100 bytes) will be allocated for extra accounting.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n     const secp256k1_context* ctx,\n-    size_t max_size\n+    size_t size\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Destroy a secp256k1 scratch space.\n  *\n  *  The pointer may not be used afterwards.\n- *  Args:   scratch: space to destroy\n+ *  Args:       ctx: a secp256k1 context object.\n+ *          scratch: space to destroy\n  */\n SECP256K1_API void secp256k1_scratch_space_destroy(\n+    const secp256k1_context* ctx,\n     secp256k1_scratch_space* scratch\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Parse a variable-length public key into the pubkey object.\n  *\n@@ -605,7 +646,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n  * Args:    ctx:    pointer to a context object initialized for validation\n  *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key obkect.\n+ * In/Out:  pubkey: pointer to a public key object.\n  * In:      tweak:  pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n@@ -636,7 +677,8 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * contexts not initialized for signing; then it will have no effect and return 1.\n  *\n  * You should call this after secp256k1_context_create or\n- * secp256k1_context_clone, and may call this repeatedly afterwards.\n+ * secp256k1_context_clone (and secp256k1_context_preallocated_create or\n+ * secp256k1_context_clone, resp.), and you may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "a9ae15d5ae8d80264c5dd1e44b17ccf81a2456a4",
        "filename": "src/secp256k1/include/secp256k1_preallocated.h",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_preallocated.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -0,0 +1,128 @@\n+#ifndef SECP256K1_PREALLOCATED_H\n+#define SECP256K1_PREALLOCATED_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The module provided by this header file is intended for settings in which it\n+ * is not possible or desirable to rely on dynamic memory allocation. It provides\n+ * functions for creating, cloning, and destroying secp256k1 context objects in a\n+ * contiguous fixed-size block of memory provided by the caller.\n+ *\n+ * Context objects created by functions in this module can be used like contexts\n+ * objects created by functions in secp256k1.h, i.e., they can be passed to any\n+ * API function that expects a context object (see secp256k1.h for details). The\n+ * only exception is that context objects created by functions in this module\n+ * must be destroyed using secp256k1_context_preallocated_destroy (in this\n+ * module) instead of secp256k1_context_destroy (in secp256k1.h).\n+ *\n+ * It is guaranteed that functions in this module will not call malloc or its\n+ * friends realloc, calloc, and free.\n+ */\n+\n+/** Determine the memory size of a secp256k1 context object to be created in\n+ *  caller-provided memory.\n+ *\n+ *  The purpose of this function is to determine how much memory must be provided\n+ *  to secp256k1_context_preallocated_create.\n+ *\n+ *  Returns: the required size of the caller-provided memory block\n+ *  In:      flags:    which parts of the context to initialize.\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_size(\n+    unsigned int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Create a secp256k1 context object in caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, which begins with the call to this\n+ *  function and ends when a call to secp256k1_context_preallocated_destroy\n+ *  (which destroys the context object again) returns. During the lifetime of the\n+ *  context object, the caller is obligated not to access this block of memory,\n+ *  i.e., the caller may not read or write the memory, e.g., by copying the memory\n+ *  contents to a different location or trying to create a second context object\n+ *  in the memory. In simpler words, the prealloc pointer (or any pointer derived\n+ *  from it) should not be used during the lifetime of the context object.\n+ *\n+ *  Returns: a newly created context object.\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ *           flags:    which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize (in secp256k1.h)\n+ *  and secp256k1_context_preallocated_destroy.\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n+    void* prealloc,\n+    unsigned int flags\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Determine the memory size of a secp256k1 context object to be copied into\n+ *  caller-provided memory.\n+ *\n+ *  Returns: the required size of the caller-provided memory block.\n+ *  In:      ctx: an existing context to copy (cannot be NULL)\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n+    const secp256k1_context* ctx\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Copy a secp256k1 context object into caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, see the description of\n+ *  secp256k1_context_preallocated_create for details.\n+ *\n+ *  Returns: a newly created context object.\n+ *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n+    const secp256k1_context* ctx,\n+    void* prealloc\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Destroy a secp256k1 context object that has been created in\n+ *  caller-provided memory.\n+ *\n+ *  The context pointer may not be used afterwards.\n+ *\n+ *  The context to destroy must have been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone.\n+ *  If the context has instead been created using secp256k1_context_create or\n+ *  secp256k1_context_clone, the behaviour is undefined. In that case,\n+ *  secp256k1_context_destroy must be used instead.\n+ *\n+ *  If required, it is the responsibility of the caller to deallocate the block\n+ *  of memory properly after this function returns, e.g., by calling free on the\n+ *  preallocated pointer given to secp256k1_context_preallocated_create or\n+ *  secp256k1_context_preallocated_clone.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_preallocated_create or\n+ *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ */\n+SECP256K1_API void secp256k1_context_preallocated_destroy(\n+    secp256k1_context* ctx\n+);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_PREALLOCATED_H */"
      },
      {
        "sha": "9a5bd06721778da61e34ca16dcc60a10b0d20a36",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -16,15 +16,9 @@ Note:\n */\n \n \t.syntax unified\n-\t.arch armv7-a\n \t@ eabi attributes - see readelf -A\n-\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n-\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n-\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n \t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n \t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n-\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Aggressive Speed\n-\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n \t.text\n \n \t@ Field constants"
      },
      {
        "sha": "3a3969d3001d6ae1ec6e4dfd40f0c0ec22ad16ff",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -10,7 +10,10 @@\n #ifdef USE_BASIC_CONFIG\n \n #undef USE_ASM_X86_64\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n #undef USE_ENDOMORPHISM\n+#undef USE_EXTERNAL_ASM\n+#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_10X26\n #undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n@@ -27,6 +30,7 @@\n #define USE_SCALAR_INV_BUILTIN 1\n #define USE_FIELD_10X26 1\n #define USE_SCALAR_8X32 1\n+#define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "7b5d185dce606b4d60a4d115a34cbbf7fd9432ee",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -64,7 +64,7 @@ static void bench_ecmult(void* arg) {\n     size_t iter;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -154,7 +154,7 @@ int main(int argc, char **argv) {\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.scratch);\n+            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n             data.scratch = NULL;\n         } else {\n             fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n@@ -193,10 +193,10 @@ int main(int argc, char **argv) {\n             run_test(&data, i << p, 1);\n         }\n     }\n-    secp256k1_context_destroy(data.ctx);\n     if (data.scratch != NULL) {\n-        secp256k1_scratch_space_destroy(data.scratch);\n+        secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n     }\n+    secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n     free(data.seckeys);"
      },
      {
        "sha": "a8f4e9e12f6d1b9a62789dcd3d5e764efa430b0d",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -253,7 +253,7 @@ void bench_wnaf_const(void* arg) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n+        secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }"
      },
      {
        "sha": "eb099c87dc83fe0898814a8de5e4edaeeeb8f448",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 38,
        "deletions": 32,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -46,68 +46,73 @@ static const secp256k1_fe secp256k1_ecdsa_const_p_minus_order = SECP256K1_FE_CON\n     0, 0, 0, 1, 0x45512319UL, 0x50B75FC4UL, 0x402DA172UL, 0x2FC9BAEEUL\n );\n \n-static int secp256k1_der_read_len(const unsigned char **sigp, const unsigned char *sigend) {\n-    int lenleft, b1;\n-    size_t ret = 0;\n+static int secp256k1_der_read_len(size_t *len, const unsigned char **sigp, const unsigned char *sigend) {\n+    size_t lenleft;\n+    unsigned char b1;\n+    VERIFY_CHECK(len != NULL);\n+    *len = 0;\n     if (*sigp >= sigend) {\n-        return -1;\n+        return 0;\n     }\n     b1 = *((*sigp)++);\n     if (b1 == 0xFF) {\n         /* X.690-0207 8.1.3.5.c the value 0xFF shall not be used. */\n-        return -1;\n+        return 0;\n     }\n     if ((b1 & 0x80) == 0) {\n         /* X.690-0207 8.1.3.4 short form length octets */\n-        return b1;\n+        *len = b1;\n+        return 1;\n     }\n     if (b1 == 0x80) {\n         /* Indefinite length is not allowed in DER. */\n-        return -1;\n+        return 0;\n     }\n     /* X.690-207 8.1.3.5 long form length octets */\n-    lenleft = b1 & 0x7F;\n-    if (lenleft > sigend - *sigp) {\n-        return -1;\n+    lenleft = b1 & 0x7F; /* lenleft is at least 1 */\n+    if (lenleft > (size_t)(sigend - *sigp)) {\n+        return 0;\n     }\n     if (**sigp == 0) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    if ((size_t)lenleft > sizeof(size_t)) {\n+    if (lenleft > sizeof(size_t)) {\n         /* The resulting length would exceed the range of a size_t, so\n          * certainly longer than the passed array size.\n          */\n-        return -1;\n+        return 0;\n     }\n     while (lenleft > 0) {\n-        ret = (ret << 8) | **sigp;\n-        if (ret + lenleft > (size_t)(sigend - *sigp)) {\n-            /* Result exceeds the length of the passed array. */\n-            return -1;\n-        }\n+        *len = (*len << 8) | **sigp;\n         (*sigp)++;\n         lenleft--;\n     }\n-    if (ret < 128) {\n+    if (*len > (size_t)(sigend - *sigp)) {\n+        /* Result exceeds the length of the passed array. */\n+        return 0;\n+    }\n+    if (*len < 128) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    return ret;\n+    return 1;\n }\n \n static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char **sig, const unsigned char *sigend) {\n     int overflow = 0;\n     unsigned char ra[32] = {0};\n-    int rlen;\n+    size_t rlen;\n \n     if (*sig == sigend || **sig != 0x02) {\n         /* Not a primitive integer (X.690-0207 8.3.1). */\n         return 0;\n     }\n     (*sig)++;\n-    rlen = secp256k1_der_read_len(sig, sigend);\n-    if (rlen <= 0 || (*sig) + rlen > sigend) {\n+    if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n+        return 0;\n+    }\n+    if (rlen == 0 || *sig + rlen > sigend) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -123,8 +128,11 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         /* Negative. */\n         overflow = 1;\n     }\n-    while (rlen > 0 && **sig == 0) {\n-        /* Skip leading zero bytes */\n+    /* There is at most one leading zero byte:\n+     * if there were two leading zero bytes, we would have failed and returned 0\n+     * because of excessive 0x00 padding already. */\n+    if (rlen > 0 && **sig == 0) {\n+        /* Skip leading zero byte */\n         rlen--;\n         (*sig)++;\n     }\n@@ -144,18 +152,16 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *rr, secp256k1_scalar *rs, const unsigned char *sig, size_t size) {\n     const unsigned char *sigend = sig + size;\n-    int rlen;\n+    size_t rlen;\n     if (sig == sigend || *(sig++) != 0x30) {\n         /* The encoding doesn't start with a constructed sequence (X.690-0207 8.9.1). */\n         return 0;\n     }\n-    rlen = secp256k1_der_read_len(&sig, sigend);\n-    if (rlen < 0 || sig + rlen > sigend) {\n-        /* Tuple exceeds bounds */\n+    if (secp256k1_der_read_len(&rlen, &sig, sigend) == 0) {\n         return 0;\n     }\n-    if (sig + rlen != sigend) {\n-        /* Garbage after tuple. */\n+    if (rlen != (size_t)(sigend - sig)) {\n+        /* Tuple exceeds bounds or garage after tuple. */\n         return 0;\n     }\n "
      },
      {
        "sha": "c9b198239d88974078443897b099851f94a6d395",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -20,10 +20,10 @@ typedef struct {\n #endif\n } secp256k1_ecmult_context;\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb);\n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n \n@@ -43,6 +43,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "03bb33257d532f8a7345bd4b8f7b090ddb346a92",
        "filename": "src/secp256k1/src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -10,8 +10,11 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+/**\n+ * Multiply: R = q*A (in constant-time)\n+ * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion.\n+ */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "aaa576ada4cc22bb2bb3a784d0c2514e8aeccead",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 13,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -48,7 +48,7 @@\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n+static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -59,8 +59,12 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     int flip;\n     int bit;\n-    secp256k1_scalar neg_s;\n+    secp256k1_scalar s;\n     int not_neg_one;\n+\n+    VERIFY_CHECK(w > 0);\n+    VERIFY_CHECK(size > 0);\n+\n     /* Note that we cannot handle even numbers by negating them to be odd, as is\n      * done in other implementations, since if our scalars were specified to have\n      * width < 256 for performance reasons, their negations would have width 256\n@@ -75,12 +79,13 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n      * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n      * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n      * we need to special-case it in this logic. */\n-    flip = secp256k1_scalar_is_high(&s);\n+    flip = secp256k1_scalar_is_high(scalar);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ !secp256k1_scalar_is_even(&s);\n+    bit = flip ^ !secp256k1_scalar_is_even(scalar);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n-    secp256k1_scalar_negate(&neg_s, &s);\n-    not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n+    secp256k1_scalar_negate(&s, scalar);\n+    not_neg_one = !secp256k1_scalar_is_one(&s);\n+    s = *scalar;\n     secp256k1_scalar_cadd_bit(&s, bit, not_neg_one);\n     /* If we had negative one, flip == 1, s.d[0] == 0, bit == 1, so caller expects\n      * that we added two to it and flipped it. In fact for -1 these operations are\n@@ -93,7 +98,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < size) {\n+    do {\n         int sign;\n         int even;\n \n@@ -109,7 +114,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n         wnaf[word++] = u_last * global_sign;\n \n         u_last = u;\n-    }\n+    } while (word * w < size);\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n@@ -132,21 +137,20 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n-    secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n #ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n-        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n #endif\n     {\n-        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n #endif"
      },
      {
        "sha": "b136e94632ddf6196c93afcc5c88a16294a63675",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -28,10 +28,10 @@ typedef struct {\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n+static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, const secp256k1_callback* cb);\n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context* src, const secp256k1_callback* cb);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);\n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context* ctx);\n static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context* ctx);\n "
      },
      {
        "sha": "0e2eafa71de307644041ce0076290eb7989e73b9",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 20,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -7,30 +7,40 @@\n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n \n+#include \"util.h\"\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n #include \"hash_impl.h\"\n #ifdef USE_ECMULT_STATIC_PRECOMPUTATION\n #include \"ecmult_static_context.h\"\n #endif\n+\n+#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = ROUND_TO_ALIGN(sizeof(*((secp256k1_ecmult_gen_context*) NULL)->prec));\n+#else\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = 0;\n+#endif\n+\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context *ctx) {\n     ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, const secp256k1_callback* cb) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, void **prealloc) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n     secp256k1_ge prec[1024];\n     secp256k1_gej gj;\n     secp256k1_gej nums_gej;\n     int i, j;\n+    size_t const prealloc_size = SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    void* const base = *prealloc;\n #endif\n \n     if (ctx->prec != NULL) {\n         return;\n     }\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*ctx->prec));\n+    ctx->prec = (secp256k1_ge_storage (*)[64][16])manual_alloc(prealloc, prealloc_size, base, prealloc_size);\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -85,7 +95,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n         }\n     }\n #else\n-    (void)cb;\n+    (void)prealloc;\n     ctx->prec = (secp256k1_ge_storage (*)[64][16])secp256k1_ecmult_static_context;\n #endif\n     secp256k1_ecmult_gen_blind(ctx, NULL);\n@@ -95,27 +105,18 @@ static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_cont\n     return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context *src, const secp256k1_callback* cb) {\n-    if (src->prec == NULL) {\n-        dst->prec = NULL;\n-    } else {\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context *src) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-        dst->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*dst->prec));\n-        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+    if (src->prec != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->prec = (secp256k1_ge_storage (*)[64][16])(void*)((unsigned char*)dst + ((unsigned char*)src->prec - (unsigned char*)src));\n+    }\n #else\n-        (void)cb;\n-        dst->prec = src->prec;\n+    (void)dst, (void)src;\n #endif\n-        dst->initial = src->initial;\n-        dst->blind = src->blind;\n-    }\n }\n \n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context *ctx) {\n-#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    free(ctx->prec);\n-#endif\n     secp256k1_scalar_clear(&ctx->blind);\n     secp256k1_gej_clear(&ctx->initial);\n     ctx->prec = NULL;\n@@ -186,7 +187,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     do {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n         retry = !secp256k1_fe_set_b32(&s, nonce32);\n-        retry |= secp256k1_fe_is_zero(&s);\n+        retry = retry || secp256k1_fe_is_zero(&s);\n     } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > Fp. */\n     /* Randomize the projection to defend against multiplier sidechannels. */\n     secp256k1_gej_rescale(&ctx->initial, &s);\n@@ -195,7 +196,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n         secp256k1_scalar_set_b32(&b, nonce32, &retry);\n         /* A blinding value of 0 works, but would undermine the projection hardening. */\n-        retry |= secp256k1_scalar_is_zero(&b);\n+        retry = retry || secp256k1_scalar_is_zero(&b);\n     } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > order. */\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n     memset(nonce32, 0, 32);"
      },
      {
        "sha": "d1a00f600bd48c2f7e7bd863d999f64d3aaa0e94",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 108,
        "deletions": 73,
        "changes": 181,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -10,6 +10,7 @@\n #include <string.h>\n #include <stdint.h>\n \n+#include \"util.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n@@ -30,16 +31,32 @@\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n-#define WINDOW_A 5\n-/** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. */\n-#ifdef USE_ENDOMORPHISM\n-/** Two tables for window size 15: 1.375 MiB. */\n-#define WINDOW_G 15\n-#else\n-/** One table for window size 16: 1.375 MiB. */\n-#define WINDOW_G 16\n+#  define WINDOW_A 5\n+/** Larger values for ECMULT_WINDOW_SIZE result in possibly better\n+ *  performance at the cost of an exponentially larger precomputed\n+ *  table. The exact table size is\n+ *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n+ *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n+ *  be larger due to platform-specific padding and alignment.\n+ *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n+ *  two tables of this size are used instead of only one.\n+ */\n+#  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n+\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * not tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #ifdef USE_ENDOMORPHISM\n@@ -294,15 +311,24 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n+    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#ifdef USE_ENDOMORPHISM\n+    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#endif\n+    ;\n+\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n #endif\n }\n \n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n     secp256k1_gej gj;\n+    void* const base = *prealloc;\n+    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n \n     if (ctx->pre_g != NULL) {\n         return;\n@@ -311,7 +337,12 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n-    ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+    {\n+        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n+    }\n \n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n@@ -321,7 +352,10 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         secp256k1_gej g_128j;\n         int i;\n \n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n \n         /* calculate 2^128*generator */\n         g_128j = gj;\n@@ -333,22 +367,14 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n #endif\n }\n \n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb) {\n-    if (src->pre_g == NULL) {\n-        dst->pre_g = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g, src->pre_g, size);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n+    if (src->pre_g != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n #ifdef USE_ENDOMORPHISM\n-    if (src->pre_g_128 == NULL) {\n-        dst->pre_g_128 = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    if (src->pre_g_128 != NULL) {\n+        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n #endif\n }\n@@ -358,10 +384,6 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n }\n \n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    free(ctx->pre_g);\n-#ifdef USE_ENDOMORPHISM\n-    free(ctx->pre_g_128);\n-#endif\n     secp256k1_ecmult_context_init(ctx);\n }\n \n@@ -373,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s = *a;\n+    secp256k1_scalar s;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -386,6 +408,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n+    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;\n@@ -418,7 +441,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     CHECK(carry == 0);\n     while (bit < 256) {\n         CHECK(secp256k1_scalar_get_bits(&s, bit++, 1) == 0);\n-    } \n+    }\n #endif\n     return last_set_bit + 1;\n }\n@@ -626,52 +649,55 @@ static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n     size_t i;\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n \n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n     }\n \n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n-        return 0;\n-    }\n-    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n-    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n-    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n-    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n #ifdef USE_ENDOMORPHISM\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n #else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n #endif\n-    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n \n     for (i = 0; i < n_points; i++) {\n         secp256k1_ge point;\n         if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n-static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n-    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(error_callback, scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n }\n \n /** Convert a number to WNAF notation.\n@@ -963,7 +989,8 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n@@ -988,15 +1015,21 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     }\n \n     bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n+    if (points == NULL || scalars == NULL || state_space == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n+\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, (1<<bucket_window) * sizeof(*buckets));\n+    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n \n     if (inp_g_sc != NULL) {\n         scalars[0] = *inp_g_sc;\n@@ -1010,7 +1043,7 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n \n     while (point_idx < n_points) {\n         if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         idx++;\n@@ -1034,22 +1067,22 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     for(i = 0; i < 1<<bucket_window; i++) {\n         secp256k1_gej_clear(&buckets[i]);\n     }\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n  * Returns the maximum number of points in addition to G that can be used with\n  * a given scratch space. The function ensures that fewer points may also be\n  * used.\n  */\n-static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n     int bucket_window;\n     size_t res = 0;\n \n@@ -1131,11 +1164,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1152,24 +1185,26 @@ static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp2\n         return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n \n-    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n-     * use pippenger. Otherwise use strauss */\n-    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n-        return 0;\n+    /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n+     * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n+     * As a first step check if there's enough space for Pippenger's algo (which requires less space\n+     * than Strauss' algo) and if not, use the simple algorithm. */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n-        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n-            return 0;\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n+            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "82c605c5d4f77245329ff3fbcc0a35e06ae1cf2c",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"basic-config.h\"\n #include \"include/secp256k1.h\"\n+#include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -26,6 +27,7 @@ static const secp256k1_callback default_error_callback = {\n \n int main(int argc, char **argv) {\n     secp256k1_ecmult_gen_context ctx;\n+    void *prealloc, *base;\n     int inner;\n     int outer;\n     FILE* fp;\n@@ -38,15 +40,17 @@ int main(int argc, char **argv) {\n         fprintf(stderr, \"Could not open src/ecmult_static_context.h for writing!\\n\");\n         return -1;\n     }\n-    \n+\n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n     fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n \n+    base = checked_malloc(&default_error_callback, SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE);\n+    prealloc = base;\n     secp256k1_ecmult_gen_context_init(&ctx);\n-    secp256k1_ecmult_gen_context_build(&ctx, &default_error_callback);\n+    secp256k1_ecmult_gen_context_build(&ctx, &prealloc);\n     for(outer = 0; outer != 64; outer++) {\n         fprintf(fp,\"{\\n\");\n         for(inner = 0; inner != 16; inner++) {\n@@ -65,10 +69,11 @@ int main(int argc, char **argv) {\n     }\n     fprintf(fp,\"};\\n\");\n     secp256k1_ecmult_gen_context_clear(&ctx);\n-    \n+    free(base);\n+\n     fprintf(fp, \"#undef SC\\n\");\n     fprintf(fp, \"#endif\\n\");\n     fclose(fp);\n-    \n+\n     return 0;\n }"
      },
      {
        "sha": "782f97216c284eff353a339fdd544c49ab2a7911",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -131,7 +131,8 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n-    while (bufsize + len >= 64) {\n+    VERIFY_CHECK(hash->bytes >= len);\n+    while (len >= 64 - bufsize) {\n         /* Fill the buffer, and process it. */\n         size_t chunk_len = 64 - bufsize;\n         memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);"
      },
      {
        "sha": "710d9f0bbfef3e50388a247baa712dc5acc74f0a",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -3,7 +3,6 @@\n import com.google.common.io.BaseEncoding;\n import java.util.Arrays;\n import java.math.BigInteger;\n-import javax.xml.bind.DatatypeConverter;\n import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n@@ -70,7 +69,7 @@ public static void testPubKeyCreatePos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String pubkeyString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n     }\n \n@@ -81,7 +80,7 @@ public static void testPubKeyCreateNeg() throws AssertFailException{\n        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       String pubkeyString = BaseEncoding.base16().encode(resultArr);\n        assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n     }\n \n@@ -94,7 +93,7 @@ public static void testSignPos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n     }\n \n@@ -106,7 +105,7 @@ public static void testSignNeg() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString, \"\" , \"testSignNeg\");\n     }\n \n@@ -118,7 +117,7 @@ public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n     }\n \n@@ -130,7 +129,7 @@ public static void testPrivKeyTweakMul_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n     }\n \n@@ -142,7 +141,7 @@ public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n     }\n \n@@ -154,7 +153,7 @@ public static void testPrivKeyTweakMul_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n     }\n \n@@ -173,7 +172,7 @@ public static void testCreateECDHSecret() throws AssertFailException{\n         byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String ecdhString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n     }\n "
      },
      {
        "sha": "b590256867c671372ab85ccb85383db592a4c775",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -81,15 +81,15 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n   jbyteArray sigArray, intsByteArray;\n   unsigned char intsarray[2];\n \n-  secp256k1_ecdsa_signature sig[72];\n+  secp256k1_ecdsa_signature sig;\n \n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n+  int ret = secp256k1_ecdsa_sign(ctx, &sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n \n   if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, &sig ); (void)ret2;\n   }\n \n   intsarray[0] = outputLen;"
      },
      {
        "sha": "ed356e53a5c8f7e6246a272765f290c49ebcc2f1",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -147,7 +147,7 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n+            if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }"
      },
      {
        "sha": "38a533a755fc9aada88ffc66e358aee2e505d419",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 0. */\n+         * and secret key 0 (which is not valid), resulting in recid 1. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "6b336d9d1a66d9c70a8c636b6ddad8b154613299",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n-#include \"group.h\"\n #include \"scalar.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "77b35d126bbe6b22c4a2e72311dd87f91039848e",
        "filename": "src/secp256k1/src/scratch.h",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -7,33 +7,36 @@\n #ifndef _SECP256K1_SCRATCH_\n #define _SECP256K1_SCRATCH_\n \n-#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n-\n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */\n typedef struct secp256k1_scratch_space_struct {\n-    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame;\n+    /** guard against interpreting this object as other types */\n+    unsigned char magic[8];\n+    /** actual allocated data */\n+    void *data;\n+    /** amount that has been allocated (i.e. `data + offset` is the next\n+     *  available pointer)  */\n+    size_t alloc_size;\n+    /** maximum size available to allocate */\n     size_t max_size;\n-    const secp256k1_callback* error_callback;\n } secp256k1_scratch;\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch);\n \n-/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+/** Returns an opaque object used to \"checkpoint\" a scratch space. Used\n+ *  with `secp256k1_scratch_apply_checkpoint` to undo allocations. */\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch);\n \n-/** Deallocates a stack frame */\n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+/** Applies a check point received from `secp256k1_scratch_checkpoint`,\n+ *  undoing all allocations since that point. */\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint);\n \n /** Returns the maximum allocation the scratch space will allow */\n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t n_objects);\n \n /** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t n);\n \n #endif"
      },
      {
        "sha": "4cee70000147b7b84e5759f00b0275fb9ead9107",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "modified",
        "additions": 47,
        "deletions": 45,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -7,78 +7,80 @@\n #ifndef _SECP256K1_SCRATCH_IMPL_H_\n #define _SECP256K1_SCRATCH_IMPL_H_\n \n+#include \"util.h\"\n #include \"scratch.h\"\n \n-/* Using 16 bytes alignment because common architectures never have alignment\n- * requirements above 8 for any of the types we care about. In addition we\n- * leave some room because currently we don't care about a few bytes.\n- * TODO: Determine this at configure time. */\n-#define ALIGNMENT 16\n-\n-static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n-    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n+    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    void *alloc = checked_malloc(error_callback, base_alloc + size);\n+    secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n         memset(ret, 0, sizeof(*ret));\n-        ret->max_size = max_size;\n-        ret->error_callback = error_callback;\n+        memcpy(ret->magic, \"scratch\", 8);\n+        ret->data = (void *) ((char *) alloc + base_alloc);\n+        ret->max_size = size;\n     }\n     return ret;\n }\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n-        VERIFY_CHECK(scratch->frame == 0);\n+        VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n+        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+            secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+            return;\n+        }\n+        memset(scratch->magic, 0, sizeof(scratch->magic));\n         free(scratch);\n     }\n }\n \n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n-    size_t i = 0;\n-    size_t allocated = 0;\n-    for (i = 0; i < scratch->frame; i++) {\n-        allocated += scratch->frame_size[i];\n-    }\n-    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n-    return scratch->max_size - allocated - objects * ALIGNMENT;\n+    return scratch->alloc_size;\n }\n \n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n-    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n-\n-    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n-        n += objects * ALIGNMENT;\n-        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n-        if (scratch->data[scratch->frame] == NULL) {\n-            return 0;\n-        }\n-        scratch->frame_size[scratch->frame] = n;\n-        scratch->offset[scratch->frame] = 0;\n-        scratch->frame++;\n-        return 1;\n-    } else {\n-        return 0;\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return;\n+    }\n+    if (checkpoint > scratch->alloc_size) {\n+        secp256k1_callback_call(error_callback, \"invalid checkpoint\");\n+        return;\n     }\n+    scratch->alloc_size = checkpoint;\n }\n \n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n-    VERIFY_CHECK(scratch->frame > 0);\n-    scratch->frame -= 1;\n-    free(scratch->data[scratch->frame]);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return 0;\n+    }\n+    if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n+        return 0;\n+    }\n+    return scratch->max_size - scratch->alloc_size - objects * (ALIGNMENT - 1);\n }\n \n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size_t frame = scratch->frame - 1;\n-    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    size = ROUND_TO_ALIGN(size);\n+\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return NULL;\n+    }\n \n-    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+    if (size > scratch->max_size - scratch->alloc_size) {\n         return NULL;\n     }\n-    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    ret = (void *) ((char *) scratch->data + scratch->alloc_size);\n     memset(ret, 0, size);\n-    scratch->offset[frame] += size;\n+    scratch->alloc_size += size;\n \n     return ret;\n }"
      },
      {
        "sha": "a3f446e507e20985d3d3d1f912f4a0203b44cc09",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 112,
        "deletions": 31,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -5,6 +5,7 @@\n  **********************************************************************/\n \n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n \n #include \"util.h\"\n #include \"num_impl.h\"\n@@ -26,28 +27,39 @@\n     } \\\n } while(0)\n \n-static void default_illegal_callback_fn(const char* str, void* data) {\n+#define ARG_CHECK_NO_RETURN(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n+    } \\\n+} while(0)\n+\n+#ifndef USE_EXTERNAL_DEFAULT_CALLBACKS\n+#include <stdlib.h>\n+#include <stdio.h>\n+static void secp256k1_default_illegal_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] illegal argument: %s\\n\", str);\n     abort();\n }\n-\n-static const secp256k1_callback default_illegal_callback = {\n-    default_illegal_callback_fn,\n-    NULL\n-};\n-\n-static void default_error_callback_fn(const char* str, void* data) {\n+static void secp256k1_default_error_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] internal consistency check failed: %s\\n\", str);\n     abort();\n }\n+#else\n+void secp256k1_default_illegal_callback_fn(const char* str, void* data);\n+void secp256k1_default_error_callback_fn(const char* str, void* data);\n+#endif\n \n-static const secp256k1_callback default_error_callback = {\n-    default_error_callback_fn,\n+static const secp256k1_callback default_illegal_callback = {\n+    secp256k1_default_illegal_callback_fn,\n     NULL\n };\n \n+static const secp256k1_callback default_error_callback = {\n+    secp256k1_default_error_callback_fn,\n+    NULL\n+};\n \n struct secp256k1_context_struct {\n     secp256k1_ecmult_context ecmult_ctx;\n@@ -59,68 +71,135 @@ struct secp256k1_context_struct {\n static const secp256k1_context secp256k1_context_no_precomp_ = {\n     { 0 },\n     { 0 },\n-    { default_illegal_callback_fn, 0 },\n-    { default_error_callback_fn, 0 }\n+    { secp256k1_default_illegal_callback_fn, 0 },\n+    { secp256k1_default_error_callback_fn, 0 }\n };\n const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n \n-secp256k1_context* secp256k1_context_create(unsigned int flags) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n+size_t secp256k1_context_preallocated_size(unsigned int flags) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+\n+    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n+            secp256k1_callback_call(&default_illegal_callback,\n+                                    \"Invalid flags\");\n+            return 0;\n+    }\n+\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    VERIFY_CHECK(ctx != NULL);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigned int flags) {\n+    void* const base = prealloc;\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+\n+    VERIFY_CHECK(prealloc != NULL);\n+    prealloc_size = secp256k1_context_preallocated_size(flags);\n+    ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&ret->illegal_callback,\n                                     \"Invalid flags\");\n-            free(ret);\n             return NULL;\n     }\n \n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n-        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &ret->error_callback);\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &ret->error_callback);\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n+    }\n+\n+    return (secp256k1_context*) ret;\n+}\n+\n+secp256k1_context* secp256k1_context_create(unsigned int flags) {\n+    size_t const prealloc_size = secp256k1_context_preallocated_size(flags);\n+    secp256k1_context* ctx = (secp256k1_context*)checked_malloc(&default_error_callback, prealloc_size);\n+    if (EXPECT(secp256k1_context_preallocated_create(ctx, flags) == NULL, 0)) {\n+        free(ctx);\n+        return NULL;\n     }\n \n+    return ctx;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context* ctx, void* prealloc) {\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prealloc != NULL);\n+\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)prealloc;\n+    memcpy(ret, ctx, prealloc_size);\n+    secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, sizeof(secp256k1_context));\n-    ret->illegal_callback = ctx->illegal_callback;\n-    ret->error_callback = ctx->error_callback;\n-    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx, &ctx->error_callback);\n-    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx, &ctx->error_callback);\n+    secp256k1_context* ret;\n+    size_t prealloc_size;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, prealloc_size);\n+    ret = secp256k1_context_preallocated_clone(ctx, ret);\n     return ret;\n }\n \n-void secp256k1_context_destroy(secp256k1_context* ctx) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+    }\n+}\n \n+void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    if (ctx != NULL) {\n+        secp256k1_context_preallocated_destroy(ctx);\n         free(ctx);\n     }\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_illegal_callback_fn;\n+        fun = secp256k1_default_illegal_callback_fn;\n     }\n     ctx->illegal_callback.fn = fun;\n     ctx->illegal_callback.data = data;\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_error_callback_fn;\n+        fun = secp256k1_default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n@@ -131,8 +210,9 @@ secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context*\n     return secp256k1_scratch_create(&ctx->error_callback, max_size);\n }\n \n-void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n-    secp256k1_scratch_destroy(scratch);\n+void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scratch_space* scratch) {\n+    VERIFY_CHECK(ctx != NULL);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n@@ -438,7 +518,7 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     ARG_CHECK(seckey != NULL);\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = (!overflow) & (!secp256k1_scalar_is_zero(&sec));\n+    ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n     if (ret) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n         secp256k1_ge_set_gej(&p, &pj);\n@@ -457,6 +537,7 @@ int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *sec\n     secp256k1_scalar_negate(&sec, &sec);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n+    secp256k1_scalar_clear(&sec);\n     return 1;\n }\n "
      },
      {
        "sha": "d408a5c30a48ac39114f952e5e86c54321a8c8f0",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 237,
        "deletions": 86,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"secp256k1.c\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n \n #ifdef ENABLE_OPENSSL_TESTS\n@@ -82,7 +83,9 @@ void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe_negate(&zero, &zero, 0);\n     secp256k1_fe_mul_int(&zero, n - 1);\n     secp256k1_fe_add(fe, &zero);\n-    VERIFY_CHECK(fe->magnitude == n);\n+#ifdef VERIFY\n+    CHECK(fe->magnitude == n);\n+#endif\n }\n \n void random_group_element_test(secp256k1_ge *ge) {\n@@ -137,23 +140,47 @@ void random_scalar_order(secp256k1_scalar *num) {\n     } while(1);\n }\n \n-void run_context_tests(void) {\n+void run_context_tests(int use_prealloc) {\n     secp256k1_pubkey pubkey;\n     secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n     int32_t ecount2;\n-    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n-    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n-    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n-    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *none;\n+    secp256k1_context *sign;\n+    secp256k1_context *vrfy;\n+    secp256k1_context *both;\n+    void *none_prealloc = NULL;\n+    void *sign_prealloc = NULL;\n+    void *vrfy_prealloc = NULL;\n+    void *both_prealloc = NULL;\n \n     secp256k1_gej pubj;\n     secp256k1_ge pub;\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    if (use_prealloc) {\n+        none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+        sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+        vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+        both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+        CHECK(none_prealloc != NULL);\n+        CHECK(sign_prealloc != NULL);\n+        CHECK(vrfy_prealloc != NULL);\n+        CHECK(both_prealloc != NULL);\n+        none = secp256k1_context_preallocated_create(none_prealloc, SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_preallocated_create(sign_prealloc, SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_preallocated_create(vrfy_prealloc, SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_preallocated_create(both_prealloc, SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    } else {\n+        none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    }\n+\n     memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n \n     ecount = 0;\n@@ -163,14 +190,57 @@ void run_context_tests(void) {\n     secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n     CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n \n+    /* check if sizes for cloning are consistent */\n+    CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+    CHECK(secp256k1_context_preallocated_clone_size(sign) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+    CHECK(secp256k1_context_preallocated_clone_size(vrfy) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+    CHECK(secp256k1_context_preallocated_clone_size(both) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+\n     /*** clone and destroy all of them to make sure cloning was complete ***/\n     {\n         secp256k1_context *ctx_tmp;\n \n-        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+        if (use_prealloc) {\n+            /* clone into a non-preallocated context and then again into a new preallocated one. */\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(none_prealloc); none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(none_prealloc != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, none_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(sign_prealloc); sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(sign_prealloc != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, sign_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(vrfy_prealloc); vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(vrfy_prealloc != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, vrfy_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(both_prealloc); both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(both_prealloc != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, both_prealloc); secp256k1_context_destroy(ctx_tmp);\n+        } else {\n+            /* clone into a preallocated context and then again into a new non-preallocated one. */\n+            void *prealloc_tmp;\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+        }\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n@@ -229,10 +299,6 @@ void run_context_tests(void) {\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n-    /* This shouldn't leak memory, due to already-set tests. */\n-    secp256k1_ecmult_gen_context_build(&sign->ecmult_gen_ctx, NULL);\n-    secp256k1_ecmult_context_build(&vrfy->ecmult_ctx, NULL);\n-\n     /* obtain a working nonce */\n     do {\n         random_scalar_order_test(&nonce);\n@@ -247,49 +313,95 @@ void run_context_tests(void) {\n     CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n-    secp256k1_context_destroy(none);\n-    secp256k1_context_destroy(sign);\n-    secp256k1_context_destroy(vrfy);\n-    secp256k1_context_destroy(both);\n+    if (use_prealloc) {\n+        secp256k1_context_preallocated_destroy(none);\n+        secp256k1_context_preallocated_destroy(sign);\n+        secp256k1_context_preallocated_destroy(vrfy);\n+        secp256k1_context_preallocated_destroy(both);\n+        free(none_prealloc);\n+        free(sign_prealloc);\n+        free(vrfy_prealloc);\n+        free(both_prealloc);\n+    } else {\n+        secp256k1_context_destroy(none);\n+        secp256k1_context_destroy(sign);\n+        secp256k1_context_destroy(vrfy);\n+        secp256k1_context_destroy(both);\n+    }\n     /* Defined as no-op. */\n     secp256k1_context_destroy(NULL);\n+    secp256k1_context_preallocated_destroy(NULL);\n+\n }\n \n void run_scratch_tests(void) {\n+    const size_t adj_alloc = ((500 + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n     int32_t ecount = 0;\n+    size_t checkpoint;\n+    size_t checkpoint_2;\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n     secp256k1_scratch_space *scratch;\n+    secp256k1_scratch_space local_scratch;\n \n     /* Test public API */\n     secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n \n     scratch = secp256k1_scratch_space_create(none, 1000);\n     CHECK(scratch != NULL);\n     CHECK(ecount == 0);\n \n     /* Test internal API */\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n-\n-    /* Allocating 500 bytes with no frame fails */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-\n-    /* ...but pushing a new stack frame does affect the max allocation */\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating 500 bytes succeeds */\n+    checkpoint = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating another 500 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* ...but it succeeds once we apply the checkpoint to undo it */\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(scratch->alloc_size != 0);\n+\n+    /* try to apply a bad checkpoint */\n+    checkpoint_2 = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(ecount == 0);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint_2); /* checkpoint_2 is after checkpoint */\n+    CHECK(ecount == 1);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, (size_t) -1); /* this is just wildly invalid */\n+    CHECK(ecount == 2);\n \n-    /* ...and this effect is undone by popping the frame */\n-    secp256k1_scratch_deallocate_frame(scratch);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    /* try to use badly initialized scratch space */\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    memset(&local_scratch, 0, sizeof(local_scratch));\n+    scratch = &local_scratch;\n+    CHECK(!secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0));\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(ecount == 4);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    CHECK(ecount == 5);\n \n     /* cleanup */\n-    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n }\n \n@@ -1709,24 +1821,32 @@ void run_field_misc(void) {\n         /* Test fe conditional move; z is not normalized here. */\n         q = x;\n         secp256k1_fe_cmov(&x, &z, 0);\n-        VERIFY_CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#endif\n         secp256k1_fe_cmov(&x, &x, 1);\n         CHECK(fe_memcmp(&x, &z) != 0);\n         CHECK(fe_memcmp(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n-        VERIFY_CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#endif\n         CHECK(fe_memcmp(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_normalize_var(&q);\n         secp256k1_fe_cmov(&q, &z, (i&1));\n-        VERIFY_CHECK(q.normalized && q.magnitude == 1);\n+#ifdef VERIFY\n+        CHECK(q.normalized && q.magnitude == 1);\n+#endif\n         for (j = 0; j < 6; j++) {\n             secp256k1_fe_negate(&z, &z, j+1);\n             secp256k1_fe_normalize_var(&q);\n             secp256k1_fe_cmov(&q, &z, (j&1));\n-            VERIFY_CHECK(!q.normalized && q.magnitude == (j+2));\n+#ifdef VERIFY\n+            CHECK(!q.normalized && q.magnitude == (j+2));\n+#endif\n         }\n         secp256k1_fe_normalize_var(&z);\n         /* Test storage conversion and conditional moves. */\n@@ -2120,7 +2240,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinitiy */\n+        /* randomly set half the points to infinity */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -2572,14 +2692,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_gej r;\n     secp256k1_gej r2;\n     ecmult_multi_data data;\n-    secp256k1_scratch *scratch_empty;\n \n     data.sc = sc;\n     data.pt = pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -2595,36 +2714,31 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         /* only G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n-        /* Try to multiply 1 point, but scratch space is empty */\n-        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n-        secp256k1_scratch_destroy(scratch_empty);\n-\n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2641,7 +2755,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2651,7 +2765,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2664,7 +2778,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -2677,7 +2791,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2692,7 +2806,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -2711,7 +2825,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2734,7 +2848,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2747,13 +2861,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -2798,7 +2912,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n                         secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -2809,6 +2923,24 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n }\n \n+void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Try to multiply 1 point, but scratch space is empty.*/\n+    scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n+}\n+\n void test_secp256k1_pippenger_bucket_window_inv(void) {\n     int i;\n \n@@ -2839,17 +2971,27 @@ void test_ecmult_multi_pippenger_max_points(void) {\n     int bucket_window = 0;\n \n     for(; scratch_size < max_size; scratch_size+=256) {\n+        size_t i;\n+        size_t total_alloc;\n+        size_t checkpoint;\n         scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n         CHECK(scratch != NULL);\n-        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        checkpoint = secp256k1_scratch_checkpoint(&ctx->error_callback, scratch);\n+        n_points_supported = secp256k1_pippenger_max_points(&ctx->error_callback, scratch);\n         if (n_points_supported == 0) {\n-            secp256k1_scratch_destroy(scratch);\n+            secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n             continue;\n         }\n         bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n-        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n-        secp256k1_scratch_deallocate_frame(scratch);\n-        secp256k1_scratch_destroy(scratch);\n+        /* allocate `total_alloc` bytes over `PIPPENGER_SCRATCH_OBJECTS` many allocations */\n+        total_alloc = secp256k1_pippenger_scratch_size(n_points_supported, bucket_window);\n+        for (i = 0; i < PIPPENGER_SCRATCH_OBJECTS - 1; i++) {\n+            CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, 1));\n+            total_alloc--;\n+        }\n+        CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, total_alloc));\n+        secp256k1_scratch_apply_checkpoint(&ctx->error_callback, scratch, checkpoint);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n }\n@@ -2932,19 +3074,25 @@ void test_ecmult_multi_batching(void) {\n     }\n     data.sc = sc;\n     data.pt = pt;\n+    secp256k1_gej_neg(&r2, &r2);\n \n-    /* Test with empty scratch space */\n+    /* Test with empty scratch space. It should compute the correct result using \n+     * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Test with space for 1 point in pippenger. That's not enough because\n-     * ecmult_multi selects strauss which requires more memory. */\n+     * ecmult_multi selects strauss which requires more memory. It should\n+     * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n-    secp256k1_gej_neg(&r2, &r2);\n     for(i = 1; i <= n_points; i++) {\n         if (i > ECMULT_PIPPENGER_THRESHOLD) {\n             int bucket_window = secp256k1_pippenger_bucket_window(i);\n@@ -2954,10 +3102,10 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n-        secp256k1_scratch_destroy(scratch);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     free(sc);\n     free(pt);\n@@ -2972,13 +3120,15 @@ void run_ecmult_multi_tests(void) {\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_pippenger_batch_single);\n     test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n-    secp256k1_scratch_destroy(scratch);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Run test_ecmult_multi with space for exactly one point */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     test_ecmult_multi_batch_size_helper();\n     test_ecmult_multi_batching();\n@@ -3050,7 +3200,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     }\n     bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n+    skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -4315,7 +4465,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0) << 14;\n+        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4356,7 +4506,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -5030,7 +5180,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if (sscanf(ch, \"%2hx\", &sh)) {\n+            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5062,7 +5212,8 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    run_context_tests();\n+    run_context_tests(0);\n+    run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {"
      },
      {
        "sha": "b44e357cb69c742b1eccb94695412960c82e6385",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -212,14 +212,14 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n                     }\n                 }\n             }\n         }\n     }\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {"
      },
      {
        "sha": "9deb61bc59d153c987ecc3a8fdca91962344e591",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78fb58d0b5cb58e6679df155acf7e0861bc05b2e/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "patch": "@@ -84,6 +84,47 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n     return ret;\n }\n \n+#if defined(__BIGGEST_ALIGNMENT__)\n+#define ALIGNMENT __BIGGEST_ALIGNMENT__\n+#else\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes. */\n+#define ALIGNMENT 16\n+#endif\n+\n+#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+\n+/* Assume there is a contiguous memory object with bounds [base, base + max_size)\n+ * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n+ * where *prealloc_ptr is an aligned pointer. In that setting, this functions\n+ * reserves the subobject [*prealloc_ptr, *prealloc_ptr + alloc_size) of\n+ * alloc_size bytes by increasing *prealloc_ptr accordingly, taking into account\n+ * alignment requirements.\n+ *\n+ * The function returns an aligned pointer to the newly allocated subobject.\n+ *\n+ * This is useful for manual memory management: if we're simply given a block\n+ * [base, base + max_size), the caller can use this function to allocate memory\n+ * in this block and keep track of the current allocation state with *prealloc_ptr.\n+ *\n+ * It is VERIFY_CHECKed that there is enough space left in the memory object and\n+ * *prealloc_ptr is aligned relative to base.\n+ */\n+static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_size, void* base, size_t max_size) {\n+    size_t aligned_alloc_size = ROUND_TO_ALIGN(alloc_size);\n+    void* ret;\n+    VERIFY_CHECK(prealloc_ptr != NULL);\n+    VERIFY_CHECK(*prealloc_ptr != NULL);\n+    VERIFY_CHECK(base != NULL);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n+    VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    ret = *prealloc_ptr;\n+    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT"
      }
    ]
  },
  {
    "sha": "69b0efd59feca9b50412d090c16e06bc7a244e6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OWIwZWZkNTlmZWNhOWI1MDQxMmQwOTBjMTZlMDZiYzdhMjQ0ZTZk",
    "commit": {
      "author": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:05:42Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:05:42Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from e729cc7f5..a228e2f54\n\na228e2f54 Add schnorrsig module which implements BIP-schnorr [0] compatible signing, verification and batch verification.\nf129809a6 add chacha20 function\nREVERT: e729cc7f5 Merge #657: Fix a nit in the recovery tests\nREVERT: b64a2e259 Fix a nit in the recovery tests\nREVERT: e028aa33d Merge #650: secp256k1/src/tests.c:  Properly handle sscanf return value\nREVERT: f1e11d363 Merge #654: Fix typo (\u221e)\nREVERT: ef83281c3 Merge pull request #656 from real-or-random/patch-1\nREVERT: 556caad2c Fix typo in docs for _context_set_illegal_callback\nREVERT: 786dfb49f Merge #583: JNI: fix use sig array\nREVERT: e95f8ab09 Merge #644: Avoid optimizing out a verify_check\nREVERT: 384f55606 Merge #652: README.md: update instruction to run tests\nREVERT: ee56accd4 Merge #651: Fix typo in secp256k1_preallocated.h\nREVERT: 7b9b11723 Merge #640: scalar_impl.h: fix includes\nREVERT: d99bec2e2 Merge #655: jni: Use only Guava for hex encoding and decoding\nREVERT: 2abcf951a jni: Use only Guava for hex encoding and decoding\nREVERT: 271582b3b Fix typo\nREVERT: ce6d43826 README.md: update instruction to run tests\nREVERT: b1e68cb8e Fix typo in secp256k1_preallocated.h\nREVERT: a11c76c59 secp256k1/src/tests.c:  Properly handle sscanf return value\nREVERT: 94ae7cbf8 Moved a dereference so the null check will be before the dereferencing\nREVERT: 2cb73b106 scalar_impl.h: fix includes\nREVERT: fa3301713 Merge #634: Add a descriptive comment for secp256k1_ecmult_const.\nREVERT: ee9e68cd3 Add a descriptive comment for secp256k1_ecmult_const.\nREVERT: d0d738d32 Merge #631: typo in comment for secp256k1_ec_pubkey_tweak_mul ()\nREVERT: 6914c2527 typo in comment for secp256k1_ec_pubkey_tweak_mul ()\nREVERT: 74e2dbd68 JNI: fix use sig array\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: a228e2f54d64692230ccb2937b12dd746c5157ed",
      "tree": {
        "sha": "a529aa422bc81b4573451ad1cea9ab966f6f39ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a529aa422bc81b4573451ad1cea9ab966f6f39ac"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69b0efd59feca9b50412d090c16e06bc7a244e6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69b0efd59feca9b50412d090c16e06bc7a244e6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/69b0efd59feca9b50412d090c16e06bc7a244e6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69b0efd59feca9b50412d090c16e06bc7a244e6d/comments",
    "author": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "461acf5c6c39610c55988eed7a50922aed732ded",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/461acf5c6c39610c55988eed7a50922aed732ded",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/461acf5c6c39610c55988eed7a50922aed732ded"
      }
    ],
    "stats": {
      "total": 1749,
      "additions": 1714,
      "deletions": 35
    },
    "files": [
      {
        "sha": "905be987305af82722e0831ce8f7b68c6f512dda",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -1,9 +1,9 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n-bench_schnorr_verify\n bench_recover\n bench_internal\n tests"
      },
      {
        "sha": "9e9fd6f214e4ae37f6af4a6d93e530066787bb11",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -11,20 +11,20 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no SCHNORRSIG=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes   SCHNORRSIG=yes\n     - SCALAR=64bit\n-    - FIELD=64bit     RECOVERY=yes\n+    - FIELD=64bit     RECOVERY=yes      EXPERIMENTAL=yes             SCHNORRSIG=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes    SCHNORRSIG=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n@@ -65,4 +65,4 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-module-schnorrsig=$SCHNORRSIG --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD"
      },
      {
        "sha": "1d985c17e130a276214a6ed3025346ab1ad374c7",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -178,6 +178,10 @@ if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n endif\n \n+if ENABLE_MODULE_SCHNORRSIG\n+include src/modules/schnorrsig/Makefile.am.include\n+endif\n+\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif"
      },
      {
        "sha": "1c66d712d4d6e789599d012cca4edd29ff2423e0",
        "filename": "README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -59,5 +59,5 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ make check\n+    $ ./tests\n     $ sudo make install  # optional"
      },
      {
        "sha": "3c21169e3f0b570ddaf880111d277d0d6dd0af7b",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -129,6 +129,11 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n+AC_ARG_ENABLE(module_schnorrsig,\n+    AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module (experimental)]),\n+    [enable_module_schnorrsig=$enableval],\n+    [enable_module_schnorrsig=no])\n+\n AC_ARG_ENABLE(module_recovery,\n     AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n@@ -488,6 +493,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n \n+if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_SCHNORRSIG, 1, [Define this symbol to enable the schnorrsig module])\n+fi\n+\n if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n@@ -507,11 +516,15 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([WARNING: experimental build])\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building schnorrsig module: $enable_module_schnorrsig])\n   AC_MSG_NOTICE([******])\n else\n   if test x\"$enable_module_ecdh\" = x\"yes\"; then\n     AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n   fi\n+  if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+    AC_MSG_ERROR([schnorrsig module is experimental. Use --enable-experimental to allow.])\n+  fi\n   if test x\"$set_asm\" = x\"arm\"; then\n     AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -530,6 +543,7 @@ AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n@@ -552,6 +566,7 @@ echo \"  with benchmarks         = $use_benchmark\"\n echo \"  with coverage           = $enable_coverage\"\n echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\"\n+echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  bignum                  = $set_bignum\""
      },
      {
        "sha": "5988b14193b563c87b493720e16313c6f8a8b15f",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -258,7 +258,7 @@ SECP256K1_API void secp256k1_context_destroy(\n  *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n  *  The library can call these default handlers even before a proper callback data\n  *  pointer could have been set using secp256k1_context_set_illegal_callback or\n- *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  secp256k1_context_set_illegal_callback, e.g., when the creation of a context\n  *  fails. In this case, the corresponding default handler will be called with\n  *  the data pointer argument set to NULL.\n  *\n@@ -523,6 +523,12 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.\n+ * If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ * extra entropy.\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_bipschnorr;\n+\n /** A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979). */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_default;\n \n@@ -646,7 +652,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n  * Args:    ctx:    pointer to a context object initialized for validation\n  *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key object.\n+ * In/Out:  pubkey: pointer to a public key obkect.\n  * In:      tweak:  pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul("
      },
      {
        "sha": "0fb64a5431f8a977a577812c44441d87f577f311",
        "filename": "include/secp256k1_preallocated.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_preallocated.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -14,12 +14,12 @@ extern \"C\" {\n  *\n  * Context objects created by functions in this module can be used like contexts\n  * objects created by functions in secp256k1.h, i.e., they can be passed to any\n- * API function that expects a context object (see secp256k1.h for details). The\n+ * API function that excepts a context object (see secp256k1.h for details). The\n  * only exception is that context objects created by functions in this module\n  * must be destroyed using secp256k1_context_preallocated_destroy (in this\n  * module) instead of secp256k1_context_destroy (in secp256k1.h).\n  *\n- * It is guaranteed that functions in this module will not call malloc or its\n+ * It is guaranteed that functions in by this module will not call malloc or its\n  * friends realloc, calloc, and free.\n  */\n "
      },
      {
        "sha": "77a9f0bc95d66fd70050d176803f97a9d7c6e27d",
        "filename": "include/secp256k1_schnorrsig.h",
        "status": "added",
        "additions": 126,
        "deletions": 0,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorrsig.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to a public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures.\n+ *\n+ * Returns 1 if all succeeded, 0 otherwise. In particular, returns 1 if n_sigs is 0.\n+ *\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *       scratch: scratch space used for the multiexponentiation\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays. Must be smaller than\n+ *                2^31 and smaller than half the maximum size_t value. Must be 0\n+ *                if above arrays are NULL.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify_batch(\n+    const secp256k1_context* ctx,\n+    secp256k1_scratch_space *scratch,\n+    const secp256k1_schnorrsig *const *sig,\n+    const unsigned char *const *msg32,\n+    const secp256k1_pubkey *const *pk,\n+    size_t n_sigs\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_SCHNORRSIG_H */"
      },
      {
        "sha": "b68adf53123aedb605dcede1904586237d38615b",
        "filename": "src/bench_schnorrsig.c",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_schnorrsig.c?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * sizeof(unsigned char *));\n+    data.msgs = (const unsigned char **)malloc(MAX_SIGS * sizeof(unsigned char *));\n+    data.sigs = (const secp256k1_schnorrsig **)malloc(MAX_SIGS * sizeof(secp256k1_schnorrsig *));\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = (unsigned char *)malloc(32);\n+        secp256k1_schnorrsig *sig = (secp256k1_schnorrsig *)malloc(sizeof(*sig));\n+        unsigned char *pk_char = (unsigned char *)malloc(33);\n+        secp256k1_pubkey pk;\n+        size_t pk_len = 33;\n+        msg[0] = sk[0] = i;\n+        msg[1] = sk[1] = i >> 8;\n+        msg[2] = sk[2] = i >> 16;\n+        msg[3] = sk[3] = i >> 24;\n+        memset(&msg[4], 'm', 28);\n+        memset(&sk[4], 's', 28);\n+\n+        data.pk[i] = pk_char;\n+        data.msgs[i] = msg;\n+        data.sigs[i] = sig;\n+\n+        CHECK(secp256k1_ec_pubkey_create(data.ctx, &pk, sk));\n+        CHECK(secp256k1_ec_pubkey_serialize(data.ctx, pk_char, &pk_len, &pk, SECP256K1_EC_COMPRESSED) == 1);\n+        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, sk, NULL, NULL));\n+    }\n+\n+    run_benchmark(\"schnorrsig_sign\", bench_schnorrsig_sign, NULL, NULL, (void *) &data, 10, 1000);\n+    run_benchmark(\"schnorrsig_verify\", bench_schnorrsig_verify, NULL, NULL, (void *) &data, 10, 1000);\n+    for (i = 1; i <= MAX_SIGS; i *= 2) {\n+        char name[64];\n+        sprintf(name, \"schnorrsig_batch_verify_%d\", (int) i);\n+\n+        data.n = i;\n+        run_benchmark(name, bench_schnorrsig_verify_n, NULL, NULL, (void *) &data, 3, MAX_SIGS);\n+    }\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        free((void *)data.pk[i]);\n+        free((void *)data.msgs[i]);\n+        free((void *)data.sigs[i]);\n+    }\n+    free(data.pk);\n+    free(data.msgs);\n+    free(data.sigs);\n+\n+    secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n+    secp256k1_context_destroy(data.ctx);\n+    return 0;\n+}"
      },
      {
        "sha": "d4804b8b68faa3ce5944e1695ec5eda3d5db3cab",
        "filename": "src/ecmult_const.h",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -10,11 +10,8 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/**\n- * Multiply: R = q*A (in constant-time)\n- * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion.\n- */\n+/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "bb7adedfb1f0dbf0386c951aef0acd885b223fd5",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -395,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s;\n+    secp256k1_scalar s = *a;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -408,7 +408,6 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n-    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;"
      },
      {
        "sha": "d766a1029ce389a73207431bdf7c0376b1fc6e35",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -3,6 +3,7 @@\n import com.google.common.io.BaseEncoding;\n import java.util.Arrays;\n import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n@@ -69,7 +70,7 @@ public static void testPubKeyCreatePos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = BaseEncoding.base16().encode(resultArr);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n     }\n \n@@ -80,7 +81,7 @@ public static void testPubKeyCreateNeg() throws AssertFailException{\n        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = BaseEncoding.base16().encode(resultArr);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n        assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n     }\n \n@@ -93,7 +94,7 @@ public static void testSignPos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n     }\n \n@@ -105,7 +106,7 @@ public static void testSignNeg() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString, \"\" , \"testSignNeg\");\n     }\n \n@@ -117,7 +118,7 @@ public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n     }\n \n@@ -129,7 +130,7 @@ public static void testPrivKeyTweakMul_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n     }\n \n@@ -141,7 +142,7 @@ public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n     }\n \n@@ -153,7 +154,7 @@ public static void testPrivKeyTweakMul_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n     }\n \n@@ -172,7 +173,7 @@ public static void testCreateECDHSecret() throws AssertFailException{\n         byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = BaseEncoding.base16().encode(resultArr);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n     }\n "
      },
      {
        "sha": "b50970b4f24c8cd3480368aab34a9d83df92fe1b",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -81,15 +81,15 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n   jbyteArray sigArray, intsByteArray;\n   unsigned char intsarray[2];\n \n-  secp256k1_ecdsa_signature sig;\n+  secp256k1_ecdsa_signature sig[72];\n \n-  int ret = secp256k1_ecdsa_sign(ctx, &sig, data, secKey, NULL, NULL);\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n \n   if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, &sig ); (void)ret2;\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n   }\n \n   intsarray[0] = outputLen;"
      },
      {
        "sha": "5c9bbe86101c9f59bf288019c2923fe6c5019b0e",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 1. */\n+         * and secret key 0 (which is not valid), resulting in recid 0. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "a82bafe43fda64027b97a8e4d66dac35b4a3e96e",
        "filename": "src/modules/schnorrsig/Makefile.am.include",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/schnorrsig/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/schnorrsig/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/Makefile.am.include?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_schnorrsig.h\n+noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_schnorrsig\n+bench_schnorrsig_SOURCES = src/bench_schnorrsig.c\n+bench_schnorrsig_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif"
      },
      {
        "sha": "739e98b0c3461a4d0733f49b91af4af1ba6f29d6",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "added",
        "additions": 332,
        "deletions": 0,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -0,0 +1,332 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. The very first randomizer will be set to 1 and\n+     * the PRNG is called at every odd indexed schnorrsig to fill the cache. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 2) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called with 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_scalar_chacha20(&ecmult_context->randomizer_cache[0], &ecmult_context->randomizer_cache[1], ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        *sc = ecmult_context->randomizer_cache[(idx / 2) % 2];\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+static int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, buflen);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.\n+ *\n+ *  In/Out: s: the s part of the input sigs is added to this s argument\n+ *  In:  chacha_seed: PRNG seed for computing randomizers\n+ *        sig: array of signatures, or NULL if there are no signatures\n+ *     n_sigs: number of signatures in above array (must be 0 if they are NULL)\n+ */\n+static int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_scalar *s, unsigned char *chacha_seed, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    secp256k1_scalar randomizer_cache[2];\n+    size_t i;\n+\n+    secp256k1_scalar_set_int(&randomizer_cache[0], 1);\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 1) {\n+            secp256k1_scalar_chacha20(&randomizer_cache[0], &randomizer_cache[1], chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != -(s1 + a2*s2 + ... + au*su)G + R1 + a2*R2 + ... + au*Ru + e1*P1 + (a2*e2)P2 + ... + (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+    /* Check that n_sigs is less than half of the maximum size_t value. This is necessary because\n+     * the number of points given to ecmult_multi is 2*n_sigs. */\n+    ARG_CHECK(n_sigs <= SIZE_MAX / 2);\n+    /* Check that n_sigs is less than 2^31 to ensure the same behavior of this function on 32-bit\n+     * and 64-bit platforms. */\n+    ARG_CHECK(n_sigs < ((uint32_t)1 << 31));\n+\n+    secp256k1_sha256_initialize(&sha);\n+    if (!secp256k1_schnorrsig_verify_batch_init_randomizer(ctx, &ecmult_context, &sha, sig, msg32, pk, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_sha256_finalize(&sha, ecmult_context.chacha_seed);\n+    secp256k1_scalar_set_int(&ecmult_context.randomizer_cache[0], 1);\n+\n+    secp256k1_scalar_clear(&s);\n+    if (!secp256k1_schnorrsig_verify_batch_sum_s(&s, ecmult_context.chacha_seed, sig, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_negate(&s, &s);\n+\n+    return secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &rj, &s, secp256k1_schnorrsig_verify_batch_ecmult_callback, (void *) &ecmult_context, 2 * n_sigs)\n+            && secp256k1_gej_is_infinity(&rj);\n+}\n+\n+#endif"
      },
      {
        "sha": "2de43af1e33b646a3c9445f7378e5532fea44e33",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "added",
        "additions": 721,
        "deletions": 0,
        "changes": 721,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -0,0 +1,721 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+void test_schnorrsig_serialize(void) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char in[64];\n+    unsigned char out[64];\n+\n+    memset(in, 0x12, 64);\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, in));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, out, &sig));\n+    CHECK(memcmp(in, out, 64) == 0);\n+}\n+\n+void test_schnorrsig_api(secp256k1_scratch_space *scratch) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    unsigned char sig64[64];\n+    secp256k1_pubkey pk[3];\n+    secp256k1_schnorrsig sig;\n+    const secp256k1_schnorrsig *sigptr = &sig;\n+    const unsigned char *msgptr = msg;\n+    const secp256k1_pubkey *pkptr = &pk[0];\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk1) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[1], sk2) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[2], sk3) == 1);\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, &sig, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, &sig, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, NULL, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, &sig) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_serialize(none, NULL, &sig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, sig64) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, NULL, sig64) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, NULL) == 0);\n+    CHECK(ecount == 4);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify_batch(none, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify_batch(sign, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, NULL, NULL, 0) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, NULL, &pkptr, 1) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, NULL, 1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (size_t)1 << (sizeof(size_t)*8-1)) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (uint32_t)1 << 31) == 0);\n+    CHECK(ecount == 7);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *msg, const unsigned char *expected_sig) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char serialized_sig[64];\n+    secp256k1_pubkey pk;\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, NULL, NULL));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, serialized_sig, &sig));\n+    CHECK(memcmp(serialized_sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, &sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(secp256k1_scratch_space *scratch, const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig_serialized, int expected) {\n+    const unsigned char *msg_arr[1];\n+    const secp256k1_schnorrsig *sig_arr[1];\n+    const secp256k1_pubkey *pk_arr[1];\n+    secp256k1_pubkey pk;\n+    secp256k1_schnorrsig sig;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, sig_serialized));\n+\n+    sig_arr[0] = &sig;\n+    msg_arr[0] = msg32;\n+    pk_arr[0] = &pk;\n+\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, &sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+}\n+\n+/* Test vectors according to BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/7f6a73e53c8bbcf2d008ea0546f76433e22094a8/bip-schnorr/test-vectors.csv).\n+ */\n+void test_schnorrsig_bip_vectors(secp256k1_scratch_space *scratch) {\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char pk1[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig1[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x70, 0x31, 0xA9, 0x88, 0x31, 0x85, 0x9D, 0xC3,\n+            0x4D, 0xFF, 0xEE, 0xDD, 0xA8, 0x68, 0x31, 0x84,\n+            0x2C, 0xCD, 0x00, 0x79, 0xE1, 0xF9, 0x2A, 0xF1,\n+            0x77, 0xF7, 0xF2, 0x2C, 0xC1, 0xDC, 0xED, 0x05\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk1, pk1, msg1, sig1);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk1, msg1, sig1, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk2[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk2[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg2[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig2[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk2, pk2, msg2, sig2);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk2, msg2, sig2, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk3[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC7\n+        };\n+        const unsigned char pk3[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg3[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig3[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0x00, 0x88, 0x03, 0x71, 0xD0, 0x17, 0x66, 0x93,\n+            0x5B, 0x92, 0xD2, 0xAB, 0x4C, 0xD5, 0xC8, 0xA2,\n+            0xA5, 0x83, 0x7E, 0xC5, 0x7F, 0xED, 0x76, 0x60,\n+            0x77, 0x3A, 0x05, 0xF0, 0xDE, 0x14, 0x23, 0x80\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk3, pk3, msg3, sig3);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk3, msg3, sig3, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk4[33] = {\n+            0x03, 0xDE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        const unsigned char msg4[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig4[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x02, 0xA8, 0xDC, 0x32, 0xE6, 0x4E, 0x86, 0xA3,\n+            0x33, 0xF2, 0x0E, 0xF5, 0x6E, 0xAC, 0x9B, 0xA3,\n+            0x0B, 0x72, 0x46, 0xD6, 0xD2, 0x5E, 0x22, 0xAD,\n+            0xB8, 0xC6, 0xBE, 0x1A, 0xEB, 0x08, 0xD4, 0x9D\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4, msg4, sig4, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk5[33] = {\n+            0x03, 0x1B, 0x84, 0xC5, 0x56, 0x7B, 0x12, 0x64,\n+            0x40, 0x99, 0x5D, 0x3E, 0xD5, 0xAA, 0xBA, 0x05,\n+            0x65, 0xD7, 0x1E, 0x18, 0x34, 0x60, 0x48, 0x19,\n+            0xFF, 0x9C, 0x17, 0xF5, 0xE9, 0xD5, 0xDD, 0x07,\n+            0x8F\n+        };\n+        const unsigned char msg5[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig5[64] = {\n+            0x52, 0x81, 0x85, 0x79, 0xAC, 0xA5, 0x97, 0x67,\n+            0xE3, 0x29, 0x1D, 0x91, 0xB7, 0x6B, 0x63, 0x7B,\n+            0xEF, 0x06, 0x20, 0x83, 0x28, 0x49, 0x92, 0xF2,\n+            0xD9, 0x5F, 0x56, 0x4C, 0xA6, 0xCB, 0x4E, 0x35,\n+            0x30, 0xB1, 0xDA, 0x84, 0x9C, 0x8E, 0x83, 0x04,\n+            0xAD, 0xC0, 0xCF, 0xE8, 0x70, 0x66, 0x03, 0x34,\n+            0xB3, 0xCF, 0xC1, 0x8E, 0x82, 0x5E, 0xF1, 0xDB,\n+            0x34, 0xCF, 0xAE, 0x3D, 0xFC, 0x5D, 0x81, 0x87\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk5, msg5, sig5, 1);\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk6[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg6[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+        };\n+        const unsigned char sig6[64] = {\n+            0x57, 0x0D, 0xD4, 0xCA, 0x83, 0xD4, 0xE6, 0x31,\n+            0x7B, 0x8E, 0xE6, 0xBA, 0xE8, 0x34, 0x67, 0xA1,\n+            0xBF, 0x41, 0x9D, 0x07, 0x67, 0x12, 0x2D, 0xE4,\n+            0x09, 0x39, 0x44, 0x14, 0xB0, 0x50, 0x80, 0xDC,\n+            0xE9, 0xEE, 0x5F, 0x23, 0x7C, 0xBD, 0x10, 0x8E,\n+            0xAB, 0xAE, 0x1E, 0x37, 0x75, 0x9A, 0xE4, 0x7F,\n+            0x8E, 0x42, 0x03, 0xDA, 0x35, 0x32, 0xEB, 0x28,\n+            0xDB, 0x86, 0x0F, 0x33, 0xD6, 0x2D, 0x49, 0xBD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk6, msg6, sig6, 1);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk7[33] = {\n+            0x03, 0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        secp256k1_pubkey pk7_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_ec_pubkey_parse(ctx, &pk7_parsed, pk7, 33));\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk8[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg8[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig8[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFA, 0x16, 0xAE, 0xE0, 0x66, 0x09, 0x28, 0x0A,\n+            0x19, 0xB6, 0x7A, 0x24, 0xE1, 0x97, 0x7E, 0x46,\n+            0x97, 0x71, 0x2B, 0x5F, 0xD2, 0x94, 0x39, 0x14,\n+            0xEC, 0xD5, 0xF7, 0x30, 0x90, 0x1B, 0x4A, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk8, msg8, sig8, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk9[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg9[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig9[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0xD0, 0x92, 0xF9, 0xD8, 0x60, 0xF1, 0x77, 0x6A,\n+            0x1F, 0x74, 0x12, 0xAD, 0x8A, 0x1E, 0xB5, 0x0D,\n+            0xAC, 0xCC, 0x22, 0x2B, 0xC8, 0xC0, 0xE2, 0x6B,\n+            0x20, 0x56, 0xDF, 0x2F, 0x27, 0x3E, 0xFD, 0xEC\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk9, msg9, sig9, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk10[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg10[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig10[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x8F, 0xCE, 0x56, 0x77, 0xCE, 0x7A, 0x62, 0x3C,\n+            0xB2, 0x00, 0x11, 0x22, 0x57, 0x97, 0xCE, 0x7A,\n+            0x8D, 0xE1, 0xDC, 0x6C, 0xCD, 0x4F, 0x75, 0x4A,\n+            0x47, 0xDA, 0x6C, 0x60, 0x0E, 0x59, 0x54, 0x3C\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk10, msg10, sig10, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk11[33] = {\n+            0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg11[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig11[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk11, msg11, sig11, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk12[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg12[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig12[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x9E, 0x9D, 0x01, 0xAF, 0x98, 0x8B, 0x5C, 0xED,\n+            0xCE, 0x47, 0x22, 0x1B, 0xFA, 0x9B, 0x22, 0x27,\n+            0x21, 0xF3, 0xFA, 0x40, 0x89, 0x15, 0x44, 0x4A,\n+            0x4B, 0x48, 0x90, 0x21, 0xDB, 0x55, 0x77, 0x5F\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk12, msg12, sig12, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk13[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg13[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig13[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xD3, 0x7D, 0xDF, 0x02, 0x54, 0x35, 0x18, 0x36,\n+            0xD8, 0x4B, 0x1B, 0xD6, 0xA7, 0x95, 0xFD, 0x5D,\n+            0x52, 0x30, 0x48, 0xF2, 0x98, 0xC4, 0x21, 0x4D,\n+            0x18, 0x7F, 0xE4, 0x89, 0x29, 0x47, 0xF7, 0x28\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk13, msg13, sig13, 0);\n+    }\n+    {\n+        /* Test vector 14 */\n+        const unsigned char pk14[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg14[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x14, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig14[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk14, msg14, sig14, 0);\n+    }\n+    {\n+        /* Test vector 15 */\n+        const unsigned char pk15[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg15[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig15[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk15, msg15, sig15, 0);\n+    }\n+    {\n+        /* Test vector 16 */\n+        const unsigned char pk16[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg16[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig16[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk16, msg16, sig16, 0);\n+    }\n+}\n+\n+/* Nonce function that returns constant 0 */\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+    (void) counter;\n+    (void) nonce32;\n+    return 0;\n+}\n+\n+/* Nonce function that sets nonce to 0 */\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+    (void) counter;\n+\n+    memset(nonce32, 0, 32);\n+    return 1;\n+}\n+\n+void test_schnorrsig_sign(void) {\n+    unsigned char sk[32];\n+    const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n+    secp256k1_schnorrsig sig;\n+\n+    memset(sk, 23, sizeof(sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, NULL, NULL) == 1);\n+\n+    /* Overflowing secret key */\n+    memset(sk, 0xFF, sizeof(sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, NULL, NULL) == 0);\n+    memset(sk, 23, sizeof(sk));\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, nonce_function_failing, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, nonce_function_0, NULL) == 0);\n+}\n+\n+#define N_SIGS  200\n+/* Creates N_SIGS valid signatures and verifies them with verify and verify_batch. Then flips some\n+ * bits and checks that verification now fails. */\n+void test_schnorrsig_sign_verify(secp256k1_scratch_space *scratch) {\n+    const unsigned char sk[32] = \"shhhhhhhh! this key is a secret.\";\n+    unsigned char msg[N_SIGS][32];\n+    secp256k1_schnorrsig sig[N_SIGS];\n+    size_t i;\n+    const secp256k1_schnorrsig *sig_arr[N_SIGS];\n+    const unsigned char *msg_arr[N_SIGS];\n+    const secp256k1_pubkey *pk_arr[N_SIGS];\n+    secp256k1_pubkey pk;\n+\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk));\n+\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, NULL, NULL, NULL, 0));\n+\n+    for (i = 0; i < N_SIGS; i++) {\n+        secp256k1_rand256(msg[i]);\n+        CHECK(secp256k1_schnorrsig_sign(ctx, &sig[i], msg[i], sk, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, &sig[i], msg[i], &pk));\n+        sig_arr[i] = &sig[i];\n+        msg_arr[i] = msg[i];\n+        pk_arr[i] = &pk;\n+    }\n+\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 2));\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, N_SIGS));\n+\n+    {\n+        /* Flip a few bits in the signature and in the message and check that\n+         * verify and verify_batch fail */\n+        size_t sig_idx = secp256k1_rand_int(4);\n+        size_t byte_idx = secp256k1_rand_int(32);\n+        unsigned char xorbyte = secp256k1_rand_int(254)+1;\n+        sig[sig_idx].data[byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+        sig[sig_idx].data[byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        sig[sig_idx].data[32+byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+        sig[sig_idx].data[32+byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+\n+        /* Check that above bitflips have been reversed correctly */\n+        CHECK(secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+    }\n+}\n+#undef N_SIGS\n+\n+void run_schnorrsig_tests(void) {\n+    secp256k1_scratch_space *scratch = secp256k1_scratch_space_create(ctx, 1024 * 1024);\n+\n+    test_schnorrsig_serialize();\n+    test_schnorrsig_api(scratch);\n+    test_schnorrsig_bip_vectors(scratch);\n+    test_schnorrsig_sign();\n+    test_schnorrsig_sign_verify(scratch);\n+\n+    secp256k1_scratch_space_destroy(ctx, scratch);\n+}\n+\n+#endif"
      },
      {
        "sha": "640693a5e32edf5472504b9f9fbf0c0dffa8dd51",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -103,4 +103,7 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n /** Multiply a and b (without taking the modulus!), divide by 2**shift, and round to the nearest integer. Shift must be at least 256. */\n static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift);\n \n+/** Generate two scalars from a 32-byte seed and an integer using the chacha20 stream cipher */\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx);\n+\n #endif /* SECP256K1_SCALAR_H */"
      },
      {
        "sha": "268cc68d60fc9ac80a217339b6d5f32f1af8ebf1",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -7,6 +7,9 @@\n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include \"scalar.h\"\n+#include <string.h>\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)\n #define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)\n@@ -946,4 +949,91 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[3] = (((uint64_t)  x0) << 32) | x1;\n+        r1->d[2] = (((uint64_t)  x2) << 32) | x3;\n+        r1->d[1] = (((uint64_t)  x4) << 32) | x5;\n+        r1->d[0] = (((uint64_t)  x6) << 32) | x7;\n+        r2->d[3] = (((uint64_t)  x8) << 32) | x9;\n+        r2->d[2] = (((uint64_t) x10) << 32) | x11;\n+        r2->d[1] = (((uint64_t) x12) << 32) | x13;\n+        r2->d[0] = (((uint64_t) x14) << 32) | x15;\n+\n+        over1 = secp256k1_scalar_check_overflow(r1);\n+        over2 = secp256k1_scalar_check_overflow(r2);\n+        over_count++;\n+   } while (over1 | over2);\n+}\n+\n+#undef ROTL32\n+#undef QUARTERROUND\n+#undef LE32\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "a9a934c43c4833b2f6c43883bd76386342dfed3a",
        "filename": "src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -7,6 +7,8 @@\n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include <string.h>\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint32_t)0xD0364141UL)\n #define SECP256K1_N_1 ((uint32_t)0xBFD25E8CUL)\n@@ -718,4 +720,99 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = x0;\n+        r1->d[6] = x1;\n+        r1->d[5] = x2;\n+        r1->d[4] = x3;\n+        r1->d[3] = x4;\n+        r1->d[2] = x5;\n+        r1->d[1] = x6;\n+        r1->d[0] = x7;\n+        r2->d[7] = x8;\n+        r2->d[6] = x9;\n+        r2->d[5] = x10;\n+        r2->d[4] = x11;\n+        r2->d[3] = x12;\n+        r2->d[2] = x13;\n+        r2->d[1] = x14;\n+        r2->d[0] = x15;\n+\n+        over1 = secp256k1_scalar_check_overflow(r1);\n+        over2 = secp256k1_scalar_check_overflow(r2);\n+        over_count++;\n+   } while (over1 | over2);\n+}\n+\n+#undef ROTL32\n+#undef QUARTERROUND\n+#undef LE32\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "fa790570ff837e2d98a1b606ed598bc9ac70fd4b",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n+#include \"group.h\"\n #include \"scalar.h\"\n-#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "88e52d803120a421c1537f867ed8252bbee3e069",
        "filename": "src/scalar_low_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low_impl.h?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -111,4 +111,9 @@ SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const\n     return *a == *b;\n }\n \n+SECP256K1_INLINE static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t n) {\n+    *r1 = (seed[0] + n) % EXHAUSTIVE_TEST_ORDER;\n+    *r2 = (seed[1] + n) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "38c2b0d69edf349c850edec9cabd74661b260975",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -413,6 +413,29 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    (void) counter;\n+    VERIFY_CHECK(counter == 0);\n+\n+    /* Hash x||msg as per the spec */\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, key32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    /* Hash in algorithm, which is not in the spec, but may be critical to\n+     * users depending on it to avoid nonce reuse across algorithms. */\n+    if (algo16 != NULL) {\n+        secp256k1_sha256_write(&sha, algo16, 16);\n+    }\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, data, 32);\n+    }\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n    unsigned char keydata[112];\n    unsigned int offset = 0;\n@@ -443,6 +466,7 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n    return 1;\n }\n \n+const secp256k1_nonce_function secp256k1_nonce_function_bipschnorr = nonce_function_bipschnorr;\n const secp256k1_nonce_function secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979;\n const secp256k1_nonce_function secp256k1_nonce_function_default = nonce_function_rfc6979;\n \n@@ -685,6 +709,10 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n # include \"modules/ecdh/main_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/main_impl.h\"\n+#endif\n+\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif"
      },
      {
        "sha": "ed66e83ac84b32caba711556502c031ef1c1aeb5",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 121,
        "deletions": 2,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69b0efd59feca9b50412d090c16e06bc7a244e6d/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "patch": "@@ -1077,12 +1077,122 @@ void scalar_test(void) {\n \n }\n \n+void scalar_chacha_tests(void) {\n+    /* Test vectors 1 to 4 from https://tools.ietf.org/html/rfc8439#appendix-A\n+     * Note that scalar_set_b32 and scalar_get_b32 represent integers\n+     * underlying the scalar in big-endian format. */\n+    unsigned char expected1[64] = {\n+        0xad, 0xe0, 0xb8, 0x76, 0x90, 0x3d, 0xf1, 0xa0,\n+        0xe5, 0x6a, 0x5d, 0x40, 0x28, 0xbd, 0x86, 0x53,\n+        0xb8, 0x19, 0xd2, 0xbd, 0x1a, 0xed, 0x8d, 0xa0,\n+        0xcc, 0xef, 0x36, 0xa8, 0xc7, 0x0d, 0x77, 0x8b,\n+        0x7c, 0x59, 0x41, 0xda, 0x8d, 0x48, 0x57, 0x51,\n+        0x3f, 0xe0, 0x24, 0x77, 0x37, 0x4a, 0xd8, 0xb8,\n+        0xf4, 0xb8, 0x43, 0x6a, 0x1c, 0xa1, 0x18, 0x15,\n+        0x69, 0xb6, 0x87, 0xc3, 0x86, 0x65, 0xee, 0xb2\n+    };\n+    unsigned char expected2[64] = {\n+        0xbe, 0xe7, 0x07, 0x9f, 0x7a, 0x38, 0x51, 0x55,\n+        0x7c, 0x97, 0xba, 0x98, 0x0d, 0x08, 0x2d, 0x73,\n+        0xa0, 0x29, 0x0f, 0xcb, 0x69, 0x65, 0xe3, 0x48,\n+        0x3e, 0x53, 0xc6, 0x12, 0xed, 0x7a, 0xee, 0x32,\n+        0x76, 0x21, 0xb7, 0x29, 0x43, 0x4e, 0xe6, 0x9c,\n+        0xb0, 0x33, 0x71, 0xd5, 0xd5, 0x39, 0xd8, 0x74,\n+        0x28, 0x1f, 0xed, 0x31, 0x45, 0xfb, 0x0a, 0x51,\n+        0x1f, 0x0a, 0xe1, 0xac, 0x6f, 0x4d, 0x79, 0x4b\n+    };\n+    unsigned char seed3[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+    };\n+    unsigned char expected3[64] = {\n+        0x24, 0x52, 0xeb, 0x3a, 0x92, 0x49, 0xf8, 0xec,\n+        0x8d, 0x82, 0x9d, 0x9b, 0xdd, 0xd4, 0xce, 0xb1,\n+        0xe8, 0x25, 0x20, 0x83, 0x60, 0x81, 0x8b, 0x01,\n+        0xf3, 0x84, 0x22, 0xb8, 0x5a, 0xaa, 0x49, 0xc9,\n+        0xbb, 0x00, 0xca, 0x8e, 0xda, 0x3b, 0xa7, 0xb4,\n+        0xc4, 0xb5, 0x92, 0xd1, 0xfd, 0xf2, 0x73, 0x2f,\n+        0x44, 0x36, 0x27, 0x4e, 0x25, 0x61, 0xb3, 0xc8,\n+        0xeb, 0xdd, 0x4a, 0xa6, 0xa0, 0x13, 0x6c, 0x00\n+    };\n+    unsigned char seed4[32] = {\n+        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+    };\n+    unsigned char expected4[64] = {\n+        0xfb, 0x4d, 0xd5, 0x72, 0x4b, 0xc4, 0x2e, 0xf1,\n+        0xdf, 0x92, 0x26, 0x36, 0x32, 0x7f, 0x13, 0x94,\n+        0xa7, 0x8d, 0xea, 0x8f, 0x5e, 0x26, 0x90, 0x39,\n+        0xa1, 0xbe, 0xbb, 0xc1, 0xca, 0xf0, 0x9a, 0xae,\n+        0xa2, 0x5a, 0xb2, 0x13, 0x48, 0xa6, 0xb4, 0x6c,\n+        0x1b, 0x9d, 0x9b, 0xcb, 0x09, 0x2c, 0x5b, 0xe6,\n+        0x54, 0x6c, 0xa6, 0x24, 0x1b, 0xec, 0x45, 0xd5,\n+        0x87, 0xf4, 0x74, 0x73, 0x96, 0xf0, 0x99, 0x2e\n+    };\n+    unsigned char seed5[32] = {\n+        0x32, 0x56, 0x56, 0xf4, 0x29, 0x02, 0xc2, 0xf8,\n+        0xa3, 0x4b, 0x96, 0xf5, 0xa7, 0xf7, 0xe3, 0x6c,\n+        0x92, 0xad, 0xa5, 0x18, 0x1c, 0xe3, 0x41, 0xae,\n+        0xc3, 0xf3, 0x18, 0xd0, 0xfa, 0x5b, 0x72, 0x53\n+    };\n+    unsigned char expected5[64] = {\n+        0xe7, 0x56, 0xd3, 0x28, 0xe9, 0xc6, 0x19, 0x5c,\n+        0x6f, 0x17, 0x8e, 0x21, 0x8c, 0x1e, 0x72, 0x11,\n+        0xe7, 0xbd, 0x17, 0x0d, 0xac, 0x14, 0xad, 0xe9,\n+        0x3d, 0x9f, 0xb6, 0x92, 0xd6, 0x09, 0x20, 0xfb,\n+        0x43, 0x8e, 0x3b, 0x6d, 0xe3, 0x33, 0xdc, 0xc7,\n+        0x6c, 0x07, 0x6f, 0xbb, 0x1f, 0xb4, 0xc8, 0xb5,\n+        0xe3, 0x6c, 0xe5, 0x12, 0xd9, 0xd7, 0x64, 0x0c,\n+        0xf5, 0xa7, 0x0d, 0xab, 0x79, 0x03, 0xf1, 0x81\n+    };\n+\n+    secp256k1_scalar exp_r1, exp_r2;\n+    secp256k1_scalar r1, r2;\n+    unsigned char seed0[32] = { 0 };\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed0, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected1[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected1[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed0, 1);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected2[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected2[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed3, 1);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected3[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected3[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed4, 2);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected4[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected4[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed5, 0x6ff8602a7a78e2f2ULL);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected5[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected5[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+}\n+\n void run_scalar_tests(void) {\n     int i;\n     for (i = 0; i < 128 * count; i++) {\n         scalar_test();\n     }\n \n+    scalar_chacha_tests();\n+\n     {\n         /* (-1)+1 should be zero. */\n         secp256k1_scalar s, o;\n@@ -2240,7 +2350,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinity */\n+        /* randomly set half the points to infinitiy */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -5162,6 +5272,10 @@ void run_ecdsa_openssl(void) {\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/tests_impl.h\"\n+#endif\n+\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/tests_impl.h\"\n #endif\n@@ -5180,7 +5294,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n+            if (sscanf(ch, \"%2hx\", &sh)) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5275,6 +5389,11 @@ int main(int argc, char **argv) {\n     run_ecdh_tests();\n #endif\n \n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+    /* Schnorrsig tests */\n+    run_schnorrsig_tests();\n+#endif\n+\n     /* ecdsa tests */\n     run_random_pubkeys();\n     run_ecdsa_der_parse();"
      }
    ]
  },
  {
    "sha": "659d36fb0e6600dc5e9493b87a20c194b373254e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NTlkMzZmYjBlNjYwMGRjNWU5NDkzYjg3YTIwYzE5NGIzNzMyNTRl",
    "commit": {
      "author": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:05:42Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:05:42Z"
      },
      "message": "Merge commit '69b0efd59feca9b50412d090c16e06bc7a244e6d' into taproot-rebase-52b9797",
      "tree": {
        "sha": "2b912f9418076e4c90c14301eba673e5eabb83e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b912f9418076e4c90c14301eba673e5eabb83e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/659d36fb0e6600dc5e9493b87a20c194b373254e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e2XgZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf2EGD/wOOIXUjcL3sM/zCmyibKqC\nTRUfmLm1bOwxps0SWbGg53NYEM3SFP8TdP1J8CKd57g0Hl0iJuOftDxfHUQfHlWW\nBq/T6IH7MSmKlcMtwv/O+Zcn6Z9ZMicuO+j4BkGMw1B/z6+ppmKaCpuV7AvmTuJg\njcD6jN8diBGhC7CU+PEJajW/v2O+WdkmucTqNlKj4hQX7fANI4OTLL5ZhoLYe+Ay\nZRIm7L2FYRu4fqi/NnCFDO5tqlwezOHYfSG/QG+Huo0EL0Z1fiyVSxw44TipdVmg\nseHQhDeattkX7p/EckHNTi/m2EwBhavpvrUPsY/VWwX7Pk5NFpvMuJ3i2xSxqyht\nvvUdyqc4lCMqlHWx28K7boDFQw9e7RDm7yD9FldD6YYp+36J/xudsYqNW2UBLX51\nZrRlGQzhf7M68/bTuD9g+xvkvY05RktI5pGYbEaH53aClGWoT4OZv3iCAWaadOQ6\nQfeCZnGO7+OIXlY/I6elS7DdjetOnkPYSnk4XiON1ZEccoiMIw4hXlvz9D3f9O8A\nBvdeX8bNQHTysDTjMbfZklNqjgCbnwUDw0j5nmt7wpQXhoVf3G4boVu0sGXJPcc4\nQy79BVzEDuVig7n3nVj+Eo7a11Vl+QWjfoNIb3TBqCV4MvZNPdYxX/FxuMVtPNi4\nX5hhKFJ1vwcWWnyKUTZyJA==\n=evZ6\n-----END PGP SIGNATURE-----",
        "payload": "tree 2b912f9418076e4c90c14301eba673e5eabb83e5\nparent 78fb58d0b5cb58e6679df155acf7e0861bc05b2e\nparent 69b0efd59feca9b50412d090c16e06bc7a244e6d\nauthor Elichai Turkel <elichai.turkel@gmail.com> 1566497142 -0400\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566497142 -0400\n\nMerge commit '69b0efd59feca9b50412d090c16e06bc7a244e6d' into taproot-rebase-52b9797\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/659d36fb0e6600dc5e9493b87a20c194b373254e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/659d36fb0e6600dc5e9493b87a20c194b373254e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/659d36fb0e6600dc5e9493b87a20c194b373254e/comments",
    "author": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78fb58d0b5cb58e6679df155acf7e0861bc05b2e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/78fb58d0b5cb58e6679df155acf7e0861bc05b2e"
      },
      {
        "sha": "69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69b0efd59feca9b50412d090c16e06bc7a244e6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/69b0efd59feca9b50412d090c16e06bc7a244e6d"
      }
    ],
    "stats": {
      "total": 1749,
      "additions": 1714,
      "deletions": 35
    },
    "files": [
      {
        "sha": "905be987305af82722e0831ce8f7b68c6f512dda",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -1,9 +1,9 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n-bench_schnorr_verify\n bench_recover\n bench_internal\n tests"
      },
      {
        "sha": "9e9fd6f214e4ae37f6af4a6d93e530066787bb11",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -11,20 +11,20 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no SCHNORRSIG=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes   SCHNORRSIG=yes\n     - SCALAR=64bit\n-    - FIELD=64bit     RECOVERY=yes\n+    - FIELD=64bit     RECOVERY=yes      EXPERIMENTAL=yes             SCHNORRSIG=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes    SCHNORRSIG=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n@@ -65,4 +65,4 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-module-schnorrsig=$SCHNORRSIG --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD"
      },
      {
        "sha": "1d985c17e130a276214a6ed3025346ab1ad374c7",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -178,6 +178,10 @@ if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n endif\n \n+if ENABLE_MODULE_SCHNORRSIG\n+include src/modules/schnorrsig/Makefile.am.include\n+endif\n+\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif"
      },
      {
        "sha": "1c66d712d4d6e789599d012cca4edd29ff2423e0",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -59,5 +59,5 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ make check\n+    $ ./tests\n     $ sudo make install  # optional"
      },
      {
        "sha": "3c21169e3f0b570ddaf880111d277d0d6dd0af7b",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -129,6 +129,11 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n+AC_ARG_ENABLE(module_schnorrsig,\n+    AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module (experimental)]),\n+    [enable_module_schnorrsig=$enableval],\n+    [enable_module_schnorrsig=no])\n+\n AC_ARG_ENABLE(module_recovery,\n     AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n@@ -488,6 +493,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n \n+if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_SCHNORRSIG, 1, [Define this symbol to enable the schnorrsig module])\n+fi\n+\n if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n@@ -507,11 +516,15 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([WARNING: experimental build])\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building schnorrsig module: $enable_module_schnorrsig])\n   AC_MSG_NOTICE([******])\n else\n   if test x\"$enable_module_ecdh\" = x\"yes\"; then\n     AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n   fi\n+  if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n+    AC_MSG_ERROR([schnorrsig module is experimental. Use --enable-experimental to allow.])\n+  fi\n   if test x\"$set_asm\" = x\"arm\"; then\n     AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -530,6 +543,7 @@ AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n@@ -552,6 +566,7 @@ echo \"  with benchmarks         = $use_benchmark\"\n echo \"  with coverage           = $enable_coverage\"\n echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\"\n+echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  bignum                  = $set_bignum\""
      },
      {
        "sha": "5988b14193b563c87b493720e16313c6f8a8b15f",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -258,7 +258,7 @@ SECP256K1_API void secp256k1_context_destroy(\n  *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n  *  The library can call these default handlers even before a proper callback data\n  *  pointer could have been set using secp256k1_context_set_illegal_callback or\n- *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  secp256k1_context_set_illegal_callback, e.g., when the creation of a context\n  *  fails. In this case, the corresponding default handler will be called with\n  *  the data pointer argument set to NULL.\n  *\n@@ -523,6 +523,12 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.\n+ * If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ * extra entropy.\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_bipschnorr;\n+\n /** A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979). */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_default;\n \n@@ -646,7 +652,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n  * Args:    ctx:    pointer to a context object initialized for validation\n  *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key object.\n+ * In/Out:  pubkey: pointer to a public key obkect.\n  * In:      tweak:  pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul("
      },
      {
        "sha": "0fb64a5431f8a977a577812c44441d87f577f311",
        "filename": "src/secp256k1/include/secp256k1_preallocated.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_preallocated.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -14,12 +14,12 @@ extern \"C\" {\n  *\n  * Context objects created by functions in this module can be used like contexts\n  * objects created by functions in secp256k1.h, i.e., they can be passed to any\n- * API function that expects a context object (see secp256k1.h for details). The\n+ * API function that excepts a context object (see secp256k1.h for details). The\n  * only exception is that context objects created by functions in this module\n  * must be destroyed using secp256k1_context_preallocated_destroy (in this\n  * module) instead of secp256k1_context_destroy (in secp256k1.h).\n  *\n- * It is guaranteed that functions in this module will not call malloc or its\n+ * It is guaranteed that functions in by this module will not call malloc or its\n  * friends realloc, calloc, and free.\n  */\n "
      },
      {
        "sha": "77a9f0bc95d66fd70050d176803f97a9d7c6e27d",
        "filename": "src/secp256k1/include/secp256k1_schnorrsig.h",
        "status": "added",
        "additions": 126,
        "deletions": 0,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorrsig.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to a public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures.\n+ *\n+ * Returns 1 if all succeeded, 0 otherwise. In particular, returns 1 if n_sigs is 0.\n+ *\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *       scratch: scratch space used for the multiexponentiation\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays. Must be smaller than\n+ *                2^31 and smaller than half the maximum size_t value. Must be 0\n+ *                if above arrays are NULL.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify_batch(\n+    const secp256k1_context* ctx,\n+    secp256k1_scratch_space *scratch,\n+    const secp256k1_schnorrsig *const *sig,\n+    const unsigned char *const *msg32,\n+    const secp256k1_pubkey *const *pk,\n+    size_t n_sigs\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_SCHNORRSIG_H */"
      },
      {
        "sha": "b68adf53123aedb605dcede1904586237d38615b",
        "filename": "src/secp256k1/src/bench_schnorrsig.c",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorrsig.c?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * sizeof(unsigned char *));\n+    data.msgs = (const unsigned char **)malloc(MAX_SIGS * sizeof(unsigned char *));\n+    data.sigs = (const secp256k1_schnorrsig **)malloc(MAX_SIGS * sizeof(secp256k1_schnorrsig *));\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = (unsigned char *)malloc(32);\n+        secp256k1_schnorrsig *sig = (secp256k1_schnorrsig *)malloc(sizeof(*sig));\n+        unsigned char *pk_char = (unsigned char *)malloc(33);\n+        secp256k1_pubkey pk;\n+        size_t pk_len = 33;\n+        msg[0] = sk[0] = i;\n+        msg[1] = sk[1] = i >> 8;\n+        msg[2] = sk[2] = i >> 16;\n+        msg[3] = sk[3] = i >> 24;\n+        memset(&msg[4], 'm', 28);\n+        memset(&sk[4], 's', 28);\n+\n+        data.pk[i] = pk_char;\n+        data.msgs[i] = msg;\n+        data.sigs[i] = sig;\n+\n+        CHECK(secp256k1_ec_pubkey_create(data.ctx, &pk, sk));\n+        CHECK(secp256k1_ec_pubkey_serialize(data.ctx, pk_char, &pk_len, &pk, SECP256K1_EC_COMPRESSED) == 1);\n+        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, sk, NULL, NULL));\n+    }\n+\n+    run_benchmark(\"schnorrsig_sign\", bench_schnorrsig_sign, NULL, NULL, (void *) &data, 10, 1000);\n+    run_benchmark(\"schnorrsig_verify\", bench_schnorrsig_verify, NULL, NULL, (void *) &data, 10, 1000);\n+    for (i = 1; i <= MAX_SIGS; i *= 2) {\n+        char name[64];\n+        sprintf(name, \"schnorrsig_batch_verify_%d\", (int) i);\n+\n+        data.n = i;\n+        run_benchmark(name, bench_schnorrsig_verify_n, NULL, NULL, (void *) &data, 3, MAX_SIGS);\n+    }\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        free((void *)data.pk[i]);\n+        free((void *)data.msgs[i]);\n+        free((void *)data.sigs[i]);\n+    }\n+    free(data.pk);\n+    free(data.msgs);\n+    free(data.sigs);\n+\n+    secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n+    secp256k1_context_destroy(data.ctx);\n+    return 0;\n+}"
      },
      {
        "sha": "d4804b8b68faa3ce5944e1695ec5eda3d5db3cab",
        "filename": "src/secp256k1/src/ecmult_const.h",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -10,11 +10,8 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/**\n- * Multiply: R = q*A (in constant-time)\n- * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion.\n- */\n+/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "bb7adedfb1f0dbf0386c951aef0acd885b223fd5",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -395,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s;\n+    secp256k1_scalar s = *a;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -408,7 +408,6 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n-    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;"
      },
      {
        "sha": "d766a1029ce389a73207431bdf7c0376b1fc6e35",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -3,6 +3,7 @@\n import com.google.common.io.BaseEncoding;\n import java.util.Arrays;\n import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n@@ -69,7 +70,7 @@ public static void testPubKeyCreatePos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = BaseEncoding.base16().encode(resultArr);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n     }\n \n@@ -80,7 +81,7 @@ public static void testPubKeyCreateNeg() throws AssertFailException{\n        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = BaseEncoding.base16().encode(resultArr);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n        assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n     }\n \n@@ -93,7 +94,7 @@ public static void testSignPos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n     }\n \n@@ -105,7 +106,7 @@ public static void testSignNeg() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString, \"\" , \"testSignNeg\");\n     }\n \n@@ -117,7 +118,7 @@ public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n     }\n \n@@ -129,7 +130,7 @@ public static void testPrivKeyTweakMul_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n     }\n \n@@ -141,7 +142,7 @@ public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n     }\n \n@@ -153,7 +154,7 @@ public static void testPrivKeyTweakMul_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = BaseEncoding.base16().encode(resultArr);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n     }\n \n@@ -172,7 +173,7 @@ public static void testCreateECDHSecret() throws AssertFailException{\n         byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = BaseEncoding.base16().encode(resultArr);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n         assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n     }\n "
      },
      {
        "sha": "b50970b4f24c8cd3480368aab34a9d83df92fe1b",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -81,15 +81,15 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n   jbyteArray sigArray, intsByteArray;\n   unsigned char intsarray[2];\n \n-  secp256k1_ecdsa_signature sig;\n+  secp256k1_ecdsa_signature sig[72];\n \n-  int ret = secp256k1_ecdsa_sign(ctx, &sig, data, secKey, NULL, NULL);\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n \n   if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, &sig ); (void)ret2;\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n   }\n \n   intsarray[0] = outputLen;"
      },
      {
        "sha": "5c9bbe86101c9f59bf288019c2923fe6c5019b0e",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 1. */\n+         * and secret key 0 (which is not valid), resulting in recid 0. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "a82bafe43fda64027b97a8e4d66dac35b4a3e96e",
        "filename": "src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/Makefile.am.include?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_schnorrsig.h\n+noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_schnorrsig\n+bench_schnorrsig_SOURCES = src/bench_schnorrsig.c\n+bench_schnorrsig_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif"
      },
      {
        "sha": "739e98b0c3461a4d0733f49b91af4af1ba6f29d6",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "added",
        "additions": 332,
        "deletions": 0,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -0,0 +1,332 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. The very first randomizer will be set to 1 and\n+     * the PRNG is called at every odd indexed schnorrsig to fill the cache. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 2) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called with 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_scalar_chacha20(&ecmult_context->randomizer_cache[0], &ecmult_context->randomizer_cache[1], ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        *sc = ecmult_context->randomizer_cache[(idx / 2) % 2];\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+static int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, buflen);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.\n+ *\n+ *  In/Out: s: the s part of the input sigs is added to this s argument\n+ *  In:  chacha_seed: PRNG seed for computing randomizers\n+ *        sig: array of signatures, or NULL if there are no signatures\n+ *     n_sigs: number of signatures in above array (must be 0 if they are NULL)\n+ */\n+static int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_scalar *s, unsigned char *chacha_seed, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    secp256k1_scalar randomizer_cache[2];\n+    size_t i;\n+\n+    secp256k1_scalar_set_int(&randomizer_cache[0], 1);\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 1) {\n+            secp256k1_scalar_chacha20(&randomizer_cache[0], &randomizer_cache[1], chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != -(s1 + a2*s2 + ... + au*su)G + R1 + a2*R2 + ... + au*Ru + e1*P1 + (a2*e2)P2 + ... + (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+    /* Check that n_sigs is less than half of the maximum size_t value. This is necessary because\n+     * the number of points given to ecmult_multi is 2*n_sigs. */\n+    ARG_CHECK(n_sigs <= SIZE_MAX / 2);\n+    /* Check that n_sigs is less than 2^31 to ensure the same behavior of this function on 32-bit\n+     * and 64-bit platforms. */\n+    ARG_CHECK(n_sigs < ((uint32_t)1 << 31));\n+\n+    secp256k1_sha256_initialize(&sha);\n+    if (!secp256k1_schnorrsig_verify_batch_init_randomizer(ctx, &ecmult_context, &sha, sig, msg32, pk, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_sha256_finalize(&sha, ecmult_context.chacha_seed);\n+    secp256k1_scalar_set_int(&ecmult_context.randomizer_cache[0], 1);\n+\n+    secp256k1_scalar_clear(&s);\n+    if (!secp256k1_schnorrsig_verify_batch_sum_s(&s, ecmult_context.chacha_seed, sig, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_negate(&s, &s);\n+\n+    return secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &rj, &s, secp256k1_schnorrsig_verify_batch_ecmult_callback, (void *) &ecmult_context, 2 * n_sigs)\n+            && secp256k1_gej_is_infinity(&rj);\n+}\n+\n+#endif"
      },
      {
        "sha": "2de43af1e33b646a3c9445f7378e5532fea44e33",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "added",
        "additions": 721,
        "deletions": 0,
        "changes": 721,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -0,0 +1,721 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+void test_schnorrsig_serialize(void) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char in[64];\n+    unsigned char out[64];\n+\n+    memset(in, 0x12, 64);\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, in));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, out, &sig));\n+    CHECK(memcmp(in, out, 64) == 0);\n+}\n+\n+void test_schnorrsig_api(secp256k1_scratch_space *scratch) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    unsigned char sig64[64];\n+    secp256k1_pubkey pk[3];\n+    secp256k1_schnorrsig sig;\n+    const secp256k1_schnorrsig *sigptr = &sig;\n+    const unsigned char *msgptr = msg;\n+    const secp256k1_pubkey *pkptr = &pk[0];\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk1) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[1], sk2) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[2], sk3) == 1);\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, &sig, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, &sig, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, NULL, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, &sig) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_serialize(none, NULL, &sig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, sig64) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, NULL, sig64) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, NULL) == 0);\n+    CHECK(ecount == 4);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify_batch(none, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify_batch(sign, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, NULL, NULL, 0) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, NULL, &pkptr, 1) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, NULL, 1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (size_t)1 << (sizeof(size_t)*8-1)) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (uint32_t)1 << 31) == 0);\n+    CHECK(ecount == 7);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *msg, const unsigned char *expected_sig) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char serialized_sig[64];\n+    secp256k1_pubkey pk;\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, NULL, NULL));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, serialized_sig, &sig));\n+    CHECK(memcmp(serialized_sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, &sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(secp256k1_scratch_space *scratch, const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig_serialized, int expected) {\n+    const unsigned char *msg_arr[1];\n+    const secp256k1_schnorrsig *sig_arr[1];\n+    const secp256k1_pubkey *pk_arr[1];\n+    secp256k1_pubkey pk;\n+    secp256k1_schnorrsig sig;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, sig_serialized));\n+\n+    sig_arr[0] = &sig;\n+    msg_arr[0] = msg32;\n+    pk_arr[0] = &pk;\n+\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, &sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+}\n+\n+/* Test vectors according to BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/7f6a73e53c8bbcf2d008ea0546f76433e22094a8/bip-schnorr/test-vectors.csv).\n+ */\n+void test_schnorrsig_bip_vectors(secp256k1_scratch_space *scratch) {\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char pk1[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig1[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x70, 0x31, 0xA9, 0x88, 0x31, 0x85, 0x9D, 0xC3,\n+            0x4D, 0xFF, 0xEE, 0xDD, 0xA8, 0x68, 0x31, 0x84,\n+            0x2C, 0xCD, 0x00, 0x79, 0xE1, 0xF9, 0x2A, 0xF1,\n+            0x77, 0xF7, 0xF2, 0x2C, 0xC1, 0xDC, 0xED, 0x05\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk1, pk1, msg1, sig1);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk1, msg1, sig1, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk2[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk2[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg2[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig2[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk2, pk2, msg2, sig2);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk2, msg2, sig2, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk3[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC7\n+        };\n+        const unsigned char pk3[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg3[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig3[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0x00, 0x88, 0x03, 0x71, 0xD0, 0x17, 0x66, 0x93,\n+            0x5B, 0x92, 0xD2, 0xAB, 0x4C, 0xD5, 0xC8, 0xA2,\n+            0xA5, 0x83, 0x7E, 0xC5, 0x7F, 0xED, 0x76, 0x60,\n+            0x77, 0x3A, 0x05, 0xF0, 0xDE, 0x14, 0x23, 0x80\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk3, pk3, msg3, sig3);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk3, msg3, sig3, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk4[33] = {\n+            0x03, 0xDE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        const unsigned char msg4[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig4[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x02, 0xA8, 0xDC, 0x32, 0xE6, 0x4E, 0x86, 0xA3,\n+            0x33, 0xF2, 0x0E, 0xF5, 0x6E, 0xAC, 0x9B, 0xA3,\n+            0x0B, 0x72, 0x46, 0xD6, 0xD2, 0x5E, 0x22, 0xAD,\n+            0xB8, 0xC6, 0xBE, 0x1A, 0xEB, 0x08, 0xD4, 0x9D\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4, msg4, sig4, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk5[33] = {\n+            0x03, 0x1B, 0x84, 0xC5, 0x56, 0x7B, 0x12, 0x64,\n+            0x40, 0x99, 0x5D, 0x3E, 0xD5, 0xAA, 0xBA, 0x05,\n+            0x65, 0xD7, 0x1E, 0x18, 0x34, 0x60, 0x48, 0x19,\n+            0xFF, 0x9C, 0x17, 0xF5, 0xE9, 0xD5, 0xDD, 0x07,\n+            0x8F\n+        };\n+        const unsigned char msg5[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig5[64] = {\n+            0x52, 0x81, 0x85, 0x79, 0xAC, 0xA5, 0x97, 0x67,\n+            0xE3, 0x29, 0x1D, 0x91, 0xB7, 0x6B, 0x63, 0x7B,\n+            0xEF, 0x06, 0x20, 0x83, 0x28, 0x49, 0x92, 0xF2,\n+            0xD9, 0x5F, 0x56, 0x4C, 0xA6, 0xCB, 0x4E, 0x35,\n+            0x30, 0xB1, 0xDA, 0x84, 0x9C, 0x8E, 0x83, 0x04,\n+            0xAD, 0xC0, 0xCF, 0xE8, 0x70, 0x66, 0x03, 0x34,\n+            0xB3, 0xCF, 0xC1, 0x8E, 0x82, 0x5E, 0xF1, 0xDB,\n+            0x34, 0xCF, 0xAE, 0x3D, 0xFC, 0x5D, 0x81, 0x87\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk5, msg5, sig5, 1);\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk6[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg6[32] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+        };\n+        const unsigned char sig6[64] = {\n+            0x57, 0x0D, 0xD4, 0xCA, 0x83, 0xD4, 0xE6, 0x31,\n+            0x7B, 0x8E, 0xE6, 0xBA, 0xE8, 0x34, 0x67, 0xA1,\n+            0xBF, 0x41, 0x9D, 0x07, 0x67, 0x12, 0x2D, 0xE4,\n+            0x09, 0x39, 0x44, 0x14, 0xB0, 0x50, 0x80, 0xDC,\n+            0xE9, 0xEE, 0x5F, 0x23, 0x7C, 0xBD, 0x10, 0x8E,\n+            0xAB, 0xAE, 0x1E, 0x37, 0x75, 0x9A, 0xE4, 0x7F,\n+            0x8E, 0x42, 0x03, 0xDA, 0x35, 0x32, 0xEB, 0x28,\n+            0xDB, 0x86, 0x0F, 0x33, 0xD6, 0x2D, 0x49, 0xBD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk6, msg6, sig6, 1);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk7[33] = {\n+            0x03, 0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        secp256k1_pubkey pk7_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_ec_pubkey_parse(ctx, &pk7_parsed, pk7, 33));\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk8[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg8[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig8[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFA, 0x16, 0xAE, 0xE0, 0x66, 0x09, 0x28, 0x0A,\n+            0x19, 0xB6, 0x7A, 0x24, 0xE1, 0x97, 0x7E, 0x46,\n+            0x97, 0x71, 0x2B, 0x5F, 0xD2, 0x94, 0x39, 0x14,\n+            0xEC, 0xD5, 0xF7, 0x30, 0x90, 0x1B, 0x4A, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk8, msg8, sig8, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk9[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg9[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig9[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0xD0, 0x92, 0xF9, 0xD8, 0x60, 0xF1, 0x77, 0x6A,\n+            0x1F, 0x74, 0x12, 0xAD, 0x8A, 0x1E, 0xB5, 0x0D,\n+            0xAC, 0xCC, 0x22, 0x2B, 0xC8, 0xC0, 0xE2, 0x6B,\n+            0x20, 0x56, 0xDF, 0x2F, 0x27, 0x3E, 0xFD, 0xEC\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk9, msg9, sig9, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk10[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg10[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig10[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x8F, 0xCE, 0x56, 0x77, 0xCE, 0x7A, 0x62, 0x3C,\n+            0xB2, 0x00, 0x11, 0x22, 0x57, 0x97, 0xCE, 0x7A,\n+            0x8D, 0xE1, 0xDC, 0x6C, 0xCD, 0x4F, 0x75, 0x4A,\n+            0x47, 0xDA, 0x6C, 0x60, 0x0E, 0x59, 0x54, 0x3C\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk10, msg10, sig10, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk11[33] = {\n+            0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg11[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig11[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk11, msg11, sig11, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk12[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg12[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig12[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x9E, 0x9D, 0x01, 0xAF, 0x98, 0x8B, 0x5C, 0xED,\n+            0xCE, 0x47, 0x22, 0x1B, 0xFA, 0x9B, 0x22, 0x27,\n+            0x21, 0xF3, 0xFA, 0x40, 0x89, 0x15, 0x44, 0x4A,\n+            0x4B, 0x48, 0x90, 0x21, 0xDB, 0x55, 0x77, 0x5F\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk12, msg12, sig12, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk13[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg13[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig13[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xD3, 0x7D, 0xDF, 0x02, 0x54, 0x35, 0x18, 0x36,\n+            0xD8, 0x4B, 0x1B, 0xD6, 0xA7, 0x95, 0xFD, 0x5D,\n+            0x52, 0x30, 0x48, 0xF2, 0x98, 0xC4, 0x21, 0x4D,\n+            0x18, 0x7F, 0xE4, 0x89, 0x29, 0x47, 0xF7, 0x28\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk13, msg13, sig13, 0);\n+    }\n+    {\n+        /* Test vector 14 */\n+        const unsigned char pk14[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg14[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x14, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig14[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk14, msg14, sig14, 0);\n+    }\n+    {\n+        /* Test vector 15 */\n+        const unsigned char pk15[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg15[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig15[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk15, msg15, sig15, 0);\n+    }\n+    {\n+        /* Test vector 16 */\n+        const unsigned char pk16[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg16[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig16[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk16, msg16, sig16, 0);\n+    }\n+}\n+\n+/* Nonce function that returns constant 0 */\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+    (void) counter;\n+    (void) nonce32;\n+    return 0;\n+}\n+\n+/* Nonce function that sets nonce to 0 */\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+    (void) counter;\n+\n+    memset(nonce32, 0, 32);\n+    return 1;\n+}\n+\n+void test_schnorrsig_sign(void) {\n+    unsigned char sk[32];\n+    const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n+    secp256k1_schnorrsig sig;\n+\n+    memset(sk, 23, sizeof(sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, NULL, NULL) == 1);\n+\n+    /* Overflowing secret key */\n+    memset(sk, 0xFF, sizeof(sk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, NULL, NULL) == 0);\n+    memset(sk, 23, sizeof(sk));\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, nonce_function_failing, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, msg, sk, nonce_function_0, NULL) == 0);\n+}\n+\n+#define N_SIGS  200\n+/* Creates N_SIGS valid signatures and verifies them with verify and verify_batch. Then flips some\n+ * bits and checks that verification now fails. */\n+void test_schnorrsig_sign_verify(secp256k1_scratch_space *scratch) {\n+    const unsigned char sk[32] = \"shhhhhhhh! this key is a secret.\";\n+    unsigned char msg[N_SIGS][32];\n+    secp256k1_schnorrsig sig[N_SIGS];\n+    size_t i;\n+    const secp256k1_schnorrsig *sig_arr[N_SIGS];\n+    const unsigned char *msg_arr[N_SIGS];\n+    const secp256k1_pubkey *pk_arr[N_SIGS];\n+    secp256k1_pubkey pk;\n+\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk));\n+\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, NULL, NULL, NULL, 0));\n+\n+    for (i = 0; i < N_SIGS; i++) {\n+        secp256k1_rand256(msg[i]);\n+        CHECK(secp256k1_schnorrsig_sign(ctx, &sig[i], msg[i], sk, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, &sig[i], msg[i], &pk));\n+        sig_arr[i] = &sig[i];\n+        msg_arr[i] = msg[i];\n+        pk_arr[i] = &pk;\n+    }\n+\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 2));\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+    CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, N_SIGS));\n+\n+    {\n+        /* Flip a few bits in the signature and in the message and check that\n+         * verify and verify_batch fail */\n+        size_t sig_idx = secp256k1_rand_int(4);\n+        size_t byte_idx = secp256k1_rand_int(32);\n+        unsigned char xorbyte = secp256k1_rand_int(254)+1;\n+        sig[sig_idx].data[byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+        sig[sig_idx].data[byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        sig[sig_idx].data[32+byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+        sig[sig_idx].data[32+byte_idx] ^= xorbyte;\n+\n+        byte_idx = secp256k1_rand_int(32);\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+        msg[sig_idx][byte_idx] ^= xorbyte;\n+\n+        /* Check that above bitflips have been reversed correctly */\n+        CHECK(secp256k1_schnorrsig_verify(ctx, &sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 4));\n+    }\n+}\n+#undef N_SIGS\n+\n+void run_schnorrsig_tests(void) {\n+    secp256k1_scratch_space *scratch = secp256k1_scratch_space_create(ctx, 1024 * 1024);\n+\n+    test_schnorrsig_serialize();\n+    test_schnorrsig_api(scratch);\n+    test_schnorrsig_bip_vectors(scratch);\n+    test_schnorrsig_sign();\n+    test_schnorrsig_sign_verify(scratch);\n+\n+    secp256k1_scratch_space_destroy(ctx, scratch);\n+}\n+\n+#endif"
      },
      {
        "sha": "640693a5e32edf5472504b9f9fbf0c0dffa8dd51",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -103,4 +103,7 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n /** Multiply a and b (without taking the modulus!), divide by 2**shift, and round to the nearest integer. Shift must be at least 256. */\n static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift);\n \n+/** Generate two scalars from a 32-byte seed and an integer using the chacha20 stream cipher */\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx);\n+\n #endif /* SECP256K1_SCALAR_H */"
      },
      {
        "sha": "268cc68d60fc9ac80a217339b6d5f32f1af8ebf1",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -7,6 +7,9 @@\n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include \"scalar.h\"\n+#include <string.h>\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)\n #define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)\n@@ -946,4 +949,91 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[3] = (((uint64_t)  x0) << 32) | x1;\n+        r1->d[2] = (((uint64_t)  x2) << 32) | x3;\n+        r1->d[1] = (((uint64_t)  x4) << 32) | x5;\n+        r1->d[0] = (((uint64_t)  x6) << 32) | x7;\n+        r2->d[3] = (((uint64_t)  x8) << 32) | x9;\n+        r2->d[2] = (((uint64_t) x10) << 32) | x11;\n+        r2->d[1] = (((uint64_t) x12) << 32) | x13;\n+        r2->d[0] = (((uint64_t) x14) << 32) | x15;\n+\n+        over1 = secp256k1_scalar_check_overflow(r1);\n+        over2 = secp256k1_scalar_check_overflow(r2);\n+        over_count++;\n+   } while (over1 | over2);\n+}\n+\n+#undef ROTL32\n+#undef QUARTERROUND\n+#undef LE32\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "a9a934c43c4833b2f6c43883bd76386342dfed3a",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -7,6 +7,8 @@\n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include <string.h>\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint32_t)0xD0364141UL)\n #define SECP256K1_N_1 ((uint32_t)0xBFD25E8CUL)\n@@ -718,4 +720,99 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = x0;\n+        r1->d[6] = x1;\n+        r1->d[5] = x2;\n+        r1->d[4] = x3;\n+        r1->d[3] = x4;\n+        r1->d[2] = x5;\n+        r1->d[1] = x6;\n+        r1->d[0] = x7;\n+        r2->d[7] = x8;\n+        r2->d[6] = x9;\n+        r2->d[5] = x10;\n+        r2->d[4] = x11;\n+        r2->d[3] = x12;\n+        r2->d[2] = x13;\n+        r2->d[1] = x14;\n+        r2->d[0] = x15;\n+\n+        over1 = secp256k1_scalar_check_overflow(r1);\n+        over2 = secp256k1_scalar_check_overflow(r2);\n+        over_count++;\n+   } while (over1 | over2);\n+}\n+\n+#undef ROTL32\n+#undef QUARTERROUND\n+#undef LE32\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "fa790570ff837e2d98a1b606ed598bc9ac70fd4b",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n+#include \"group.h\"\n #include \"scalar.h\"\n-#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "88e52d803120a421c1537f867ed8252bbee3e069",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -111,4 +111,9 @@ SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const\n     return *a == *b;\n }\n \n+SECP256K1_INLINE static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t n) {\n+    *r1 = (seed[0] + n) % EXHAUSTIVE_TEST_ORDER;\n+    *r2 = (seed[1] + n) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "38c2b0d69edf349c850edec9cabd74661b260975",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -413,6 +413,29 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    (void) counter;\n+    VERIFY_CHECK(counter == 0);\n+\n+    /* Hash x||msg as per the spec */\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, key32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    /* Hash in algorithm, which is not in the spec, but may be critical to\n+     * users depending on it to avoid nonce reuse across algorithms. */\n+    if (algo16 != NULL) {\n+        secp256k1_sha256_write(&sha, algo16, 16);\n+    }\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, data, 32);\n+    }\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n    unsigned char keydata[112];\n    unsigned int offset = 0;\n@@ -443,6 +466,7 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n    return 1;\n }\n \n+const secp256k1_nonce_function secp256k1_nonce_function_bipschnorr = nonce_function_bipschnorr;\n const secp256k1_nonce_function secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979;\n const secp256k1_nonce_function secp256k1_nonce_function_default = nonce_function_rfc6979;\n \n@@ -685,6 +709,10 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n # include \"modules/ecdh/main_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/main_impl.h\"\n+#endif\n+\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif"
      },
      {
        "sha": "ed66e83ac84b32caba711556502c031ef1c1aeb5",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 121,
        "deletions": 2,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/659d36fb0e6600dc5e9493b87a20c194b373254e/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=659d36fb0e6600dc5e9493b87a20c194b373254e",
        "patch": "@@ -1077,12 +1077,122 @@ void scalar_test(void) {\n \n }\n \n+void scalar_chacha_tests(void) {\n+    /* Test vectors 1 to 4 from https://tools.ietf.org/html/rfc8439#appendix-A\n+     * Note that scalar_set_b32 and scalar_get_b32 represent integers\n+     * underlying the scalar in big-endian format. */\n+    unsigned char expected1[64] = {\n+        0xad, 0xe0, 0xb8, 0x76, 0x90, 0x3d, 0xf1, 0xa0,\n+        0xe5, 0x6a, 0x5d, 0x40, 0x28, 0xbd, 0x86, 0x53,\n+        0xb8, 0x19, 0xd2, 0xbd, 0x1a, 0xed, 0x8d, 0xa0,\n+        0xcc, 0xef, 0x36, 0xa8, 0xc7, 0x0d, 0x77, 0x8b,\n+        0x7c, 0x59, 0x41, 0xda, 0x8d, 0x48, 0x57, 0x51,\n+        0x3f, 0xe0, 0x24, 0x77, 0x37, 0x4a, 0xd8, 0xb8,\n+        0xf4, 0xb8, 0x43, 0x6a, 0x1c, 0xa1, 0x18, 0x15,\n+        0x69, 0xb6, 0x87, 0xc3, 0x86, 0x65, 0xee, 0xb2\n+    };\n+    unsigned char expected2[64] = {\n+        0xbe, 0xe7, 0x07, 0x9f, 0x7a, 0x38, 0x51, 0x55,\n+        0x7c, 0x97, 0xba, 0x98, 0x0d, 0x08, 0x2d, 0x73,\n+        0xa0, 0x29, 0x0f, 0xcb, 0x69, 0x65, 0xe3, 0x48,\n+        0x3e, 0x53, 0xc6, 0x12, 0xed, 0x7a, 0xee, 0x32,\n+        0x76, 0x21, 0xb7, 0x29, 0x43, 0x4e, 0xe6, 0x9c,\n+        0xb0, 0x33, 0x71, 0xd5, 0xd5, 0x39, 0xd8, 0x74,\n+        0x28, 0x1f, 0xed, 0x31, 0x45, 0xfb, 0x0a, 0x51,\n+        0x1f, 0x0a, 0xe1, 0xac, 0x6f, 0x4d, 0x79, 0x4b\n+    };\n+    unsigned char seed3[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+    };\n+    unsigned char expected3[64] = {\n+        0x24, 0x52, 0xeb, 0x3a, 0x92, 0x49, 0xf8, 0xec,\n+        0x8d, 0x82, 0x9d, 0x9b, 0xdd, 0xd4, 0xce, 0xb1,\n+        0xe8, 0x25, 0x20, 0x83, 0x60, 0x81, 0x8b, 0x01,\n+        0xf3, 0x84, 0x22, 0xb8, 0x5a, 0xaa, 0x49, 0xc9,\n+        0xbb, 0x00, 0xca, 0x8e, 0xda, 0x3b, 0xa7, 0xb4,\n+        0xc4, 0xb5, 0x92, 0xd1, 0xfd, 0xf2, 0x73, 0x2f,\n+        0x44, 0x36, 0x27, 0x4e, 0x25, 0x61, 0xb3, 0xc8,\n+        0xeb, 0xdd, 0x4a, 0xa6, 0xa0, 0x13, 0x6c, 0x00\n+    };\n+    unsigned char seed4[32] = {\n+        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+    };\n+    unsigned char expected4[64] = {\n+        0xfb, 0x4d, 0xd5, 0x72, 0x4b, 0xc4, 0x2e, 0xf1,\n+        0xdf, 0x92, 0x26, 0x36, 0x32, 0x7f, 0x13, 0x94,\n+        0xa7, 0x8d, 0xea, 0x8f, 0x5e, 0x26, 0x90, 0x39,\n+        0xa1, 0xbe, 0xbb, 0xc1, 0xca, 0xf0, 0x9a, 0xae,\n+        0xa2, 0x5a, 0xb2, 0x13, 0x48, 0xa6, 0xb4, 0x6c,\n+        0x1b, 0x9d, 0x9b, 0xcb, 0x09, 0x2c, 0x5b, 0xe6,\n+        0x54, 0x6c, 0xa6, 0x24, 0x1b, 0xec, 0x45, 0xd5,\n+        0x87, 0xf4, 0x74, 0x73, 0x96, 0xf0, 0x99, 0x2e\n+    };\n+    unsigned char seed5[32] = {\n+        0x32, 0x56, 0x56, 0xf4, 0x29, 0x02, 0xc2, 0xf8,\n+        0xa3, 0x4b, 0x96, 0xf5, 0xa7, 0xf7, 0xe3, 0x6c,\n+        0x92, 0xad, 0xa5, 0x18, 0x1c, 0xe3, 0x41, 0xae,\n+        0xc3, 0xf3, 0x18, 0xd0, 0xfa, 0x5b, 0x72, 0x53\n+    };\n+    unsigned char expected5[64] = {\n+        0xe7, 0x56, 0xd3, 0x28, 0xe9, 0xc6, 0x19, 0x5c,\n+        0x6f, 0x17, 0x8e, 0x21, 0x8c, 0x1e, 0x72, 0x11,\n+        0xe7, 0xbd, 0x17, 0x0d, 0xac, 0x14, 0xad, 0xe9,\n+        0x3d, 0x9f, 0xb6, 0x92, 0xd6, 0x09, 0x20, 0xfb,\n+        0x43, 0x8e, 0x3b, 0x6d, 0xe3, 0x33, 0xdc, 0xc7,\n+        0x6c, 0x07, 0x6f, 0xbb, 0x1f, 0xb4, 0xc8, 0xb5,\n+        0xe3, 0x6c, 0xe5, 0x12, 0xd9, 0xd7, 0x64, 0x0c,\n+        0xf5, 0xa7, 0x0d, 0xab, 0x79, 0x03, 0xf1, 0x81\n+    };\n+\n+    secp256k1_scalar exp_r1, exp_r2;\n+    secp256k1_scalar r1, r2;\n+    unsigned char seed0[32] = { 0 };\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed0, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected1[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected1[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed0, 1);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected2[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected2[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed3, 1);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected3[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected3[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed4, 2);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected4[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected4[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed5, 0x6ff8602a7a78e2f2ULL);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected5[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected5[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+}\n+\n void run_scalar_tests(void) {\n     int i;\n     for (i = 0; i < 128 * count; i++) {\n         scalar_test();\n     }\n \n+    scalar_chacha_tests();\n+\n     {\n         /* (-1)+1 should be zero. */\n         secp256k1_scalar s, o;\n@@ -2240,7 +2350,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinity */\n+        /* randomly set half the points to infinitiy */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -5162,6 +5272,10 @@ void run_ecdsa_openssl(void) {\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+# include \"modules/schnorrsig/tests_impl.h\"\n+#endif\n+\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/tests_impl.h\"\n #endif\n@@ -5180,7 +5294,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n+            if (sscanf(ch, \"%2hx\", &sh)) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5275,6 +5389,11 @@ int main(int argc, char **argv) {\n     run_ecdh_tests();\n #endif\n \n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+    /* Schnorrsig tests */\n+    run_schnorrsig_tests();\n+#endif\n+\n     /* ecdsa tests */\n     run_random_pubkeys();\n     run_ecdsa_der_parse();"
      }
    ]
  },
  {
    "sha": "badc6e2c1a1d3c63786a7c3e75385397c33e6754",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYWRjNmUyYzFhMWQzYzYzNzg2YTdjM2U3NTM4NTM5N2MzM2U2NzU0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-02T20:12:08Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:19:07Z"
      },
      "message": "Initialize PrecomputedTransactionData in CheckInputs",
      "tree": {
        "sha": "2679664925f1e7485ead0295a09bf4f1e95de051",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2679664925f1e7485ead0295a09bf4f1e95de051"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/badc6e2c1a1d3c63786a7c3e75385397c33e6754",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3JsZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf+jTEACOtDjNBwfp4Ctz5QRsGzd2\nJeI3AC4pSc+fM8lv6IEF56co4PLzWo6qojJzPvS1lSqKIWbscU1vP9DJWSt678v6\n67f+v4JOrXRdx40UNGkQR6SdcBJbknZqyalcNDQvWGLIw4NfC0Hf2yIjzjr2nh+u\nzemT6eu2yl7++sm7m2HbmFTk5VC0QB0wrQrI3QcoY+2gk9tcB4pXj57YjgNmKmgi\notm0EDJX4jyq0qyRjfvEDb1NoTiGHrBt4gEA+ONahJFV/idgwZRiAUXqTZPIh9P2\n6o8lCzrbxeU4vjxSIX/3g0Miw3GmG8foF45oVUw7BKQMO34nmmsRIImImeaYayVa\nDHOnJ+0iJ2dI8O8JklB/1YH3CHc2URGE1Tlurav9BRpp9v7bcriIqnlI6DNDJIA5\nRQXht0J3wkZjforanxMoHjAzePQgVos/ep7/zmcH+9ZhEZXA2kvcXDWJpO9yNBTb\ntoDlH3uFAHsOBIjdrzlXCq1FpXjBBH01sJNkPxub2VUPnRZWRghEGd3V8h57pO1X\n+4YGY9tFh0U/LChGALuCXrAnMQ7PBqqEAxgrPlp32cZ76ZK6i/FMz7cSRBiVTNIF\nQJc3zJJqC11AUncyRBMxBfEz0MQGZhRFDbpNX5/qVzq7BPXBcrd+sIyhKS0SnjMQ\n7KSXAT0mn3dvWJxaAzDZdw==\n=Bf0H\n-----END PGP SIGNATURE-----",
        "payload": "tree 2679664925f1e7485ead0295a09bf4f1e95de051\nparent 659d36fb0e6600dc5e9493b87a20c194b373254e\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554235928 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566497947 -0400\n\nInitialize PrecomputedTransactionData in CheckInputs\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/badc6e2c1a1d3c63786a7c3e75385397c33e6754",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/badc6e2c1a1d3c63786a7c3e75385397c33e6754",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/badc6e2c1a1d3c63786a7c3e75385397c33e6754/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "659d36fb0e6600dc5e9493b87a20c194b373254e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/659d36fb0e6600dc5e9493b87a20c194b373254e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/659d36fb0e6600dc5e9493b87a20c194b373254e"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 18,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a5863a0e7a21d2c8e67f9469cea20a7c6b5e44cd",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/badc6e2c1a1d3c63786a7c3e75385397c33e6754/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/badc6e2c1a1d3c63786a7c3e75385397c33e6754/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=badc6e2c1a1d3c63786a7c3e75385397c33e6754",
        "patch": "@@ -1215,8 +1215,9 @@ uint256 GetOutputsHash(const T& txTo)\n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo)\n {\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n         hashPrevouts = GetPrevoutHash(txTo);\n@@ -1226,7 +1227,15 @@ PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo);\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n "
      },
      {
        "sha": "8ab5653c4a7d9baaa0e0aa132f6923a2fb4fc37f",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/badc6e2c1a1d3c63786a7c3e75385397c33e6754/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/badc6e2c1a1d3c63786a7c3e75385397c33e6754/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=badc6e2c1a1d3c63786a7c3e75385397c33e6754",
        "patch": "@@ -124,6 +124,11 @@ struct PrecomputedTransactionData\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n \n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx);\n+\n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };"
      },
      {
        "sha": "3c18493818c558b79fbca5640d61888c1e4214a0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/badc6e2c1a1d3c63786a7c3e75385397c33e6754/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/badc6e2c1a1d3c63786a7c3e75385397c33e6754/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=badc6e2c1a1d3c63786a7c3e75385397c33e6754",
        "patch": "@@ -774,7 +774,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        PrecomputedTransactionData txdata(tx);\n+        PrecomputedTransactionData txdata;\n         if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n@@ -1330,6 +1330,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 return true;\n             }\n \n+            txdata.Init(tx);\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n@@ -1897,7 +1898,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     int64_t nSigOpsCost = 0;\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n     std::vector<PrecomputedTransactionData> txdata;\n-    txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated\n+    txdata.resize(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = *(block.vtx[i]);\n@@ -1947,7 +1948,6 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n-        txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n         {\n             std::vector<CScriptCheck> vChecks;"
      }
    ]
  },
  {
    "sha": "958acfa3e33fa14e10845ee5fcce514da83a8093",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NThhY2ZhM2UzM2ZhMTRlMTA4NDVlZTVmY2NlNTE0ZGE4M2E4MDkz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-02T20:38:05Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:20:36Z"
      },
      "message": "Keep spent outputs in PrecomputedTransactionData during validation",
      "tree": {
        "sha": "19826b7664a8a5b3cdabe15edfff607d4a06bc40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/19826b7664a8a5b3cdabe15edfff607d4a06bc40"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/958acfa3e33fa14e10845ee5fcce514da83a8093",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3PYZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf566D/9VwsH/ulK92yW5kDGK82z5\nIV0aAZ2irdwm3DTRp230G8lv/CTckjUBlRgtFs8ehIkfJAZio6f7tde5wX0vkv4M\nxZfP/QGHGs5wV7xhqeesQPenV99BMeVQvAM/f309H/iwDA1OlBLxcsmK4MGHYldm\nSC6Fs7Zj3OSuOCGAla5v+goI3leoB4w0WzTj/0iVd9h9PPBaf3Tj9GLrwuYuPCiJ\n3xOl7C9yfnjEHljNUh/Vgt01Sk9LWXOvR9iuiQvDyCrZZS63IS/YuB1UCQnwuwrv\nmas/2XjPbHxcDy/DPfqaN+FmcXg1EBODM+fXubZ5sDshYI8LcN+1v9eDodN5CuEa\nkHk4I2FAqCOiap0LbrVeW6wbqbSkc8pCy1aWVb9mSVZc3SwHo9nIAy+PEH936KK1\n6gzig7szynSXxOZiNYMF0JcAjAhzcSYEmjILCT7eM+KppWDG1z1oTev4utxDMG5R\nhj88MntwAJeOsX9W8t+iutdsOzUKhohdyvSGxzkfc+0cB7i1y8OKooviZ9AYNJya\naLuQTvWN4rg9Bcc08meq15VyIQBVTGn9eqdDavcUrTzXIrb7EjxgKI+efDtQFfty\nuTJWFe1ZlsbYjoXjhLt9FWMu6x2PBCVg+nZKEWjIPB5k0v0A5NoDqiLy6tFQu0dH\nINSw9m0vVBiVPbxYM0w3gg==\n=eSH1\n-----END PGP SIGNATURE-----",
        "payload": "tree 19826b7664a8a5b3cdabe15edfff607d4a06bc40\nparent badc6e2c1a1d3c63786a7c3e75385397c33e6754\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554237485 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498036 -0400\n\nKeep spent outputs in PrecomputedTransactionData during validation\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/958acfa3e33fa14e10845ee5fcce514da83a8093",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/958acfa3e33fa14e10845ee5fcce514da83a8093",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/958acfa3e33fa14e10845ee5fcce514da83a8093/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "badc6e2c1a1d3c63786a7c3e75385397c33e6754",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/badc6e2c1a1d3c63786a7c3e75385397c33e6754",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/badc6e2c1a1d3c63786a7c3e75385397c33e6754"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 17,
      "deletions": 8
    },
    "files": [
      {
        "sha": "ba9879079d69c2b8270a64dab826937c3db696c1",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/958acfa3e33fa14e10845ee5fcce514da83a8093/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/958acfa3e33fa14e10845ee5fcce514da83a8093/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=958acfa3e33fa14e10845ee5fcce514da83a8093",
        "patch": "@@ -1215,8 +1215,10 @@ uint256 GetOutputsHash(const T& txTo)\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n     if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n@@ -1230,12 +1232,12 @@ void PrecomputedTransactionData::Init(const T& txTo)\n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n "
      },
      {
        "sha": "cd50a4c6d0bca81874f944fba194eae491f0e912",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/958acfa3e33fa14e10845ee5fcce514da83a8093/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/958acfa3e33fa14e10845ee5fcce514da83a8093/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=958acfa3e33fa14e10845ee5fcce514da83a8093",
        "patch": "@@ -16,6 +16,7 @@\n class CPubKey;\n class CScript;\n class CTransaction;\n+class CTxOut;\n class uint256;\n \n /** Signature hash types/flags */\n@@ -123,11 +124,12 @@ struct PrecomputedTransactionData\n {\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);"
      },
      {
        "sha": "a33fdcdf692126c341bc403c88f4e0a7e15804f6",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/958acfa3e33fa14e10845ee5fcce514da83a8093/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/958acfa3e33fa14e10845ee5fcce514da83a8093/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=958acfa3e33fa14e10845ee5fcce514da83a8093",
        "patch": "@@ -1330,20 +1330,25 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 return true;\n             }\n \n-            txdata.Init(tx);\n+            std::vector<CTxOut> spent_outputs;\n+            spent_outputs.reserve(tx.vin.size());\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n                 assert(!coin.IsSpent());\n+                spent_outputs.emplace_back(coin.out);\n+            }\n \n+            txdata.Init(tx, std::move(spent_outputs));\n+            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 // We very carefully only pass in things to CScriptCheck which\n                 // are clearly committed to by tx' witness hash. This provides\n                 // a sanity check that our caching is not introducing consensus\n                 // failures through additional data in, eg, the coins being\n                 // spent being checked as a part of CScriptCheck.\n \n                 // Verify signature\n-                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n+                CScriptCheck check(txdata.m_spent_outputs[i], tx, i, flags, cacheSigStore, &txdata);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -1357,7 +1362,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // splitting the network between upgraded and\n                         // non-upgraded nodes by banning CONSENSUS-failing\n                         // data providers.\n-                        CScriptCheck check2(coin.out, tx, i,\n+                        CScriptCheck check2(txdata.m_spent_outputs[i], tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n                             return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));"
      }
    ]
  },
  {
    "sha": "63f7c9b716b1bf680f80911abfbdc226e8058dc4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2M2Y3YzliNzE2YjFiZjY4MGY4MDkxMWFiZmJkYzIyNmU4MDU4ZGM0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-02T02:25:17Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:20:49Z"
      },
      "message": "Make PrecomputedTransactionData compatible with taproot sighash",
      "tree": {
        "sha": "f495446146c488f256760371b1fe21f48cf4710f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f495446146c488f256760371b1fe21f48cf4710f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63f7c9b716b1bf680f80911abfbdc226e8058dc4",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3QEZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqfz2zEADDxCkco+OqLlidCTJJd0YE\nG2tcJ/4488cJjnabtKx4IMSUa0IkJbT7ZuJNc8AeUlKDqYoNeqJX1Phn4BbJkFQa\npxXL0jaGchZG+zHepEOx9bbErJpwWKoEyVfkaLyTftCx5iOKjEpKHQ5f9qFJBFY1\nZ2TQiR5wDo21YYPwBNQ+tPGhhBIMVcbg6sK7p/k5RRFiEzxi5Ha8qC2A7hkgRSTq\nwjgxtfZfrcQD6yJ0U13S7nQtUt2myCtUqIcM0JrKLFPm0rals91irTfzYftDgFuk\nAWjk4BccVsCjqrcqRfYF6nvEWaMq16IOFOSmoYfMTzDTvxsJgcOtegsGeDP7aoPe\n2DRzk5h+cSrEV7FZgoUpO1l+x9ck+KcBzFTWtyYEXYph/XwUGw/zC3s8yn2wWY+Q\nZmYhCLyMX1EIn61S24K6zRzF8FLX4LuF9rJf+MGnl/B2JV2ge4oh43pyGsTEevZp\nTHF+1zgc2Re3nMg4c6X5KhLBa5m1cERWiF6Wpzmjl0pk5bMenz+PafX6sCZA7IZq\njlrfk4HoJAZczfDdY9Anr+5QiiC2uJKWmXRTcesPUTV3G5CFC5c92LB7BG+vcwlI\nzrQtZ+zQInzFX1U4mFLOBp3LVgjXUgtKBj4r2kAFvhp/AIX4XT/rNBlG9ttoDedn\nlCB+5qLFJXVHpLHGOLkV+Q==\n=TIU0\n-----END PGP SIGNATURE-----",
        "payload": "tree f495446146c488f256760371b1fe21f48cf4710f\nparent 958acfa3e33fa14e10845ee5fcce514da83a8093\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554171917 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498049 -0400\n\nMake PrecomputedTransactionData compatible with taproot sighash\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63f7c9b716b1bf680f80911abfbdc226e8058dc4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/63f7c9b716b1bf680f80911abfbdc226e8058dc4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63f7c9b716b1bf680f80911abfbdc226e8058dc4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "958acfa3e33fa14e10845ee5fcce514da83a8093",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/958acfa3e33fa14e10845ee5fcce514da83a8093",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/958acfa3e33fa14e10845ee5fcce514da83a8093"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 51,
      "deletions": 14
    },
    "files": [
      {
        "sha": "2b2b689a907c8748eb095202785325b97690268a",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/63f7c9b716b1bf680f80911abfbdc226e8058dc4/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/63f7c9b716b1bf680f80911abfbdc226e8058dc4/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=63f7c9b716b1bf680f80911abfbdc226e8058dc4",
        "patch": "@@ -117,7 +117,7 @@ inline uint160 Hash160(const prevector<N, unsigned char>& vch)\n class CHashWriter\n {\n private:\n-    CHash256 ctx;\n+    CSHA256 ctx;\n \n     const int nType;\n     const int nVersion;\n@@ -135,17 +135,25 @@ class CHashWriter\n     // invalidates the object\n     uint256 GetHash() {\n         uint256 result;\n-        ctx.Finalize((unsigned char*)&result);\n+        unsigned char buf[CSHA256::OUTPUT_SIZE];\n+        ctx.Finalize(buf);\n+        ctx.Reset().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(result.begin());\n+        return result;\n+    }\n+\n+    // invalidates the object\n+    uint256 GetSHA256() {\n+        uint256 result;\n+        ctx.Finalize(result.begin());\n         return result;\n     }\n \n     /**\n      * Returns the first 64 bits from the resulting hash.\n      */\n     inline uint64_t GetCheapHash() {\n-        unsigned char result[CHash256::OUTPUT_SIZE];\n-        ctx.Finalize(result);\n-        return ReadLE64(result);\n+        uint256 result = GetHash();\n+        return ReadLE64(result.begin());\n     }\n \n     template<typename T>"
      },
      {
        "sha": "2fc75459ad248af8e8c6a5273aa74b1a173bf990",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 9,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/63f7c9b716b1bf680f80911abfbdc226e8058dc4/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/63f7c9b716b1bf680f80911abfbdc226e8058dc4/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=63f7c9b716b1bf680f80911abfbdc226e8058dc4",
        "patch": "@@ -1189,7 +1189,14 @@ uint256 GetPrevoutHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 HashAgain(const uint256& hash)\n+{\n+    uint256 result;\n+    CSHA256().Write(hash.begin(), 32).Finalize(result.begin());\n+    return result;\n }\n \n template <class T>\n@@ -1199,7 +1206,7 @@ uint256 GetSequenceHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n template <class T>\n@@ -1209,7 +1216,16 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n@@ -1222,10 +1238,18 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n     if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = HashAgain(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = HashAgain(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = HashAgain(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n@@ -1253,16 +1277,16 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn\n         const bool cacheready = cache && cache->ready;\n \n         if (!(nHashType & SIGHASH_ANYONECANPAY)) {\n-            hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);\n+            hashPrevouts = cacheready ? cache->hashPrevouts : HashAgain(GetPrevoutHash(txTo));\n         }\n \n         if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n-            hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);\n+            hashSequence = cacheready ? cache->hashSequence : HashAgain(GetSequenceHash(txTo));\n         }\n \n \n         if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n-            hashOutputs = cacheready ? cache->hashOutputs : GetOutputsHash(txTo);\n+            hashOutputs = cacheready ? cache->hashOutputs : HashAgain(GetOutputsHash(txTo));\n         } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {\n             CHashWriter ss(SER_GETHASH, 0);\n             ss << txTo.vout[nIn];"
      },
      {
        "sha": "d00db25ab036904166e5fd9b234686cfcd5bb72c",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/63f7c9b716b1bf680f80911abfbdc226e8058dc4/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/63f7c9b716b1bf680f80911abfbdc226e8058dc4/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=63f7c9b716b1bf680f80911abfbdc226e8058dc4",
        "patch": "@@ -122,6 +122,11 @@ bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned i\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n     std::vector<CTxOut> m_spent_outputs;"
      }
    ]
  },
  {
    "sha": "e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2QwYjA2NmUzNTNjZTNiMGE4OWRjMGY0ZmNkYThjZDM0NTU2MDQ1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-03T21:04:57Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:23:04Z"
      },
      "message": "Support for Schnorr signatures in pubkey and SignatureCheckers",
      "tree": {
        "sha": "b5979be206e368b2c3654114ae27eee03762557b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5979be206e368b2c3654114ae27eee03762557b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3YoZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqfyRHD/400sK/JGUAkdMYU8BJz9Qq\n1Bu7fqQelJnacZCOMYALvllglfs5MDNZ2fTz+0OmfeqOuoihZyHNEBej8CfFke4d\npBER69qVwPhlRx5SpTXqMEek/tI/6CgD0e8HvrFjSGCblDQzjD/jjAs5egKATrKo\n82gAqmwvrNV1zW01jH7kd/CSNz7+fTLpiGiu+CCpEYoAgU5li4TdQG22LX1LTvGY\nxQ3VqyNMgfpbXfn/hiDc8LXe7hHf1iZNsLbJURyH/SANCdctSzZ5mBGIGHnao8m3\nZ9XvAqqBLqwN/RKVnI/NOZzoykrzNIl2ON9ShHFFiL1Iq2pPhbP152xWavacEfCw\n0cYiCUuqTr15wc7icvAJPKd38rZC/x7Sy3Flt/9iTdwcMNiVsQnOlxBti7bDl8m+\n3DVEop0Cc1Th5d9ac722slcL1sADzLxsiPkUNFNjaWvCnroeuWVh7Pz10OPB3iwj\ngV0HX4vB55Sy+SL3ByKXcLMEeDvF3ID/GSs/FO56ePls5QBPorf2/zeVY2YamZQG\nXOYFQBLCJ/6Ms+5v3ee0k64ipEqdX1JGPdB6HzVZagg4wfIo+MGQu5i9hrebQ4ns\nx6X2wTZ6ALXvWTsj7zqZwIiuPdIeEueUekKoLPLSQRnEY8I0ckPCaIzsUiIO+5Io\n/Tr0gbRiu1aqbV8tm4npdg==\n=6Hip\n-----END PGP SIGNATURE-----",
        "payload": "tree b5979be206e368b2c3654114ae27eee03762557b\nparent 63f7c9b716b1bf680f80911abfbdc226e8058dc4\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554325497 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498184 -0400\n\nSupport for Schnorr signatures in pubkey and SignatureCheckers\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "63f7c9b716b1bf680f80911abfbdc226e8058dc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63f7c9b716b1bf680f80911abfbdc226e8058dc4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/63f7c9b716b1bf680f80911abfbdc226e8058dc4"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 42,
      "deletions": 11
    },
    "files": [
      {
        "sha": "3e9d8d82cca3bf49f8d1f1ede330e46cf8f14769",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -1622,7 +1622,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --disable-jni\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental --disable-jni\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      },
      {
        "sha": "fa21f84350729f4ec0076752c7f310fefbf1626d",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <secp256k1.h>\n #include <secp256k1_recovery.h>\n+#include <secp256k1_schnorrsig.h>\n \n namespace\n {\n@@ -166,6 +167,17 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+bool CPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned char>& sigbytes) const {\n+    if (!IsValid()) return false;\n+    if (vch[0] != 2 && vch[0] != 3) return false; // Only compressed pubkeys\n+    if (sigbytes.size() != 64) return false;\n+    secp256k1_pubkey pubkey;\n+    secp256k1_schnorrsig sig;\n+    if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, vch, size())) return false;\n+    if (!secp256k1_schnorrsig_parse(secp256k1_context_verify, &sig, sigbytes.data())) return false;\n+    return secp256k1_schnorrsig_verify(secp256k1_context_verify, &sig, hash.begin(), &pubkey);\n+}\n+\n bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n     if (!IsValid())\n         return false;"
      },
      {
        "sha": "4e41bf7ea0f97e7f013aed25301c655da997a04d",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -188,6 +188,11 @@ class CPubKey\n      */\n     bool Verify(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\n \n+    /**\n+     * Verify a Schnorr (DLS) signature (64 bytes)\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& sig) const;\n+\n     /**\n      * Check whether a signature is normalized (lower-S).\n      */"
      },
      {
        "sha": "bc9bafdda4fc16107933e8469a9f9b6aebb1b1ac",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -1336,9 +1336,13 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn\n }\n \n template <class T>\n-bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash, SignatureType sigtype) const\n {\n-    return pubkey.Verify(sighash, vchSig);\n+    switch (sigtype) {\n+    case SignatureType::ECDSA: return pubkey.Verify(sighash, vchSig);\n+    case SignatureType::SCHNORR: return pubkey.VerifySchnorr(sighash, vchSig);\n+    }\n+    assert(false);\n }\n \n template <class T>\n@@ -1357,7 +1361,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifySignature(vchSig, pubkey, sighash, SignatureType::ECDSA))\n         return false;\n \n     return true;"
      },
      {
        "sha": "0fa846c9ac13c704e349f5c65bbdceb452962954",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -174,6 +174,11 @@ class BaseSignatureChecker\n     virtual ~BaseSignatureChecker() {}\n };\n \n+enum class SignatureType {\n+    ECDSA,\n+    SCHNORR\n+};\n+\n template <class T>\n class GenericTransactionSignatureChecker : public BaseSignatureChecker\n {\n@@ -184,7 +189,7 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     const PrecomputedTransactionData* txdata;\n \n protected:\n-    virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash, SignatureType sigtype) const;\n \n public:\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}"
      },
      {
        "sha": "684c1b9a2ce53b7f52d24b6c27b70975e855a0c9",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -35,9 +35,14 @@ class CSignatureCache\n     }\n \n     void\n-    ComputeEntry(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey)\n+    ComputeEntry(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, SignatureType sigtype)\n     {\n-        CSHA256().Write(nonce.begin(), 32).Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(&vchSig[0], vchSig.size()).Finalize(entry.begin());\n+        unsigned char st;\n+        switch (sigtype) {\n+        case SignatureType::ECDSA: st = 'E'; break;\n+        case SignatureType::SCHNORR: st = 'S'; break;\n+        }\n+        CSHA256().Write(nonce.begin(), 32).Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(&st, 1).Write(&vchSig[0], vchSig.size()).Finalize(entry.begin());\n     }\n \n     bool\n@@ -79,13 +84,13 @@ void InitSignatureCache()\n             (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n-bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash, SignatureType sigtype) const\n {\n     uint256 entry;\n-    signatureCache.ComputeEntry(entry, sighash, vchSig, pubkey);\n+    signatureCache.ComputeEntry(entry, sighash, vchSig, pubkey, sigtype);\n     if (signatureCache.Get(entry, !store))\n         return true;\n-    if (!TransactionSignatureChecker::VerifySignature(vchSig, pubkey, sighash))\n+    if (!TransactionSignatureChecker::VerifySignature(vchSig, pubkey, sighash, sigtype))\n         return false;\n     if (store)\n         signatureCache.Set(entry);"
      },
      {
        "sha": "c444f78e6f35f8bb4c30af877f86073c14b73176",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "patch": "@@ -48,7 +48,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n public:\n     CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}\n \n-    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n+    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash, SignatureType sigtype) const override;\n };\n \n void InitSignatureCache();"
      }
    ]
  },
  {
    "sha": "15750103dffdcf6481ed8e4e565d27a9f87f240b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNTc1MDEwM2RmZmRjZjY0ODFlZDhlNGU1NjVkMjdhOWY4N2YyNDBi",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2019-04-04T19:55:35Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:23:12Z"
      },
      "message": "Implement Taproot signature validation\n\n* Integration into CheckSig by Pieter Wuille.",
      "tree": {
        "sha": "3793625c2067cfa3773b05529aad44c84776dfc9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3793625c2067cfa3773b05529aad44c84776dfc9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/15750103dffdcf6481ed8e4e565d27a9f87f240b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3ZAZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf2vAD/9qbnDl03threThcAR1VgFN\n74mhguZzWQNHRpTaHbagIavl3a1dvcPJy1wrT8AisJg4jOumxZLQo3DCgaLtp0kA\nnftYnVIUmP62K8aspuKfuWUL5geHhhNOJ68eE+UcOGY77V70MdKo6E7+IZzBvlAI\ne2ZixIHae6ZhxTvjM5YTQUlL823cDREXhBy3Bg0oNkoHUnWOBh60is8WhfjcbNEW\nThTlodvvIy6tpuB7uXzWAZGu1pFwYCxm3Or+K0C39L/u8sN6UMG6eLhxpMY2dy4N\nuCMBLlSH4jhJOb/pbIoopEYMTinXWx8j6v0eO+yrYX10Vlwp+cEyHmAwC+aazeUk\na7tcox7aqf94pDGlst6BVJXIXZbd5IXMM9lje88NhLQ79ZaGPn3/K/ziiWUVpInf\nlJuQ/M4kYQai7q4fihZU2aRNIUUTeouoTaYfBzY/t9khyAX1U12tAoJH8rHOYe57\npn6JACGEdE0Y9YjD/yu4ZTQTsAW2fJsCqzHoZndOTuCp01a6Y3HFaLRlKV4DPCYy\nWWkaJBTVf0+2zSOwNr5NuRjG/l/AeBqELnUs5N9E/hoOmi4pOJvd46ZnV4El9/9m\nnW6b4iCsVvstLQzh5lz4fPRrXp9CcP5f22Qs4VP/ifb8Xi1r8f0B45zd45U5630p\nnBwFQZQmxNBrsvWIvu2Kmg==\n=wkI8\n-----END PGP SIGNATURE-----",
        "payload": "tree 3793625c2067cfa3773b05529aad44c84776dfc9\nparent e3d0b066e353ce3b0a89dc0f4fcda8cd34556045\nauthor Johnson Lau <jl2012@xbt.hk> 1554407735 +0800\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498192 -0400\n\nImplement Taproot signature validation\n\n* Integration into CheckSig by Pieter Wuille.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15750103dffdcf6481ed8e4e565d27a9f87f240b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/15750103dffdcf6481ed8e4e565d27a9f87f240b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15750103dffdcf6481ed8e4e565d27a9f87f240b/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3d0b066e353ce3b0a89dc0f4fcda8cd34556045"
      }
    ],
    "stats": {
      "total": 120,
      "additions": 111,
      "deletions": 9
    },
    "files": [
      {
        "sha": "76ec7eb4f865b3204066fc4b0eb35e96c2225ce6",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 9,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15750103dffdcf6481ed8e4e565d27a9f87f240b/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15750103dffdcf6481ed8e4e565d27a9f87f240b/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=15750103dffdcf6481ed8e4e565d27a9f87f240b",
        "patch": "@@ -1265,6 +1265,83 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());\n+    writer << taghash << taghash;\n+    return writer;\n+}\n+\n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashTap(uint256& hash_out, const T& tx_to, const unsigned int in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    assert(in_pos < tx_to.vin.size());\n+    assert(sigversion == SigVersion::TAPROOT);\n+    assert(cache.ready && cache.m_amounts_spent_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    uint8_t epoch = 0;\n+    ss << epoch;\n+\n+    // Hash type\n+    if ((hash_type > 3) && (hash_type < 0x81 || hash_type > 0x83)) return false;\n+    ss << hash_type;\n+    const uint8_t input_type = hash_type & SIGHASH_TAPINPUTMASK;\n+    const uint8_t output_type = hash_type & SIGHASH_TAPOUTPUTMASK;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+\n+    if (input_type == SIGHASH_TAPDEFAULT) {\n+        ss << cache.m_prevouts_hash;\n+        ss << cache.m_amounts_spent_hash;\n+        ss << cache.m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_TAPDEFAULT || output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const CScript& scriptPubKey = cache.m_spent_outputs[in_pos].scriptPubKey;\n+    uint8_t spend_type = scriptPubKey.IsPayToScriptHash() ? 1 : 0;\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    if (witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff) {\n+        spend_type |= 2;\n+    }\n+\n+    ss << spend_type;\n+    ss << scriptPubKey;\n+\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos].nValue;\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << uint16_t(in_pos);\n+    }\n+    if (spend_type & 2) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();\n+    }\n+\n+    // Data about the output(s)\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;\n+        CHashWriter sha_single_output(SER_GETHASH, 0);\n+        sha_single_output << tx_to.vout[in_pos];\n+        ss << sha_single_output.GetSHA256();\n+    }\n+\n+    hash_out = ss.GetSHA256();\n+    return true;\n+}\n+\n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)\n {\n@@ -1356,15 +1433,32 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n     std::vector<unsigned char> vchSig(vchSigIn);\n     if (vchSig.empty())\n         return false;\n-    int nHashType = vchSig.back();\n-    vchSig.pop_back();\n-\n-    uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n-\n-    if (!VerifySignature(vchSig, pubkey, sighash, SignatureType::ECDSA))\n-        return false;\n-\n-    return true;\n+    switch (sigversion) {\n+    case SigVersion::BASE:\n+    case SigVersion::WITNESS_V0:\n+        {\n+            int nHashType = vchSig.back();\n+            vchSig.pop_back();\n+            uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n+            return VerifySignature(vchSig, pubkey, sighash, SignatureType::ECDSA);\n+        }\n+    case SigVersion::TAPROOT:\n+        {\n+            uint8_t hashtype = SIGHASH_TAPDEFAULT;\n+            if (vchSig.size() == 65) {\n+                hashtype = vchSig.back();\n+                if (hashtype == SIGHASH_TAPDEFAULT) return false;\n+                vchSig.pop_back();\n+            }\n+            if (vchSig.size() != 64) return false;\n+            uint256 sighash;\n+            bool ret = SignatureHashTap(sighash, *txTo, nIn, hashtype, sigversion, *this->txdata);\n+            if (!ret) return false;\n+            return VerifySignature(vchSig, pubkey, sighash, SignatureType::SCHNORR);\n+        }\n+    default:\n+        assert(false);\n+    }\n }\n \n template <class T>"
      },
      {
        "sha": "6cdfad151e810ce5da8b74b87238ebf74b62ca86",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15750103dffdcf6481ed8e4e565d27a9f87f240b/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15750103dffdcf6481ed8e4e565d27a9f87f240b/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=15750103dffdcf6481ed8e4e565d27a9f87f240b",
        "patch": "@@ -26,6 +26,10 @@ enum\n     SIGHASH_NONE = 2,\n     SIGHASH_SINGLE = 3,\n     SIGHASH_ANYONECANPAY = 0x80,\n+\n+    SIGHASH_TAPDEFAULT = 0,\n+    SIGHASH_TAPOUTPUTMASK = 3,\n+    SIGHASH_TAPINPUTMASK = 0x80,\n };\n \n /** Script verification flags.\n@@ -144,6 +148,7 @@ enum class SigVersion\n {\n     BASE = 0,\n     WITNESS_V0 = 1,\n+    TAPROOT = 2,\n };\n \n /** Signature hash sizes */\n@@ -153,6 +158,9 @@ static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n+template <class T>\n+bool SignatureHashTap(uint256& hash_out, const T& tx_to, unsigned int in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache);\n+\n class BaseSignatureChecker\n {\n public:"
      }
    ]
  },
  {
    "sha": "4673a65062db9a38bdea14ce7ac4baba84edff8f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NjczYTY1MDYyZGI5YTM4YmRlYTE0Y2U3YWM0YmFiYTg0ZWRmZjhm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-08T22:58:57Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:23:18Z"
      },
      "message": "Taproot validation\n\nThis includes key path spending and script path spending, but not the\nTapscript execution implementation.",
      "tree": {
        "sha": "fdd99a1bb84fd4cbdcde0cf7af1cbc9ec658c005",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fdd99a1bb84fd4cbdcde0cf7af1cbc9ec658c005"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4673a65062db9a38bdea14ce7ac4baba84edff8f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3ZYZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf9r+D/92blkS9kmauBCqVOzl4XXX\nUOfd/Ofd53Q4CahatR6MU5KHn6nyyfgEsC2+oPwsae2gxpxg6Zno+hVctaqs/GHq\n9xeuBbECJNBDSHwKQitLgTjA1iXp8AGYTi5MAu/1yVOfEMPj95pLV/yR73a9vGCS\nc6JNSHwJ/XSo+orLP02pQRZI1sSKzfjZSmgT+m2UdQCV6gNbateJUKJxSuF7ykme\nrFZOhzkQI4Y2bCYPZyyzRuZrjqD/kX6sDJV0PE4ZputfP1ajG5JBIMByCgKkFXSM\nEvfuytfWzj6aX2Ew7c/HeLwOxouRHHD4vhxeEKLxakxr9YoZEkMZwa0Ykpriys7z\nMvZah37DJeC/5u+g1BxVX/WO/pTnYHWAVdFuldvQgG6TJzA/liVo8DCyZPxBMdvd\naW74O0iGKsE0QiuPDAyz9V7+cNuFGWNwLWLRX1qddJtEe2qDrCGnX6rhDveVMMqj\nAHxtfXEnVfNjR8Rwh4fu8ZhB6JrkTQWctesx59dTr+VQG6i++sjVtXsHlI3m/V/I\nL+TWrAJpl6ECIxJfTSWCaBAXTNeQaeu2L31q1qo/HZLTh1KFJg2RxaenR468/ite\nr/RkaUrFyKEJdG8JaSBbZLqZogx1OtBFk2H0/1f0oICWxuZdhjG2qqAuKYbTHBVa\nI5TolMDrkU6NJArZX4Rh3A==\n=401l\n-----END PGP SIGNATURE-----",
        "payload": "tree fdd99a1bb84fd4cbdcde0cf7af1cbc9ec658c005\nparent 15750103dffdcf6481ed8e4e565d27a9f87f240b\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554764337 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498198 -0400\n\nTaproot validation\n\nThis includes key path spending and script path spending, but not the\nTapscript execution implementation.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4673a65062db9a38bdea14ce7ac4baba84edff8f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4673a65062db9a38bdea14ce7ac4baba84edff8f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4673a65062db9a38bdea14ce7ac4baba84edff8f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "15750103dffdcf6481ed8e4e565d27a9f87f240b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15750103dffdcf6481ed8e4e565d27a9f87f240b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/15750103dffdcf6481ed8e4e565d27a9f87f240b"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 93,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5bb0d1a527e139f9730a56000ab2ea162a4ba82c",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -283,6 +283,18 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int _nChild) const {\n     return pubkey.Derive(out.pubkey, out.chaincode, _nChild, chaincode);\n }\n \n+bool CPubKey::CheckPayToContract(const CPubKey& base, const uint256& hash) const\n+{\n+    if (!IsCompressed() || !base.IsCompressed()) return false;\n+    secp256k1_pubkey base_point;\n+    if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &base_point, base.vch, base.size())) return false;\n+    if (!secp256k1_ec_pubkey_tweak_add(secp256k1_context_verify, &base_point, hash.begin())) return false;\n+    unsigned char out[COMPRESSED_PUBLIC_KEY_SIZE];\n+    size_t len = COMPRESSED_PUBLIC_KEY_SIZE;\n+    secp256k1_ec_pubkey_serialize(secp256k1_context_verify, out, &len, &base_point, SECP256K1_EC_COMPRESSED);\n+    return memcmp(out, vch, COMPRESSED_PUBLIC_KEY_SIZE) == 0;\n+}\n+\n /* static */ bool CPubKey::CheckLowS(const std::vector<unsigned char>& vchSig) {\n     secp256k1_ecdsa_signature sig;\n     if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, vchSig.data(), vchSig.size())) {"
      },
      {
        "sha": "d102e5be8ec7e0ddeb98b1e452a96dd12160904c",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -206,6 +206,9 @@ class CPubKey\n \n     //! Derive BIP32 child pubkey.\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n+\n+    //! Verify a P2C derivation. Hash must be a cryptographic hash that commits to base.\n+    bool CheckPayToContract(const CPubKey& base, const uint256& hash) const;\n };\n \n struct CExtPubKey {"
      },
      {
        "sha": "9fd5310eea60b591e41aa92cf99c9e526c90d6b0",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -1275,6 +1275,9 @@ CHashWriter TaggedHash(const std::string& tag)\n }\n \n static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n \n template<typename T>\n bool SignatureHashTap(uint256& hash_out, const T& tx_to, const unsigned int in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n@@ -1577,6 +1580,52 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if ((flags & SCRIPT_VERIFY_TAPROOT) && witversion == 1 && program.size() == 33 && (program[0] & 0xfe) == 0) {\n+        std::vector<unsigned char> pubkey = program;\n+        pubkey[0] = 2 + (pubkey[0] & 1);\n+        stack = witness.stack;\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            stack.pop_back();\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending\n+            if (!checker.CheckSig(stack[0], pubkey, /* scriptCode is ignored */ {}, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        }\n+        // Script path spending\n+        auto control = std::move(stack.back());\n+        stack.pop_back();\n+        scriptPubKey = CScript(stack.back().begin(), stack.back().end());\n+        stack.pop_back();\n+        if (control.size() < 33 || control.size() > 33 + 32*32 || (control.size() % 32) != 1) {\n+            return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+        }\n+        int path_len = (control.size() - 33) / 32;\n+        std::vector<unsigned char> basekey(control.begin(), control.begin() + 33);\n+        basekey[0] = 2 + (basekey[0] & 1);\n+        uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & 0xfe) << scriptPubKey).GetSHA256();\n+        for (int i = 0; i < path_len; ++i) {\n+            CHashWriter ss_branch = HasherTapBranch;\n+            if (std::lexicographical_compare(k.begin(), k.end(), control.begin() + 33 + 32*i, control.begin() + 65 + 32*i)) {\n+               ss_branch << k << Span<const unsigned char>(control.data() + 33 + 32*i, 32);\n+            } else {\n+               ss_branch << Span<const unsigned char>(control.data() + 33 + 32*i, 32) << k;\n+            }\n+            k = ss_branch.GetSHA256();\n+        }\n+        k = (CHashWriter(HasherTapTweak) << MakeSpan(basekey) << k).GetSHA256();\n+        CPubKey p(basekey.begin(), basekey.end());\n+        CPubKey q(pubkey.begin(), pubkey.end());\n+        if (!q.CheckPayToContract(p, k)) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION);\n+        }\n+        return set_success(serror);\n     } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n         return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n     } else {"
      },
      {
        "sha": "8094b3b8a3a7ed6ef97fed9f5ed8663418f3084c",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -120,6 +120,16 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot validation\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown taproot inner versions non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown taproot inner versions non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "520e7dea95fc675e6310f7e6839d1a1065c783ab",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -44,6 +44,11 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;\n+\n template <typename T>\n std::vector<unsigned char> ToByteVector(const T& in)\n {"
      },
      {
        "sha": "a95246ce2bc549e21e88c276e1120f682022db57",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -71,6 +71,10 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"NOPx reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM:\n             return \"Witness version reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION:\n+            return \"Taproot version reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX:\n+            return \"Unknown input annex reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_PUBKEYTYPE:\n             return \"Public key is neither compressed or uncompressed\";\n         case SCRIPT_ERR_CLEANSTACK:\n@@ -89,6 +93,10 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Witness provided for non-witness script\";\n         case SCRIPT_ERR_WITNESS_PUBKEYTYPE:\n             return \"Using non-compressed keys in segwit\";\n+        case SCRIPT_ERR_TAPROOT_INVALID_SIG:\n+            return \"Invalid signature for taproot key path spending\";\n+        case SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE:\n+            return \"Invalid taproot control block size\";\n         case SCRIPT_ERR_OP_CODESEPARATOR:\n             return \"Using OP_CODESEPARATOR in non-witness script\";\n         case SCRIPT_ERR_SIG_FINDANDDELETE:"
      },
      {
        "sha": "ab03a7f0cc76a082bc90f779e366a7d855243e53",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4673a65062db9a38bdea14ce7ac4baba84edff8f/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "patch": "@@ -54,6 +54,8 @@ typedef enum ScriptError_t\n     /* softfork safeness */\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,\n+    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION,\n+    SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX,\n \n     /* segregated witness */\n     SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH,\n@@ -64,6 +66,10 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_WITNESS_UNEXPECTED,\n     SCRIPT_ERR_WITNESS_PUBKEYTYPE,\n \n+    /* Taproot */\n+    SCRIPT_ERR_TAPROOT_INVALID_SIG,\n+    SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE,\n+\n     /* Constant scriptCode */\n     SCRIPT_ERR_OP_CODESEPARATOR,\n     SCRIPT_ERR_SIG_FINDANDDELETE,"
      }
    ]
  },
  {
    "sha": "a17aab25478bf78ccfbc23ee715e1751f1371829",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMTdhYWIyNTQ3OGJmNzhjY2ZiYzIzZWU3MTVlMTc1MWYxMzcxODI5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-10T04:24:44Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:28:46Z"
      },
      "message": "Add ScriptExecutionData struct that encapsulates scriptCode",
      "tree": {
        "sha": "a5c2fce37b4e7bdadafda43f2ac0cfce2d8b7b45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5c2fce37b4e7bdadafda43f2ac0cfce2d8b7b45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a17aab25478bf78ccfbc23ee715e1751f1371829",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3uAZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf0hVD/9lk/QUGuMLGccAmo0oIHjJ\ne5LZM0CZWUOve9HTYXkll8ewla112OQs0HpPpxp/Y7IzhFskbYYqQULeVfPbJ7pg\nW50tlNsxP8pCQeUbJoDyntvfotFKxzkVLLWhhZSqtdpTYkxcKgnLk/ZYxgS5NixW\n3RDfaU26UddcWuhtn9DvdoDIRpwX/hwEjE7wAHDetLi7qxzCelgvMCBNr0nu8EB+\nj7bXKKbsIzbnkAZhRrWHLCfEm+oq3som8TragyM/zSFQ54/V+K0fVi6+5v3UZG1j\ngsMn4hJeBsRBSqLY8rVKJ2+Hc8i4waPRjU+y7EldTKhtMF40mHic1TtzbGePyiV+\ntbB6fs3mk82NnsGce8bgfiYiVoYxieZ8AkOUPVfJognKNL7NX9j7QGYy5/l7CdOQ\nBgXDkCyBdOyNulGUf3cniY/Zv/lx2FVSyD7lUP8xPlK5ei/60LIGLvkJIzsGXxIv\nJGy4OMx1+FwBKJmzSqj8fLkbhJCwr/B8Pi5eaC9oaVSWZZSwL7qIuCntYxBVkri7\nidSv/atwKdZTnazTyL94CN8Ltdbfhi+SLMu+WEuDiQFLPTjIBJYkw5mc3xv0PvaW\nsgBu64t7+PGVSpTDTzi0bwK8l1t46aamTISHxFc5JHqFbSnIyZAaVk9uEbTU0Hzp\n95HGYWe2kMymOMEeVLEBdA==\n=yW3H\n-----END PGP SIGNATURE-----",
        "payload": "tree a5c2fce37b4e7bdadafda43f2ac0cfce2d8b7b45\nparent 4673a65062db9a38bdea14ce7ac4baba84edff8f\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554870284 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498526 -0400\n\nAdd ScriptExecutionData struct that encapsulates scriptCode\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a17aab25478bf78ccfbc23ee715e1751f1371829",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a17aab25478bf78ccfbc23ee715e1751f1371829",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a17aab25478bf78ccfbc23ee715e1751f1371829/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4673a65062db9a38bdea14ce7ac4baba84edff8f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4673a65062db9a38bdea14ce7ac4baba84edff8f"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 24,
      "deletions": 16
    },
    "files": [
      {
        "sha": "8692c9b630c197a209aa4677b977f222e08d7775",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a17aab25478bf78ccfbc23ee715e1751f1371829/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a17aab25478bf78ccfbc23ee715e1751f1371829/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=a17aab25478bf78ccfbc23ee715e1751f1371829",
        "patch": "@@ -288,6 +288,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    ScriptExecutionData execdata;\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n     CScript::const_iterator pbegincodehash = script.begin();\n@@ -922,11 +923,11 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     valtype& vchPubKey = stacktop(-1);\n \n                     // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n+                    execdata.m_scriptcode = CScript(pbegincodehash, pend);\n \n                     // Drop the signature in pre-segwit scripts but not segwit scripts\n                     if (sigversion == SigVersion::BASE) {\n-                        int found = FindAndDelete(scriptCode, CScript() << vchSig);\n+                        int found = FindAndDelete(execdata.m_scriptcode, CScript() << vchSig);\n                         if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))\n                             return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);\n                     }\n@@ -935,7 +936,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         //serror is set\n                         return false;\n                     }\n-                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, execdata, sigversion);\n \n                     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n                         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n@@ -985,14 +986,14 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n                     // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n+                    execdata.m_scriptcode = CScript(pbegincodehash, pend);\n \n                     // Drop the signature in pre-segwit scripts but not segwit scripts\n                     for (int k = 0; k < nSigsCount; k++)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n                         if (sigversion == SigVersion::BASE) {\n-                            int found = FindAndDelete(scriptCode, CScript() << vchSig);\n+                            int found = FindAndDelete(execdata.m_scriptcode, CScript() << vchSig);\n                             if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))\n                                 return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);\n                         }\n@@ -1013,7 +1014,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         }\n \n                         // Check signature\n-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+                        bool fOk = checker.CheckSig(vchSig, vchPubKey, execdata, sigversion);\n \n                         if (fOk) {\n                             isig++;\n@@ -1426,7 +1427,7 @@ bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<un\n }\n \n template <class T>\n-bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const ScriptExecutionData& execdata, SigVersion sigversion) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n@@ -1442,7 +1443,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n         {\n             int nHashType = vchSig.back();\n             vchSig.pop_back();\n-            uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n+            uint256 sighash = SignatureHash(execdata.m_scriptcode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n             return VerifySignature(vchSig, pubkey, sighash, SignatureType::ECDSA);\n         }\n     case SigVersion::TAPROOT:\n@@ -1592,7 +1593,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         }\n         if (stack.size() == 1) {\n             // Key path spending\n-            if (!checker.CheckSig(stack[0], pubkey, /* scriptCode is ignored */ {}, SigVersion::TAPROOT)) {\n+            if (!checker.CheckSig(stack[0], pubkey, ScriptExecutionData(), SigVersion::TAPROOT)) {\n                 return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n             }\n             return set_success(serror);"
      },
      {
        "sha": "3b07c04088f58c25994e7a482dbe3596c6a56cce",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a17aab25478bf78ccfbc23ee715e1751f1371829/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a17aab25478bf78ccfbc23ee715e1751f1371829/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=a17aab25478bf78ccfbc23ee715e1751f1371829",
        "patch": "@@ -161,6 +161,11 @@ enum class SigVersion\n     TAPROOT = 2,\n };\n \n+struct ScriptExecutionData\n+{\n+    CScript m_scriptcode;\n+};\n+\n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n@@ -174,7 +179,7 @@ bool SignatureHashTap(uint256& hash_out, const T& tx_to, unsigned int in_pos, ui\n class BaseSignatureChecker\n {\n public:\n-    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const ScriptExecutionData& execdata, SigVersion sigversion) const\n     {\n         return false;\n     }\n@@ -212,7 +217,7 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n public:\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const ScriptExecutionData& execdata, SigVersion sigversion) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };"
      },
      {
        "sha": "99da7dd917f523a9685822b58876bf54b8d2905d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a17aab25478bf78ccfbc23ee715e1751f1371829/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a17aab25478bf78ccfbc23ee715e1751f1371829/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=a17aab25478bf78ccfbc23ee715e1751f1371829",
        "patch": "@@ -252,12 +252,12 @@ class SignatureExtractorChecker final : public BaseSignatureChecker\n \n public:\n     SignatureExtractorChecker(SignatureData& sigdata, BaseSignatureChecker& checker) : sigdata(sigdata), checker(checker) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const ScriptExecutionData& execdata, SigVersion sigversion) const override;\n };\n \n-bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const ScriptExecutionData& execdata, SigVersion sigversion) const\n {\n-    if (checker.CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+    if (checker.CheckSig(scriptSig, vchPubKey, execdata, sigversion)) {\n         CPubKey pubkey(vchPubKey);\n         sigdata.signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n         return true;\n@@ -335,7 +335,9 @@ SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nI\n             for (unsigned int i = last_success_key; i < num_pubkeys; ++i) {\n                 const valtype& pubkey = solutions[i+1];\n                 // We either have a signature for this pubkey, or we have found a signature and it is valid\n-                if (data.signatures.count(CPubKey(pubkey).GetID()) || extractor_checker.CheckSig(sig, pubkey, next_script, sigversion)) {\n+                ScriptExecutionData execdata;\n+                execdata.m_scriptcode = next_script;\n+                if (data.signatures.count(CPubKey(pubkey).GetID()) || extractor_checker.CheckSig(sig, pubkey, execdata, sigversion)) {\n                     last_success_key = i + 1;\n                     break;\n                 }\n@@ -396,7 +398,7 @@ class DummySignatureChecker final : public BaseSignatureChecker\n {\n public:\n     DummySignatureChecker() {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override { return true; }\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const ScriptExecutionData& execdata, SigVersion sigversion) const override { return true; }\n };\n const DummySignatureChecker DUMMY_CHECKER;\n "
      }
    ]
  },
  {
    "sha": "686fd712c157c9dfe89e882ed92953976735e41b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODZmZDcxMmMxNTdjOWRmZTg5ZTg4MmVkOTI5NTM5NzY3MzVlNDFi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-12T22:12:25Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:29:03Z"
      },
      "message": "Use ScriptExecutionData to pass through annex hash",
      "tree": {
        "sha": "861317965cacf3d2dff9dda8edfc95915e72e998",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/861317965cacf3d2dff9dda8edfc95915e72e998"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/686fd712c157c9dfe89e882ed92953976735e41b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e3u8ZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqfxluEADZ0DPY72Ax/KzU8HrxWDwK\n6ch8VxL7b5hIL5xJv1rO6JVYqQebs0VI+A1zrZpFDncb7TOJAnEiF9PXKaXGcVX0\nF8KxmnAXzQs3EaN3hHsOXWzjT8CAj0GQ1yG9cKJS65zmN7eZaymUsUUHFvXNSyFG\nNL5LAHyxR3lydrT9NJo36H3v5PlJjrF+ZxbW99rwzvhx4577jkkfSjdOwH4n1rOg\nHz4YwxRWO4vT2D42JIIRDHc8liAM196wrrh+TEA/1htUWWo2o0OizRPcYHbRUYTl\n/WA+76fuatlC7aZ05fXiYYMVCuOQ0SK0w+pWWNj4yjTt+TODNYRLoQ2rsmaB7i+N\nQlnyXTUEAvNFFtW6bJtgB0Tp4u1MgrH8wm9cxj1XesTI+h534YEH60o5ffflyF16\n1y5aP0qpphR18tSrzX1F6NjFy98DPmETwDyi4DXhMWGNgSJWd621ZZyehMXwNkVh\n6AcyHD960IrZd8aVyTGR82ifIg1oOxVRgttI8YeNiaX1tSwboZAaLxfbElqxHy6/\nJvinItTYQmginI2JYU+SO3syQXyNOHzpvSBGY/Ku2yF4RivR0UJ7nV3KD6t64wzk\n1k2aNbkinsZJnupi6d1ZO0Jmi4LmNDkQN1d3st0ye/uMQMugzZRoKecneFHFWrIr\ndOJq2qZLrWV0TPzJY4DbVg==\n=ZhCX\n-----END PGP SIGNATURE-----",
        "payload": "tree 861317965cacf3d2dff9dda8edfc95915e72e998\nparent a17aab25478bf78ccfbc23ee715e1751f1371829\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1555107145 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566498543 -0400\n\nUse ScriptExecutionData to pass through annex hash\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/686fd712c157c9dfe89e882ed92953976735e41b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/686fd712c157c9dfe89e882ed92953976735e41b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/686fd712c157c9dfe89e882ed92953976735e41b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a17aab25478bf78ccfbc23ee715e1751f1371829",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a17aab25478bf78ccfbc23ee715e1751f1371829",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a17aab25478bf78ccfbc23ee715e1751f1371829"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 21,
      "deletions": 12
    },
    "files": [
      {
        "sha": "732b6059844096552376735a664f86ef9cb80048",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/686fd712c157c9dfe89e882ed92953976735e41b/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/686fd712c157c9dfe89e882ed92953976735e41b/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=686fd712c157c9dfe89e882ed92953976735e41b",
        "patch": "@@ -278,7 +278,7 @@ int FindAndDelete(CScript& script, const CScript& b)\n     return nFound;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, ScriptExecutionData execdata)\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n@@ -288,7 +288,6 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n-    ScriptExecutionData execdata;\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n     CScript::const_iterator pbegincodehash = script.begin();\n@@ -1281,7 +1280,7 @@ static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n \n template<typename T>\n-bool SignatureHashTap(uint256& hash_out, const T& tx_to, const unsigned int in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const unsigned int in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n {\n     assert(in_pos < tx_to.vin.size());\n     assert(sigversion == SigVersion::TAPROOT);\n@@ -1315,8 +1314,8 @@ bool SignatureHashTap(uint256& hash_out, const T& tx_to, const unsigned int in_p\n     // Data about the input/prevout being spent\n     const CScript& scriptPubKey = cache.m_spent_outputs[in_pos].scriptPubKey;\n     uint8_t spend_type = scriptPubKey.IsPayToScriptHash() ? 1 : 0;\n-    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n-    if (witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff) {\n+    assert(execdata.m_annex_init);\n+    if (execdata.m_annex_present) {\n         spend_type |= 2;\n     }\n \n@@ -1330,8 +1329,8 @@ bool SignatureHashTap(uint256& hash_out, const T& tx_to, const unsigned int in_p\n     } else {\n         ss << uint16_t(in_pos);\n     }\n-    if (spend_type & 2) {\n-        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();\n+    if (execdata.m_annex_present) {\n+        ss << execdata.m_annex_hash;\n     }\n \n     // Data about the output(s)\n@@ -1456,7 +1455,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n             }\n             if (vchSig.size() != 64) return false;\n             uint256 sighash;\n-            bool ret = SignatureHashTap(sighash, *txTo, nIn, hashtype, sigversion, *this->txdata);\n+            bool ret = SignatureHashTap(sighash, execdata, *txTo, nIn, hashtype, sigversion, *this->txdata);\n             if (!ret) return false;\n             return VerifySignature(vchSig, pubkey, sighash, SignatureType::SCHNORR);\n         }\n@@ -1557,6 +1556,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n {\n     std::vector<std::vector<unsigned char> > stack;\n     CScript scriptPubKey;\n+    ScriptExecutionData execdata;\n \n     if (witversion == 0) {\n         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n@@ -1589,11 +1589,16 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n             // Drop annex\n             if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << stack.back()).GetSHA256();\n+            execdata.m_annex_present = true;\n             stack.pop_back();\n+        } else {\n+            execdata.m_annex_present = false;\n         }\n+        execdata.m_annex_init = true;\n         if (stack.size() == 1) {\n             // Key path spending\n-            if (!checker.CheckSig(stack[0], pubkey, ScriptExecutionData(), SigVersion::TAPROOT)) {\n+            if (!checker.CheckSig(stack[0], pubkey, execdata, SigVersion::TAPROOT)) {\n                 return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n             }\n             return set_success(serror);\n@@ -1640,7 +1645,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror, execdata)) {\n         return false;\n     }\n "
      },
      {
        "sha": "2fa90f7bac0382eb44c813cbec792321c6dc77d4",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/686fd712c157c9dfe89e882ed92953976735e41b/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/686fd712c157c9dfe89e882ed92953976735e41b/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=686fd712c157c9dfe89e882ed92953976735e41b",
        "patch": "@@ -164,6 +164,10 @@ enum class SigVersion\n struct ScriptExecutionData\n {\n     CScript m_scriptcode;\n+\n+    bool m_annex_init = false;\n+    bool m_annex_present;\n+    uint256 m_annex_hash;\n };\n \n /** Signature hash sizes */\n@@ -174,7 +178,7 @@ template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n template <class T>\n-bool SignatureHashTap(uint256& hash_out, const T& tx_to, unsigned int in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache);\n+bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, unsigned int in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache);\n \n class BaseSignatureChecker\n {\n@@ -225,7 +229,7 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr, ScriptExecutionData execdata = {});\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);\n \n size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags);"
      }
    ]
  },
  {
    "sha": "ebcfe3584199f281f825625dcadef8535dece536",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYmNmZTM1ODQxOTlmMjgxZjgyNTYyNWRjYWRlZjg1MzVkZWNlNTM2",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2019-04-09T09:10:38Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:41:10Z"
      },
      "message": "Tapscript",
      "tree": {
        "sha": "64b06a9aab5727f4925da0fe4b644351641eab76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64b06a9aab5727f4925da0fe4b644351641eab76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ebcfe3584199f281f825625dcadef8535dece536",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e4cwZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf+U3D/9wIIFfpPwJbyRSjrBTWfzM\nE55vK+iwsu2am6RleuwDDYhmuAbIfn8oPz6oX33OyPtnPcbj6JOpHwrREkptXAgs\ngGKel6HogzYeZaNeVncma7K0Bh1XDQiR2SMq9Ghw2hKCTPBZiYTpeXdPHcVeNM/p\n+3e3F4oEdFQu7qYfQtI2M2HK/Q3Ad4RK5S+0ahgoBHQ0FPVTe282i9LTME3O095s\nKqN7Kgu4yl8xAYMKUu21VmLla6x3a7A43AoKUVG2oadquqT0oMqA1l/+Vf/Ovkw0\nyNtmWsZ76VPrzGFukypUyN50MFW8pP1iZULIhITbcIO6Xp6Wwl+xKx/9/Gyvzjke\nkhUCt8zLOoNQkq2Q9HueY4+48NZvfc2uZssshFyHrsQdwZwEBUJN2vVoXUYbpCIp\nvN2+nHu7wIMfUB5hj9vgkhBjr22FIt+p30hDFlQ5bjuAr0OTS7yyQW+4QAHGRiQC\nGdYWL4xvKNVc1XMGHO81XA0cdu/aAqMxk4Qs/do9HWlVIY9rLyva0i8z1XPOwsoq\n3ceY6I1Tc8fKlvKRxmu3hEHCzSUZYef7Q3N9y4w5hIhBps07lDIX2Tr045jzJt5c\nzI9yZpcs4WhbSYgVIS2PKHUJ2/6Nc3DvBeRkcGhagxqgzlDeNB/R8+FiOTdYpuV/\nI3oketNt0jw4S0A9mbixag==\n=ODyU\n-----END PGP SIGNATURE-----",
        "payload": "tree 64b06a9aab5727f4925da0fe4b644351641eab76\nparent 686fd712c157c9dfe89e882ed92953976735e41b\nauthor Johnson Lau <jl2012@xbt.hk> 1554801038 +0800\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566499270 -0400\n\nTapscript\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebcfe3584199f281f825625dcadef8535dece536",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ebcfe3584199f281f825625dcadef8535dece536",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebcfe3584199f281f825625dcadef8535dece536/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "686fd712c157c9dfe89e882ed92953976735e41b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/686fd712c157c9dfe89e882ed92953976735e41b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/686fd712c157c9dfe89e882ed92953976735e41b"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 159,
      "deletions": 17
    },
    "files": [
      {
        "sha": "99143695fa7db06b7c3efc219690d52ae12b8871",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 107,
        "deletions": 17,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebcfe3584199f281f825625dcadef8535dece536/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebcfe3584199f281f825625dcadef8535dece536/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=ebcfe3584199f281f825625dcadef8535dece536",
        "patch": "@@ -300,6 +300,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    uint32_t sigops_passed = 0;\n+    uint16_t opcode_pos = 0;\n+    execdata.m_codeseparator_pos = 0xFFFF;\n \n     try\n     {\n@@ -475,7 +478,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::TAPSCRIPT || (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF))) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n                             if (vch.size() == 1 && vch[0] != 1)\n@@ -908,19 +911,33 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n \n                     // Hash starts after the code separator\n                     pbegincodehash = pc;\n+                    execdata.m_codeseparator_pos = opcode_pos;\n                 }\n                 break;\n \n                 case OP_CHECKSIG:\n                 case OP_CHECKSIGVERIFY:\n+                case OP_CHECKSIGADD:\n                 {\n+                    if (opcode == OP_CHECKSIGADD && sigversion <= SigVersion::WITNESS_V0) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+                    }\n+                    const int args = (opcode == OP_CHECKSIGADD) ? 3 : 2;\n+\n                     // (sig pubkey -- bool)\n-                    if (stack.size() < 2)\n+                    if (stack.size() < (size_t)args)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n-                    valtype& vchSig    = stacktop(-2);\n-                    valtype& vchPubKey = stacktop(-1);\n+                    const valtype& vchSig    = stacktop(-args);\n+                    const valtype& vchPubKey = stacktop(-1);\n+                    const CScriptNum num = (opcode == OP_CHECKSIGADD) ? CScriptNum(stacktop(-2), fRequireMinimal) : bnZero;\n+\n+                    bool fSuccess;\n \n+                    switch (sigversion)\n+                    {\n+                    case SigVersion::BASE:\n+                    case SigVersion::WITNESS_V0:\n                     // Subset of script starting at the most recent codeseparator\n                     execdata.m_scriptcode = CScript(pbegincodehash, pend);\n \n@@ -935,27 +952,62 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         //serror is set\n                         return false;\n                     }\n-                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, execdata, sigversion);\n+                    fSuccess = checker.CheckSig(vchSig, vchPubKey, execdata, sigversion);\n \n                     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n                         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                    break;\n \n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-                    if (opcode == OP_CHECKSIGVERIFY)\n+                    case SigVersion::TAPSCRIPT:\n                     {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return set_error(serror, SCRIPT_ERR_CHECKSIGVERIFY);\n+                        /*\n+                         *  The following validation sequence is consensus critical. Please note how --\n+                         *    upgradable public key versions precede other rules;\n+                         *    the script execution fails when using empty signature with invalid public key;\n+                         *    the script execution fails when using non-empty invalid signature.\n+                         */\n+                        fSuccess = !vchSig.empty();\n+                        if (vchPubKey.empty() || vchPubKey[0] == 4 || vchPubKey[0] == 6 || vchPubKey[0] == 7) {\n+                            return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n+                        } else if (vchPubKey[0] == 2 || vchPubKey[0] == 3) {\n+                            if (!IsCompressedPubKey(vchPubKey)) return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n+                            if (fSuccess && !checker.CheckSig(vchSig, vchPubKey, execdata, sigversion)) {\n+                                return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                            }\n+                        } else {\n+                            /*\n+                             *  New public key version softforks should be defined before this `else` block.\n+                             *  Generally, the new code should not do anything but failing the script execution. To avoid\n+                             *  consensus bugs, it must not alter any existing values (including fSuccess and sigops_passed).\n+                             */\n+                            if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+                                return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+                            }\n+                        }\n+                        // Note how the first passing signature is not counted.\n+                        // Passing with upgradable public key version is also counted.\n+                        assert(execdata.m_witness_weight_init);\n+                        if (fSuccess && (sigops_passed++ * VALIDATION_WEIGHT_PER_SIGOP_PASSED > execdata.m_witness_weight)) {\n+                            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+                        }\n                     }\n+                    break;\n+\n+                    default: assert(false);\n+                    }\n+\n+                    for (int i = 0; i < args; ++i) popstack(stack);\n+                    if (opcode == OP_CHECKSIGVERIFY && !fSuccess) return set_error(serror, SCRIPT_ERR_CHECKSIGVERIFY);\n+                    if (opcode == OP_CHECKSIG) stack.push_back(fSuccess ? vchTrue : vchFalse);\n+                    if (opcode == OP_CHECKSIGADD) stack.push_back((num + (fSuccess ? 1 : 0)).getvch());\n                 }\n                 break;\n \n                 case OP_CHECKMULTISIG:\n                 case OP_CHECKMULTISIGVERIFY:\n                 {\n+                    if (sigversion == SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE);\n+\n                     // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n \n                     int i = 1;\n@@ -1070,6 +1122,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             // Size limits\n             if (stack.size() + altstack.size() > MAX_STACK_SIZE)\n                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+\n+            ++opcode_pos;\n         }\n     }\n     catch (...)\n@@ -1283,7 +1337,7 @@ template<typename T>\n bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const unsigned int in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n {\n     assert(in_pos < tx_to.vin.size());\n-    assert(sigversion == SigVersion::TAPROOT);\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n     assert(cache.ready && cache.m_amounts_spent_ready);\n \n     CHashWriter ss = HasherTapSighash;\n@@ -1318,6 +1372,9 @@ bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, co\n     if (execdata.m_annex_present) {\n         spend_type |= 2;\n     }\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        spend_type |= 4;\n+    }\n \n     ss << spend_type;\n     ss << scriptPubKey;\n@@ -1341,6 +1398,14 @@ bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, co\n         ss << sha_single_output.GetSHA256();\n     }\n \n+    // Additional data for tapscript\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        assert(execdata.m_tapleaf_hash_init);\n+        ss << execdata.m_tapleaf_hash;\n+        ss << uint8_t(2); // key_version\n+        ss << execdata.m_codeseparator_pos;\n+    }\n+\n     hash_out = ss.GetSHA256();\n     return true;\n }\n@@ -1446,6 +1511,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n             return VerifySignature(vchSig, pubkey, sighash, SignatureType::ECDSA);\n         }\n     case SigVersion::TAPROOT:\n+    case SigVersion::TAPSCRIPT:\n         {\n             uint8_t hashtype = SIGHASH_TAPDEFAULT;\n             if (vchSig.size() == 65) {\n@@ -1556,9 +1622,11 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n {\n     std::vector<std::vector<unsigned char> > stack;\n     CScript scriptPubKey;\n+    SigVersion sigversion;\n     ScriptExecutionData execdata;\n \n     if (witversion == 0) {\n+        sigversion = SigVersion::WITNESS_V0;\n         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n             // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n             if (witness.stack.size() == 0) {\n@@ -1615,6 +1683,8 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         std::vector<unsigned char> basekey(control.begin(), control.begin() + 33);\n         basekey[0] = 2 + (basekey[0] & 1);\n         uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & 0xfe) << scriptPubKey).GetSHA256();\n+        execdata.m_tapleaf_hash = k;\n+        execdata.m_tapleaf_hash_init = true;\n         for (int i = 0; i < path_len; ++i) {\n             CHashWriter ss_branch = HasherTapBranch;\n             if (std::lexicographical_compare(k.begin(), k.end(), control.begin() + 33 + 32*i, control.begin() + 65 + 32*i)) {\n@@ -1628,10 +1698,30 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         CPubKey p(basekey.begin(), basekey.end());\n         CPubKey q(pubkey.begin(), pubkey.end());\n         if (!q.CheckPayToContract(p, k)) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n-        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n+        if ((control[0] & 0xfe) == 0xc0) {\n+            sigversion = SigVersion::TAPSCRIPT;\n+            CScript::const_iterator pc = scriptPubKey.begin();\n+            while (pc < scriptPubKey.end()) {\n+                opcodetype opcode;\n+                if (!scriptPubKey.GetOp(pc, opcode)) {\n+                    // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                    return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+                }\n+                // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+                if (IsOpSuccess(opcode)) {\n+                    if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                        return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                    }\n+                    return set_success(serror);\n+                }\n+            }\n+            execdata.m_witness_weight = ::GetSerializeSize(witness.stack, PROTOCOL_VERSION);\n+            execdata.m_witness_weight_init = true;\n+        } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION);\n+        } else {\n+            return set_success(serror);\n         }\n-        return set_success(serror);\n     } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n         return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n     } else {\n@@ -1645,7 +1735,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror, execdata)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) {\n         return false;\n     }\n "
      },
      {
        "sha": "9696293afb677006e095efc0b7e81e4c5cb34914",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebcfe3584199f281f825625dcadef8535dece536/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebcfe3584199f281f825625dcadef8535dece536/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=ebcfe3584199f281f825625dcadef8535dece536",
        "patch": "@@ -130,6 +130,12 @@ enum\n \n     // Making unknown taproot inner versions non-standard\n     SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions in tapscript non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n@@ -159,15 +165,23 @@ enum class SigVersion\n     BASE = 0,\n     WITNESS_V0 = 1,\n     TAPROOT = 2,\n+    TAPSCRIPT = 3,\n };\n \n struct ScriptExecutionData\n {\n     CScript m_scriptcode;\n \n+    bool m_tapleaf_hash_init = false;\n+    uint256 m_tapleaf_hash;\n+    uint16_t m_codeseparator_pos;\n+\n     bool m_annex_init = false;\n     bool m_annex_present;\n     uint256 m_annex_hash;\n+\n+    bool m_witness_weight_init = false;\n+    size_t m_witness_weight;\n };\n \n /** Signature hash sizes */"
      },
      {
        "sha": "2e59bcb30d43f85eb81b85a2e6111eb366715021",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebcfe3584199f281f825625dcadef8535dece536/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebcfe3584199f281f825625dcadef8535dece536/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=ebcfe3584199f281f825625dcadef8535dece536",
        "patch": "@@ -138,6 +138,9 @@ const char* GetOpName(opcodetype opcode)\n     case OP_NOP9                   : return \"OP_NOP9\";\n     case OP_NOP10                  : return \"OP_NOP10\";\n \n+    // taproot\n+    case OP_CHECKSIGADD            : return \"OP_CHECKSIGADD\";\n+\n     case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n \n     default:\n@@ -326,3 +329,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||\n+            opcode == 0x8a || opcode == 0x8d || opcode == 0x8e ||\n+            (opcode >= 0x7e && opcode <= 0x81) || (opcode >= 0x83 && opcode <= 0x86) ||\n+            (opcode >= 0x95 && opcode <= 0x99) || (opcode >= 0xbb && opcode <= 0xfe));\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "db6e2ed8c126121d67fa711ebc81cab29d77409c",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebcfe3584199f281f825625dcadef8535dece536/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebcfe3584199f281f825625dcadef8535dece536/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=ebcfe3584199f281f825625dcadef8535dece536",
        "patch": "@@ -49,6 +49,10 @@ static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n // has meanings independent of the script\n static const unsigned int ANNEX_TAG = 0x50;\n \n+// Validation weight per passing signature (tapscript only)\n+// The first passing signature is not counted\n+static const size_t VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n+\n template <typename T>\n std::vector<unsigned char> ToByteVector(const T& in)\n {\n@@ -192,6 +196,9 @@ enum opcodetype\n     OP_NOP9 = 0xb8,\n     OP_NOP10 = 0xb9,\n \n+    // taproot\n+    OP_CHECKSIGADD = 0xba,\n+\n     OP_INVALIDOPCODE = 0xff,\n };\n \n@@ -588,4 +595,15 @@ struct CScriptWitness\n     std::string ToString() const;\n };\n \n+class CReserveScript\n+{\n+public:\n+    CScript reserveScript;\n+    virtual void KeepScript() {}\n+    CReserveScript() {}\n+    virtual ~CReserveScript() {}\n+};\n+\n+bool IsOpSuccess(const opcodetype& opcode);\n+\n #endif // BITCOIN_SCRIPT_SCRIPT_H"
      },
      {
        "sha": "865b49cf6cbf9545e963e6c767c4c9999b5a54f9",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebcfe3584199f281f825625dcadef8535dece536/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebcfe3584199f281f825625dcadef8535dece536/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=ebcfe3584199f281f825625dcadef8535dece536",
        "patch": "@@ -75,6 +75,10 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Taproot version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX:\n             return \"Unknown input annex reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_OP_SUCCESS:\n+            return \"SUCCESSx reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE:\n+            return \"Public key version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_PUBKEYTYPE:\n             return \"Public key is neither compressed or uncompressed\";\n         case SCRIPT_ERR_CLEANSTACK:\n@@ -97,6 +101,8 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Invalid signature for taproot key path spending\";\n         case SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE:\n             return \"Invalid taproot control block size\";\n+        case SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT:\n+            return \"Too much signature validation relative to witness weight\";\n         case SCRIPT_ERR_OP_CODESEPARATOR:\n             return \"Using OP_CODESEPARATOR in non-witness script\";\n         case SCRIPT_ERR_SIG_FINDANDDELETE:"
      },
      {
        "sha": "fb9832797e90002bf358ea273324c71732325662",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebcfe3584199f281f825625dcadef8535dece536/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebcfe3584199f281f825625dcadef8535dece536/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=ebcfe3584199f281f825625dcadef8535dece536",
        "patch": "@@ -56,6 +56,8 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION,\n     SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX,\n+    SCRIPT_ERR_DISCOURAGE_OP_SUCCESS,\n+    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE,\n \n     /* segregated witness */\n     SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH,\n@@ -69,6 +71,7 @@ typedef enum ScriptError_t\n     /* Taproot */\n     SCRIPT_ERR_TAPROOT_INVALID_SIG,\n     SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE,\n+    SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT,\n \n     /* Constant scriptCode */\n     SCRIPT_ERR_OP_CODESEPARATOR,"
      }
    ]
  },
  {
    "sha": "be0cf6cc0dd8d988581fdb1506b5335a9803e107",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTBjZjZjYzBkZDhkOTg4NTgxZmRiMTUwNmI1MzM1YTk4MDNlMTA3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-10T05:53:24Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:44:15Z"
      },
      "message": "Indent the legacy branch in CHECKSIG interpreter code correctly",
      "tree": {
        "sha": "4079cf13fdd448e24363dc89de8114eb7c17e4c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4079cf13fdd448e24363dc89de8114eb7c17e4c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be0cf6cc0dd8d988581fdb1506b5335a9803e107",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e4oEZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf4IMEAC+oRzZArUZliZdyWGvP9OB\nAIZfVTyZP/zbhYxBQ/b4uTUkE1rW8FdBj+CUh5PmiUSWaA24rZJJSju7n6214H1T\nlg8cdQXiPGYTrWkuAziKNaO9uRfieXUxpJhGYX1jDo+bKPj67fFniIAJIP2PHP85\n5O3lFr4dUchcuDABfKH/9YrbdZuJ6xYbXyumqAIot7eRMwxcM5ne5/6U1fdlg4kq\nulT1WrvPZja8G9zTnZkpNDcztlGSgamiHQFmJbHudbdzTHOsUdpxleVg4EYdyweW\n3V7scZs+ol9u5VvCOW0RVAT7BESQ4C4Jvhhz/2oAb0HkIKreZhHRhuzsGrdWUItn\nWUQoT4bcUX/CvnwxAbGC8Jd5uVOgyyIrQsARh5j/ewTGFU+YQDA+KUmOHmrXYgro\nPuMR6a3rep69m/AGnFcjzSRw5KRGzTm0z5VnfaV9bAkVfm1tG12uSU+z3UbUFu6t\nY9VEteQgmsDS5qc1PrDJy1+nZpyclCmhkAM+5Gkz/6csh0cYew3bhw3/lL0YZFjy\nUGAgIqPt+ZgvYFgdsI92RVxna2Ksi7k17Cnm5RT93WPSsHG/b0vUkwW3nLcrgO1W\nJMEfVKFfJBES66Q+56UE/nnvHeYBpiF63wltD5W248zVvQV8+l+B+fTSYPrr9E88\nLXAW6nJRoCkg7qdZe6YyuA==\n=o0SZ\n-----END PGP SIGNATURE-----",
        "payload": "tree 4079cf13fdd448e24363dc89de8114eb7c17e4c2\nparent ebcfe3584199f281f825625dcadef8535dece536\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1554875604 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566499455 -0400\n\nIndent the legacy branch in CHECKSIG interpreter code correctly\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be0cf6cc0dd8d988581fdb1506b5335a9803e107",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be0cf6cc0dd8d988581fdb1506b5335a9803e107",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be0cf6cc0dd8d988581fdb1506b5335a9803e107/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ebcfe3584199f281f825625dcadef8535dece536",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebcfe3584199f281f825625dcadef8535dece536",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ebcfe3584199f281f825625dcadef8535dece536"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 17,
      "deletions": 15
    },
    "files": [
      {
        "sha": "e6acb724be85570ad1057edb5d4e14884f70a956",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 15,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be0cf6cc0dd8d988581fdb1506b5335a9803e107/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be0cf6cc0dd8d988581fdb1506b5335a9803e107/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=be0cf6cc0dd8d988581fdb1506b5335a9803e107",
        "patch": "@@ -938,24 +938,26 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     {\n                     case SigVersion::BASE:\n                     case SigVersion::WITNESS_V0:\n-                    // Subset of script starting at the most recent codeseparator\n-                    execdata.m_scriptcode = CScript(pbegincodehash, pend);\n+                    {\n+                        // Subset of script starting at the most recent codeseparator\n+                        execdata.m_scriptcode = CScript(pbegincodehash, pend);\n \n-                    // Drop the signature in pre-segwit scripts but not segwit scripts\n-                    if (sigversion == SigVersion::BASE) {\n-                        int found = FindAndDelete(execdata.m_scriptcode, CScript() << vchSig);\n-                        if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))\n-                            return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);\n-                    }\n+                        // Drop the signature in pre-segwit scripts but not segwit scripts\n+                        if (sigversion == SigVersion::BASE) {\n+                            int found = FindAndDelete(execdata.m_scriptcode,  CScript() << vchSig);\n+                            if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))\n+                                return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);\n+                        }\n \n-                    if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n-                        //serror is set\n-                        return false;\n-                    }\n-                    fSuccess = checker.CheckSig(vchSig, vchPubKey, execdata, sigversion);\n+                        if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n+                            //serror is set\n+                            return false;\n+                        }\n+                        fSuccess = checker.CheckSig(vchSig, vchPubKey, execdata, sigversion);\n \n-                    if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n-                        return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                        if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n+                            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                    }\n                     break;\n \n                     case SigVersion::TAPSCRIPT:"
      }
    ]
  },
  {
    "sha": "906bc454634693b1aa4beff62f61d189ee5178cc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDZiYzQ1NDYzNDY5M2IxYWE0YmVmZjYyZjYxZDE4OWVlNTE3OGNj",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2019-04-15T18:50:22Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:46:22Z"
      },
      "message": "Taproot policy change",
      "tree": {
        "sha": "565de4ceab43445750d419eab94b3f0c6d572be4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/565de4ceab43445750d419eab94b3f0c6d572be4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/906bc454634693b1aa4beff62f61d189ee5178cc",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e4v8ZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqfyP2D/wI2k/l42q4acKN2Gy+3XRK\n/6uDyjH9t57hia61cfYOrxYhHGKVBoL8+SAoLqvagRx1TUUHcVY4aCDLVrRuzHR9\nZ6deh/d0rK7Arnpu4vhr0d2gTzgFSUGrELlRIfu3E+v4rlbzhl7cJYlhCGxZzu70\nkJaIBgOfIiz8owZDZuRPXS6Wr0cyhjc/ocsaQ3SfCErxng4wXoqR2ssn6gC6IBfJ\n2hyFzZpjQr/+yWwSNHeOgeeJ2t6fNrJLoWeZwPGwnMdJzSvGDL7YQ5oOGoLQhKog\n+s4IjrQ9pNicxZBoB3Ogi9wDQc5kXp7HkoYSpXGCIbqAfR3fKlxyw2ch/1beAIiH\n1FtC/lObN+sKb7Fe0witYVmSeefGjKh8rqxdyjwwb+o0mj6I7SiDoRrSKrSC0zLr\nO23AtsF19uuXGZhDUSi5QKl0frKRZDLC2GlIv6sNZSJ7Vtl8LlHo28pEVdnAQKwe\nNiNaAx8vdJZPnwJVHwPlwfTYQd2Ix6mgYM1rwXePqxMITcJAmbiSyrtY80Q8znoP\niQ46qyHC8pnENgXax0ReH3mLbh4hPOpTAXN/SEJUulmiZG4elj8fE1nGIyYNr8Fm\n6TCGqDygRvHdJj8s090iNTVfze96qjPpIfoxxoO5bZkE4D8C0tSDD9JQaXGG0BpW\npEKom7uUCxg7uf9SrCYsoA==\n=5wL5\n-----END PGP SIGNATURE-----",
        "payload": "tree 565de4ceab43445750d419eab94b3f0c6d572be4\nparent be0cf6cc0dd8d988581fdb1506b5335a9803e107\nauthor Johnson Lau <jl2012@xbt.hk> 1555354222 +0800\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566499582 -0400\n\nTaproot policy change\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/906bc454634693b1aa4beff62f61d189ee5178cc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/906bc454634693b1aa4beff62f61d189ee5178cc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/906bc454634693b1aa4beff62f61d189ee5178cc/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be0cf6cc0dd8d988581fdb1506b5335a9803e107",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be0cf6cc0dd8d988581fdb1506b5335a9803e107",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be0cf6cc0dd8d988581fdb1506b5335a9803e107"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 61,
      "deletions": 36
    },
    "files": [
      {
        "sha": "80bf3a20cc8683fdad6bc99110b83aaaa4e39079",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 10,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/906bc454634693b1aa4beff62f61d189ee5178cc/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/906bc454634693b1aa4beff62f61d189ee5178cc/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=906bc454634693b1aa4beff62f61d189ee5178cc",
        "patch": "@@ -219,16 +219,27 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         if (!prevScript.IsWitnessProgram(witnessversion, witnessprogram))\n             return false;\n \n-        // Check P2WSH standard limits\n-        if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n-            if (tx.vin[i].scriptWitness.stack.back().size() > MAX_STANDARD_P2WSH_SCRIPT_SIZE)\n-                return false;\n-            size_t sizeWitnessStack = tx.vin[i].scriptWitness.stack.size() - 1;\n-            if (sizeWitnessStack > MAX_STANDARD_P2WSH_STACK_ITEMS)\n-                return false;\n-            for (unsigned int j = 0; j < sizeWitnessStack; j++) {\n-                if (tx.vin[i].scriptWitness.stack[j].size() > MAX_STANDARD_P2WSH_STACK_ITEM_SIZE)\n-                    return false;\n+        auto stack = tx.vin[i].scriptWitness.stack;\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            return false; // annex is non-standard\n+        }\n+\n+        bool p2wsh = (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE);\n+        bool taproot = (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && (witnessprogram[0] & 0xfe) == 0);\n+\n+        // Preprocessing for TAPROOT\n+        if (taproot) {\n+            if (stack.size() <= 1) return true;\n+            stack.pop_back();\n+        }\n+\n+        // Check P2WSH and TAPROOT standard limits\n+        if (p2wsh || taproot) {\n+            if (stack.back().size() > MAX_STANDARD_WITNESS_SCRIPT_SIZE) return false;\n+            stack.pop_back();\n+            if (stack.size() > MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS) return false;\n+            for (const auto& item : stack) {\n+                if (item.size() > MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE) return false;\n             }\n         }\n     }"
      },
      {
        "sha": "eb45c039cfb5a15445279fecc4a999e27f747462",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/906bc454634693b1aa4beff62f61d189ee5178cc/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/906bc454634693b1aa4beff62f61d189ee5178cc/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=906bc454634693b1aa4beff62f61d189ee5178cc",
        "patch": "@@ -36,12 +36,12 @@ static const unsigned int DEFAULT_INCREMENTAL_RELAY_FEE = 1000;\n static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\n /** Default for -permitbaremultisig */\n static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n-/** The maximum number of witness stack items in a standard P2WSH script */\n-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n-/** The maximum size of each witness stack item in a standard P2WSH script */\n-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n-/** The maximum size of a standard witnessScript */\n-static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n+/** The maximum number of witness input stack items in a standard witness script */\n+static const unsigned int MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS = 210;\n+/** The maximum size of each witness stack item in a standard witness script */\n+static const unsigned int MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE = 80;\n+/** The maximum size of a standard witness script */\n+static const unsigned int MAX_STANDARD_WITNESS_SCRIPT_SIZE = 7100;\n /** Min feerate for defining dust. Historically this has been based on the\n  * minRelayTxFee, however changing the dust limit changes which transactions are\n  * standard and should be done with care and ideally rarely. It makes sense to\n@@ -68,7 +68,12 @@ static constexpr unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VE\n                                                              SCRIPT_VERIFY_WITNESS |\n                                                              SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\n                                                              SCRIPT_VERIFY_WITNESS_PUBKEYTYPE |\n-                                                             SCRIPT_VERIFY_CONST_SCRIPTCODE;\n+                                                             SCRIPT_VERIFY_CONST_SCRIPTCODE |\n+                                                             SCRIPT_VERIFY_TAPROOT |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE;\n \n /** For convenience, standard but not mandatory verify flags. */\n static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;"
      },
      {
        "sha": "d5a464ee60e94b5aacb3705256b420ca2b305b95",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/906bc454634693b1aa4beff62f61d189ee5178cc/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/906bc454634693b1aa4beff62f61d189ee5178cc/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=906bc454634693b1aa4beff62f61d189ee5178cc",
        "patch": "@@ -187,6 +187,7 @@ struct ScriptExecutionData\n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 33;\n \n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);"
      },
      {
        "sha": "8218671b2cdbaeb2abcf43399190aebfb6da1fb7",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 27,
        "deletions": 19,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/906bc454634693b1aa4beff62f61d189ee5178cc/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/906bc454634693b1aa4beff62f61d189ee5178cc/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=906bc454634693b1aa4beff62f61d189ee5178cc",
        "patch": "@@ -89,6 +89,12 @@\n MAX_SIGOP_COST = 80000\n \n SEGWIT_HEIGHT = 120\n+MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS = 210\n+MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE = 80\n+MAX_STANDARD_WITNESS_SCRIPT_SIZE = 7100\n+# Extra restrictions make tests easier\n+assert MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS < 403 and (MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS % 2) == 0\n+assert MAX_STANDARD_WITNESS_SCRIPT_SIZE % 50 == 0\n \n class UTXO():\n     \"\"\"Used to keep track of anyone-can-spend outputs that we can use in the tests.\"\"\"\n@@ -1797,10 +1803,12 @@ def test_non_standard_witness(self):\n \n         # Create scripts for tests\n         scripts = []\n-        scripts.append(CScript([OP_DROP] * 100))\n-        scripts.append(CScript([OP_DROP] * 99))\n-        scripts.append(CScript([pad * 59] * 59 + [OP_DROP] * 60))\n-        scripts.append(CScript([pad * 59] * 59 + [OP_DROP] * 61))\n+        scripts.append(CScript([OP_2DROP] * (MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS // 2)))\n+        scripts.append(CScript([OP_2DROP] * (MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS // 2 - 1) + [OP_DROP]))\n+        scripts.append(CScript([pad * 48] * (MAX_STANDARD_WITNESS_SCRIPT_SIZE // 50) + [OP_DROP] * (MAX_STANDARD_WITNESS_SCRIPT_SIZE // 50)))\n+        scripts.append(CScript([pad * 48] * (MAX_STANDARD_WITNESS_SCRIPT_SIZE // 50) + [OP_DROP] * (MAX_STANDARD_WITNESS_SCRIPT_SIZE // 50 + 1)))\n+        assert len(scripts[2]) == MAX_STANDARD_WITNESS_SCRIPT_SIZE\n+        assert len(scripts[3]) == MAX_STANDARD_WITNESS_SCRIPT_SIZE + 1\n \n         p2wsh_scripts = []\n \n@@ -1840,45 +1848,45 @@ def test_non_standard_witness(self):\n             p2sh_txs.append(p2sh_tx)\n \n         # Testing native P2WSH\n-        # Witness stack size, excluding witnessScript, over 100 is non-standard\n-        p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n+        # Witness stack size, excluding witnessScript, over MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS is non-standard\n+        p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * (MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS + 1) + [scripts[0]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[0], True, True)\n \n-        # Stack element size over 80 bytes is non-standard\n-        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n+        # Stack element size over MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE bytes is non-standard\n+        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * (MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE + 1)] * MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS + [scripts[1]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[1], True, True)\n-        # Standard nodes should accept if element size is not over 80 bytes\n-        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n+        # Standard nodes should accept if element size is not over MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE\n+        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE] * MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS + [scripts[1]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, True)\n \n-        # witnessScript size at 3600 bytes is standard\n-        p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n+        # witnessScript size at 7100 bytes is standard\n+        p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, scripts[2]]\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[2], True, True)\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[2], True, True)\n \n-        # witnessScript size at 3601 bytes is non-standard\n-        p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n+        # witnessScript size at 7101 bytes is non-standard\n+        p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[3]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[3], True, True)\n \n         # Repeating the same tests with P2SH-P2WSH\n-        p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n+        p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * (MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS + 1) + [scripts[0]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[0], True, True)\n-        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n+        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * (MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE + 1)] * MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS + [scripts[1]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[1], True, True)\n-        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n+        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * MAX_STANDARD_WITNESS_INPUT_STACK_ITEM_SIZE] * MAX_STANDARD_WITNESS_INPUT_STACK_ITEMS + [scripts[1]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, True)\n-        p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n+        p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, scripts[2]]\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[2], True, True)\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[2], True, True)\n-        p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n+        p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[3]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n "
      }
    ]
  },
  {
    "sha": "912753ca71c9884a647bfc98b1e3c9ccca965119",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MTI3NTNjYTcxYzk4ODRhNjQ3YmZjOThiMWUzYzljY2NhOTY1MTE5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-18T09:17:47Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:53:11Z"
      },
      "message": "Activate taproot on regtest",
      "tree": {
        "sha": "a4433cffc0e7b06ac0129beaf2d6d619b26b240f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a4433cffc0e7b06ac0129beaf2d6d619b26b240f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/912753ca71c9884a647bfc98b1e3c9ccca965119",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e5JgZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqf2VREACNKvJxRIcHVtE+BvrSIgYS\nSZRr6gcmFiNGLeg8zJZ+1uPU4m0euR9wlXPMzGDL6edAVW3sHQyDPD6eUC7Yj/Qy\nuakPCQQZF+fT82R9q63hUgdHDjM+5LzLvPjG+p6TKGE8xCVKmeqeHmQReiUyT2Dm\nhXxk0ceNukwKzmnfguXjmgOX/DclasiyPxpe3/Rfnxm4wcnozkKzBr9H7jgiQyrs\nFqU43XTuQ7V+8aj56AYii6eiVGMy2kVoL7VxkqXn28Hxgh/cY5QEESFkgii2DUXo\nZSQslktDS91n4k5ABa47VYXMCs4lJzBlbbAcltdD/yVIDucCR+5pzHUIW6vc/3+7\nVzBt7L0i3ej0MKCzbZ+KwQfP4xqC8fxY2SPgkykX1oG0IIxvL78yKnfqdUsxMsgB\nU3CN4Ap9gM9G5I1wBpCcQFeMNFpoAMtDR/fshOlc7dSGiQAaDMhhDbyVRbMsVxXo\nLsMZN/LziKRbrAnW2JcUrox6vi5XBa4+z057xhrScwUyV5KdINNpcevMy8gQ9K5u\nS2zbLC5Xhc7dFx8UbaZi4a7jwbechZdtpmK9c7VXESThaxb1Yc6JrWRNE71+Q5bl\nbd3XTDUJ/eo48JkIqJXLBFT35KZCVldj4sigVhiaCHvlIsn/BICWeES/2cQ2rcps\nquDppP7SjP2gMPAAYRpGeg==\n=oOuG\n-----END PGP SIGNATURE-----",
        "payload": "tree a4433cffc0e7b06ac0129beaf2d6d619b26b240f\nparent 906bc454634693b1aa4beff62f61d189ee5178cc\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1555579067 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566499991 -0400\n\nActivate taproot on regtest\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/912753ca71c9884a647bfc98b1e3c9ccca965119",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/912753ca71c9884a647bfc98b1e3c9ccca965119",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/912753ca71c9884a647bfc98b1e3c9ccca965119/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "906bc454634693b1aa4beff62f61d189ee5178cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/906bc454634693b1aa4beff62f61d189ee5178cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/906bc454634693b1aa4beff62f61d189ee5178cc"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 23,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2d4f7250db1eddde7f60beeacdfde35dd769720a",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/912753ca71c9884a647bfc98b1e3c9ccca965119/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/912753ca71c9884a647bfc98b1e3c9ccca965119/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=912753ca71c9884a647bfc98b1e3c9ccca965119",
        "patch": "@@ -82,6 +82,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n+\n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000051dc8b82f450202ecb3d471\");\n \n@@ -188,6 +193,11 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n+\n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000007dbe94253893cbd463\");\n \n@@ -271,6 +281,9 @@ class CRegTestParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00\");"
      },
      {
        "sha": "5aac8351b40bbb1f03983118167c055b5c2ee20c",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/912753ca71c9884a647bfc98b1e3c9ccca965119/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/912753ca71c9884a647bfc98b1e3c9ccca965119/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=912753ca71c9884a647bfc98b1e3c9ccca965119",
        "patch": "@@ -16,6 +16,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of bip-taproot/bip-tapscript/bip-schnorr\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n };"
      },
      {
        "sha": "b2bcbab55e94643f8e91166f18ce45318c601724",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/912753ca71c9884a647bfc98b1e3c9ccca965119/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/912753ca71c9884a647bfc98b1e3c9ccca965119/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=912753ca71c9884a647bfc98b1e3c9ccca965119",
        "patch": "@@ -1695,6 +1695,11 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n     }\n \n+    // Start enforcing Taproot using versionbits logic.\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache) == ThresholdState::ACTIVE) {\n+        flags |= SCRIPT_VERIFY_TAPROOT;\n+    }\n+    \n     // Start enforcing BIP147 NULLDUMMY (activated simultaneously with segwit)\n     if (IsWitnessEnabled(pindex->pprev, consensusparams)) {\n         flags |= SCRIPT_VERIFY_NULLDUMMY;"
      },
      {
        "sha": "21bd8e4c2a7ce04d5252fb7a238211ffea71366b",
        "filename": "src/versionbitsinfo.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/912753ca71c9884a647bfc98b1e3c9ccca965119/src/versionbitsinfo.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/912753ca71c9884a647bfc98b1e3c9ccca965119/src/versionbitsinfo.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbitsinfo.cpp?ref=912753ca71c9884a647bfc98b1e3c9ccca965119",
        "patch": "@@ -11,4 +11,8 @@ const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_B\n         /*.name =*/ \"testdummy\",\n         /*.gbt_force =*/ true,\n     },\n+    {\n+        /*.name =*/ \"taproot\",\n+        /*.gbt_force =*/ true,\n+    },\n };"
      }
    ]
  },
  {
    "sha": "00708a2029d13a3876cb01a566dc6e93330674af",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDcwOGEyMDI5ZDEzYTM4NzZjYjAxYTU2NmRjNmU5MzMzMDY3NGFm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-16T23:38:06Z"
      },
      "committer": {
        "name": "Elichai Turkel",
        "email": "elichai.turkel@gmail.com",
        "date": "2019-08-22T18:53:44Z"
      },
      "message": "[TESTS] Tests for Taproot/Schnorr/Tapscript\n\nIncludes sighashing code and many tests by Johnson Lau.",
      "tree": {
        "sha": "057d28b11e518704b4e902477036d1ae45de6f05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/057d28b11e518704b4e902477036d1ae45de6f05"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00708a2029d13a3876cb01a566dc6e93330674af",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJNBAABCAA3FiEEC5PUstyhDoo+NyfXk4PN6ejman8FAl1e5LoZHGVsaWNoYWku\ndHVya2VsQGdtYWlsLmNvbQAKCRCTg83p6OZqfy2MEAC77lqlKEssT05CV+808lsq\nL7zurPonVQ+bPZchN3JSJRuOkQBSjos2ieSWKDdTPVU5IYWECXry8WZjR+ZdHmJh\ntJGlrvyOIEqy61R3FS4rR4m+V7vaVfEIWLm7KzZL7RWvFFmsgPPGqaN9z9Bw7lxS\n+jXcSBnS6vyWyfMEUIMmKwDRMmvxpXuX0k/e67mvK8M01InQ4OjkEeyC/f8QgpZA\nv18oVVGm7DgXNdIHTsZVHoklUai7/qV48TqFNn0T7hjFvc1Mq0oraEpYiz4QcHiT\n0HnmEoAZwR/rXsPqFTMJtYGOsyZq2AwS3sMEg1zW9QFvtZ6PN8KryfP4rUHGCR1I\nhLc5+xsWgidyc1ZYmTYTOt/6YcjZMRfHlmIwOQsgClvGvN5WSJMAL9HOaHqbZiyP\nO+n6Eq677FzpMu/uNsvhTEh9e6vfgSMYaQ/9f6kCwX6QW6RBmXZT3uU//Y1cr1rZ\namKgy9RZmt5niPQCAadBp3e8SqCx1miWhhS/1KlFOwIUDTPoFy/+v6zZHV0dhaLU\nh3bC78NLp3E8z3BG/CouLEfu0T9N+NZV9IPiww5g5eKtlpw5iKNxek6DgG3pDSyd\nAHvjvqg04GE4dnEty4oLVUwTXw9McQi1vpaFWv1IUS4RuIi8S0WddMObKESSF7D+\neDV2QAjJXH45jFsLkgvIFA==\n=6xEc\n-----END PGP SIGNATURE-----",
        "payload": "tree 057d28b11e518704b4e902477036d1ae45de6f05\nparent 912753ca71c9884a647bfc98b1e3c9ccca965119\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1555457886 -0700\ncommitter Elichai Turkel <elichai.turkel@gmail.com> 1566500024 -0400\n\n[TESTS] Tests for Taproot/Schnorr/Tapscript\n\nIncludes sighashing code and many tests by Johnson Lau.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00708a2029d13a3876cb01a566dc6e93330674af",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00708a2029d13a3876cb01a566dc6e93330674af",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00708a2029d13a3876cb01a566dc6e93330674af/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "elichai",
      "id": 2167860,
      "node_id": "MDQ6VXNlcjIxNjc4NjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/elichai",
      "html_url": "https://github.com/elichai",
      "followers_url": "https://api.github.com/users/elichai/followers",
      "following_url": "https://api.github.com/users/elichai/following{/other_user}",
      "gists_url": "https://api.github.com/users/elichai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/elichai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
      "organizations_url": "https://api.github.com/users/elichai/orgs",
      "repos_url": "https://api.github.com/users/elichai/repos",
      "events_url": "https://api.github.com/users/elichai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/elichai/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "912753ca71c9884a647bfc98b1e3c9ccca965119",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/912753ca71c9884a647bfc98b1e3c9ccca965119",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/912753ca71c9884a647bfc98b1e3c9ccca965119"
      }
    ],
    "stats": {
      "total": 644,
      "additions": 631,
      "deletions": 13
    },
    "files": [
      {
        "sha": "9d5e3299f6ad9c6f5fc6a8eea3074f8326dc1b32",
        "filename": "test/functional/feature_taproot.py",
        "status": "added",
        "additions": 443,
        "deletions": 0,
        "changes": 443,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=00708a2029d13a3876cb01a566dc6e93330674af",
        "patch": "@@ -0,0 +1,443 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test taproot softfork.\n+\n+from test_framework.blocktools import create_coinbase, create_block, create_transaction, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, GetP2SH, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, DEFAULT_TAPSCRIPT_VER, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_RESERVED, OP_1NEGATE, OP_EQUAL, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, assert_raises_rpc_error, hex_str_to_bytes\n+from test_framework.key import ECKey\n+from test_framework.address import program_to_witness, script_to_p2sh\n+from binascii import hexlify\n+from hashlib import sha256\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_taproot_p2sh(info):\n+    return script_to_p2sh(info[0])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_tapscript_ver(no_annex_tag=True):\n+    ret = DEFAULT_TAPSCRIPT_VER\n+    while (ret == DEFAULT_TAPSCRIPT_VER or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def random_script(size, no_success = True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num+1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b)*8))).to_bytes(len(b), 'big')\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, p2sh, key, annex=None, hashtype=0, prefix=[], suffix=[], script=None, pos=-1, damage=False):\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        key = key.tweak_add(info[1])\n+        assert(key is not None)\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath = True, tapscript = script, codeseparator_pos = pos, annex = annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath = False, annex = annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = key.sign_schnorr(sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+    # Construct P2SH redeemscript\n+    if p2sh:\n+        tx.vin[input_index].scriptSig = CScript([info[0]])\n+\n+def spend_alwaysvalid(tx, input_index, info, p2sh, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for tapscript version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE*2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+    # Construct P2SH redeemscript\n+    if p2sh:\n+        tx.vin[input_index].scriptSig = CScript([info[0]])\n+\n+def spender_sighash_mutation(spenders, info, p2sh, comment, standard=True, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+    if p2sh:\n+        spk = GetP2SH(spk)\n+        addr = get_taproot_p2sh(info)\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, p2sh=p2sh, **kwargs)\n+    spenders.append((spk, addr, comment, standard, fn))\n+\n+def spender_alwaysvalid(spenders, info, p2sh, comment, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+    if p2sh:\n+        spk = GetP2SH(spk)\n+        addr = get_taproot_p2sh(info)\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, p2sh=p2sh, **kwargs)\n+    spenders.append((spk, addr, comment, False, fn))\n+\n+class TAPROOTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, cb_pubkey=None, fees=0, witness=False, accept=False):\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(block.serialize(True).hex())\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: \" + msg\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Each spender is a tuple of:\n+        - A scriptPubKey (CScript)\n+        - An address for that scriptPubKey (string)\n+        - A comment describing the test (string)\n+        - Whether the spending (on itself) is expected to be standard (bool)\n+        - A lambda taking as inputs:\n+          - A transaction to sign (CTransaction)\n+          - An input position (int)\n+          - The spent UTXOs by this transaction (list of CTxOut)\n+          - Whether to produce a valid spend (bool)\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a UTXO to spend for each of the spenders\n+        self.nodes[0].generate(110)\n+        bal = self.nodes[0].getbalance() * 3 / (4*len(spenders))\n+        random.shuffle(spenders)\n+        num_spenders = len(spenders)\n+        utxos = []\n+        while len(spenders):\n+            # Create the necessary outputs in multiple transactions, as sPKs may be repeated (which sendmany does not support)\n+            outputs = {}\n+            new_spenders = []\n+            batch = []\n+            for spender in spenders:\n+                addr = spender[1]\n+                if addr in outputs:\n+                    new_spenders.append(spender)\n+                else:\n+                    amount = random.randrange(int(bal * 95000000), int(bal * 105000000))\n+                    outputs[addr] = amount / 100000000\n+                    batch.append(spender)\n+            self.log.info(\"Constructing %i UTXOs for spending tests\" % len(batch))\n+            tx = tx_from_hex(self.nodes[0].getrawtransaction(self.nodes[0].sendmany(\"\", outputs)))\n+            tx.rehash()\n+            spenders = new_spenders\n+            random.shuffle(spenders)\n+\n+            # Map created UTXOs back to the spenders they were created for\n+            for n, out in enumerate(tx.vout):\n+                for spender in batch:\n+                    if out.scriptPubKey == spender[0]:\n+                        utxos.append((COutPoint(tx.sha256, n), out, spender))\n+                        break\n+        assert(len(utxos) == num_spenders)\n+        random.shuffle(utxos)\n+        self.nodes[0].generate(1)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"Constructing 100 addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(100):\n+            addr = self.nodes[0].getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = self.nodes[0].getaddressinfo(addr)\n+            spk = hex_str_to_bytes(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(hex_str_to_bytes(info['pubkey']))\n+\n+        # Pick random subsets of UTXOs to construct transactions with\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        block = self.nodes[0].getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+        while len(utxos):\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000,0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000 # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200) # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight+1) # all block heights in the past\n+\n+            # Pick 1 to 4 UTXOs to construct transaction inputs\n+            acceptable_input_counts = [cnt for cnt in input_counts if cnt <= len(utxos)]\n+            while True:\n+                inputs = random.choice(acceptable_input_counts)\n+                remaining = len(utxos) - inputs\n+                if remaining == 0 or remaining >= max(input_counts) or remaining in input_counts:\n+                    break\n+            input_utxos = utxos[-inputs:]\n+            utxos = utxos[:-inputs]\n+            fee = random.randrange(MIN_FEE * 2, MIN_FEE * 4) # 10000-20000 sat fee\n+            in_value = sum(utxo[1].nValue for utxo in input_utxos) - fee\n+            tx.vin = [CTxIn(outpoint = input_utxos[i][0], nSequence = random.randint(min_sequence, 0xffffffff)) for i in range(inputs)]\n+            tx.wit.vtxinwit = [CTxInWitness() for i in range(inputs)]\n+            self.log.info(\"Test: %s\" % (\", \".join(utxo[2][2] for utxo in input_utxos)))\n+\n+            # Add 1 to 4 outputs\n+            outputs = random.choice([1,2,3,4])\n+            assert in_value >= 0 and fee - outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+            fee += in_value\n+            assert(fee >= 0)\n+\n+            # For each inputs, make it fail once; then succeed once\n+            for fail_input in range(inputs + 1):\n+                # Wipe scriptSig/witness\n+                for i in range(inputs):\n+                    tx.vin[i].scriptSig = CScript()\n+                    tx.wit.vtxinwit[i] = CTxInWitness()\n+                # Fill inputs/witnesses\n+                for i in range(inputs):\n+                    fn = input_utxos[i][2][4]\n+                    fn(tx, i, [utxo[1] for utxo in input_utxos], i != fail_input)\n+                # Submit to mempool to check standardness\n+                standard = fail_input == inputs and all(utxo[2][3] for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                if standard:\n+                    self.nodes[0].sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert(self.nodes[0].getmempoolentry(tx.hash) is not None)\n+                else:\n+                    assert_raises_rpc_error(-26, None, self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                tx.rehash()\n+                msg = ','.join(utxo[2][2] + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                self.block_submit(self.nodes[0], [tx], msg, witness=True, accept=fail_input == inputs, cb_pubkey=random.choice(host_pubkeys), fees=fee)\n+\n+    def run_test(self):\n+        VALID_SIGHASHES = [0,1,2,3,0x81,0x82,0x83]\n+        spenders = []\n+\n+        for p2sh in [False, True]:\n+            random_annex = bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 5))\n+            for annex in [None, random_annex]:\n+                standard = annex is None\n+                sec1, sec2 = ECKey(), ECKey()\n+                sec1.generate()\n+                sec2.generate()\n+                pub1, pub2 = sec1.get_pubkey(), sec2.get_pubkey()\n+\n+                # Sighash mutation tests\n+                for hashtype in VALID_SIGHASHES:\n+                    # Pure pubkey\n+                    info = taproot_construct(pub1, [])\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=standard)\n+                    # Pubkey/P2PK script combination\n+                    scripts = [CScript(random_checksig_style(pub2.get_bytes()))]\n+                    info = taproot_construct(pub1, scripts)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/p2pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=standard)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/p2pk#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=standard)\n+                    # More complex script structure\n+                    scripts = [\n+                        CScript(random_checksig_style(pub2.get_bytes()) + bytes([OP_CODESEPARATOR])), # codesep after checksig\n+                        CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2.get_bytes())), # codesep before checksig\n+                        CScript([bytes([1,2,3]), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1.get_bytes(), OP_ELSE, OP_CODESEPARATOR, pub2.get_bytes(), OP_ENDIF, OP_CHECKSIG]), # branch dependent codesep\n+                    ]\n+                    info = taproot_construct(pub1, scripts)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/codesep#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=standard)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/codesep#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=standard)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/codesep#s1\", script=scripts[1], key=sec2, hashtype=hashtype, annex=annex, pos=0, standard=standard)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/codesep#s2a\", script=scripts[2], key=sec1, hashtype=hashtype, annex=annex, pos=3, suffix=[bytes([1])], standard=standard)\n+                    spender_sighash_mutation(spenders, info, p2sh, \"sighash/codesep#s2b\", script=scripts[2], key=sec2, hashtype=hashtype, annex=annex, pos=6, suffix=[bytes([])], standard=standard)\n+\n+                # OP_SUCCESSx and unknown tapscript versions\n+                scripts = [\n+                    CScript([random_op_success()]),\n+                    CScript([OP_0, OP_IF, random_op_success(), OP_ENDIF, OP_RETURN]),\n+                    CScript([random_op_success(), OP_VERIF]),\n+                    CScript(random_script(10000) + bytes([random_op_success()]) + random_invalid_push(random.randint(1,10))),\n+                    (random_unknown_tapscript_ver(), CScript([OP_RETURN])),\n+                    (random_unknown_tapscript_ver(), CScript(random_script(10000) + random_invalid_push(random.randint(1,10)))),\n+                    (ANNEX_TAG & 0xfe, CScript()),\n+                ]\n+                info = taproot_construct(pub1, scripts)\n+                spender_sighash_mutation(spenders, info, p2sh, \"alwaysvalid/pk\", key=sec1, hashtype=random.choice(VALID_SIGHASHES), annex=annex, standard=standard)\n+                spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/success\", script=scripts[0], annex=annex)\n+                spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/success#if\", script=scripts[1], annex=annex)\n+                spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/success#verif\", script=scripts[2], annex=annex)\n+                spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/success#10000+\", script=scripts[3], annex=annex)\n+                spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/unknownversion#return\", script=scripts[4], annex=annex)\n+                spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/unknownversion#10000+\", script=scripts[5], annex=annex)\n+                if (info[2][scripts[6][1]][0] != ANNEX_TAG or annex is not None):\n+                    # Annex is mandatory for control block with version 0x50\n+                    spender_alwaysvalid(spenders, info, p2sh, \"alwaysvalid/unknownversion#fe\", script=scripts[6], annex=annex)\n+\n+        # Run all tests once with individual inputs, once with groups of inputs\n+        self.test_spenders(spenders, input_counts=[1])\n+        self.test_spenders(spenders, input_counts=[2,3,4])\n+\n+\n+if __name__ == '__main__':\n+    TAPROOTTest().main()"
      },
      {
        "sha": "2c1a73a607e053b39fe3cc4241de28bdc3d89224",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=00708a2029d13a3876cb01a566dc6e93330674af",
        "patch": "@@ -99,8 +99,8 @@ def script_BIP34_coinbase_height(height):\n     return CScript([CScriptNum(height)])\n \n \n-def create_coinbase(height, pubkey=None):\n-    \"\"\"Create a coinbase transaction, assuming no miner fees.\n+def create_coinbase(height, pubkey=None, fees=0):\n+    \"\"\"Create a coinbase transaction.\n \n     If pubkey is passed in, the coinbase output will be a P2PK output;\n     otherwise an anyone-can-spend output.\"\"\"\n@@ -110,6 +110,7 @@ def create_coinbase(height, pubkey=None):\n     coinbaseoutput.nValue = 50 * COIN\n     halvings = int(height / 150)  # regtest\n     coinbaseoutput.nValue >>= halvings\n+    coinbaseoutput.nValue += fees\n     if (pubkey is not None):\n         coinbaseoutput.scriptPubKey = CScript([pubkey, OP_CHECKSIG])\n     else:"
      },
      {
        "sha": "b3c283623692eea64a792efdc1b877368944f108",
        "filename": "test/functional/test_framework/key.py",
        "status": "modified",
        "additions": 61,
        "deletions": 1,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/key.py?ref=00708a2029d13a3876cb01a566dc6e93330674af",
        "patch": "@@ -7,6 +7,7 @@\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n anything but tests.\"\"\"\n import random\n+import hashlib\n \n def modinv(a, n):\n     \"\"\"Compute the modular inverse of a modulo n\n@@ -212,7 +213,8 @@ def mul(self, ps):\n                     r = self.add(r, p)\n         return r\n \n-SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n+SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n@@ -322,6 +324,38 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+    def verify_schnorr(self, sig, msg):\n+        assert(len(msg) == 32)\n+        assert(len(sig) == 64)\n+        assert(self.valid)\n+        assert(self.compressed)\n+        r = int.from_bytes(sig[0:32], 'big')\n+        if r >= SECP256K1_FIELD_SIZE:\n+            return False\n+        s = int.from_bytes(sig[32:64], 'big')\n+        if s >= SECP256K1_ORDER:\n+            return False\n+        e = int.from_bytes(hashlib.sha256(sig[0:32] + self.get_bytes() + msg).digest(), 'big') % SECP256K1_ORDER\n+        R = SECP256K1.mul([(SECP256K1_G, s), (self.p, SECP256K1_ORDER - e)])\n+        if R[2] == 0 or jacobi_symbol(R[1] * R[2], SECP256K1_FIELD_SIZE) != 1 or ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+            return False\n+        return True\n+\n+    def tweak_add(self, tweak):\n+        assert(self.valid)\n+        assert(len(tweak) == 32)\n+        t = int.from_bytes(tweak, 'big')\n+        if t >= SECP256K1_ORDER:\n+            return None\n+        tweaked = SECP256K1.affine(SECP256K1.mul([(self.p, 1), (SECP256K1_G, t)]))\n+        if tweaked is None:\n+            return None\n+        ret = ECPubKey()\n+        ret.p = tweaked\n+        ret.valid = True\n+        ret.compressed = self.compressed\n+        return ret\n+\n class ECKey():\n     \"\"\"A secp256k1 private key\"\"\"\n \n@@ -384,3 +418,29 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+    def sign_schnorr(self, msg):\n+        \"\"\"Construct a bip-schnorr compatible signature with this key.\"\"\"\n+        assert(self.valid)\n+        assert(self.compressed)\n+        assert(len(msg) == 32)\n+        kp = int.from_bytes(hashlib.sha256(self.get_bytes() + msg).digest(), 'big') % SECP256K1_ORDER\n+        assert(kp != 0)\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+        k = kp if jacobi_symbol(R[1], SECP256K1_FIELD_SIZE) == 1 else SECP256K1_ORDER - kp\n+        e = int.from_bytes(hashlib.sha256(R[0].to_bytes(32, 'big') + self.get_pubkey().get_bytes() + msg).digest(), 'big') % SECP256K1_ORDER\n+        return R[0].to_bytes(32, 'big') + ((k + e*self.secret) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+    def tweak_add(self, tweak):\n+        \"\"\"Return a tweaked version of this private key.\"\"\"\n+        assert(self.valid)\n+        assert(len(tweak) == 32)\n+        t = int.from_bytes(tweak, 'big')\n+        if t >= SECP256K1_ORDER:\n+            return None\n+        tweaked = (self.secret + t) % SECP256K1_ORDER\n+        if tweaked == 0:\n+            return None\n+        ret = ECKey()\n+        ret.set(tweaked.to_bytes(32, 'big'), self.compressed)\n+        return ret"
      },
      {
        "sha": "962d2687f4883fe6bce6e8c3ad4f3b5766ae3b35",
        "filename": "test/functional/test_framework/script.py",
        "status": "modified",
        "additions": 123,
        "deletions": 10,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script.py?ref=00708a2029d13a3876cb01a566dc6e93330674af",
        "patch": "@@ -7,17 +7,23 @@\n This file is modified from python-bitcoinlib.\n \"\"\"\n \n-from .messages import CTransaction, CTxOut, sha256, hash256, uint256_from_str, ser_uint256, ser_string\n+from .messages import CTransaction, CTxOut, sha256, hash256, uint256_from_str, ser_uint256, ser_string, CTxInWitness\n+from .key import ECKey, ECPubKey\n \n import hashlib\n import struct\n \n from .bignum import bn2vch\n \n MAX_SCRIPT_ELEMENT_SIZE = 520\n+LOCKTIME_THRESHOLD = 500000000\n+ANNEX_TAG = 0x50\n \n OPCODE_NAMES = {}\n \n+DEFAULT_TAPSCRIPT_VER = 0xc0\n+TAPROOT_VER = 0\n+\n def hash160(s):\n     return hashlib.new('ripemd160', sha256(s)).digest()\n \n@@ -223,11 +229,8 @@ def __new__(cls, n):\n OP_NOP9 = CScriptOp(0xb8)\n OP_NOP10 = CScriptOp(0xb9)\n \n-# template matching params\n-OP_SMALLINTEGER = CScriptOp(0xfa)\n-OP_PUBKEYS = CScriptOp(0xfb)\n-OP_PUBKEYHASH = CScriptOp(0xfd)\n-OP_PUBKEY = CScriptOp(0xfe)\n+# tapscript\n+OP_CHECKSIGADD = CScriptOp(0xba)\n \n OP_INVALIDOPCODE = CScriptOp(0xff)\n \n@@ -343,10 +346,7 @@ def __new__(cls, n):\n     OP_NOP8 : 'OP_NOP8',\n     OP_NOP9 : 'OP_NOP9',\n     OP_NOP10 : 'OP_NOP10',\n-    OP_SMALLINTEGER : 'OP_SMALLINTEGER',\n-    OP_PUBKEYS : 'OP_PUBKEYS',\n-    OP_PUBKEYHASH : 'OP_PUBKEYHASH',\n-    OP_PUBKEY : 'OP_PUBKEY',\n+    OP_CHECKSIGADD : 'OP_CHECKSIGADD',\n     OP_INVALIDOPCODE : 'OP_INVALIDOPCODE',\n })\n \n@@ -607,6 +607,20 @@ def FindAndDelete(script, sig):\n         r += script[last_sop_idx:]\n     return CScript(r)\n \n+def IsPayToScriptHash(script):\n+    return len(script) == 23 and script[0] == OP_HASH160 and script[1] == 20 and script[22] == OP_EQUAL\n+\n+def IsPayToTaproot(script):\n+    return len(script) == 35 and script[0] == OP_1 and script[1] == 33 and script[2] >= 0 and script[2] <= 1\n+\n+def TaggedHash(tag, data):\n+    ss = sha256(tag.encode('utf-8'))\n+    ss += ss\n+    ss += data\n+    return sha256(ss)\n+\n+def GetP2SH(script):\n+    return CScript([OP_HASH160, hash160(script), OP_EQUAL])\n \n def SignatureHash(script, txTo, inIdx, hashtype):\n     \"\"\"Consensus-correct SignatureHash\n@@ -702,3 +716,102 @@ def SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, amount):\n     ss += struct.pack(\"<I\", hashtype)\n \n     return hash256(ss)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, tapscript = CScript(), codeseparator_pos = -1, annex = None, tapscript_ver = DEFAULT_TAPSCRIPT_VER):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert((hash_type >= 0 and hash_type <= 3) or (hash_type >= 0x81 and hash_type <= 0x83))\n+    assert (input_index < len(txTo.vin))\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if not (hash_type & SIGHASH_ANYONECANPAY):\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if (hash_type & 3) != SIGHASH_SINGLE and (hash_type & 3) != SIGHASH_NONE:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if IsPayToScriptHash(spk):\n+        spend_type = 1\n+    else:\n+        assert(IsPayToTaproot(spk))\n+    if annex is not None:\n+        assert (annex[0] == ANNEX_TAG)\n+        spend_type |= 2\n+    if (scriptpath):\n+        assert (len(tapscript) > 0)\n+        assert (codeseparator_pos >= -1)\n+        spend_type |= 4\n+    ss += bytes([spend_type])\n+    ss += ser_string(spk)\n+    if (hash_type & SIGHASH_ANYONECANPAY):\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<H\", input_index)\n+    if (spend_type & 2):\n+        ss += sha256(ser_string(annex))\n+    if (hash_type & 3 == SIGHASH_SINGLE):\n+        assert (input_index < len(txTo.vout))\n+        ss += sha256(txTo.vout[input_index].serialize())\n+    if (scriptpath):\n+        ss += TaggedHash(\"TapLeaf\", bytes([tapscript_ver]) + ser_string(tapscript))\n+        ss += bytes([0x02])\n+        ss += struct.pack(\"<h\", codeseparator_pos)\n+    assert (len(ss) == 177 - bool(hash_type & SIGHASH_ANYONECANPAY) * 50 - ((hash_type & 3) == SIGHASH_NONE) * 32 - (IsPayToScriptHash(spk)) * 12 + (annex is not None) * 32 + scriptpath * 35)\n+    return TaggedHash(\"TapSighash\", ss)\n+\n+def GetVersionTaggedPubKey(pubkey, version):\n+    assert pubkey.is_compressed\n+    assert pubkey.is_valid\n+    # When the version 0xfe is used, the control block may become indistinguishable from annex.\n+    # In such case, use of annex becomes mandatory.\n+    assert version >= 0 and version < 0xff and not (version & 1)\n+    data = pubkey.get_bytes()\n+    return bytes([data[0] & 1 | version]) + data[1:]\n+\n+def taproot_tree_helper(scripts):\n+    if len(scripts) == 1:\n+        script = scripts[0]\n+        if isinstance(script, list):\n+            return taproot_tree_helper(script)\n+        version = DEFAULT_TAPSCRIPT_VER\n+        if isinstance(script, tuple):\n+            version, script = script\n+        assert isinstance(script, bytes)\n+        h = TaggedHash(\"TapLeaf\", bytes([version & 0xfe]) + ser_string(script))\n+        return ([(version, script, bytes())], h)\n+    split_pos = len(scripts) // 2\n+    left, left_h = taproot_tree_helper(scripts[0:split_pos])\n+    right, right_h = taproot_tree_helper(scripts[split_pos:])\n+    left = [(version, script, control + right_h) for version, script, control in left]\n+    right = [(version, script, control + left_h) for version, script, control in right]\n+    if right_h < left_h:\n+        right_h, left_h = left_h, right_h\n+    h = TaggedHash(\"TapBranch\", left_h + right_h)\n+    return (left + right, h)\n+\n+def taproot_construct(pubkey, scripts=[]):\n+    \"\"\"Construct a tree of taproot spending conditions\n+\n+    pubkey: an ECPubKey object for the root pubkey\n+    scripts: a list of items; each item is either:\n+             - a CScript\n+             - a (version, CScript) tuple\n+             - another list of items (with the same structure)\n+\n+    Returns: script (sPK or redeemScript), tweak, {script:control, ...}\n+    \"\"\"\n+    if len(scripts) == 0:\n+        return (CScript([OP_1, GetVersionTaggedPubKey(pubkey, TAPROOT_VER)]), bytes([0 for i in range(32)]), {})\n+\n+    ret, h = taproot_tree_helper(scripts)\n+    control_map = dict((script, GetVersionTaggedPubKey(pubkey, version) + control) for version, script, control in ret)\n+    tweak = TaggedHash(\"TapTweak\", pubkey.get_bytes() + h)\n+    tweaked = pubkey.tweak_add(tweak)\n+    return (CScript([OP_1, GetVersionTaggedPubKey(tweaked, TAPROOT_VER)]), tweak, control_map)\n+\n+def is_op_success(o):\n+    return o == 0x50 or o == 0x62 or o == 0x89 or o == 0x8a or o == 0x8d or o == 0x8e or (o >= 0x7e and o <= 0x81) or (o >= 0x83 and o <= 0x86) or (o >= 0x95 and o <= 0x99) or (o >= 0xbb and o <= 0xfe)"
      },
      {
        "sha": "f8a35dc680816a5c6c1ff288e5da6bf11e69391f",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00708a2029d13a3876cb01a566dc6e93330674af/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=00708a2029d13a3876cb01a566dc6e93330674af",
        "patch": "@@ -148,6 +148,7 @@\n     'p2p_mempool.py',\n     'rpc_setban.py',\n     'p2p_blocksonly.py',\n+    'feature_taproot.py',\n     'mining_prioritisetransaction.py',\n     'p2p_invalid_locator.py',\n     'p2p_invalid_block.py',"
      }
    ]
  }
]