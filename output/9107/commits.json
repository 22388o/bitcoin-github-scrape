[
  {
    "sha": "b50cd7a67e71051db59199a4185e7c82b669c659",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNTBjZDdhNjdlNzEwNTFkYjU5MTk5YTQxODVlN2M4MmI2NjljNjU5",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-11-07T20:30:41Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2017-01-04T16:20:42Z"
      },
      "message": "Fix dangerous condition in ModifyNewCoins.\n\nWe were marking coins FRESH before being sure they were not overwriting dirty undo data. This condition was never reached in existing code because undo data was always flushed before UpdateCoins was called with new transactions, but could have been exposed in an otherwise safe refactor.\nClarify in the comments the assumptions made in ModifyNewCoins.\nAdd ability to undo transactions to UpdateCoins unit test.\nThanks to Russ Yanofsky for suggestion on how to make logic clearer and fixing up the ccoins_modify_new test cases.",
      "tree": {
        "sha": "9708654395f01d61688c9b979325c0a088029c02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9708654395f01d61688c9b979325c0a088029c02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b50cd7a67e71051db59199a4185e7c82b669c659",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b50cd7a67e71051db59199a4185e7c82b669c659",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b50cd7a67e71051db59199a4185e7c82b669c659",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b50cd7a67e71051db59199a4185e7c82b669c659/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "caa2f106d704ec3ade63498031dd58d34510bc76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/caa2f106d704ec3ade63498031dd58d34510bc76",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/caa2f106d704ec3ade63498031dd58d34510bc76"
      }
    ],
    "stats": {
      "total": 243,
      "additions": 181,
      "deletions": 62
    },
    "files": [
      {
        "sha": "fe474fdda28f9bda7f825dab6c07ad0919cf1fba",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 6,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b50cd7a67e71051db59199a4185e7c82b669c659/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b50cd7a67e71051db59199a4185e7c82b669c659/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=b50cd7a67e71051db59199a4185e7c82b669c659",
        "patch": "@@ -117,17 +117,37 @@ CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n     return CCoinsModifier(*this, ret.first, cachedCoinUsage);\n }\n \n-// ModifyNewCoins has to know whether the new outputs its creating are for a\n-// coinbase or not.  If they are for a coinbase, it can not mark them as fresh.\n-// This is to ensure that the historical duplicate coinbases before BIP30 was\n-// in effect will still be properly overwritten when spent.\n+/* ModifyNewCoins allows for faster coin modification when creating the new\n+ * outputs from a transaction.  It assumes that BIP 30 (no duplicate txids)\n+ * applies and has already been tested for (or the test is not required due to\n+ * BIP 34, height in coinbase).  If we can assume BIP 30 then we know that any\n+ * non-coinbase transaction we are adding to the UTXO must not already exist in\n+ * the utxo unless it is fully spent.  Thus we can check only if it exists DIRTY\n+ * at the current level of the cache, in which case it is not safe to mark it\n+ * FRESH (b/c then its spentness still needs to flushed).  If it's not dirty and\n+ * doesn't exist or is pruned in the current cache, we know it either doesn't\n+ * exist or is pruned in parent caches, which is the definition of FRESH.  The\n+ * exception to this is the two historical violations of BIP 30 in the chain,\n+ * both of which were coinbases.  We do not mark these fresh so we we can ensure\n+ * that they will still be properly overwritten when spent.\n+ */\n CCoinsModifier CCoinsViewCache::ModifyNewCoins(const uint256 &txid, bool coinbase) {\n     assert(!hasModifier);\n     std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    ret.first->second.coins.Clear();\n     if (!coinbase) {\n-        ret.first->second.flags = CCoinsCacheEntry::FRESH;\n+        // New coins must not already exist.\n+        if (!ret.first->second.coins.IsPruned())\n+            throw std::logic_error(\"ModifyNewCoins should not find pre-existing coins on a non-coinbase unless they are pruned!\");\n+\n+        if (!(ret.first->second.flags & CCoinsCacheEntry::DIRTY)) {\n+            // If the coin is known to be pruned (have no unspent outputs) in\n+            // the current view and the cache entry is not dirty, we know the\n+            // coin also must be pruned in the parent view as well, so it is safe\n+            // to mark this fresh.\n+            ret.first->second.flags |= CCoinsCacheEntry::FRESH;\n+        }\n     }\n+    ret.first->second.coins.Clear();\n     ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n     return CCoinsModifier(*this, ret.first, 0);\n }\n@@ -200,6 +220,11 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                     itUs->second.coins.swap(it->second.coins);\n                     cachedCoinsUsage += itUs->second.coins.DynamicMemoryUsage();\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n+                    // NOTE: It is possible the child has a FRESH flag here in\n+                    // the event the entry we found in the parent is pruned. But\n+                    // we must not copy that FRESH flag to the parent as that\n+                    // pruned state likely still needs to be communicated to the\n+                    // grandparent.\n                 }\n             }\n         }"
      },
      {
        "sha": "624460635631e0dca27d833ce699321a3ea12148",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b50cd7a67e71051db59199a4185e7c82b669c659/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b50cd7a67e71051db59199a4185e7c82b669c659/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=b50cd7a67e71051db59199a4185e7c82b669c659",
        "patch": "@@ -269,6 +269,11 @@ struct CCoinsCacheEntry\n     enum Flags {\n         DIRTY = (1 << 0), // This cache entry is potentially different from the version in the parent view.\n         FRESH = (1 << 1), // The parent view does not have this entry (or it is pruned).\n+        /* Note that FRESH is a performance optimization with which we can\n+         * erase coins that are fully spent if we know we do not need to\n+         * flush the changes to the parent cache.  It is always safe to\n+         * not mark FRESH if that condition is not guaranteed.\n+         */\n     };\n \n     CCoinsCacheEntry() : coins(), flags(0) {}"
      },
      {
        "sha": "94a11d17683aac97e18f206ef1739547c0d76d82",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 144,
        "deletions": 55,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b50cd7a67e71051db59199a4185e7c82b669c659/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b50cd7a67e71051db59199a4185e7c82b669c659/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=b50cd7a67e71051db59199a4185e7c82b669c659",
        "patch": "@@ -5,6 +5,7 @@\n #include \"coins.h\"\n #include \"script/standard.h\"\n #include \"uint256.h\"\n+#include \"undo.h\"\n #include \"utilstrencodings.h\"\n #include \"test/test_bitcoin.h\"\n #include \"test/test_random.h\"\n@@ -16,6 +17,9 @@\n \n #include <boost/test/unit_test.hpp>\n \n+bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out);\n+void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight);\n+\n namespace\n {\n class CCoinsViewTest : public CCoinsView\n@@ -213,6 +217,22 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n+typedef std::tuple<CTransaction,CTxUndo,CCoins> TxData;\n+// Store of all necessary tx and undo data for next test\n+std::map<uint256, TxData> alltxs;\n+\n+TxData &FindRandomFrom(const std::set<uint256> &txidset) {\n+    assert(txidset.size());\n+    std::set<uint256>::iterator txIt = txidset.lower_bound(GetRandHash());\n+    if (txIt == txidset.end()) {\n+        txIt = txidset.begin();\n+    }\n+    std::map<uint256, TxData>::iterator txdit = alltxs.find(*txIt);\n+    assert(txdit != alltxs.end());\n+    return txdit->second;\n+}\n+\n+\n // This test is similar to the previous test\n // except the emphasis is on testing the functionality of UpdateCoins\n // random txs are created and UpdateCoins is used to update the cache stack\n@@ -229,77 +249,139 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n     std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n     stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n \n-    // Track the txids we've used and whether they have been spent or not\n-    std::map<uint256, CAmount> coinbaseids;\n-    std::set<uint256> alltxids;\n+    // Track the txids we've used in various sets\n+    std::set<uint256> coinbaseids;\n+    std::set<uint256> disconnectedids;\n     std::set<uint256> duplicateids;\n+    std::set<uint256> utxoset;\n \n     for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n-        {\n+        uint32_t randiter = insecure_rand();\n+\n+        // 19/20 txs add a new transaction\n+        if (randiter % 20 < 19) {\n             CMutableTransaction tx;\n             tx.vin.resize(1);\n             tx.vout.resize(1);\n             tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n             unsigned int height = insecure_rand();\n+            CCoins oldcoins;\n \n-            // 1/10 times create a coinbase\n-            if (insecure_rand() % 10 == 0 || coinbaseids.size() < 10) {\n-                // 1/100 times create a duplicate coinbase\n+            // 2/20 times create a new coinbase\n+            if (randiter % 20 < 2 || coinbaseids.size() < 10) {\n+                // 1/10 of those times create a duplicate coinbase\n                 if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n-                    std::map<uint256, CAmount>::iterator coinbaseIt = coinbaseids.lower_bound(GetRandHash());\n-                    if (coinbaseIt == coinbaseids.end()) {\n-                        coinbaseIt = coinbaseids.begin();\n-                    }\n-                    //Use same random value to have same hash and be a true duplicate\n-                    tx.vout[0].nValue = coinbaseIt->second;\n-                    assert(tx.GetHash() == coinbaseIt->first);\n-                    duplicateids.insert(coinbaseIt->first);\n+                    TxData &txd = FindRandomFrom(coinbaseids);\n+                    // Reuse the exact same coinbase\n+                    tx = std::get<0>(txd);\n+                    // shouldn't be available for reconnection if its been duplicated\n+                    disconnectedids.erase(tx.GetHash());\n+\n+                    duplicateids.insert(tx.GetHash());\n                 }\n                 else {\n-                    coinbaseids[tx.GetHash()] = tx.vout[0].nValue;\n+                    coinbaseids.insert(tx.GetHash());\n                 }\n                 assert(CTransaction(tx).IsCoinBase());\n             }\n-            // 9/10 times create a regular tx\n+\n+            // 17/20 times reconnect previous or add a regular tx\n             else {\n+\n                 uint256 prevouthash;\n-                // equally likely to spend coinbase or non coinbase\n-                std::set<uint256>::iterator txIt = alltxids.lower_bound(GetRandHash());\n-                if (txIt == alltxids.end()) {\n-                    txIt = alltxids.begin();\n+                // 1/20 times reconnect a previously disconnected tx\n+                if (randiter % 20 == 2 && disconnectedids.size()) {\n+                    TxData &txd = FindRandomFrom(disconnectedids);\n+                    tx = std::get<0>(txd);\n+                    prevouthash = tx.vin[0].prevout.hash;\n+                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevouthash)) {\n+                        disconnectedids.erase(tx.GetHash());\n+                        continue;\n+                    }\n+\n+                    // If this tx is already IN the UTXO, then it must be a coinbase, and it must be a duplicate\n+                    if (utxoset.count(tx.GetHash())) {\n+                        assert(CTransaction(tx).IsCoinBase());\n+                        assert(duplicateids.count(tx.GetHash()));\n+                    }\n+                    disconnectedids.erase(tx.GetHash());\n                 }\n-                prevouthash = *txIt;\n \n-                // Construct the tx to spend the coins of prevouthash\n-                tx.vin[0].prevout.hash = prevouthash;\n-                tx.vin[0].prevout.n = 0;\n+                // 16/20 times create a regular tx\n+                else {\n+                    TxData &txd = FindRandomFrom(utxoset);\n+                    prevouthash = std::get<0>(txd).GetHash();\n \n+                    // Construct the tx to spend the coins of prevouthash\n+                    tx.vin[0].prevout.hash = prevouthash;\n+                    tx.vin[0].prevout.n = 0;\n+                    assert(!CTransaction(tx).IsCoinBase());\n+                }\n+                // In this simple test coins only have two states, spent or unspent, save the unspent state to restore\n+                oldcoins = result[prevouthash];\n                 // Update the expected result of prevouthash to know these coins are spent\n-                CCoins& oldcoins = result[prevouthash];\n-                oldcoins.Clear();\n+                result[prevouthash].Clear();\n \n-                // It is of particular importance here that once we spend a coinbase tx hash\n-                // it is no longer available to be duplicated (or spent again)\n-                // BIP 34 in conjunction with enforcing BIP 30 (at least until BIP 34 was active)\n-                // results in the fact that no coinbases were duplicated after they were already spent\n-                alltxids.erase(prevouthash);\n-                coinbaseids.erase(prevouthash);\n+                utxoset.erase(prevouthash);\n \n                 // The test is designed to ensure spending a duplicate coinbase will work properly\n                 // if that ever happens and not resurrect the previously overwritten coinbase\n                 if (duplicateids.count(prevouthash))\n                     spent_a_duplicate_coinbase = true;\n \n-                assert(!CTransaction(tx).IsCoinBase());\n             }\n-            // Track this tx to possibly spend later\n-            alltxids.insert(tx.GetHash());\n-\n             // Update the expected result to know about the new output coins\n-            CCoins &coins = result[tx.GetHash()];\n-            coins.FromTx(tx, height);\n+            result[tx.GetHash()].FromTx(tx, height);\n+\n+            // Call UpdateCoins on the top cache\n+            CTxUndo undo;\n+            UpdateCoins(tx, *(stack.back()), undo, height);\n \n-            UpdateCoins(tx, *(stack.back()), height);\n+            // Update the utxo set for future spends\n+            utxoset.insert(tx.GetHash());\n+\n+            // Track this tx and undo info to use later\n+            alltxs.insert(std::make_pair(tx.GetHash(),std::make_tuple(tx,undo,oldcoins)));\n+        }\n+\n+        //1/20 times undo a previous transaction\n+        else if (utxoset.size()) {\n+            TxData &txd = FindRandomFrom(utxoset);\n+\n+            CTransaction &tx = std::get<0>(txd);\n+            CTxUndo &undo = std::get<1>(txd);\n+            CCoins &origcoins = std::get<2>(txd);\n+\n+            uint256 undohash = tx.GetHash();\n+\n+            // Update the expected result\n+            // Remove new outputs\n+            result[undohash].Clear();\n+            // If not coinbase restore prevout\n+            if (!tx.IsCoinBase()) {\n+                result[tx.vin[0].prevout.hash] = origcoins;\n+            }\n+\n+            // Disconnect the tx from the current UTXO\n+            // See code in DisconnectBlock\n+            // remove outputs\n+            {\n+                CCoinsModifier outs = stack.back()->ModifyCoins(undohash);\n+                outs->Clear();\n+            }\n+            // restore inputs\n+            if (!tx.IsCoinBase()) {\n+                const COutPoint &out = tx.vin[0].prevout;\n+                const CTxInUndo &undoin = undo.vprevout[0];\n+                ApplyTxInUndo(undoin, *(stack.back()), out);\n+            }\n+            // Store as a candidate for reconnection\n+            disconnectedids.insert(undohash);\n+\n+            // Update the utxoset\n+            utxoset.erase(undohash);\n+            if (!tx.IsCoinBase())\n+                utxoset.insert(tx.vin[0].prevout.hash);\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n@@ -308,9 +390,9 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n                 const CCoins* coins = stack.back()->AccessCoins(it->first);\n                 if (coins) {\n                     BOOST_CHECK(*coins == it->second);\n-                 } else {\n+                } else {\n                     BOOST_CHECK(it->second.IsPruned());\n-                 }\n+                }\n             }\n         }\n \n@@ -334,7 +416,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n                     tip = stack.back();\n                 }\n                 stack.push_back(new CCoinsViewCacheTest(tip));\n-           }\n+            }\n         }\n     }\n \n@@ -420,6 +502,7 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n const static uint256 TXID;\n const static CAmount PRUNED = -1;\n const static CAmount ABSENT = -2;\n+const static CAmount FAIL = -3;\n const static CAmount VALUE1 = 100;\n const static CAmount VALUE2 = 200;\n const static CAmount VALUE3 = 300;\n@@ -630,11 +713,17 @@ BOOST_AUTO_TEST_CASE(ccoins_modify)\n void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    SetCoinsValue(modify_value, *test.cache.ModifyNewCoins(TXID, coinbase));\n \n     CAmount result_value;\n     char result_flags;\n-    GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n+    try {\n+        SetCoinsValue(modify_value, *test.cache.ModifyNewCoins(TXID, coinbase));\n+        GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n+    } catch (std::logic_error& e) {\n+        result_value = FAIL;\n+        result_flags = NO_ENTRY;\n+    }\n+\n     BOOST_CHECK_EQUAL(result_value, expected_value);\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n }\n@@ -669,33 +758,33 @@ BOOST_AUTO_TEST_CASE(ccoins_modify_new)\n     CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      , true );\n     CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n     CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , false);\n     CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n     CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n     CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n     CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, 0          , NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , 0          , NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , FRESH      , NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY      , NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n     CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n }\n "
      },
      {
        "sha": "744c228bb76b54504e3b904243a2f887e3b7583a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b50cd7a67e71051db59199a4185e7c82b669c659/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b50cd7a67e71051db59199a4185e7c82b669c659/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b50cd7a67e71051db59199a4185e7c82b669c659",
        "patch": "@@ -1498,7 +1498,7 @@ bool AbortNode(CValidationState& state, const std::string& strMessage, const std\n  * @param out The out point that corresponds to the tx input.\n  * @return True on success.\n  */\n-static bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out)\n+bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n "
      }
    ]
  }
]