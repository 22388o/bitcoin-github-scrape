[
  {
    "sha": "b23add5521e4207085d41a0266617e94435fc22e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjNhZGQ1NTIxZTQyMDcwODVkNDFhMDI2NjYxN2U5NDQzNWZjMjJl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-08T13:30:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-24T00:00:32Z"
      },
      "message": "Switch addrman key from vector to uint256",
      "tree": {
        "sha": "256976b0c67cda4452c6e00041ee8ff4a39bd349",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/256976b0c67cda4452c6e00041ee8ff4a39bd349"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b23add5521e4207085d41a0266617e94435fc22e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b23add5521e4207085d41a0266617e94435fc22e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b23add5521e4207085d41a0266617e94435fc22e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b23add5521e4207085d41a0266617e94435fc22e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3948a30cd27928fdf9dffbbf90ea6430c869edf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3948a30cd27928fdf9dffbbf90ea6430c869edf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3948a30cd27928fdf9dffbbf90ea6430c869edf"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 23,
      "deletions": 12
    },
    "files": [
      {
        "sha": "0c09a244701092ad083efb038f26c979e90eb221",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b23add5521e4207085d41a0266617e94435fc22e/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b23add5521e4207085d41a0266617e94435fc22e/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=b23add5521e4207085d41a0266617e94435fc22e",
        "patch": "@@ -10,30 +10,30 @@\n \n using namespace std;\n \n-int CAddrInfo::GetTriedBucket(const std::vector<unsigned char>& nKey) const\n+int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n     std::vector<unsigned char> vchKey = GetKey();\n-    ss1 << nKey << vchKey;\n+    ss1 << ((unsigned char)32) << nKey << vchKey;\n     uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n \n     CDataStream ss2(SER_GETHASH, 0);\n     std::vector<unsigned char> vchGroupKey = GetGroup();\n-    ss2 << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n+    ss2 << ((unsigned char)32) << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n     uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n \n-int CAddrInfo::GetNewBucket(const std::vector<unsigned char>& nKey, const CNetAddr& src) const\n+int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n     std::vector<unsigned char> vchGroupKey = GetGroup();\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n-    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n+    ss1 << ((unsigned char)32) << nKey << vchGroupKey << vchSourceGroupKey;\n     uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n \n     CDataStream ss2(SER_GETHASH, 0);\n-    ss2 << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n+    ss2 << ((unsigned char)32) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n     uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n }\n@@ -483,6 +483,8 @@ int CAddrMan::Check_()\n         return -13;\n     if (mapNew.size())\n         return -15;\n+    if (nKey.IsNull())\n+        return -16;\n \n     return 0;\n }"
      },
      {
        "sha": "04c7b32eafa3ae53050dc815173127267fa3efa2",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 15,
        "deletions": 6,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b23add5521e4207085d41a0266617e94435fc22e/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b23add5521e4207085d41a0266617e94435fc22e/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=b23add5521e4207085d41a0266617e94435fc22e",
        "patch": "@@ -10,6 +10,7 @@\n #include \"random.h\"\n #include \"sync.h\"\n #include \"timedata.h\"\n+#include \"uint256.h\"\n #include \"util.h\"\n \n #include <map>\n@@ -79,13 +80,13 @@ class CAddrInfo : public CAddress\n     }\n \n     //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const std::vector<unsigned char> &nKey) const;\n+    int GetTriedBucket(const uint256 &nKey) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const;\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const std::vector<unsigned char> &nKey) const\n+    int GetNewBucket(const uint256 &nKey) const\n     {\n         return GetNewBucket(nKey, source);\n     }\n@@ -176,7 +177,7 @@ class CAddrMan\n     mutable CCriticalSection cs;\n \n     //! secret key to randomize bucket select with\n-    std::vector<unsigned char> nKey;\n+    uint256 nKey;\n \n     //! last used nId\n     int nIdCount;\n@@ -284,6 +285,7 @@ class CAddrMan\n \n         unsigned char nVersion = 0;\n         s << nVersion;\n+        s << ((unsigned char)32);\n         s << nKey;\n         s << nNew;\n         s << nTried;\n@@ -328,6 +330,9 @@ class CAddrMan\n \n         unsigned char nVersion;\n         s >> nVersion;\n+        unsigned char nKeySize;\n+        s >> nKeySize;\n+        if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman\");\n         s >> nKey;\n         s >> nNew;\n         s >> nTried;\n@@ -393,14 +398,18 @@ class CAddrMan\n \n     CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n     {\n-         nKey.resize(32);\n-         GetRandBytes(&nKey[0], 32);\n+         nKey = GetRandHash();\n \n          nIdCount = 0;\n          nTried = 0;\n          nNew = 0;\n     }\n \n+    ~CAddrMan()\n+    {\n+         nKey.SetNull();\n+    }\n+\n     //! Return the number of (unique) addresses in all tables.\n     int size()\n     {"
      }
    ]
  },
  {
    "sha": "e6b343d880f50d52390c5af8623afa15fcbc65a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNmIzNDNkODgwZjUwZDUyMzkwYzVhZjg2MjNhZmExNWZjYmM2NWEy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-18T16:31:49Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-24T00:19:13Z"
      },
      "message": "Make addrman's bucket placement deterministic.\n\nGive each address a single fixed location in the new and tried tables,\nwhich become simple fixed-size arrays instead of sets and vectors.\n\nThis prevents attackers from having an advantages by inserting an\naddress multiple times.\n\nThis change was suggested as Countermeasure 1 in\nEclipse Attacks on Bitcoin\u2019s Peer-to-Peer Network, Ethan Heilman,\nAlison Kendler, Aviv Zohar, Sharon Goldberg. ePrint Archive Report\n2015/263. March 2015.\n\nIt is also more efficient.",
      "tree": {
        "sha": "db402827c0aeda3350a6f8d2fb0a3c1bfcf3479e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/db402827c0aeda3350a6f8d2fb0a3c1bfcf3479e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e6b343d880f50d52390c5af8623afa15fcbc65a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6b343d880f50d52390c5af8623afa15fcbc65a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e6b343d880f50d52390c5af8623afa15fcbc65a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6b343d880f50d52390c5af8623afa15fcbc65a2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b23add5521e4207085d41a0266617e94435fc22e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b23add5521e4207085d41a0266617e94435fc22e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b23add5521e4207085d41a0266617e94435fc22e"
      }
    ],
    "stats": {
      "total": 437,
      "additions": 231,
      "deletions": 206
    },
    "files": [
      {
        "sha": "8310f0fe70e3ab80b6cb294dcefefbe8920f750c",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 124,
        "deletions": 146,
        "changes": 270,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6b343d880f50d52390c5af8623afa15fcbc65a2/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6b343d880f50d52390c5af8623afa15fcbc65a2/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=e6b343d880f50d52390c5af8623afa15fcbc65a2",
        "patch": "@@ -14,12 +14,12 @@ int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n     std::vector<unsigned char> vchKey = GetKey();\n-    ss1 << ((unsigned char)32) << nKey << vchKey;\n+    ss1 << nKey << vchKey;\n     uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n \n     CDataStream ss2(SER_GETHASH, 0);\n     std::vector<unsigned char> vchGroupKey = GetGroup();\n-    ss2 << ((unsigned char)32) << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n+    ss2 << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n     uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n@@ -29,15 +29,24 @@ int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n     CDataStream ss1(SER_GETHASH, 0);\n     std::vector<unsigned char> vchGroupKey = GetGroup();\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n-    ss1 << ((unsigned char)32) << nKey << vchGroupKey << vchSourceGroupKey;\n+    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n     uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n \n     CDataStream ss2(SER_GETHASH, 0);\n-    ss2 << ((unsigned char)32) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n+    ss2 << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n     uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n }\n \n+int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+{\n+    CDataStream ss1(SER_GETHASH, 0);\n+    std::vector<unsigned char> vchKey = GetKey();\n+    ss1 << nKey << (fNew ? 'N' : 'K') << nBucket << vchKey;\n+    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n+    return hash1 % ADDRMAN_BUCKET_SIZE;\n+}\n+\n bool CAddrInfo::IsTerrible(int64_t nNow) const\n {\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n@@ -128,130 +137,81 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n     vRandom[nRndPos2] = nId1;\n }\n \n-int CAddrMan::SelectTried(int nKBucket)\n+void CAddrMan::Delete(int nId)\n {\n-    std::vector<int>& vTried = vvTried[nKBucket];\n-\n-    // randomly shuffle the first few elements (using the entire list)\n-    // find the least recently tried among them\n-    int64_t nOldest = -1;\n-    int nOldestPos = -1;\n-    for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++) {\n-        int nPos = GetRandInt(vTried.size() - i) + i;\n-        int nTemp = vTried[nPos];\n-        vTried[nPos] = vTried[i];\n-        vTried[i] = nTemp;\n-        assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n-        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n-            nOldest = nTemp;\n-            nOldestPos = nPos;\n-        }\n-    }\n+    assert(mapInfo.count(nId) != 0);\n+    CAddrInfo& info = mapInfo[nId];\n+    assert(!info.fInTried);\n+    assert(info.nRefCount == 0);\n \n-    return nOldestPos;\n+    SwapRandom(info.nRandomPos, vRandom.size() - 1);\n+    vRandom.pop_back();\n+    mapAddr.erase(info);\n+    mapInfo.erase(nId);\n+    nNew--;\n }\n \n-int CAddrMan::ShrinkNew(int nUBucket)\n+void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n {\n-    assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n-    std::set<int>& vNew = vvNew[nUBucket];\n-\n-    // first look for deletable items\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n-        assert(mapInfo.count(*it));\n-        CAddrInfo& info = mapInfo[*it];\n-        if (info.IsTerrible()) {\n-            if (--info.nRefCount == 0) {\n-                SwapRandom(info.nRandomPos, vRandom.size() - 1);\n-                vRandom.pop_back();\n-                mapAddr.erase(info);\n-                mapInfo.erase(*it);\n-                nNew--;\n-            }\n-            vNew.erase(it);\n-            return 0;\n-        }\n-    }\n-\n-    // otherwise, select four randomly, and pick the oldest of those to replace\n-    int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n-    int nI = 0;\n-    int nOldest = -1;\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n-        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3]) {\n-            assert(nOldest == -1 || mapInfo.count(*it) == 1);\n-            if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n-                nOldest = *it;\n+    // if there is an entry in the specified bucket, delete it.\n+    if (vvNew[nUBucket][nUBucketPos] != -1) {\n+        int nIdDelete = vvNew[nUBucket][nUBucketPos];\n+        CAddrInfo& infoDelete = mapInfo[nIdDelete];\n+        assert(infoDelete.nRefCount > 0);\n+        infoDelete.nRefCount--;\n+        vvNew[nUBucket][nUBucketPos] = -1;\n+        if (infoDelete.nRefCount == 0) {\n+            Delete(nIdDelete);\n         }\n-        nI++;\n-    }\n-    assert(mapInfo.count(nOldest) == 1);\n-    CAddrInfo& info = mapInfo[nOldest];\n-    if (--info.nRefCount == 0) {\n-        SwapRandom(info.nRandomPos, vRandom.size() - 1);\n-        vRandom.pop_back();\n-        mapAddr.erase(info);\n-        mapInfo.erase(nOldest);\n-        nNew--;\n     }\n-    vNew.erase(nOldest);\n-\n-    return 1;\n }\n \n-void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n+void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n {\n-    assert(vvNew[nOrigin].count(nId) == 1);\n-\n     // remove the entry from all new buckets\n-    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n-        if ((*it).erase(nId))\n+    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+        int pos = info.GetBucketPosition(nKey, true, bucket);\n+        if (vvNew[bucket][pos] == nId) {\n+            vvNew[bucket][pos] = -1;\n             info.nRefCount--;\n+        }\n     }\n     nNew--;\n \n     assert(info.nRefCount == 0);\n \n     // which tried bucket to move the entry to\n     int nKBucket = info.GetTriedBucket(nKey);\n-    std::vector<int>& vTried = vvTried[nKBucket];\n-\n-    // first check whether there is place to just add it\n-    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n-        vTried.push_back(nId);\n-        nTried++;\n-        info.fInTried = true;\n-        return;\n-    }\n-\n-    // otherwise, find an item to evict\n-    int nPos = SelectTried(nKBucket);\n-\n-    // find which new bucket it belongs to\n-    assert(mapInfo.count(vTried[nPos]) == 1);\n-    int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n-    std::set<int>& vNew = vvNew[nUBucket];\n-\n-    // remove the to-be-replaced tried entry from the tried set\n-    CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n-    infoOld.fInTried = false;\n-    infoOld.nRefCount = 1;\n-    // do not update nTried, as we are going to move something else there immediately\n-\n-    // check whether there is place in that one,\n-    if (vNew.size() < ADDRMAN_NEW_BUCKET_SIZE) {\n-        // if so, move it back there\n-        vNew.insert(vTried[nPos]);\n-    } else {\n-        // otherwise, move it to the new bucket nId came from (there is certainly place there)\n-        vvNew[nOrigin].insert(vTried[nPos]);\n+    int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n+\n+    // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n+    if (vvTried[nKBucket][nKBucketPos] != -1) {\n+        // find an item to evict\n+        int nIdEvict = vvTried[nKBucket][nKBucketPos];\n+        assert(mapInfo.count(nIdEvict) == 1);\n+        CAddrInfo& infoOld = mapInfo[nIdEvict];\n+\n+        // Remove the to-be-evicted item from the tried set.\n+        infoOld.fInTried = false;\n+        vvTried[nKBucket][nKBucketPos] = -1;\n+        nTried--;\n+\n+        // find which new bucket it belongs to\n+        int nUBucket = infoOld.GetNewBucket(nKey);\n+        int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);\n+        ClearNew(nUBucket, nUBucketPos);\n+        assert(vvNew[nUBucket][nUBucketPos] == -1);\n+\n+        // Enter it into the new set again.\n+        infoOld.nRefCount = 1;\n+        vvNew[nUBucket][nUBucketPos] = nIdEvict;\n+        nNew++;\n     }\n-    nNew++;\n+    assert(vvTried[nKBucket][nKBucketPos] == -1);\n \n-    vTried[nPos] = nId;\n-    // we just overwrote an entry in vTried; no need to update nTried\n+    vvTried[nKBucket][nKBucketPos] = nId;\n+    nTried++;\n     info.fInTried = true;\n-    return;\n }\n \n void CAddrMan::Good_(const CService& addr, int64_t nTime)\n@@ -281,12 +241,12 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n         return;\n \n     // find a bucket it is in now\n-    int nRnd = GetRandInt(vvNew.size());\n+    int nRnd = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n-    for (unsigned int n = 0; n < vvNew.size(); n++) {\n-        int nB = (n + nRnd) % vvNew.size();\n-        std::set<int>& vNew = vvNew[nB];\n-        if (vNew.count(nId)) {\n+    for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        int nB = (n + nRnd) % ADDRMAN_NEW_BUCKET_COUNT;\n+        int nBpos = info.GetBucketPosition(nKey, true, nB);\n+        if (vvNew[nB][nBpos] == nId) {\n             nUBucket = nB;\n             break;\n         }\n@@ -300,7 +260,7 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n \n     // move nId to the tried tables\n-    MakeTried(info, nId, nUBucket);\n+    MakeTried(info, nId);\n }\n \n bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n@@ -348,12 +308,25 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     }\n \n     int nUBucket = pinfo->GetNewBucket(nKey, source);\n-    std::set<int>& vNew = vvNew[nUBucket];\n-    if (!vNew.count(nId)) {\n-        pinfo->nRefCount++;\n-        if (vNew.size() == ADDRMAN_NEW_BUCKET_SIZE)\n-            ShrinkNew(nUBucket);\n-        vvNew[nUBucket].insert(nId);\n+    int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);\n+    if (vvNew[nUBucket][nUBucketPos] != nId) {\n+        bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n+        if (!fInsert) {\n+            CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n+            if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n+                // Overwrite the existing new table entry.\n+                fInsert = true;\n+            }\n+        }\n+        if (fInsert) {\n+            ClearNew(nUBucket, nUBucketPos);\n+            pinfo->nRefCount++;\n+            vvNew[nUBucket][nUBucketPos] = nId;\n+        } else {\n+            if (pinfo->nRefCount == 0) {\n+                Delete(nId);\n+            }\n+        }\n     }\n     return fNew;\n }\n@@ -388,13 +361,13 @@ CAddress CAddrMan::Select_(int nUnkBias)\n         // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nKBucket = GetRandInt(vvTried.size());\n-            std::vector<int>& vTried = vvTried[nKBucket];\n-            if (vTried.size() == 0)\n+            int nKBucket = GetRandInt(ADDRMAN_TRIED_BUCKET_COUNT);\n+            int nKBucketPos = GetRandInt(ADDRMAN_BUCKET_SIZE);\n+            if (vvTried[nKBucket][nKBucketPos] == -1)\n                 continue;\n-            int nPos = GetRandInt(vTried.size());\n-            assert(mapInfo.count(vTried[nPos]) == 1);\n-            CAddrInfo& info = mapInfo[vTried[nPos]];\n+            int nId = vvTried[nKBucket][nKBucketPos];\n+            assert(mapInfo.count(nId) == 1);\n+            CAddrInfo& info = mapInfo[nId];\n             if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n@@ -403,16 +376,13 @@ CAddress CAddrMan::Select_(int nUnkBias)\n         // use a new node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nUBucket = GetRandInt(vvNew.size());\n-            std::set<int>& vNew = vvNew[nUBucket];\n-            if (vNew.size() == 0)\n+            int nUBucket = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n+            int nUBucketPos = GetRandInt(ADDRMAN_BUCKET_SIZE);\n+            if (vvNew[nUBucket][nUBucketPos] == -1)\n                 continue;\n-            int nPos = GetRandInt(vNew.size());\n-            std::set<int>::iterator it = vNew.begin();\n-            while (nPos--)\n-                it++;\n-            assert(mapInfo.count(*it) == 1);\n-            CAddrInfo& info = mapInfo[*it];\n+            int nId = vvNew[nUBucket][nUBucketPos];\n+            assert(mapInfo.count(nId) == 1);\n+            CAddrInfo& info = mapInfo[nId];\n             if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n@@ -460,22 +430,30 @@ int CAddrMan::Check_()\n     if (mapNew.size() != nNew)\n         return -10;\n \n-    for (int n = 0; n < vvTried.size(); n++) {\n-        std::vector<int>& vTried = vvTried[n];\n-        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++) {\n-            if (!setTried.count(*it))\n-                return -11;\n-            setTried.erase(*it);\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+             if (vvTried[n][i] != -1) {\n+                 if (!setTried.count(vvTried[n][i]))\n+                     return -11;\n+                 if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey) != n)\n+                     return -17;\n+                 if (mapInfo[vvTried[n][i]].GetBucketPosition(nKey, false, n) != i)\n+                     return -18;\n+                 setTried.erase(vvTried[n][i]);\n+             }\n         }\n     }\n \n-    for (int n = 0; n < vvNew.size(); n++) {\n-        std::set<int>& vNew = vvNew[n];\n-        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n-            if (!mapNew.count(*it))\n-                return -12;\n-            if (--mapNew[*it] == 0)\n-                mapNew.erase(*it);\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[n][i] != -1) {\n+                if (!mapNew.count(vvNew[n][i]))\n+                    return -12;\n+                if (mapInfo[vvNew[n][i]].GetBucketPosition(nKey, true, n) != i)\n+                    return -19;\n+                if (--mapNew[vvNew[n][i]] == 0)\n+                    mapNew.erase(vvNew[n][i]);\n+            }\n         }\n     }\n "
      },
      {
        "sha": "f7c63184484e9a2a71a1ff177fb7eda7c75f07bd",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 107,
        "deletions": 60,
        "changes": 167,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6b343d880f50d52390c5af8623afa15fcbc65a2/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6b343d880f50d52390c5af8623afa15fcbc65a2/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=e6b343d880f50d52390c5af8623afa15fcbc65a2",
        "patch": "@@ -10,7 +10,6 @@\n #include \"random.h\"\n #include \"sync.h\"\n #include \"timedata.h\"\n-#include \"uint256.h\"\n #include \"util.h\"\n \n #include <map>\n@@ -91,6 +90,9 @@ class CAddrInfo : public CAddress\n         return GetNewBucket(nKey, source);\n     }\n \n+    //! Calculate in which position of a bucket to store this entry.\n+    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n+\n     //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n     bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n \n@@ -128,14 +130,11 @@ class CAddrInfo : public CAddress\n //! total number of buckets for tried addresses\n #define ADDRMAN_TRIED_BUCKET_COUNT 64\n \n-//! maximum allowed number of entries in buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_SIZE 64\n-\n //! total number of buckets for new addresses\n #define ADDRMAN_NEW_BUCKET_COUNT 256\n \n-//! maximum allowed number of entries in buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_SIZE 64\n+//! maximum allowed number of entries in buckets for new and tried addresses\n+#define ADDRMAN_BUCKET_SIZE 64\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n #define ADDRMAN_TRIED_BUCKETS_PER_GROUP 4\n@@ -146,9 +145,6 @@ class CAddrInfo : public CAddress\n //! in how many buckets for entries with new addresses a single address may occur\n #define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 4\n \n-//! how many entries in a bucket with tried addresses are inspected, when selecting one to replace\n-#define ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT 4\n-\n //! how old addresses can maximally be\n #define ADDRMAN_HORIZON_DAYS 30\n \n@@ -195,13 +191,13 @@ class CAddrMan\n     int nTried;\n \n     //! list of \"tried\" buckets\n-    std::vector<std::vector<int> > vvTried;\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE];\n \n     //! number of (unique) \"new\" entries\n     int nNew;\n \n     //! list of \"new\" buckets\n-    std::vector<std::set<int> > vvNew;\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE];\n \n protected:\n \n@@ -215,17 +211,14 @@ class CAddrMan\n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2);\n \n-    //! Return position in given bucket to replace.\n-    int SelectTried(int nKBucket);\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId);\n \n-    //! Remove an element from a \"new\" bucket.\n-    //! This is the only place where actual deletions occur.\n-    //! Elements are never deleted while in the \"tried\" table, only possibly evicted back to the \"new\" table.\n-    int ShrinkNew(int nUBucket);\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId);\n \n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    //! @pre vvUnkown[nOrigin].count(nId) != 0\n-    void MakeTried(CAddrInfo& info, int nId, int nOrigin);\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos);\n \n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, int64_t nTime);\n@@ -254,17 +247,21 @@ class CAddrMan\n public:\n     /**\n      * serialized format:\n-     * * version byte (currently 0)\n-     * * nKey\n+     * * version byte (currently 1)\n+     * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)\n      * * nNew\n      * * nTried\n-     * * number of \"new\" buckets\n+     * * number of \"new\" buckets XOR 2**30\n      * * all nNew addrinfos in vvNew\n      * * all nTried addrinfos in vvTried\n      * * for each bucket:\n      *   * number of elements\n      *   * for each element: index\n      *\n+     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n+     * as incompatible. This is necessary because it did not check the version number on\n+     * deserialization.\n+     *\n      * Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n      * they are instead reconstructed from the other information.\n      *\n@@ -276,49 +273,53 @@ class CAddrMan\n      *\n      * We don't use ADD_SERIALIZE_METHODS since the serialization and deserialization code has\n      * very little in common.\n-     *\n      */\n     template<typename Stream>\n     void Serialize(Stream &s, int nType, int nVersionDummy) const\n     {\n         LOCK(cs);\n \n-        unsigned char nVersion = 0;\n+        unsigned char nVersion = 1;\n         s << nVersion;\n         s << ((unsigned char)32);\n         s << nKey;\n         s << nNew;\n         s << nTried;\n \n-        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n+        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n         s << nUBuckets;\n         std::map<int, int> mapUnkIds;\n         int nIds = 0;\n         for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            if (nIds == nNew) break; // this means nNew was wrong, oh ow\n             mapUnkIds[(*it).first] = nIds;\n             const CAddrInfo &info = (*it).second;\n             if (info.nRefCount) {\n+                assert(nIds != nNew); // this means nNew was wrong, oh ow\n                 s << info;\n                 nIds++;\n             }\n         }\n         nIds = 0;\n         for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            if (nIds == nTried) break; // this means nTried was wrong, oh ow\n             const CAddrInfo &info = (*it).second;\n             if (info.fInTried) {\n+                assert(nIds != nTried); // this means nTried was wrong, oh ow\n                 s << info;\n                 nIds++;\n             }\n         }\n-        for (std::vector<std::set<int> >::const_iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n-            const std::set<int> &vNew = (*it);\n-            int nSize = vNew.size();\n+        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+            int nSize = 0;\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+                if (vvNew[bucket][i] != -1)\n+                    nSize++;\n+            }\n             s << nSize;\n-            for (std::set<int>::const_iterator it2 = vNew.begin(); it2 != vNew.end(); it2++) {\n-                int nIndex = mapUnkIds[*it2];\n-                s << nIndex;\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+                if (vvNew[bucket][i] != -1) {\n+                    int nIndex = mapUnkIds[vvNew[bucket][i]];\n+                    s << nIndex;\n+                }\n             }\n         }\n     }\n@@ -328,86 +329,132 @@ class CAddrMan\n     {\n         LOCK(cs);\n \n+        Clear();\n+\n         unsigned char nVersion;\n         s >> nVersion;\n         unsigned char nKeySize;\n         s >> nKeySize;\n-        if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman\");\n+        if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman deserialization\");\n         s >> nKey;\n         s >> nNew;\n         s >> nTried;\n-\n         int nUBuckets = 0;\n         s >> nUBuckets;\n-        nIdCount = 0;\n-        mapInfo.clear();\n-        mapAddr.clear();\n-        vRandom.clear();\n-        vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n-        vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n+        if (nVersion != 0) {\n+            nUBuckets ^= (1 << 30);\n+        }\n+\n+        // Deserialize entries from the new table.\n         for (int n = 0; n < nNew; n++) {\n             CAddrInfo &info = mapInfo[n];\n             s >> info;\n             mapAddr[info] = n;\n             info.nRandomPos = vRandom.size();\n             vRandom.push_back(n);\n-            if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n-                vvNew[info.GetNewBucket(nKey)].insert(n);\n-                info.nRefCount++;\n+            if (nVersion != 1 || nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n+                // In case the new table data cannot be used (nVersion unknown, or bucket count wrong),\n+                // immediately try to give them a reference based on their primary source address.\n+                int nUBucket = info.GetNewBucket(nKey);\n+                int nUBucketPos = info.GetBucketPosition(nKey, true, nUBucket);\n+                if (vvNew[nUBucket][nUBucketPos] == -1) {\n+                    vvNew[nUBucket][nUBucketPos] = n;\n+                    info.nRefCount++;\n+                }\n             }\n         }\n         nIdCount = nNew;\n+\n+        // Deserialize entries from the tried table.\n         int nLost = 0;\n         for (int n = 0; n < nTried; n++) {\n             CAddrInfo info;\n             s >> info;\n-            std::vector<int> &vTried = vvTried[info.GetTriedBucket(nKey)];\n-            if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n+            int nKBucket = info.GetTriedBucket(nKey);\n+            int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n+            if (vvTried[nKBucket][nKBucketPos] == -1) {\n                 info.nRandomPos = vRandom.size();\n                 info.fInTried = true;\n                 vRandom.push_back(nIdCount);\n                 mapInfo[nIdCount] = info;\n                 mapAddr[info] = nIdCount;\n-                vTried.push_back(nIdCount);\n+                vvTried[nKBucket][nKBucketPos] = nIdCount;\n                 nIdCount++;\n             } else {\n                 nLost++;\n             }\n         }\n         nTried -= nLost;\n-        for (int b = 0; b < nUBuckets; b++) {\n-            std::set<int> &vNew = vvNew[b];\n+\n+        // Deserialize positions in the new table (if possible).\n+        for (int bucket = 0; bucket < nUBuckets; bucket++) {\n             int nSize = 0;\n             s >> nSize;\n             for (int n = 0; n < nSize; n++) {\n                 int nIndex = 0;\n                 s >> nIndex;\n-                CAddrInfo &info = mapInfo[nIndex];\n-                if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n-                    info.nRefCount++;\n-                    vNew.insert(nIndex);\n+                if (nIndex >= 0 && nIndex < nNew) {\n+                    CAddrInfo &info = mapInfo[nIndex];\n+                    int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n+                    if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n+                        info.nRefCount++;\n+                        vvNew[bucket][nUBucketPos] = nIndex;\n+                    }\n                 }\n             }\n         }\n+\n+        // Prune new entries with refcount 0 (as a result of collisions).\n+        int nLostUnk = 0;\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ) {\n+            if (it->second.fInTried == false && it->second.nRefCount == 0) {\n+                std::map<int, CAddrInfo>::const_iterator itCopy = it++;\n+                Delete(itCopy->first);\n+                nLostUnk++;\n+            } else {\n+                it++;\n+            }\n+        }\n+        if (nLost + nLostUnk > 0) {\n+            LogPrint(\"addrman\", \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n+        }\n+\n+        Check();\n     }\n \n     unsigned int GetSerializeSize(int nType, int nVersion) const\n     {\n         return (CSizeComputer(nType, nVersion) << *this).size();\n     }\n \n-    CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n+    void Clear()\n     {\n-         nKey = GetRandHash();\n+        std::vector<int>().swap(vRandom);\n+        nKey = GetRandHash();\n+        for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+                vvNew[bucket][entry] = -1;\n+            }\n+        }\n+        for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; bucket++) {\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+                vvTried[bucket][entry] = -1;\n+            }\n+        }\n \n-         nIdCount = 0;\n-         nTried = 0;\n-         nNew = 0;\n+        nIdCount = 0;\n+        nTried = 0;\n+        nNew = 0;\n+    }\n+\n+    CAddrMan()\n+    {\n+        Clear();\n     }\n \n     ~CAddrMan()\n     {\n-         nKey.SetNull();\n+        nKey.SetNull();\n     }\n \n     //! Return the number of (unique) addresses in all tables."
      }
    ]
  },
  {
    "sha": "a8ff7c62edc63c7c94bc91c30b80995539ed7477",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOGZmN2M2MmVkYzYzYzdjOTRiYzkxYzMwYjgwOTk1NTM5ZWQ3NDc3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-19T15:50:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-24T00:23:40Z"
      },
      "message": "Simplify hashing code",
      "tree": {
        "sha": "738ec60be876b4e02d08d642301916ee5f29e635",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/738ec60be876b4e02d08d642301916ee5f29e635"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a8ff7c62edc63c7c94bc91c30b80995539ed7477",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8ff7c62edc63c7c94bc91c30b80995539ed7477",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a8ff7c62edc63c7c94bc91c30b80995539ed7477",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8ff7c62edc63c7c94bc91c30b80995539ed7477/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e6b343d880f50d52390c5af8623afa15fcbc65a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6b343d880f50d52390c5af8623afa15fcbc65a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e6b343d880f50d52390c5af8623afa15fcbc65a2"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 5,
      "deletions": 21
    },
    "files": [
      {
        "sha": "05688fbdf0bbe99260dcb1c2aeed729900fc871a",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 21,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8ff7c62edc63c7c94bc91c30b80995539ed7477/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8ff7c62edc63c7c94bc91c30b80995539ed7477/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=a8ff7c62edc63c7c94bc91c30b80995539ed7477",
        "patch": "@@ -12,38 +12,22 @@ using namespace std;\n \n int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n {\n-    CDataStream ss1(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchKey = GetKey();\n-    ss1 << nKey << vchKey;\n-    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n-\n-    CDataStream ss2(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchGroupKey = GetGroup();\n-    ss2 << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n-    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetHash().GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetHash().GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n \n int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n {\n-    CDataStream ss1(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchGroupKey = GetGroup();\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n-    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n-    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n-\n-    CDataStream ss2(SER_GETHASH, 0);\n-    ss2 << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n-    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << vchSourceGroupKey).GetHash().GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetHash().GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n }\n \n int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n {\n-    CDataStream ss1(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchKey = GetKey();\n-    ss1 << nKey << (fNew ? 'N' : 'K') << nBucket << vchKey;\n-    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? 'N' : 'K') << nBucket << GetKey()).GetHash().GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n }\n "
      }
    ]
  },
  {
    "sha": "f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNjhiYTNmNjdiZDUwMGE2NGZiODkzMmM2YjQxOTI0ZGRjMzFkNzZm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-19T16:44:26Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-24T00:23:40Z"
      },
      "message": "Do not bias outgoing connections towards fresh addresses\n\nThis change was suggested as Countermeasure 2 in\nEclipse Attacks on Bitcoin\u2019s Peer-to-Peer Network, Ethan Heilman,\nAlison Kendler, Aviv Zohar, Sharon Goldberg. ePrint Archive Report\n2015/263. March 2015.",
      "tree": {
        "sha": "e3a16852cb0e0f89f423357745fbee8bc3a3a129",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e3a16852cb0e0f89f423357745fbee8bc3a3a129"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f68ba3f67bd500a64fb8932c6b41924ddc31d76f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8ff7c62edc63c7c94bc91c30b80995539ed7477",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8ff7c62edc63c7c94bc91c30b80995539ed7477",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8ff7c62edc63c7c94bc91c30b80995539ed7477"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 0,
      "deletions": 2
    },
    "files": [
      {
        "sha": "eb431ec59c8e04bcce013df55652302699531d79",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68ba3f67bd500a64fb8932c6b41924ddc31d76f/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68ba3f67bd500a64fb8932c6b41924ddc31d76f/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
        "patch": "@@ -63,8 +63,6 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     if (nSinceLastTry < 0)\n         nSinceLastTry = 0;\n \n-    fChance *= 600.0 / (600.0 + nSinceLastSeen);\n-\n     // deprioritize very recent attempts away\n     if (nSinceLastTry < 60 * 10)\n         fChance *= 0.01;"
      }
    ]
  },
  {
    "sha": "c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmE2M2NlZWI0OTU2OTMzNTg4OTk1YmNmMDFkYzMwOTVhYWViMWZj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-19T16:51:59Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-24T00:24:18Z"
      },
      "message": "Always use a 50% chance to choose between tried and new entries\n\nThis change was suggested as Countermeasure 2 in\nEclipse Attacks on Bitcoin\u2019s Peer-to-Peer Network, Ethan Heilman,\nAlison Kendler, Aviv Zohar, Sharon Goldberg. ePrint Archive Report\n2015/263. March 2015.",
      "tree": {
        "sha": "b88a7fe5aebb9118f552d4be074a6e7eca22fa8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b88a7fe5aebb9118f552d4be074a6e7eca22fa8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f68ba3f67bd500a64fb8932c6b41924ddc31d76f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f68ba3f67bd500a64fb8932c6b41924ddc31d76f"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 7,
      "deletions": 9
    },
    "files": [
      {
        "sha": "5d9527f0e15908661274623914acafae581de5bc",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
        "patch": "@@ -332,14 +332,13 @@ void CAddrMan::Attempt_(const CService& addr, int64_t nTime)\n     info.nAttempts++;\n }\n \n-CAddress CAddrMan::Select_(int nUnkBias)\n+CAddress CAddrMan::Select_()\n {\n     if (size() == 0)\n         return CAddress();\n \n-    double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n-    double nCorNew = sqrt(nNew) * nUnkBias;\n-    if ((nCorTried + nCorNew) * GetRandInt(1 << 30) / (1 << 30) < nCorTried) {\n+    // Use a 50% chance for choosing between tried and new table entries.\n+    if (nTried > 0 && (nNew == 0 || GetRandInt(2) == 0)) {\n         // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {"
      },
      {
        "sha": "fe06a745b5ccbd3e8f17b2cf77a755cc830a4685",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
        "patch": "@@ -231,7 +231,7 @@ class CAddrMan\n \n     //! Select an address to connect to.\n     //! nUnkBias determines how much to favor new addresses over tried ones (min=0, max=100)\n-    CAddress Select_(int nUnkBias);\n+    CAddress Select_();\n \n #ifdef DEBUG_ADDRMAN\n     //! Perform consistency check. Returns an error code or zero.\n@@ -533,13 +533,13 @@ class CAddrMan\n      * Choose an address to connect to.\n      * nUnkBias determines how much \"new\" entries are favored over \"tried\" ones (0-100).\n      */\n-    CAddress Select(int nUnkBias = 50)\n+    CAddress Select()\n     {\n         CAddress addrRet;\n         {\n             LOCK(cs);\n             Check();\n-            addrRet = Select_(nUnkBias);\n+            addrRet = Select_();\n             Check();\n         }\n         return addrRet;"
      },
      {
        "sha": "d8991ffa8df1b5cf8691a4846bbf8cfa9b98efe7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6a63ceeb4956933588995bcf01dc3095aaeb1fc/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
        "patch": "@@ -1221,8 +1221,7 @@ void ThreadOpenConnections()\n         int nTries = 0;\n         while (true)\n         {\n-            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n-            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n+            CAddress addr = addrman.Select();\n \n             // if we selected an invalid address, restart\n             if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))"
      }
    ]
  },
  {
    "sha": "1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZDIxYmEyZjVlY2JmMDMwODZkMGI2NWM0YzRjODBhMzlhOTRjMmVl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-19T17:01:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-03-24T00:24:29Z"
      },
      "message": "Scale up addrman\n\nThis change was suggested as Countermeasure 6 in\nEclipse Attacks on Bitcoin\u2019s Peer-to-Peer Network, Ethan Heilman,\nAlison Kendler, Aviv Zohar, Sharon Goldberg. ePrint Archive Report\n2015/263. March 2015.",
      "tree": {
        "sha": "777bb3d5bbf662ced58017621f4f82b61bd60495",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/777bb3d5bbf662ced58017621f4f82b61bd60495"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6a63ceeb4956933588995bcf01dc3095aaeb1fc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6a63ceeb4956933588995bcf01dc3095aaeb1fc"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 10,
      "deletions": 10
    },
    "files": [
      {
        "sha": "8116d0b763df4694f1421b7c7a5d11fda890bc70",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=1d21ba2f5ecbf03086d0b65c4c4c80a39a94c2ee",
        "patch": "@@ -109,15 +109,15 @@ class CAddrInfo : public CAddress\n  *\n  * To that end:\n  *  * Addresses are organized into buckets.\n- *    * Address that have not yet been tried go into 256 \"new\" buckets.\n- *      * Based on the address range (/16 for IPv4) of source of the information, 32 buckets are selected at random\n+ *    * Address that have not yet been tried go into 1024 \"new\" buckets.\n+ *      * Based on the address range (/16 for IPv4) of source of the information, 64 buckets are selected at random\n  *      * The actual bucket is chosen from one of these, based on the range the address itself is located.\n- *      * One single address can occur in up to 4 different buckets, to increase selection chances for addresses that\n+ *      * One single address can occur in up to 8 different buckets, to increase selection chances for addresses that\n  *        are seen frequently. The chance for increasing this multiplicity decreases exponentially.\n  *      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen\n  *        ones) is removed from it first.\n- *    * Addresses of nodes that are known to be accessible go into 64 \"tried\" buckets.\n- *      * Each address range selects at random 4 of these buckets.\n+ *    * Addresses of nodes that are known to be accessible go into 256 \"tried\" buckets.\n+ *      * Each address range selects at random 8 of these buckets.\n  *      * The actual bucket is chosen from one of these, based on the full address.\n  *      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently\n  *        tried ones) is evicted from it, back to the \"new\" buckets.\n@@ -128,22 +128,22 @@ class CAddrInfo : public CAddress\n  */\n \n //! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT 64\n+#define ADDRMAN_TRIED_BUCKET_COUNT 256\n \n //! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT 256\n+#define ADDRMAN_NEW_BUCKET_COUNT 1024\n \n //! maximum allowed number of entries in buckets for new and tried addresses\n #define ADDRMAN_BUCKET_SIZE 64\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n-#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 4\n+#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n \n //! over how many buckets entries with new addresses originating from a single group are spread\n-#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 32\n+#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 64\n \n //! in how many buckets for entries with new addresses a single address may occur\n-#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 4\n+#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 8\n \n //! how old addresses can maximally be\n #define ADDRMAN_HORIZON_DAYS 30"
      }
    ]
  }
]