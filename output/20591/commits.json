[
  {
    "sha": "07b44f16e71b9df10dfac7f32f92997938f7e7aa",
    "node_id": "C_kwDOABII59oAKDA3YjQ0ZjE2ZTcxYjlkZjEwZGZhYzdmMzJmOTI5OTc5MzhmN2U3YWE",
    "commit": {
      "author": {
        "name": "BitcoinTsunami",
        "email": "",
        "date": "2020-12-07T16:29:48Z"
      },
      "committer": {
        "name": "BitcoinTsunami",
        "email": "",
        "date": "2021-09-28T18:56:52Z"
      },
      "message": "wallet: fix ComputeTimeSmart algorithm to use blocktime during old block rescanning",
      "tree": {
        "sha": "358f11918fb37ccf9fdf06069f7f5cd933160697",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/358f11918fb37ccf9fdf06069f7f5cd933160697"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07b44f16e71b9df10dfac7f32f92997938f7e7aa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07b44f16e71b9df10dfac7f32f92997938f7e7aa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/07b44f16e71b9df10dfac7f32f92997938f7e7aa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07b44f16e71b9df10dfac7f32f92997938f7e7aa/comments",
    "author": {},
    "committer": {},
    "parents": [
      {
        "sha": "09cb5ec6c8b4468ee3e8c2b3e1a9075907e5c84d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cb5ec6c8b4468ee3e8c2b3e1a9075907e5c84d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/09cb5ec6c8b4468ee3e8c2b3e1a9075907e5c84d"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 41,
      "deletions": 36
    },
    "files": [
      {
        "sha": "f0df5016e92b9e491dc80dd240094385fd387d3f",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 32,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07b44f16e71b9df10dfac7f32f92997938f7e7aa/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07b44f16e71b9df10dfac7f32f92997938f7e7aa/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=07b44f16e71b9df10dfac7f32f92997938f7e7aa",
        "patch": "@@ -884,7 +884,7 @@ bool CWallet::IsSpentKey(const uint256& hash, unsigned int n) const\n     return false;\n }\n \n-CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx, bool fFlushOnClose)\n+CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx, bool fFlushOnClose, bool rescanning_old_block)\n {\n     LOCK(cs_wallet);\n \n@@ -914,7 +914,7 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n         wtx.nTimeReceived = chain().getAdjustedTime();\n         wtx.nOrderPos = IncOrderPosNext(&batch);\n         wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));\n-        wtx.nTimeSmart = ComputeTimeSmart(wtx);\n+        wtx.nTimeSmart = ComputeTimeSmart(wtx, rescanning_old_block);\n         AddToSpends(hash, &batch);\n     }\n \n@@ -1031,7 +1031,7 @@ bool CWallet::LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx\n     return true;\n }\n \n-bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Confirmation confirm, bool fUpdate)\n+bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Confirmation confirm, bool fUpdate, bool rescanning_old_block)\n {\n     const CTransaction& tx = *ptx;\n     {\n@@ -1069,7 +1069,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Co\n \n             // Block disconnection override an abandoned tx as unconfirmed\n             // which means user may have to call abandontransaction again\n-            return AddToWallet(MakeTransactionRef(tx), confirm, /* update_wtx= */ nullptr, /* fFlushOnClose= */ false);\n+            return AddToWallet(MakeTransactionRef(tx), confirm, /* update_wtx= */ nullptr, /* fFlushOnClose= */ false, rescanning_old_block);\n         }\n     }\n     return false;\n@@ -1198,9 +1198,9 @@ void CWallet::MarkConflicted(const uint256& hashBlock, int conflicting_height, c\n     }\n }\n \n-void CWallet::SyncTransaction(const CTransactionRef& ptx, CWalletTx::Confirmation confirm, bool update_tx)\n+void CWallet::SyncTransaction(const CTransactionRef& ptx, CWalletTx::Confirmation confirm, bool update_tx, bool rescanning_old_block)\n {\n-    if (!AddToWalletIfInvolvingMe(ptx, confirm, update_tx))\n+    if (!AddToWalletIfInvolvingMe(ptx, confirm, update_tx, rescanning_old_block))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -1643,7 +1643,7 @@ CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_bloc\n                 break;\n             }\n             for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                SyncTransaction(block.vtx[posInBlock], {CWalletTx::Status::CONFIRMED, block_height, block_hash, (int)posInBlock}, fUpdate);\n+                SyncTransaction(block.vtx[posInBlock], {CWalletTx::Status::CONFIRMED, block_height, block_hash, (int)posInBlock}, fUpdate, /* rescanning_old_block */ true);\n             }\n             // scan succeeded, record block as most recent successfully scanned\n             result.last_scanned_block = block_hash;\n@@ -2398,38 +2398,43 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n  * https://bitcointalk.org/?topic=54527, or\n  * https://github.com/bitcoin/bitcoin/pull/1393.\n  */\n-unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n+unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx, bool rescanning_old_block) const\n {\n     unsigned int nTimeSmart = wtx.nTimeReceived;\n     if (!wtx.isUnconfirmed() && !wtx.isAbandoned()) {\n         int64_t blocktime;\n-        if (chain().findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(blocktime))) {\n-            int64_t latestNow = wtx.nTimeReceived;\n-            int64_t latestEntry = 0;\n-\n-            // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n-            int64_t latestTolerated = latestNow + 300;\n-            const TxItems& txOrdered = wtxOrdered;\n-            for (auto it = txOrdered.rbegin(); it != txOrdered.rend(); ++it) {\n-                CWalletTx* const pwtx = it->second;\n-                if (pwtx == &wtx) {\n-                    continue;\n-                }\n-                int64_t nSmartTime;\n-                nSmartTime = pwtx->nTimeSmart;\n-                if (!nSmartTime) {\n-                    nSmartTime = pwtx->nTimeReceived;\n-                }\n-                if (nSmartTime <= latestTolerated) {\n-                    latestEntry = nSmartTime;\n-                    if (nSmartTime > latestNow) {\n-                        latestNow = nSmartTime;\n+        int64_t block_max_time;\n+        if (chain().findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(blocktime).maxTime(block_max_time))) {\n+            if (rescanning_old_block) {\n+                nTimeSmart = block_max_time;\n+            } else {\n+                int64_t latestNow = wtx.nTimeReceived;\n+                int64_t latestEntry = 0;\n+\n+                // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n+                int64_t latestTolerated = latestNow + 300;\n+                const TxItems& txOrdered = wtxOrdered;\n+                for (auto it = txOrdered.rbegin(); it != txOrdered.rend(); ++it) {\n+                    CWalletTx* const pwtx = it->second;\n+                    if (pwtx == &wtx) {\n+                        continue;\n+                    }\n+                    int64_t nSmartTime;\n+                    nSmartTime = pwtx->nTimeSmart;\n+                    if (!nSmartTime) {\n+                        nSmartTime = pwtx->nTimeReceived;\n+                    }\n+                    if (nSmartTime <= latestTolerated) {\n+                        latestEntry = nSmartTime;\n+                        if (nSmartTime > latestNow) {\n+                            latestNow = nSmartTime;\n+                        }\n+                        break;\n                     }\n-                    break;\n                 }\n-            }\n \n-            nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n+                nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n+            }\n         } else {\n             WalletLogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.m_confirm.hashBlock.ToString());\n         }"
      },
      {
        "sha": "10bac9d5d78bfe8cb3a8fe478994dce1e9124a83",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07b44f16e71b9df10dfac7f32f92997938f7e7aa/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07b44f16e71b9df10dfac7f32f92997938f7e7aa/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=07b44f16e71b9df10dfac7f32f92997938f7e7aa",
        "patch": "@@ -272,7 +272,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Abandoned state should probably be more carefully tracked via different\n      * posInBlock signals or by checking mempool presence when necessary.\n      */\n-    bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool fUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool fUpdate, bool rescanning_old_block) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /** Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n     void MarkConflicted(const uint256& hashBlock, int conflicting_height, const uint256& hashTx);\n@@ -284,7 +284,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected/ScanForWalletTransactions.\n      * Should be called with non-zero block_hash and posInBlock if this is for a transaction that is included in a block. */\n-    void SyncTransaction(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool update_tx = true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void SyncTransaction(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool update_tx = true, bool rescanning_old_block = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /** WalletFlags set on this wallet. */\n     std::atomic<uint64_t> m_wallet_flags{0};\n@@ -484,7 +484,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool EncryptWallet(const SecureString& strWalletPassphrase);\n \n     void GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    unsigned int ComputeTimeSmart(const CWalletTx& wtx) const;\n+    unsigned int ComputeTimeSmart(const CWalletTx& wtx, bool rescanning_old_block) const;\n \n     /**\n      * Increment the next transaction order id\n@@ -503,7 +503,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     //! @return true if wtx is changed and needs to be saved to disk, otherwise false\n     using UpdateWalletTxFn = std::function<bool(CWalletTx& wtx, bool new_tx)>;\n \n-    CWalletTx* AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true);\n+    CWalletTx* AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true, bool rescanning_old_block = false);\n     bool LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override;\n     void blockConnected(const CBlock& block, int height) override;"
      }
    ]
  },
  {
    "sha": "d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
    "node_id": "C_kwDOABII59oAKGQ2ZWIzOWFmMjE4MTBiZjFjM2JkY2UwZWYyMjEyYzFhZDY1OTdiY2Q",
    "commit": {
      "author": {
        "name": "BitcoinTsunami",
        "email": "",
        "date": "2020-12-07T16:45:47Z"
      },
      "committer": {
        "name": "BitcoinTsunami",
        "email": "",
        "date": "2021-09-28T19:49:22Z"
      },
      "message": "test: add functional test to check transaction time determination during block rescanning",
      "tree": {
        "sha": "260f636eca72bd136188ffcbdd724413d859ec57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/260f636eca72bd136188ffcbdd724413d859ec57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd/comments",
    "author": {},
    "committer": {},
    "parents": [
      {
        "sha": "07b44f16e71b9df10dfac7f32f92997938f7e7aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07b44f16e71b9df10dfac7f32f92997938f7e7aa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/07b44f16e71b9df10dfac7f32f92997938f7e7aa"
      }
    ],
    "stats": {
      "total": 162,
      "additions": 162,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3387132cc732cd8fa6e523c7fdb2dcc9a659b157",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
        "patch": "@@ -175,6 +175,7 @@\n     'rpc_rawtransaction.py --legacy-wallet',\n     'rpc_rawtransaction.py --descriptors',\n     'wallet_groups.py --legacy-wallet',\n+    'wallet_transactiontime_rescan.py',\n     'p2p_addrv2_relay.py',\n     'wallet_groups.py --descriptors',\n     'p2p_compactblocks_hb.py',"
      },
      {
        "sha": "78859e6131a7801bb8ba0fe67955598dcb5a5d22",
        "filename": "test/functional/wallet_transactiontime_rescan.py",
        "status": "added",
        "additions": 161,
        "deletions": 0,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd/test/functional/wallet_transactiontime_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd/test/functional/wallet_transactiontime_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_transactiontime_rescan.py?ref=d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
        "patch": "@@ -0,0 +1,161 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction time during old block rescanning\n+\"\"\"\n+\n+import time\n+\n+from test_framework.blocktools import COINBASE_MATURITY\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal\n+)\n+\n+\n+class TransactionTimeRescanTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = False\n+        self.num_nodes = 3\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.log.info('Prepare nodes and wallet')\n+\n+        minernode = self.nodes[0]  # node used to mine BTC and create transactions\n+        usernode = self.nodes[1]  # user node with correct time\n+        restorenode = self.nodes[2]  # node used to restore user wallet and check time determination in ComputeSmartTime (wallet.cpp)\n+\n+        # time constant\n+        cur_time = int(time.time())\n+        ten_days = 10 * 24 * 60 * 60\n+\n+        # synchronize nodes and time\n+        self.sync_all()\n+        minernode.setmocktime(cur_time)\n+        usernode.setmocktime(cur_time)\n+        restorenode.setmocktime(cur_time)\n+\n+        # prepare miner wallet\n+        minernode.createwallet(wallet_name='default')\n+        miner_wallet = minernode.get_wallet_rpc('default')\n+        m1 = miner_wallet.getnewaddress()\n+\n+        # prepare the user wallet with 3 watch only addresses\n+        wo1 = usernode.getnewaddress()\n+        wo2 = usernode.getnewaddress()\n+        wo3 = usernode.getnewaddress()\n+\n+        usernode.createwallet(wallet_name='wo', disable_private_keys=True)\n+        wo_wallet = usernode.get_wallet_rpc('wo')\n+\n+        wo_wallet.importaddress(wo1)\n+        wo_wallet.importaddress(wo2)\n+        wo_wallet.importaddress(wo3)\n+\n+        self.log.info('Start transactions')\n+\n+        # check blockcount\n+        assert_equal(minernode.getblockcount(), 200)\n+\n+        # generate some btc to create transactions and check blockcount\n+        initial_mine = COINBASE_MATURITY + 1\n+        minernode.generatetoaddress(initial_mine, m1)\n+        assert_equal(minernode.getblockcount(), initial_mine + 200)\n+\n+        # synchronize nodes and time\n+        self.sync_all()\n+        minernode.setmocktime(cur_time + ten_days)\n+        usernode.setmocktime(cur_time + ten_days)\n+        restorenode.setmocktime(cur_time + ten_days)\n+        # send 10 btc to user's first watch-only address\n+        self.log.info('Send 10 btc to user')\n+        miner_wallet.sendtoaddress(wo1, 10)\n+\n+        # generate blocks and check blockcount\n+        minernode.generatetoaddress(COINBASE_MATURITY, m1)\n+        assert_equal(minernode.getblockcount(), initial_mine + 300)\n+\n+        # synchronize nodes and time\n+        self.sync_all()\n+        minernode.setmocktime(cur_time + ten_days + ten_days)\n+        usernode.setmocktime(cur_time + ten_days + ten_days)\n+        restorenode.setmocktime(cur_time + ten_days + ten_days)\n+        # send 5 btc to our second watch-only address\n+        self.log.info('Send 5 btc to user')\n+        miner_wallet.sendtoaddress(wo2, 5)\n+\n+        # generate blocks and check blockcount\n+        minernode.generatetoaddress(COINBASE_MATURITY, m1)\n+        assert_equal(minernode.getblockcount(), initial_mine + 400)\n+\n+        # synchronize nodes and time\n+        self.sync_all()\n+        minernode.setmocktime(cur_time + ten_days + ten_days + ten_days)\n+        usernode.setmocktime(cur_time + ten_days + ten_days + ten_days)\n+        restorenode.setmocktime(cur_time + ten_days + ten_days + ten_days)\n+        # send 1 btc to our third watch-only address\n+        self.log.info('Send 1 btc to user')\n+        miner_wallet.sendtoaddress(wo3, 1)\n+\n+        # generate more blocks and check blockcount\n+        minernode.generatetoaddress(COINBASE_MATURITY, m1)\n+        assert_equal(minernode.getblockcount(), initial_mine + 500)\n+\n+        self.log.info('Check user\\'s final balance and transaction count')\n+        assert_equal(wo_wallet.getbalance(), 16)\n+        assert_equal(len(wo_wallet.listtransactions()), 3)\n+\n+        self.log.info('Check transaction times')\n+        for tx in wo_wallet.listtransactions():\n+            if tx['address'] == wo1:\n+                assert_equal(tx['blocktime'], cur_time + ten_days)\n+                assert_equal(tx['time'], cur_time + ten_days)\n+            elif tx['address'] == wo2:\n+                assert_equal(tx['blocktime'], cur_time + ten_days + ten_days)\n+                assert_equal(tx['time'], cur_time + ten_days + ten_days)\n+            elif tx['address'] == wo3:\n+                assert_equal(tx['blocktime'], cur_time + ten_days + ten_days + ten_days)\n+                assert_equal(tx['time'], cur_time + ten_days + ten_days + ten_days)\n+\n+        # restore user wallet without rescan\n+        self.log.info('Restore user wallet on another node without rescan')\n+        restorenode.createwallet(wallet_name='wo', disable_private_keys=True)\n+        restorewo_wallet = restorenode.get_wallet_rpc('wo')\n+\n+        restorewo_wallet.importaddress(wo1, rescan=False)\n+        restorewo_wallet.importaddress(wo2, rescan=False)\n+        restorewo_wallet.importaddress(wo3, rescan=False)\n+\n+        # check user has 0 balance and no transactions\n+        assert_equal(restorewo_wallet.getbalance(), 0)\n+        assert_equal(len(restorewo_wallet.listtransactions()), 0)\n+\n+        # proceed to rescan, first with an incomplete one, then with a full rescan\n+        self.log.info('Rescan last history part')\n+        restorewo_wallet.rescanblockchain(initial_mine + 350)\n+        self.log.info('Rescan all history')\n+        restorewo_wallet.rescanblockchain()\n+\n+        self.log.info('Check user\\'s final balance and transaction count after restoration')\n+        assert_equal(restorewo_wallet.getbalance(), 16)\n+        assert_equal(len(restorewo_wallet.listtransactions()), 3)\n+\n+        self.log.info('Check transaction times after restoration')\n+        for tx in restorewo_wallet.listtransactions():\n+            if tx['address'] == wo1:\n+                assert_equal(tx['blocktime'], cur_time + ten_days)\n+                assert_equal(tx['time'], cur_time + ten_days)\n+            elif tx['address'] == wo2:\n+                assert_equal(tx['blocktime'], cur_time + ten_days + ten_days)\n+                assert_equal(tx['time'], cur_time + ten_days + ten_days)\n+            elif tx['address'] == wo3:\n+                assert_equal(tx['blocktime'], cur_time + ten_days + ten_days + ten_days)\n+                assert_equal(tx['time'], cur_time + ten_days + ten_days + ten_days)\n+\n+\n+if __name__ == '__main__':\n+    TransactionTimeRescanTest().main()"
      }
    ]
  },
  {
    "sha": "240ea294d5e899a906f213f039b21e94c24d6018",
    "node_id": "C_kwDOABII59oAKDI0MGVhMjk0ZDVlODk5YTkwNmYyMTNmMDM5YjIxZTk0YzI0ZDYwMTg",
    "commit": {
      "author": {
        "name": "BitcoinTsunami",
        "email": "",
        "date": "2020-12-10T23:00:43Z"
      },
      "committer": {
        "name": "BitcoinTsunami",
        "email": "",
        "date": "2021-09-28T19:49:35Z"
      },
      "message": "doc: update doxygen documention of ComputeTimeSmart() and AddToWalletIfInvolvingMe() regarding rescanning_old_block parameter",
      "tree": {
        "sha": "52533a4cb1156b3dd7a604272d52d144b78114aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/52533a4cb1156b3dd7a604272d52d144b78114aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/240ea294d5e899a906f213f039b21e94c24d6018",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/240ea294d5e899a906f213f039b21e94c24d6018",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/240ea294d5e899a906f213f039b21e94c24d6018",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/240ea294d5e899a906f213f039b21e94c24d6018/comments",
    "author": {},
    "committer": {},
    "parents": [
      {
        "sha": "d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6eb39af21810bf1c3bdce0ef2212c1ad6597bcd"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0452474f2f2bcac2d6e8903f85cbed490e3f2653",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/240ea294d5e899a906f213f039b21e94c24d6018/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/240ea294d5e899a906f213f039b21e94c24d6018/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=240ea294d5e899a906f213f039b21e94c24d6018",
        "patch": "@@ -2384,6 +2384,8 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n  * - If sending a transaction, assign its timestamp to the current time.\n  * - If receiving a transaction outside a block, assign its timestamp to the\n  *   current time.\n+ * - If receiving a transaction during a rescanning process, assign all its\n+ *   (not already known) transactions' timestamps to the block time.\n  * - If receiving a block with a future timestamp, assign all its (not already\n  *   known) transactions' timestamps to the current time.\n  * - If receiving a block with a past timestamp, before the most recent known"
      },
      {
        "sha": "15a59334248e214a12bc77208efa92c0d5cfb3a7",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/240ea294d5e899a906f213f039b21e94c24d6018/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/240ea294d5e899a906f213f039b21e94c24d6018/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=240ea294d5e899a906f213f039b21e94c24d6018",
        "patch": "@@ -271,6 +271,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * abandoned is an indication that it is not safe to be considered abandoned.\n      * Abandoned state should probably be more carefully tracked via different\n      * posInBlock signals or by checking mempool presence when necessary.\n+     *\n+     * Should be called with rescanning_old_block set to true, if the transaction is\n+     * not discovered in real time, but during a rescan of old blocks.\n      */\n     bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool fUpdate, bool rescanning_old_block) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n "
      }
    ]
  }
]