[
  {
    "sha": "8a8c6383f6f9da10b931f00ca1220408fede8f35",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YThjNjM4M2Y2ZjlkYTEwYjkzMWYwMGNhMTIyMDQwOGZlZGU4ZjM1",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-02-27T17:32:48Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-03-01T00:31:41Z"
      },
      "message": "zmq test: fix sync-up by matching notification to generated block\n\nIt turned out that the \"sync up\" procedure of repeatedly generating a\nblock and waiting for a notification once with timeout is too naive in\nits current form, as the following scenario could happen:\n    - generate block A\n    - receive notification, timeout happens -> repeat procedure\n    - generate block B\n    - node publishes block A notification\n    - receive notification, we receive the one caused by block A\n      -> sync-up procedure is completed\n    - node publishes block B\n    - the actual test starts\n    - on the first notification reception, one caused by block B is received,\n      rather than the one actually caused by test code, leading to failure\n\nThis change ensures that after each test block generation, we wait for\nthe notification that is actually caused by that block and ignore others\nfrom possibly earlier blocks.\n\nCo-authored-by: Jon Atack <jon@atack.com>",
      "tree": {
        "sha": "67f6e7c30e287bfc22ea7f24687e7b24f45dd45c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/67f6e7c30e287bfc22ea7f24687e7b24f45dd45c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8a8c6383f6f9da10b931f00ca1220408fede8f35",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a8c6383f6f9da10b931f00ca1220408fede8f35",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8a8c6383f6f9da10b931f00ca1220408fede8f35",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a8c6383f6f9da10b931f00ca1220408fede8f35/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb67caebe26f49a1edfff20c754b8217ef4f23ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb67caebe26f49a1edfff20c754b8217ef4f23ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb67caebe26f49a1edfff20c754b8217ef4f23ad"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 34,
      "deletions": 8
    },
    "files": [
      {
        "sha": "94e162b748f1b1b61e5815b97f2837ec11fe6cd0",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 34,
        "deletions": 8,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a8c6383f6f9da10b931f00ca1220408fede8f35/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a8c6383f6f9da10b931f00ca1220408fede8f35/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=8a8c6383f6f9da10b931f00ca1220408fede8f35",
        "patch": "@@ -62,6 +62,31 @@ def receive_sequence(self):\n         return (hash, label, mempool_sequence)\n \n \n+class ZMQTestSetupBlock:\n+    \"\"\"Helper class for setting up a ZMQ test via the \"sync up\" procedure.\n+    Generates a block on the specified node on instantiation and provides a\n+    method to check whether a ZMQ notification matches, i.e. the event was\n+    caused by this generated block.  Assumes that a notification either contains\n+    the generated block's hash, it's (coinbase) transaction id, the raw block or\n+    raw transaction data.\n+    \"\"\"\n+\n+    def __init__(self, node):\n+        self.block_hash = node.generate(1)[0]\n+        coinbase = node.getblock(self.block_hash, 2)['tx'][0]\n+        self.tx_hash = coinbase['txid']\n+        self.raw_tx = coinbase['hex']\n+        self.raw_block = node.getblock(self.block_hash, 0)\n+\n+    def caused_notification(self, notification):\n+        return (\n+            self.block_hash in notification\n+            or self.tx_hash in notification\n+            or self.raw_block in notification\n+            or self.raw_tx in notification\n+        )\n+\n+\n class ZMQTest (BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n@@ -105,17 +130,18 @@ def setup_zmq_test(self, services, *, recv_timeout=60, sync_blocks=True):\n         # Ensure that all zmq publisher notification interfaces are ready by\n         # running the following \"sync up\" procedure:\n         #   1. Generate a block on the node\n-        #   2. Try to receive a notification on all subscribers\n-        #   3. If all subscribers get a message within the timeout (1 second),\n+        #   2. Try to receive the corresponding notification on all subscribers\n+        #   3. If all subscribers get the message within the timeout (1 second),\n         #      we are done, otherwise repeat starting from step 1\n         for sub in subscribers:\n             sub.socket.set(zmq.RCVTIMEO, 1000)\n         while True:\n-            self.nodes[0].generate(1)\n+            test_block = ZMQTestSetupBlock(self.nodes[0])\n             recv_failed = False\n             for sub in subscribers:\n                 try:\n-                    sub.receive()\n+                    while not test_block.caused_notification(sub.receive().hex()):\n+                        self.log.debug(\"Ignoring sync-up notification for previously generated block.\")\n                 except zmq.error.Again:\n                     self.log.debug(\"Didn't receive sync-up notification, trying again.\")\n                     recv_failed = True\n@@ -340,7 +366,7 @@ def test_sequence(self):\n             block_count = self.nodes[0].getblockcount()\n             best_hash = self.nodes[0].getbestblockhash()\n             self.nodes[0].invalidateblock(best_hash)\n-            sleep(2) # Bit of room to make sure transaction things happened\n+            sleep(2)  # Bit of room to make sure transaction things happened\n \n             # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n             # of the time they were gathered.\n@@ -389,8 +415,8 @@ def test_sequence(self):\n             assert_equal(label, \"A\")\n             # More transactions to be simply mined\n             for i in range(len(more_tx)):\n-                    assert_equal((more_tx[i], \"A\", mempool_seq), seq.receive_sequence())\n-                    mempool_seq += 1\n+                assert_equal((more_tx[i], \"A\", mempool_seq), seq.receive_sequence())\n+                mempool_seq += 1\n             # Bumped by rbf\n             assert_equal((orig_txid, \"R\", mempool_seq), seq.receive_sequence())\n             mempool_seq += 1\n@@ -405,7 +431,7 @@ def test_sequence(self):\n             assert_equal((orig_txid_2, \"A\", mempool_seq), seq.receive_sequence())\n             mempool_seq += 1\n             self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n-            self.sync_all() # want to make sure we didn't break \"consensus\" for other tests\n+            self.sync_all()  # want to make sure we didn't break \"consensus\" for other tests\n \n     def test_mempool_sync(self):\n         \"\"\""
      }
    ]
  }
]