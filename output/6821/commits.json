[
  {
    "sha": "b0e5b158484bd6be487400b098747b6904d8e854",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMGU1YjE1ODQ4NGJkNmJlNDg3NDAwYjA5ODc0N2I2OTA0ZDhlODU0",
    "commit": {
      "author": {
        "name": "Daniel Kraft",
        "email": "d@domob.eu",
        "date": "2015-10-13T17:50:26Z"
      },
      "committer": {
        "name": "Daniel Kraft",
        "email": "d@domob.eu",
        "date": "2015-10-13T17:50:26Z"
      },
      "message": "net: avoid duplicate getheaders requests\n\nIf new blocks are announced while a node is currently still downloading\nthe headers, it starts to request the same headers multiple times.\nSee https://github.com/bitcoin/bitcoin/issues/6755.\n\nWith this patch, the client tries to guess whether it is still in the\ninitial headers sync and avoids starting the duplicate requests if it is.",
      "tree": {
        "sha": "56879a4af75eeebb54491012a23c13bb8e0f2cdd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/56879a4af75eeebb54491012a23c13bb8e0f2cdd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0e5b158484bd6be487400b098747b6904d8e854",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0e5b158484bd6be487400b098747b6904d8e854",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0e5b158484bd6be487400b098747b6904d8e854",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0e5b158484bd6be487400b098747b6904d8e854/comments",
    "author": {
      "login": "domob1812",
      "id": 4943644,
      "node_id": "MDQ6VXNlcjQ5NDM2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/domob1812",
      "html_url": "https://github.com/domob1812",
      "followers_url": "https://api.github.com/users/domob1812/followers",
      "following_url": "https://api.github.com/users/domob1812/following{/other_user}",
      "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions",
      "organizations_url": "https://api.github.com/users/domob1812/orgs",
      "repos_url": "https://api.github.com/users/domob1812/repos",
      "events_url": "https://api.github.com/users/domob1812/events{/privacy}",
      "received_events_url": "https://api.github.com/users/domob1812/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "domob1812",
      "id": 4943644,
      "node_id": "MDQ6VXNlcjQ5NDM2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/domob1812",
      "html_url": "https://github.com/domob1812",
      "followers_url": "https://api.github.com/users/domob1812/followers",
      "following_url": "https://api.github.com/users/domob1812/following{/other_user}",
      "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions",
      "organizations_url": "https://api.github.com/users/domob1812/orgs",
      "repos_url": "https://api.github.com/users/domob1812/repos",
      "events_url": "https://api.github.com/users/domob1812/events{/privacy}",
      "received_events_url": "https://api.github.com/users/domob1812/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ca6ddec4d7918b47f0e4747c5647daf54675306",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ca6ddec4d7918b47f0e4747c5647daf54675306",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ca6ddec4d7918b47f0e4747c5647daf54675306"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 52,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5eebd882943eab6e02386debf9e34e41ab822071",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 1,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0e5b158484bd6be487400b098747b6904d8e854/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0e5b158484bd6be487400b098747b6904d8e854/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b0e5b158484bd6be487400b098747b6904d8e854",
        "patch": "@@ -138,6 +138,20 @@ namespace {\n       */\n     multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n+    /**\n+     * Whether we are in initial headers download.  This flag is set when\n+     * we receive full-sized \"headers\" messages and unset on fewer headers.\n+     * If true, this prevents the node from requesting newly announced blocks.\n+     */\n+    bool fInitialHeadersSync = false;\n+    /**\n+     * Minimum number of new best headers a peer must include in a headers\n+     * message before we set fInitialHeadersSync.  This must be high enough\n+     * so that an attacker is unlikely to create this many new headers\n+     * with PoW.\n+     */\n+    static const int MIN_BEST_HEADERS_INITIAL_SYNC = 12;\n+\n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n     int nLastBlockFile = 0;\n@@ -4120,7 +4134,21 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n             if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+\n+                /* If we are in initial headers sync, do not request the newly\n+                   announced block.  Otherwise, we may end up requesting the\n+                   same headers multiple times; each request even starts a\n+                   \"chain\" of requests for more, which would all be redundant.\n+\n+                   Note that fInitialHeadersSync is only set to true if a peer\n+                   sent us new and, importantly, best headers without any\n+                   other peer sending fewer headers in response to a\n+                   \"getheaders\" request afterwards.  It is not possible to\n+                   abuse this to make an actually up-to-date node not request\n+                   a new block, since an attacker would have to prepare\n+                   MIN_BEST_HEADERS_INITIAL_SYNC headers with valid PoW.  */\n+\n+                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash) && !fInitialHeadersSync) {\n                     // First request the headers preceding the announced block. In the normal fully-synced\n                     // case where a new block is announced that succeeds the current tip (no reorganization),\n                     // there are no such headers.\n@@ -4406,14 +4434,24 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         LOCK(cs_main);\n \n+        /* For now, reset fInitialHeadersSync to false.  It is safer\n+           to disable the flag when in doubt.  In case this message\n+           looks like we are still in the initial sync, we enable\n+           it later on again.  */\n+        fInitialHeadersSync = false;\n+\n         if (nCount == 0) {\n             // Nothing interesting. Stop asking this peers for more headers.\n             return true;\n         }\n \n+        const CBlockIndex *pindexFormerBest = pindexBestHeader;\n+        bool fExtendingFormerBest = false;\n         CBlockIndex *pindexLast = NULL;\n         BOOST_FOREACH(const CBlockHeader& header, headers) {\n             CValidationState state;\n+            if (header.hashPrevBlock == *pindexFormerBest->phashBlock)\n+                fExtendingFormerBest = true;\n             if (pindexLast != NULL && header.hashPrevBlock != pindexLast->GetBlockHash()) {\n                 Misbehaving(pfrom->GetId(), 20);\n                 return error(\"non-continuous headers sequence\");\n@@ -4433,6 +4471,19 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         if (nCount == MAX_HEADERS_RESULTS && pindexLast) {\n             // Headers message had its maximum size; the peer may have more headers.\n+\n+            /* We also possibly set the flag for initial headers sync.  This\n+               prevents the node from requesting newly announced blocks, so\n+               must be done carefully.  We only set it if not only the headers\n+               message was full size, but also many of them were new and best\n+               headers for us.  */\n+            assert(!headers.empty());\n+            if (fExtendingFormerBest && pindexLast->nHeight >= pindexFormerBest->nHeight + MIN_BEST_HEADERS_INITIAL_SYNC)\n+            {\n+                LogPrint(\"net\", \"seems we are in initial headers sync\\n\");\n+                fInitialHeadersSync = true;\n+            }\n+\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);"
      }
    ]
  }
]