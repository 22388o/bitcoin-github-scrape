[
  {
    "sha": "ed037857dad102f0829ab16cce0bb9acf11892ff",
    "node_id": "C_kwDOABII59oAKGVkMDM3ODU3ZGFkMTAyZjA4MjlhYjE2Y2NlMGJiOWFjZjExODkyZmY",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-12-07T20:06:44Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-29T16:20:20Z"
      },
      "message": "CCoinsViewCache code cleanup & deduplication\n\nThe change moves code responsible for updating the cache out of various\nCCoinsViewCache methods and into a Modifier class. This way the cache update\ncode is just written once in a general way instead of being duplicated and\nsplit up to handle various special cases.\n\nThis is a refactoring, with changes to cache behavior only in 2 corner cases\n(with corresponding tests in coins_test.cpp) which don't affect the meaning of\ndata stored in the cache:\n\n* In BatchWrite, overwriting a non-dirty pruned cache entry with a fresh pruned\n  cache entry now deletes the cache entry instead of leaving behind a dirty\n  pruned entry that will trigger an unnecessary database write later.\n\n* In BatchWrite, overwriting a dirty pruned fresh cache entry with a nonpruned\n  entry updates the entry without dropping the fresh flag. There's no reason to\n  drop the fresh flag in this case because the flag accurately describes the\n  state of the base view and could prevent unnecessary database writes in the\n  future if the utxo is spent later.",
      "tree": {
        "sha": "a864c6e100cf01e1d44ed7cc179fbbc2a6f1d4d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a864c6e100cf01e1d44ed7cc179fbbc2a6f1d4d6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed037857dad102f0829ab16cce0bb9acf11892ff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed037857dad102f0829ab16cce0bb9acf11892ff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ed037857dad102f0829ab16cce0bb9acf11892ff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed037857dad102f0829ab16cce0bb9acf11892ff/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "383d350bd5107bfe00e3b90a00cab9a3c1397c72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/383d350bd5107bfe00e3b90a00cab9a3c1397c72",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/383d350bd5107bfe00e3b90a00cab9a3c1397c72"
      }
    ],
    "stats": {
      "total": 236,
      "additions": 131,
      "deletions": 105
    },
    "files": [
      {
        "sha": "58235cd98d9a1018560b848ac07d3f17cab548f8",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 127,
        "deletions": 102,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed037857dad102f0829ab16cce0bb9acf11892ff/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed037857dad102f0829ab16cce0bb9acf11892ff/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=ed037857dad102f0829ab16cce0bb9acf11892ff",
        "patch": "@@ -10,6 +10,8 @@\n #include <util/trace.h>\n #include <version.h>\n \n+#include <optional>\n+\n bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n std::vector<uint256> CCoinsView::GetHeadBlocks() const { return std::vector<uint256>(); }\n@@ -38,21 +40,24 @@ size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n+class CCoinsViewCache::Modifier\n+{\n+public:\n+    Modifier(const CCoinsViewCache& cache, const COutPoint& outpoint);\n+    Modifier(const CCoinsViewCache& cache, const COutPoint& outpoint, CCoinsCacheEntry&& new_entry);\n+    ~Modifier() { Flush(); }\n+    Coin& Modify();\n+    CCoinsMap::iterator Flush();\n+\n+private:\n+    const CCoinsViewCache& m_cache;\n+    const COutPoint& m_outpoint;\n+    CCoinsMap::iterator m_cur_entry = m_cache.cacheCoins.find(m_outpoint);\n+    std::optional<CCoinsCacheEntry> m_new_entry;\n+};\n+\n CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n-    CCoinsMap::iterator it = cacheCoins.find(outpoint);\n-    if (it != cacheCoins.end())\n-        return it;\n-    Coin tmp;\n-    if (!base->GetCoin(outpoint, tmp))\n-        return cacheCoins.end();\n-    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n-    if (ret->second.coin.IsSpent()) {\n-        // The parent only has an empty entry for this outpoint; we can consider our\n-        // version as fresh.\n-        ret->second.flags = CCoinsCacheEntry::FRESH;\n-    }\n-    cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n-    return ret;\n+    return Modifier(*this, outpoint).Flush();\n }\n \n bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n@@ -67,35 +72,14 @@ bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n     assert(!coin.IsSpent());\n     if (coin.out.scriptPubKey.IsUnspendable()) return;\n-    CCoinsMap::iterator it;\n-    bool inserted;\n-    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n-    bool fresh = false;\n-    if (!inserted) {\n-        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n-    }\n-    if (!possible_overwrite) {\n-        if (!it->second.coin.IsSpent()) {\n-            throw std::logic_error(\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\");\n-        }\n-        // If the coin exists in this cache as a spent coin and is DIRTY, then\n-        // its spentness hasn't been flushed to the parent cache. We're\n-        // re-adding the coin to this cache now but we can't mark it as FRESH.\n-        // If we mark it FRESH and then spend it before the cache is flushed\n-        // we would remove it from this cache and would never flush spentness\n-        // to the parent cache.\n-        //\n-        // Re-adding a spent coin can happen in the case of a re-org (the coin\n-        // is 'spent' when the block adding it is disconnected and then\n-        // re-added when it is also added in a newly connected block).\n-        //\n-        // If the coin doesn't exist in the current cache, or is spent but not\n-        // DIRTY, then it can be marked FRESH.\n-        fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n-    }\n-    it->second.coin = std::move(coin);\n-    it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n-    cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n+    CCoinsCacheEntry entry;\n+    // If we are not possibly overwriting, any coin in the base view below the\n+    // cache will be spent, so the cache entry can be marked fresh.\n+    // If we are possibly overwriting, we can't make any assumption about the\n+    // coin in the the base view below the cache, so the new cache entry which\n+    // will replace it must be marked dirty.\n+    entry.flags |= possible_overwrite ? CCoinsCacheEntry::DIRTY : CCoinsCacheEntry::FRESH;\n+    Modifier(*this, outpoint, std::move(entry)).Modify() = std::move(coin);\n     TRACE5(utxocache, add,\n            outpoint.hash.data(),\n            (uint32_t)outpoint.n,\n@@ -112,37 +96,32 @@ void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coi\n         std::forward_as_tuple(std::move(coin), CCoinsCacheEntry::DIRTY));\n }\n \n-void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check_for_overwrite) {\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) {\n     bool fCoinbase = tx.IsCoinBase();\n     const uint256& txid = tx.GetHash();\n     for (size_t i = 0; i < tx.vout.size(); ++i) {\n-        bool overwrite = check_for_overwrite ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n-        // Coinbase transactions can always be overwritten, in order to correctly\n+        bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n+        // Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly\n         // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n         cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);\n     }\n }\n \n bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n-    CCoinsMap::iterator it = FetchCoin(outpoint);\n-    if (it == cacheCoins.end()) return false;\n-    cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    Modifier modifier(*this, outpoint);\n+    Coin& coin = modifier.Modify();\n     TRACE5(utxocache, spent,\n            outpoint.hash.data(),\n            (uint32_t)outpoint.n,\n            (uint32_t)it->second.coin.nHeight,\n            (int64_t)it->second.coin.out.nValue,\n            (bool)it->second.coin.IsCoinBase());\n+    bool already_spent = coin.IsSpent();\n     if (moveout) {\n-        *moveout = std::move(it->second.coin);\n-    }\n-    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n-        cacheCoins.erase(it);\n-    } else {\n-        it->second.flags |= CCoinsCacheEntry::DIRTY;\n-        it->second.coin.Clear();\n+        *moveout = std::move(coin);\n     }\n-    return true;\n+    coin.Clear();\n+    return !already_spent;\n }\n \n static const Coin coinEmpty;\n@@ -182,51 +161,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n         if (!(it->second.flags & CCoinsCacheEntry::DIRTY)) {\n             continue;\n         }\n-        CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n-        if (itUs == cacheCoins.end()) {\n-            // The parent cache does not have an entry, while the child cache does.\n-            // We can ignore it if it's both spent and FRESH in the child\n-            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n-                // Create the coin in the parent cache, move the data up\n-                // and mark it as dirty.\n-                CCoinsCacheEntry& entry = cacheCoins[it->first];\n-                entry.coin = std::move(it->second.coin);\n-                cachedCoinsUsage += entry.coin.DynamicMemoryUsage();\n-                entry.flags = CCoinsCacheEntry::DIRTY;\n-                // We can mark it FRESH in the parent if it was FRESH in the child\n-                // Otherwise it might have just been flushed from the parent's cache\n-                // and already exist in the grandparent\n-                if (it->second.flags & CCoinsCacheEntry::FRESH) {\n-                    entry.flags |= CCoinsCacheEntry::FRESH;\n-                }\n-            }\n-        } else {\n-            // Found the entry in the parent cache\n-            if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent()) {\n-                // The coin was marked FRESH in the child cache, but the coin\n-                // exists in the parent cache. If this ever happens, it means\n-                // the FRESH flag was misapplied and there is a logic error in\n-                // the calling code.\n-                throw std::logic_error(\"FRESH flag misapplied to coin that exists in parent cache\");\n-            }\n-\n-            if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n-                // The grandparent cache does not have an entry, and the coin\n-                // has been spent. We can just delete it from the parent cache.\n-                cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n-                cacheCoins.erase(itUs);\n-            } else {\n-                // A normal modification.\n-                cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n-                itUs->second.coin = std::move(it->second.coin);\n-                cachedCoinsUsage += itUs->second.coin.DynamicMemoryUsage();\n-                itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n-                // NOTE: It isn't safe to mark the coin as FRESH in the parent\n-                // cache. If it already existed and was spent in the parent\n-                // cache then marking it FRESH would prevent that spentness\n-                // from being flushed to the grandparent.\n-            }\n-        }\n+        Modifier(*this, it->first, std::move(it->second));\n     }\n     hashBlock = hashBlockIn;\n     return true;\n@@ -307,3 +242,93 @@ bool CCoinsViewErrorCatcher::GetCoin(const COutPoint &outpoint, Coin &coin) cons\n         std::abort();\n     }\n }\n+\n+CCoinsViewCache::Modifier::Modifier(const CCoinsViewCache& cache, const COutPoint& outpoint)\n+    : m_cache(cache), m_outpoint(outpoint)\n+{\n+    if (m_cur_entry == m_cache.cacheCoins.end()) {\n+        m_new_entry.emplace();\n+        m_cache.base->GetCoin(m_outpoint, m_new_entry->coin);\n+        if (m_new_entry->coin.IsSpent()) {\n+            m_new_entry->flags |= CCoinsCacheEntry::FRESH;\n+        }\n+    }\n+}\n+\n+CCoinsViewCache::Modifier::Modifier(const CCoinsViewCache& cache,\n+    const COutPoint& outpoint,\n+    CCoinsCacheEntry&& new_entry)\n+    : m_cache(cache), m_outpoint(outpoint)\n+{\n+    const bool cur_entry = m_cur_entry != m_cache.cacheCoins.end();\n+    const bool cur_spent = cur_entry && m_cur_entry->second.coin.IsSpent();\n+    const bool cur_dirty = cur_entry && m_cur_entry->second.flags & CCoinsCacheEntry::DIRTY;\n+    const bool cur_fresh = cur_entry && m_cur_entry->second.flags & CCoinsCacheEntry::FRESH;\n+    const bool new_spent = new_entry.coin.IsSpent();\n+    const bool new_dirty = new_entry.flags & CCoinsCacheEntry::DIRTY;\n+    const bool new_fresh = new_entry.flags & CCoinsCacheEntry::FRESH;\n+\n+    // If the new value is marked FRESH, assert any existing cache entry is\n+    // spent, otherwise it means the FRESH flag was misapplied.\n+    if (new_fresh && cur_entry && !cur_spent) {\n+        throw std::logic_error(\"FRESH flag misapplied to cache of unspent coin\");\n+    }\n+\n+    // If a cache entry is spent but not dirty, it should be marked fresh.\n+    if (new_spent && !new_fresh && !new_dirty) {\n+        throw std::logic_error(\"Missing FRESH or DIRTY flags for spent cache entry.\");\n+    }\n+\n+    // Create new cache entry that can be merged into the cache in Flush().\n+    m_new_entry.emplace();\n+    m_new_entry->coin = std::move(new_entry.coin);\n+\n+    // If `cur_fresh` is true it means the `m_cache.base` coin is spent, so\n+    // keep the FRESH flag. If `new_fresh` is true, it means that the `m_cache`\n+    // coin is spent, which implies that the `m_cache.base` coin is also spent\n+    // as long as the cache is not dirty, so keep the FRESH flag in this case as\n+    // well.\n+    if (cur_fresh || (new_fresh && !cur_dirty)) {\n+        m_new_entry->flags |= CCoinsCacheEntry::FRESH;\n+    }\n+\n+    if (cur_dirty || new_dirty) {\n+        m_new_entry->flags |= CCoinsCacheEntry::DIRTY;\n+    }\n+}\n+\n+// Add DIRTY flag to m_new_entry and return mutable coin reference. Populate\n+// m_new_entry from existing cache entry if necessary.\n+Coin& CCoinsViewCache::Modifier::Modify()\n+{\n+    if (!m_new_entry) {\n+        assert(m_cur_entry != m_cache.cacheCoins.end());\n+        m_new_entry.emplace(m_cur_entry->second);\n+    }\n+    m_new_entry->flags |= CCoinsCacheEntry::DIRTY;\n+    return m_new_entry->coin;\n+}\n+\n+// Update m_cache.cacheCoins with the contents of m_new_entry, if present.\n+CCoinsMap::iterator CCoinsViewCache::Modifier::Flush()\n+{\n+    if (m_new_entry) {\n+        bool erase = (m_new_entry->flags & CCoinsCacheEntry::FRESH) && m_new_entry->coin.IsSpent();\n+        if (m_cur_entry != m_cache.cacheCoins.end()) {\n+            m_cache.cachedCoinsUsage -= m_cur_entry->second.coin.DynamicMemoryUsage();\n+            if (erase) {\n+                m_cache.cacheCoins.erase(m_cur_entry);\n+                m_cur_entry = m_cache.cacheCoins.end();\n+            } else {\n+                m_cur_entry->second = std::move(*m_new_entry);\n+            }\n+        } else if (!erase) {\n+            m_cur_entry = m_cache.cacheCoins.emplace(m_outpoint, std::move(*m_new_entry)).first;\n+        }\n+        if (!erase) {\n+            m_cache.cachedCoinsUsage += m_cur_entry->second.coin.DynamicMemoryUsage();\n+        }\n+    }\n+    m_new_entry.reset();\n+    return m_cur_entry;\n+}"
      },
      {
        "sha": "0a86f4dc3f7282dac36924d87cd413299be85fb3",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed037857dad102f0829ab16cce0bb9acf11892ff/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed037857dad102f0829ab16cce0bb9acf11892ff/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=ed037857dad102f0829ab16cce0bb9acf11892ff",
        "patch": "@@ -223,6 +223,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     /* Cached dynamic memory usage for the inner Coin objects. */\n     mutable size_t cachedCoinsUsage;\n \n+    class Modifier;\n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n "
      },
      {
        "sha": "6e3ad8192f43728f1e0ce68d3623abb63bc240dd",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed037857dad102f0829ab16cce0bb9acf11892ff/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed037857dad102f0829ab16cce0bb9acf11892ff/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=ed037857dad102f0829ab16cce0bb9acf11892ff",
        "patch": "@@ -831,15 +831,15 @@ BOOST_AUTO_TEST_CASE(ccoins_write)\n     CheckWriteCoins(SPENT , ABSENT, SPENT , DIRTY      , NO_ENTRY   , DIRTY      );\n     CheckWriteCoins(SPENT , ABSENT, SPENT , DIRTY|FRESH, NO_ENTRY   , DIRTY|FRESH);\n     CheckWriteCoins(SPENT , SPENT , SPENT , 0          , DIRTY      , DIRTY      );\n-    CheckWriteCoins(SPENT , SPENT , SPENT , 0          , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(SPENT , SPENT , ABSENT, 0          , DIRTY|FRESH, NO_ENTRY   );\n     CheckWriteCoins(SPENT , SPENT , ABSENT, FRESH      , DIRTY      , NO_ENTRY   );\n     CheckWriteCoins(SPENT , SPENT , ABSENT, FRESH      , DIRTY|FRESH, NO_ENTRY   );\n     CheckWriteCoins(SPENT , SPENT , SPENT , DIRTY      , DIRTY      , DIRTY      );\n     CheckWriteCoins(SPENT , SPENT , SPENT , DIRTY      , DIRTY|FRESH, DIRTY      );\n     CheckWriteCoins(SPENT , SPENT , ABSENT, DIRTY|FRESH, DIRTY      , NO_ENTRY   );\n     CheckWriteCoins(SPENT , SPENT , ABSENT, DIRTY|FRESH, DIRTY|FRESH, NO_ENTRY   );\n     CheckWriteCoins(SPENT , VALUE2, VALUE2, 0          , DIRTY      , DIRTY      );\n-    CheckWriteCoins(SPENT , VALUE2, VALUE2, 0          , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(SPENT , VALUE2, VALUE2, 0          , DIRTY|FRESH, DIRTY|FRESH);\n     CheckWriteCoins(SPENT , VALUE2, VALUE2, FRESH      , DIRTY      , DIRTY|FRESH);\n     CheckWriteCoins(SPENT , VALUE2, VALUE2, FRESH      , DIRTY|FRESH, DIRTY|FRESH);\n     CheckWriteCoins(SPENT , VALUE2, VALUE2, DIRTY      , DIRTY      , DIRTY      );"
      },
      {
        "sha": "4515ba3b502446726bd0093407a6d826e7725577",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed037857dad102f0829ab16cce0bb9acf11892ff/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed037857dad102f0829ab16cce0bb9acf11892ff/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=ed037857dad102f0829ab16cce0bb9acf11892ff",
        "patch": "@@ -65,7 +65,7 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n                     coins_view_cache.AddCoin(random_out_point, std::move(coin), possible_overwrite);\n                     expected_code_path = true;\n                 } catch (const std::logic_error& e) {\n-                    if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n+                    if (e.what() == std::string{\"FRESH flag misapplied to cache of unspent coin\"}) {\n                         assert(!possible_overwrite);\n                         expected_code_path = true;\n                     }"
      }
    ]
  }
]