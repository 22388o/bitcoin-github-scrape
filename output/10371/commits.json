[
  {
    "sha": "a80f295666ba15d795be00773f768d7167599a63",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphODBmMjk1NjY2YmExNWQ3OTViZTAwNzczZjc2OGQ3MTY3NTk5YTYz",
    "commit": {
      "author": {
        "name": "Jimmy Song",
        "email": "jaejoon@gmail.com",
        "date": "2017-05-09T16:11:12Z"
      },
      "committer": {
        "name": "Jimmy Song",
        "email": "jaejoon@gmail.com",
        "date": "2017-05-09T20:59:49Z"
      },
      "message": "[tests] Clean up addrman_tests.cpp\n\nCleanup request from #10287.\nChange \"Test #:\" comments to \"Test:\"\nChange BOOST_CHECK(... = ...) to BOOST_CHECK_EQUAL(..., ...)\nRemove three unnecessary if statements",
      "tree": {
        "sha": "4e9b030f37d9fae18b8d6d45e1562c56eaf49879",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e9b030f37d9fae18b8d6d45e1562c56eaf49879"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a80f295666ba15d795be00773f768d7167599a63",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a80f295666ba15d795be00773f768d7167599a63",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a80f295666ba15d795be00773f768d7167599a63",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a80f295666ba15d795be00773f768d7167599a63/comments",
    "author": {
      "login": "jimmysong",
      "id": 524761,
      "node_id": "MDQ6VXNlcjUyNDc2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/524761?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimmysong",
      "html_url": "https://github.com/jimmysong",
      "followers_url": "https://api.github.com/users/jimmysong/followers",
      "following_url": "https://api.github.com/users/jimmysong/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimmysong/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimmysong/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimmysong/subscriptions",
      "organizations_url": "https://api.github.com/users/jimmysong/orgs",
      "repos_url": "https://api.github.com/users/jimmysong/repos",
      "events_url": "https://api.github.com/users/jimmysong/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimmysong/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimmysong",
      "id": 524761,
      "node_id": "MDQ6VXNlcjUyNDc2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/524761?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimmysong",
      "html_url": "https://github.com/jimmysong",
      "followers_url": "https://api.github.com/users/jimmysong/followers",
      "following_url": "https://api.github.com/users/jimmysong/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimmysong/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimmysong/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimmysong/subscriptions",
      "organizations_url": "https://api.github.com/users/jimmysong/orgs",
      "repos_url": "https://api.github.com/users/jimmysong/repos",
      "events_url": "https://api.github.com/users/jimmysong/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimmysong/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "776ba233e939fe41a74c6b2632b93a0679a32c71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/776ba233e939fe41a74c6b2632b93a0679a32c71",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/776ba233e939fe41a74c6b2632b93a0679a32c71"
      }
    ],
    "stats": {
      "total": 177,
      "additions": 87,
      "deletions": 90
    },
    "files": [
      {
        "sha": "3812490ec0161e7073189b2a6bafc41824255176",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 90,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a80f295666ba15d795be00773f768d7167599a63/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a80f295666ba15d795be00773f768d7167599a63/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=a80f295666ba15d795be00773f768d7167599a63",
        "patch": "@@ -84,43 +84,43 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test 1: Does Addrman respond correctly when empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    // Test: Does Addrman respond correctly when empty.\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo addr_null = addrman.Select();\n-    BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n-    // Test 2: Does Addrman::Add work as expected.\n+    // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 3: Does IP address deduplication work correctly.\n+    // Test: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n     CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(!addrman.Add(CAddress(addr1_dup, NODE_NONE), source));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n \n-    // Test 5: New table has one addr and we add a diff addr we should\n+    // Test: New table has one addr and we add a diff addr we should\n     //  have two addrs.\n     CService addr2 = ResolveService(\"250.1.1.2\", 8333);\n     BOOST_CHECK(addrman.Add(CAddress(addr2, NODE_NONE), source));\n-    BOOST_CHECK(addrman.size() == 2);\n+    BOOST_CHECK_EQUAL(addrman.size(), 2);\n \n-    // Test 6: AddrMan::Clear() should empty the new table.\n+    // Test: AddrMan::Clear() should empty the new table.\n     addrman.Clear();\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo addr_null2 = addrman.Select();\n-    BOOST_CHECK(addr_null2.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_null2.ToString(), \"[::]:0\");\n \n-    // Test 6.5: AddrMan::Add multiple addresses works as expected\n+    // Test: AddrMan::Add multiple addresses works as expected\n     std::vector<CAddress> vAddr;\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n     BOOST_CHECK(addrman.Add(vAddr, source));\n-    BOOST_CHECK(addrman.size() == 2);\n+    BOOST_CHECK_EQUAL(addrman.size(), 2);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n@@ -132,26 +132,26 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n-    BOOST_CHECK(addr_ret2.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 8: Add same IP but diff port to tried table, it doesn't get added.\n+    // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     bool newOnly = true;\n     CAddrInfo addr_ret3 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n \n@@ -164,25 +164,25 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test 9: Select from new with 1 addr in new.\n+    // Test: Select from new with 1 addr in new.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n     bool newOnly = true;\n     CAddrInfo addr_ret1 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 10: move addr to tried, select from new expected nothing returned.\n+    // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret2 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret2.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n     CAddrInfo addr_ret3 = addrman.Select();\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n \n     // Add three addresses to new table.\n@@ -206,10 +206,10 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333));\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n-    // Test 11: 6 addrs + 1 addr from last test = 7.\n-    BOOST_CHECK(addrman.size() == 7);\n+    // Test: 6 addrs + 1 addr from last test = 7.\n+    BOOST_CHECK_EQUAL(addrman.size(), 7);\n \n-    // Test 12: Select pulls from new and tried regardless of port number.\n+    // Test: Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman.Select().GetPort());\n@@ -226,24 +226,24 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n-        //Test 13: No collision in new table yet.\n-        BOOST_CHECK(addrman.size() == i);\n+        //Test: No collision in new table yet.\n+        BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n-    //Test 14: new table collision!\n+    //Test: new table collision!\n     CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 17);\n+    BOOST_CHECK_EQUAL(addrman.size(), 17);\n \n     CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 18);\n+    BOOST_CHECK_EQUAL(addrman.size(), 18);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n@@ -255,25 +255,25 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n-        //Test 15: No collision in tried table yet.\n+        //Test: No collision in tried table yet.\n         BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n-    //Test 16: tried table collision!\n+    //Test: tried table collision!\n     CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 79);\n+    BOOST_CHECK_EQUAL(addrman.size(), 79);\n \n     CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 80);\n+    BOOST_CHECK_EQUAL(addrman.size(), 80);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n@@ -283,7 +283,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -296,23 +296,20 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     addrman.Add(addr2, source2);\n     addrman.Add(addr3, source1);\n \n-    // Test 17: ensure Find returns an IP matching what we searched on.\n+    // Test: ensure Find returns an IP matching what we searched on.\n     CAddrInfo* info1 = addrman.Find(addr1);\n-    BOOST_CHECK(info1);\n-    if (info1)\n-        BOOST_CHECK(info1->ToString() == \"250.1.2.1:8333\");\n+    BOOST_REQUIRE(info1);\n+    BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n     CAddrInfo* info2 = addrman.Find(addr2);\n-    BOOST_CHECK(info2);\n-    if (info2 && info1)\n-        BOOST_CHECK(info2->ToString() == info1->ToString());\n+    BOOST_REQUIRE(info2);\n+    BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n-    // Test 19: Find returns another IP matching what we searched on.\n+    // Test: Find returns another IP matching what we searched on.\n     CAddrInfo* info3 = addrman.Find(addr3);\n-    BOOST_CHECK(info3);\n-    if (info3)\n-        BOOST_CHECK(info3->ToString() == \"251.255.2.1:8333\");\n+    BOOST_REQUIRE(info3);\n+    BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n@@ -322,19 +319,19 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n-    // Test 20: The result should be the same as the input addr.\n-    BOOST_CHECK(pinfo->ToString() == \"250.1.2.1:8333\");\n+    // Test: The result should be the same as the input addr.\n+    BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n     CAddrInfo* info2 = addrman.Find(addr1);\n-    BOOST_CHECK(info2->ToString() == \"250.1.2.1:8333\");\n+    BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n \n@@ -345,18 +342,18 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     addrman.Create(addr1, source1, &nId);\n \n-    // Test 21: Delete should actually delete the addr.\n-    BOOST_CHECK(addrman.size() == 1);\n+    // Test: Delete should actually delete the addr.\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     addrman.Delete(nId);\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == NULL);\n }\n@@ -368,11 +365,11 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    // Test 22: Sanity check, GetAddr should never return anything if addrman\n+    // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     std::vector<CAddress> vAddr1 = addrman.GetAddr();\n-    BOOST_CHECK(vAddr1.size() == 0);\n+    BOOST_CHECK_EQUAL(vAddr1.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n@@ -387,28 +384,28 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n     CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n \n-    // Test 23: Ensure GetAddr works with new addresses.\n+    // Test: Ensure GetAddr works with new addresses.\n     addrman.Add(addr1, source1);\n     addrman.Add(addr2, source2);\n     addrman.Add(addr3, source1);\n     addrman.Add(addr4, source2);\n     addrman.Add(addr5, source1);\n \n     // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n-    BOOST_CHECK(addrman.GetAddr().size() == 1); \n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n \n-    // Test 24: Ensure GetAddr works with new and tried addresses.\n+    // Test: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK(addrman.GetAddr().size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n \n-    // Test 25: Ensure GetAddr still returns 23% when addrman has many addrs.\n+    // Test: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n         int octet1 = i % 256;\n         int octet2 = i >> 8 % 256;\n         std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".1.23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n-        \n+\n         // Ensure that for all addrs in addrman, isTerrible == false.\n         addr.nTime = GetAdjustedTime();\n         addrman.Add(addr, ResolveIP(strAddr));\n@@ -444,13 +441,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n \n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) == 40);\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1), 40);\n \n-    // Test 26: Make sure key actually randomizes bucket placement. A fail on\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n \n-    // Test 27: Two addresses with same IP but different ports can map to\n+    // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n \n@@ -465,9 +462,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 28: IP addresses in the same group (\\16 prefix for IPv4) should\n+    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  never get more than 8 buckets\n-    BOOST_CHECK(buckets.size() == 8);\n+    BOOST_CHECK_EQUAL(buckets.size(), 8);\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n@@ -477,9 +474,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 29: IP addresses in the different groups should map to more than\n+    // Test: IP addresses in the different groups should map to more than\n     //  8 buckets.\n-    BOOST_CHECK(buckets.size() == 160);\n+    BOOST_CHECK_EQUAL(buckets.size(), 160);\n }\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n@@ -499,18 +496,18 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    // Test 29.5: Make sure the buckets are what we expect\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == 786);\n-    BOOST_CHECK(info1.GetNewBucket(nKey1, source1) == 786);\n+    // Test: Make sure the buckets are what we expect\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1), 786);\n \n-    // Test 30: Make sure key actually randomizes bucket placement. A fail on\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n \n-    // Test 31: Ports should not effect bucket placement in the addr\n+    // Test: Ports should not effect bucket placement in the addr\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), info2.GetNewBucket(nKey1));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n@@ -520,9 +517,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 32: IP addresses in the same group (\\16 prefix for IPv4) should\n+    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  always map to the same bucket.\n-    BOOST_CHECK(buckets.size() == 1);\n+    BOOST_CHECK_EQUAL(buckets.size(), 1);\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n@@ -533,7 +530,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 33: IP addresses in the same source groups should map to no more\n+    // Test: IP addresses in the same source groups should map to no more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() <= 64);\n \n@@ -545,7 +542,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 34: IP addresses in the different source groups should map to more\n+    // Test: IP addresses in the different source groups should map to more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() > 64);\n }"
      }
    ]
  }
]