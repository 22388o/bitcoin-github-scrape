[
  {
    "sha": "ababcdede19c57955a35ed9f4fbdae40e1c4e106",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYmFiY2RlZGUxOWM1Nzk1NWEzNWVkOWY0ZmJkYWU0MGUxYzRlMTA2",
    "commit": {
      "author": {
        "name": "Conor Scott",
        "email": "conor.r.scott.88@gmail.com",
        "date": "2018-04-09T13:03:03Z"
      },
      "committer": {
        "name": "Conor Scott",
        "email": "conor.r.scott.88@gmail.com",
        "date": "2018-04-10T07:41:50Z"
      },
      "message": "[Tests] Refactor big transaction generation and make generic",
      "tree": {
        "sha": "b2ab15941f8e423640ddf819f0741bd076127dc3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2ab15941f8e423640ddf819f0741bd076127dc3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ababcdede19c57955a35ed9f4fbdae40e1c4e106",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ababcdede19c57955a35ed9f4fbdae40e1c4e106",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ababcdede19c57955a35ed9f4fbdae40e1c4e106",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ababcdede19c57955a35ed9f4fbdae40e1c4e106/comments",
    "author": {
      "login": "conscott",
      "id": 14220652,
      "node_id": "MDQ6VXNlcjE0MjIwNjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14220652?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/conscott",
      "html_url": "https://github.com/conscott",
      "followers_url": "https://api.github.com/users/conscott/followers",
      "following_url": "https://api.github.com/users/conscott/following{/other_user}",
      "gists_url": "https://api.github.com/users/conscott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/conscott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/conscott/subscriptions",
      "organizations_url": "https://api.github.com/users/conscott/orgs",
      "repos_url": "https://api.github.com/users/conscott/repos",
      "events_url": "https://api.github.com/users/conscott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/conscott/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "conscott",
      "id": 14220652,
      "node_id": "MDQ6VXNlcjE0MjIwNjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/14220652?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/conscott",
      "html_url": "https://github.com/conscott",
      "followers_url": "https://api.github.com/users/conscott/followers",
      "following_url": "https://api.github.com/users/conscott/following{/other_user}",
      "gists_url": "https://api.github.com/users/conscott/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/conscott/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/conscott/subscriptions",
      "organizations_url": "https://api.github.com/users/conscott/orgs",
      "repos_url": "https://api.github.com/users/conscott/repos",
      "events_url": "https://api.github.com/users/conscott/events{/privacy}",
      "received_events_url": "https://api.github.com/users/conscott/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "603975b96a1542006f738a564171f98e264d32bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/603975b96a1542006f738a564171f98e264d32bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/603975b96a1542006f738a564171f98e264d32bf"
      }
    ],
    "stats": {
      "total": 204,
      "additions": 168,
      "deletions": 36
    },
    "files": [
      {
        "sha": "82002e4958aaecf213885b2eef63bcb1fe5b738f",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ababcdede19c57955a35ed9f4fbdae40e1c4e106/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ababcdede19c57955a35ed9f4fbdae40e1c4e106/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=ababcdede19c57955a35ed9f4fbdae40e1c4e106",
        "patch": "@@ -14,7 +14,6 @@ def set_test_params(self):\n         self.extra_args = [[\"-maxmempool=5\", \"-spendzeroconfchange=0\"]]\n \n     def run_test(self):\n-        txouts = gen_return_txouts()\n         relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n \n         self.log.info('Check that mempoolminfee is minrelytxfee')\n@@ -39,7 +38,7 @@ def run_test(self):\n         base_fee = relayfee*100\n         for i in range (3):\n             txids.append([])\n-            txids[i] = create_lots_of_big_transactions(self.nodes[0], txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)\n+            txids[i] = create_lots_of_big_transactions(self.nodes[0], utxos[30*i:30*i+30], 30, (i+1)*base_fee)\n \n         self.log.info('The tx should be evicted by now')\n         assert(txid not in self.nodes[0].getrawmempool())"
      },
      {
        "sha": "bc102d626672f43527a9ab23d3deb60c4cf587d8",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ababcdede19c57955a35ed9f4fbdae40e1c4e106/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ababcdede19c57955a35ed9f4fbdae40e1c4e106/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=ababcdede19c57955a35ed9f4fbdae40e1c4e106",
        "patch": "@@ -34,7 +34,6 @@ def run_test(self):\n         # Test `prioritisetransaction` invalid `fee_delta`\n         assert_raises_rpc_error(-1, \"JSON value is not an integer as expected\", self.nodes[0].prioritisetransaction, txid=txid, fee_delta='foo')\n \n-        self.txouts = gen_return_txouts()\n         self.relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n \n         utxo_count = 90\n@@ -48,7 +47,7 @@ def run_test(self):\n             txids.append([])\n             start_range = i * range_size\n             end_range = start_range + range_size\n-            txids[i] = create_lots_of_big_transactions(self.nodes[0], self.txouts, utxos[start_range:end_range], end_range - start_range, (i+1)*base_fee)\n+            txids[i] = create_lots_of_big_transactions(self.nodes[0], utxos[start_range:end_range], end_range - start_range, (i+1)*base_fee)\n \n         # Make sure that the size of each group of transactions exceeds\n         # MAX_BLOCK_BASE_SIZE -- otherwise the test needs to be revised to create"
      },
      {
        "sha": "03609dce9259abef9913ab97cf8c0df545cf8f01",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 166,
        "deletions": 32,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ababcdede19c57955a35ed9f4fbdae40e1c4e106/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ababcdede19c57955a35ed9f4fbdae40e1c4e106/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=ababcdede19c57955a35ed9f4fbdae40e1c4e106",
        "patch": "@@ -489,26 +489,87 @@ def create_confirmed_utxos(fee, node, count):\n     assert(len(utxos) >= count)\n     return utxos\n \n-# Create large OP_RETURN txouts that can be appended to a transaction\n+\n+# Flip the endian-ness of a hex str\n+#\n+# '0033aaff' -> 'ffaa3300'\n+def reverse_endian(hex_str):\n+    return ''.join([hex_str[i-2:i] for i in range(len(hex_str), 0, -2)])\n+\n+\n+# Get a varint hex string from an integer\n+# According to protocol:\n+#\n+# Value            Storage length    Format\n+# < 0xFD            1                uint8_t\n+# <= 0xFFFF         3                0xFD followed by the length as uint16_t\n+# <= 0xFFFF FFFF    5                0xFE followed by the length as uint32_t\n+# -                 9                0xFF followed by the length as uint64_t\n+def get_varint_hex(num):\n+    if num < int(\"fd\", 16):\n+        return \"{:02x}\".format(num)\n+    elif num <= int(\"ffff\", 16):\n+        return \"fd\" + reverse_endian(\"{:04x}\".format(num))\n+    elif num <= int(\"ffffffff\", 16):\n+        return \"fe\" + reverse_endian(\"{:08x}\".format(num))\n+    else:\n+        return \"ff\" + reverse_endian(\"{:16x}\".format(num))\n+\n+\n+# Get bytes required for a PUSHDATA of size num\n+def pushdata_size_bytes(num):\n+    if num < int(\"ff\", 16):\n+        return 1\n+    elif num <= int(\"ffff\", 16):\n+        return 2\n+    elif num <= int(\"ffffffff\", 16):\n+        return 4\n+\n+\n+# Given numoutputs pushing data_push_sz to the tx stack\n+# calculate the expected size of the outputs splice\n+def calculate_txouts_size(numoutputs, data_push_sz):\n+    # 2 bytes for [OP_RETURN, OP_PUSHDATAX] + DATA_SIZE + <DATA BYTES>\n+    script_pubkey_bytes = 2 + pushdata_size_bytes(data_push_sz) + data_push_sz\n+    num_outputs_varint_sz = int(len(get_varint_hex(numoutputs + 1)) / 2)\n+    script_pubkey_varint_sz = int(len(get_varint_hex(script_pubkey_bytes)) / 2)\n+    return (num_outputs_varint_sz + (numoutputs * (8 + script_pubkey_varint_sz + script_pubkey_bytes)))\n+\n+\n+# Create OP_RETURN txouts that can be appended to a transaction\n # to make it large (helper for constructing large transactions).\n-def gen_return_txouts():\n-    # Some pre-processing to create a bunch of OP_RETURN txouts to insert into transactions we create\n-    # So we have big transactions (and therefore can't fit very many into each block)\n-    # create one script_pubkey\n-    script_pubkey = \"6a4d0200\"  # OP_RETURN OP_PUSH2 512 bytes\n-    for i in range(512):\n-        script_pubkey = script_pubkey + \"01\"\n-    # concatenate 128 txouts of above script_pubkey which we'll insert before the txout for change\n-    txouts = \"81\"\n-    for k in range(128):\n-        # add txout value\n-        txouts = txouts + \"0000000000000000\"\n-        # add length of script_pubkey\n-        txouts = txouts + \"fd0402\"\n-        # add script_pubkey\n-        txouts = txouts + script_pubkey\n+def gen_return_txouts(numoutputs=128, data_push_sz=512):\n+\n+    # OP_RETURN OP_PUSHDATA1 DATA_SIZE <DATA_BYTES>\n+    if data_push_sz <= int('ff', 16):\n+        script_pubkey = \"6a4c{:02x}\".format(data_push_sz) + (\"01\" * data_push_sz)\n+    # OP_RETURN OP_PUSHDATA2 DATA_SIZE <DATA_BYTES>\n+    elif data_push_sz <= int('ffff', 16):\n+        script_pubkey = \"6a4d{:04x}\".format(data_push_sz) + (\"01\" * data_push_sz)\n+    # OP_RETURN OP_PUSHDATA4 DATA_SIZE <DATA_BYTES>\n+    else:\n+        script_pubkey = \"6a4e{:08x}\".format(data_push_sz) + (\"01\" * data_push_sz)\n+\n+    # number is + 1 because this will be spliced into single output tx\n+    num_outputs_varint = get_varint_hex(numoutputs + 1)\n+\n+    # 3-6 bytes for OP_RETURN OP_PUSHDATA DATA_SIZE\n+    sz_script_pubkey_varint = get_varint_hex(2 + pushdata_size_bytes(data_push_sz) + data_push_sz)\n+\n+    # Output format:\n+    #   8 bytes for Amount = 0x0000000000000000\n+    #   VarInt for scriptPubKey size\n+    #   scriptPubKey\n+    tx_output = \"0000000000000000\" + sz_script_pubkey_varint + script_pubkey\n+\n+    # Combine number of outputs as varint with the repeated outputs\n+    txouts = num_outputs_varint + (tx_output * numoutputs)\n+\n+    assert_equal(len(txouts)/2, calculate_txouts_size(numoutputs, data_push_sz))\n+\n     return txouts\n \n+\n def create_tx(node, coinbase, to_address, amount):\n     inputs = [{\"txid\": coinbase, \"vout\": 0}]\n     outputs = {to_address: amount}\n@@ -517,35 +578,108 @@ def create_tx(node, coinbase, to_address, amount):\n     assert_equal(signresult[\"complete\"], True)\n     return signresult[\"hex\"]\n \n+\n+# For very large transactions, need to find utxo that has enough to pay large fee\n+def get_utxo_with_amount(node, amount):\n+    for utxo in node.listunspent():\n+        if utxo['amount'] >= amount:\n+            return utxo\n+\n+    fee = node.getnetworkinfo()['relayfee'] * 1000\n+    for utxo in create_confirmed_utxos(fee, node, 1):\n+        if utxo['amount'] >= amount:\n+            return utxo\n+\n+# Create a transaction that is target_vsize. May not be exact in cases where\n+# (target_vsize - base_vsize) < 13 bytes (min output size)\n+# or when the difference is close to a VarInt boundary.\n+def create_tx_with_size(node, target_vsize, utxo=None, addr=None, fee=None):\n+\n+    if not fee:\n+        # 10 sat / byte\n+        fee = target_vsize / 10000000\n+    if not utxo:\n+        utxo = get_utxo_with_amount(node, fee + 1/10000000)\n+    if not addr:\n+        addr = node.getnewaddress()\n+\n+    fee = Decimal(fee)\n+    inputs = [{\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]}]\n+    outputs = {addr: satoshi_round(utxo['amount'] - fee)}\n+    tx = (node.decoderawtransaction(\n+          node.signrawtransactionwithwallet(\n+          node.createrawtransaction(inputs, outputs), None, \"NONE\")['hex']))\n+\n+    base_vsize = tx['vsize']\n+\n+    assert_greater_than(target_vsize, base_vsize)\n+\n+    # Output is:\n+    # 8 bytes for amount\n+    # 1/3/5 byte VarInt for size of scriptPubKey\n+    # 2 bytes for OP codes\n+    # 1/2/4 bytes for <DATA_SIZE>\n+    # DATA_BYTES (can range from 1 byte to just under maxblocksize)\n+\n+    # For 8 byte amount and 2 byes of OP codes\n+    base_output_size = 10\n+    bytes_to_add = target_vsize - base_vsize\n+\n+    # Now have to figure out the size of varints needed based on bytes to add\n+    if bytes_to_add <= 12:\n+        logger.warn(\"Bytes to add to transaction is smaller than minimum output size\")\n+        data_push_sz = 1\n+    elif bytes_to_add <= 264:\n+        # VarInt for scriptPubKey size is 1 byte and 1 byte for PUSHDATA1\n+        data_push_sz = bytes_to_add - base_output_size - 2\n+    elif bytes_to_add <= 65550:\n+        # VarInt for scriptPubKey size is 3 bytes and 2 byte for PUSHDATA2\n+        data_push_sz = bytes_to_add - base_output_size - 5\n+    else:\n+        # VarInt for scriptPubKey size is 5 bytes and 4 byte for PUSHDATA4\n+        data_push_sz = bytes_to_add - base_output_size - 9\n+\n+    txouts = gen_return_txouts(numoutputs=1, data_push_sz=data_push_sz)\n+\n+    return create_transaction_with_outputs(node, txouts, utxo, addr, fee)\n+\n+\n+# Create a normal transaction form the utxo and then\n+# splice in the additional ouputs in txouts that are\n+# generated with gen_return_txouts()\n+def create_transaction_with_outputs(node, txouts, utxo, addr, fee):\n+    inputs = [{\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]}]\n+    outputs = {}\n+    change = utxo['amount'] - fee\n+    outputs[addr] = satoshi_round(change)\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    newtx = rawtx[0:92]\n+    newtx = newtx + txouts\n+    newtx = newtx + rawtx[94:]\n+    signresult = node.signrawtransactionwithwallet(newtx, None, \"NONE\")\n+    txid = node.sendrawtransaction(signresult[\"hex\"], True)\n+    return txid\n+\n+\n # Create a spend of each passed-in utxo, splicing in \"txouts\" to each raw\n # transaction to make it large.  See gen_return_txouts() above.\n-def create_lots_of_big_transactions(node, txouts, utxos, num, fee):\n+def create_lots_of_big_transactions(node, utxos, num, fee):\n+    txouts = gen_return_txouts()\n     addr = node.getnewaddress()\n     txids = []\n+    assert_greater_than_or_equal(num, len(utxos))\n     for _ in range(num):\n-        t = utxos.pop()\n-        inputs = [{\"txid\": t[\"txid\"], \"vout\": t[\"vout\"]}]\n-        outputs = {}\n-        change = t['amount'] - fee\n-        outputs[addr] = satoshi_round(change)\n-        rawtx = node.createrawtransaction(inputs, outputs)\n-        newtx = rawtx[0:92]\n-        newtx = newtx + txouts\n-        newtx = newtx + rawtx[94:]\n-        signresult = node.signrawtransactionwithwallet(newtx, None, \"NONE\")\n-        txid = node.sendrawtransaction(signresult[\"hex\"], True)\n-        txids.append(txid)\n+        txids.append(create_transaction_with_outputs(node, txouts, utxos.pop(), addr, fee))\n     return txids\n \n def mine_large_block(node, utxos=None):\n     # generate a 66k transaction,\n     # and 14 of them is close to the 1MB block limit\n     num = 14\n-    txouts = gen_return_txouts()\n     utxos = utxos if utxos is not None else []\n     if len(utxos) < num:\n         utxos.clear()\n         utxos.extend(node.listunspent())\n     fee = 100 * node.getnetworkinfo()[\"relayfee\"]\n-    create_lots_of_big_transactions(node, txouts, utxos, num, fee=fee)\n+    create_lots_of_big_transactions(node, utxos, num, fee=fee)\n     node.generate(1)"
      }
    ]
  }
]