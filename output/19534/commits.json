[
  {
    "sha": "100c64a95b518a6a19241aec4058b866a8872d9b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDBjNjRhOTViNTE4YTZhMTkyNDFhZWM0MDU4Yjg2NmE4ODcyZDli",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-14T08:47:46Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-07-20T14:03:39Z"
      },
      "message": "net: document `enum Network`",
      "tree": {
        "sha": "c2a798cea3b8f7512c6a93e280e13fdbb40c5e17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2a798cea3b8f7512c6a93e280e13fdbb40c5e17"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100c64a95b518a6a19241aec4058b866a8872d9b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl8VpDwACgkQVN8G9ktV\ny78VFiAAmEurrAYA5TiFQCYp6pw/hEZBePsdiCdzP5XxzIvBUuVj6EobJwk+ZaCc\n2CJQ60VUQ6ieyxFRMl/+VFRRijy2B/BEwVinfqBrFX4a/vh8B7eEQ5p7FiEbYkrY\nGKttscxKYtycD5KsobBfNdcr3+zWrAuEbeoxxtObEmLL+jMdB2Qrohy+4nqwi4Q4\nwTyger2i7mFtGPaWIMRcsXJMa3jXM6MNeCazQPUQo2hVDWn3U/BK2gvTrS3oSDsm\nsxJrRgut7zb5CYTxncuopOyrV4QgJf07wFreFpUZsQsuVFkgAYHKfS0k4oJpOZXS\n/BmKI/DY1bGFbvLZNSMNI3bIG2sh9eJlZ4GglmLbhwy7g0hbo83KAbdFTpeqr8us\naYMMgkyCla/NF8SeBNwjIJkSVfg3Qt8zzGsv4SDwaaSiWwThmmEoPTzyOGNt5ex9\n4F6g+EeIRjliK1ORYjsXyEp9+Y90Oq4QQpd/vXkOtpYBkgFihxqbtLwsWfn5Sjj4\n2CQEE9xmvNjj8QBI9yiuCvkmQZVqxTfK2/3u0HcaEFpf3noFoinfbf77NoFDo4bS\nt1XZhxyGknZ22971BMM06smkdH8VUxpIpKnPtUClsQgkORWtgqhffW2DivcDtQdw\nnc6esSSh0RGzk+yXKhsjJTPYQ72qLY4E9Y/4SnG67Ivn8z0ZAoiMDqOWMG0Tf6Gf\n6c8NjWjq8n0tfj5jDpymeqt7jj5ijYYdb9AM2NA/umy3Xu+ZZIn9BpGaQINw/UzL\nvk9xbhpclvAXVXPjFDkCWt4Y//dKLYVE9xynKxvvQz6O4iahiBg/fil0QlBWaXBF\nTmwRBi/BF9H4hSxiG6UxRwT/NK65Rqs8/2JRkUYINxcDTnT1HY9WwPmAOdGZ8FsC\n8/uVWcUyCb4yBbUFOKbSnxsAhv5MSsFLa8unHnot//KC4MKwHr16wIIE1YBrHGnA\nHFOpPzojl16sTzsx0Dm1qVCpEPw3uM8J7UOqejd/gs+0Daa8jBrTK4X+/0rRtdFJ\n9fE1trJiebpJgUao+cbZ4+f9NTViKSxqEAC4ghAK/pLcrTh5UpdfVCjnKvT6L1My\nFSkCLSBzR6eBaEwWB9+Hj/8OmWlAle5WyKbJ9grTPnjtgXV8Nhr6I2Qh2sub0T96\n85F/Hs6hEm8hXOHuzZvjpWJXG1Pv8Oe9GK6xl1TadppuiUGC09rX6PL3punBaA/u\nYftlW3zxuSsEFMFLbiDA2L5ivSN/JwHdqV9Su2+UE0kSXppxOlc3f8MUehQoRQ82\nSBltS3jl1MaCTbYeF/knjNmeeRF7IlOxpIokeZxxnVHm+nvkAvqOVi8c3EtyGjll\nyL4lzLU+z9eRdP1EkhLxbdoKm7S+oQ==\n=Iwak\n-----END PGP SIGNATURE-----",
        "payload": "tree c2a798cea3b8f7512c6a93e280e13fdbb40c5e17\nparent 1148f3d63094eab788993a9417e5038cfbe5aa77\nauthor Vasil Dimov <vd@FreeBSD.org> 1589446066 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1595253819 +0200\n\nnet: document `enum Network`\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100c64a95b518a6a19241aec4058b866a8872d9b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/100c64a95b518a6a19241aec4058b866a8872d9b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100c64a95b518a6a19241aec4058b866a8872d9b/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1148f3d63094eab788993a9417e5038cfbe5aa77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1148f3d63094eab788993a9417e5038cfbe5aa77",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1148f3d63094eab788993a9417e5038cfbe5aa77"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 22,
      "deletions": 0
    },
    "files": [
      {
        "sha": "11c5ae1d5307a7ef0e263455c34724881bf57ada",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100c64a95b518a6a19241aec4058b866a8872d9b/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100c64a95b518a6a19241aec4058b866a8872d9b/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=100c64a95b518a6a19241aec4058b866a8872d9b",
        "patch": "@@ -16,14 +16,36 @@\n #include <string>\n #include <vector>\n \n+/**\n+ * A network type.\n+ * @note An address may belong to more than one network, for example `10.0.0.1`\n+ * belongs to both `NET_UNROUTABLE` and `NET_IPV4`.\n+ * Keep these sequential starting from 0 and `NET_MAX` as the last entry.\n+ * We have loops like `for (int i = 0; i < NET_MAX; i++)` that expect to iterate\n+ * over all enum values and also `GetExtNetwork()` \"extends\" this enum by\n+ * introducing standalone constants starting from `NET_MAX`.\n+ */\n enum Network\n {\n+    /// Addresses from these networks are not publicly routable on the global Internet.\n     NET_UNROUTABLE = 0,\n+\n+    /// IPv4\n     NET_IPV4,\n+\n+    /// IPv6\n     NET_IPV6,\n+\n+    /// TORv2\n     NET_ONION,\n+\n+    /// A set of dummy addresses that map a name to an IPv6 address. These\n+    /// addresses belong to RFC4193's fc00::/7 subnet (unique-local addresses).\n+    /// We use them to map a string or FQDN to an IPv6 address in CAddrMan to\n+    /// keep track of which DNS seeds were used.\n     NET_INTERNAL,\n \n+    /// Dummy value to indicate the number of NET_* constants.\n     NET_MAX,\n };\n "
      }
    ]
  },
  {
    "sha": "bcfebb6d5511ad4c156868bc799831ace628a225",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiY2ZlYmI2ZDU1MTFhZDRjMTU2ODY4YmM3OTk4MzFhY2U2MjhhMjI1",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-14T15:03:11Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-07-27T13:13:24Z"
      },
      "message": "net: save the network type explicitly in CNetAddr\n\nBefore this change, we would analyze the contents of `CNetAddr::ip[16]`\nin order to tell which type is an address. Change this by introducing a\nnew member `CNetAddr::m_net` that explicitly tells the type of the\naddress.\n\nThis is necessary because in BIP155 we will not be able to tell the\naddress type by just looking at its raw representation (e.g. both TORv3\nand I2P are \"seemingly random\" 32 bytes).\n\nAs a side effect of this change we no longer need to store IPv4\naddresses encoded as IPv6 addresses - we can store them in proper 4\nbytes (will be done in a separate commit). Also the code gets\nsomewhat simplified - instead of\n`memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0` we can use\n`m_net == NET_IPV4`.\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "656d24a3f34ad2b7c7dcc767942d38549d3dfdaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/656d24a3f34ad2b7c7dcc767942d38549d3dfdaa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bcfebb6d5511ad4c156868bc799831ace628a225",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl8e0vUACgkQVN8G9ktV\ny78uACAAprSug9FnrWXoS1RDbxQDF5ZmbVfeoWgwRI9/XEkAxYGPJ9YL9az70OHS\nMk8HP7vV36ZO+Jhya3QC2IHBNX2jwW8EnvVG+jBcoBGwrTWVkruln025PVj/XKEM\nm52PsmN5yNz8bHmvf7nir5PbUefI3VhKbG3xttaxqrKlmvTzPQ0vKay3yF/LlgPP\ndaheXX44Vdu7mnfVQcTzLA0Rkj5Jiuu54+2I25Uy+Akmpiq2LuADMQGq4SlTZHVm\nS8fnrWx6KhXNlP2EzMStBxUTJbA3eT3UNQKciWGTCZoT0A5MAlmC1oZ1eqPFel3D\n9kRXUrtlgLTveSi2ef2OVABxKLTflguDKWJh0VWABsEdwxWrmZffhBSDxBcgs8Hv\njUpcl0meiRaG5aARTdq9tRmqFNBxQVLVUVvfPqK6KibtEpaYb/wzG4xDXDHIqCoj\nMSo/4oP96Q6Zczdt3Q41rHIXkd2jdOiqL76IB2c1M7dRvOGQrkxp7qQoajxmIiOo\nW3wNyz2DwP1MvqaSdIlwqPV2hjpoE1NGd0GPvTemtaYRPRBLqxh17AiuyB7pQtZ/\nBJ73UDcoCGkdxJok+q9/RGABlESgxHuxBM2cQgOAm629pqDlBqaeU+9puoT6MKkD\neCNq79a0/v2NaJ7jsYi2ABjNSctzXbDqVWMHcpFvXU3ubHRZgL2Z1YfWTBnuOUtt\nI7mSaeXJRvp050LBr0jDHzWPXGK7sS0B0P34yqRg1mqpqzOucAgYqUD5hpgAfLTT\nz+RIj+omvyj63VqZugxFjNfQNbgJI+rKitrsCyGz3GCTSzx+IRa9LE0r/iv8XTas\n+uCWYRwfDTXRYKVDEcNFAZxtfgO8t2PNB1Ytq6PJoJt49gGphrPvYulyIsBLJAH1\ntgXyFQujvUeyQq7UZvvq6eRwxuzIiZWJyK0oeBpGhbv7P3QueiQWVaP4a4z60eiT\n4/H/iRnLFSxuPEkCrtHihSniP5IqlxmxPlZ9JDI1RIBYm64t5klexF3/uCcsdoTq\nzKkbhWb7kxlMYZEkRpOTAvpRESXFfDpXxtUy+F0Ub/cZhY+hr39TLElzTLtBKFAo\ndMko58GJ+ZpYUsOTrmhUVhDZdHo7rYS65ewGEKcqPZ0BBzCx/klCiRjr/1Bt3EME\n5vMLbUp5itdbknMmX6+0x4n9N6nDMkzbCYVGMeJMd39DhrKN83iGD5INTsAlx57U\nKVZtYGBRMTz7/xgGm9cyu7WWzxOd2SEG7sHOp9fOa33D9YxztFUg5kVtpNbJW9fc\nOMADM2qNgHtnNUcNI2d00jW2+XvsCwLghIuQHUxzvd3mExVd2G+RRoYcjEmK2fJj\nnGTauopc6vAxry+FFWQyav7QKMPLIQ==\n=RR9g\n-----END PGP SIGNATURE-----",
        "payload": "tree 656d24a3f34ad2b7c7dcc767942d38549d3dfdaa\nparent 100c64a95b518a6a19241aec4058b866a8872d9b\nauthor Vasil Dimov <vd@FreeBSD.org> 1589468591 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1595855604 +0200\n\nnet: save the network type explicitly in CNetAddr\n\nBefore this change, we would analyze the contents of `CNetAddr::ip[16]`\nin order to tell which type is an address. Change this by introducing a\nnew member `CNetAddr::m_net` that explicitly tells the type of the\naddress.\n\nThis is necessary because in BIP155 we will not be able to tell the\naddress type by just looking at its raw representation (e.g. both TORv3\nand I2P are \"seemingly random\" 32 bytes).\n\nAs a side effect of this change we no longer need to store IPv4\naddresses encoded as IPv6 addresses - we can store them in proper 4\nbytes (will be done in a separate commit). Also the code gets\nsomewhat simplified - instead of\n`memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0` we can use\n`m_net == NET_IPV4`.\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcfebb6d5511ad4c156868bc799831ace628a225",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bcfebb6d5511ad4c156868bc799831ace628a225",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcfebb6d5511ad4c156868bc799831ace628a225/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "100c64a95b518a6a19241aec4058b866a8872d9b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100c64a95b518a6a19241aec4058b866a8872d9b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/100c64a95b518a6a19241aec4058b866a8872d9b"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 91,
      "deletions": 40
    },
    "files": [
      {
        "sha": "0874b8dceae85e8583320c9d01cdc5ee6909747d",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 36,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcfebb6d5511ad4c156868bc799831ace628a225/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcfebb6d5511ad4c156868bc799831ace628a225/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=bcfebb6d5511ad4c156868bc799831ace628a225",
        "patch": "@@ -28,19 +28,35 @@ CNetAddr::CNetAddr()\n \n void CNetAddr::SetIP(const CNetAddr& ipIn)\n {\n+    m_net = ipIn.m_net;\n     memcpy(ip, ipIn.ip, sizeof(ip));\n }\n \n+void CNetAddr::SetLegacyIPv6(const uint8_t ipv6[16])\n+{\n+    if (memcmp(ipv6, pchIPv4, sizeof(pchIPv4)) == 0) {\n+        m_net = NET_IPV4;\n+    } else if (memcmp(ipv6, pchOnionCat, sizeof(pchOnionCat)) == 0) {\n+        m_net = NET_ONION;\n+    } else if (memcmp(ipv6, g_internal_prefix, sizeof(g_internal_prefix)) == 0) {\n+        m_net = NET_INTERNAL;\n+    } else {\n+        m_net = NET_IPV6;\n+    }\n+    memcpy(ip, ipv6, 16);\n+}\n+\n void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n {\n     switch(network)\n     {\n         case NET_IPV4:\n+            m_net = NET_IPV4;\n             memcpy(ip, pchIPv4, 12);\n             memcpy(ip+12, ip_in, 4);\n             break;\n         case NET_IPV6:\n-            memcpy(ip, ip_in, 16);\n+            SetLegacyIPv6(ip_in);\n             break;\n         default:\n             assert(!\"invalid network\");\n@@ -66,6 +82,7 @@ bool CNetAddr::SetInternal(const std::string &name)\n     if (name.empty()) {\n         return false;\n     }\n+    m_net = NET_INTERNAL;\n     unsigned char hash[32] = {};\n     CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\n     memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\n@@ -89,6 +106,7 @@ bool CNetAddr::SetSpecial(const std::string &strName)\n         std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n         if (vchAddr.size() != 16-sizeof(pchOnionCat))\n             return false;\n+        m_net = NET_ONION;\n         memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n         for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n             ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n@@ -123,15 +141,9 @@ bool CNetAddr::IsBindAny() const\n     return true;\n }\n \n-bool CNetAddr::IsIPv4() const\n-{\n-    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n-}\n+bool CNetAddr::IsIPv4() const { return m_net == NET_IPV4; }\n \n-bool CNetAddr::IsIPv6() const\n-{\n-    return (!IsIPv4() && !IsTor() && !IsInternal());\n-}\n+bool CNetAddr::IsIPv6() const { return m_net == NET_IPV6; }\n \n bool CNetAddr::IsRFC1918() const\n {\n@@ -165,50 +177,54 @@ bool CNetAddr::IsRFC5737() const\n \n bool CNetAddr::IsRFC3849() const\n {\n-    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n+    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&\n+           GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n }\n \n bool CNetAddr::IsRFC3964() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n+    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x02;\n }\n \n bool CNetAddr::IsRFC6052() const\n {\n     static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n+    return IsIPv6() && memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0;\n }\n \n bool CNetAddr::IsRFC4380() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n+    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 &&\n+           GetByte(12) == 0;\n }\n \n bool CNetAddr::IsRFC4862() const\n {\n     static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n+    return IsIPv6() && memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0;\n }\n \n bool CNetAddr::IsRFC4193() const\n {\n-    return ((GetByte(15) & 0xFE) == 0xFC);\n+    return IsIPv6() && (GetByte(15) & 0xFE) == 0xFC;\n }\n \n bool CNetAddr::IsRFC6145() const\n {\n     static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n-    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n+    return IsIPv6() && memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0;\n }\n \n bool CNetAddr::IsRFC4843() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n+    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&\n+           GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10;\n }\n \n bool CNetAddr::IsRFC7343() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x20);\n+    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&\n+           GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x20;\n }\n \n bool CNetAddr::IsHeNet() const\n@@ -222,10 +238,7 @@ bool CNetAddr::IsHeNet() const\n  *\n  * @see CNetAddr::SetSpecial(const std::string &)\n  */\n-bool CNetAddr::IsTor() const\n-{\n-    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n-}\n+bool CNetAddr::IsTor() const { return m_net == NET_ONION; }\n \n bool CNetAddr::IsLocal() const\n {\n@@ -235,7 +248,7 @@ bool CNetAddr::IsLocal() const\n \n     // IPv6 loopback (::1/128)\n     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-    if (memcmp(ip, pchLocal, 16) == 0)\n+    if (IsIPv6() && memcmp(ip, pchLocal, 16) == 0)\n         return true;\n \n     return false;\n@@ -259,12 +272,12 @@ bool CNetAddr::IsValid() const\n     // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n     // so if the first length field is garbled, it reads the second batch\n     // of addr misaligned by 3 bytes.\n-    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+    if (IsIPv6() && memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n         return false;\n \n     // unspecified IPv6 address (::/128)\n     unsigned char ipNone6[16] = {};\n-    if (memcmp(ip, ipNone6, 16) == 0)\n+    if (IsIPv6() && memcmp(ip, ipNone6, 16) == 0)\n         return false;\n \n     // documentation IPv6 address\n@@ -311,7 +324,7 @@ bool CNetAddr::IsRoutable() const\n  */\n bool CNetAddr::IsInternal() const\n {\n-   return memcmp(ip, g_internal_prefix, sizeof(g_internal_prefix)) == 0;\n+   return m_net == NET_INTERNAL;\n }\n \n enum Network CNetAddr::GetNetwork() const\n@@ -322,13 +335,7 @@ enum Network CNetAddr::GetNetwork() const\n     if (!IsRoutable())\n         return NET_UNROUTABLE;\n \n-    if (IsIPv4())\n-        return NET_IPV4;\n-\n-    if (IsTor())\n-        return NET_ONION;\n-\n-    return NET_IPV6;\n+    return m_net;\n }\n \n std::string CNetAddr::ToStringIP() const\n@@ -362,12 +369,12 @@ std::string CNetAddr::ToString() const\n \n bool operator==(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n+    return a.m_net == b.m_net && memcmp(a.ip, b.ip, 16) == 0;\n }\n \n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n+    return a.m_net < b.m_net || (a.m_net == b.m_net && memcmp(a.ip, b.ip, 16) < 0);\n }\n \n /**\n@@ -813,7 +820,7 @@ CSubNet::CSubNet(const CNetAddr &addr):\n  */\n bool CSubNet::Match(const CNetAddr &addr) const\n {\n-    if (!valid || !addr.IsValid())\n+    if (!valid || !addr.IsValid() || network.m_net != addr.m_net)\n         return false;\n     for(int x=0; x<16; ++x)\n         if ((addr.ip[x] & netmask[x]) != network.ip[x])"
      },
      {
        "sha": "0365907d44ce6a26865646c17ef230d2cab89513",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcfebb6d5511ad4c156868bc799831ace628a225/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcfebb6d5511ad4c156868bc799831ace628a225/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=bcfebb6d5511ad4c156868bc799831ace628a225",
        "patch": "@@ -49,10 +49,17 @@ enum Network\n     NET_MAX,\n };\n \n-/** IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96)) */\n+/**\n+ * Network address.\n+ */\n class CNetAddr\n {\n     protected:\n+        /**\n+         * Network to which this address belongs.\n+         */\n+        Network m_net{NET_IPV6};\n+\n         unsigned char ip[16]; // in network byte order\n         uint32_t scopeId{0}; // for scoped/link-local ipv6 addresses\n \n@@ -61,6 +68,14 @@ class CNetAddr\n         explicit CNetAddr(const struct in_addr& ipv4Addr);\n         void SetIP(const CNetAddr& ip);\n \n+        /**\n+         * Set from a legacy IPv6 address.\n+         * Legacy IPv6 address may be a normal IPv6 address, or another address\n+         * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n+         * `addr` encoding.\n+         */\n+        void SetLegacyIPv6(const uint8_t ipv6[16]);\n+\n         /**\n          * Set raw IPv4 or IPv6 address (in network byte order)\n          * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n@@ -122,7 +137,27 @@ class CNetAddr\n         friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n         friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n \n-        SERIALIZE_METHODS(CNetAddr, obj) { READWRITE(obj.ip); }\n+        /**\n+         * Serialize to a stream.\n+         */\n+        template <typename Stream>\n+        void Serialize(Stream& s) const\n+        {\n+            s << ip;\n+        }\n+\n+        /**\n+         * Unserialize from a stream.\n+         */\n+        template <typename Stream>\n+        void Unserialize(Stream& s)\n+        {\n+            unsigned char ip_temp[sizeof(ip)];\n+            s >> ip_temp;\n+            // Use SetLegacyIPv6() so that m_net is set correctly. For example\n+            // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n+            SetLegacyIPv6(ip_temp);\n+        }\n \n         friend class CSubNet;\n };"
      },
      {
        "sha": "591b4ce49ac5ef1c578f36933c754abc6e4b99ff",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcfebb6d5511ad4c156868bc799831ace628a225/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcfebb6d5511ad4c156868bc799831ace628a225/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=bcfebb6d5511ad4c156868bc799831ace628a225",
        "patch": "@@ -138,6 +138,14 @@ BOOST_AUTO_TEST_CASE(onioncat_test)\n \n }\n \n+BOOST_AUTO_TEST_CASE(embedded_test)\n+{\n+    CNetAddr addr1(ResolveIP(\"1.2.3.4\"));\n+    CNetAddr addr2(ResolveIP(\"::FFFF:0102:0304\"));\n+    BOOST_CHECK(addr2.IsIPv4());\n+    BOOST_CHECK_EQUAL(addr1.ToString(), addr2.ToString());\n+}\n+\n BOOST_AUTO_TEST_CASE(subnet_test)\n {\n \n@@ -158,12 +166,13 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(ResolveSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n     BOOST_CHECK(ResolveSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n     BOOST_CHECK(ResolveSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n-    // All-Matching IPv6 Matches arbitrary IPv4 and IPv6\n+    // All-Matching IPv6 Matches arbitrary IPv6\n     BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n     // But not `::` or `0.0.0.0` because they are considered invalid addresses\n     BOOST_CHECK(!ResolveSubNet(\"::/0\").Match(ResolveIP(\"::\")));\n     BOOST_CHECK(!ResolveSubNet(\"::/0\").Match(ResolveIP(\"0.0.0.0\")));\n-    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n+    // Addresses from one network (IPv4) don't belong to subnets of another network (IPv6)\n+    BOOST_CHECK(!ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n     // All-Matching IPv4 does not Match IPv6\n     BOOST_CHECK(!ResolveSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n     // Invalid subnets Match nothing (not even invalid addresses)"
      }
    ]
  }
]