[
  {
    "sha": "4c4c0cf2396809800ee69f3f1ee8069885e16a06",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzRjMGNmMjM5NjgwOTgwMGVlNjlmM2YxZWU4MDY5ODg1ZTE2YTA2",
    "commit": {
      "author": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2019-11-27T00:59:33Z"
      },
      "committer": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2020-10-01T00:46:51Z"
      },
      "message": "Add address index\n\nAdds index that relates scriptPubKeys to location of transactions in the\nfilesystem, along with the hash of the block they are found in, and the\noutpoint information of the txout with the related script.",
      "tree": {
        "sha": "047be3db5d995424ed47af51830a4a8adb711672",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/047be3db5d995424ed47af51830a4a8adb711672"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c4c0cf2396809800ee69f3f1ee8069885e16a06",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c4c0cf2396809800ee69f3f1ee8069885e16a06",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c4c0cf2396809800ee69f3f1ee8069885e16a06",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c4c0cf2396809800ee69f3f1ee8069885e16a06/comments",
    "author": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3487e421a7fef4b28381efcf21a7e38483946cec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3487e421a7fef4b28381efcf21a7e38483946cec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3487e421a7fef4b28381efcf21a7e38483946cec"
      }
    ],
    "stats": {
      "total": 345,
      "additions": 345,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3bd93aeef512b7a3ccd2e2d9724fe091ff28424e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c4c0cf2396809800ee69f3f1ee8069885e16a06/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c4c0cf2396809800ee69f3f1ee8069885e16a06/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=4c4c0cf2396809800ee69f3f1ee8069885e16a06",
        "patch": "@@ -139,6 +139,7 @@ BITCOIN_CORE_H = \\\n   fs.h \\\n   httprpc.h \\\n   httpserver.h \\\n+  index/addrindex.h \\\n   index/base.h \\\n   index/blockfilterindex.h \\\n   index/disktxpos.h \\\n@@ -294,6 +295,7 @@ libbitcoin_server_a_SOURCES = \\\n   flatfile.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n+  index/addrindex.cpp \\\n   index/base.cpp \\\n   index/blockfilterindex.cpp \\\n   index/txindex.cpp \\"
      },
      {
        "sha": "31fe3fd78c77bbeef6f395b13e5e5fa12757419f",
        "filename": "src/index/addrindex.cpp",
        "status": "added",
        "additions": 279,
        "deletions": 0,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c4c0cf2396809800ee69f3f1ee8069885e16a06/src/index/addrindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c4c0cf2396809800ee69f3f1ee8069885e16a06/src/index/addrindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/addrindex.cpp?ref=4c4c0cf2396809800ee69f3f1ee8069885e16a06",
        "patch": "@@ -0,0 +1,279 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <dbwrapper.h>\n+#include <hash.h>\n+#include <index/addrindex.h>\n+#include <index/disktxpos.h>\n+#include <shutdown.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <script/standard.h>\n+#include <txdb.h>\n+#include <validation.h>\n+#include <vector>\n+#include <uint256.h>\n+\n+std::unique_ptr<AddrIndex> g_addr_index;\n+\n+/*\n+ * The address index stores two main types of objects that allow for\n+ * script-based/address-based look-ups of all created outputs and all spent\n+ * outputs in the Bitcoin blockchain. These are differentiated by their key_type\n+ * as either DBKeyType::SPENT or DBKekyType::CREATED. The address index also\n+ * stores one unique global value under the DBKeyType::SEED key that seeds the\n+ * MurmurHash3 hasher used to create AddrIds.\n+ *\n+ * The DB keys are structured as follows: <addr_id, key_type, outpoint>\n+ *\n+ * addr_id is the hash of the script_pub_key computed using MurmurHash3, a short\n+ * non-cryptographic hash function. It also functions as the search key, since\n+ * LevelDB keys are iterated through in lexicograpical order. Collisions are\n+ * resolved by storing the full script_pub_key in the DB value. This can be\n+ * checked against the script used to make a look-up in the index.\n+ *\n+ * key_type is SPENT when the outpoint stored in the key is spent, i.e. it is\n+ * used as a prevout in a transaction input.  It is CREATED when the outpoint is\n+ * created as a new  COutpoint in that transaction.\n+ *\n+ * outpoints are stored in the key as opposed to in the DB value to preserve\n+ * uniqueness and to support multiple values for a single addr_id and key_type\n+ * combination. LevelDB only allows one value stored for each key.\n+ *\n+ *\n+ * The DB values are simply: <CDiskTxPos, CScript>\n+ *\n+ * The tx_pos (CDiskTxPos) value is the transaction in which:\n+ *  - the outpoint in the key was spent (for SPENT keys)\n+ *  - OR where the outpoint was created (for CREATED keys)\n+ *\n+ * The CScript (the script_pub_key) is used for collision resolution.\n+ */\n+using AddrId = unsigned int;\n+// DBKeyType is used by the address index to distinguish between the\n+// different kinds of values stored.\n+enum class DBKeyType : uint8_t {\n+    SEED,    // Seed used for MurmurHash3 inside GetAddrId\n+    SPENT,   // Used for values in the index indicating a spend\n+    CREATED, // Used for values in the index indicating the creation of an input\n+};\n+\n+\n+namespace {\n+\n+struct DBKey {\n+  AddrId m_addr_id;\n+  DBKeyType m_key_type;\n+  COutPoint m_outpoint;\n+\n+  DBKey() {}\n+  explicit DBKey(DBKeyType key_type, AddrId addr_id, COutPoint outpoint) : m_addr_id(addr_id), m_key_type(key_type), m_outpoint(outpoint) {}\n+\n+  SERIALIZE_METHODS(DBKey, obj) {\n+    uint8_t key_type;\n+    SER_WRITE(obj, key_type = static_cast<uint8_t>(obj.m_key_type));\n+\n+    READWRITE(obj.m_addr_id, key_type, obj.m_outpoint);\n+\n+    SER_READ(obj, obj.m_key_type  = static_cast<DBKeyType>(key_type));\n+    // Check if the key type is a valid key. SEED keys are excluded because they\n+    // are never created with this type.\n+    if ((obj.m_key_type != DBKeyType::SPENT) && (obj.m_key_type != DBKeyType::CREATED)) {\n+      throw std::ios_base::failure(\"Invalid key type for address index DB key\");\n+    }\n+  }\n+};\n+\n+}; // namespace\n+\n+// The address index stores information needed to get relevant transactions,\n+// and a copy of the CScript to double check against in case of hash collisions.\n+using DBValue = std::pair<CDiskTxPos, CScript>;\n+\n+/** Access to the addr_index database (indexes/addr_index/)*/\n+class AddrIndex::DB : public BaseIndex::DB\n+{\n+public:\n+    explicit DB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n+\n+    /** ReadAddrIndex returns the set of entries stored in the index for this addr_id. */\n+    std::vector<std::pair<DBKey, DBValue>> ReadAddrIndex(const int max_count, const int skip, const unsigned int addr_id, const CScript& script);\n+\n+    /** WriteToIndex writes the input vector of database entries into the index.  */\n+    bool WriteToIndex(const std::vector<std::pair<DBKey, DBValue>> &entries);\n+\n+    /** SetupHashSeed is used to create/backup/restore the seed used by the index for hashing. */\n+    unsigned int SetupHashSeed();\n+};\n+\n+AddrIndex::DB::DB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n+    BaseIndex::DB(GetDataDir() / \"indexes\" / \"addr_index\", n_cache_size, f_memory, f_wipe)\n+{}\n+\n+BaseIndex::DB& AddrIndex::GetDB() const { return *m_db; }\n+\n+std::vector<std::pair<DBKey, DBValue>> AddrIndex::DB::ReadAddrIndex(const int max_count, const int skip, const unsigned int addr_id, const CScript& script)\n+{\n+    std::vector<std::pair<DBKey, DBValue>> result;\n+    AddrId search_key = addr_id;\n+\n+    std::unique_ptr<CDBIterator> iter(NewIterator());\n+    iter->Seek(search_key);\n+    int i = 0;\n+    while (iter->Valid() && i < max_count) {\n+        DBKey key;\n+        DBValue value;\n+        if (!iter->GetKey(key) || key.m_addr_id != addr_id) break;\n+        if (!iter->GetValue(value)) {\n+            LogPrintf(\"%s: Failed to read value stored under key with addr_id:  %d\\n\", __func__, addr_id);\n+            break;\n+        }\n+\n+        // Check that the stored script matches the one we're searching for, in case of hash collisions.\n+        if (value.second == script && i >= skip) {\n+            result.emplace_back(std::make_pair(key, value));\n+        }\n+        iter->Next();\n+        i++;\n+    }\n+\n+    return result;\n+}\n+\n+bool AddrIndex::Init() {\n+        m_hash_seed = m_db->SetupHashSeed();\n+        return BaseIndex::Init();\n+}\n+\n+AddrIndex::AddrIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_db(MakeUnique<AddrIndex::DB>(n_cache_size, f_memory, f_wipe)) {}\n+\n+unsigned int AddrIndex::DB::SetupHashSeed() {\n+    static const uint8_t seed_key =  static_cast<uint8_t>(DBKeyType::SEED);\n+    unsigned int seed;\n+\n+    std::unique_ptr<CDBIterator> iter(NewIterator());\n+    uint8_t key;\n+\n+    // If key is in the index already, read it and return.\n+    iter->Seek(seed_key);\n+    if (iter->Valid() && iter->GetKey(key) && key == seed_key) {\n+        if (!iter->GetValue(seed)) {\n+            return error(\"%s: Cannot read current %s seed key; index may be corrupted\", __func__);\n+        }\n+        return seed;\n+    }\n+\n+    // Generate a random key and write it to the index.\n+    seed = GetRandInt(std::numeric_limits<int>::max());\n+    Write(seed_key, seed);\n+    return seed;\n+}\n+\n+AddrIndex::~AddrIndex() {}\n+\n+unsigned int AddrIndex::GetAddrId(const CScript& script) {\n+    std::vector<unsigned char> script_data;\n+    for (auto it = script.begin(); it != script.end(); ++it) {\n+        script_data.push_back(*it);\n+    }\n+    return MurmurHash3(m_hash_seed, script_data);\n+}\n+\n+bool AddrIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n+    std::vector<std::pair<DBKey, DBValue>> entries;\n+\n+    const bool genesis_block = (pindex->nHeight == 0);\n+    if (!genesis_block && !UndoReadFromDisk(block_undo, pindex)) {\n+      return false;\n+    }\n+\n+    for (size_t i = 0; i < block.vtx.size(); ++i) {\n+        const CTransaction& tx = *(block.vtx[i]);\n+        const uint256 tx_hash = tx.GetHash();\n+        for (size_t j = 0; j < tx.vout.size(); ++j) {\n+            CScript script_pub_key = tx.vout[j].scriptPubKey;\n+            DBKey key(DBKeyType::CREATED, GetAddrId(script_pub_key), COutPoint(tx_hash, j));\n+            entries.emplace_back(key, std::make_pair(pos, script_pub_key));\n+        }\n+\n+        // Skip coinbase inputs.\n+        if (!genesis_block && i > 0) {\n+            const CTxUndo& tx_undo = block_undo.vtxundo[i-1];\n+            for (size_t k = 0; k < tx.vin.size(); ++k) {\n+                CScript spent_outputs_scriptpubkey = tx_undo.vprevout[k].out.scriptPubKey;\n+                DBKey key(DBKeyType::SPENT, GetAddrId(spent_outputs_scriptpubkey), tx.vin[k].prevout);\n+                entries.emplace_back(key, std::make_pair(pos, spent_outputs_scriptpubkey));\n+            }\n+        }\n+        pos.nTxOffset += ::GetSerializeSize(tx, CLIENT_VERSION);\n+    }\n+\n+    return m_db->WriteToIndex(entries);\n+}\n+\n+bool AddrIndex::DB::WriteToIndex(const std::vector<std::pair<DBKey, DBValue>> &entries)\n+{\n+    CDBBatch batch(*this);\n+    for (const auto& entry : entries) {\n+        batch.Write(entry.first, entry.second);\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+// FindTxsByScript fills the spends_result vector with outpoints corresponding\n+// to the output spent with the given script, and the transaction it was spent\n+// in. creations_result is filled with outpoints for outputs created with this\n+// script as their script pubkey, and the transactions they were created in.\n+// max_count determines the maximum number of results returned. The skip\n+// parameter sets the number of initial values skipped.\n+bool AddrIndex::FindTxsByScript(const int max_count,\n+                                const int skip,\n+                                const CScript& script,\n+                                std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> &spends_result,\n+                                std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> &creations_result)\n+{\n+    auto db_entries = m_db->ReadAddrIndex(max_count, skip, GetAddrId(script), script);\n+    if (db_entries.size() == 0) return false;\n+\n+    for (const auto& entry : db_entries) {\n+        DBKey key = entry.first;\n+        CDiskTxPos pos = entry.second.first;\n+\n+        CAutoFile file(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n+        if (file.IsNull()) {\n+            return error(\"%s: OpenBlockFile failed\", __func__);\n+        }\n+        CBlockHeader header;\n+        CTransactionRef tx;\n+        try {\n+            file >> header;\n+            if (fseek(file.Get(), pos.nTxOffset, SEEK_CUR)) {\n+                return error(\"%s: fseek(...) failed\", __func__);\n+            }\n+            file >> tx;\n+        } catch (const std::exception& e) {\n+            return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n+        }\n+        std::pair<CTransactionRef, uint256> result =  std::make_pair(tx, header.GetHash());\n+\n+        // Place entry into correct vector depending on its type.\n+        switch (key.m_key_type) {\n+            case DBKeyType::SPENT:\n+                spends_result.emplace_back(std::make_pair(key.m_outpoint, result));\n+                break;\n+            case DBKeyType::CREATED:\n+                creations_result.emplace_back(std::make_pair(key.m_outpoint, result));\n+                break;\n+            default:\n+                LogPrintf(\"AddrIndex::DB returned value with unexpected key type.\\n\");\n+                return false;\n+        }\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "11607ed4ed5046ad4c0311ce63851704461af377",
        "filename": "src/index/addrindex.h",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c4c0cf2396809800ee69f3f1ee8069885e16a06/src/index/addrindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c4c0cf2396809800ee69f3f1ee8069885e16a06/src/index/addrindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/addrindex.h?ref=4c4c0cf2396809800ee69f3f1ee8069885e16a06",
        "patch": "@@ -0,0 +1,64 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INDEX_ADDRINDEX_H\n+#define BITCOIN_INDEX_ADDRINDEX_H\n+\n+#include <chain.h>\n+#include <index/base.h>\n+#include <vector>\n+#include <txdb.h>\n+#include <uint256.h>\n+#include <primitives/transaction.h>\n+#include <script/standard.h>\n+#include <script/script.h>\n+#include <undo.h>\n+\n+/**\n+ * AddrIndex is used to look up transactions included in the blockchain by script.\n+ * The index is written to a LevelDB database and records the filesystem\n+ * location of transactions by script.\n+ */\n+class AddrIndex final : public BaseIndex\n+{\n+protected:\n+    class DB;\n+\n+private:\n+    const std::unique_ptr<DB> m_db;\n+\n+    // m_hash_seed is used by GetAddrID in its calls to MurmurHash3.\n+    // It is stored in the index, and restored from there on construction\n+    // to maintain consistency.\n+    unsigned int m_hash_seed;\n+\n+    unsigned int GetAddrId(const CScript& script);\n+\n+protected:\n+    bool Init() override;\n+\n+    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;\n+\n+    BaseIndex::DB& GetDB() const override;\n+\n+    const char* GetName() const override { return \"addr_index\"; }\n+\n+public:\n+    /// Constructs the index, which becomes available to be queried.\n+    explicit AddrIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n+\n+    // Destructor is declared because this class contains a unique_ptr to an incomplete type.\n+    ~AddrIndex() override;\n+\n+    bool FindTxsByScript(const int max_count,\n+                         const int skip,\n+                         const CScript& dest,\n+                         std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> &spends_result,\n+                         std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> &creations_result);\n+};\n+\n+/// The global address index, used in FindTxsByScript. May be null.\n+extern std::unique_ptr<AddrIndex> g_addr_index;\n+\n+#endif // BITCOIN_INDEX_ADDRINDEX_H"
      }
    ]
  },
  {
    "sha": "545bc46a225b68d09a129924bbedf41fef58d071",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDViYzQ2YTIyNWI2OGQwOWExMjk5MjRiYmVkZjQxZmVmNThkMDcx",
    "commit": {
      "author": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2019-11-26T23:41:39Z"
      },
      "committer": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2020-10-01T00:46:51Z"
      },
      "message": "Initialize address index\n\nSetup address index in initialization process.\nAdd initialization warning and wallet feature request warning as\nsuggested by ryanofsky.",
      "tree": {
        "sha": "300fcc4b25586b8b1d643d0e4ddd85dff9e5e07d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/300fcc4b25586b8b1d643d0e4ddd85dff9e5e07d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/545bc46a225b68d09a129924bbedf41fef58d071",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/545bc46a225b68d09a129924bbedf41fef58d071",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/545bc46a225b68d09a129924bbedf41fef58d071",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/545bc46a225b68d09a129924bbedf41fef58d071/comments",
    "author": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c4c0cf2396809800ee69f3f1ee8069885e16a06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c4c0cf2396809800ee69f3f1ee8069885e16a06",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c4c0cf2396809800ee69f3f1ee8069885e16a06"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 43,
      "deletions": 0
    },
    "files": [
      {
        "sha": "aae9428309f2289729699f454a31d4d93f58f17e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/545bc46a225b68d09a129924bbedf41fef58d071/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/545bc46a225b68d09a129924bbedf41fef58d071/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=545bc46a225b68d09a129924bbedf41fef58d071",
        "patch": "@@ -21,6 +21,7 @@\n #include <hash.h>\n #include <httprpc.h>\n #include <httpserver.h>\n+#include <index/addrindex.h>\n #include <index/blockfilterindex.h>\n #include <index/txindex.h>\n #include <interfaces/chain.h>\n@@ -171,6 +172,9 @@ void Interrupt(NodeContext& node)\n     if (g_txindex) {\n         g_txindex->Interrupt();\n     }\n+    if (g_addr_index) {\n+        g_addr_index->Interrupt();\n+    }\n     ForEachBlockFilterIndex([](BlockFilterIndex& index) { index.Interrupt(); });\n }\n \n@@ -266,6 +270,12 @@ void Shutdown(NodeContext& node)\n         g_txindex->Stop();\n         g_txindex.reset();\n     }\n+    if (g_addr_index) {\n+        g_addr_index->Stop();\n+        g_addr_index.reset();\n+    }\n+\n+\n     ForEachBlockFilterIndex([](BlockFilterIndex& index) { index.Stop(); });\n     DestroyAllBlockFilterIndexes();\n \n@@ -433,6 +443,7 @@ void SetupServerArgs(NodeContext& node)\n     hidden_args.emplace_back(\"-sysperms\");\n #endif\n     argsman.AddArg(\"-txindex\", strprintf(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\", DEFAULT_TXINDEX), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    argsman.AddArg(\"-addrindex\", strprintf(\"Maintain a full address index, used by the searchrawtransactions rpc call (default: %u)\", DEFAULT_ADDR_INDEX), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-blockfilterindex=<type>\",\n                  strprintf(\"Maintain an index of compact filters by block (default: %s, values: %s).\", DEFAULT_BLOCKFILTERINDEX, ListBlockFilterTypes()) +\n                  \" If <type> is not supplied or if <type> = 1, indexes for all known types are enabled.\",\n@@ -1017,6 +1028,8 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n     if (args.GetArg(\"-prune\", 0)) {\n         if (args.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX))\n             return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n+        if (gArgs.GetBoolArg(\"-addrindex\", DEFAULT_ADDR_INDEX))\n+            return InitError(_(\"Prune mode is incompatible with -addrindex.\"));\n         if (!g_enabled_filter_types.empty()) {\n             return InitError(_(\"Prune mode is incompatible with -blockfilterindex.\"));\n         }\n@@ -1548,6 +1561,8 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n         filter_index_cache = max_cache / n_indexes;\n         nTotalCache -= filter_index_cache * n_indexes;\n     }\n+    int64_t addr_index_cache = std::min(nTotalCache / 8, gArgs.GetBoolArg(\"-addrindex\", DEFAULT_TXINDEX) ? max_addr_index_cache << 20 : 0);\n+    nTotalCache -= addr_index_cache;\n     int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache\n     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache\n     nTotalCache -= nCoinDBCache;\n@@ -1565,6 +1580,25 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     LogPrintf(\"* Using %.1f MiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n+    if (gArgs.GetBoolArg(\"-addrindex\", DEFAULT_ADDR_INDEX)) {\n+        LogPrintf(\"* Using %.1f MiB for address index database\\n\", addr_index_cache * (1.0 / 1024 / 1024));\n+\n+        LogPrintf(\"Built-in address index is enabled! Address \" /* Continued */\n+          \"indexing is going to become less scalable as transaction history \"\n+          \"increases, and will eventually need to be removed from %s and \"\n+          \"replaced by a dedicated external index. Users relying on the address\"\n+          \" index for accounting purposes are advised to track metadata in real\"\n+          \" time so relying on a historical index is not necessary.\\n\",\n+          PACKAGE_NAME);\n+\n+        if (g_wallet_init_interface.HasWalletSupport()) {\n+          LogPrintf(\"If using the address index to work around lack\" /* Continued */\n+           \" of tagging or notifications from the built-in %s wallet, \"\n+           \" please file wallet feature requests: %s\\n\",\n+           PACKAGE_NAME, PACKAGE_BUGREPORT);\n+        }\n+    }\n+\n     bool fLoaded = false;\n     while (!fLoaded && !ShutdownRequested()) {\n         bool fReset = fReindex;\n@@ -1801,6 +1835,11 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n         g_txindex->Start();\n     }\n \n+    if (gArgs.GetBoolArg(\"-addrindex\", DEFAULT_ADDR_INDEX)) {\n+        g_addr_index = MakeUnique<AddrIndex>(addr_index_cache, false, fReindex);\n+        g_addr_index->Start();\n+    }\n+\n     for (const auto& filter_type : g_enabled_filter_types) {\n         InitBlockFilterIndex(filter_type, filter_index_cache, false, fReindex);\n         GetBlockFilterIndex(filter_type)->Start();"
      },
      {
        "sha": "3fe15568be1959acffe892dee70e6bdce3869424",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/545bc46a225b68d09a129924bbedf41fef58d071/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/545bc46a225b68d09a129924bbedf41fef58d071/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=545bc46a225b68d09a129924bbedf41fef58d071",
        "patch": "@@ -36,6 +36,8 @@ static const int64_t nMaxBlockDBCache = 2;\n static const int64_t nMaxTxIndexCache = 1024;\n //! Max memory allocated to all block filter index caches combined in MiB.\n static const int64_t max_filter_index_cache = 1024;\n+//! Max memory allocated to the address index cache.\n+static const int64_t max_addr_index_cache = 1024;\n //! Max memory allocated to coin DB specific cache (MiB)\n static const int64_t nMaxCoinsDBCache = 8;\n "
      },
      {
        "sha": "65ef2f8e5aba1baf3a56893ea5bebc4e93166fa9",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/545bc46a225b68d09a129924bbedf41fef58d071/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/545bc46a225b68d09a129924bbedf41fef58d071/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=545bc46a225b68d09a129924bbedf41fef58d071",
        "patch": "@@ -74,6 +74,8 @@ static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n static const bool DEFAULT_TXINDEX = false;\n static const char* const DEFAULT_BLOCKFILTERINDEX = \"0\";\n+static const bool DEFAULT_ADDR_INDEX = false;\n+static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n /** Default for -persistmempool */\n static const bool DEFAULT_PERSIST_MEMPOOL = true;\n /** Default for using fee filter */"
      }
    ]
  },
  {
    "sha": "0f85eb9043f899235acb7b4b75472d125b54008e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZjg1ZWI5MDQzZjg5OTIzNWFjYjdiNGI3NTQ3MmQxMjViNTQwMDhl",
    "commit": {
      "author": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2019-11-27T00:59:44Z"
      },
      "committer": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2020-10-01T00:46:51Z"
      },
      "message": "Add address index test",
      "tree": {
        "sha": "189852b6bd8551070133560d564f4801c1b5ebef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/189852b6bd8551070133560d564f4801c1b5ebef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0f85eb9043f899235acb7b4b75472d125b54008e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f85eb9043f899235acb7b4b75472d125b54008e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0f85eb9043f899235acb7b4b75472d125b54008e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f85eb9043f899235acb7b4b75472d125b54008e/comments",
    "author": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "545bc46a225b68d09a129924bbedf41fef58d071",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/545bc46a225b68d09a129924bbedf41fef58d071",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/545bc46a225b68d09a129924bbedf41fef58d071"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 199,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8e3ab54443b8592e89c12b7fe240fe8611546183",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f85eb9043f899235acb7b4b75472d125b54008e/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f85eb9043f899235acb7b4b75472d125b54008e/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=0f85eb9043f899235acb7b4b75472d125b54008e",
        "patch": "@@ -204,6 +204,7 @@ FUZZ_SUITE_LD_COMMON = \\\n \n # test_bitcoin binary #\n BITCOIN_TESTS =\\\n+  test/addrindex_tests.cpp \\\n   test/arith_uint256_tests.cpp \\\n   test/scriptnum10.h \\\n   test/addrman_tests.cpp \\"
      },
      {
        "sha": "3992828cdf0d4c83ecbf9ed26aaa79b7edd20d28",
        "filename": "src/test/addrindex_tests.cpp",
        "status": "added",
        "additions": 174,
        "deletions": 0,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f85eb9043f899235acb7b4b75472d125b54008e/src/test/addrindex_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f85eb9043f899235acb7b4b75472d125b54008e/src/test/addrindex_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrindex_tests.cpp?ref=0f85eb9043f899235acb7b4b75472d125b54008e",
        "patch": "@@ -0,0 +1,174 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chainparams.h>\n+#include <index/addrindex.h>\n+#include <index/txindex.h>\n+#include <script/standard.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(addr_index_tests)\n+\n+BOOST_FIXTURE_TEST_CASE(addr_index_initial_sync_and_spends, TestChain100Setup)\n+{\n+    AddrIndex addr_index(1 << 20, true);\n+    CScript coinbase_script_pub_key = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    const int max_count = 500; // Use a max count of 500, which is much higher than the number of results in the test.\n+    const int skip = 0;\n+\n+    // Transactions should not be found in the index before it is started.\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations;\n+    BOOST_CHECK(!addr_index.FindTxsByScript(max_count, skip, coinbase_script_pub_key, spends, creations));\n+\n+    // BlockUntilSyncedToCurrentChain should return false before addr_index is started.\n+    BOOST_CHECK(!addr_index.BlockUntilSyncedToCurrentChain());\n+    addr_index.Start();\n+\n+    // Mine blocks for coinbase maturity, so we can spend some coinbase outputs in the test.\n+    for (int i = 0; i < 20; i++) {\n+        std::vector<CMutableTransaction> no_txns;\n+        CreateAndProcessBlock(no_txns, coinbase_script_pub_key);\n+    }\n+\n+    // Allow addr_index to catch up with the block index.\n+    constexpr int64_t timeout_ms = 10 * 1000;\n+    int64_t time_start = GetTimeMillis();\n+    while (!addr_index.BlockUntilSyncedToCurrentChain()) {\n+        BOOST_REQUIRE(time_start + timeout_ms > GetTimeMillis());\n+        UninterruptibleSleep(std::chrono::milliseconds{100});\n+    }\n+\n+    // Check that addr_index has all coinbase outputs indexed.\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends2;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations2;\n+    if (!addr_index.FindTxsByScript(max_count, skip, coinbase_script_pub_key, spends2, creations2)) {\n+            BOOST_ERROR(\"FindTxsByScript failed\");\n+    }\n+    // The coinbase transactions have the same scriptPubKey in their output.\n+    BOOST_CHECK_EQUAL(spends2.size(), 0u);\n+    BOOST_CHECK_EQUAL(creations2.size(), 120u);\n+\n+    // Create several new key pairs to test sending to many different addresses in the same block.\n+    std::vector<CKey> priv_keys(10);\n+    std::vector<CScript> script_pub_keys(10);\n+    for (int i = 0; i < 10; i++) {\n+        priv_keys[i].MakeNewKey(true);\n+        script_pub_keys[i] = CScript() <<  ToByteVector(priv_keys[i].GetPubKey()) << OP_CHECKSIG;\n+    }\n+\n+    // Create a transaction sending to each of the new addresses.\n+    std::vector<CMutableTransaction> spend_txns(10);\n+    CreateSpendingTxs(0, script_pub_keys, spend_txns, coinbase_script_pub_key);\n+\n+    const CBlock& block = CreateAndProcessBlock(spend_txns, coinbase_script_pub_key);\n+    const uint256 block_hash = block.GetHash();\n+    BOOST_CHECK(addr_index.BlockUntilSyncedToCurrentChain()); // Let the address index catch up.\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() == block_hash); // Sanity check to make sure this block is actually being used.\n+\n+    // Now check that all the addresses we sent to are present in the index.\n+    for (int i = 0; i < 10; i++) {\n+        std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends3;\n+        std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations3;\n+        if (!addr_index.FindTxsByScript(max_count, skip, script_pub_keys[i], spends3, creations3)) {\n+            BOOST_ERROR(\"FindTxsByScript failed\");\n+        }\n+\n+        // The coinbase transactions have the same scriptPubKey in their output.\n+        BOOST_CHECK_EQUAL(spends3.size(), 0u);\n+        BOOST_CHECK_EQUAL(creations3.size(), 1u);\n+\n+        // Confirm that the transaction's destination is in the index.\n+        bool found_tx = false;\n+        for (const auto& creation : creations3) {\n+            if (creation.second.first->GetHash() == spend_txns[i].GetHash()) {\n+                found_tx = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found_tx) BOOST_ERROR(\"Transaction not found by destination\");\n+    }\n+\n+    // Now we'll create transaction that only send to the first 5 addresses we made.\n+    // Then we can check that the number of txs for those addresses increases, while\n+    // the number of txs for the other address remains the same.\n+    std::vector<CMutableTransaction> spend_txns2(5);\n+    CreateSpendingTxs(10, script_pub_keys, spend_txns2, coinbase_script_pub_key);\n+\n+    const CBlock& block2 = CreateAndProcessBlock(spend_txns2, coinbase_script_pub_key);\n+    const uint256 block_hash2 = block2.GetHash();\n+    BOOST_CHECK(addr_index.BlockUntilSyncedToCurrentChain());\n+    BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() == block_hash2);\n+\n+    for (int i = 0; i < 10; i++) {\n+        std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends4;\n+        std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations4;\n+\n+        if (!addr_index.FindTxsByScript(max_count, skip, script_pub_keys[i], spends4, creations4)) {\n+            BOOST_ERROR(\"FindTxsByScript failed\");\n+        }\n+\n+        // The coinbase transactions have the same scriptPubKey in their output.\n+        BOOST_CHECK_EQUAL(spends4.size(), 0u);\n+\n+        // Expect 2 transactions for those sent to twice, 1 for the rest.\n+        if (i >= 5) {\n+            BOOST_CHECK_EQUAL(creations4.size(), 1u);\n+        } else {\n+            BOOST_CHECK_EQUAL(creations4.size(), 2u);\n+        }\n+\n+        // Confirm that the transaction's destination is in the index.\n+        bool found_tx = false;\n+        for (const auto& creation :creations4) {\n+            if (i >= 5) {\n+                if (creation.second.first->GetHash() == spend_txns[i].GetHash()) {\n+                    found_tx = true;\n+                    break;\n+                }\n+            } else {\n+                if (creation.second.first->GetHash() == spend_txns2[i].GetHash()) {\n+                    found_tx = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!found_tx) BOOST_ERROR(\"Transaction not found by destination\");\n+    }\n+\n+    // Check the results for the coinbase_script_pub_key again.\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends5;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations5;\n+    if (!addr_index.FindTxsByScript(max_count, skip, coinbase_script_pub_key, spends5, creations5)) {\n+        BOOST_ERROR(\"FindTxsByScript failed\");\n+    }\n+    BOOST_CHECK_EQUAL(spends5.size(), 10u + 5u);\n+    BOOST_CHECK_EQUAL(creations5.size(), 100u + 20u + 2u);\n+\n+    // Check that max_count is respected by setting a low max_count of 22.\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends6;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations6;\n+    if (!addr_index.FindTxsByScript(22, skip, coinbase_script_pub_key, spends6, creations6)) {\n+            BOOST_ERROR(\"FindTxsByScript failed\");\n+    }\n+    BOOST_CHECK_EQUAL(spends6.size()+creations6.size(), 22u);\n+\n+    // Check that the skip parameter is respected by setting a skip of 40.\n+    const unsigned int skip_test_val = 40;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends7;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations7;\n+    if (!addr_index.FindTxsByScript(max_count, skip_test_val, coinbase_script_pub_key, spends7, creations7)) {\n+            BOOST_ERROR(\"FindTxsByScript failed\");\n+    }\n+    BOOST_CHECK_EQUAL(spends7.size()+creations7.size(), spends5.size()+creations5.size()-skip_test_val);\n+\n+    addr_index.Stop();\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7eb0d016f6207c0d55190642685acb8cce094d7f",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f85eb9043f899235acb7b4b75472d125b54008e/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f85eb9043f899235acb7b4b75472d125b54008e/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=0f85eb9043f899235acb7b4b75472d125b54008e",
        "patch": "@@ -227,6 +227,26 @@ CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa\n     return block;\n }\n \n+void TestChain100Setup::CreateSpendingTxs(int coinbase_spent_offset, std::vector<CScript>& script_pub_keys, std::vector<CMutableTransaction> &spends, const CScript& coinbase_script_pub_key) {\n+    for (unsigned int i = 0; i < spends.size(); i++) {\n+        spends[i].nVersion = 1;\n+        spends[i].vin.resize(1);\n+        spends[i].vin[0].prevout.hash = m_coinbase_txns[i + coinbase_spent_offset]->GetHash();\n+        spends[i].vin[0].prevout.n = 0;\n+        spends[i].vout.resize(1);\n+        spends[i].vout[0].nValue = 11*CENT;\n+        spends[i].vout[0].scriptPubKey = script_pub_keys[i];\n+\n+        // Sign:\n+        std::vector<unsigned char> vchSig;\n+        const uint256 hash = SignatureHash(coinbase_script_pub_key, spends[i], 0, SIGHASH_ALL, 0, SigVersion::BASE);\n+        coinbaseKey.Sign(hash, vchSig);\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        spends[i].vin[0].scriptSig << vchSig;\n+    }\n+}\n+\n+\n TestChain100Setup::~TestChain100Setup()\n {\n     gArgs.ForceSetArg(\"-segwitheight\", \"0\");"
      },
      {
        "sha": "92b9c90cd59e9e6d3ceb1253442fd22153262bac",
        "filename": "src/test/util/setup_common.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f85eb9043f899235acb7b4b75472d125b54008e/src/test/util/setup_common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f85eb9043f899235acb7b4b75472d125b54008e/src/test/util/setup_common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.h?ref=0f85eb9043f899235acb7b4b75472d125b54008e",
        "patch": "@@ -115,6 +115,10 @@ struct TestChain100Setup : public RegTestingSetup {\n     CBlock CreateAndProcessBlock(const std::vector<CMutableTransaction>& txns,\n                                  const CScript& scriptPubKey);\n \n+    // Fill spends with spending transaction using coinbase_spent_offset to\n+    // choose which m_coinbase_txns to spend from.\n+    void CreateSpendingTxs(int coinbase_spent_offset, std::vector<CScript>& script_pub_keys, std::vector<CMutableTransaction> &spends, const CScript& coinbase_script_pub_key);\n+\n     ~TestChain100Setup();\n \n     std::vector<CTransactionRef> m_coinbase_txns; // For convenience, coinbase transactions"
      }
    ]
  },
  {
    "sha": "cd274024b8e47e840a54e21a1c0e27c7024d3d73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDI3NDAyNGI4ZTQ3ZTg0MGE1NGUyMWExYzBlMjdjNzAyNGQzZDcz",
    "commit": {
      "author": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2019-08-16T01:37:32Z"
      },
      "committer": {
        "name": "Marcin Jachymiak",
        "email": "marcin.jachymiak1@gmail.com",
        "date": "2020-10-01T01:27:17Z"
      },
      "message": "Add searchrawtransactions RPC\n\nAdds searchrawtransactions RPC that uses the address index to lookup\ntransactions and outpoints by script and address. Adds basic functional\ntests for searchrawtransactions.",
      "tree": {
        "sha": "78c2cebf36a1ad8ab8473bfeb375e297abc23a38",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78c2cebf36a1ad8ab8473bfeb375e297abc23a38"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd274024b8e47e840a54e21a1c0e27c7024d3d73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd274024b8e47e840a54e21a1c0e27c7024d3d73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd274024b8e47e840a54e21a1c0e27c7024d3d73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd274024b8e47e840a54e21a1c0e27c7024d3d73/comments",
    "author": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "marcinja",
      "id": 12243734,
      "node_id": "MDQ6VXNlcjEyMjQzNzM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12243734?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marcinja",
      "html_url": "https://github.com/marcinja",
      "followers_url": "https://api.github.com/users/marcinja/followers",
      "following_url": "https://api.github.com/users/marcinja/following{/other_user}",
      "gists_url": "https://api.github.com/users/marcinja/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marcinja/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marcinja/subscriptions",
      "organizations_url": "https://api.github.com/users/marcinja/orgs",
      "repos_url": "https://api.github.com/users/marcinja/repos",
      "events_url": "https://api.github.com/users/marcinja/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marcinja/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0f85eb9043f899235acb7b4b75472d125b54008e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f85eb9043f899235acb7b4b75472d125b54008e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0f85eb9043f899235acb7b4b75472d125b54008e"
      }
    ],
    "stats": {
      "total": 219,
      "additions": 218,
      "deletions": 1
    },
    "files": [
      {
        "sha": "4251475845a0fc3b9a474e0e2468ba769460cc33",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd274024b8e47e840a54e21a1c0e27c7024d3d73/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd274024b8e47e840a54e21a1c0e27c7024d3d73/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=cd274024b8e47e840a54e21a1c0e27c7024d3d73",
        "patch": "@@ -150,6 +150,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"estimaterawfee\", 1, \"threshold\" },\n     { \"prioritisetransaction\", 1, \"dummy\" },\n     { \"prioritisetransaction\", 2, \"fee_delta\" },\n+    { \"searchrawtransactions\", 1, \"verbose\" },\n+    { \"searchrawtransactions\", 2, \"count\" },\n     { \"setban\", 2, \"bantime\" },\n     { \"setban\", 3, \"absolute\" },\n     { \"setnetworkactive\", 0, \"state\" },"
      },
      {
        "sha": "b4552cdca35521bc09b355a9625e57a7102bba07",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 145,
        "deletions": 0,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd274024b8e47e840a54e21a1c0e27c7024d3d73/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd274024b8e47e840a54e21a1c0e27c7024d3d73/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=cd274024b8e47e840a54e21a1c0e27c7024d3d73",
        "patch": "@@ -7,6 +7,7 @@\n #include <coins.h>\n #include <consensus/validation.h>\n #include <core_io.h>\n+#include <index/addrindex.h>\n #include <index/txindex.h>\n #include <key_io.h>\n #include <merkleblock.h>\n@@ -221,6 +222,149 @@ static RPCHelpMan getrawtransaction()\n     };\n }\n \n+static RPCHelpMan searchrawtransactions()\n+{\n+    return RPCHelpMan{\"searchrawtransactions\",\n+        \"\\nReturns raw transactions that contain outputs with the given script/address, and outpoint information for those outputs.\\n\"\n+        \"\\nRequires -addrindex to be enabled.\\n\",\n+         {\n+                {\"address\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, /* default_val */ \"\", \"address or scriptPubKey\"},\n+                {\"verbose\", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED, /* default_val */ \"false\", \"If false, return hex-encoded tx, otherwise return a json object\"},\n+                {\"count\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, /* default_val */ \"\", \"the maximum number of results to return, defaults to 100\"},\n+                {\"skip\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, /* default_val */ \"\", \"the number of initial values to skip, defaults to 0.\"},\n+         },\n+         RPCResult{\n+              RPCResult::Type::OBJ, \"\",\"\",\n+              {\n+                  {RPCResult::Type::ARR, \"\", \"\",\n+                  {\n+                    {RPCResult::Type::ARR, \"\", \"outpoint/tx pairs for spent outputs with this scriptPubKey\",\n+                    {\n+                      {RPCResult::Type::OBJ, \"spent_outpoint\", \"\",\n+                      {\n+                        {RPCResult::Type::STR, \"txid\", \"The transaction id\"},\n+                        {RPCResult::Type::STR_HEX, \"hex\", \"The serialized, hex-encoded data for 'txid'\"},\n+                      }}\n+                    }},\n+                    {RPCResult::Type::ARR, \"\", \"outpoint/tx pairs for outputs created with this scriptPubKey\",\n+                    {\n+                      {RPCResult::Type::OBJ, \"created_outpoint\", \"\",\n+                      {\n+                        {RPCResult::Type::STR, \"txid\", \"The transaction id\"},\n+                        {RPCResult::Type::STR_HEX, \"hex\", \"The serialized, hex-encoded data for 'txid'\"},\n+                      }}\n+                    }}\n+                   }}\n+              },\n+        },\n+        RPCExamples{\n+                HelpExampleCli(\"searchrawtransactions\", \"\\\"address\\\"\")\n+    + HelpExampleCli(\"searchrawtransactions\", \"\\\"address\\\" true\")\n+        },\n+    [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    CScript scriptPubKey;\n+    const CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if(IsValidDestination(dest)) {\n+        scriptPubKey = GetScriptForDestination(dest);\n+    } else if(IsHex(request.params[0].get_str())) {\n+        std::vector<unsigned char> data(ParseHex(request.params[0].get_str()));\n+        scriptPubKey = CScript(data.begin(), data.end());\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address or script\");\n+    }\n+\n+    // Accept either a bool (true) or a num (>=1) to indicate verbose output.\n+    bool verbose = false;\n+    if (!request.params[1].isNull()) {\n+        verbose = request.params[1].isNum() ? (request.params[1].get_int() != 0) : request.params[1].get_bool();\n+    }\n+\n+    int count = 100;\n+    if (request.params.size() > 2) {\n+        if (!request.params[2].isNum()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, argument 3 must be an integer\");\n+        }\n+        count = request.params[2].get_int();\n+    }\n+\n+    int skip = 0;\n+    if (request.params.size() > 3) {\n+        if (!request.params[3].isNum()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, argument 4 must be an integer\");\n+        }\n+        skip = request.params[3].get_int();\n+    }\n+\n+\n+\n+    if (!g_addr_index) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"This RPC requires -addrindex to be enabled.\");\n+    }\n+\n+    bool addrindex_ready = g_addr_index->BlockUntilSyncedToCurrentChain();\n+\n+    UniValue ret(UniValue::VOBJ);\n+\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> spends_result;\n+    std::vector<std::pair<COutPoint, std::pair<CTransactionRef, uint256>>> creations_result;\n+    if (!g_addr_index->FindTxsByScript(count, skip, scriptPubKey, spends_result, creations_result)) {\n+        if (!addrindex_ready) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY,\"Transactions with given address not found. Blockchain transactions are still in the process of being indexed\");\n+        }\n+        return ret;\n+    }\n+\n+    UniValue spends(UniValue::VARR);\n+    UniValue creations(UniValue::VARR);\n+\n+    auto spends_it = spends_result.begin();\n+    while (spends_it != spends_result.end()) {\n+        const auto& spend = *spends_it;\n+        UniValue tx_val(UniValue::VOBJ);\n+\n+        UniValue outpoint_val(UniValue::VOBJ);\n+        outpoint_val.pushKV(\"txid\", spend.second.first->GetHash().GetHex());\n+        outpoint_val.pushKV(\"n\", static_cast<int>(spend.first.n));\n+\n+        tx_val.pushKV(\"spent_outpoint\", outpoint_val);\n+        if (verbose) {\n+            TxToJSON(*(spend.second.first), spend.second.second, tx_val);\n+        } else {\n+            std::string hex_tx = EncodeHexTx(*(spend.second.first), RPCSerializationFlags());\n+            tx_val.pushKV(\"hex\", hex_tx);\n+        }\n+        spends.push_back(tx_val);\n+        ++spends_it;\n+    }\n+\n+    auto creations_it = creations_result.begin();\n+    while (creations_it != creations_result.end()) {\n+        const auto& creation = *creations_it;\n+        UniValue tx_val(UniValue::VOBJ);\n+\n+        UniValue outpoint_val(UniValue::VOBJ);\n+        outpoint_val.pushKV(\"txid\", creation.first.hash.GetHex());\n+        outpoint_val.pushKV(\"n\", static_cast<int>(creation.first.n));\n+\n+        tx_val.pushKV(\"created_outpoint\", outpoint_val);\n+        if (verbose) {\n+            TxToJSON(*(creation.second.first), creation.second.second, tx_val);\n+        } else {\n+            std::string hex_tx = EncodeHexTx(*(creation.second.first), RPCSerializationFlags());\n+            tx_val.pushKV(\"hex\", hex_tx);\n+        }\n+        creations.push_back(tx_val);\n+        ++creations_it;\n+    }\n+\n+    ret.pushKV(\"spends\", spends);\n+    ret.pushKV(\"creations\", creations);\n+    return ret;\n+},\n+  };\n+}\n+\n static RPCHelpMan gettxoutproof()\n {\n     return RPCHelpMan{\"gettxoutproof\",\n@@ -1854,6 +1998,7 @@ static const CRPCCommand commands[] =\n { //  category              name                            actor (function)            argNames\n   //  --------------------- ------------------------        -----------------------     ----------\n     { \"rawtransactions\",    \"getrawtransaction\",            &getrawtransaction,         {\"txid\",\"verbose\",\"blockhash\"} },\n+    { \"rawtransactions\",    \"searchrawtransactions\",        &searchrawtransactions,     {\"address\", \"verbose\", \"count\", \"skip\"} },\n     { \"rawtransactions\",    \"createrawtransaction\",         &createrawtransaction,      {\"inputs\",\"outputs\",\"locktime\",\"replaceable\"} },\n     { \"rawtransactions\",    \"decoderawtransaction\",         &decoderawtransaction,      {\"hexstring\",\"iswitness\"} },\n     { \"rawtransactions\",    \"decodescript\",                 &decodescript,              {\"hexstring\"} },"
      },
      {
        "sha": "3419eca337101ceb01411b9494adbd54b3e7d38d",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 71,
        "deletions": 1,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd274024b8e47e840a54e21a1c0e27c7024d3d73/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd274024b8e47e840a54e21a1c0e27c7024d3d73/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=cd274024b8e47e840a54e21a1c0e27c7024d3d73",
        "patch": "@@ -10,6 +10,7 @@\n    - sendrawtransaction\n    - decoderawtransaction\n    - getrawtransaction\n+   - searchrawtransactions\n \"\"\"\n \n from collections import OrderedDict\n@@ -49,7 +50,7 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n         self.extra_args = [\n-            [\"-txindex\"],\n+            [\"-txindex\", \"-addrindex\"],\n             [\"-txindex\"],\n             [\"-txindex\"],\n         ]\n@@ -488,6 +489,75 @@ def run_test(self):\n         assert_equal(testres['allowed'], True)\n         self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')\n \n+        self._test_searchrawtransactions()\n+\n+    def _test_searchrawtransactions(self):\n+        self.log.info('searchrawtransactions test')\n+\n+        # Create 3 new outputs with the same address.\n+        expected_txids = []\n+        addr1 = self.nodes[1].getnewaddress()\n+        expected_txids.append(self.nodes[0].sendtoaddress(addr1, 0.1))\n+        expected_txids.append(self.nodes[0].sendtoaddress(addr1, 0.1))\n+        expected_txids.append(self.nodes[0].sendtoaddress(addr1, 0.1))\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        res = self.nodes[0].searchrawtransactions(addr1, True)\n+        spends_results, creations_results = res[\"spends\"], res[\"creations\"]\n+\n+        assert_equal(len(spends_results), 0)\n+        assert_equal(len(creations_results), 3)\n+\n+        for c in creations_results:\n+            # Since this output was created in the tx, its outpoint should have the same txid.\n+            outpoint_txid = c['created_outpoint']['txid']\n+            txid = c['txid']\n+            assert_equal(outpoint_txid, txid)\n+            assert(txid in expected_txids)\n+\n+        # Check that equivalent result is produced without verbose option set.\n+        res = self.nodes[0].searchrawtransactions(addr1)\n+        spends_results, creations_results = res[\"spends\"], res[\"creations\"]\n+\n+        assert_equal(len(spends_results), 0)\n+        assert_equal(len(creations_results), 3)\n+        for c in creations_results:\n+            # Since this output was created in the tx, its outpoint should have the same txid.\n+            outpoint_txid = c['created_outpoint']['txid']\n+            assert(outpoint_txid in expected_txids)\n+\n+        # Set the count to 1 and check that only 1 result is returned.\n+        res = self.nodes[0].searchrawtransactions(addr1, False, 1)\n+        spends_results, creations_results = res[\"spends\"], res[\"creations\"]\n+        assert_equal(len(spends_results), 0)\n+        assert_equal(len(creations_results), 1)\n+\n+        # Set the skip to 2 and check that only 1 result is returned.\n+        res = self.nodes[0].searchrawtransactions(addr1, False, 100, 2)\n+        spends_results, creations_results = res[\"spends\"], res[\"creations\"]\n+        assert_equal(len(spends_results), 0)\n+        assert_equal(len(creations_results), 1)\n+\n+        # Send the most of balance to addr2 and then to addr3.\n+        addr2 = self.nodes[1].getnewaddress()\n+        balance = self.nodes[1].getbalance()\n+        self.nodes[1].sendtoaddress(address=addr2, amount=balance, subtractfeefromamount=True)\n+\n+        addr3 = self.nodes[1].getnewaddress()\n+        balance = self.nodes[1].getbalance()\n+        expected_send_txid = self.nodes[1].sendtoaddress(address=addr3, amount=balance, subtractfeefromamount=True)\n+\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+\n+        # Check that the spent output was found by the address index.\n+        res = self.nodes[0].searchrawtransactions(addr2, True)\n+        spends_results, creations_results = res[\"spends\"], res[\"creations\"]\n+        assert_equal(len(spends_results), 1)\n+        assert_equal(len(creations_results), 1)\n+        assert_equal(expected_send_txid, spends_results[0]['spent_outpoint']['txid'])\n \n if __name__ == '__main__':\n     RawTransactionsTest().main()"
      }
    ]
  }
]