[
  {
    "sha": "7b49f22bdbdecca600c4744d020b3553fe427e61",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YjQ5ZjIyYmRiZGVjY2E2MDBjNDc0NGQwMjBiMzU1M2ZlNDI3ZTYx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-12-12T19:08:47Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-12-12T19:08:47Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 7a49cac..8225239\n\n8225239 Merge #433: Make the libcrypto detection fail the newer API.\n12de863 Make the libcrypto detection fail the newer API.\n2928420 Merge #427: Remove Schnorr from travis as well\n8eecc4a Remove Schnorr from travis as well\na8abae7 Merge #310: Add exhaustive test for group functions on a low-order subgroup\nb4ceedf Add exhaustive test for verification\n83836a9 Add exhaustive tests for group arithmetic, signing, and ecmult on a small group\n20b8877 Add exhaustive test for group functions on a low-order subgroup\n80773a6 Merge #425: Remove Schnorr experiment\ne06e878 Remove Schnorr experiment\n04c8ef3 Merge #407: Modify parameter order of internal functions to match API parameter order\n6e06696 Merge #411: Remove guarantees about memcmp-ability\n40c8d7e Merge #421: Update scalar_4x64_impl.h\na922365 Merge #422: Restructure nonce clearing\n3769783 Restructure nonce clearing\n0f9e69d Restructure nonce clearing\n9d67afa Update scalar_4x64_impl.h\n7d15cd7 Merge #413: fix auto-enabled static precompuatation\n00c5d2e fix auto-enabled static precompuatation\n91219a1 Remove guarantees about memcmp-ability\n353c1bf Fix secp256k1_ge_set_table_gej_var parameter order\n541b783 Fix secp256k1_ge_set_all_gej_var parameter order\n7d893f4 Fix secp256k1_fe_inv_all_var parameter order\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 8225239f490f79842a5a3b82ad6cc8aa11d5208e",
      "tree": {
        "sha": "8a1dfe59fe37e649e6c687386318cf6f2194f199",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a1dfe59fe37e649e6c687386318cf6f2194f199"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7b49f22bdbdecca600c4744d020b3553fe427e61",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b49f22bdbdecca600c4744d020b3553fe427e61",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7b49f22bdbdecca600c4744d020b3553fe427e61",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b49f22bdbdecca600c4744d020b3553fe427e61/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b2135359b3ad37cf2ac09b008079ddb237eff2c9"
      }
    ],
    "stats": {
      "total": 1613,
      "additions": 676,
      "deletions": 937
    },
    "files": [
      {
        "sha": "87fea161ba5aea04756cb378d487b703bb2e2ab2",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -6,6 +6,7 @@ bench_schnorr_verify\n bench_recover\n bench_internal\n tests\n+exhaustive_tests\n gen_context\n *.exe\n *.so"
      },
      {
        "sha": "24395292426d697856f34b0b0d6c8f26d81d6856",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -11,7 +11,7 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no  EXPERIMENTAL=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n@@ -22,15 +22,14 @@ env:\n     - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes EXPERIMENTAL=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes EXPERIMENTAL=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n-    - BUILD=check-java ECDH=yes SCHNORR=yes EXPERIMENTAL=yes\n+    - BUILD=check-java ECDH=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -66,5 +65,5 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "e5657f7f31307852c4dc90750cabea1e2bf1947f",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -12,9 +12,11 @@ noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n noinst_HEADERS += src/scalar_8x32.h\n+noinst_HEADERS += src/scalar_low.h\n noinst_HEADERS += src/scalar_impl.h\n noinst_HEADERS += src/scalar_4x64_impl.h\n noinst_HEADERS += src/scalar_8x32_impl.h\n+noinst_HEADERS += src/scalar_low_impl.h\n noinst_HEADERS += src/group.h\n noinst_HEADERS += src/group_impl.h\n noinst_HEADERS += src/num_gmp.h\n@@ -87,13 +89,23 @@ bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n+TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n-TESTS = tests\n+TESTS += tests\n+endif\n+\n+if USE_EXHAUSTIVE_TESTS\n+noinst_PROGRAMS += exhaustive_tests\n+exhaustive_tests_SOURCES = src/tests_exhaustive.c\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_LDADD = $(SECP_LIBS)\n+exhaustive_tests_LDFLAGS = -static\n+TESTS += exhaustive_tests\n endif\n \n JAVAROOT=src/java\n@@ -154,10 +166,6 @@ if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n endif\n \n-if ENABLE_MODULE_SCHNORR\n-include src/modules/schnorr/Makefile.am.include\n-endif\n-\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif"
      },
      {
        "sha": "b74acb8c138823c67e7fd0a11d059a90bd2551a9",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -46,6 +46,10 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     ECDSA_sign(0, NULL, 0, NULL, NULL, eckey);\n     ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n     EC_KEY_free(eckey);\n+    ECDSA_SIG *sig_openssl;\n+    sig_openssl = ECDSA_SIG_new();\n+    (void)sig_openssl->r;\n+    ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])\n fi"
      },
      {
        "sha": "ec50ffe3a251b653cdcd9eb88b887e6374934c0e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 9,
        "deletions": 21,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -104,6 +104,11 @@ AC_ARG_ENABLE(experimental,\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n+AC_ARG_ENABLE(exhaustive_tests,\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    [use_exhaustive_tests=$enableval],\n+    [use_exhaustive_tests=yes])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n@@ -119,11 +124,6 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n-AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (experimental)]),\n-    [enable_module_schnorr=$enableval],\n-    [enable_module_schnorr=no])\n-\n AC_ARG_ENABLE(module_recovery,\n     AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n     [enable_module_recovery=$enableval],\n@@ -381,9 +381,6 @@ fi\n if test x\"$use_jni\" != x\"no\"; then\n   AX_JNI_INCLUDE_DIR\n   have_jni_dependencies=yes\n-  if test x\"$enable_module_schnorr\" = x\"no\"; then\n-    have_jni_dependencies=no\n-  fi\n   if test x\"$enable_module_ecdh\" = x\"no\"; then\n     have_jni_dependencies=no\n   fi\n@@ -392,7 +389,7 @@ if test x\"$use_jni\" != x\"no\"; then\n   fi\n   if test \"x$have_jni_dependencies\" = \"xno\"; then\n     if test x\"$use_jni\" = x\"yes\"; then\n-      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and Schnorr and try again.])\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and try again.])\n     fi\n     AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n     use_jni=no\n@@ -413,18 +410,14 @@ if test x\"$use_endomorphism\" = x\"yes\"; then\n   AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism optimization])\n fi\n \n-if test x\"$use_ecmult_static_precomputation\" = x\"yes\"; then\n+if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n \n if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n \n-if test x\"$enable_module_schnorr\" = x\"yes\"; then\n-  AC_DEFINE(ENABLE_MODULE_SCHNORR, 1, [Define this symbol to enable the Schnorr signature module])\n-fi\n-\n if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n@@ -442,7 +435,6 @@ AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n AC_MSG_NOTICE([Using jni: $use_jni])\n \n@@ -451,12 +443,8 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([WARNING: experimental build])\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-  AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n   AC_MSG_NOTICE([******])\n else\n-  if test x\"$enable_module_schnorr\" = x\"yes\"; then\n-    AC_MSG_ERROR([Schnorr signature module is experimental. Use --enable-experimental to allow.])\n-  fi\n   if test x\"$enable_module_ecdh\" = x\"yes\"; then\n     AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -473,10 +461,10 @@ AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n-AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_precomputation\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n-AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])"
      },
      {
        "sha": "f268e309d0bf5d0db21bc61224bb798aba14dbf0",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -47,11 +47,8 @@ typedef struct secp256k1_context_struct secp256k1_context;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n- *\n- *  Furthermore, it is guaranteed that identical public keys (ignoring\n- *  compression) will have identical representation, so they can be memcmp'ed.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -62,12 +59,9 @@ typedef struct {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  the secp256k1_ecdsa_signature_serialize_* and\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the secp256k1_ecdsa_signature_serialize_* and\n  *  secp256k1_ecdsa_signature_serialize_* functions.\n- *\n- *  Furthermore, it is guaranteed to identical signatures will have identical\n- *  representation, so they can be memcmp'ed.\n  */\n typedef struct {\n     unsigned char data[64];"
      },
      {
        "sha": "dc32fec1eac0380e687399c0cf66e0c44cb2e1a3",
        "filename": "include/secp256k1_schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 173,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/include/secp256k1_schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/include/secp256k1_schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorr.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,173 +0,0 @@\n-#ifndef _SECP256K1_SCHNORR_\n-# define _SECP256K1_SCHNORR_\n-\n-# include \"secp256k1.h\"\n-\n-# ifdef __cplusplus\n-extern \"C\" {\n-# endif\n-\n-/** Create a signature using a custom EC-Schnorr-SHA256 construction. It\n- *  produces non-malleable 64-byte signatures which support public key recovery\n- *  batch validation, and multiparty signing.\n- *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was\n- *              invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing\n- *                   (cannot be NULL)\n- *  Out:     sig64:  pointer to a 64-byte array where the signature will be\n- *                   placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL,\n- *                   secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation\n- *                   function (can be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *seckey,\n-  secp256k1_nonce_function noncefp,\n-  const void *ndata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Verify a signature created by secp256k1_schnorr_sign.\n- *  Returns: 1: correct signature\n- *           0: incorrect signature\n- *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig64:     the 64-byte signature being verified (cannot be NULL)\n- *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n- *           pubkey:    the public key to verify with (cannot be NULL)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_verify(\n-  const secp256k1_context* ctx,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const secp256k1_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Recover an EC public key from a Schnorr signature created using\n- *  secp256k1_schnorr_sign.\n- *  Returns: 1: public key successfully recovered (which guarantees a correct\n- *           signature).\n- *           0: otherwise.\n- *  Args:    ctx:        pointer to a context object, initialized for\n- *                       verification (cannot be NULL)\n- *  Out:     pubkey:     pointer to a pubkey to set to the recovered public key\n- *                       (cannot be NULL).\n- *  In:      sig64:      signature as 64 byte array (cannot be NULL)\n- *           msg32:      the 32-byte message hash assumed to be signed (cannot\n- *                       be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_recover(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubkey,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Generate a nonce pair deterministically for use with\n- *  secp256k1_schnorr_partial_sign.\n- *  Returns: 1: valid nonce pair was generated.\n- *           0: otherwise (nonce generation function failed)\n- *  Args:    ctx:         pointer to a context object, initialized for signing\n- *                        (cannot be NULL)\n- *  Out:     pubnonce:    public side of the nonce (cannot be NULL)\n- *           privnonce32: private side of the nonce (32 byte) (cannot be NULL)\n- *  In:      msg32:       the 32-byte message hash assumed to be signed (cannot\n- *                        be NULL)\n- *           sec32:       the 32-byte private key (cannot be NULL)\n- *           noncefp:     pointer to a nonce generation function. If NULL,\n- *                        secp256k1_nonce_function_default is used\n- *           noncedata:   pointer to arbitrary data used by the nonce generation\n- *                        function (can be NULL)\n- *\n- *  Do not use the output as a private/public key pair for signing/validation.\n- */\n-SECP256K1_API int secp256k1_schnorr_generate_nonce_pair(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubnonce,\n-  unsigned char *privnonce32,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  secp256k1_nonce_function noncefp,\n-  const void* noncedata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-/** Produce a partial Schnorr signature, which can be combined using\n- *  secp256k1_schnorr_partial_combine, to end up with a full signature that is\n- *  verifiable using secp256k1_schnorr_verify.\n- *  Returns: 1: signature created successfully.\n- *           0: no valid signature exists with this combination of keys, nonces\n- *              and message (chance around 1 in 2^128)\n- *          -1: invalid private key, nonce, or public nonces.\n- *  Args: ctx:             pointer to context object, initialized for signing (cannot\n- *                         be NULL)\n- *  Out:  sig64:           pointer to 64-byte array to put partial signature in\n- *  In:   msg32:           pointer to 32-byte message to sign\n- *        sec32:           pointer to 32-byte private key\n- *        pubnonce_others: pointer to pubkey containing the sum of the other's\n- *                         nonces (see secp256k1_ec_pubkey_combine)\n- *        secnonce32:      pointer to 32-byte array containing our nonce\n- *\n- * The intended procedure for creating a multiparty signature is:\n- * - Each signer S[i] with private key x[i] and public key Q[i] runs\n- *   secp256k1_schnorr_generate_nonce_pair to produce a pair (k[i],R[i]) of\n- *   private/public nonces.\n- * - All signers communicate their public nonces to each other (revealing your\n- *   private nonce can lead to discovery of your private key, so it should be\n- *   considered secret).\n- * - All signers combine all the public nonces they received (excluding their\n- *   own) using secp256k1_ec_pubkey_combine to obtain an\n- *   Rall[i] = sum(R[0..i-1,i+1..n]).\n- * - All signers produce a partial signature using\n- *   secp256k1_schnorr_partial_sign, passing in their own private key x[i],\n- *   their own private nonce k[i], and the sum of the others' public nonces\n- *   Rall[i].\n- * - All signers communicate their partial signatures to each other.\n- * - Someone combines all partial signatures using\n- *   secp256k1_schnorr_partial_combine, to obtain a full signature.\n- * - The resulting signature is validatable using secp256k1_schnorr_verify, with\n- *   public key equal to the result of secp256k1_ec_pubkey_combine of the\n- *   signers' public keys (sum(Q[0..n])).\n- *\n- *  Note that secp256k1_schnorr_partial_combine and secp256k1_ec_pubkey_combine\n- *  function take their arguments in any order, and it is possible to\n- *  pre-combine several inputs already with one call, and add more inputs later\n- *  by calling the function again (they are commutative and associative).\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  const secp256k1_pubkey *pubnonce_others,\n-  const unsigned char *secnonce32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n-\n-/** Combine multiple Schnorr partial signatures.\n- * Returns: 1: the passed signatures were successfully combined.\n- *          0: the resulting signature is not valid (chance of 1 in 2^256)\n- *         -1: some inputs were invalid, or the signatures were not created\n- *             using the same set of nonces\n- * Args:   ctx:      pointer to a context object\n- * Out:    sig64:    pointer to a 64-byte array to place the combined signature\n- *                   (cannot be NULL)\n- * In:     sig64sin: pointer to an array of n pointers to 64-byte input\n- *                   signatures\n- *         n:        the number of signatures to combine (at least 1)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_combine(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char * const * sig64sin,\n-  size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-# ifdef __cplusplus\n-}\n-# endif\n-\n-#endif"
      },
      {
        "sha": "9a42e519bd580c6f505d66deec88bbed6dabecf8",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -203,7 +203,9 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n+#if !defined(EXHAUSTIVE_TEST_ORDER)\n     secp256k1_fe xr;\n+#endif\n     secp256k1_gej pubkeyj;\n     secp256k1_gej pr;\n \n@@ -219,6 +221,21 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }\n+\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+{\n+    secp256k1_scalar computed_r;\n+    int overflow = 0;\n+    secp256k1_ge pr_ge;\n+    secp256k1_ge_set_gej(&pr_ge, &pr);\n+    secp256k1_fe_normalize(&pr_ge.x);\n+\n+    secp256k1_fe_get_b32(c, &pr_ge.x);\n+    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n+    /* we fully expect overflow */\n+    return secp256k1_scalar_eq(sigr, &computed_r);\n+}\n+#else\n     secp256k1_scalar_get_b32(c, sigr);\n     secp256k1_fe_set_b32(&xr, c);\n \n@@ -252,6 +269,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n         return 1;\n     }\n     return 0;\n+#endif\n }\n \n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid) {"
      },
      {
        "sha": "0db314c48e0cdc844a89cb4a6d5b4ce4c9352578",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -78,7 +78,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ (s.d[0] & 1);\n+    bit = flip ^ !secp256k1_scalar_is_even(&s);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n     secp256k1_scalar_negate(&neg_s, &s);\n     not_neg_one = !secp256k1_scalar_is_one(&neg_s);"
      },
      {
        "sha": "35f25460773f3ab1819beb6a1633ef264c83408d",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -77,7 +77,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(1024, prec, precj, cb);\n+        secp256k1_ge_set_all_gej_var(prec, precj, 1024, cb);\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {"
      },
      {
        "sha": "4e40104ad43ceb12845b79994c5bd5d28f3b31a0",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -7,15 +7,29 @@\n #ifndef _SECP256K1_ECMULT_IMPL_H_\n #define _SECP256K1_ECMULT_IMPL_H_\n \n+#include <string.h>\n+\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n-#include <string.h>\n-\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need to lower these values for exhaustive tests because\n+ * the tables cannot have infinities in them (this breaks the\n+ * affine-isomorphism stuff which tracks z-ratios) */\n+#  if EXHAUSTIVE_TEST_ORDER > 128\n+#    define WINDOW_A 5\n+#    define WINDOW_G 8\n+#  elif EXHAUSTIVE_TEST_ORDER > 8\n+#    define WINDOW_A 4\n+#    define WINDOW_G 4\n+#  else\n+#    define WINDOW_A 2\n+#    define WINDOW_G 2\n+#  endif\n+#else\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n-\n /** larger numbers may result in slightly better performance, at the cost of\n     exponentially larger precomputed tables. */\n #ifdef USE_ENDOMORPHISM\n@@ -25,6 +39,7 @@\n /** One table for window size 16: 1.375 MiB. */\n #define WINDOW_G 16\n #endif\n+#endif\n \n /** The number of entries a table with precomputed multiples needs to have. */\n #define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n@@ -103,7 +118,7 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n     /* Compute the odd multiples in Jacobian form. */\n     secp256k1_ecmult_odd_multiples_table(n, prej, zr, a);\n     /* Convert them in batch to affine coordinates. */\n-    secp256k1_ge_set_table_gej_var(n, prea, prej, zr);\n+    secp256k1_ge_set_table_gej_var(prea, prej, zr, n);\n     /* Convert them to compact storage form. */\n     for (i = 0; i < n; i++) {\n         secp256k1_ge_to_storage(&pre[i], &prea[i]);"
      },
      {
        "sha": "bbb1ee866cc427108f03a4f94fc1da27981c29fa",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -30,6 +30,8 @@\n #error \"Please select field implementation\"\n #endif\n \n+#include \"util.h\"\n+\n /** Normalize a field element. */\n static void secp256k1_fe_normalize(secp256k1_fe *r);\n \n@@ -50,6 +52,9 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r);\n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n \n+/** Sets a field element equal to zero, initializing all fields. */\n+static void secp256k1_fe_clear(secp256k1_fe *a);\n+\n /** Verify whether a field element is zero. Requires the input to be normalized. */\n static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n \n@@ -110,7 +115,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a);\n /** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n  *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n  *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a);\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len);\n \n /** Convert a field element to the storage type. */\n static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a);"
      },
      {
        "sha": "5127b279bc7f56b621042d9f79bfc200dd7086c7",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -260,7 +260,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a) {\n #endif\n }\n \n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a) {\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len) {\n     secp256k1_fe u;\n     size_t i;\n     if (len < 1) {"
      },
      {
        "sha": "4957b248fe6a608b8ae825b9b200b263415f36c4",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -65,12 +65,12 @@ static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb);\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb);\n \n /** Set a batch of group elements equal to the inputs given in jacobian\n  *  coordinates (with known z-ratios). zr must contain the known z-ratios such\n  *  that mul(a[i].z, zr[i+1]) == a[i+1].z. zr[0] is ignored. */\n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr);\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len);\n \n /** Bring a batch inputs given in jacobian coordinates (with known z-ratios) to\n  *  the same global z \"denominator\". zr must contain the known z-ratios such"
      },
      {
        "sha": "2e192b62fd2ce7fa83f0b3d1876c0fbc6876f60e",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 67,
        "deletions": 11,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -11,6 +11,53 @@\n #include \"field.h\"\n #include \"group.h\"\n \n+/* These points can be generated in sage as follows:\n+ *\n+ * 0. Setup a worksheet with the following parameters.\n+ *   b = 4  # whatever CURVE_B will be set to\n+ *   F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)\n+ *   C = EllipticCurve ([F (0), F (b)])\n+ *\n+ * 1. Determine all the small orders available to you. (If there are\n+ *    no satisfactory ones, go back and change b.)\n+ *   print C.order().factor(limit=1000)\n+ *\n+ * 2. Choose an order as one of the prime factors listed in the above step.\n+ *    (You can also multiply some to get a composite order, though the\n+ *    tests will crash trying to invert scalars during signing.) We take a\n+ *    random point and scale it to drop its order to the desired value.\n+ *    There is some probability this won't work; just try again.\n+ *   order = 199\n+ *   P = C.random_point()\n+ *   P = (int(P.order()) / int(order)) * P\n+ *   assert(P.order() == order)\n+ *\n+ * 3. Print the values. You'll need to use a vim macro or something to\n+ *    split the hex output into 4-byte chunks.\n+ *   print \"%x %x\" % P.xy()\n+ */\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n+    0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n+    0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n+    0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n+);\n+\n+const int CURVE_B = 4;\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n+    0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n+    0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n+    0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n+);\n+const int CURVE_B = 2;\n+#  else\n+#    error No known generator for the specified exhaustive test group order.\n+#  endif\n+#else\n /** Generator for secp256k1, value 'g' defined in\n  *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n  */\n@@ -21,8 +68,11 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n+const int CURVE_B = 7;\n+#endif\n+\n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n-    secp256k1_fe zi2; \n+    secp256k1_fe zi2;\n     secp256k1_fe zi3;\n     secp256k1_fe_sqr(&zi2, zi);\n     secp256k1_fe_mul(&zi3, &zi2, zi);\n@@ -76,7 +126,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     r->y = a->y;\n }\n \n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb) {\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb) {\n     secp256k1_fe *az;\n     secp256k1_fe *azi;\n     size_t i;\n@@ -89,7 +139,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     }\n \n     azi = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * count);\n-    secp256k1_fe_inv_all_var(count, azi, az);\n+    secp256k1_fe_inv_all_var(azi, az, count);\n     free(az);\n \n     count = 0;\n@@ -102,7 +152,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     free(azi);\n }\n \n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr) {\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len) {\n     size_t i = len - 1;\n     secp256k1_fe zi;\n \n@@ -145,9 +195,15 @@ static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp\n \n static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     r->infinity = 1;\n-    secp256k1_fe_set_int(&r->x, 0);\n-    secp256k1_fe_set_int(&r->y, 0);\n-    secp256k1_fe_set_int(&r->z, 0);\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+    secp256k1_fe_clear(&r->z);\n+}\n+\n+static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n+    r->infinity = 1;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n }\n \n static void secp256k1_gej_clear(secp256k1_gej *r) {\n@@ -169,7 +225,7 @@ static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&c, &x3);\n     return secp256k1_fe_sqrt(&r->y, &c);\n }\n@@ -228,7 +284,7 @@ static int secp256k1_gej_is_valid_var(const secp256k1_gej *a) {\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n     secp256k1_fe_sqr(&z2, &a->z);\n     secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n-    secp256k1_fe_mul_int(&z6, 7);\n+    secp256k1_fe_mul_int(&z6, CURVE_B);\n     secp256k1_fe_add(&x3, &z6);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n@@ -242,7 +298,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&x3, &c);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n@@ -260,7 +316,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n-     *  \n+     *\n      *  Having said this, if this function receives a point on a sextic twist, e.g. by\n      *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n      *  since -6 does have a cube root mod p. For this point, this function will not set"
      },
      {
        "sha": "1c67802fba82e60498c560473e9966c161939ffb",
        "filename": "src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 1,
        "deletions": 33,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1.java?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -32,7 +32,7 @@\n  * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n  *\n  * <p>To build secp256k1 for use with bitcoinj, run\n- * `./configure --enable-jni --enable-experimental --enable-module-schnorr --enable-module-ecdh`\n+ * `./configure --enable-jni --enable-experimental --enable-module-ecdh`\n  * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n  * or point the JVM to the folder containing it with -Djava.library.path\n  * </p>\n@@ -417,36 +417,6 @@ public static synchronized boolean randomize(byte[] seed) throws AssertFailExcep\n         }\n     }\n \n-    public static byte[] schnorrSign(byte[] data, byte[] sec) throws AssertFailException {\n-        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(data);\n-        byteBuff.put(sec);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_schnorr_sign(byteBuff, Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] sigArr = retByteArray[0];\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-\n-        assertEquals(sigArr.length, 64, \"Got bad signature length.\");\n-\n-        return retVal == 0 ? new byte[0] : sigArr;\n-    }\n-\n     private static native long secp256k1_ctx_clone(long context);\n \n     private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n@@ -471,8 +441,6 @@ public static synchronized boolean randomize(byte[] seed) throws AssertFailExcep\n \n     private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n \n-    private static native byte[][] secp256k1_schnorr_sign(ByteBuffer byteBuff, long context);\n-\n     private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n \n }"
      },
      {
        "sha": "c00d08899b9b004af75a4e98569c460ad83395a1",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -167,22 +167,6 @@ public static void testRandomize() throws AssertFailException {\n         assertEquals( result, true, \"testRandomize\");\n     }\n \n-    /**\n-      * This tests signSchnorr() for a valid secretkey\n-      */\n-    public static void testSchnorrSign() throws AssertFailException{\n-\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.schnorrSign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString, \"C5E929AA058B982048760422D3B563749B7D0E50C5EBD8CD2FFC23214BD6A2F1B072C13880997EBA847CF20F2F90FCE07C1CA33A890A4127095A351127F8D95F\" , \"testSchnorrSign\");\n-    }\n-\n-    /**\n-      * This tests signSchnorr() for a valid secretkey\n-      */\n     public static void testCreateECDHSecret() throws AssertFailException{\n \n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n@@ -216,11 +200,6 @@ public static void main(String[] args) throws AssertFailException{\n         testSignPos();\n         testSignNeg();\n \n-        //Test Schnorr (partial support) //TODO\n-        testSchnorrSign();\n-        //testSchnorrVerify\n-        //testSchnorrRecovery\n-\n         //Test privKeyTweakAdd() 1\n         testPrivKeyTweakAdd_1();\n "
      },
      {
        "sha": "bcef7b32ce3e7fe1587f15dac2e7c56fef998a8a",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 0,
        "deletions": 34,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -5,7 +5,6 @@\n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_ecdh.h\"\n #include \"include/secp256k1_recovery.h\"\n-#include \"include/secp256k1_schnorr.h\"\n \n \n SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n@@ -333,39 +332,6 @@ SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1p\n   return 0;\n }\n \n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  unsigned char* secKey = (unsigned char*) (data + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray sigArray, intsByteArray;\n-  unsigned char intsarray[1];\n-  unsigned char sig[64];\n-\n-  int ret = secp256k1_schnorr_sign(ctx, sig, data, secKey, NULL, NULL);\n-\n-  intsarray[0] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  sigArray = (*env)->NewByteArray(env, 64);\n-  (*env)->SetByteArrayRegion(env, sigArray, 0, 64, (jbyte*)sig);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 1);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n   (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n {"
      },
      {
        "sha": "fe613c9e9e77eddb18e0b0d8422948678f3408a8",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -104,14 +104,6 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n   (JNIEnv *, jclass, jobject, jlong, jint);\n \n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_schnorr_sign\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l);\n-\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdh"
      },
      {
        "sha": "86f2f0cb2b5334baf4fd34e58abe6f8fc4733e32",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -138,23 +138,23 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);"
      },
      {
        "sha": "f1af8e83255fd0c1e0bd7d051dcaed609bae1447",
        "filename": "src/modules/schnorr/Makefile.am.include",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/Makefile.am.include?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,10 +0,0 @@\n-include_HEADERS += include/secp256k1_schnorr.h\n-noinst_HEADERS += src/modules/schnorr/main_impl.h\n-noinst_HEADERS += src/modules/schnorr/schnorr.h\n-noinst_HEADERS += src/modules/schnorr/schnorr_impl.h\n-noinst_HEADERS += src/modules/schnorr/tests_impl.h\n-if USE_BENCHMARK\n-noinst_PROGRAMS += bench_schnorr_verify\n-bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n-endif"
      },
      {
        "sha": "fa176a1767f5f8388a4960f4eaecabbeb56a4d4a",
        "filename": "src/modules/schnorr/main_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 164,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/main_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,164 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_MAIN\n-#define SECP256K1_MODULE_SCHNORR_MAIN\n-\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"modules/schnorr/schnorr_impl.h\"\n-\n-static void secp256k1_schnorr_msghash_sha256(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    secp256k1_sha256_t sha;\n-    secp256k1_sha256_initialize(&sha);\n-    secp256k1_sha256_write(&sha, r32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, h32);\n-}\n-\n-static const unsigned char secp256k1_schnorr_algo16[17] = \"Schnorr+SHA256  \";\n-\n-int secp256k1_schnorr_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    secp256k1_scalar sec, non;\n-    int ret = 0;\n-    int overflow = 0;\n-    unsigned int count = 0;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(seckey != NULL);\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n-    while (1) {\n-        unsigned char nonce32[32];\n-        ret = noncefp(nonce32, msg32, seckey, secp256k1_schnorr_algo16, (void*)noncedata, count);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-        memset(nonce32, 0, 32);\n-        if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, NULL, secp256k1_schnorr_msghash_sha256, msg32)) {\n-                break;\n-            }\n-        }\n-        count++;\n-    }\n-    if (!ret) {\n-        memset(sig64, 0, 64);\n-    }\n-    secp256k1_scalar_clear(&non);\n-    secp256k1_scalar_clear(&sec);\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_pubkey *pubkey) {\n-    secp256k1_ge q;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    secp256k1_pubkey_load(ctx, &q, pubkey);\n-    return secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *sig64, const unsigned char *msg32) {\n-    secp256k1_ge q;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32)) {\n-        secp256k1_pubkey_save(pubkey, &q);\n-        return 1;\n-    } else {\n-        memset(pubkey, 0, sizeof(*pubkey));\n-        return 0;\n-    }\n-}\n-\n-int secp256k1_schnorr_generate_nonce_pair(const secp256k1_context* ctx, secp256k1_pubkey *pubnonce, unsigned char *privnonce32, const unsigned char *sec32, const unsigned char *msg32, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    int count = 0;\n-    int ret = 1;\n-    secp256k1_gej Qj;\n-    secp256k1_ge Q;\n-    secp256k1_scalar sec;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(pubnonce != NULL);\n-    ARG_CHECK(privnonce32 != NULL);\n-\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    do {\n-        int overflow;\n-        ret = noncefp(privnonce32, sec32, msg32, secp256k1_schnorr_algo16, (void*)noncedata, count++);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&sec, privnonce32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-            continue;\n-        }\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &Qj, &sec);\n-        secp256k1_ge_set_gej(&Q, &Qj);\n-\n-        secp256k1_pubkey_save(pubnonce, &Q);\n-        break;\n-    } while(1);\n-\n-    secp256k1_scalar_clear(&sec);\n-    if (!ret) {\n-        memset(pubnonce, 0, sizeof(*pubnonce));\n-    }\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_partial_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *sec32, const secp256k1_pubkey *pubnonce_others, const unsigned char *secnonce32) {\n-    int overflow = 0;\n-    secp256k1_scalar sec, non;\n-    secp256k1_ge pubnon;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(secnonce32 != NULL);\n-    ARG_CHECK(pubnonce_others != NULL);\n-\n-    secp256k1_scalar_set_b32(&sec, sec32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-        return -1;\n-    }\n-    secp256k1_scalar_set_b32(&non, secnonce32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&non)) {\n-        return -1;\n-    }\n-    secp256k1_pubkey_load(ctx, &pubnon, pubnonce_others);\n-    return secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, &pubnon, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_partial_combine(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char * const *sig64sin, size_t n) {\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(n >= 1);\n-    ARG_CHECK(sig64sin != NULL);\n-    return secp256k1_schnorr_sig_combine(sig64, n, sig64sin);\n-}\n-\n-#endif"
      },
      {
        "sha": "de18147bd52ac0f70369114dfcb06947730cbaac",
        "filename": "src/modules/schnorr/schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/schnorr.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,20 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_MODULE_SCHNORR_H_\n-#define _SECP256K1_MODULE_SCHNORR_H_\n-\n-#include \"scalar.h\"\n-#include \"group.h\"\n-\n-typedef void (*secp256k1_schnorr_msghash)(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32);\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins);\n-\n-#endif"
      },
      {
        "sha": "e13ab6db7cca1173582c47597d42fb916f43fc22",
        "filename": "src/modules/schnorr/schnorr_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 207,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/schnorr_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/schnorr_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/schnorr_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,207 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_SCHNORR_IMPL_H_\n-#define _SECP256K1_SCHNORR_IMPL_H_\n-\n-#include <string.h>\n-\n-#include \"schnorr.h\"\n-#include \"num.h\"\n-#include \"field.h\"\n-#include \"group.h\"\n-#include \"ecmult.h\"\n-#include \"ecmult_gen.h\"\n-\n-/**\n- * Custom Schnorr-based signature scheme. They support multiparty signing, public key\n- * recovery and batch validation.\n- *\n- * Rationale for verifying R's y coordinate:\n- * In order to support batch validation and public key recovery, the full R point must\n- * be known to verifiers, rather than just its x coordinate. In order to not risk\n- * being more strict in batch validation than normal validation, validators must be\n- * required to reject signatures with incorrect y coordinate. This is only possible\n- * by including a (relatively slow) field inverse, or a field square root. However,\n- * batch validation offers potentially much higher benefits than this cost.\n- *\n- * Rationale for having an implicit y coordinate oddness:\n- * If we commit to having the full R point known to verifiers, there are two mechanism.\n- * Either include its oddness in the signature, or give it an implicit fixed value.\n- * As the R y coordinate can be flipped by a simple negation of the nonce, we choose the\n- * latter, as it comes with nearly zero impact on signing or validation performance, and\n- * saves a byte in the signature.\n- *\n- * Signing:\n- *   Inputs: 32-byte message m, 32-byte scalar key x (!=0), 32-byte scalar nonce k (!=0)\n- *\n- *   Compute point R = k * G. Reject nonce if R's y coordinate is odd (or negate nonce).\n- *   Compute 32-byte r, the serialization of R's x coordinate.\n- *   Compute scalar h = Hash(r || m). Reject nonce if h == 0 or h >= order.\n- *   Compute scalar s = k - h * x.\n- *   The signature is (r, s).\n- *\n- *\n- * Verification:\n- *   Inputs: 32-byte message m, public key point Q, signature: (32-byte r, scalar s)\n- *\n- *   Signature is invalid if s >= order.\n- *   Signature is invalid if r >= p.\n- *   Compute scalar h = Hash(r || m). Signature is invalid if h == 0 or h >= order.\n- *   Option 1 (faster for single verification):\n- *     Compute point R = h * Q + s * G. Signature is invalid if R is infinity or R's y coordinate is odd.\n- *     Signature is valid if the serialization of R's x coordinate equals r.\n- *   Option 2 (allows batch validation and pubkey recovery):\n- *     Decompress x coordinate r into point R, with odd y coordinate. Fail if R is not on the curve.\n- *     Signature is valid if R + h * Q + s * G == 0.\n- */\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Rj;\n-    secp256k1_ge Ra;\n-    unsigned char h32[32];\n-    secp256k1_scalar h, s;\n-    int overflow;\n-    secp256k1_scalar n;\n-\n-    if (secp256k1_scalar_is_zero(key) || secp256k1_scalar_is_zero(nonce)) {\n-        return 0;\n-    }\n-    n = *nonce;\n-\n-    secp256k1_ecmult_gen(ctx, &Rj, &n);\n-    if (pubnonce != NULL) {\n-        secp256k1_gej_add_ge(&Rj, &Rj, pubnonce);\n-    }\n-    secp256k1_ge_set_gej(&Ra, &Rj);\n-    secp256k1_fe_normalize(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        /* R's y coordinate is odd, which is not allowed (see rationale above).\n-           Force it to be even by negating the nonce. Note that this even works\n-           for multiparty signing, as the R point is known to all participants,\n-           which can all decide to flip the sign in unison, resulting in the\n-           overall R point to be negated too. */\n-        secp256k1_scalar_negate(&n, &n);\n-    }\n-    secp256k1_fe_normalize(&Ra.x);\n-    secp256k1_fe_get_b32(sig64, &Ra.x);\n-    hash(h32, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, h32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        secp256k1_scalar_clear(&n);\n-        return 0;\n-    }\n-    secp256k1_scalar_mul(&s, &h, key);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_add(&s, &s, &n);\n-    secp256k1_scalar_clear(&n);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    if (secp256k1_ge_is_infinity(pubkey)) {\n-        return 0;\n-    }\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Qj, pubkey);\n-    secp256k1_ecmult(ctx, &Rj, &Qj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Rj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej_var(&Ra, &Rj);\n-    secp256k1_fe_normalize_var(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        return 0;\n-    }\n-    return secp256k1_fe_equal_var(&Rx, &Ra.x);\n-}\n-\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    if (!secp256k1_ge_set_xo_var(&Ra, &Rx, 0)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Rj, &Ra);\n-    secp256k1_scalar_inverse_var(&h, &h);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_mul(&s, &s, &h);\n-    secp256k1_ecmult(ctx, &Qj, &Rj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Qj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej(pubkey, &Qj);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins) {\n-    secp256k1_scalar s = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n-    size_t i;\n-    for (i = 0; i < n; i++) {\n-        secp256k1_scalar si;\n-        int overflow;\n-        secp256k1_scalar_set_b32(&si, sig64ins[i] + 32, &overflow);\n-        if (overflow) {\n-            return -1;\n-        }\n-        if (i) {\n-            if (memcmp(sig64ins[i - 1], sig64ins[i], 32) != 0) {\n-                return -1;\n-            }\n-        }\n-        secp256k1_scalar_add(&s, &s, &si);\n-    }\n-    if (secp256k1_scalar_is_zero(&s)) {\n-        return 0;\n-    }\n-    memcpy(sig64, sig64ins[0], 32);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    secp256k1_scalar_clear(&s);\n-    return 1;\n-}\n-\n-#endif"
      },
      {
        "sha": "5bd14a03e3c65ba99c27e6694352bf9e4d9ab1cd",
        "filename": "src/modules/schnorr/tests_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 175,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/tests_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,175 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_TESTS\n-#define SECP256K1_MODULE_SCHNORR_TESTS\n-\n-#include \"include/secp256k1_schnorr.h\"\n-\n-void test_schnorr_end_to_end(void) {\n-    unsigned char privkey[32];\n-    unsigned char message[32];\n-    unsigned char schnorr_signature[64];\n-    secp256k1_pubkey pubkey, recpubkey;\n-\n-    /* Generate a random key and message. */\n-    {\n-        secp256k1_scalar key;\n-        random_scalar_order_test(&key);\n-        secp256k1_scalar_get_b32(privkey, &key);\n-        secp256k1_rand256_test(message);\n-    }\n-\n-    /* Construct and verify corresponding public key. */\n-    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n-    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n-\n-    /* Schnorr sign. */\n-    CHECK(secp256k1_schnorr_sign(ctx, schnorr_signature, message, privkey, NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 1);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) == 1);\n-    CHECK(memcmp(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n-    /* Destroy signature and verify again. */\n-    schnorr_signature[secp256k1_rand_bits(6)] += 1 + secp256k1_rand_int(255);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 0);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) != 1 ||\n-          memcmp(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n-}\n-\n-/** Horribly broken hash function. Do not use for anything but tests. */\n-void test_schnorr_hash(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    int i;\n-    for (i = 0; i < 32; i++) {\n-        h32[i] = r32[i] ^ msg32[i];\n-    }\n-}\n-\n-void test_schnorr_sign_verify(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[3][64];\n-    secp256k1_gej pubkeyj[3];\n-    secp256k1_ge pubkey[3];\n-    secp256k1_scalar nonce[3], key[3];\n-    int i = 0;\n-    int k;\n-\n-    secp256k1_rand256_test(msg32);\n-\n-    for (k = 0; k < 3; k++) {\n-        random_scalar_order_test(&key[k]);\n-\n-        do {\n-            random_scalar_order_test(&nonce[k]);\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64[k], &key[k], &nonce[k], NULL, &test_schnorr_hash, msg32)) {\n-                break;\n-            }\n-        } while(1);\n-\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubkeyj[k], &key[k]);\n-        secp256k1_ge_set_gej_var(&pubkey[k], &pubkeyj[k]);\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32));\n-\n-        for (i = 0; i < 4; i++) {\n-            int pos = secp256k1_rand_bits(6);\n-            int mod = 1 + secp256k1_rand_int(255);\n-            sig64[k][pos] ^= mod;\n-            CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32) == 0);\n-            sig64[k][pos] ^= mod;\n-        }\n-    }\n-}\n-\n-void test_schnorr_threshold(void) {\n-    unsigned char msg[32];\n-    unsigned char sec[5][32];\n-    secp256k1_pubkey pub[5];\n-    unsigned char nonce[5][32];\n-    secp256k1_pubkey pubnonce[5];\n-    unsigned char sig[5][64];\n-    const unsigned char* sigs[5];\n-    unsigned char allsig[64];\n-    const secp256k1_pubkey* pubs[5];\n-    secp256k1_pubkey allpub;\n-    int n, i;\n-    int damage;\n-    int ret = 0;\n-\n-    damage = secp256k1_rand_bits(1) ? (1 + secp256k1_rand_int(4)) : 0;\n-    secp256k1_rand256_test(msg);\n-    n = 2 + secp256k1_rand_int(4);\n-    for (i = 0; i < n; i++) {\n-        do {\n-            secp256k1_rand256_test(sec[i]);\n-        } while (!secp256k1_ec_seckey_verify(ctx, sec[i]));\n-        CHECK(secp256k1_ec_pubkey_create(ctx, &pub[i], sec[i]));\n-        CHECK(secp256k1_schnorr_generate_nonce_pair(ctx, &pubnonce[i], nonce[i], msg, sec[i], NULL, NULL));\n-        pubs[i] = &pub[i];\n-    }\n-    if (damage == 1) {\n-        nonce[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    } else if (damage == 2) {\n-        sec[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    for (i = 0; i < n; i++) {\n-        secp256k1_pubkey allpubnonce;\n-        const secp256k1_pubkey *pubnonces[4];\n-        int j;\n-        for (j = 0; j < i; j++) {\n-            pubnonces[j] = &pubnonce[j];\n-        }\n-        for (j = i + 1; j < n; j++) {\n-            pubnonces[j - 1] = &pubnonce[j];\n-        }\n-        CHECK(secp256k1_ec_pubkey_combine(ctx, &allpubnonce, pubnonces, n - 1));\n-        ret |= (secp256k1_schnorr_partial_sign(ctx, sig[i], msg, sec[i], &allpubnonce, nonce[i]) != 1) * 1;\n-        sigs[i] = sig[i];\n-    }\n-    if (damage == 3) {\n-        sig[secp256k1_rand_int(n)][secp256k1_rand_bits(6)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    ret |= (secp256k1_ec_pubkey_combine(ctx, &allpub, pubs, n) != 1) * 2;\n-    if ((ret & 1) == 0) {\n-        ret |= (secp256k1_schnorr_partial_combine(ctx, allsig, sigs, n) != 1) * 4;\n-    }\n-    if (damage == 4) {\n-        allsig[secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    if ((ret & 7) == 0) {\n-        ret |= (secp256k1_schnorr_verify(ctx, allsig, msg, &allpub) != 1) * 8;\n-    }\n-    CHECK((ret == 0) == (damage == 0));\n-}\n-\n-void test_schnorr_recovery(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[64];\n-    secp256k1_ge Q;\n-\n-    secp256k1_rand256_test(msg32);\n-    secp256k1_rand256_test(sig64);\n-    secp256k1_rand256_test(sig64 + 32);\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1) {\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1);\n-    }\n-}\n-\n-void run_schnorr_tests(void) {\n-    int i;\n-    for (i = 0; i < 32*count; i++) {\n-        test_schnorr_end_to_end();\n-    }\n-    for (i = 0; i < 32 * count; i++) {\n-         test_schnorr_sign_verify();\n-    }\n-    for (i = 0; i < 16 * count; i++) {\n-         test_schnorr_recovery();\n-    }\n-    for (i = 0; i < 10 * count; i++) {\n-         test_schnorr_threshold();\n-    }\n-}\n-\n-#endif"
      },
      {
        "sha": "27e9d8375e8b0dc9977d8b037fb1b4344d027d4c",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -13,7 +13,9 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32.h\""
      },
      {
        "sha": "56e7bd82afd630b107c080b5c96cf50cdbb722f9",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -282,16 +282,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq 56(%%rsi), %%r14\\n\"\n     /* Initialize r8,r9,r10 */\n     \"movq 0(%%rsi), %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += n0 * c0 */\n     \"movq %8, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract m0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += l1 */\n     \"addq 8(%%rsi), %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -309,7 +309,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract m1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += l2 */\n     \"addq 16(%%rsi), %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -332,7 +332,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r9\\n\"\n     /* extract m2 */\n     \"movq %%r10, %q2\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9,r10) += l3 */\n     \"addq 24(%%rsi), %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -355,7 +355,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r10\\n\"\n     /* extract m3 */\n     \"movq %%r8, %q3\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10,r8) += n3 * c1 */\n     \"movq %9, %%rax\\n\"\n     \"mulq %%r14\\n\"\n@@ -387,16 +387,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %q11, %%r13\\n\"\n     /* Initialize (r8,r9,r10) */\n     \"movq %q5, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += m4 * c0 */\n     \"movq %12, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract p0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += m1 */\n     \"addq %q6, %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -414,7 +414,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract p1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += m2 */\n     \"addq %q7, %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -472,7 +472,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %%rax, 0(%q6)\\n\"\n     /* Move to (r8,r9) */\n     \"movq %%rdx, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p1 */\n     \"addq %q2, %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -483,7 +483,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq %%rdx, %%r9\\n\"\n     /* Extract r1 */\n     \"movq %%r8, 8(%q6)\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r8) += p4 */\n     \"addq %%r10, %%r9\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -492,7 +492,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* Extract r2 */\n     \"movq %%r9, 16(%q6)\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p3 */\n     \"addq %q4, %%r8\\n\"\n     \"adcq $0, %%r9\\n\""
      },
      {
        "sha": "f5b2376407bd3b2338e26b1a0bb84cd3fc91660b",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -14,7 +14,9 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low_impl.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64_impl.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32_impl.h\"\n@@ -31,17 +33,37 @@ static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a\n \n /** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */\n static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    static const unsigned char order[32] = {\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,EXHAUSTIVE_TEST_ORDER\n+    };\n+#else\n     static const unsigned char order[32] = {\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n         0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n         0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n     };\n+#endif\n     secp256k1_num_set_bin(r, order, 32);\n }\n #endif\n \n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n+        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n+            *r = i;\n+    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n+     * have a composite group order; fix it in exhaustive_tests.c). */\n+    VERIFY_CHECK(*r != 0);\n+}\n+#else\n     secp256k1_scalar *t;\n     int i;\n     /* First compute x ^ (2^N - 1) for some values of N. */\n@@ -233,9 +255,9 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n }\n \n SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n-    /* d[0] is present and is the lowest word for all representations */\n     return !(a->d[0] & 1);\n }\n+#endif\n \n static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n #if defined(USE_SCALAR_INV_BUILTIN)\n@@ -259,6 +281,18 @@ static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_sc\n }\n \n #ifdef USE_ENDOMORPHISM\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/**\n+ * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the\n+ * full case we don't bother making k1 and k2 be small, we just want them to be\n+ * nontrivial to get full test coverage for the exhaustive tests. We therefore\n+ * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.\n+ */\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r2 = (*a + 5) % EXHAUSTIVE_TEST_ORDER;\n+    *r1 = (*a + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n+}\n+#else\n /**\n  * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where\n  * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n@@ -331,5 +365,6 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n     secp256k1_scalar_add(r1, r1, a);\n }\n #endif\n+#endif\n \n #endif"
      },
      {
        "sha": "5574c44c7aeb3c8d41ec626adcb1b6994b6f05ef",
        "filename": "src/scalar_low.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -0,0 +1,15 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef uint32_t secp256k1_scalar;\n+\n+#endif"
      },
      {
        "sha": "4f94441f492a8144ebe579435ead2a66712eea17",
        "filename": "src/scalar_low_impl.h",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low_impl.h?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -0,0 +1,114 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+#include \"scalar.h\"\n+\n+#include <string.h>\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(*a & 1);\n+}\n+\n+SECP256K1_INLINE static void secp256k1_scalar_clear(secp256k1_scalar *r) { *r = 0; }\n+SECP256K1_INLINE static void secp256k1_scalar_set_int(secp256k1_scalar *r, unsigned int v) { *r = v; }\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    if (offset < 32)\n+        return ((*a >> offset) & ((((uint32_t)1) << count) - 1));\n+    else\n+        return 0;\n+}\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    return secp256k1_scalar_get_bits(a, offset, count);\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_check_overflow(const secp256k1_scalar *a) { return *a >= EXHAUSTIVE_TEST_ORDER; }\n+\n+static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a + *b) % EXHAUSTIVE_TEST_ORDER;\n+    return *r < *b;\n+}\n+\n+static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n+    if (flag && bit < 32)\n+        *r += (1 << bit);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {\n+    const int base = 0x100 % EXHAUSTIVE_TEST_ORDER;\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < 32; i++) {\n+       *r = ((*r * base) + b32[i]) % EXHAUSTIVE_TEST_ORDER;\n+    }\n+    /* just deny overflow, it basically always happens */\n+    if (overflow) *overflow = 0;\n+}\n+\n+static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {\n+    memset(bin, 0, 32);\n+    bin[28] = *a >> 24; bin[29] = *a >> 16; bin[30] = *a >> 8; bin[31] = *a;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_zero(const secp256k1_scalar *a) {\n+    return *a == 0;\n+}\n+\n+static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    if (*a == 0) {\n+        *r = 0;\n+    } else {\n+        *r = EXHAUSTIVE_TEST_ORDER - *a;\n+    }\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_one(const secp256k1_scalar *a) {\n+    return *a == 1;\n+}\n+\n+static int secp256k1_scalar_is_high(const secp256k1_scalar *a) {\n+    return *a > EXHAUSTIVE_TEST_ORDER / 2;\n+}\n+\n+static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n+    if (flag) secp256k1_scalar_negate(r, r);\n+    return flag ? -1 : 1;\n+}\n+\n+static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a * *b) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n+    int ret;\n+    VERIFY_CHECK(n > 0);\n+    VERIFY_CHECK(n < 16);\n+    ret = *r & ((1 << n) - 1);\n+    *r >>= n;\n+    return ret;\n+}\n+\n+static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    *r = (*a * *a) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r1 = *a;\n+    *r2 = 0;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    return *a == *b;\n+}\n+\n+#endif"
      },
      {
        "sha": "fb8b882faafd36d8b60476e1df024829b32326e0",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -359,23 +359,23 @@ int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, NULL)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);"
      },
      {
        "sha": "9ae7d3028130637ba1159c4c9772cf94267e3711",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -520,7 +520,7 @@ void test_num_mod(void) {\n     secp256k1_num order, n;\n \n     /* check that 0 mod anything is 0 */\n-    random_scalar_order_test(&s); \n+    random_scalar_order_test(&s);\n     secp256k1_scalar_get_num(&order, &s);\n     secp256k1_scalar_set_int(&s, 0);\n     secp256k1_scalar_get_num(&n, &s);\n@@ -535,7 +535,7 @@ void test_num_mod(void) {\n     CHECK(secp256k1_num_is_zero(&n));\n \n     /* check that increasing the number past 2^256 does not break this */\n-    random_scalar_order_test(&s); \n+    random_scalar_order_test(&s);\n     secp256k1_scalar_get_num(&n, &s);\n     /* multiply by 2^8, which'll test this case with high probability */\n     for (i = 0; i < 8; ++i) {\n@@ -568,7 +568,7 @@ void test_num_jacobi(void) {\n     /* we first need a scalar which is not a multiple of 5 */\n     do {\n         secp256k1_num fiven;\n-        random_scalar_order_test(&sqr); \n+        random_scalar_order_test(&sqr);\n         secp256k1_scalar_get_num(&fiven, &five);\n         secp256k1_scalar_get_num(&n, &sqr);\n         secp256k1_num_mod(&n, &fiven);\n@@ -587,7 +587,7 @@ void test_num_jacobi(void) {\n \n     /** test with secp group order as order */\n     secp256k1_scalar_order_get_num(&order);\n-    random_scalar_order_test(&sqr); \n+    random_scalar_order_test(&sqr);\n     secp256k1_scalar_sqr(&sqr, &sqr);\n     /* test residue */\n     secp256k1_scalar_get_num(&n, &sqr);\n@@ -1733,18 +1733,18 @@ void run_field_inv_all_var(void) {\n     secp256k1_fe x[16], xi[16], xii[16];\n     int i;\n     /* Check it's safe to call for 0 elements */\n-    secp256k1_fe_inv_all_var(0, xi, x);\n+    secp256k1_fe_inv_all_var(xi, x, 0);\n     for (i = 0; i < count; i++) {\n         size_t j;\n         size_t len = secp256k1_rand_int(15) + 1;\n         for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n         }\n-        secp256k1_fe_inv_all_var(len, xi, x);\n+        secp256k1_fe_inv_all_var(xi, x, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_inverse(&x[j], &xi[j]));\n         }\n-        secp256k1_fe_inv_all_var(len, xii, xi);\n+        secp256k1_fe_inv_all_var(xii, xi, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_equal(&x[j], &xii[j]));\n         }\n@@ -1930,7 +1930,7 @@ void test_ge(void) {\n                 zs[i] = gej[i].z;\n             }\n         }\n-        secp256k1_fe_inv_all_var(4 * runs + 1, zinv, zs);\n+        secp256k1_fe_inv_all_var(zinv, zs, 4 * runs + 1);\n         free(zs);\n     }\n \n@@ -2050,8 +2050,8 @@ void test_ge(void) {\n                 secp256k1_fe_mul(&zr[i + 1], &zinv[i], &gej[i + 1].z);\n             }\n         }\n-        secp256k1_ge_set_table_gej_var(4 * runs + 1, ge_set_table, gej, zr);\n-        secp256k1_ge_set_all_gej_var(4 * runs + 1, ge_set_all, gej, &ctx->error_callback);\n+        secp256k1_ge_set_table_gej_var(ge_set_table, gej, zr, 4 * runs + 1);\n+        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1, &ctx->error_callback);\n         for (i = 0; i < 4 * runs + 1; i++) {\n             secp256k1_fe s;\n             random_fe_non_zero(&s);"
      },
      {
        "sha": "bda6ee475c9c0fb5c85eb4944f0746107cff6b42",
        "filename": "src/tests_exhaustive.c",
        "status": "added",
        "additions": 329,
        "deletions": 0,
        "changes": 329,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -0,0 +1,329 @@\n+/***********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <time.h>\n+\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n+\n+#ifndef EXHAUSTIVE_TEST_ORDER\n+/* see group_impl.h for allowable values */\n+#define EXHAUSTIVE_TEST_ORDER 13\n+#define EXHAUSTIVE_TEST_LAMBDA 9   /* cube root of 1 mod 13 */\n+#endif\n+\n+#include \"include/secp256k1.h\"\n+#include \"group.h\"\n+#include \"secp256k1.c\"\n+#include \"testrand_impl.h\"\n+\n+/** stolen from tests.c */\n+void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    CHECK(secp256k1_fe_equal_var(&a->x, &b->x));\n+    CHECK(secp256k1_fe_equal_var(&a->y, &b->y));\n+}\n+\n+void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n+    secp256k1_fe z2s;\n+    secp256k1_fe u1, u2, s1, s2;\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    /* Check a.x * b.z^2 == b.x && a.y * b.z^3 == b.y, to avoid inverses. */\n+    secp256k1_fe_sqr(&z2s, &b->z);\n+    secp256k1_fe_mul(&u1, &a->x, &z2s);\n+    u2 = b->x; secp256k1_fe_normalize_weak(&u2);\n+    secp256k1_fe_mul(&s1, &a->y, &z2s); secp256k1_fe_mul(&s1, &s1, &b->z);\n+    s2 = b->y; secp256k1_fe_normalize_weak(&s2);\n+    CHECK(secp256k1_fe_equal_var(&u1, &u2));\n+    CHECK(secp256k1_fe_equal_var(&s1, &s2));\n+}\n+\n+void random_fe(secp256k1_fe *x) {\n+    unsigned char bin[32];\n+    do {\n+        secp256k1_rand256(bin);\n+        if (secp256k1_fe_set_b32(x, bin)) {\n+            return;\n+        }\n+    } while(1);\n+}\n+/** END stolen from tests.c */\n+\n+int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+                                      const unsigned char *key32, const unsigned char *algo16,\n+                                      void *data, unsigned int attempt) {\n+    secp256k1_scalar s;\n+    int *idata = data;\n+    (void)msg32;\n+    (void)key32;\n+    (void)algo16;\n+    /* Some nonces cannot be used because they'd cause s and/or r to be zero.\n+     * The signing function has retry logic here that just re-calls the nonce\n+     * function with an increased `attempt`. So if attempt > 0 this means we\n+     * need to change the nonce to avoid an infinite loop. */\n+    if (attempt > 0) {\n+        (*idata)++;\n+    }\n+    secp256k1_scalar_set_int(&s, *idata);\n+    secp256k1_scalar_get_b32(nonce32, &s);\n+    return 1;\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+void test_exhaustive_endomorphism(const secp256k1_ge *group, int order) {\n+    int i;\n+    for (i = 0; i < order; i++) {\n+        secp256k1_ge res;\n+        secp256k1_ge_mul_lambda(&res, &group[i]);\n+        ge_equals_ge(&group[i * EXHAUSTIVE_TEST_LAMBDA % EXHAUSTIVE_TEST_ORDER], &res);\n+    }\n+}\n+#endif\n+\n+void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j;\n+\n+    /* Sanity-check (and check infinity functions) */\n+    CHECK(secp256k1_ge_is_infinity(&group[0]));\n+    CHECK(secp256k1_gej_is_infinity(&groupj[0]));\n+    for (i = 1; i < order; i++) {\n+        CHECK(!secp256k1_ge_is_infinity(&group[i]));\n+        CHECK(!secp256k1_gej_is_infinity(&groupj[i]));\n+    }\n+\n+    /* Check all addition formulae */\n+    for (j = 0; j < order; j++) {\n+        secp256k1_fe fe_inv;\n+        secp256k1_fe_inv(&fe_inv, &groupj[j].z);\n+        for (i = 0; i < order; i++) {\n+            secp256k1_ge zless_gej;\n+            secp256k1_gej tmp;\n+            /* add_var */\n+            secp256k1_gej_add_var(&tmp, &groupj[i], &groupj[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_ge */\n+            if (j > 0) {\n+                secp256k1_gej_add_ge(&tmp, &groupj[i], &group[j]);\n+                ge_equals_gej(&group[(i + j) % order], &tmp);\n+            }\n+            /* add_ge_var */\n+            secp256k1_gej_add_ge_var(&tmp, &groupj[i], &group[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_zinv_var */\n+            zless_gej.infinity = groupj[j].infinity;\n+            zless_gej.x = groupj[j].x;\n+            zless_gej.y = groupj[j].y;\n+            secp256k1_gej_add_zinv_var(&tmp, &groupj[i], &zless_gej, &fe_inv);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+        }\n+    }\n+\n+    /* Check doubling */\n+    for (i = 0; i < order; i++) {\n+        secp256k1_gej tmp;\n+        if (i > 0) {\n+            secp256k1_gej_double_nonzero(&tmp, &groupj[i], NULL);\n+            ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        }\n+        secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+    }\n+\n+    /* Check negation */\n+    for (i = 1; i < order; i++) {\n+        secp256k1_ge tmp;\n+        secp256k1_gej tmpj;\n+        secp256k1_ge_neg(&tmp, &group[i]);\n+        ge_equals_ge(&group[order - i], &tmp);\n+        secp256k1_gej_neg(&tmpj, &groupj[i]);\n+        ge_equals_gej(&group[order - i], &tmpj);\n+    }\n+}\n+\n+void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j, r_log;\n+    for (r_log = 1; r_log < order; r_log++) {\n+        for (j = 0; j < order; j++) {\n+            for (i = 0; i < order; i++) {\n+                secp256k1_gej tmp;\n+                secp256k1_scalar na, ng;\n+                secp256k1_scalar_set_int(&na, i);\n+                secp256k1_scalar_set_int(&ng, j);\n+\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n+\n+                if (i > 0) {\n+                    secp256k1_ecmult_const(&tmp, &group[i], &ng);\n+                    ge_equals_gej(&group[(i * j) % order], &tmp);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n+    secp256k1_fe x;\n+    unsigned char x_bin[32];\n+    k %= EXHAUSTIVE_TEST_ORDER;\n+    x = group[k].x;\n+    secp256k1_fe_normalize(&x);\n+    secp256k1_fe_get_b32(x_bin, &x);\n+    secp256k1_scalar_set_b32(r, x_bin, NULL);\n+}\n+\n+void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* Verify by calling verify */\n+                    secp256k1_ecdsa_signature_save(&sig, &r_s, &s_s);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+            }\n+        }\n+    }\n+\n+    /* We would like to verify zero-knowledge here by counting how often every\n+     * possible (s, r) tuple appears, but because the group order is larger\n+     * than the field order, when coercing the x-values to scalar values, some\n+     * appear more often than others, so we are actually not zero-knowledge.\n+     * (This effect also appears in the real code, but the difference is on the\n+     * order of 1/2^128th the field order, so the deviation is not useful to a\n+     * computationally bounded attacker.)\n+     */\n+}\n+\n+int main(void) {\n+    int i;\n+    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n+    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n+\n+    /* Build context */\n+    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+    /* TODO set z = 1, then do num_tests runs with random z values */\n+\n+    /* Generate the entire group */\n+    secp256k1_gej_set_infinity(&groupj[0]);\n+    secp256k1_ge_set_gej(&group[0], &groupj[0]);\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        /* Set a different random z-value for each Jacobian point */\n+        secp256k1_fe z;\n+        random_fe(&z);\n+\n+        secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n+        secp256k1_ge_set_gej(&group[i], &groupj[i]);\n+        secp256k1_gej_rescale(&groupj[i], &z);\n+\n+        /* Verify against ecmult_gen */\n+        {\n+            secp256k1_scalar scalar_i;\n+            secp256k1_gej generatedj;\n+            secp256k1_ge generated;\n+\n+            secp256k1_scalar_set_int(&scalar_i, i);\n+            secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n+            secp256k1_ge_set_gej(&generated, &generatedj);\n+\n+            CHECK(group[i].infinity == 0);\n+            CHECK(generated.infinity == 0);\n+            CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n+            CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n+        }\n+    }\n+\n+    /* Run the tests */\n+#ifdef USE_ENDOMORPHISM\n+    test_exhaustive_endomorphism(group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+    test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+\n+    return 0;\n+}\n+"
      }
    ]
  },
  {
    "sha": "547a53d13507b3348d216d82353e0d6a9d8fa974",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDdhNTNkMTM1MDdiMzM0OGQyMTZkODIzNTNlMGQ2YTlkOGZhOTc0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-12-12T19:08:47Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-12-12T19:08:47Z"
      },
      "message": "Update libsecp256k1 to master",
      "tree": {
        "sha": "113b853b342ee4c67b39b0226f3ff06b35cc92cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/113b853b342ee4c67b39b0226f3ff06b35cc92cf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/547a53d13507b3348d216d82353e0d6a9d8fa974",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/547a53d13507b3348d216d82353e0d6a9d8fa974",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/547a53d13507b3348d216d82353e0d6a9d8fa974",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/547a53d13507b3348d216d82353e0d6a9d8fa974/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76fcd9d5034143a5b041766552670d19f926097d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76fcd9d5034143a5b041766552670d19f926097d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76fcd9d5034143a5b041766552670d19f926097d"
      },
      {
        "sha": "7b49f22bdbdecca600c4744d020b3553fe427e61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b49f22bdbdecca600c4744d020b3553fe427e61",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b49f22bdbdecca600c4744d020b3553fe427e61"
      }
    ],
    "stats": {
      "total": 1613,
      "additions": 676,
      "deletions": 937
    },
    "files": [
      {
        "sha": "87fea161ba5aea04756cb378d487b703bb2e2ab2",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -6,6 +6,7 @@ bench_schnorr_verify\n bench_recover\n bench_internal\n tests\n+exhaustive_tests\n gen_context\n *.exe\n *.so"
      },
      {
        "sha": "24395292426d697856f34b0b0d6c8f26d81d6856",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -11,7 +11,7 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no  EXPERIMENTAL=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n@@ -22,15 +22,14 @@ env:\n     - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes EXPERIMENTAL=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes EXPERIMENTAL=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n-    - BUILD=check-java ECDH=yes SCHNORR=yes EXPERIMENTAL=yes\n+    - BUILD=check-java ECDH=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -66,5 +65,5 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "e5657f7f31307852c4dc90750cabea1e2bf1947f",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -12,9 +12,11 @@ noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n noinst_HEADERS += src/scalar_8x32.h\n+noinst_HEADERS += src/scalar_low.h\n noinst_HEADERS += src/scalar_impl.h\n noinst_HEADERS += src/scalar_4x64_impl.h\n noinst_HEADERS += src/scalar_8x32_impl.h\n+noinst_HEADERS += src/scalar_low_impl.h\n noinst_HEADERS += src/group.h\n noinst_HEADERS += src/group_impl.h\n noinst_HEADERS += src/num_gmp.h\n@@ -87,13 +89,23 @@ bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n+TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n-TESTS = tests\n+TESTS += tests\n+endif\n+\n+if USE_EXHAUSTIVE_TESTS\n+noinst_PROGRAMS += exhaustive_tests\n+exhaustive_tests_SOURCES = src/tests_exhaustive.c\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_LDADD = $(SECP_LIBS)\n+exhaustive_tests_LDFLAGS = -static\n+TESTS += exhaustive_tests\n endif\n \n JAVAROOT=src/java\n@@ -154,10 +166,6 @@ if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n endif\n \n-if ENABLE_MODULE_SCHNORR\n-include src/modules/schnorr/Makefile.am.include\n-endif\n-\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif"
      },
      {
        "sha": "b74acb8c138823c67e7fd0a11d059a90bd2551a9",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -46,6 +46,10 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     ECDSA_sign(0, NULL, 0, NULL, NULL, eckey);\n     ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n     EC_KEY_free(eckey);\n+    ECDSA_SIG *sig_openssl;\n+    sig_openssl = ECDSA_SIG_new();\n+    (void)sig_openssl->r;\n+    ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])\n fi"
      },
      {
        "sha": "ec50ffe3a251b653cdcd9eb88b887e6374934c0e",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 9,
        "deletions": 21,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -104,6 +104,11 @@ AC_ARG_ENABLE(experimental,\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n+AC_ARG_ENABLE(exhaustive_tests,\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    [use_exhaustive_tests=$enableval],\n+    [use_exhaustive_tests=yes])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n@@ -119,11 +124,6 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n-AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (experimental)]),\n-    [enable_module_schnorr=$enableval],\n-    [enable_module_schnorr=no])\n-\n AC_ARG_ENABLE(module_recovery,\n     AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n     [enable_module_recovery=$enableval],\n@@ -381,9 +381,6 @@ fi\n if test x\"$use_jni\" != x\"no\"; then\n   AX_JNI_INCLUDE_DIR\n   have_jni_dependencies=yes\n-  if test x\"$enable_module_schnorr\" = x\"no\"; then\n-    have_jni_dependencies=no\n-  fi\n   if test x\"$enable_module_ecdh\" = x\"no\"; then\n     have_jni_dependencies=no\n   fi\n@@ -392,7 +389,7 @@ if test x\"$use_jni\" != x\"no\"; then\n   fi\n   if test \"x$have_jni_dependencies\" = \"xno\"; then\n     if test x\"$use_jni\" = x\"yes\"; then\n-      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and Schnorr and try again.])\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and try again.])\n     fi\n     AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n     use_jni=no\n@@ -413,18 +410,14 @@ if test x\"$use_endomorphism\" = x\"yes\"; then\n   AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism optimization])\n fi\n \n-if test x\"$use_ecmult_static_precomputation\" = x\"yes\"; then\n+if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n \n if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n \n-if test x\"$enable_module_schnorr\" = x\"yes\"; then\n-  AC_DEFINE(ENABLE_MODULE_SCHNORR, 1, [Define this symbol to enable the Schnorr signature module])\n-fi\n-\n if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n@@ -442,7 +435,6 @@ AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n AC_MSG_NOTICE([Using jni: $use_jni])\n \n@@ -451,12 +443,8 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([WARNING: experimental build])\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-  AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n   AC_MSG_NOTICE([******])\n else\n-  if test x\"$enable_module_schnorr\" = x\"yes\"; then\n-    AC_MSG_ERROR([Schnorr signature module is experimental. Use --enable-experimental to allow.])\n-  fi\n   if test x\"$enable_module_ecdh\" = x\"yes\"; then\n     AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -473,10 +461,10 @@ AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n-AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_precomputation\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n-AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])"
      },
      {
        "sha": "f268e309d0bf5d0db21bc61224bb798aba14dbf0",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -47,11 +47,8 @@ typedef struct secp256k1_context_struct secp256k1_context;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n- *\n- *  Furthermore, it is guaranteed that identical public keys (ignoring\n- *  compression) will have identical representation, so they can be memcmp'ed.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -62,12 +59,9 @@ typedef struct {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  the secp256k1_ecdsa_signature_serialize_* and\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the secp256k1_ecdsa_signature_serialize_* and\n  *  secp256k1_ecdsa_signature_serialize_* functions.\n- *\n- *  Furthermore, it is guaranteed to identical signatures will have identical\n- *  representation, so they can be memcmp'ed.\n  */\n typedef struct {\n     unsigned char data[64];"
      },
      {
        "sha": "dc32fec1eac0380e687399c0cf66e0c44cb2e1a3",
        "filename": "src/secp256k1/include/secp256k1_schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 173,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/include/secp256k1_schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/include/secp256k1_schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorr.h?ref=76fcd9d5034143a5b041766552670d19f926097d",
        "patch": "@@ -1,173 +0,0 @@\n-#ifndef _SECP256K1_SCHNORR_\n-# define _SECP256K1_SCHNORR_\n-\n-# include \"secp256k1.h\"\n-\n-# ifdef __cplusplus\n-extern \"C\" {\n-# endif\n-\n-/** Create a signature using a custom EC-Schnorr-SHA256 construction. It\n- *  produces non-malleable 64-byte signatures which support public key recovery\n- *  batch validation, and multiparty signing.\n- *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was\n- *              invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing\n- *                   (cannot be NULL)\n- *  Out:     sig64:  pointer to a 64-byte array where the signature will be\n- *                   placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL,\n- *                   secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation\n- *                   function (can be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *seckey,\n-  secp256k1_nonce_function noncefp,\n-  const void *ndata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Verify a signature created by secp256k1_schnorr_sign.\n- *  Returns: 1: correct signature\n- *           0: incorrect signature\n- *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig64:     the 64-byte signature being verified (cannot be NULL)\n- *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n- *           pubkey:    the public key to verify with (cannot be NULL)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_verify(\n-  const secp256k1_context* ctx,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const secp256k1_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Recover an EC public key from a Schnorr signature created using\n- *  secp256k1_schnorr_sign.\n- *  Returns: 1: public key successfully recovered (which guarantees a correct\n- *           signature).\n- *           0: otherwise.\n- *  Args:    ctx:        pointer to a context object, initialized for\n- *                       verification (cannot be NULL)\n- *  Out:     pubkey:     pointer to a pubkey to set to the recovered public key\n- *                       (cannot be NULL).\n- *  In:      sig64:      signature as 64 byte array (cannot be NULL)\n- *           msg32:      the 32-byte message hash assumed to be signed (cannot\n- *                       be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_recover(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubkey,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Generate a nonce pair deterministically for use with\n- *  secp256k1_schnorr_partial_sign.\n- *  Returns: 1: valid nonce pair was generated.\n- *           0: otherwise (nonce generation function failed)\n- *  Args:    ctx:         pointer to a context object, initialized for signing\n- *                        (cannot be NULL)\n- *  Out:     pubnonce:    public side of the nonce (cannot be NULL)\n- *           privnonce32: private side of the nonce (32 byte) (cannot be NULL)\n- *  In:      msg32:       the 32-byte message hash assumed to be signed (cannot\n- *                        be NULL)\n- *           sec32:       the 32-byte private key (cannot be NULL)\n- *           noncefp:     pointer to a nonce generation function. If NULL,\n- *                        secp256k1_nonce_function_default is used\n- *           noncedata:   pointer to arbitrary data used by the nonce generation\n- *                        function (can be NULL)\n- *\n- *  Do not use the output as a private/public key pair for signing/validation.\n- */\n-SECP256K1_API int secp256k1_schnorr_generate_nonce_pair(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubnonce,\n-  unsigned char *privnonce32,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  secp256k1_nonce_function noncefp,\n-  const void* noncedata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-/** Produce a partial Schnorr signature, which can be combined using\n- *  secp256k1_schnorr_partial_combine, to end up with a full signature that is\n- *  verifiable using secp256k1_schnorr_verify.\n- *  Returns: 1: signature created successfully.\n- *           0: no valid signature exists with this combination of keys, nonces\n- *              and message (chance around 1 in 2^128)\n- *          -1: invalid private key, nonce, or public nonces.\n- *  Args: ctx:             pointer to context object, initialized for signing (cannot\n- *                         be NULL)\n- *  Out:  sig64:           pointer to 64-byte array to put partial signature in\n- *  In:   msg32:           pointer to 32-byte message to sign\n- *        sec32:           pointer to 32-byte private key\n- *        pubnonce_others: pointer to pubkey containing the sum of the other's\n- *                         nonces (see secp256k1_ec_pubkey_combine)\n- *        secnonce32:      pointer to 32-byte array containing our nonce\n- *\n- * The intended procedure for creating a multiparty signature is:\n- * - Each signer S[i] with private key x[i] and public key Q[i] runs\n- *   secp256k1_schnorr_generate_nonce_pair to produce a pair (k[i],R[i]) of\n- *   private/public nonces.\n- * - All signers communicate their public nonces to each other (revealing your\n- *   private nonce can lead to discovery of your private key, so it should be\n- *   considered secret).\n- * - All signers combine all the public nonces they received (excluding their\n- *   own) using secp256k1_ec_pubkey_combine to obtain an\n- *   Rall[i] = sum(R[0..i-1,i+1..n]).\n- * - All signers produce a partial signature using\n- *   secp256k1_schnorr_partial_sign, passing in their own private key x[i],\n- *   their own private nonce k[i], and the sum of the others' public nonces\n- *   Rall[i].\n- * - All signers communicate their partial signatures to each other.\n- * - Someone combines all partial signatures using\n- *   secp256k1_schnorr_partial_combine, to obtain a full signature.\n- * - The resulting signature is validatable using secp256k1_schnorr_verify, with\n- *   public key equal to the result of secp256k1_ec_pubkey_combine of the\n- *   signers' public keys (sum(Q[0..n])).\n- *\n- *  Note that secp256k1_schnorr_partial_combine and secp256k1_ec_pubkey_combine\n- *  function take their arguments in any order, and it is possible to\n- *  pre-combine several inputs already with one call, and add more inputs later\n- *  by calling the function again (they are commutative and associative).\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  const secp256k1_pubkey *pubnonce_others,\n-  const unsigned char *secnonce32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n-\n-/** Combine multiple Schnorr partial signatures.\n- * Returns: 1: the passed signatures were successfully combined.\n- *          0: the resulting signature is not valid (chance of 1 in 2^256)\n- *         -1: some inputs were invalid, or the signatures were not created\n- *             using the same set of nonces\n- * Args:   ctx:      pointer to a context object\n- * Out:    sig64:    pointer to a 64-byte array to place the combined signature\n- *                   (cannot be NULL)\n- * In:     sig64sin: pointer to an array of n pointers to 64-byte input\n- *                   signatures\n- *         n:        the number of signatures to combine (at least 1)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_combine(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char * const * sig64sin,\n-  size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-# ifdef __cplusplus\n-}\n-# endif\n-\n-#endif"
      },
      {
        "sha": "9a42e519bd580c6f505d66deec88bbed6dabecf8",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -203,7 +203,9 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n+#if !defined(EXHAUSTIVE_TEST_ORDER)\n     secp256k1_fe xr;\n+#endif\n     secp256k1_gej pubkeyj;\n     secp256k1_gej pr;\n \n@@ -219,6 +221,21 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }\n+\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+{\n+    secp256k1_scalar computed_r;\n+    int overflow = 0;\n+    secp256k1_ge pr_ge;\n+    secp256k1_ge_set_gej(&pr_ge, &pr);\n+    secp256k1_fe_normalize(&pr_ge.x);\n+\n+    secp256k1_fe_get_b32(c, &pr_ge.x);\n+    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n+    /* we fully expect overflow */\n+    return secp256k1_scalar_eq(sigr, &computed_r);\n+}\n+#else\n     secp256k1_scalar_get_b32(c, sigr);\n     secp256k1_fe_set_b32(&xr, c);\n \n@@ -252,6 +269,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n         return 1;\n     }\n     return 0;\n+#endif\n }\n \n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid) {"
      },
      {
        "sha": "0db314c48e0cdc844a89cb4a6d5b4ce4c9352578",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -78,7 +78,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ (s.d[0] & 1);\n+    bit = flip ^ !secp256k1_scalar_is_even(&s);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n     secp256k1_scalar_negate(&neg_s, &s);\n     not_neg_one = !secp256k1_scalar_is_one(&neg_s);"
      },
      {
        "sha": "35f25460773f3ab1819beb6a1633ef264c83408d",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -77,7 +77,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(1024, prec, precj, cb);\n+        secp256k1_ge_set_all_gej_var(prec, precj, 1024, cb);\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {"
      },
      {
        "sha": "4e40104ad43ceb12845b79994c5bd5d28f3b31a0",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -7,15 +7,29 @@\n #ifndef _SECP256K1_ECMULT_IMPL_H_\n #define _SECP256K1_ECMULT_IMPL_H_\n \n+#include <string.h>\n+\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n-#include <string.h>\n-\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need to lower these values for exhaustive tests because\n+ * the tables cannot have infinities in them (this breaks the\n+ * affine-isomorphism stuff which tracks z-ratios) */\n+#  if EXHAUSTIVE_TEST_ORDER > 128\n+#    define WINDOW_A 5\n+#    define WINDOW_G 8\n+#  elif EXHAUSTIVE_TEST_ORDER > 8\n+#    define WINDOW_A 4\n+#    define WINDOW_G 4\n+#  else\n+#    define WINDOW_A 2\n+#    define WINDOW_G 2\n+#  endif\n+#else\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n-\n /** larger numbers may result in slightly better performance, at the cost of\n     exponentially larger precomputed tables. */\n #ifdef USE_ENDOMORPHISM\n@@ -25,6 +39,7 @@\n /** One table for window size 16: 1.375 MiB. */\n #define WINDOW_G 16\n #endif\n+#endif\n \n /** The number of entries a table with precomputed multiples needs to have. */\n #define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n@@ -103,7 +118,7 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n     /* Compute the odd multiples in Jacobian form. */\n     secp256k1_ecmult_odd_multiples_table(n, prej, zr, a);\n     /* Convert them in batch to affine coordinates. */\n-    secp256k1_ge_set_table_gej_var(n, prea, prej, zr);\n+    secp256k1_ge_set_table_gej_var(prea, prej, zr, n);\n     /* Convert them to compact storage form. */\n     for (i = 0; i < n; i++) {\n         secp256k1_ge_to_storage(&pre[i], &prea[i]);"
      },
      {
        "sha": "bbb1ee866cc427108f03a4f94fc1da27981c29fa",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -30,6 +30,8 @@\n #error \"Please select field implementation\"\n #endif\n \n+#include \"util.h\"\n+\n /** Normalize a field element. */\n static void secp256k1_fe_normalize(secp256k1_fe *r);\n \n@@ -50,6 +52,9 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r);\n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n \n+/** Sets a field element equal to zero, initializing all fields. */\n+static void secp256k1_fe_clear(secp256k1_fe *a);\n+\n /** Verify whether a field element is zero. Requires the input to be normalized. */\n static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n \n@@ -110,7 +115,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a);\n /** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n  *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n  *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a);\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len);\n \n /** Convert a field element to the storage type. */\n static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a);"
      },
      {
        "sha": "5127b279bc7f56b621042d9f79bfc200dd7086c7",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -260,7 +260,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a) {\n #endif\n }\n \n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a) {\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len) {\n     secp256k1_fe u;\n     size_t i;\n     if (len < 1) {"
      },
      {
        "sha": "4957b248fe6a608b8ae825b9b200b263415f36c4",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -65,12 +65,12 @@ static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb);\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb);\n \n /** Set a batch of group elements equal to the inputs given in jacobian\n  *  coordinates (with known z-ratios). zr must contain the known z-ratios such\n  *  that mul(a[i].z, zr[i+1]) == a[i+1].z. zr[0] is ignored. */\n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr);\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len);\n \n /** Bring a batch inputs given in jacobian coordinates (with known z-ratios) to\n  *  the same global z \"denominator\". zr must contain the known z-ratios such"
      },
      {
        "sha": "2e192b62fd2ce7fa83f0b3d1876c0fbc6876f60e",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 67,
        "deletions": 11,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -11,6 +11,53 @@\n #include \"field.h\"\n #include \"group.h\"\n \n+/* These points can be generated in sage as follows:\n+ *\n+ * 0. Setup a worksheet with the following parameters.\n+ *   b = 4  # whatever CURVE_B will be set to\n+ *   F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)\n+ *   C = EllipticCurve ([F (0), F (b)])\n+ *\n+ * 1. Determine all the small orders available to you. (If there are\n+ *    no satisfactory ones, go back and change b.)\n+ *   print C.order().factor(limit=1000)\n+ *\n+ * 2. Choose an order as one of the prime factors listed in the above step.\n+ *    (You can also multiply some to get a composite order, though the\n+ *    tests will crash trying to invert scalars during signing.) We take a\n+ *    random point and scale it to drop its order to the desired value.\n+ *    There is some probability this won't work; just try again.\n+ *   order = 199\n+ *   P = C.random_point()\n+ *   P = (int(P.order()) / int(order)) * P\n+ *   assert(P.order() == order)\n+ *\n+ * 3. Print the values. You'll need to use a vim macro or something to\n+ *    split the hex output into 4-byte chunks.\n+ *   print \"%x %x\" % P.xy()\n+ */\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n+    0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n+    0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n+    0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n+);\n+\n+const int CURVE_B = 4;\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n+    0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n+    0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n+    0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n+);\n+const int CURVE_B = 2;\n+#  else\n+#    error No known generator for the specified exhaustive test group order.\n+#  endif\n+#else\n /** Generator for secp256k1, value 'g' defined in\n  *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n  */\n@@ -21,8 +68,11 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n+const int CURVE_B = 7;\n+#endif\n+\n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n-    secp256k1_fe zi2; \n+    secp256k1_fe zi2;\n     secp256k1_fe zi3;\n     secp256k1_fe_sqr(&zi2, zi);\n     secp256k1_fe_mul(&zi3, &zi2, zi);\n@@ -76,7 +126,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     r->y = a->y;\n }\n \n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb) {\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb) {\n     secp256k1_fe *az;\n     secp256k1_fe *azi;\n     size_t i;\n@@ -89,7 +139,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     }\n \n     azi = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * count);\n-    secp256k1_fe_inv_all_var(count, azi, az);\n+    secp256k1_fe_inv_all_var(azi, az, count);\n     free(az);\n \n     count = 0;\n@@ -102,7 +152,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     free(azi);\n }\n \n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr) {\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len) {\n     size_t i = len - 1;\n     secp256k1_fe zi;\n \n@@ -145,9 +195,15 @@ static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp\n \n static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     r->infinity = 1;\n-    secp256k1_fe_set_int(&r->x, 0);\n-    secp256k1_fe_set_int(&r->y, 0);\n-    secp256k1_fe_set_int(&r->z, 0);\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+    secp256k1_fe_clear(&r->z);\n+}\n+\n+static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n+    r->infinity = 1;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n }\n \n static void secp256k1_gej_clear(secp256k1_gej *r) {\n@@ -169,7 +225,7 @@ static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&c, &x3);\n     return secp256k1_fe_sqrt(&r->y, &c);\n }\n@@ -228,7 +284,7 @@ static int secp256k1_gej_is_valid_var(const secp256k1_gej *a) {\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n     secp256k1_fe_sqr(&z2, &a->z);\n     secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n-    secp256k1_fe_mul_int(&z6, 7);\n+    secp256k1_fe_mul_int(&z6, CURVE_B);\n     secp256k1_fe_add(&x3, &z6);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n@@ -242,7 +298,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&x3, &c);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n@@ -260,7 +316,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n-     *  \n+     *\n      *  Having said this, if this function receives a point on a sextic twist, e.g. by\n      *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n      *  since -6 does have a cube root mod p. For this point, this function will not set"
      },
      {
        "sha": "1c67802fba82e60498c560473e9966c161939ffb",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 1,
        "deletions": 33,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -32,7 +32,7 @@\n  * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n  *\n  * <p>To build secp256k1 for use with bitcoinj, run\n- * `./configure --enable-jni --enable-experimental --enable-module-schnorr --enable-module-ecdh`\n+ * `./configure --enable-jni --enable-experimental --enable-module-ecdh`\n  * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n  * or point the JVM to the folder containing it with -Djava.library.path\n  * </p>\n@@ -417,36 +417,6 @@ public static synchronized boolean randomize(byte[] seed) throws AssertFailExcep\n         }\n     }\n \n-    public static byte[] schnorrSign(byte[] data, byte[] sec) throws AssertFailException {\n-        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(data);\n-        byteBuff.put(sec);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_schnorr_sign(byteBuff, Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] sigArr = retByteArray[0];\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-\n-        assertEquals(sigArr.length, 64, \"Got bad signature length.\");\n-\n-        return retVal == 0 ? new byte[0] : sigArr;\n-    }\n-\n     private static native long secp256k1_ctx_clone(long context);\n \n     private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n@@ -471,8 +441,6 @@ public static synchronized boolean randomize(byte[] seed) throws AssertFailExcep\n \n     private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n \n-    private static native byte[][] secp256k1_schnorr_sign(ByteBuffer byteBuff, long context);\n-\n     private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n \n }"
      },
      {
        "sha": "c00d08899b9b004af75a4e98569c460ad83395a1",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -167,22 +167,6 @@ public static void testRandomize() throws AssertFailException {\n         assertEquals( result, true, \"testRandomize\");\n     }\n \n-    /**\n-      * This tests signSchnorr() for a valid secretkey\n-      */\n-    public static void testSchnorrSign() throws AssertFailException{\n-\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.schnorrSign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString, \"C5E929AA058B982048760422D3B563749B7D0E50C5EBD8CD2FFC23214BD6A2F1B072C13880997EBA847CF20F2F90FCE07C1CA33A890A4127095A351127F8D95F\" , \"testSchnorrSign\");\n-    }\n-\n-    /**\n-      * This tests signSchnorr() for a valid secretkey\n-      */\n     public static void testCreateECDHSecret() throws AssertFailException{\n \n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n@@ -216,11 +200,6 @@ public static void main(String[] args) throws AssertFailException{\n         testSignPos();\n         testSignNeg();\n \n-        //Test Schnorr (partial support) //TODO\n-        testSchnorrSign();\n-        //testSchnorrVerify\n-        //testSchnorrRecovery\n-\n         //Test privKeyTweakAdd() 1\n         testPrivKeyTweakAdd_1();\n "
      },
      {
        "sha": "bcef7b32ce3e7fe1587f15dac2e7c56fef998a8a",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 0,
        "deletions": 34,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -5,7 +5,6 @@\n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_ecdh.h\"\n #include \"include/secp256k1_recovery.h\"\n-#include \"include/secp256k1_schnorr.h\"\n \n \n SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n@@ -333,39 +332,6 @@ SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1p\n   return 0;\n }\n \n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  unsigned char* secKey = (unsigned char*) (data + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray sigArray, intsByteArray;\n-  unsigned char intsarray[1];\n-  unsigned char sig[64];\n-\n-  int ret = secp256k1_schnorr_sign(ctx, sig, data, secKey, NULL, NULL);\n-\n-  intsarray[0] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  sigArray = (*env)->NewByteArray(env, 64);\n-  (*env)->SetByteArrayRegion(env, sigArray, 0, 64, (jbyte*)sig);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 1);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n   (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n {"
      },
      {
        "sha": "fe613c9e9e77eddb18e0b0d8422948678f3408a8",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -104,14 +104,6 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n   (JNIEnv *, jclass, jobject, jlong, jint);\n \n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_schnorr_sign\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l);\n-\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdh"
      },
      {
        "sha": "86f2f0cb2b5334baf4fd34e58abe6f8fc4733e32",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -138,23 +138,23 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);"
      },
      {
        "sha": "f1af8e83255fd0c1e0bd7d051dcaed609bae1447",
        "filename": "src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/Makefile.am.include?ref=76fcd9d5034143a5b041766552670d19f926097d",
        "patch": "@@ -1,10 +0,0 @@\n-include_HEADERS += include/secp256k1_schnorr.h\n-noinst_HEADERS += src/modules/schnorr/main_impl.h\n-noinst_HEADERS += src/modules/schnorr/schnorr.h\n-noinst_HEADERS += src/modules/schnorr/schnorr_impl.h\n-noinst_HEADERS += src/modules/schnorr/tests_impl.h\n-if USE_BENCHMARK\n-noinst_PROGRAMS += bench_schnorr_verify\n-bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n-endif"
      },
      {
        "sha": "fa176a1767f5f8388a4960f4eaecabbeb56a4d4a",
        "filename": "src/secp256k1/src/modules/schnorr/main_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 164,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/main_impl.h?ref=76fcd9d5034143a5b041766552670d19f926097d",
        "patch": "@@ -1,164 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_MAIN\n-#define SECP256K1_MODULE_SCHNORR_MAIN\n-\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"modules/schnorr/schnorr_impl.h\"\n-\n-static void secp256k1_schnorr_msghash_sha256(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    secp256k1_sha256_t sha;\n-    secp256k1_sha256_initialize(&sha);\n-    secp256k1_sha256_write(&sha, r32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, h32);\n-}\n-\n-static const unsigned char secp256k1_schnorr_algo16[17] = \"Schnorr+SHA256  \";\n-\n-int secp256k1_schnorr_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    secp256k1_scalar sec, non;\n-    int ret = 0;\n-    int overflow = 0;\n-    unsigned int count = 0;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(seckey != NULL);\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n-    while (1) {\n-        unsigned char nonce32[32];\n-        ret = noncefp(nonce32, msg32, seckey, secp256k1_schnorr_algo16, (void*)noncedata, count);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-        memset(nonce32, 0, 32);\n-        if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, NULL, secp256k1_schnorr_msghash_sha256, msg32)) {\n-                break;\n-            }\n-        }\n-        count++;\n-    }\n-    if (!ret) {\n-        memset(sig64, 0, 64);\n-    }\n-    secp256k1_scalar_clear(&non);\n-    secp256k1_scalar_clear(&sec);\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_pubkey *pubkey) {\n-    secp256k1_ge q;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    secp256k1_pubkey_load(ctx, &q, pubkey);\n-    return secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *sig64, const unsigned char *msg32) {\n-    secp256k1_ge q;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32)) {\n-        secp256k1_pubkey_save(pubkey, &q);\n-        return 1;\n-    } else {\n-        memset(pubkey, 0, sizeof(*pubkey));\n-        return 0;\n-    }\n-}\n-\n-int secp256k1_schnorr_generate_nonce_pair(const secp256k1_context* ctx, secp256k1_pubkey *pubnonce, unsigned char *privnonce32, const unsigned char *sec32, const unsigned char *msg32, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    int count = 0;\n-    int ret = 1;\n-    secp256k1_gej Qj;\n-    secp256k1_ge Q;\n-    secp256k1_scalar sec;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(pubnonce != NULL);\n-    ARG_CHECK(privnonce32 != NULL);\n-\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    do {\n-        int overflow;\n-        ret = noncefp(privnonce32, sec32, msg32, secp256k1_schnorr_algo16, (void*)noncedata, count++);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&sec, privnonce32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-            continue;\n-        }\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &Qj, &sec);\n-        secp256k1_ge_set_gej(&Q, &Qj);\n-\n-        secp256k1_pubkey_save(pubnonce, &Q);\n-        break;\n-    } while(1);\n-\n-    secp256k1_scalar_clear(&sec);\n-    if (!ret) {\n-        memset(pubnonce, 0, sizeof(*pubnonce));\n-    }\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_partial_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *sec32, const secp256k1_pubkey *pubnonce_others, const unsigned char *secnonce32) {\n-    int overflow = 0;\n-    secp256k1_scalar sec, non;\n-    secp256k1_ge pubnon;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(secnonce32 != NULL);\n-    ARG_CHECK(pubnonce_others != NULL);\n-\n-    secp256k1_scalar_set_b32(&sec, sec32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-        return -1;\n-    }\n-    secp256k1_scalar_set_b32(&non, secnonce32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&non)) {\n-        return -1;\n-    }\n-    secp256k1_pubkey_load(ctx, &pubnon, pubnonce_others);\n-    return secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, &pubnon, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_partial_combine(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char * const *sig64sin, size_t n) {\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(n >= 1);\n-    ARG_CHECK(sig64sin != NULL);\n-    return secp256k1_schnorr_sig_combine(sig64, n, sig64sin);\n-}\n-\n-#endif"
      },
      {
        "sha": "de18147bd52ac0f70369114dfcb06947730cbaac",
        "filename": "src/secp256k1/src/modules/schnorr/schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/schnorr.h?ref=76fcd9d5034143a5b041766552670d19f926097d",
        "patch": "@@ -1,20 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_MODULE_SCHNORR_H_\n-#define _SECP256K1_MODULE_SCHNORR_H_\n-\n-#include \"scalar.h\"\n-#include \"group.h\"\n-\n-typedef void (*secp256k1_schnorr_msghash)(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32);\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins);\n-\n-#endif"
      },
      {
        "sha": "e13ab6db7cca1173582c47597d42fb916f43fc22",
        "filename": "src/secp256k1/src/modules/schnorr/schnorr_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 207,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/schnorr_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/schnorr_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/schnorr_impl.h?ref=76fcd9d5034143a5b041766552670d19f926097d",
        "patch": "@@ -1,207 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_SCHNORR_IMPL_H_\n-#define _SECP256K1_SCHNORR_IMPL_H_\n-\n-#include <string.h>\n-\n-#include \"schnorr.h\"\n-#include \"num.h\"\n-#include \"field.h\"\n-#include \"group.h\"\n-#include \"ecmult.h\"\n-#include \"ecmult_gen.h\"\n-\n-/**\n- * Custom Schnorr-based signature scheme. They support multiparty signing, public key\n- * recovery and batch validation.\n- *\n- * Rationale for verifying R's y coordinate:\n- * In order to support batch validation and public key recovery, the full R point must\n- * be known to verifiers, rather than just its x coordinate. In order to not risk\n- * being more strict in batch validation than normal validation, validators must be\n- * required to reject signatures with incorrect y coordinate. This is only possible\n- * by including a (relatively slow) field inverse, or a field square root. However,\n- * batch validation offers potentially much higher benefits than this cost.\n- *\n- * Rationale for having an implicit y coordinate oddness:\n- * If we commit to having the full R point known to verifiers, there are two mechanism.\n- * Either include its oddness in the signature, or give it an implicit fixed value.\n- * As the R y coordinate can be flipped by a simple negation of the nonce, we choose the\n- * latter, as it comes with nearly zero impact on signing or validation performance, and\n- * saves a byte in the signature.\n- *\n- * Signing:\n- *   Inputs: 32-byte message m, 32-byte scalar key x (!=0), 32-byte scalar nonce k (!=0)\n- *\n- *   Compute point R = k * G. Reject nonce if R's y coordinate is odd (or negate nonce).\n- *   Compute 32-byte r, the serialization of R's x coordinate.\n- *   Compute scalar h = Hash(r || m). Reject nonce if h == 0 or h >= order.\n- *   Compute scalar s = k - h * x.\n- *   The signature is (r, s).\n- *\n- *\n- * Verification:\n- *   Inputs: 32-byte message m, public key point Q, signature: (32-byte r, scalar s)\n- *\n- *   Signature is invalid if s >= order.\n- *   Signature is invalid if r >= p.\n- *   Compute scalar h = Hash(r || m). Signature is invalid if h == 0 or h >= order.\n- *   Option 1 (faster for single verification):\n- *     Compute point R = h * Q + s * G. Signature is invalid if R is infinity or R's y coordinate is odd.\n- *     Signature is valid if the serialization of R's x coordinate equals r.\n- *   Option 2 (allows batch validation and pubkey recovery):\n- *     Decompress x coordinate r into point R, with odd y coordinate. Fail if R is not on the curve.\n- *     Signature is valid if R + h * Q + s * G == 0.\n- */\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Rj;\n-    secp256k1_ge Ra;\n-    unsigned char h32[32];\n-    secp256k1_scalar h, s;\n-    int overflow;\n-    secp256k1_scalar n;\n-\n-    if (secp256k1_scalar_is_zero(key) || secp256k1_scalar_is_zero(nonce)) {\n-        return 0;\n-    }\n-    n = *nonce;\n-\n-    secp256k1_ecmult_gen(ctx, &Rj, &n);\n-    if (pubnonce != NULL) {\n-        secp256k1_gej_add_ge(&Rj, &Rj, pubnonce);\n-    }\n-    secp256k1_ge_set_gej(&Ra, &Rj);\n-    secp256k1_fe_normalize(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        /* R's y coordinate is odd, which is not allowed (see rationale above).\n-           Force it to be even by negating the nonce. Note that this even works\n-           for multiparty signing, as the R point is known to all participants,\n-           which can all decide to flip the sign in unison, resulting in the\n-           overall R point to be negated too. */\n-        secp256k1_scalar_negate(&n, &n);\n-    }\n-    secp256k1_fe_normalize(&Ra.x);\n-    secp256k1_fe_get_b32(sig64, &Ra.x);\n-    hash(h32, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, h32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        secp256k1_scalar_clear(&n);\n-        return 0;\n-    }\n-    secp256k1_scalar_mul(&s, &h, key);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_add(&s, &s, &n);\n-    secp256k1_scalar_clear(&n);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    if (secp256k1_ge_is_infinity(pubkey)) {\n-        return 0;\n-    }\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Qj, pubkey);\n-    secp256k1_ecmult(ctx, &Rj, &Qj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Rj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej_var(&Ra, &Rj);\n-    secp256k1_fe_normalize_var(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        return 0;\n-    }\n-    return secp256k1_fe_equal_var(&Rx, &Ra.x);\n-}\n-\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    if (!secp256k1_ge_set_xo_var(&Ra, &Rx, 0)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Rj, &Ra);\n-    secp256k1_scalar_inverse_var(&h, &h);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_mul(&s, &s, &h);\n-    secp256k1_ecmult(ctx, &Qj, &Rj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Qj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej(pubkey, &Qj);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins) {\n-    secp256k1_scalar s = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n-    size_t i;\n-    for (i = 0; i < n; i++) {\n-        secp256k1_scalar si;\n-        int overflow;\n-        secp256k1_scalar_set_b32(&si, sig64ins[i] + 32, &overflow);\n-        if (overflow) {\n-            return -1;\n-        }\n-        if (i) {\n-            if (memcmp(sig64ins[i - 1], sig64ins[i], 32) != 0) {\n-                return -1;\n-            }\n-        }\n-        secp256k1_scalar_add(&s, &s, &si);\n-    }\n-    if (secp256k1_scalar_is_zero(&s)) {\n-        return 0;\n-    }\n-    memcpy(sig64, sig64ins[0], 32);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    secp256k1_scalar_clear(&s);\n-    return 1;\n-}\n-\n-#endif"
      },
      {
        "sha": "5bd14a03e3c65ba99c27e6694352bf9e4d9ab1cd",
        "filename": "src/secp256k1/src/modules/schnorr/tests_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 175,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76fcd9d5034143a5b041766552670d19f926097d/src/secp256k1/src/modules/schnorr/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/tests_impl.h?ref=76fcd9d5034143a5b041766552670d19f926097d",
        "patch": "@@ -1,175 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_TESTS\n-#define SECP256K1_MODULE_SCHNORR_TESTS\n-\n-#include \"include/secp256k1_schnorr.h\"\n-\n-void test_schnorr_end_to_end(void) {\n-    unsigned char privkey[32];\n-    unsigned char message[32];\n-    unsigned char schnorr_signature[64];\n-    secp256k1_pubkey pubkey, recpubkey;\n-\n-    /* Generate a random key and message. */\n-    {\n-        secp256k1_scalar key;\n-        random_scalar_order_test(&key);\n-        secp256k1_scalar_get_b32(privkey, &key);\n-        secp256k1_rand256_test(message);\n-    }\n-\n-    /* Construct and verify corresponding public key. */\n-    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n-    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n-\n-    /* Schnorr sign. */\n-    CHECK(secp256k1_schnorr_sign(ctx, schnorr_signature, message, privkey, NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 1);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) == 1);\n-    CHECK(memcmp(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n-    /* Destroy signature and verify again. */\n-    schnorr_signature[secp256k1_rand_bits(6)] += 1 + secp256k1_rand_int(255);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 0);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) != 1 ||\n-          memcmp(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n-}\n-\n-/** Horribly broken hash function. Do not use for anything but tests. */\n-void test_schnorr_hash(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    int i;\n-    for (i = 0; i < 32; i++) {\n-        h32[i] = r32[i] ^ msg32[i];\n-    }\n-}\n-\n-void test_schnorr_sign_verify(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[3][64];\n-    secp256k1_gej pubkeyj[3];\n-    secp256k1_ge pubkey[3];\n-    secp256k1_scalar nonce[3], key[3];\n-    int i = 0;\n-    int k;\n-\n-    secp256k1_rand256_test(msg32);\n-\n-    for (k = 0; k < 3; k++) {\n-        random_scalar_order_test(&key[k]);\n-\n-        do {\n-            random_scalar_order_test(&nonce[k]);\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64[k], &key[k], &nonce[k], NULL, &test_schnorr_hash, msg32)) {\n-                break;\n-            }\n-        } while(1);\n-\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubkeyj[k], &key[k]);\n-        secp256k1_ge_set_gej_var(&pubkey[k], &pubkeyj[k]);\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32));\n-\n-        for (i = 0; i < 4; i++) {\n-            int pos = secp256k1_rand_bits(6);\n-            int mod = 1 + secp256k1_rand_int(255);\n-            sig64[k][pos] ^= mod;\n-            CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32) == 0);\n-            sig64[k][pos] ^= mod;\n-        }\n-    }\n-}\n-\n-void test_schnorr_threshold(void) {\n-    unsigned char msg[32];\n-    unsigned char sec[5][32];\n-    secp256k1_pubkey pub[5];\n-    unsigned char nonce[5][32];\n-    secp256k1_pubkey pubnonce[5];\n-    unsigned char sig[5][64];\n-    const unsigned char* sigs[5];\n-    unsigned char allsig[64];\n-    const secp256k1_pubkey* pubs[5];\n-    secp256k1_pubkey allpub;\n-    int n, i;\n-    int damage;\n-    int ret = 0;\n-\n-    damage = secp256k1_rand_bits(1) ? (1 + secp256k1_rand_int(4)) : 0;\n-    secp256k1_rand256_test(msg);\n-    n = 2 + secp256k1_rand_int(4);\n-    for (i = 0; i < n; i++) {\n-        do {\n-            secp256k1_rand256_test(sec[i]);\n-        } while (!secp256k1_ec_seckey_verify(ctx, sec[i]));\n-        CHECK(secp256k1_ec_pubkey_create(ctx, &pub[i], sec[i]));\n-        CHECK(secp256k1_schnorr_generate_nonce_pair(ctx, &pubnonce[i], nonce[i], msg, sec[i], NULL, NULL));\n-        pubs[i] = &pub[i];\n-    }\n-    if (damage == 1) {\n-        nonce[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    } else if (damage == 2) {\n-        sec[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    for (i = 0; i < n; i++) {\n-        secp256k1_pubkey allpubnonce;\n-        const secp256k1_pubkey *pubnonces[4];\n-        int j;\n-        for (j = 0; j < i; j++) {\n-            pubnonces[j] = &pubnonce[j];\n-        }\n-        for (j = i + 1; j < n; j++) {\n-            pubnonces[j - 1] = &pubnonce[j];\n-        }\n-        CHECK(secp256k1_ec_pubkey_combine(ctx, &allpubnonce, pubnonces, n - 1));\n-        ret |= (secp256k1_schnorr_partial_sign(ctx, sig[i], msg, sec[i], &allpubnonce, nonce[i]) != 1) * 1;\n-        sigs[i] = sig[i];\n-    }\n-    if (damage == 3) {\n-        sig[secp256k1_rand_int(n)][secp256k1_rand_bits(6)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    ret |= (secp256k1_ec_pubkey_combine(ctx, &allpub, pubs, n) != 1) * 2;\n-    if ((ret & 1) == 0) {\n-        ret |= (secp256k1_schnorr_partial_combine(ctx, allsig, sigs, n) != 1) * 4;\n-    }\n-    if (damage == 4) {\n-        allsig[secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    if ((ret & 7) == 0) {\n-        ret |= (secp256k1_schnorr_verify(ctx, allsig, msg, &allpub) != 1) * 8;\n-    }\n-    CHECK((ret == 0) == (damage == 0));\n-}\n-\n-void test_schnorr_recovery(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[64];\n-    secp256k1_ge Q;\n-\n-    secp256k1_rand256_test(msg32);\n-    secp256k1_rand256_test(sig64);\n-    secp256k1_rand256_test(sig64 + 32);\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1) {\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1);\n-    }\n-}\n-\n-void run_schnorr_tests(void) {\n-    int i;\n-    for (i = 0; i < 32*count; i++) {\n-        test_schnorr_end_to_end();\n-    }\n-    for (i = 0; i < 32 * count; i++) {\n-         test_schnorr_sign_verify();\n-    }\n-    for (i = 0; i < 16 * count; i++) {\n-         test_schnorr_recovery();\n-    }\n-    for (i = 0; i < 10 * count; i++) {\n-         test_schnorr_threshold();\n-    }\n-}\n-\n-#endif"
      },
      {
        "sha": "27e9d8375e8b0dc9977d8b037fb1b4344d027d4c",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -13,7 +13,9 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32.h\""
      },
      {
        "sha": "56e7bd82afd630b107c080b5c96cf50cdbb722f9",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -282,16 +282,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq 56(%%rsi), %%r14\\n\"\n     /* Initialize r8,r9,r10 */\n     \"movq 0(%%rsi), %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += n0 * c0 */\n     \"movq %8, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract m0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += l1 */\n     \"addq 8(%%rsi), %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -309,7 +309,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract m1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += l2 */\n     \"addq 16(%%rsi), %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -332,7 +332,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r9\\n\"\n     /* extract m2 */\n     \"movq %%r10, %q2\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9,r10) += l3 */\n     \"addq 24(%%rsi), %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -355,7 +355,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r10\\n\"\n     /* extract m3 */\n     \"movq %%r8, %q3\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10,r8) += n3 * c1 */\n     \"movq %9, %%rax\\n\"\n     \"mulq %%r14\\n\"\n@@ -387,16 +387,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %q11, %%r13\\n\"\n     /* Initialize (r8,r9,r10) */\n     \"movq %q5, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += m4 * c0 */\n     \"movq %12, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract p0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += m1 */\n     \"addq %q6, %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -414,7 +414,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract p1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += m2 */\n     \"addq %q7, %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -472,7 +472,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %%rax, 0(%q6)\\n\"\n     /* Move to (r8,r9) */\n     \"movq %%rdx, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p1 */\n     \"addq %q2, %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -483,7 +483,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq %%rdx, %%r9\\n\"\n     /* Extract r1 */\n     \"movq %%r8, 8(%q6)\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r8) += p4 */\n     \"addq %%r10, %%r9\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -492,7 +492,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* Extract r2 */\n     \"movq %%r9, 16(%q6)\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p3 */\n     \"addq %q4, %%r8\\n\"\n     \"adcq $0, %%r9\\n\""
      },
      {
        "sha": "f5b2376407bd3b2338e26b1a0bb84cd3fc91660b",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -14,7 +14,9 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low_impl.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64_impl.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32_impl.h\"\n@@ -31,17 +33,37 @@ static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a\n \n /** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */\n static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    static const unsigned char order[32] = {\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,EXHAUSTIVE_TEST_ORDER\n+    };\n+#else\n     static const unsigned char order[32] = {\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n         0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n         0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n     };\n+#endif\n     secp256k1_num_set_bin(r, order, 32);\n }\n #endif\n \n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n+        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n+            *r = i;\n+    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n+     * have a composite group order; fix it in exhaustive_tests.c). */\n+    VERIFY_CHECK(*r != 0);\n+}\n+#else\n     secp256k1_scalar *t;\n     int i;\n     /* First compute x ^ (2^N - 1) for some values of N. */\n@@ -233,9 +255,9 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n }\n \n SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n-    /* d[0] is present and is the lowest word for all representations */\n     return !(a->d[0] & 1);\n }\n+#endif\n \n static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n #if defined(USE_SCALAR_INV_BUILTIN)\n@@ -259,6 +281,18 @@ static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_sc\n }\n \n #ifdef USE_ENDOMORPHISM\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/**\n+ * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the\n+ * full case we don't bother making k1 and k2 be small, we just want them to be\n+ * nontrivial to get full test coverage for the exhaustive tests. We therefore\n+ * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.\n+ */\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r2 = (*a + 5) % EXHAUSTIVE_TEST_ORDER;\n+    *r1 = (*a + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n+}\n+#else\n /**\n  * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where\n  * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n@@ -331,5 +365,6 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n     secp256k1_scalar_add(r1, r1, a);\n }\n #endif\n+#endif\n \n #endif"
      },
      {
        "sha": "5574c44c7aeb3c8d41ec626adcb1b6994b6f05ef",
        "filename": "src/secp256k1/src/scalar_low.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -0,0 +1,15 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef uint32_t secp256k1_scalar;\n+\n+#endif"
      },
      {
        "sha": "4f94441f492a8144ebe579435ead2a66712eea17",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -0,0 +1,114 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+#include \"scalar.h\"\n+\n+#include <string.h>\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(*a & 1);\n+}\n+\n+SECP256K1_INLINE static void secp256k1_scalar_clear(secp256k1_scalar *r) { *r = 0; }\n+SECP256K1_INLINE static void secp256k1_scalar_set_int(secp256k1_scalar *r, unsigned int v) { *r = v; }\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    if (offset < 32)\n+        return ((*a >> offset) & ((((uint32_t)1) << count) - 1));\n+    else\n+        return 0;\n+}\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    return secp256k1_scalar_get_bits(a, offset, count);\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_check_overflow(const secp256k1_scalar *a) { return *a >= EXHAUSTIVE_TEST_ORDER; }\n+\n+static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a + *b) % EXHAUSTIVE_TEST_ORDER;\n+    return *r < *b;\n+}\n+\n+static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n+    if (flag && bit < 32)\n+        *r += (1 << bit);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {\n+    const int base = 0x100 % EXHAUSTIVE_TEST_ORDER;\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < 32; i++) {\n+       *r = ((*r * base) + b32[i]) % EXHAUSTIVE_TEST_ORDER;\n+    }\n+    /* just deny overflow, it basically always happens */\n+    if (overflow) *overflow = 0;\n+}\n+\n+static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {\n+    memset(bin, 0, 32);\n+    bin[28] = *a >> 24; bin[29] = *a >> 16; bin[30] = *a >> 8; bin[31] = *a;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_zero(const secp256k1_scalar *a) {\n+    return *a == 0;\n+}\n+\n+static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    if (*a == 0) {\n+        *r = 0;\n+    } else {\n+        *r = EXHAUSTIVE_TEST_ORDER - *a;\n+    }\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_one(const secp256k1_scalar *a) {\n+    return *a == 1;\n+}\n+\n+static int secp256k1_scalar_is_high(const secp256k1_scalar *a) {\n+    return *a > EXHAUSTIVE_TEST_ORDER / 2;\n+}\n+\n+static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n+    if (flag) secp256k1_scalar_negate(r, r);\n+    return flag ? -1 : 1;\n+}\n+\n+static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a * *b) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n+    int ret;\n+    VERIFY_CHECK(n > 0);\n+    VERIFY_CHECK(n < 16);\n+    ret = *r & ((1 << n) - 1);\n+    *r >>= n;\n+    return ret;\n+}\n+\n+static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    *r = (*a * *a) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r1 = *a;\n+    *r2 = 0;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    return *a == *b;\n+}\n+\n+#endif"
      },
      {
        "sha": "fb8b882faafd36d8b60476e1df024829b32326e0",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -359,23 +359,23 @@ int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, NULL)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);"
      },
      {
        "sha": "9ae7d3028130637ba1159c4c9772cf94267e3711",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -520,7 +520,7 @@ void test_num_mod(void) {\n     secp256k1_num order, n;\n \n     /* check that 0 mod anything is 0 */\n-    random_scalar_order_test(&s); \n+    random_scalar_order_test(&s);\n     secp256k1_scalar_get_num(&order, &s);\n     secp256k1_scalar_set_int(&s, 0);\n     secp256k1_scalar_get_num(&n, &s);\n@@ -535,7 +535,7 @@ void test_num_mod(void) {\n     CHECK(secp256k1_num_is_zero(&n));\n \n     /* check that increasing the number past 2^256 does not break this */\n-    random_scalar_order_test(&s); \n+    random_scalar_order_test(&s);\n     secp256k1_scalar_get_num(&n, &s);\n     /* multiply by 2^8, which'll test this case with high probability */\n     for (i = 0; i < 8; ++i) {\n@@ -568,7 +568,7 @@ void test_num_jacobi(void) {\n     /* we first need a scalar which is not a multiple of 5 */\n     do {\n         secp256k1_num fiven;\n-        random_scalar_order_test(&sqr); \n+        random_scalar_order_test(&sqr);\n         secp256k1_scalar_get_num(&fiven, &five);\n         secp256k1_scalar_get_num(&n, &sqr);\n         secp256k1_num_mod(&n, &fiven);\n@@ -587,7 +587,7 @@ void test_num_jacobi(void) {\n \n     /** test with secp group order as order */\n     secp256k1_scalar_order_get_num(&order);\n-    random_scalar_order_test(&sqr); \n+    random_scalar_order_test(&sqr);\n     secp256k1_scalar_sqr(&sqr, &sqr);\n     /* test residue */\n     secp256k1_scalar_get_num(&n, &sqr);\n@@ -1733,18 +1733,18 @@ void run_field_inv_all_var(void) {\n     secp256k1_fe x[16], xi[16], xii[16];\n     int i;\n     /* Check it's safe to call for 0 elements */\n-    secp256k1_fe_inv_all_var(0, xi, x);\n+    secp256k1_fe_inv_all_var(xi, x, 0);\n     for (i = 0; i < count; i++) {\n         size_t j;\n         size_t len = secp256k1_rand_int(15) + 1;\n         for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n         }\n-        secp256k1_fe_inv_all_var(len, xi, x);\n+        secp256k1_fe_inv_all_var(xi, x, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_inverse(&x[j], &xi[j]));\n         }\n-        secp256k1_fe_inv_all_var(len, xii, xi);\n+        secp256k1_fe_inv_all_var(xii, xi, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_equal(&x[j], &xii[j]));\n         }\n@@ -1930,7 +1930,7 @@ void test_ge(void) {\n                 zs[i] = gej[i].z;\n             }\n         }\n-        secp256k1_fe_inv_all_var(4 * runs + 1, zinv, zs);\n+        secp256k1_fe_inv_all_var(zinv, zs, 4 * runs + 1);\n         free(zs);\n     }\n \n@@ -2050,8 +2050,8 @@ void test_ge(void) {\n                 secp256k1_fe_mul(&zr[i + 1], &zinv[i], &gej[i + 1].z);\n             }\n         }\n-        secp256k1_ge_set_table_gej_var(4 * runs + 1, ge_set_table, gej, zr);\n-        secp256k1_ge_set_all_gej_var(4 * runs + 1, ge_set_all, gej, &ctx->error_callback);\n+        secp256k1_ge_set_table_gej_var(ge_set_table, gej, zr, 4 * runs + 1);\n+        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1, &ctx->error_callback);\n         for (i = 0; i < 4 * runs + 1; i++) {\n             secp256k1_fe s;\n             random_fe_non_zero(&s);"
      },
      {
        "sha": "bda6ee475c9c0fb5c85eb4944f0746107cff6b42",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "added",
        "additions": 329,
        "deletions": 0,
        "changes": 329,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/547a53d13507b3348d216d82353e0d6a9d8fa974/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=547a53d13507b3348d216d82353e0d6a9d8fa974",
        "patch": "@@ -0,0 +1,329 @@\n+/***********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <time.h>\n+\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n+\n+#ifndef EXHAUSTIVE_TEST_ORDER\n+/* see group_impl.h for allowable values */\n+#define EXHAUSTIVE_TEST_ORDER 13\n+#define EXHAUSTIVE_TEST_LAMBDA 9   /* cube root of 1 mod 13 */\n+#endif\n+\n+#include \"include/secp256k1.h\"\n+#include \"group.h\"\n+#include \"secp256k1.c\"\n+#include \"testrand_impl.h\"\n+\n+/** stolen from tests.c */\n+void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    CHECK(secp256k1_fe_equal_var(&a->x, &b->x));\n+    CHECK(secp256k1_fe_equal_var(&a->y, &b->y));\n+}\n+\n+void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n+    secp256k1_fe z2s;\n+    secp256k1_fe u1, u2, s1, s2;\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    /* Check a.x * b.z^2 == b.x && a.y * b.z^3 == b.y, to avoid inverses. */\n+    secp256k1_fe_sqr(&z2s, &b->z);\n+    secp256k1_fe_mul(&u1, &a->x, &z2s);\n+    u2 = b->x; secp256k1_fe_normalize_weak(&u2);\n+    secp256k1_fe_mul(&s1, &a->y, &z2s); secp256k1_fe_mul(&s1, &s1, &b->z);\n+    s2 = b->y; secp256k1_fe_normalize_weak(&s2);\n+    CHECK(secp256k1_fe_equal_var(&u1, &u2));\n+    CHECK(secp256k1_fe_equal_var(&s1, &s2));\n+}\n+\n+void random_fe(secp256k1_fe *x) {\n+    unsigned char bin[32];\n+    do {\n+        secp256k1_rand256(bin);\n+        if (secp256k1_fe_set_b32(x, bin)) {\n+            return;\n+        }\n+    } while(1);\n+}\n+/** END stolen from tests.c */\n+\n+int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+                                      const unsigned char *key32, const unsigned char *algo16,\n+                                      void *data, unsigned int attempt) {\n+    secp256k1_scalar s;\n+    int *idata = data;\n+    (void)msg32;\n+    (void)key32;\n+    (void)algo16;\n+    /* Some nonces cannot be used because they'd cause s and/or r to be zero.\n+     * The signing function has retry logic here that just re-calls the nonce\n+     * function with an increased `attempt`. So if attempt > 0 this means we\n+     * need to change the nonce to avoid an infinite loop. */\n+    if (attempt > 0) {\n+        (*idata)++;\n+    }\n+    secp256k1_scalar_set_int(&s, *idata);\n+    secp256k1_scalar_get_b32(nonce32, &s);\n+    return 1;\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+void test_exhaustive_endomorphism(const secp256k1_ge *group, int order) {\n+    int i;\n+    for (i = 0; i < order; i++) {\n+        secp256k1_ge res;\n+        secp256k1_ge_mul_lambda(&res, &group[i]);\n+        ge_equals_ge(&group[i * EXHAUSTIVE_TEST_LAMBDA % EXHAUSTIVE_TEST_ORDER], &res);\n+    }\n+}\n+#endif\n+\n+void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j;\n+\n+    /* Sanity-check (and check infinity functions) */\n+    CHECK(secp256k1_ge_is_infinity(&group[0]));\n+    CHECK(secp256k1_gej_is_infinity(&groupj[0]));\n+    for (i = 1; i < order; i++) {\n+        CHECK(!secp256k1_ge_is_infinity(&group[i]));\n+        CHECK(!secp256k1_gej_is_infinity(&groupj[i]));\n+    }\n+\n+    /* Check all addition formulae */\n+    for (j = 0; j < order; j++) {\n+        secp256k1_fe fe_inv;\n+        secp256k1_fe_inv(&fe_inv, &groupj[j].z);\n+        for (i = 0; i < order; i++) {\n+            secp256k1_ge zless_gej;\n+            secp256k1_gej tmp;\n+            /* add_var */\n+            secp256k1_gej_add_var(&tmp, &groupj[i], &groupj[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_ge */\n+            if (j > 0) {\n+                secp256k1_gej_add_ge(&tmp, &groupj[i], &group[j]);\n+                ge_equals_gej(&group[(i + j) % order], &tmp);\n+            }\n+            /* add_ge_var */\n+            secp256k1_gej_add_ge_var(&tmp, &groupj[i], &group[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_zinv_var */\n+            zless_gej.infinity = groupj[j].infinity;\n+            zless_gej.x = groupj[j].x;\n+            zless_gej.y = groupj[j].y;\n+            secp256k1_gej_add_zinv_var(&tmp, &groupj[i], &zless_gej, &fe_inv);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+        }\n+    }\n+\n+    /* Check doubling */\n+    for (i = 0; i < order; i++) {\n+        secp256k1_gej tmp;\n+        if (i > 0) {\n+            secp256k1_gej_double_nonzero(&tmp, &groupj[i], NULL);\n+            ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        }\n+        secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+    }\n+\n+    /* Check negation */\n+    for (i = 1; i < order; i++) {\n+        secp256k1_ge tmp;\n+        secp256k1_gej tmpj;\n+        secp256k1_ge_neg(&tmp, &group[i]);\n+        ge_equals_ge(&group[order - i], &tmp);\n+        secp256k1_gej_neg(&tmpj, &groupj[i]);\n+        ge_equals_gej(&group[order - i], &tmpj);\n+    }\n+}\n+\n+void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j, r_log;\n+    for (r_log = 1; r_log < order; r_log++) {\n+        for (j = 0; j < order; j++) {\n+            for (i = 0; i < order; i++) {\n+                secp256k1_gej tmp;\n+                secp256k1_scalar na, ng;\n+                secp256k1_scalar_set_int(&na, i);\n+                secp256k1_scalar_set_int(&ng, j);\n+\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n+\n+                if (i > 0) {\n+                    secp256k1_ecmult_const(&tmp, &group[i], &ng);\n+                    ge_equals_gej(&group[(i * j) % order], &tmp);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n+    secp256k1_fe x;\n+    unsigned char x_bin[32];\n+    k %= EXHAUSTIVE_TEST_ORDER;\n+    x = group[k].x;\n+    secp256k1_fe_normalize(&x);\n+    secp256k1_fe_get_b32(x_bin, &x);\n+    secp256k1_scalar_set_b32(r, x_bin, NULL);\n+}\n+\n+void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* Verify by calling verify */\n+                    secp256k1_ecdsa_signature_save(&sig, &r_s, &s_s);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+            }\n+        }\n+    }\n+\n+    /* We would like to verify zero-knowledge here by counting how often every\n+     * possible (s, r) tuple appears, but because the group order is larger\n+     * than the field order, when coercing the x-values to scalar values, some\n+     * appear more often than others, so we are actually not zero-knowledge.\n+     * (This effect also appears in the real code, but the difference is on the\n+     * order of 1/2^128th the field order, so the deviation is not useful to a\n+     * computationally bounded attacker.)\n+     */\n+}\n+\n+int main(void) {\n+    int i;\n+    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n+    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n+\n+    /* Build context */\n+    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+    /* TODO set z = 1, then do num_tests runs with random z values */\n+\n+    /* Generate the entire group */\n+    secp256k1_gej_set_infinity(&groupj[0]);\n+    secp256k1_ge_set_gej(&group[0], &groupj[0]);\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        /* Set a different random z-value for each Jacobian point */\n+        secp256k1_fe z;\n+        random_fe(&z);\n+\n+        secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n+        secp256k1_ge_set_gej(&group[i], &groupj[i]);\n+        secp256k1_gej_rescale(&groupj[i], &z);\n+\n+        /* Verify against ecmult_gen */\n+        {\n+            secp256k1_scalar scalar_i;\n+            secp256k1_gej generatedj;\n+            secp256k1_ge generated;\n+\n+            secp256k1_scalar_set_int(&scalar_i, i);\n+            secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n+            secp256k1_ge_set_gej(&generated, &generatedj);\n+\n+            CHECK(group[i].infinity == 0);\n+            CHECK(generated.infinity == 0);\n+            CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n+            CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n+        }\n+    }\n+\n+    /* Run the tests */\n+#ifdef USE_ENDOMORPHISM\n+    test_exhaustive_endomorphism(group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+    test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+\n+    return 0;\n+}\n+"
      }
    ]
  }
]