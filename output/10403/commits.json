[
  {
    "sha": "4d2d6045a4784d576d56299244b9f76a5909904b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZDJkNjA0NWE0Nzg0ZDU3NmQ1NjI5OTI0NGI5Zjc2YTU5MDk5MDRi",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-05-15T13:11:03Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-05-15T13:11:03Z"
      },
      "message": "Fix importmulti failure to return rescan errors\n\nAn off-by-one-block bug in importmulti rescan logic could cause it to return\nsuccess in an edge case even when a rescan was not successful. The case where\nthis would happen is if there were multiple blocks in a row with the same\nGetBlockTimeMax() value, and the last block was scanned successfully, but one\nor more of the earlier blocks was not readable.",
      "tree": {
        "sha": "1bdbce291ea8d01c9b47173f04b8fd0dae9ffd98",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1bdbce291ea8d01c9b47173f04b8fd0dae9ffd98"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d2d6045a4784d576d56299244b9f76a5909904b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d2d6045a4784d576d56299244b9f76a5909904b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4d2d6045a4784d576d56299244b9f76a5909904b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d2d6045a4784d576d56299244b9f76a5909904b/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "41987aa92f0d6c0bee4d4b4889355fbd1dedeede",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41987aa92f0d6c0bee4d4b4889355fbd1dedeede",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/41987aa92f0d6c0bee4d4b4889355fbd1dedeede"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 34,
      "deletions": 29
    },
    "files": [
      {
        "sha": "37cdaf121ec524d906915d06fba955d638d622b6",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 5,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d2d6045a4784d576d56299244b9f76a5909904b/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d2d6045a4784d576d56299244b9f76a5909904b/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=4d2d6045a4784d576d56299244b9f76a5909904b",
        "patch": "@@ -1121,13 +1121,13 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     if (fRescan && fRunScan && requests.size()) {\n         CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(std::max<int64_t>(nLowestTimestamp - TIMESTAMP_WINDOW, 0)) : chainActive.Genesis();\n-        CBlockIndex* scannedRange = nullptr;\n+        CBlockIndex* scanFailed = nullptr;\n         if (pindex) {\n-            scannedRange = pwallet->ScanForWalletTransactions(pindex, true);\n+            scanFailed = pwallet->ScanForWalletTransactions(pindex, true);\n             pwallet->ReacceptWalletTransactions();\n         }\n \n-        if (!scannedRange || scannedRange->nHeight > pindex->nHeight) {\n+        if (scanFailed) {\n             std::vector<UniValue> results = response.getValues();\n             response.clear();\n             response.setArray();\n@@ -1137,12 +1137,23 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                 // range, or if the import result already has an error set, let\n                 // the result stand unmodified. Otherwise replace the result\n                 // with an error message.\n-                if (GetImportTimestamp(request, now) - TIMESTAMP_WINDOW >= scannedRange->GetBlockTimeMax() || results.at(i).exists(\"error\")) {\n+                if (GetImportTimestamp(request, now) - TIMESTAMP_WINDOW > scanFailed->GetBlockTimeMax() || results.at(i).exists(\"error\")) {\n                     response.push_back(results.at(i));\n                 } else {\n                     UniValue result = UniValue(UniValue::VOBJ);\n                     result.pushKV(\"success\", UniValue(false));\n-                    result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, strprintf(\"Failed to rescan before time %d, transactions may be missing.\", scannedRange->GetBlockTimeMax())));\n+                    result.pushKV(\n+                        \"error\",\n+                        JSONRPCError(\n+                            RPC_MISC_ERROR,\n+                            strprintf(\"Rescan failed for key with creation timestamp %d. There was an error reading a \"\n+                                      \"block from time %d, which is after or within %d seconds of key creation, and \"\n+                                      \"could contain transactions pertaining to the key. As a result, transactions \"\n+                                      \"and coins using this key may not appear in the wallet. This error could be \"\n+                                      \"caused by pruning or data corruption (see bitcoind log for details) and could \"\n+                                      \"be dealt with by downloading and rescanning the relevant blocks (see -reindex \"\n+                                      \"and -rescan options).\",\n+                                GetImportTimestamp(request, now), scanFailed->GetBlockTimeMax(), TIMESTAMP_WINDOW)));\n                     response.push_back(std::move(result));\n                 }\n                 ++i;"
      },
      {
        "sha": "bdfebd6b73039595995145457307494e364b4120",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d2d6045a4784d576d56299244b9f76a5909904b/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d2d6045a4784d576d56299244b9f76a5909904b/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=4d2d6045a4784d576d56299244b9f76a5909904b",
        "patch": "@@ -364,6 +364,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     LOCK(cs_main);\n \n     // Cap last block file size, and mine new block in a new block file.\n+    CBlockIndex* const nullBlock = nullptr;\n     CBlockIndex* oldTip = chainActive.Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n@@ -375,7 +376,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n         CWallet wallet;\n         LOCK(wallet.cs_wallet);\n         wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n-        BOOST_CHECK_EQUAL(oldTip, wallet.ScanForWalletTransactions(oldTip));\n+        BOOST_CHECK_EQUAL(nullBlock, wallet.ScanForWalletTransactions(oldTip));\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 100 * COIN);\n     }\n \n@@ -389,7 +390,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n         CWallet wallet;\n         LOCK(wallet.cs_wallet);\n         wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n-        BOOST_CHECK_EQUAL(newTip, wallet.ScanForWalletTransactions(oldTip));\n+        BOOST_CHECK_EQUAL(oldTip, wallet.ScanForWalletTransactions(oldTip));\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 50 * COIN);\n     }\n \n@@ -413,28 +414,25 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n         CKey futureKey;\n         futureKey.MakeNewKey(true);\n         key.pushKV(\"scriptPubKey\", HexStr(GetScriptForRawPubKey(futureKey.GetPubKey())));\n-        key.pushKV(\"timestamp\", newTip->GetBlockTimeMax() + TIMESTAMP_WINDOW);\n+        key.pushKV(\"timestamp\", newTip->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1);\n         key.pushKV(\"internal\", UniValue(true));\n         keys.push_back(key);\n         JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back(keys);\n \n         UniValue response = importmulti(request);\n-        BOOST_CHECK_EQUAL(response.write(), strprintf(\"[{\\\"success\\\":false,\\\"error\\\":{\\\"code\\\":-1,\\\"message\\\":\\\"Failed to rescan before time %d, transactions may be missing.\\\"}},{\\\"success\\\":true}]\", newTip->GetBlockTimeMax()));\n+        BOOST_CHECK_EQUAL(response.write(),\n+            strprintf(\"[{\\\"success\\\":false,\\\"error\\\":{\\\"code\\\":-1,\\\"message\\\":\\\"Rescan failed for key with creation \"\n+                      \"timestamp %d. There was an error reading a block from time %d, which is after or within %d \"\n+                      \"seconds of key creation, and could contain transactions pertaining to the key. As a result, \"\n+                      \"transactions and coins using this key may not appear in the wallet. This error could be caused \"\n+                      \"by pruning or data corruption (see bitcoind log for details) and could be dealt with by \"\n+                      \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n+                      \"options).\\\"}},{\\\"success\\\":true}]\",\n+                              0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n         ::pwalletMain = backup;\n     }\n-\n-    // Verify ScanForWalletTransactions does not return null when the scan is\n-    // elided due to the nTimeFirstKey optimization.\n-    {\n-        CWallet wallet;\n-        {\n-            LOCK(wallet.cs_wallet);\n-            wallet.UpdateTimeFirstKey(newTip->GetBlockTime() + 7200 + 1);\n-        }\n-        BOOST_CHECK_EQUAL(newTip, wallet.ScanForWalletTransactions(newTip));\n-    }\n }\n \n // Check that GetImmatureCredit() returns a newly calculated value instead of"
      },
      {
        "sha": "e93708209c3dd26ca89f955b867015aadbd2e4d9",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 9,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d2d6045a4784d576d56299244b9f76a5909904b/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d2d6045a4784d576d56299244b9f76a5909904b/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=4d2d6045a4784d576d56299244b9f76a5909904b",
        "patch": "@@ -1456,18 +1456,17 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n- * Returns pointer to the first block in the last contiguous range that was\n- * successfully scanned or elided (elided if pIndexStart points at a block\n- * before CWallet::nTimeFirstKey). Returns null if there is no such range, or\n- * the range doesn't include chainActive.Tip().\n+ * Returns null if scan was successful. Otherwise, if a complete rescan was not\n+ * possible (due to pruning or corruption), returns pointer to the most recent\n+ * block that could not be scanned.\n  */\n CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n \n     CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = pindexStart;\n+    CBlockIndex* ret = nullptr;\n     {\n         LOCK2(cs_main, cs_wallet);\n         fAbortRescan = false;\n@@ -1495,11 +1494,8 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n                     AddToWalletIfInvolvingMe(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n                 }\n-                if (!ret) {\n-                    ret = pindex;\n-                }\n             } else {\n-                ret = nullptr;\n+                ret = pindex;\n             }\n             pindex = chainActive.Next(pindex);\n         }"
      }
    ]
  }
]