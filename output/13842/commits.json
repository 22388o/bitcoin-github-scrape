[
  {
    "sha": "6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YWJkOWJkYmZkMWFjNjQ2ZDIzOWIzNGM3YzllYjA5ZTEzNmE4MTc2",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-08-02T02:04:29Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-08-02T02:04:29Z"
      },
      "message": "Squashed 'src/tinyformat/' content from commit 689695cf5\n\ngit-subtree-dir: src/tinyformat\ngit-subtree-split: 689695cf58700e6defe3741829564cd682d5ae57",
      "tree": {
        "sha": "548dc3ae82e7f5457a9da0bcba18485a424c5397",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/548dc3ae82e7f5457a9da0bcba18485a424c5397"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [],
    "stats": {
      "total": 2303,
      "additions": 2303,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6e87896d0ebe4ee027ce8332614dcbd2fc06d1d8",
        "filename": ".gitignore",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,3 @@\n+_bloat_test_tmp*\n+tinyformat_test_cxx*\n+tinyformat_speed_test"
      },
      {
        "sha": "75409d435342848dc3a5ea4b5ef863998765311d",
        "filename": ".travis.yml",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,196 @@\n+language: cpp\n+\n+sudo: false\n+\n+# C'mon Travis, you're a great service, but why do I need a script to generate my build matrix?\n+\n+# cat $0 | sed -e 's/^\\(.\\)/# \\1/' -e 's/^$/#/'\n+#\n+# cat <<EOF\n+# matrix:\n+#   include:\n+#\n+# EOF\n+#\n+#\n+# for os in linux ; do\n+#     for compiler in g++-5 clang++-3.8 ; do\n+#         for buildtype in Release Debug ; do\n+#             for std in c++98 c++11 ; do\n+# cat <<EOF\n+#     - os: $os\n+#       compiler: $compiler\n+#       env:\n+#         - CXX_STD=$std\n+#         - COMPILER=$compiler\n+#         - BUILD_TYPE=$buildtype\n+# EOF\n+#                 if [[ $os == linux ]] ; then\n+# cat <<EOF\n+#       addons:\n+#         apt:\n+#           sources:\n+#             - ubuntu-toolchain-r-test\n+#             - llvm-toolchain-precise-3.8\n+#           packages:\n+#             - $compiler\n+# EOF\n+#                 fi\n+#                 echo\n+#             done\n+#         done\n+#     done\n+# done\n+matrix:\n+  include:\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Release\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Release\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Debug\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Debug\n+\n+\n+before_script:\n+  - cmake --version\n+\n+script:\n+  - mkdir build\n+  - cd build\n+  - cmake -DCMAKE_CXX_COMPILER=$COMPILER -DCMAKE_BUILD_TYPE=$BUILD_TYPE -DCXX_STD=$CXX_STD ..\n+  - make testall\n+"
      },
      {
        "sha": "391d1768f5c47f228c9ab86e1a36133fe208aac2",
        "filename": "CMakeLists.txt",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/CMakeLists.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/CMakeLists.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CMakeLists.txt?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,41 @@\n+# CMake build for tests.\n+#\n+# See also the Makefile, which is currently more fully featured on unix.\n+\n+\n+# Set cmake builtin variables before calling project(), otherwise the\n+# cmake-provided defaults will get in first!\n+set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING\n+    \"Choose the type of build, options are: None(CMAKE_CXX_FLAGS or CMAKE_C_FLAGS used) Debug Release RelWithDebInfo MinSizeRel.\"\n+)\n+\n+set(CXX_STD \"c++11\" CACHE STRING \"Version of C++ standard in use\")\n+\n+# This project is infrastructure.  Warnings from common warning levels should\n+# be errors on all compilers, unless explicitly silenced.\n+if(NOT WIN32)\n+    set(CMAKE_CXX_FLAGS \"-Wall -Werror -std=${CXX_STD}\" CACHE STRING \"Flags used by the compiler during all build types.\")\n+endif()\n+\n+project(tinyformat)\n+cmake_minimum_required(VERSION 2.8)\n+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n+\n+if(WIN32)\n+    # Treat warnings as errors.  Would set this above, but need the default\n+    # flags too, and `project()` behaves is differently on different systems.\n+    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /W3 /WX\")\n+endif()\n+\n+add_executable(tinyformat_test tinyformat_test.cpp)\n+enable_testing()\n+if(CMAKE_CONFIGURATION_TYPES)\n+    set(ctest_config_opt -C ${CMAKE_BUILD_TYPE})\n+endif()\n+add_test(NAME test COMMAND tinyformat_test)\n+add_custom_target(testall COMMAND ${CMAKE_CTEST_COMMAND} -V ${ctest_config_opt} DEPENDS tinyformat_test)\n+\n+option(COMPILE_SPEED_TEST FALSE)\n+if (COMPILE_SPEED_TEST)\n+    add_executable(tinyformat_speed_test tinyformat_speed_test.cpp)\n+endif ()"
      },
      {
        "sha": "6cef5f568f589c1a70685631bf3feb82c54f006b",
        "filename": "Makefile",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,56 @@\n+# Build and run the unit tests (or speed tests) on linux\n+#\n+# Should work with recent versions of both gcc and clang.  (To compile with\n+# clang use \"make CXX=clang++\".)\n+\n+CXXFLAGS?=-Wall -Werror\n+CXX11FLAGS?=-std=c++11\n+\n+test: tinyformat_test_cxx98 tinyformat_test_cxx11\n+\t@echo running tests...\n+\t@./tinyformat_test_cxx98 && \\\n+\t\t./tinyformat_test_cxx11 && \\\n+\t\t! $(CXX) $(CXXFLAGS) -std=c++98 -DTINYFORMAT_NO_VARIADIC_TEMPLATES \\\n+\t\t-DTEST_WCHAR_T_COMPILE tinyformat_test.cpp 2> /dev/null && \\\n+\t\techo \"No errors\" || echo \"Tests failed\"\n+\n+doc: tinyformat.html\n+\n+speed_test: tinyformat_speed_test\n+\t@echo running speed tests...\n+\t@echo printf timings:\n+\t@time -p ./tinyformat_speed_test printf > /dev/null\n+\t@echo iostreams timings:\n+\t@time -p ./tinyformat_speed_test iostreams > /dev/null\n+\t@echo tinyformat timings:\n+\t@time -p ./tinyformat_speed_test tinyformat > /dev/null\n+\t@echo boost timings:\n+\t@time -p ./tinyformat_speed_test boost > /dev/null\n+\n+tinyformat_test_cxx98: tinyformat.h tinyformat_test.cpp Makefile\n+\t$(CXX) $(CXXFLAGS) -std=c++98 -DTINYFORMAT_NO_VARIADIC_TEMPLATES tinyformat_test.cpp -o tinyformat_test_cxx98\n+\n+tinyformat_test_cxx11: tinyformat.h tinyformat_test.cpp Makefile\n+\t$(CXX) $(CXXFLAGS) $(CXX11FLAGS) -DTINYFORMAT_USE_VARIADIC_TEMPLATES tinyformat_test.cpp -o tinyformat_test_cxx11\n+\n+tinyformat.html: README.rst\n+\t@echo building docs...\n+\trst2html.py README.rst > tinyformat.html\n+\n+tinyformat_speed_test: tinyformat.h tinyformat_speed_test.cpp Makefile\n+\t$(CXX) $(CXXFLAGS) -O3 -DNDEBUG tinyformat_speed_test.cpp -o tinyformat_speed_test\n+\n+bloat_test:\n+\t@for opt in '' '-O3 -DNDEBUG' ; do \\\n+\t\tfor use in '' '-DUSE_IOSTREAMS' '-DUSE_TINYFORMAT' '-DUSE_TINYFORMAT $(CXX11FLAGS)' '-DUSE_BOOST' ; do \\\n+\t\t\techo ; \\\n+\t\t\techo ./bloat_test.sh $(CXX) $$opt $$use ; \\\n+\t\t\t./bloat_test.sh $(CXX) $$opt $$use ; \\\n+\t\tdone ; \\\n+\tdone\n+\n+\n+clean:\n+\trm -f tinyformat_test_cxx98 tinyformat_test_cxx11 tinyformat_speed_test\n+\trm -f tinyformat.html\n+\trm -f _bloat_test_tmp_*"
      },
      {
        "sha": "966f4b59dc17cf926a093644b07e14c434c93232",
        "filename": "README.md",
        "status": "added",
        "additions": 452,
        "deletions": 0,
        "changes": 452,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,452 @@\n+# tinyformat.h\n+\n+## A minimal type safe printf() replacement\n+\n+**tinyformat.h** is a type safe printf replacement library in a single C++\n+header file.  If you've ever wanted `printf(\"%s\", s)` to just work regardless\n+of the type of `s`, tinyformat might be for you.  Design goals include:\n+\n+* Type safety and extensibility for user defined types.\n+* C99 `printf()` compatibility, to the extent possible using `std::ostream`\n+* Simplicity and minimalism.  A single header file to include and distribute\n+  with your projects.\n+* Augment rather than replace the standard stream formatting mechanism\n+* C++98 support, with optional C++11 niceties\n+\n+Build status, master branch:\n+[![Linux/OSX build](https://travis-ci.org/c42f/tinyformat.svg?branch=master)](https://travis-ci.org/c42f/tinyformat)\n+[![Windows build](https://ci.appveyor.com/api/projects/status/rwxqhhy6v5m0p1aq/branch/master?svg=true)](https://ci.appveyor.com/project/c42f/tinyformat/branch/master)\n+\n+## Quickstart\n+\n+To print a date to `std::cout`:\n+\n+```C++\n+std::string weekday = \"Wednesday\";\n+const char* month = \"July\";\n+size_t day = 27;\n+long hour = 14;\n+int min = 44;\n+\n+tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n+```\n+\n+The strange types here emphasize the type safety of the interface, for example\n+it is possible to print a `std::string` using the `\"%s\"` conversion, and a\n+`size_t` using the `\"%d\"` conversion.  A similar result could be achieved\n+using either of the `tfm::format()` functions.  One prints on a user provided\n+stream:\n+\n+```C++\n+tfm::format(std::cerr, \"%s, %s %d, %.2d:%.2d\\n\",\n+            weekday, month, day, hour, min);\n+```\n+\n+The other returns a `std::string`:\n+\n+```C++\n+std::string date = tfm::format(\"%s, %s %d, %.2d:%.2d\\n\",\n+                               weekday, month, day, hour, min);\n+std::cout << date;\n+```\n+\n+\n+It is safe to use tinyformat inside a template function.  For any type which\n+has the usual stream insertion `operator<<` defined, the following will work\n+as desired:\n+\n+```C++\n+template<typename T>\n+void myPrint(const T& value)\n+{\n+    tfm::printf(\"My value is '%s'\\n\", value);\n+}\n+```\n+\n+(The above is a compile error for types `T` without a stream insertion\n+operator.)\n+\n+\n+## Function reference\n+\n+All user facing functions are defined in the namespace `tinyformat`.  A\n+namespace alias `tfm` is provided to encourage brevity, but can easily be\n+disabled if desired.\n+\n+Three main interface functions are available: an iostreams-based `format()`,\n+a string-based `format()` and a `printf()` replacement.  These functions\n+can be thought of as C++ replacements for C's `fprintf()`, `sprintf()` and\n+`printf()` functions respectively.  All the interface functions can take an\n+unlimited number of input arguments if compiled with C++11 variadic templates\n+support.  In C++98 mode, the number of arguments must be limited to some fixed\n+upper bound which is currently 16 as of version 1.3. Supporting more arguments\n+is quite easy using the in-source code generator based on\n+[cog.py](http://nedbatchelder.com/code/cog) - see the source for details.\n+\n+The `format()` function which takes a stream as the first argument is the\n+main part of the tinyformat interface.  `stream` is the output stream,\n+`formatString` is a format string in C99 `printf()` format, and the values\n+to be formatted have arbitrary types:\n+\n+```C++\n+template<typename... Args>\n+void format(std::ostream& stream, const char* formatString,\n+            const Args&... args);\n+```\n+\n+The second version of `format()` is a convenience function which returns a\n+`std::string` rather than printing onto a stream.  This function simply\n+calls the main version of `format()` using a `std::ostringstream`, and\n+returns the resulting string:\n+\n+```C++\n+template<typename... Args>\n+std::string format(const char* formatString, const Args&... args);\n+```\n+\n+Finally, `printf()` and `printfln()` are convenience functions which call\n+`format()` with `std::cout` as the first argument; both have the same\n+signature:\n+\n+```C++\n+template<typename... Args>\n+void printf(const char* formatString, const Args&... args);\n+```\n+\n+`printfln()` is the same as `printf()` but appends an additional newline\n+for convenience - a concession to the author's tendency to forget the newline\n+when using the library for simple logging.\n+\n+## Format strings and type safety\n+\n+Tinyformat parses C99 format strings to guide the formatting process --- please\n+refer to any standard C99 printf documentation for format string syntax.  In\n+contrast to printf, tinyformat does not use the format string to decide on\n+the type to be formatted so this does not compromise the type safety: *you may\n+use any format specifier with any C++ type*.  The author suggests standardising\n+on the `%s` conversion unless formatting numeric types.\n+\n+Let's look at what happens when you execute the function call:\n+\n+```C++\n+tfm::format(outStream, \"%+6.4f\", yourType);\n+```\n+\n+First, the library parses the format string, and uses it to modify the state of\n+`outStream`:\n+\n+1. The `outStream` formatting flags are cleared and the width, precision and\n+   fill reset to the default.\n+2. The flag `'+'` means to prefix positive numbers with a `'+'`; tinyformat\n+   executes `outStream.setf(std::ios::showpos)`\n+3. The number 6 gives the field width; execute `outStream.width(6)`.\n+4. The number 4 gives the precision; execute `outStream.precision(4)`.\n+5. The conversion specification character `'f'` means that floats should be\n+   formatted with a fixed number of digits; this corresponds to executing\n+   `outStream.setf(std::ios::fixed, std::ios::floatfield);`\n+\n+After all these steps, tinyformat executes:\n+\n+```C++\n+outStream << yourType;\n+```\n+\n+and finally restores the stream flags, precision and fill.\n+\n+What happens if `yourType` isn't actually a floating point type?  In this\n+case the flags set above are probably irrelevant and will be ignored by the\n+underlying `std::ostream` implementation.  The field width of six may cause\n+some padding in the output of `yourType`, but that's about it.\n+\n+\n+### Special cases for \"%p\", \"%c\" and \"%s\"\n+\n+Tinyformat normally uses `operator<<` to convert types to strings.  However,\n+the \"%p\" and \"%c\" conversions require special rules for robustness.  Consider:\n+\n+```C++\n+uint8_t* pixels = get_pixels(/* ... */);\n+tfm::printf(\"%p\", pixels);\n+```\n+\n+Clearly the intention here is to print a representation of the *pointer* to\n+`pixels`, but since `uint8_t` is a character type the compiler would\n+attempt to print it as a C string if we blindly fed it into `operator<<`.  To\n+counter this kind of madness, tinyformat tries to static_cast any type fed to\n+the \"%p\" conversion into a `const void*` before printing.  If this can't be\n+done at compile time the library falls back to using `operator<<` as usual.\n+\n+The \"%c\" conversion has a similar problem: it signifies that the given integral\n+type should be converted into a `char` before printing.  The solution is\n+identical: attempt to convert the provided type into a char using\n+`static_cast` if possible, and if not fall back to using `operator<<`.\n+\n+The \"%s\" conversion sets the boolalpha flag on the formatting stream.  This\n+means that a `bool` variable printed with \"%s\" will come out as `true` or\n+`false` rather than the `1` or `0` that you would otherwise get.\n+\n+\n+### Incompatibilities with C99 printf\n+\n+Not all features of printf can be simulated simply using standard iostreams.\n+Here's a list of known incompatibilities:\n+\n+* The C99 `\"%a\"` and `\"%A\"` hexadecimal floating point conversions are not\n+  supported since the iostreams don't have the necessary flags.  Using either\n+  of these flags will result in a call to `TINYFORMAT_ERROR`.\n+* The precision for integer conversions cannot be supported by the iostreams\n+  state independently of the field width.  (Note: **this is only a\n+  problem for certain obscure integer conversions**; float conversions like\n+  `%6.4f` work correctly.)  In tinyformat the field width takes precedence,\n+  so the 4 in `%6.4d` will be ignored.  However, if the field width is not\n+  specified, the width used internally is set equal to the precision and padded\n+  with zeros on the left.  That is, a conversion like `%.4d` effectively\n+  becomes `%04d` internally.  This isn't correct for every case (eg, negative\n+  numbers end up with one less digit than desired) but it's about the closest\n+  simple solution within the iostream model.\n+* The `\"%n\"` query specifier isn't supported to keep things simple and will\n+  result in a call to `TINYFORMAT_ERROR`.\n+* The `\"%ls\"` conversion is not supported, and attempting to format a\n+  `wchar_t` array will cause a compile time error to minimise unexpected\n+  surprises.  If you know the encoding of your wchar_t strings, you could write\n+  your own `std::ostream` insertion operator for them, and disable the\n+  compile time check by defining the macro `TINYFORMAT_ALLOW_WCHAR_STRINGS`.\n+  If you want to print the *address* of a wide character with the `\"%p\"`\n+  conversion, you should cast it to a `void*` before passing it to one of the\n+  formatting functions.\n+\n+\n+## Error handling\n+\n+By default, tinyformat calls `assert()` if it encounters an error in the\n+format string or number of arguments.  This behaviour can be changed (for\n+example, to throw an exception) by defining the `TINYFORMAT_ERROR` macro\n+before including tinyformat.h, or editing the config section of the header.\n+\n+\n+## Formatting user defined types\n+\n+User defined types with a stream insertion operator will be formatted using\n+`operator<<(std::ostream&, T)` by default.  The `\"%s\"` format specifier is\n+suggested for user defined types, unless the type is inherently numeric.\n+\n+For further customization, the user can override the `formatValue()`\n+function to specify formatting independently of the stream insertion operator.\n+If you override this function, the library will have already parsed the format\n+specification and set the stream flags accordingly - see the source for details.\n+\n+\n+## Wrapping tfm::format() inside a user defined format function\n+\n+Suppose you wanted to define your own function which wraps `tfm::format`.\n+For example, consider an error function taking an error code, which in C++11\n+might be written simply as:\n+\n+```C++\n+template<typename... Args>\n+void error(int code, const char* fmt, const Args&... args)\n+{\n+    std::cerr << \"error (code \" << code << \")\";\n+    tfm::format(std::cerr, fmt, args...);\n+}\n+```\n+\n+Simulating this functionality in C++98 is pretty painful since it requires\n+writing out a version of `error()` for each desired number of arguments.  To\n+make this bearable tinyformat comes with a set of macros which are used\n+internally to generate the API, but which may also be used in user code.\n+\n+The three macros `TINYFORMAT_ARGTYPES(n)`, `TINYFORMAT_VARARGS(n)` and\n+`TINYFORMAT_PASSARGS(n)` will generate a list of `n` argument types,\n+type/name pairs and argument names respectively when called with an integer\n+`n` between 1 and 16.  We can use these to define a macro which generates the\n+desired user defined function with `n` arguments.  This should be followed by\n+a call to `TINYFORMAT_FOREACH_ARGNUM` to generate the set of functions for\n+all supported `n`:\n+\n+```C++\n+#define MAKE_ERROR_FUNC(n)                                    \\\n+template<TINYFORMAT_ARGTYPES(n)>                              \\\n+void error(int code, const char* fmt, TINYFORMAT_VARARGS(n))  \\\n+{                                                             \\\n+    std::cerr << \"error (code \" << code << \")\";               \\\n+    tfm::format(std::cerr, fmt, TINYFORMAT_PASSARGS(n));      \\\n+}\n+TINYFORMAT_FOREACH_ARGNUM(MAKE_ERROR_FUNC)\n+```\n+\n+Sometimes it's useful to be able to pass a list of format arguments through to\n+a non-template function.  The `FormatList` class is provided as a way to do\n+this by storing the argument list in a type-opaque way.  For example:\n+\n+```C++\n+template<typename... Args>\n+void error(int code, const char* fmt, const Args&... args)\n+{\n+    tfm::FormatListRef formatList = tfm::makeFormatList(args...);\n+    errorImpl(code, fmt, formatList);\n+}\n+```\n+\n+What's interesting here is that `errorImpl()` is a non-template function so\n+it could be separately compiled if desired.  The `FormatList` instance can be\n+used via a call to the `vformat()` function (the name chosen for semantic\n+similarity to `vprintf()`):\n+\n+```C++\n+void errorImpl(int code, const char* fmt, tfm::FormatListRef formatList)\n+{\n+    std::cerr << \"error (code \" << code << \")\";\n+    tfm::vformat(std::cout, fmt, formatList);\n+}\n+```\n+\n+The construction of a `FormatList` instance is very lightweight - it defers\n+all formatting and simply stores a couple of function pointers and a value\n+pointer per argument.  Since most of the actual work is done inside\n+`vformat()`, any logic which causes an early exit of `errorImpl()` -\n+filtering of verbose log messages based on error code for example - could be a\n+useful optimization for programs using tinyformat.  (A faster option would be\n+to write any early bailout code inside `error()`, though this must be done in\n+the header.)\n+\n+\n+## Benchmarks\n+\n+### Compile time and code bloat\n+\n+The script `bloat_test.sh` included in the repository tests whether\n+tinyformat succeeds in avoiding compile time and code bloat for nontrivial\n+projects.  The idea is to include `tinyformat.h` into 100 translation units\n+and use `printf()` five times in each to simulate a medium sized project.\n+The resulting executable size and compile time (g++-4.8.2, linux ubuntu 14.04)\n+is shown in the following tables, which can be regenerated using `make\n+bloat_test`:\n+\n+**Non-optimized build**\n+\n+| test name              | compiler wall time | executable size (stripped) |\n+| ---------------------- | ------------------ | -------------------------- |\n+| libc printf            | 1.8s               | 48K  (36K)                 |\n+| std::ostream           | 10.7s              | 96K  (76K)                 |\n+| tinyformat, no inlines | 18.9s              | 140K (104K)                |\n+| tinyformat             | 21.1s              | 220K (180K)                |\n+| tinyformat, c++0x mode | 20.7s              | 220K (176K)                |\n+| boost::format          | 70.1s              | 844K (736K)                |\n+\n+**Optimized build (-O3 -DNDEBUG)**\n+\n+| test name              | compiler wall time | executable size (stripped) |\n+| ---------------------- | ------------------ | -------------------------- |\n+| libc printf            | 2.3s               | 40K  (28K)                 |\n+| std::ostream           | 11.8s              | 104K (80K)                 |\n+| tinyformat, no inlines | 23.0s              | 128K (104K)                |\n+| tinyformat             | 32.9s              | 128K (104K)                |\n+| tinyformat, c++0x mode | 34.0s              | 128K (104K)                |\n+| boost::format          | 147.9s             | 644K (600K)                |\n+\n+For large projects it's arguably worthwhile to do separate compilation of the\n+non-templated parts of tinyformat, as shown in the rows labelled *tinyformat,\n+no inlines*.  These were generated by putting the implementation of `vformat`\n+(`detail::formatImpl()` etc) it into a separate file, tinyformat.cpp.  Note\n+that the results above can vary considerably with different compilers.  For\n+example, the `-fipa-cp-clone` optimization pass in g++-4.6 resulted in\n+excessively large binaries.  On the other hand, the g++-4.8 results are quite\n+similar to using clang++-3.4.\n+\n+\n+### Speed tests\n+\n+The following speed tests results were generated by building\n+`tinyformat_speed_test.cpp` on an Intel core i7-2600K running Linux Ubuntu\n+14.04 with g++-4.8.2 using `-O3 -DNDEBUG`.  In the test, the format string\n+`\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\"` is filled 2000000 times with output sent to\n+`/dev/null`; for further details see the source and Makefile.\n+\n+| test name      | run time |\n+| -------------- | -------- |\n+| libc printf    | 1.20s    |\n+| std::ostream   | 1.82s    |\n+| tinyformat     | 2.08s    |\n+| boost::format  | 9.04s    |\n+\n+It's likely that tinyformat has an advantage over boost.format because it tries\n+reasonably hard to avoid formatting into temporary strings, preferring instead\n+to send the results directly to the stream buffer.  Tinyformat cannot\n+be faster than the iostreams because it uses them internally, but it comes\n+acceptably close.\n+\n+\n+## Rationale\n+\n+Or, why did I reinvent this particularly well studied wheel?\n+\n+Nearly every program needs text formatting in some form but in many cases such\n+formatting is *incidental* to the main purpose of the program.  In these cases,\n+you really want a library which is simple to use but as lightweight as\n+possible.\n+\n+The ultimate in lightweight dependencies are the solutions provided by the C++\n+and C libraries.  However, both the C++ iostreams and C's printf() have\n+well known usability problems: iostreams are hopelessly verbose for complicated\n+formatting and printf() lacks extensibility and type safety.  For example:\n+\n+```C++\n+// Verbose; hard to read, hard to type:\n+std::cout << std::setprecision(2) << std::fixed << 1.23456 << \"\\n\";\n+// The alternative using a format string is much easier on the eyes\n+tfm::printf(\"%.2f\\n\", 1.23456);\n+\n+// Type mismatch between \"%s\" and int: will cause a segfault at runtime!\n+printf(\"%s\", 1);\n+// The following is perfectly fine, and will result in \"1\" being printed.\n+tfm::printf(\"%s\", 1);\n+```\n+\n+On the other hand, there are plenty of excellent and complete libraries which\n+solve the formatting problem in great generality (boost.format and fastformat\n+come to mind, but there are many others).  Unfortunately these kind of\n+libraries tend to be rather heavy dependencies, far too heavy for projects\n+which need to do only a little formatting.  Problems include\n+\n+1. Having many large source files.  This makes a heavy dependency unsuitable to\n+   bundle within other projects for convenience.\n+2. Slow build times for every file using any sort of formatting (this is very\n+   noticeable with g++ and boost/format.hpp. I'm not sure about the various\n+   other alternatives.)\n+3. Code bloat due to instantiating many templates\n+\n+Tinyformat tries to solve these problems while providing formatting which is\n+sufficiently general and fast for incidental day to day uses.\n+\n+\n+## License\n+\n+For minimum license-related fuss, tinyformat.h is distributed under the boost\n+software license, version 1.0.  (Summary: you must keep the license text on\n+all source copies, but don't have to mention tinyformat when distributing\n+binaries.)\n+\n+\n+## Author and acknowledgements\n+\n+Tinyformat was written by Chris Foster, with contributions from various people\n+as recorded in the git repository.\n+The implementation owes a lot to `boost::format` for showing that it's fairly\n+easy to use stream based formatting to simulate most of the `printf()`\n+syntax.  Douglas Gregor's introduction to variadic templates --- see\n+http://www.generic-programming.org/~dgregor/cpp/variadic-templates.html --- was\n+also helpful, especially since it solves exactly the `printf()` problem for\n+the case of trivial format strings.\n+\n+## Bugs\n+\n+Here's a list of known bugs which are probably cumbersome to fix:\n+\n+* Field padding won't work correctly with complicated user defined types.  For\n+  general types, the only way to do this correctly seems to be format to a\n+  temporary string stream, check the length, and finally send to the output\n+  stream with padding if necessary.  Doing this for all types would be\n+  quite inelegant because it implies extra allocations to make the temporary\n+  stream.  A workaround is to add logic to `operator<<()` for composite user\n+  defined types so they are aware of the stream field width."
      },
      {
        "sha": "160f21e25a97385b24804f538fa8deb570b5ba5d",
        "filename": "appveyor.yml",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/appveyor.yml?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,52 @@\n+# Windows CI build via the Appveyor service\n+\n+version: '{build}'\n+\n+# branches to build\n+branches:\n+  only:\n+    - master\n+\n+# scripts that are called at very beginning, before repo cloning\n+init:\n+  - git config --global core.autocrlf input\n+\n+# Build matrix variables -\n+#   * environment\n+#   * platform\n+#   * configuration\n+environment:\n+  matrix:\n+    - COMPILER: \"Visual Studio 12 Win64\"\n+    - COMPILER: \"Visual Studio 14 Win64\"\n+    - COMPILER: \"Visual Studio 15 Win64\"\n+      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n+\n+# build platform, i.e. x86, x64, Any CPU.\n+platform:\n+  - x86\n+  - x64\n+\n+# build Configuration, i.e. Debug, Release, etc.\n+configuration:\n+  - Debug\n+  - Release\n+\n+before_build:\n+  - echo --------------------------------------------------------------------------------\n+  - echo Appveyor environment info:\n+  - echo COMPILER = %COMPILER%, CONFIGURATION = %CONFIGURATION%\n+  - cmake -h\n+\n+build_script:\n+  - echo --------------------------------------------------------------------------------\n+  - echo Build tinyformat\n+  - mkdir build\n+  - cd build\n+  - cmake -G \"%COMPILER%\" ..\n+  - cmake --build . --config %CONFIGURATION%\n+\n+test_script:\n+  # cmake testall target has problems finding the correct configuration, so use ctest directly.\n+  - ctest -C %CONFIGURATION%\n+"
      },
      {
        "sha": "8f6961fe34ebbe613e2f93e38be82a703cc4f81e",
        "filename": "bloat_test.sh",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/bloat_test.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/bloat_test.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bloat_test.sh?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,105 @@\n+#!/bin/bash\n+\n+# Script to test how much bloating a large project will suffer when using\n+# tinyformat, vs alternatives.  Call as\n+#\n+# C99 printf            :  bloat_test.sh $CXX [-O3]\n+# tinyformat            :  bloat_test.sh $CXX [-O3] -DUSE_TINYFORMAT\n+# tinyformat, no inlines:  bloat_test.sh $CXX [-O3] -DUSE_TINYFORMAT -DUSE_TINYFORMAT_NOINLINE\n+# boost::format         :  bloat_test.sh $CXX [-O3] -DUSE_BOOST\n+# std::iostream         :  bloat_test.sh $CXX [-O3] -DUSE_IOSTREAMS\n+#\n+# Note: to test the NOINLINE version of tinyformat, you need to remove the few\n+# inline functions in the tinyformat::detail namespace, and put them into a\n+# file tinyformat.cpp.  Then rename that version of tinyformat.h into\n+# tinyformat_noinline.h\n+\n+\n+prefix=_bloat_test_tmp_\n+numTranslationUnits=100\n+\n+rm -f $prefix??.cpp ${prefix}main.cpp ${prefix}all.h\n+\n+template='\n+#ifdef USE_BOOST\n+\n+#include <boost/format.hpp>\n+#include <iostream>\n+\n+void doFormat_a()\n+{\n+    std::cout << boost::format(\"%s\\n\") % \"somefile.cpp\";\n+    std::cout << boost::format(\"%s:%d\\n\") % \"somefile.cpp\"% 42;\n+    std::cout << boost::format(\"%s:%d:%s\\n\") % \"somefile.cpp\"% 42% \"asdf\";\n+    std::cout << boost::format(\"%s:%d:%d:%s\\n\") % \"somefile.cpp\"% 42% 1% \"asdf\";\n+    std::cout << boost::format(\"%s:%d:%d:%d:%s\\n\") % \"somefile.cpp\"% 42% 1% 2% \"asdf\";\n+}\n+\n+#elif defined(USE_IOSTREAMS)\n+\n+#include <iostream>\n+\n+void doFormat_a()\n+{\n+    const char* str1 = \"somefile.cpp\";\n+    const char* str2 = \"asdf\";\n+    std::cout << str1 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \":\" << str2 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \":\" << 1 << \":\" << str2 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \":\" << 1 << \":\" << 2 << \":\" << str2 << \"\\n\";\n+}\n+\n+#else\n+#ifdef USE_TINYFORMAT\n+#   ifdef USE_TINYFORMAT_NOINLINE\n+#       include \"tinyformat_noinline.h\"\n+#   else\n+#       include \"tinyformat.h\"\n+#   endif\n+#   define PRINTF tfm::printf\n+#else\n+#   include <stdio.h>\n+#   define PRINTF ::printf\n+#endif\n+\n+void doFormat_a()\n+{\n+    const char* str1 = \"somefile.cpp\";\n+    const char* str2 = \"asdf\";\n+    PRINTF(\"%s\\n\", str1);\n+    PRINTF(\"%s:%d\\n\", str1, 42);\n+    PRINTF(\"%s:%d:%s\\n\", str1, 42, str2);\n+    PRINTF(\"%s:%d:%d:%s\\n\", str1, 42, 1, str2);\n+    PRINTF(\"%s:%d:%d:%d:%s\\n\", str1, 42, 1, 2, str2);\n+}\n+#endif\n+'\n+\n+# Generate all the files\n+echo \"#include \\\"${prefix}all.h\\\"\" >> ${prefix}main.cpp\n+echo '\n+#ifdef USE_TINYFORMAT_NOINLINE\n+#include \"tinyformat.cpp\"\n+#endif\n+\n+int main()\n+{' >> ${prefix}main.cpp\n+\n+for ((i=0;i<$numTranslationUnits;i++)) ; do\n+    n=$(printf \"%03d\" $i)\n+    f=${prefix}$n.cpp\n+    echo \"$template\" | sed -e \"s/doFormat_a/doFormat_a$n/\" -e \"s/42/$i/\" > $f\n+    echo \"doFormat_a$n();\" >> ${prefix}main.cpp\n+    echo \"void doFormat_a$n();\" >> ${prefix}all.h\n+done\n+\n+echo \"return 0; }\" >> ${prefix}main.cpp\n+\n+\n+# Compile\n+time \"$@\" ${prefix}???.cpp ${prefix}main.cpp -o ${prefix}.out\n+ls -sh ${prefix}.out\n+cp ${prefix}.out ${prefix}stripped.out\n+strip ${prefix}stripped.out\n+ls -sh ${prefix}stripped.out"
      },
      {
        "sha": "85a22c15ab17de08e9894acd0afcda5fbecc39c5",
        "filename": "tinyformat.h",
        "status": "added",
        "additions": 1051,
        "deletions": 0,
        "changes": 1051,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/tinyformat.h?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,1051 @@\n+// tinyformat.h\n+// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]\n+//\n+// Boost Software License - Version 1.0\n+//\n+// Permission is hereby granted, free of charge, to any person or organization\n+// obtaining a copy of the software and accompanying documentation covered by\n+// this license (the \"Software\") to use, reproduce, display, distribute,\n+// execute, and transmit the Software, and to prepare derivative works of the\n+// Software, and to permit third-parties to whom the Software is furnished to\n+// do so, all subject to the following:\n+//\n+// The copyright notices in the Software and this entire statement, including\n+// the above license grant, this restriction and the following disclaimer,\n+// must be included in all copies of the Software, in whole or in part, and\n+// all derivative works of the Software, unless such copies or derivative\n+// works are solely in the form of machine-executable object code generated by\n+// a source language processor.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n+// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n+// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+\n+//------------------------------------------------------------------------------\n+// Tinyformat: A minimal type safe printf replacement\n+//\n+// tinyformat.h is a type safe printf replacement library in a single C++\n+// header file.  Design goals include:\n+//\n+// * Type safety and extensibility for user defined types.\n+// * C99 printf() compatibility, to the extent possible using std::ostream\n+// * Simplicity and minimalism.  A single header file to include and distribute\n+//   with your projects.\n+// * Augment rather than replace the standard stream formatting mechanism\n+// * C++98 support, with optional C++11 niceties\n+//\n+//\n+// Main interface example usage\n+// ----------------------------\n+//\n+// To print a date to std::cout:\n+//\n+//   std::string weekday = \"Wednesday\";\n+//   const char* month = \"July\";\n+//   size_t day = 27;\n+//   long hour = 14;\n+//   int min = 44;\n+//\n+//   tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n+//\n+// The strange types here emphasize the type safety of the interface; it is\n+// possible to print a std::string using the \"%s\" conversion, and a\n+// size_t using the \"%d\" conversion.  A similar result could be achieved\n+// using either of the tfm::format() functions.  One prints on a user provided\n+// stream:\n+//\n+//   tfm::format(std::cerr, \"%s, %s %d, %.2d:%.2d\\n\",\n+//               weekday, month, day, hour, min);\n+//\n+// The other returns a std::string:\n+//\n+//   std::string date = tfm::format(\"%s, %s %d, %.2d:%.2d\\n\",\n+//                                  weekday, month, day, hour, min);\n+//   std::cout << date;\n+//\n+// These are the three primary interface functions.  There is also a\n+// convenience function printfln() which appends a newline to the usual result\n+// of printf() for super simple logging.\n+//\n+//\n+// User defined format functions\n+// -----------------------------\n+//\n+// Simulating variadic templates in C++98 is pretty painful since it requires\n+// writing out the same function for each desired number of arguments.  To make\n+// this bearable tinyformat comes with a set of macros which are used\n+// internally to generate the API, but which may also be used in user code.\n+//\n+// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and\n+// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,\n+// type/name pairs and argument names respectively when called with an integer\n+// n between 1 and 16.  We can use these to define a macro which generates the\n+// desired user defined function with n arguments.  To generate all 16 user\n+// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an\n+// example, see the implementation of printf() at the end of the source file.\n+//\n+// Sometimes it's useful to be able to pass a list of format arguments through\n+// to a non-template function.  The FormatList class is provided as a way to do\n+// this by storing the argument list in a type-opaque way.  Continuing the\n+// example from above, we construct a FormatList using makeFormatList():\n+//\n+//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);\n+//\n+// The format list can now be passed into any non-template function and used\n+// via a call to the vformat() function:\n+//\n+//   tfm::vformat(std::cout, \"%s, %s %d, %.2d:%.2d\\n\", formatList);\n+//\n+//\n+// Additional API information\n+// --------------------------\n+//\n+// Error handling: Define TINYFORMAT_ERROR to customize the error handling for\n+// format strings which are unsupported or have the wrong number of format\n+// specifiers (calls assert() by default).\n+//\n+// User defined types: Uses operator<< for user defined types by default.\n+// Overload formatValue() for more control.\n+\n+\n+#ifndef TINYFORMAT_H_INCLUDED\n+#define TINYFORMAT_H_INCLUDED\n+\n+namespace tinyformat {}\n+//------------------------------------------------------------------------------\n+// Config section.  Customize to your liking!\n+\n+// Namespace alias to encourage brevity\n+namespace tfm = tinyformat;\n+\n+// Error handling; calls assert() by default.\n+// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)\n+\n+// Define for C++11 variadic templates which make the code shorter & more\n+// general.  If you don't define this, C++11 support is autodetected below.\n+// #define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+\n+//------------------------------------------------------------------------------\n+// Implementation details.\n+#include <algorithm>\n+#include <cassert>\n+#include <iostream>\n+#include <sstream>\n+\n+#ifndef TINYFORMAT_ERROR\n+#   define TINYFORMAT_ERROR(reason) assert(0 && reason)\n+#endif\n+\n+#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)\n+#   ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#       define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+#   endif\n+#endif\n+\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n+//  std::showpos is broken on old libstdc++ as provided with OSX.  See\n+//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n+#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+#endif\n+\n+#ifdef __APPLE__\n+// Workaround OSX linker warning: xcode uses different default symbol\n+// visibilities for static libs vs executables (see issue #25)\n+#   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n+#else\n+#   define TINYFORMAT_HIDDEN\n+#endif\n+\n+namespace tinyformat {\n+\n+//------------------------------------------------------------------------------\n+namespace detail {\n+\n+// Test whether type T1 is convertible to type T2\n+template <typename T1, typename T2>\n+struct is_convertible\n+{\n+    private:\n+        // two types of different size\n+        struct fail { char dummy[2]; };\n+        struct succeed { char dummy; };\n+        // Try to convert a T1 to a T2 by plugging into tryConvert\n+        static fail tryConvert(...);\n+        static succeed tryConvert(const T2&);\n+        static const T1& makeT1();\n+    public:\n+#       ifdef _MSC_VER\n+        // Disable spurious loss of precision warnings in tryConvert(makeT1())\n+#       pragma warning(push)\n+#       pragma warning(disable:4244)\n+#       pragma warning(disable:4267)\n+#       endif\n+        // Standard trick: the (...) version of tryConvert will be chosen from\n+        // the overload set only if the version taking a T2 doesn't match.\n+        // Then we compare the sizes of the return types to check which\n+        // function matched.  Very neat, in a disgusting kind of way :)\n+        static const bool value =\n+            sizeof(tryConvert(makeT1())) == sizeof(succeed);\n+#       ifdef _MSC_VER\n+#       pragma warning(pop)\n+#       endif\n+};\n+\n+\n+// Detect when a type is not a wchar_t string\n+template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };\n+template<> struct is_wchar<wchar_t*> {};\n+template<> struct is_wchar<const wchar_t*> {};\n+template<int n> struct is_wchar<const wchar_t[n]> {};\n+template<int n> struct is_wchar<wchar_t[n]> {};\n+\n+\n+// Format the value by casting to type fmtT.  This default implementation\n+// should never be called.\n+template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>\n+struct formatValueAsType\n+{\n+    static void invoke(std::ostream& /*out*/, const T& /*value*/) { assert(0); }\n+};\n+// Specialized version for types that can actually be converted to fmtT, as\n+// indicated by the \"convertible\" template parameter.\n+template<typename T, typename fmtT>\n+struct formatValueAsType<T,fmtT,true>\n+{\n+    static void invoke(std::ostream& out, const T& value)\n+        { out << static_cast<fmtT>(value); }\n+};\n+\n+#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+template<typename T, bool convertible = is_convertible<T, int>::value>\n+struct formatZeroIntegerWorkaround\n+{\n+    static bool invoke(std::ostream& /**/, const T& /**/) { return false; }\n+};\n+template<typename T>\n+struct formatZeroIntegerWorkaround<T,true>\n+{\n+    static bool invoke(std::ostream& out, const T& value)\n+    {\n+        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos)\n+        {\n+            out << \"+0\";\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+\n+// Convert an arbitrary type to integer.  The version with convertible=false\n+// throws an error.\n+template<typename T, bool convertible = is_convertible<T,int>::value>\n+struct convertToInt\n+{\n+    static int invoke(const T& /*value*/)\n+    {\n+        TINYFORMAT_ERROR(\"tinyformat: Cannot convert from argument type to \"\n+                         \"integer for use as variable width or precision\");\n+        return 0;\n+    }\n+};\n+// Specialization for convertToInt when conversion is possible\n+template<typename T>\n+struct convertToInt<T,true>\n+{\n+    static int invoke(const T& value) { return static_cast<int>(value); }\n+};\n+\n+// Format at most ntrunc characters to the given stream.\n+template<typename T>\n+inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)\n+{\n+    std::ostringstream tmp;\n+    tmp << value;\n+    std::string result = tmp.str();\n+    out.write(result.c_str(), (std::min)(ntrunc, static_cast<int>(result.size())));\n+}\n+#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \\\n+inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \\\n+{                                                           \\\n+    std::streamsize len = 0;                                \\\n+    while(len < ntrunc && value[len] != 0)                  \\\n+        ++len;                                              \\\n+    out.write(value, len);                                  \\\n+}\n+// Overload for const char* and char*.  Could overload for signed & unsigned\n+// char too, but these are technically unneeded for printf compatibility.\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)\n+#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR\n+\n+} // namespace detail\n+\n+\n+//------------------------------------------------------------------------------\n+// Variable formatting functions.  May be overridden for user-defined types if\n+// desired.\n+\n+\n+/// Format a value into a stream, delegating to operator<< by default.\n+///\n+/// Users may override this for their own types.  When this function is called,\n+/// the stream flags will have been modified according to the format string.\n+/// The format specification is provided in the range [fmtBegin, fmtEnd).  For\n+/// truncating conversions, ntrunc is set to the desired maximum number of\n+/// characters, for example \"%.7s\" calls formatValue with ntrunc = 7.\n+///\n+/// By default, formatValue() uses the usual stream insertion operator\n+/// operator<< to format the type T, with special cases for the %c and %p\n+/// conversions.\n+template<typename T>\n+inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n+                        const char* fmtEnd, int ntrunc, const T& value)\n+{\n+#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS\n+    // Since we don't support printing of wchar_t using \"%ls\", make it fail at\n+    // compile time in preference to printing as a void* at runtime.\n+    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;\n+    (void) DummyType(); // avoid unused type warning with gcc-4.8\n+#endif\n+    // The mess here is to support the %c and %p conversions: if these\n+    // conversions are active we try to convert the type to a char or const\n+    // void* respectively and format that instead of the value itself.  For the\n+    // %p conversion it's important to avoid dereferencing the pointer, which\n+    // could otherwise lead to a crash when printing a dangling (const char*).\n+    const bool canConvertToChar = detail::is_convertible<T,char>::value;\n+    const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;\n+    if(canConvertToChar && *(fmtEnd-1) == 'c')\n+        detail::formatValueAsType<T, char>::invoke(out, value);\n+    else if(canConvertToVoidPtr && *(fmtEnd-1) == 'p')\n+        detail::formatValueAsType<T, const void*>::invoke(out, value);\n+#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+    else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n+#endif\n+    else if(ntrunc >= 0)\n+    {\n+        // Take care not to overread C strings in truncating conversions like\n+        // \"%.4s\" where at most 4 characters may be read.\n+        detail::formatTruncated(out, value, ntrunc);\n+    }\n+    else\n+        out << value;\n+}\n+\n+\n+// Overloaded version for char types to support printing as an integer\n+#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \\\n+inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n+                        const char* fmtEnd, int /**/, charType value) \\\n+{                                                                     \\\n+    switch(*(fmtEnd-1))                                               \\\n+    {                                                                 \\\n+        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \\\n+            out << static_cast<int>(value); break;                    \\\n+        default:                                                      \\\n+            out << value;                   break;                    \\\n+    }                                                                 \\\n+}\n+// per 3.9.1: char, signed char and unsigned char are all distinct types\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)\n+#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR\n+\n+\n+//------------------------------------------------------------------------------\n+// Tools for emulating variadic templates in C++98.  The basic idea here is\n+// stolen from the boost preprocessor metaprogramming library and cut down to\n+// be just general enough for what we need.\n+\n+#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n\n+#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n\n+#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n\n+#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n\n+\n+// To keep it as transparent as possible, the macros below have been generated\n+// using python via the excellent cog.py code generation script.  This avoids\n+// the need for a bunch of complex (but more general) preprocessor tricks as\n+// used in boost.preprocessor.\n+//\n+// To rerun the code generation in place, use `cog.py -r tinyformat.h`\n+// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create\n+// extra versions by hand.\n+\n+/*[[[cog\n+maxParams = 16\n+\n+def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):\n+    for j in range(startInd,maxParams+1):\n+        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])\n+        cog.outl(lineTemplate % {'j':j, 'list':list})\n+\n+makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',\n+                  'class T%(i)d')\n+\n+cog.outl()\n+makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',\n+                  'const T%(i)d& v%(i)d')\n+\n+cog.outl()\n+makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')\n+\n+cog.outl()\n+cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')\n+makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',\n+                  'v%(i)d', startInd = 2)\n+\n+cog.outl()\n+cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\\\\n    ' +\n+         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))\n+]]]*/\n+#define TINYFORMAT_ARGTYPES_1 class T1\n+#define TINYFORMAT_ARGTYPES_2 class T1, class T2\n+#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3\n+#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4\n+#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5\n+#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6\n+#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7\n+#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8\n+#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9\n+#define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10\n+#define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11\n+#define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12\n+#define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13\n+#define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14\n+#define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15\n+#define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16\n+\n+#define TINYFORMAT_VARARGS_1 const T1& v1\n+#define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2\n+#define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3\n+#define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4\n+#define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5\n+#define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6\n+#define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7\n+#define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8\n+#define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9\n+#define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10\n+#define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11\n+#define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12\n+#define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13\n+#define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14\n+#define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15\n+#define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16\n+\n+#define TINYFORMAT_PASSARGS_1 v1\n+#define TINYFORMAT_PASSARGS_2 v1, v2\n+#define TINYFORMAT_PASSARGS_3 v1, v2, v3\n+#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4\n+#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5\n+#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6\n+#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7\n+#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8\n+#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9\n+#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10\n+#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n+#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n+#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n+#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n+#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n+#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n+\n+#define TINYFORMAT_PASSARGS_TAIL_1\n+#define TINYFORMAT_PASSARGS_TAIL_2 , v2\n+#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3\n+#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4\n+#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5\n+#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6\n+#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7\n+#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8\n+#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9\n+#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10\n+#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n+#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n+#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n+#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n+#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n+#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n+\n+#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n+    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)\n+//[[[end]]]\n+\n+\n+\n+namespace detail {\n+\n+// Type-opaque holder for an argument to format(), with associated actions on\n+// the type held as explicit function pointers.  This allows FormatArg's for\n+// each argument to be allocated as a homogenous array inside FormatList\n+// whereas a naive implementation based on inheritance does not.\n+class FormatArg\n+{\n+    public:\n+        FormatArg()\n+            : m_value(NULL),\n+            m_formatImpl(NULL),\n+            m_toIntImpl(NULL)\n+        { }\n+\n+        template<typename T>\n+        FormatArg(const T& value)\n+            : m_value(static_cast<const void*>(&value)),\n+            m_formatImpl(&formatImpl<T>),\n+            m_toIntImpl(&toIntImpl<T>)\n+        { }\n+\n+        void format(std::ostream& out, const char* fmtBegin,\n+                    const char* fmtEnd, int ntrunc) const\n+        {\n+            assert(m_value);\n+            assert(m_formatImpl);\n+            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);\n+        }\n+\n+        int toInt() const\n+        {\n+            assert(m_value);\n+            assert(m_toIntImpl);\n+            return m_toIntImpl(m_value);\n+        }\n+\n+    private:\n+        template<typename T>\n+        TINYFORMAT_HIDDEN static void formatImpl(std::ostream& out, const char* fmtBegin,\n+                        const char* fmtEnd, int ntrunc, const void* value)\n+        {\n+            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));\n+        }\n+\n+        template<typename T>\n+        TINYFORMAT_HIDDEN static int toIntImpl(const void* value)\n+        {\n+            return convertToInt<T>::invoke(*static_cast<const T*>(value));\n+        }\n+\n+        const void* m_value;\n+        void (*m_formatImpl)(std::ostream& out, const char* fmtBegin,\n+                             const char* fmtEnd, int ntrunc, const void* value);\n+        int (*m_toIntImpl)(const void* value);\n+};\n+\n+\n+// Parse and return an integer from the string c, as atoi()\n+// On return, c is set to one past the end of the integer.\n+inline int parseIntAndAdvance(const char*& c)\n+{\n+    int i = 0;\n+    for(;*c >= '0' && *c <= '9'; ++c)\n+        i = 10*i + (*c - '0');\n+    return i;\n+}\n+\n+// Print literal part of format string and return next format spec\n+// position.\n+//\n+// Skips over any occurrences of '%%', printing a literal '%' to the\n+// output.  The position of the first % character of the next\n+// nontrivial format spec is returned, or the end of string.\n+inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n+{\n+    const char* c = fmt;\n+    for(;; ++c)\n+    {\n+        switch(*c)\n+        {\n+            case '\\0':\n+                out.write(fmt, c - fmt);\n+                return c;\n+            case '%':\n+                out.write(fmt, c - fmt);\n+                if(*(c+1) != '%')\n+                    return c;\n+                // for \"%%\", tack trailing % onto next literal section.\n+                fmt = ++c;\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+}\n+\n+\n+// Parse a format string and set the stream state accordingly.\n+//\n+// The format mini-language recognized here is meant to be the one from C99,\n+// with the form \"%[flags][width][.precision][length]type\".\n+//\n+// Formatting options which can't be natively represented using the ostream\n+// state are returned in spacePadPositive (for space padded positive numbers)\n+// and ntrunc (for truncating conversions).  argIndex is incremented if\n+// necessary to pull out variable width and precision .  The function returns a\n+// pointer to the character after the end of the current format spec.\n+inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n+                                         int& ntrunc, const char* fmtStart,\n+                                         const detail::FormatArg* formatters,\n+                                         int& argIndex, int numFormatters)\n+{\n+    if(*fmtStart != '%')\n+    {\n+        TINYFORMAT_ERROR(\"tinyformat: Not enough conversion specifiers in format string\");\n+        return fmtStart;\n+    }\n+    // Reset stream state to defaults.\n+    out.width(0);\n+    out.precision(6);\n+    out.fill(' ');\n+    // Reset most flags; ignore irrelevant unitbuf & skipws.\n+    out.unsetf(std::ios::adjustfield | std::ios::basefield |\n+               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |\n+               std::ios::showpoint | std::ios::showpos | std::ios::uppercase);\n+    bool precisionSet = false;\n+    bool widthSet = false;\n+    int widthExtra = 0;\n+    const char* c = fmtStart + 1;\n+    // 1) Parse flags\n+    for(;; ++c)\n+    {\n+        switch(*c)\n+        {\n+            case '#':\n+                out.setf(std::ios::showpoint | std::ios::showbase);\n+                continue;\n+            case '0':\n+                // overridden by left alignment ('-' flag)\n+                if(!(out.flags() & std::ios::left))\n+                {\n+                    // Use internal padding so that numeric values are\n+                    // formatted correctly, eg -00010 rather than 000-10\n+                    out.fill('0');\n+                    out.setf(std::ios::internal, std::ios::adjustfield);\n+                }\n+                continue;\n+            case '-':\n+                out.fill(' ');\n+                out.setf(std::ios::left, std::ios::adjustfield);\n+                continue;\n+            case ' ':\n+                // overridden by show positive sign, '+' flag.\n+                if(!(out.flags() & std::ios::showpos))\n+                    spacePadPositive = true;\n+                continue;\n+            case '+':\n+                out.setf(std::ios::showpos);\n+                spacePadPositive = false;\n+                widthExtra = 1;\n+                continue;\n+            default:\n+                break;\n+        }\n+        break;\n+    }\n+    // 2) Parse width\n+    if(*c >= '0' && *c <= '9')\n+    {\n+        widthSet = true;\n+        out.width(parseIntAndAdvance(c));\n+    }\n+    if(*c == '*')\n+    {\n+        widthSet = true;\n+        int width = 0;\n+        if(argIndex < numFormatters)\n+            width = formatters[argIndex++].toInt();\n+        else\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width\");\n+        if(width < 0)\n+        {\n+            // negative widths correspond to '-' flag set\n+            out.fill(' ');\n+            out.setf(std::ios::left, std::ios::adjustfield);\n+            width = -width;\n+        }\n+        out.width(width);\n+        ++c;\n+    }\n+    // 3) Parse precision\n+    if(*c == '.')\n+    {\n+        ++c;\n+        int precision = 0;\n+        if(*c == '*')\n+        {\n+            ++c;\n+            if(argIndex < numFormatters)\n+                precision = formatters[argIndex++].toInt();\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable precision\");\n+        }\n+        else\n+        {\n+            if(*c >= '0' && *c <= '9')\n+                precision = parseIntAndAdvance(c);\n+            else if(*c == '-') // negative precisions ignored, treated as zero.\n+                parseIntAndAdvance(++c);\n+        }\n+        out.precision(precision);\n+        precisionSet = true;\n+    }\n+    // 4) Ignore any C99 length modifier\n+    while(*c == 'l' || *c == 'h' || *c == 'L' ||\n+          *c == 'j' || *c == 'z' || *c == 't')\n+        ++c;\n+    // 5) We're up to the conversion specifier character.\n+    // Set stream flags based on conversion specifier (thanks to the\n+    // boost::format class for forging the way here).\n+    bool intConversion = false;\n+    switch(*c)\n+    {\n+        case 'u': case 'd': case 'i':\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'o':\n+            out.setf(std::ios::oct, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'X':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'x': case 'p':\n+            out.setf(std::ios::hex, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'E':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'e':\n+            out.setf(std::ios::scientific, std::ios::floatfield);\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            break;\n+        case 'F':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'f':\n+            out.setf(std::ios::fixed, std::ios::floatfield);\n+            break;\n+        case 'G':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'g':\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            // As in boost::format, let stream decide float format.\n+            out.flags(out.flags() & ~std::ios::floatfield);\n+            break;\n+        case 'a': case 'A':\n+            TINYFORMAT_ERROR(\"tinyformat: the %a and %A conversion specs \"\n+                             \"are not supported\");\n+            break;\n+        case 'c':\n+            // Handled as special case inside formatValue()\n+            break;\n+        case 's':\n+            if(precisionSet)\n+                ntrunc = static_cast<int>(out.precision());\n+            // Make %s print booleans as \"true\" and \"false\"\n+            out.setf(std::ios::boolalpha);\n+            break;\n+        case 'n':\n+            // Not supported - will cause problems!\n+            TINYFORMAT_ERROR(\"tinyformat: %n conversion spec not supported\");\n+            break;\n+        case '\\0':\n+            TINYFORMAT_ERROR(\"tinyformat: Conversion spec incorrectly \"\n+                             \"terminated by end of string\");\n+            return c;\n+        default:\n+            break;\n+    }\n+    if(intConversion && precisionSet && !widthSet)\n+    {\n+        // \"precision\" for integers gives the minimum number of digits (to be\n+        // padded with zeros on the left).  This isn't really supported by the\n+        // iostreams, but we can approximately simulate it with the width if\n+        // the width isn't otherwise used.\n+        out.width(out.precision() + widthExtra);\n+        out.setf(std::ios::internal, std::ios::adjustfield);\n+        out.fill('0');\n+    }\n+    return c+1;\n+}\n+\n+\n+//------------------------------------------------------------------------------\n+inline void formatImpl(std::ostream& out, const char* fmt,\n+                       const detail::FormatArg* formatters,\n+                       int numFormatters)\n+{\n+    // Saved stream state\n+    std::streamsize origWidth = out.width();\n+    std::streamsize origPrecision = out.precision();\n+    std::ios::fmtflags origFlags = out.flags();\n+    char origFill = out.fill();\n+\n+    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)\n+    {\n+        // Parse the format string\n+        fmt = printFormatStringLiteral(out, fmt);\n+        bool spacePadPositive = false;\n+        int ntrunc = -1;\n+        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,\n+                                                   formatters, argIndex, numFormatters);\n+        if (argIndex >= numFormatters)\n+        {\n+            // Check args remain after reading any variable width/precision\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough format arguments\");\n+            return;\n+        }\n+        const FormatArg& arg = formatters[argIndex];\n+        // Format the arg into the stream.\n+        if(!spacePadPositive)\n+            arg.format(out, fmt, fmtEnd, ntrunc);\n+        else\n+        {\n+            // The following is a special case with no direct correspondence\n+            // between stream formatting and the printf() behaviour.  Simulate\n+            // it crudely by formatting into a temporary string stream and\n+            // munging the resulting string.\n+            std::ostringstream tmpStream;\n+            tmpStream.copyfmt(out);\n+            tmpStream.setf(std::ios::showpos);\n+            arg.format(tmpStream, fmt, fmtEnd, ntrunc);\n+            std::string result = tmpStream.str(); // allocates... yuck.\n+            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n+                if(result[i] == '+') result[i] = ' ';\n+            out << result;\n+        }\n+        fmt = fmtEnd;\n+    }\n+\n+    // Print remaining part of format string.\n+    fmt = printFormatStringLiteral(out, fmt);\n+    if(*fmt != '\\0')\n+        TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+\n+    // Restore stream state\n+    out.width(origWidth);\n+    out.precision(origPrecision);\n+    out.flags(origFlags);\n+    out.fill(origFill);\n+}\n+\n+} // namespace detail\n+\n+\n+/// List of template arguments format(), held in a type-opaque way.\n+///\n+/// A const reference to FormatList (typedef'd as FormatListRef) may be\n+/// conveniently used to pass arguments to non-template functions: All type\n+/// information has been stripped from the arguments, leaving just enough of a\n+/// common interface to perform formatting as required.\n+class FormatList\n+{\n+    public:\n+        FormatList(detail::FormatArg* formatters, int N)\n+            : m_formatters(formatters), m_N(N) { }\n+\n+        friend void vformat(std::ostream& out, const char* fmt,\n+                            const FormatList& list);\n+\n+    private:\n+        const detail::FormatArg* m_formatters;\n+        int m_N;\n+};\n+\n+/// Reference to type-opaque format list for passing to vformat()\n+typedef const FormatList& FormatListRef;\n+\n+\n+namespace detail {\n+\n+// Format list subclass with fixed storage to avoid dynamic allocation\n+template<int N>\n+class FormatListN : public FormatList\n+{\n+    public:\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+        template<typename... Args>\n+        FormatListN(const Args&... args)\n+            : FormatList(&m_formatterStore[0], N),\n+            m_formatterStore { FormatArg(args)... }\n+        { static_assert(sizeof...(args) == N, \"Number of args must be N\"); }\n+#else // C++98 version\n+        void init(int) {}\n+#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        FormatListN(TINYFORMAT_VARARGS(n))                     \\\n+            : FormatList(&m_formatterStore[0], n)              \\\n+        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        void init(int i, TINYFORMAT_VARARGS(n))                \\\n+        {                                                      \\\n+            m_formatterStore[i] = FormatArg(v1);               \\\n+            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \\\n+        }\n+\n+        TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)\n+#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR\n+#endif\n+\n+    private:\n+        FormatArg m_formatterStore[N];\n+};\n+\n+// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard\n+template<> class FormatListN<0> : public FormatList\n+{\n+    public: FormatListN() : FormatList(0, 0) {}\n+};\n+\n+} // namespace detail\n+\n+\n+//------------------------------------------------------------------------------\n+// Primary API functions\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+/// Make type-agnostic format list from list of template arguments.\n+///\n+/// The exact return type of this function is an implementation detail and\n+/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:\n+///\n+///   FormatListRef formatList = makeFormatList( /*...*/ );\n+template<typename... Args>\n+detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args)\n+{\n+    return detail::FormatListN<sizeof...(args)>(args...);\n+}\n+\n+#else // C++98 version\n+\n+inline detail::FormatListN<0> makeFormatList()\n+{\n+    return detail::FormatListN<0>();\n+}\n+#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \\\n+template<TINYFORMAT_ARGTYPES(n)>                              \\\n+detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \\\n+{                                                             \\\n+    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \\\n+}\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)\n+#undef TINYFORMAT_MAKE_MAKEFORMATLIST\n+\n+#endif\n+\n+/// Format list of arguments to the stream according to the given format string.\n+///\n+/// The name vformat() is chosen for the semantic similarity to vprintf(): the\n+/// list of format arguments is held in a single function argument.\n+inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)\n+{\n+    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);\n+}\n+\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+/// Format list of arguments to the stream according to given format string.\n+template<typename... Args>\n+void format(std::ostream& out, const char* fmt, const Args&... args)\n+{\n+    vformat(out, fmt, makeFormatList(args...));\n+}\n+\n+/// Format list of arguments according to the given format string and return\n+/// the result as a string.\n+template<typename... Args>\n+std::string format(const char* fmt, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt, args...);\n+    return oss.str();\n+}\n+\n+/// Format list of arguments to std::cout, according to the given format string\n+template<typename... Args>\n+void printf(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+}\n+\n+template<typename... Args>\n+void printfln(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+    std::cout << '\\n';\n+}\n+\n+\n+#else // C++98 version\n+\n+inline void format(std::ostream& out, const char* fmt)\n+{\n+    vformat(out, fmt, makeFormatList());\n+}\n+\n+inline std::string format(const char* fmt)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt);\n+    return oss.str();\n+}\n+\n+inline void printf(const char* fmt)\n+{\n+    format(std::cout, fmt);\n+}\n+\n+inline void printfln(const char* fmt)\n+{\n+    format(std::cout, fmt);\n+    std::cout << '\\n';\n+}\n+\n+#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \\\n+{                                                                         \\\n+    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \\\n+{                                                                         \\\n+    std::ostringstream oss;                                               \\\n+    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \\\n+    return oss.str();                                                     \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n+{                                                                         \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \\\n+{                                                                         \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n+    std::cout << '\\n';                                                    \\\n+}\n+\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)\n+#undef TINYFORMAT_MAKE_FORMAT_FUNCS\n+\n+#endif\n+\n+\n+} // namespace tinyformat\n+\n+#endif // TINYFORMAT_H_INCLUDED"
      },
      {
        "sha": "95aa5b8125c2c74fe59afca42bead7bf487597f6",
        "filename": "tinyformat_speed_test.cpp",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/tinyformat_speed_test.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/tinyformat_speed_test.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/tinyformat_speed_test.cpp?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,64 @@\n+#if defined(__linux__) && defined(__clang__)\n+// Workaround for bug in gcc 4.4 standard library headers when compling with\n+// clang in C++11 mode.\n+namespace std { class type_info; }\n+#endif\n+\n+#include <boost/format.hpp>\n+#include <iomanip>\n+#include <stdio.h>\n+#include \"tinyformat.h\"\n+\n+void speedTest(const std::string& which)\n+{\n+    // Following is required so that we're not limited by per-character\n+    // buffering.\n+    std::ios_base::sync_with_stdio(false);\n+    const long maxIter = 2000000L;\n+    if(which == \"printf\")\n+    {\n+        // libc version\n+        for(long i = 0; i < maxIter; ++i)\n+            printf(\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\",\n+                   1.234, 42, 3.13, \"str\", (void*)1000, (int)'X');\n+    }\n+    else if(which == \"iostreams\")\n+    {\n+        // Std iostreams version.  What a mess!!\n+        for(long i = 0; i < maxIter; ++i)\n+            std::cout\n+                << std::setprecision(10) << std::fixed << 1.234\n+                << std::resetiosflags(std::ios::floatfield) << \":\"\n+                << std::setw(4) << std::setfill('0') << 42 << std::setfill(' ') << \":\"\n+                << std::setiosflags(std::ios::showpos) << 3.13 << std::resetiosflags(std::ios::showpos) << \":\"\n+                << \"str\" << \":\"\n+                << (void*)1000 << \":\"\n+                << 'X' << \":%\\n\";\n+    }\n+    else if(which == \"tinyformat\")\n+    {\n+        // tinyformat version.\n+        for(long i = 0; i < maxIter; ++i)\n+            tfm::printf(\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\",\n+                        1.234, 42, 3.13, \"str\", (void*)1000, (int)'X');\n+    }\n+    else if(which == \"boost\")\n+    {\n+        // boost::format version\n+        for(long i = 0; i < maxIter; ++i)\n+            std::cout << boost::format(\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\")\n+                % 1.234 % 42 % 3.13 % \"str\" % (void*)1000 % (int)'X';\n+    }\n+    else\n+    {\n+        assert(0 && \"speed test for which version?\");\n+    }\n+}\n+\n+\n+int main(int argc, char* argv[])\n+{\n+    if(argc >= 2)\n+        speedTest(argv[1]);\n+    return 0;\n+}"
      },
      {
        "sha": "bcc72780c5ee36b2c2dc1c2b94c3cc8832ebb096",
        "filename": "tinyformat_test.cpp",
        "status": "added",
        "additions": 283,
        "deletions": 0,
        "changes": 283,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/tinyformat_test.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176/tinyformat_test.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/tinyformat_test.cpp?ref=6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "patch": "@@ -0,0 +1,283 @@\n+#if defined(__linux__) && defined(__clang__)\n+// Workaround for bug in gcc 4.4 standard library headers when compling with\n+// clang in C++11 mode.\n+namespace std { class type_info; }\n+#endif\n+\n+#if defined(_MSC_VER) && _MSC_VER == 1800\n+    // Disable spurious warning about printf format string mismatch in VS 2012\n+#   pragma warning(disable:4313)\n+#endif\n+\n+#include <stdexcept>\n+#include <climits>\n+#include <cfloat>\n+#include <cstddef>\n+\n+// Throw instead of abort() so we can test error conditions.\n+#define TINYFORMAT_ERROR(reason) \\\n+    throw std::runtime_error(reason);\n+\n+#include \"tinyformat.h\"\n+#include <cassert>\n+\n+#if 0\n+// Compare result of tfm::format() to C's sprintf().\n+template<typename... Args>\n+void compareSprintf(const Args&... args)\n+{\n+    std::string tfmResult = tfm::format(args...);\n+    char sprintfResult[200];\n+    sprintf(sprintfResult, args...);\n+    if(tfmResult != sprintfResult)\n+    {\n+        std::cout << tfmResult << std::endl;\n+        std::cout << sprintfResult << std::endl;\n+        assert(0 && \"results didn't match, see above.\");\n+    }\n+}\n+#endif\n+\n+#define EXPECT_ERROR(expression)                                \\\n+try                                                             \\\n+{                                                               \\\n+    expression;                                                 \\\n+    std::cout << \"test failed, line \" << __LINE__ << \"\\n\";      \\\n+    std::cout << \"expected exception in \" #expression << \"\\n\";  \\\n+    ++nfailed;                                                  \\\n+}                                                               \\\n+catch(std::runtime_error&) {}                                   \\\n+\n+#define CHECK_EQUAL(a, b)                                  \\\n+if(!((a) == (b)))                                          \\\n+{                                                          \\\n+    std::cout << \"test failed, line \" << __LINE__ << \"\\n\"; \\\n+    std::cout << (a) << \" != \" << (b) << \"\\n\";             \\\n+    std::cout << \"[\" #a \", \" #b \"]\\n\";                     \\\n+    ++nfailed;                                             \\\n+}\n+\n+\n+// Test wrapping to create our own function which calls through to tfm::format\n+struct TestWrap\n+{\n+    std::ostringstream m_oss;\n+    // template<typename... Args>\n+    // std::string error(int code, const char* fmt, const Args&... args);\n+#   define MAKE_ERROR_FUNC(n)                                            \\\n+    template<TINYFORMAT_ARGTYPES(n)>                                     \\\n+    std::string error(int code, const char* fmt, TINYFORMAT_VARARGS(n))  \\\n+    {                                                                    \\\n+        m_oss.clear();                                                   \\\n+        m_oss << code << \": \";                                           \\\n+        tfm::format(m_oss, fmt, TINYFORMAT_PASSARGS(n));                 \\\n+        return m_oss.str();                                              \\\n+    }\n+    TINYFORMAT_FOREACH_ARGNUM(MAKE_ERROR_FUNC)\n+};\n+\n+\n+struct TestExceptionDef : public std::runtime_error\n+{\n+#   define MAKE_CONSTRUCTOR(n)                                          \\\n+    template<TINYFORMAT_ARGTYPES(n)>                                    \\\n+    TestExceptionDef(const char* fmt, TINYFORMAT_VARARGS(n))            \\\n+        : std::runtime_error(tfm::format(fmt, TINYFORMAT_PASSARGS(n)))  \\\n+    { }\n+    TINYFORMAT_FOREACH_ARGNUM(MAKE_CONSTRUCTOR)\n+};\n+\n+\n+struct MyInt {\n+public:\n+    MyInt(int value) : m_value(value) {}\n+    int value() const { return m_value; }\n+private:\n+    int m_value;\n+};\n+\n+std::ostream& operator<<(std::ostream& os, const MyInt& obj) {\n+    os << obj.value();\n+    return os;\n+}\n+\n+\n+int unitTests()\n+{\n+    int nfailed = 0;\n+#   if defined(_MSC_VER) && _MSC_VER < 1900 // VC++ older than 2015\n+    // floats are printed with three digit exponents on windows, which messes\n+    // up the tests.  Turn this off for consistency:\n+    _set_output_format(_TWO_DIGIT_EXPONENT);\n+#   endif\n+    // Test various basic format specs against results of sprintf\n+    CHECK_EQUAL(tfm::format(\"%s\", \"asdf\"), \"asdf\");\n+    CHECK_EQUAL(tfm::format(\"%d\", 1234), \"1234\");\n+    CHECK_EQUAL(tfm::format(\"%i\", -5678), \"-5678\");\n+    CHECK_EQUAL(tfm::format(\"%o\", 012), \"12\");\n+    CHECK_EQUAL(tfm::format(\"%u\", 123456u), \"123456\");\n+    CHECK_EQUAL(tfm::format(\"%x\", 0xdeadbeef), \"deadbeef\");\n+    CHECK_EQUAL(tfm::format(\"%X\", 0xDEADBEEF), \"DEADBEEF\");\n+    CHECK_EQUAL(tfm::format(\"%e\", 1.23456e10), \"1.234560e+10\");\n+    CHECK_EQUAL(tfm::format(\"%E\", -1.23456E10), \"-1.234560E+10\");\n+    CHECK_EQUAL(tfm::format(\"%f\", -9.8765), \"-9.876500\");\n+    CHECK_EQUAL(tfm::format(\"%F\", 9.8765), \"9.876500\");\n+    CHECK_EQUAL(tfm::format(\"%g\", 10), \"10\");\n+    CHECK_EQUAL(tfm::format(\"%G\", 100), \"100\");\n+    CHECK_EQUAL(tfm::format(\"%c\", 65), \"A\");\n+    CHECK_EQUAL(tfm::format(\"%hc\", (short)65), \"A\");\n+    CHECK_EQUAL(tfm::format(\"%lc\", (long)65), \"A\");\n+    CHECK_EQUAL(tfm::format(\"%s\", \"asdf_123098\"), \"asdf_123098\");\n+    // Note: All tests printing pointers are different on windows, since\n+    // there's no standard numerical representation.\n+    // Representation also differs between 32-bit and 64-bit windows.\n+#   ifdef _MSC_VER\n+#   ifdef _WIN64\n+    CHECK_EQUAL(tfm::format(\"%p\", (void*)0x12345), \"0000000000012345\");\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (void*)0x12345), \"00012345\");\n+#   endif // _WIN64\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (void*)0x12345), \"0x12345\");\n+#   endif // _MSC_VER\n+    CHECK_EQUAL(tfm::format(\"%%%s\", \"asdf\"), \"%asdf\"); // note: plain \"%%\" format gives warning with gcc\n+    // chars with int format specs are printed as ints:\n+    CHECK_EQUAL(tfm::format(\"%hhd\", (char)65), \"65\");\n+    CHECK_EQUAL(tfm::format(\"%hhu\", (unsigned char)65), \"65\");\n+    CHECK_EQUAL(tfm::format(\"%hhd\", (signed char)65), \"65\");\n+#   ifdef _MSC_VER\n+#   ifdef _WIN64\n+    CHECK_EQUAL(tfm::format(\"%p\", (const char*)0x10), \"0000000000000010\");\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (const char*)0x10), \"00000010\");\n+#   endif // _WIN64\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (const char*)0x10), \"0x10\"); // should print address, not string.\n+#   endif // _MSC_VER\n+    // bools with string format spec are printed as \"true\" or \"false\"\n+    CHECK_EQUAL(tfm::format(\"%s\", true), \"true\");\n+    CHECK_EQUAL(tfm::format(\"%d\", true), \"1\");\n+\n+    // Test precision & width\n+    CHECK_EQUAL(tfm::format(\"%10d\", -10), \"       -10\");\n+    CHECK_EQUAL(tfm::format(\"%.4d\", 10), \"0010\");\n+    CHECK_EQUAL(tfm::format(\"%10.4f\", 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%.f\", 10.1), \"10\");\n+    CHECK_EQUAL(tfm::format(\"%.2s\", \"asdf\"), \"as\"); // strings truncate to precision\n+    CHECK_EQUAL(tfm::format(\"%.2s\", std::string(\"asdf\")), \"as\");\n+//    // Test variable precision & width\n+    CHECK_EQUAL(tfm::format(\"%*.4f\", 10, 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%10.*f\", 4, 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%*.*f\", 10, 4, 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%*.*f\", -10, 4, 1234.1234567890), \"1234.1235 \");\n+\n+    // Test flags\n+    CHECK_EQUAL(tfm::format(\"%#x\", 0x271828), \"0x271828\");\n+    CHECK_EQUAL(tfm::format(\"%#o\", 0x271828), \"011614050\");\n+    CHECK_EQUAL(tfm::format(\"%#f\", 3.0), \"3.000000\");\n+    CHECK_EQUAL(tfm::format(\"%+d\", 3), \"+3\");\n+    CHECK_EQUAL(tfm::format(\"%+d\", 0), \"+0\");\n+    CHECK_EQUAL(tfm::format(\"%+d\", -3), \"-3\");\n+    CHECK_EQUAL(tfm::format(\"%010d\", 100), \"0000000100\");\n+    CHECK_EQUAL(tfm::format(\"%010d\", -10), \"-000000010\"); // sign should extend\n+    CHECK_EQUAL(tfm::format(\"%#010X\", 0xBEEF), \"0X0000BEEF\");\n+    CHECK_EQUAL(tfm::format(\"% d\",  10), \" 10\");\n+    CHECK_EQUAL(tfm::format(\"% d\", -10), \"-10\");\n+    // Test flags with variable precision & width\n+    CHECK_EQUAL(tfm::format(\"%+.2d\", 3), \"+03\");\n+    CHECK_EQUAL(tfm::format(\"%+.2d\", -3), \"-03\");\n+    // flag override precedence\n+    CHECK_EQUAL(tfm::format(\"%+ d\", 10), \"+10\"); // '+' overrides ' '\n+    CHECK_EQUAL(tfm::format(\"% +d\", 10), \"+10\");\n+    CHECK_EQUAL(tfm::format(\"%-010d\", 10), \"10        \"); // '-' overrides '0'\n+    CHECK_EQUAL(tfm::format(\"%0-10d\", 10), \"10        \");\n+\n+    // Check that length modifiers are ignored\n+    CHECK_EQUAL(tfm::format(\"%hd\", (short)1000), \"1000\");\n+    CHECK_EQUAL(tfm::format(\"%ld\", (long)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%lld\", (long long)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%zd\", (size_t)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%td\", (ptrdiff_t)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%jd\", 100000), \"100000\");\n+\n+    // Check that 0-argument formatting is printf-compatible\n+    CHECK_EQUAL(tfm::format(\"100%%\"), \"100%\");\n+\n+    // printf incompatibilities:\n+    // compareSprintf(\"%6.4x\", 10); // precision & width can't be supported independently\n+    // compareSprintf(\"%.4d\", -10); // negative numbers + precision don't quite work.\n+\n+    // General \"complicated\" format spec test\n+    CHECK_EQUAL(tfm::format(\"%0.10f:%04d:%+g:%s:%#X:%c:%%:%%asdf\",\n+                       1.234, 42, 3.13, \"str\", 0XDEAD, (int)'X'),\n+                \"1.2340000000:0042:+3.13:str:0XDEAD:X:%:%asdf\");\n+\n+    // Test wrong number of args\n+    EXPECT_ERROR( tfm::format(\"%d\", 5, 10) )\n+    EXPECT_ERROR( tfm::format(\"%d %d\", 1)  )\n+    // Unterminated format spec\n+    EXPECT_ERROR( tfm::format(\"%123\", 10)  )\n+    // Types used to specify variable width/precision must be convertible to int.\n+    EXPECT_ERROR( tfm::format(\"%0*d\", \"thing that can't convert to int\", 42)  )\n+    EXPECT_ERROR( tfm::format(\"%0.*d\", \"thing that can't convert to int\", 42) )\n+    // Error required if not enough args for variable width/precision\n+    EXPECT_ERROR( tfm::format(\"%*d\", 1)      )\n+    EXPECT_ERROR( tfm::format(\"%.*d\", 1)     )\n+    EXPECT_ERROR( tfm::format(\"%*.*d\", 1, 2) )\n+\n+    // Unhandled C99 format spec\n+    EXPECT_ERROR( tfm::format(\"%n\", 10) )\n+    EXPECT_ERROR( tfm::format(\"%a\", 10) )\n+    EXPECT_ERROR( tfm::format(\"%A\", 10) )\n+\n+#ifdef TEST_WCHAR_T_COMPILE\n+    // Test wchar_t handling - should fail to compile!\n+    tfm::format(\"%ls\", L\"blah\");\n+#endif\n+\n+    // Test that formatting is independent of underlying stream state.\n+    std::ostringstream oss;\n+    oss.width(20);\n+    oss.precision(10);\n+    oss.fill('*');\n+    oss.setf(std::ios::scientific);\n+    tfm::format(oss, \"%f\", 10.1234123412341234);\n+    CHECK_EQUAL(oss.str(), \"10.123412\");\n+\n+    // Test formatting a custom object\n+    MyInt myobj(42);\n+    CHECK_EQUAL(tfm::format(\"myobj: %s\", myobj), \"myobj: 42\");\n+\n+    // Test that interface wrapping works correctly\n+    TestWrap wrap;\n+    CHECK_EQUAL(wrap.error(10, \"someformat %s:%d:%d\", \"asdf\", 2, 4),\n+                \"10: someformat asdf:2:4\");\n+\n+    TestExceptionDef ex(\"blah %d\", 100);\n+    CHECK_EQUAL(ex.what(), std::string(\"blah 100\"));\n+\n+    // Test tfm::printf by swapping the std::cout stream buffer to capture data\n+    // which would noramlly go to the stdout\n+    std::ostringstream coutCapture;\n+    std::streambuf* coutBuf = std::cout.rdbuf(coutCapture.rdbuf());\n+    tfm::printf(\"%s %s %d\\n\", \"printf\", \"test\", 1);\n+    tfm::printfln(\"%s %s %d\", \"printfln\", \"test\", 1);\n+    std::cout.rdbuf(coutBuf); // restore buffer\n+    CHECK_EQUAL(coutCapture.str(), \"printf test 1\\nprintfln test 1\\n\");\n+\n+    return nfailed;\n+}\n+\n+\n+int main()\n+{\n+    try\n+    {\n+        return unitTests();\n+    }\n+    catch (std::runtime_error & e)\n+    {\n+        std::cout << \"Failure due to uncaught exception: \" << e.what() << std::endl;\n+        return EXIT_FAILURE;\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "bc483a29dff28e86fa8224b30799e539c98ed7ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYzQ4M2EyOWRmZjI4ZTg2ZmE4MjI0YjMwNzk5ZTUzOWM5OGVkN2Vj",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-08-02T02:04:29Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-08-02T02:04:29Z"
      },
      "message": "Merge commit '6abd9bdbfd1ac646d239b34c7c9eb09e136a8176' as 'src/tinyformat'",
      "tree": {
        "sha": "6af4429656ef745bb834d9041fe2cf3055704c54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6af4429656ef745bb834d9041fe2cf3055704c54"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bc483a29dff28e86fa8224b30799e539c98ed7ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc483a29dff28e86fa8224b30799e539c98ed7ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bc483a29dff28e86fa8224b30799e539c98ed7ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc483a29dff28e86fa8224b30799e539c98ed7ec/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f030410e88f11c5ff1ce6c80b463a1c7f6d39830",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f030410e88f11c5ff1ce6c80b463a1c7f6d39830",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f030410e88f11c5ff1ce6c80b463a1c7f6d39830"
      },
      {
        "sha": "6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6abd9bdbfd1ac646d239b34c7c9eb09e136a8176"
      }
    ],
    "stats": {
      "total": 2303,
      "additions": 2303,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6e87896d0ebe4ee027ce8332614dcbd2fc06d1d8",
        "filename": "src/tinyformat/.gitignore",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/.gitignore?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,3 @@\n+_bloat_test_tmp*\n+tinyformat_test_cxx*\n+tinyformat_speed_test"
      },
      {
        "sha": "75409d435342848dc3a5ea4b5ef863998765311d",
        "filename": "src/tinyformat/.travis.yml",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/.travis.yml?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,196 @@\n+language: cpp\n+\n+sudo: false\n+\n+# C'mon Travis, you're a great service, but why do I need a script to generate my build matrix?\n+\n+# cat $0 | sed -e 's/^\\(.\\)/# \\1/' -e 's/^$/#/'\n+#\n+# cat <<EOF\n+# matrix:\n+#   include:\n+#\n+# EOF\n+#\n+#\n+# for os in linux ; do\n+#     for compiler in g++-5 clang++-3.8 ; do\n+#         for buildtype in Release Debug ; do\n+#             for std in c++98 c++11 ; do\n+# cat <<EOF\n+#     - os: $os\n+#       compiler: $compiler\n+#       env:\n+#         - CXX_STD=$std\n+#         - COMPILER=$compiler\n+#         - BUILD_TYPE=$buildtype\n+# EOF\n+#                 if [[ $os == linux ]] ; then\n+# cat <<EOF\n+#       addons:\n+#         apt:\n+#           sources:\n+#             - ubuntu-toolchain-r-test\n+#             - llvm-toolchain-precise-3.8\n+#           packages:\n+#             - $compiler\n+# EOF\n+#                 fi\n+#                 echo\n+#             done\n+#         done\n+#     done\n+# done\n+matrix:\n+  include:\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: g++-5\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=g++-5\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - g++-5\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Release\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: linux\n+      compiler: clang++-3.8\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++-3.8\n+        - BUILD_TYPE=Debug\n+      addons:\n+        apt:\n+          sources:\n+            - ubuntu-toolchain-r-test\n+            - llvm-toolchain-precise-3.8\n+          packages:\n+            - clang++-3.8\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Release\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Release\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++98\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Debug\n+\n+    - os: osx\n+      compiler: clang\n+      env:\n+        - CXX_STD=c++11\n+        - COMPILER=clang++\n+        - BUILD_TYPE=Debug\n+\n+\n+before_script:\n+  - cmake --version\n+\n+script:\n+  - mkdir build\n+  - cd build\n+  - cmake -DCMAKE_CXX_COMPILER=$COMPILER -DCMAKE_BUILD_TYPE=$BUILD_TYPE -DCXX_STD=$CXX_STD ..\n+  - make testall\n+"
      },
      {
        "sha": "391d1768f5c47f228c9ab86e1a36133fe208aac2",
        "filename": "src/tinyformat/CMakeLists.txt",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/CMakeLists.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/CMakeLists.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/CMakeLists.txt?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,41 @@\n+# CMake build for tests.\n+#\n+# See also the Makefile, which is currently more fully featured on unix.\n+\n+\n+# Set cmake builtin variables before calling project(), otherwise the\n+# cmake-provided defaults will get in first!\n+set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING\n+    \"Choose the type of build, options are: None(CMAKE_CXX_FLAGS or CMAKE_C_FLAGS used) Debug Release RelWithDebInfo MinSizeRel.\"\n+)\n+\n+set(CXX_STD \"c++11\" CACHE STRING \"Version of C++ standard in use\")\n+\n+# This project is infrastructure.  Warnings from common warning levels should\n+# be errors on all compilers, unless explicitly silenced.\n+if(NOT WIN32)\n+    set(CMAKE_CXX_FLAGS \"-Wall -Werror -std=${CXX_STD}\" CACHE STRING \"Flags used by the compiler during all build types.\")\n+endif()\n+\n+project(tinyformat)\n+cmake_minimum_required(VERSION 2.8)\n+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n+\n+if(WIN32)\n+    # Treat warnings as errors.  Would set this above, but need the default\n+    # flags too, and `project()` behaves is differently on different systems.\n+    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /W3 /WX\")\n+endif()\n+\n+add_executable(tinyformat_test tinyformat_test.cpp)\n+enable_testing()\n+if(CMAKE_CONFIGURATION_TYPES)\n+    set(ctest_config_opt -C ${CMAKE_BUILD_TYPE})\n+endif()\n+add_test(NAME test COMMAND tinyformat_test)\n+add_custom_target(testall COMMAND ${CMAKE_CTEST_COMMAND} -V ${ctest_config_opt} DEPENDS tinyformat_test)\n+\n+option(COMPILE_SPEED_TEST FALSE)\n+if (COMPILE_SPEED_TEST)\n+    add_executable(tinyformat_speed_test tinyformat_speed_test.cpp)\n+endif ()"
      },
      {
        "sha": "6cef5f568f589c1a70685631bf3feb82c54f006b",
        "filename": "src/tinyformat/Makefile",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/Makefile?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,56 @@\n+# Build and run the unit tests (or speed tests) on linux\n+#\n+# Should work with recent versions of both gcc and clang.  (To compile with\n+# clang use \"make CXX=clang++\".)\n+\n+CXXFLAGS?=-Wall -Werror\n+CXX11FLAGS?=-std=c++11\n+\n+test: tinyformat_test_cxx98 tinyformat_test_cxx11\n+\t@echo running tests...\n+\t@./tinyformat_test_cxx98 && \\\n+\t\t./tinyformat_test_cxx11 && \\\n+\t\t! $(CXX) $(CXXFLAGS) -std=c++98 -DTINYFORMAT_NO_VARIADIC_TEMPLATES \\\n+\t\t-DTEST_WCHAR_T_COMPILE tinyformat_test.cpp 2> /dev/null && \\\n+\t\techo \"No errors\" || echo \"Tests failed\"\n+\n+doc: tinyformat.html\n+\n+speed_test: tinyformat_speed_test\n+\t@echo running speed tests...\n+\t@echo printf timings:\n+\t@time -p ./tinyformat_speed_test printf > /dev/null\n+\t@echo iostreams timings:\n+\t@time -p ./tinyformat_speed_test iostreams > /dev/null\n+\t@echo tinyformat timings:\n+\t@time -p ./tinyformat_speed_test tinyformat > /dev/null\n+\t@echo boost timings:\n+\t@time -p ./tinyformat_speed_test boost > /dev/null\n+\n+tinyformat_test_cxx98: tinyformat.h tinyformat_test.cpp Makefile\n+\t$(CXX) $(CXXFLAGS) -std=c++98 -DTINYFORMAT_NO_VARIADIC_TEMPLATES tinyformat_test.cpp -o tinyformat_test_cxx98\n+\n+tinyformat_test_cxx11: tinyformat.h tinyformat_test.cpp Makefile\n+\t$(CXX) $(CXXFLAGS) $(CXX11FLAGS) -DTINYFORMAT_USE_VARIADIC_TEMPLATES tinyformat_test.cpp -o tinyformat_test_cxx11\n+\n+tinyformat.html: README.rst\n+\t@echo building docs...\n+\trst2html.py README.rst > tinyformat.html\n+\n+tinyformat_speed_test: tinyformat.h tinyformat_speed_test.cpp Makefile\n+\t$(CXX) $(CXXFLAGS) -O3 -DNDEBUG tinyformat_speed_test.cpp -o tinyformat_speed_test\n+\n+bloat_test:\n+\t@for opt in '' '-O3 -DNDEBUG' ; do \\\n+\t\tfor use in '' '-DUSE_IOSTREAMS' '-DUSE_TINYFORMAT' '-DUSE_TINYFORMAT $(CXX11FLAGS)' '-DUSE_BOOST' ; do \\\n+\t\t\techo ; \\\n+\t\t\techo ./bloat_test.sh $(CXX) $$opt $$use ; \\\n+\t\t\t./bloat_test.sh $(CXX) $$opt $$use ; \\\n+\t\tdone ; \\\n+\tdone\n+\n+\n+clean:\n+\trm -f tinyformat_test_cxx98 tinyformat_test_cxx11 tinyformat_speed_test\n+\trm -f tinyformat.html\n+\trm -f _bloat_test_tmp_*"
      },
      {
        "sha": "966f4b59dc17cf926a093644b07e14c434c93232",
        "filename": "src/tinyformat/README.md",
        "status": "added",
        "additions": 452,
        "deletions": 0,
        "changes": 452,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/README.md?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,452 @@\n+# tinyformat.h\n+\n+## A minimal type safe printf() replacement\n+\n+**tinyformat.h** is a type safe printf replacement library in a single C++\n+header file.  If you've ever wanted `printf(\"%s\", s)` to just work regardless\n+of the type of `s`, tinyformat might be for you.  Design goals include:\n+\n+* Type safety and extensibility for user defined types.\n+* C99 `printf()` compatibility, to the extent possible using `std::ostream`\n+* Simplicity and minimalism.  A single header file to include and distribute\n+  with your projects.\n+* Augment rather than replace the standard stream formatting mechanism\n+* C++98 support, with optional C++11 niceties\n+\n+Build status, master branch:\n+[![Linux/OSX build](https://travis-ci.org/c42f/tinyformat.svg?branch=master)](https://travis-ci.org/c42f/tinyformat)\n+[![Windows build](https://ci.appveyor.com/api/projects/status/rwxqhhy6v5m0p1aq/branch/master?svg=true)](https://ci.appveyor.com/project/c42f/tinyformat/branch/master)\n+\n+## Quickstart\n+\n+To print a date to `std::cout`:\n+\n+```C++\n+std::string weekday = \"Wednesday\";\n+const char* month = \"July\";\n+size_t day = 27;\n+long hour = 14;\n+int min = 44;\n+\n+tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n+```\n+\n+The strange types here emphasize the type safety of the interface, for example\n+it is possible to print a `std::string` using the `\"%s\"` conversion, and a\n+`size_t` using the `\"%d\"` conversion.  A similar result could be achieved\n+using either of the `tfm::format()` functions.  One prints on a user provided\n+stream:\n+\n+```C++\n+tfm::format(std::cerr, \"%s, %s %d, %.2d:%.2d\\n\",\n+            weekday, month, day, hour, min);\n+```\n+\n+The other returns a `std::string`:\n+\n+```C++\n+std::string date = tfm::format(\"%s, %s %d, %.2d:%.2d\\n\",\n+                               weekday, month, day, hour, min);\n+std::cout << date;\n+```\n+\n+\n+It is safe to use tinyformat inside a template function.  For any type which\n+has the usual stream insertion `operator<<` defined, the following will work\n+as desired:\n+\n+```C++\n+template<typename T>\n+void myPrint(const T& value)\n+{\n+    tfm::printf(\"My value is '%s'\\n\", value);\n+}\n+```\n+\n+(The above is a compile error for types `T` without a stream insertion\n+operator.)\n+\n+\n+## Function reference\n+\n+All user facing functions are defined in the namespace `tinyformat`.  A\n+namespace alias `tfm` is provided to encourage brevity, but can easily be\n+disabled if desired.\n+\n+Three main interface functions are available: an iostreams-based `format()`,\n+a string-based `format()` and a `printf()` replacement.  These functions\n+can be thought of as C++ replacements for C's `fprintf()`, `sprintf()` and\n+`printf()` functions respectively.  All the interface functions can take an\n+unlimited number of input arguments if compiled with C++11 variadic templates\n+support.  In C++98 mode, the number of arguments must be limited to some fixed\n+upper bound which is currently 16 as of version 1.3. Supporting more arguments\n+is quite easy using the in-source code generator based on\n+[cog.py](http://nedbatchelder.com/code/cog) - see the source for details.\n+\n+The `format()` function which takes a stream as the first argument is the\n+main part of the tinyformat interface.  `stream` is the output stream,\n+`formatString` is a format string in C99 `printf()` format, and the values\n+to be formatted have arbitrary types:\n+\n+```C++\n+template<typename... Args>\n+void format(std::ostream& stream, const char* formatString,\n+            const Args&... args);\n+```\n+\n+The second version of `format()` is a convenience function which returns a\n+`std::string` rather than printing onto a stream.  This function simply\n+calls the main version of `format()` using a `std::ostringstream`, and\n+returns the resulting string:\n+\n+```C++\n+template<typename... Args>\n+std::string format(const char* formatString, const Args&... args);\n+```\n+\n+Finally, `printf()` and `printfln()` are convenience functions which call\n+`format()` with `std::cout` as the first argument; both have the same\n+signature:\n+\n+```C++\n+template<typename... Args>\n+void printf(const char* formatString, const Args&... args);\n+```\n+\n+`printfln()` is the same as `printf()` but appends an additional newline\n+for convenience - a concession to the author's tendency to forget the newline\n+when using the library for simple logging.\n+\n+## Format strings and type safety\n+\n+Tinyformat parses C99 format strings to guide the formatting process --- please\n+refer to any standard C99 printf documentation for format string syntax.  In\n+contrast to printf, tinyformat does not use the format string to decide on\n+the type to be formatted so this does not compromise the type safety: *you may\n+use any format specifier with any C++ type*.  The author suggests standardising\n+on the `%s` conversion unless formatting numeric types.\n+\n+Let's look at what happens when you execute the function call:\n+\n+```C++\n+tfm::format(outStream, \"%+6.4f\", yourType);\n+```\n+\n+First, the library parses the format string, and uses it to modify the state of\n+`outStream`:\n+\n+1. The `outStream` formatting flags are cleared and the width, precision and\n+   fill reset to the default.\n+2. The flag `'+'` means to prefix positive numbers with a `'+'`; tinyformat\n+   executes `outStream.setf(std::ios::showpos)`\n+3. The number 6 gives the field width; execute `outStream.width(6)`.\n+4. The number 4 gives the precision; execute `outStream.precision(4)`.\n+5. The conversion specification character `'f'` means that floats should be\n+   formatted with a fixed number of digits; this corresponds to executing\n+   `outStream.setf(std::ios::fixed, std::ios::floatfield);`\n+\n+After all these steps, tinyformat executes:\n+\n+```C++\n+outStream << yourType;\n+```\n+\n+and finally restores the stream flags, precision and fill.\n+\n+What happens if `yourType` isn't actually a floating point type?  In this\n+case the flags set above are probably irrelevant and will be ignored by the\n+underlying `std::ostream` implementation.  The field width of six may cause\n+some padding in the output of `yourType`, but that's about it.\n+\n+\n+### Special cases for \"%p\", \"%c\" and \"%s\"\n+\n+Tinyformat normally uses `operator<<` to convert types to strings.  However,\n+the \"%p\" and \"%c\" conversions require special rules for robustness.  Consider:\n+\n+```C++\n+uint8_t* pixels = get_pixels(/* ... */);\n+tfm::printf(\"%p\", pixels);\n+```\n+\n+Clearly the intention here is to print a representation of the *pointer* to\n+`pixels`, but since `uint8_t` is a character type the compiler would\n+attempt to print it as a C string if we blindly fed it into `operator<<`.  To\n+counter this kind of madness, tinyformat tries to static_cast any type fed to\n+the \"%p\" conversion into a `const void*` before printing.  If this can't be\n+done at compile time the library falls back to using `operator<<` as usual.\n+\n+The \"%c\" conversion has a similar problem: it signifies that the given integral\n+type should be converted into a `char` before printing.  The solution is\n+identical: attempt to convert the provided type into a char using\n+`static_cast` if possible, and if not fall back to using `operator<<`.\n+\n+The \"%s\" conversion sets the boolalpha flag on the formatting stream.  This\n+means that a `bool` variable printed with \"%s\" will come out as `true` or\n+`false` rather than the `1` or `0` that you would otherwise get.\n+\n+\n+### Incompatibilities with C99 printf\n+\n+Not all features of printf can be simulated simply using standard iostreams.\n+Here's a list of known incompatibilities:\n+\n+* The C99 `\"%a\"` and `\"%A\"` hexadecimal floating point conversions are not\n+  supported since the iostreams don't have the necessary flags.  Using either\n+  of these flags will result in a call to `TINYFORMAT_ERROR`.\n+* The precision for integer conversions cannot be supported by the iostreams\n+  state independently of the field width.  (Note: **this is only a\n+  problem for certain obscure integer conversions**; float conversions like\n+  `%6.4f` work correctly.)  In tinyformat the field width takes precedence,\n+  so the 4 in `%6.4d` will be ignored.  However, if the field width is not\n+  specified, the width used internally is set equal to the precision and padded\n+  with zeros on the left.  That is, a conversion like `%.4d` effectively\n+  becomes `%04d` internally.  This isn't correct for every case (eg, negative\n+  numbers end up with one less digit than desired) but it's about the closest\n+  simple solution within the iostream model.\n+* The `\"%n\"` query specifier isn't supported to keep things simple and will\n+  result in a call to `TINYFORMAT_ERROR`.\n+* The `\"%ls\"` conversion is not supported, and attempting to format a\n+  `wchar_t` array will cause a compile time error to minimise unexpected\n+  surprises.  If you know the encoding of your wchar_t strings, you could write\n+  your own `std::ostream` insertion operator for them, and disable the\n+  compile time check by defining the macro `TINYFORMAT_ALLOW_WCHAR_STRINGS`.\n+  If you want to print the *address* of a wide character with the `\"%p\"`\n+  conversion, you should cast it to a `void*` before passing it to one of the\n+  formatting functions.\n+\n+\n+## Error handling\n+\n+By default, tinyformat calls `assert()` if it encounters an error in the\n+format string or number of arguments.  This behaviour can be changed (for\n+example, to throw an exception) by defining the `TINYFORMAT_ERROR` macro\n+before including tinyformat.h, or editing the config section of the header.\n+\n+\n+## Formatting user defined types\n+\n+User defined types with a stream insertion operator will be formatted using\n+`operator<<(std::ostream&, T)` by default.  The `\"%s\"` format specifier is\n+suggested for user defined types, unless the type is inherently numeric.\n+\n+For further customization, the user can override the `formatValue()`\n+function to specify formatting independently of the stream insertion operator.\n+If you override this function, the library will have already parsed the format\n+specification and set the stream flags accordingly - see the source for details.\n+\n+\n+## Wrapping tfm::format() inside a user defined format function\n+\n+Suppose you wanted to define your own function which wraps `tfm::format`.\n+For example, consider an error function taking an error code, which in C++11\n+might be written simply as:\n+\n+```C++\n+template<typename... Args>\n+void error(int code, const char* fmt, const Args&... args)\n+{\n+    std::cerr << \"error (code \" << code << \")\";\n+    tfm::format(std::cerr, fmt, args...);\n+}\n+```\n+\n+Simulating this functionality in C++98 is pretty painful since it requires\n+writing out a version of `error()` for each desired number of arguments.  To\n+make this bearable tinyformat comes with a set of macros which are used\n+internally to generate the API, but which may also be used in user code.\n+\n+The three macros `TINYFORMAT_ARGTYPES(n)`, `TINYFORMAT_VARARGS(n)` and\n+`TINYFORMAT_PASSARGS(n)` will generate a list of `n` argument types,\n+type/name pairs and argument names respectively when called with an integer\n+`n` between 1 and 16.  We can use these to define a macro which generates the\n+desired user defined function with `n` arguments.  This should be followed by\n+a call to `TINYFORMAT_FOREACH_ARGNUM` to generate the set of functions for\n+all supported `n`:\n+\n+```C++\n+#define MAKE_ERROR_FUNC(n)                                    \\\n+template<TINYFORMAT_ARGTYPES(n)>                              \\\n+void error(int code, const char* fmt, TINYFORMAT_VARARGS(n))  \\\n+{                                                             \\\n+    std::cerr << \"error (code \" << code << \")\";               \\\n+    tfm::format(std::cerr, fmt, TINYFORMAT_PASSARGS(n));      \\\n+}\n+TINYFORMAT_FOREACH_ARGNUM(MAKE_ERROR_FUNC)\n+```\n+\n+Sometimes it's useful to be able to pass a list of format arguments through to\n+a non-template function.  The `FormatList` class is provided as a way to do\n+this by storing the argument list in a type-opaque way.  For example:\n+\n+```C++\n+template<typename... Args>\n+void error(int code, const char* fmt, const Args&... args)\n+{\n+    tfm::FormatListRef formatList = tfm::makeFormatList(args...);\n+    errorImpl(code, fmt, formatList);\n+}\n+```\n+\n+What's interesting here is that `errorImpl()` is a non-template function so\n+it could be separately compiled if desired.  The `FormatList` instance can be\n+used via a call to the `vformat()` function (the name chosen for semantic\n+similarity to `vprintf()`):\n+\n+```C++\n+void errorImpl(int code, const char* fmt, tfm::FormatListRef formatList)\n+{\n+    std::cerr << \"error (code \" << code << \")\";\n+    tfm::vformat(std::cout, fmt, formatList);\n+}\n+```\n+\n+The construction of a `FormatList` instance is very lightweight - it defers\n+all formatting and simply stores a couple of function pointers and a value\n+pointer per argument.  Since most of the actual work is done inside\n+`vformat()`, any logic which causes an early exit of `errorImpl()` -\n+filtering of verbose log messages based on error code for example - could be a\n+useful optimization for programs using tinyformat.  (A faster option would be\n+to write any early bailout code inside `error()`, though this must be done in\n+the header.)\n+\n+\n+## Benchmarks\n+\n+### Compile time and code bloat\n+\n+The script `bloat_test.sh` included in the repository tests whether\n+tinyformat succeeds in avoiding compile time and code bloat for nontrivial\n+projects.  The idea is to include `tinyformat.h` into 100 translation units\n+and use `printf()` five times in each to simulate a medium sized project.\n+The resulting executable size and compile time (g++-4.8.2, linux ubuntu 14.04)\n+is shown in the following tables, which can be regenerated using `make\n+bloat_test`:\n+\n+**Non-optimized build**\n+\n+| test name              | compiler wall time | executable size (stripped) |\n+| ---------------------- | ------------------ | -------------------------- |\n+| libc printf            | 1.8s               | 48K  (36K)                 |\n+| std::ostream           | 10.7s              | 96K  (76K)                 |\n+| tinyformat, no inlines | 18.9s              | 140K (104K)                |\n+| tinyformat             | 21.1s              | 220K (180K)                |\n+| tinyformat, c++0x mode | 20.7s              | 220K (176K)                |\n+| boost::format          | 70.1s              | 844K (736K)                |\n+\n+**Optimized build (-O3 -DNDEBUG)**\n+\n+| test name              | compiler wall time | executable size (stripped) |\n+| ---------------------- | ------------------ | -------------------------- |\n+| libc printf            | 2.3s               | 40K  (28K)                 |\n+| std::ostream           | 11.8s              | 104K (80K)                 |\n+| tinyformat, no inlines | 23.0s              | 128K (104K)                |\n+| tinyformat             | 32.9s              | 128K (104K)                |\n+| tinyformat, c++0x mode | 34.0s              | 128K (104K)                |\n+| boost::format          | 147.9s             | 644K (600K)                |\n+\n+For large projects it's arguably worthwhile to do separate compilation of the\n+non-templated parts of tinyformat, as shown in the rows labelled *tinyformat,\n+no inlines*.  These were generated by putting the implementation of `vformat`\n+(`detail::formatImpl()` etc) it into a separate file, tinyformat.cpp.  Note\n+that the results above can vary considerably with different compilers.  For\n+example, the `-fipa-cp-clone` optimization pass in g++-4.6 resulted in\n+excessively large binaries.  On the other hand, the g++-4.8 results are quite\n+similar to using clang++-3.4.\n+\n+\n+### Speed tests\n+\n+The following speed tests results were generated by building\n+`tinyformat_speed_test.cpp` on an Intel core i7-2600K running Linux Ubuntu\n+14.04 with g++-4.8.2 using `-O3 -DNDEBUG`.  In the test, the format string\n+`\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\"` is filled 2000000 times with output sent to\n+`/dev/null`; for further details see the source and Makefile.\n+\n+| test name      | run time |\n+| -------------- | -------- |\n+| libc printf    | 1.20s    |\n+| std::ostream   | 1.82s    |\n+| tinyformat     | 2.08s    |\n+| boost::format  | 9.04s    |\n+\n+It's likely that tinyformat has an advantage over boost.format because it tries\n+reasonably hard to avoid formatting into temporary strings, preferring instead\n+to send the results directly to the stream buffer.  Tinyformat cannot\n+be faster than the iostreams because it uses them internally, but it comes\n+acceptably close.\n+\n+\n+## Rationale\n+\n+Or, why did I reinvent this particularly well studied wheel?\n+\n+Nearly every program needs text formatting in some form but in many cases such\n+formatting is *incidental* to the main purpose of the program.  In these cases,\n+you really want a library which is simple to use but as lightweight as\n+possible.\n+\n+The ultimate in lightweight dependencies are the solutions provided by the C++\n+and C libraries.  However, both the C++ iostreams and C's printf() have\n+well known usability problems: iostreams are hopelessly verbose for complicated\n+formatting and printf() lacks extensibility and type safety.  For example:\n+\n+```C++\n+// Verbose; hard to read, hard to type:\n+std::cout << std::setprecision(2) << std::fixed << 1.23456 << \"\\n\";\n+// The alternative using a format string is much easier on the eyes\n+tfm::printf(\"%.2f\\n\", 1.23456);\n+\n+// Type mismatch between \"%s\" and int: will cause a segfault at runtime!\n+printf(\"%s\", 1);\n+// The following is perfectly fine, and will result in \"1\" being printed.\n+tfm::printf(\"%s\", 1);\n+```\n+\n+On the other hand, there are plenty of excellent and complete libraries which\n+solve the formatting problem in great generality (boost.format and fastformat\n+come to mind, but there are many others).  Unfortunately these kind of\n+libraries tend to be rather heavy dependencies, far too heavy for projects\n+which need to do only a little formatting.  Problems include\n+\n+1. Having many large source files.  This makes a heavy dependency unsuitable to\n+   bundle within other projects for convenience.\n+2. Slow build times for every file using any sort of formatting (this is very\n+   noticeable with g++ and boost/format.hpp. I'm not sure about the various\n+   other alternatives.)\n+3. Code bloat due to instantiating many templates\n+\n+Tinyformat tries to solve these problems while providing formatting which is\n+sufficiently general and fast for incidental day to day uses.\n+\n+\n+## License\n+\n+For minimum license-related fuss, tinyformat.h is distributed under the boost\n+software license, version 1.0.  (Summary: you must keep the license text on\n+all source copies, but don't have to mention tinyformat when distributing\n+binaries.)\n+\n+\n+## Author and acknowledgements\n+\n+Tinyformat was written by Chris Foster, with contributions from various people\n+as recorded in the git repository.\n+The implementation owes a lot to `boost::format` for showing that it's fairly\n+easy to use stream based formatting to simulate most of the `printf()`\n+syntax.  Douglas Gregor's introduction to variadic templates --- see\n+http://www.generic-programming.org/~dgregor/cpp/variadic-templates.html --- was\n+also helpful, especially since it solves exactly the `printf()` problem for\n+the case of trivial format strings.\n+\n+## Bugs\n+\n+Here's a list of known bugs which are probably cumbersome to fix:\n+\n+* Field padding won't work correctly with complicated user defined types.  For\n+  general types, the only way to do this correctly seems to be format to a\n+  temporary string stream, check the length, and finally send to the output\n+  stream with padding if necessary.  Doing this for all types would be\n+  quite inelegant because it implies extra allocations to make the temporary\n+  stream.  A workaround is to add logic to `operator<<()` for composite user\n+  defined types so they are aware of the stream field width."
      },
      {
        "sha": "160f21e25a97385b24804f538fa8deb570b5ba5d",
        "filename": "src/tinyformat/appveyor.yml",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/appveyor.yml?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,52 @@\n+# Windows CI build via the Appveyor service\n+\n+version: '{build}'\n+\n+# branches to build\n+branches:\n+  only:\n+    - master\n+\n+# scripts that are called at very beginning, before repo cloning\n+init:\n+  - git config --global core.autocrlf input\n+\n+# Build matrix variables -\n+#   * environment\n+#   * platform\n+#   * configuration\n+environment:\n+  matrix:\n+    - COMPILER: \"Visual Studio 12 Win64\"\n+    - COMPILER: \"Visual Studio 14 Win64\"\n+    - COMPILER: \"Visual Studio 15 Win64\"\n+      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n+\n+# build platform, i.e. x86, x64, Any CPU.\n+platform:\n+  - x86\n+  - x64\n+\n+# build Configuration, i.e. Debug, Release, etc.\n+configuration:\n+  - Debug\n+  - Release\n+\n+before_build:\n+  - echo --------------------------------------------------------------------------------\n+  - echo Appveyor environment info:\n+  - echo COMPILER = %COMPILER%, CONFIGURATION = %CONFIGURATION%\n+  - cmake -h\n+\n+build_script:\n+  - echo --------------------------------------------------------------------------------\n+  - echo Build tinyformat\n+  - mkdir build\n+  - cd build\n+  - cmake -G \"%COMPILER%\" ..\n+  - cmake --build . --config %CONFIGURATION%\n+\n+test_script:\n+  # cmake testall target has problems finding the correct configuration, so use ctest directly.\n+  - ctest -C %CONFIGURATION%\n+"
      },
      {
        "sha": "8f6961fe34ebbe613e2f93e38be82a703cc4f81e",
        "filename": "src/tinyformat/bloat_test.sh",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/bloat_test.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/bloat_test.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/bloat_test.sh?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,105 @@\n+#!/bin/bash\n+\n+# Script to test how much bloating a large project will suffer when using\n+# tinyformat, vs alternatives.  Call as\n+#\n+# C99 printf            :  bloat_test.sh $CXX [-O3]\n+# tinyformat            :  bloat_test.sh $CXX [-O3] -DUSE_TINYFORMAT\n+# tinyformat, no inlines:  bloat_test.sh $CXX [-O3] -DUSE_TINYFORMAT -DUSE_TINYFORMAT_NOINLINE\n+# boost::format         :  bloat_test.sh $CXX [-O3] -DUSE_BOOST\n+# std::iostream         :  bloat_test.sh $CXX [-O3] -DUSE_IOSTREAMS\n+#\n+# Note: to test the NOINLINE version of tinyformat, you need to remove the few\n+# inline functions in the tinyformat::detail namespace, and put them into a\n+# file tinyformat.cpp.  Then rename that version of tinyformat.h into\n+# tinyformat_noinline.h\n+\n+\n+prefix=_bloat_test_tmp_\n+numTranslationUnits=100\n+\n+rm -f $prefix??.cpp ${prefix}main.cpp ${prefix}all.h\n+\n+template='\n+#ifdef USE_BOOST\n+\n+#include <boost/format.hpp>\n+#include <iostream>\n+\n+void doFormat_a()\n+{\n+    std::cout << boost::format(\"%s\\n\") % \"somefile.cpp\";\n+    std::cout << boost::format(\"%s:%d\\n\") % \"somefile.cpp\"% 42;\n+    std::cout << boost::format(\"%s:%d:%s\\n\") % \"somefile.cpp\"% 42% \"asdf\";\n+    std::cout << boost::format(\"%s:%d:%d:%s\\n\") % \"somefile.cpp\"% 42% 1% \"asdf\";\n+    std::cout << boost::format(\"%s:%d:%d:%d:%s\\n\") % \"somefile.cpp\"% 42% 1% 2% \"asdf\";\n+}\n+\n+#elif defined(USE_IOSTREAMS)\n+\n+#include <iostream>\n+\n+void doFormat_a()\n+{\n+    const char* str1 = \"somefile.cpp\";\n+    const char* str2 = \"asdf\";\n+    std::cout << str1 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \":\" << str2 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \":\" << 1 << \":\" << str2 << \"\\n\";\n+    std::cout << str1 << \":\" << 42 << \":\" << 1 << \":\" << 2 << \":\" << str2 << \"\\n\";\n+}\n+\n+#else\n+#ifdef USE_TINYFORMAT\n+#   ifdef USE_TINYFORMAT_NOINLINE\n+#       include \"tinyformat_noinline.h\"\n+#   else\n+#       include \"tinyformat.h\"\n+#   endif\n+#   define PRINTF tfm::printf\n+#else\n+#   include <stdio.h>\n+#   define PRINTF ::printf\n+#endif\n+\n+void doFormat_a()\n+{\n+    const char* str1 = \"somefile.cpp\";\n+    const char* str2 = \"asdf\";\n+    PRINTF(\"%s\\n\", str1);\n+    PRINTF(\"%s:%d\\n\", str1, 42);\n+    PRINTF(\"%s:%d:%s\\n\", str1, 42, str2);\n+    PRINTF(\"%s:%d:%d:%s\\n\", str1, 42, 1, str2);\n+    PRINTF(\"%s:%d:%d:%d:%s\\n\", str1, 42, 1, 2, str2);\n+}\n+#endif\n+'\n+\n+# Generate all the files\n+echo \"#include \\\"${prefix}all.h\\\"\" >> ${prefix}main.cpp\n+echo '\n+#ifdef USE_TINYFORMAT_NOINLINE\n+#include \"tinyformat.cpp\"\n+#endif\n+\n+int main()\n+{' >> ${prefix}main.cpp\n+\n+for ((i=0;i<$numTranslationUnits;i++)) ; do\n+    n=$(printf \"%03d\" $i)\n+    f=${prefix}$n.cpp\n+    echo \"$template\" | sed -e \"s/doFormat_a/doFormat_a$n/\" -e \"s/42/$i/\" > $f\n+    echo \"doFormat_a$n();\" >> ${prefix}main.cpp\n+    echo \"void doFormat_a$n();\" >> ${prefix}all.h\n+done\n+\n+echo \"return 0; }\" >> ${prefix}main.cpp\n+\n+\n+# Compile\n+time \"$@\" ${prefix}???.cpp ${prefix}main.cpp -o ${prefix}.out\n+ls -sh ${prefix}.out\n+cp ${prefix}.out ${prefix}stripped.out\n+strip ${prefix}stripped.out\n+ls -sh ${prefix}stripped.out"
      },
      {
        "sha": "85a22c15ab17de08e9894acd0afcda5fbecc39c5",
        "filename": "src/tinyformat/tinyformat.h",
        "status": "added",
        "additions": 1051,
        "deletions": 0,
        "changes": 1051,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/tinyformat.h?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,1051 @@\n+// tinyformat.h\n+// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]\n+//\n+// Boost Software License - Version 1.0\n+//\n+// Permission is hereby granted, free of charge, to any person or organization\n+// obtaining a copy of the software and accompanying documentation covered by\n+// this license (the \"Software\") to use, reproduce, display, distribute,\n+// execute, and transmit the Software, and to prepare derivative works of the\n+// Software, and to permit third-parties to whom the Software is furnished to\n+// do so, all subject to the following:\n+//\n+// The copyright notices in the Software and this entire statement, including\n+// the above license grant, this restriction and the following disclaimer,\n+// must be included in all copies of the Software, in whole or in part, and\n+// all derivative works of the Software, unless such copies or derivative\n+// works are solely in the form of machine-executable object code generated by\n+// a source language processor.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n+// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n+// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+\n+//------------------------------------------------------------------------------\n+// Tinyformat: A minimal type safe printf replacement\n+//\n+// tinyformat.h is a type safe printf replacement library in a single C++\n+// header file.  Design goals include:\n+//\n+// * Type safety and extensibility for user defined types.\n+// * C99 printf() compatibility, to the extent possible using std::ostream\n+// * Simplicity and minimalism.  A single header file to include and distribute\n+//   with your projects.\n+// * Augment rather than replace the standard stream formatting mechanism\n+// * C++98 support, with optional C++11 niceties\n+//\n+//\n+// Main interface example usage\n+// ----------------------------\n+//\n+// To print a date to std::cout:\n+//\n+//   std::string weekday = \"Wednesday\";\n+//   const char* month = \"July\";\n+//   size_t day = 27;\n+//   long hour = 14;\n+//   int min = 44;\n+//\n+//   tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n+//\n+// The strange types here emphasize the type safety of the interface; it is\n+// possible to print a std::string using the \"%s\" conversion, and a\n+// size_t using the \"%d\" conversion.  A similar result could be achieved\n+// using either of the tfm::format() functions.  One prints on a user provided\n+// stream:\n+//\n+//   tfm::format(std::cerr, \"%s, %s %d, %.2d:%.2d\\n\",\n+//               weekday, month, day, hour, min);\n+//\n+// The other returns a std::string:\n+//\n+//   std::string date = tfm::format(\"%s, %s %d, %.2d:%.2d\\n\",\n+//                                  weekday, month, day, hour, min);\n+//   std::cout << date;\n+//\n+// These are the three primary interface functions.  There is also a\n+// convenience function printfln() which appends a newline to the usual result\n+// of printf() for super simple logging.\n+//\n+//\n+// User defined format functions\n+// -----------------------------\n+//\n+// Simulating variadic templates in C++98 is pretty painful since it requires\n+// writing out the same function for each desired number of arguments.  To make\n+// this bearable tinyformat comes with a set of macros which are used\n+// internally to generate the API, but which may also be used in user code.\n+//\n+// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and\n+// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,\n+// type/name pairs and argument names respectively when called with an integer\n+// n between 1 and 16.  We can use these to define a macro which generates the\n+// desired user defined function with n arguments.  To generate all 16 user\n+// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an\n+// example, see the implementation of printf() at the end of the source file.\n+//\n+// Sometimes it's useful to be able to pass a list of format arguments through\n+// to a non-template function.  The FormatList class is provided as a way to do\n+// this by storing the argument list in a type-opaque way.  Continuing the\n+// example from above, we construct a FormatList using makeFormatList():\n+//\n+//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);\n+//\n+// The format list can now be passed into any non-template function and used\n+// via a call to the vformat() function:\n+//\n+//   tfm::vformat(std::cout, \"%s, %s %d, %.2d:%.2d\\n\", formatList);\n+//\n+//\n+// Additional API information\n+// --------------------------\n+//\n+// Error handling: Define TINYFORMAT_ERROR to customize the error handling for\n+// format strings which are unsupported or have the wrong number of format\n+// specifiers (calls assert() by default).\n+//\n+// User defined types: Uses operator<< for user defined types by default.\n+// Overload formatValue() for more control.\n+\n+\n+#ifndef TINYFORMAT_H_INCLUDED\n+#define TINYFORMAT_H_INCLUDED\n+\n+namespace tinyformat {}\n+//------------------------------------------------------------------------------\n+// Config section.  Customize to your liking!\n+\n+// Namespace alias to encourage brevity\n+namespace tfm = tinyformat;\n+\n+// Error handling; calls assert() by default.\n+// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)\n+\n+// Define for C++11 variadic templates which make the code shorter & more\n+// general.  If you don't define this, C++11 support is autodetected below.\n+// #define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+\n+//------------------------------------------------------------------------------\n+// Implementation details.\n+#include <algorithm>\n+#include <cassert>\n+#include <iostream>\n+#include <sstream>\n+\n+#ifndef TINYFORMAT_ERROR\n+#   define TINYFORMAT_ERROR(reason) assert(0 && reason)\n+#endif\n+\n+#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)\n+#   ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#       define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+#   endif\n+#endif\n+\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n+//  std::showpos is broken on old libstdc++ as provided with OSX.  See\n+//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n+#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+#endif\n+\n+#ifdef __APPLE__\n+// Workaround OSX linker warning: xcode uses different default symbol\n+// visibilities for static libs vs executables (see issue #25)\n+#   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n+#else\n+#   define TINYFORMAT_HIDDEN\n+#endif\n+\n+namespace tinyformat {\n+\n+//------------------------------------------------------------------------------\n+namespace detail {\n+\n+// Test whether type T1 is convertible to type T2\n+template <typename T1, typename T2>\n+struct is_convertible\n+{\n+    private:\n+        // two types of different size\n+        struct fail { char dummy[2]; };\n+        struct succeed { char dummy; };\n+        // Try to convert a T1 to a T2 by plugging into tryConvert\n+        static fail tryConvert(...);\n+        static succeed tryConvert(const T2&);\n+        static const T1& makeT1();\n+    public:\n+#       ifdef _MSC_VER\n+        // Disable spurious loss of precision warnings in tryConvert(makeT1())\n+#       pragma warning(push)\n+#       pragma warning(disable:4244)\n+#       pragma warning(disable:4267)\n+#       endif\n+        // Standard trick: the (...) version of tryConvert will be chosen from\n+        // the overload set only if the version taking a T2 doesn't match.\n+        // Then we compare the sizes of the return types to check which\n+        // function matched.  Very neat, in a disgusting kind of way :)\n+        static const bool value =\n+            sizeof(tryConvert(makeT1())) == sizeof(succeed);\n+#       ifdef _MSC_VER\n+#       pragma warning(pop)\n+#       endif\n+};\n+\n+\n+// Detect when a type is not a wchar_t string\n+template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };\n+template<> struct is_wchar<wchar_t*> {};\n+template<> struct is_wchar<const wchar_t*> {};\n+template<int n> struct is_wchar<const wchar_t[n]> {};\n+template<int n> struct is_wchar<wchar_t[n]> {};\n+\n+\n+// Format the value by casting to type fmtT.  This default implementation\n+// should never be called.\n+template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>\n+struct formatValueAsType\n+{\n+    static void invoke(std::ostream& /*out*/, const T& /*value*/) { assert(0); }\n+};\n+// Specialized version for types that can actually be converted to fmtT, as\n+// indicated by the \"convertible\" template parameter.\n+template<typename T, typename fmtT>\n+struct formatValueAsType<T,fmtT,true>\n+{\n+    static void invoke(std::ostream& out, const T& value)\n+        { out << static_cast<fmtT>(value); }\n+};\n+\n+#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+template<typename T, bool convertible = is_convertible<T, int>::value>\n+struct formatZeroIntegerWorkaround\n+{\n+    static bool invoke(std::ostream& /**/, const T& /**/) { return false; }\n+};\n+template<typename T>\n+struct formatZeroIntegerWorkaround<T,true>\n+{\n+    static bool invoke(std::ostream& out, const T& value)\n+    {\n+        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos)\n+        {\n+            out << \"+0\";\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+\n+// Convert an arbitrary type to integer.  The version with convertible=false\n+// throws an error.\n+template<typename T, bool convertible = is_convertible<T,int>::value>\n+struct convertToInt\n+{\n+    static int invoke(const T& /*value*/)\n+    {\n+        TINYFORMAT_ERROR(\"tinyformat: Cannot convert from argument type to \"\n+                         \"integer for use as variable width or precision\");\n+        return 0;\n+    }\n+};\n+// Specialization for convertToInt when conversion is possible\n+template<typename T>\n+struct convertToInt<T,true>\n+{\n+    static int invoke(const T& value) { return static_cast<int>(value); }\n+};\n+\n+// Format at most ntrunc characters to the given stream.\n+template<typename T>\n+inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)\n+{\n+    std::ostringstream tmp;\n+    tmp << value;\n+    std::string result = tmp.str();\n+    out.write(result.c_str(), (std::min)(ntrunc, static_cast<int>(result.size())));\n+}\n+#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \\\n+inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \\\n+{                                                           \\\n+    std::streamsize len = 0;                                \\\n+    while(len < ntrunc && value[len] != 0)                  \\\n+        ++len;                                              \\\n+    out.write(value, len);                                  \\\n+}\n+// Overload for const char* and char*.  Could overload for signed & unsigned\n+// char too, but these are technically unneeded for printf compatibility.\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)\n+#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR\n+\n+} // namespace detail\n+\n+\n+//------------------------------------------------------------------------------\n+// Variable formatting functions.  May be overridden for user-defined types if\n+// desired.\n+\n+\n+/// Format a value into a stream, delegating to operator<< by default.\n+///\n+/// Users may override this for their own types.  When this function is called,\n+/// the stream flags will have been modified according to the format string.\n+/// The format specification is provided in the range [fmtBegin, fmtEnd).  For\n+/// truncating conversions, ntrunc is set to the desired maximum number of\n+/// characters, for example \"%.7s\" calls formatValue with ntrunc = 7.\n+///\n+/// By default, formatValue() uses the usual stream insertion operator\n+/// operator<< to format the type T, with special cases for the %c and %p\n+/// conversions.\n+template<typename T>\n+inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n+                        const char* fmtEnd, int ntrunc, const T& value)\n+{\n+#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS\n+    // Since we don't support printing of wchar_t using \"%ls\", make it fail at\n+    // compile time in preference to printing as a void* at runtime.\n+    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;\n+    (void) DummyType(); // avoid unused type warning with gcc-4.8\n+#endif\n+    // The mess here is to support the %c and %p conversions: if these\n+    // conversions are active we try to convert the type to a char or const\n+    // void* respectively and format that instead of the value itself.  For the\n+    // %p conversion it's important to avoid dereferencing the pointer, which\n+    // could otherwise lead to a crash when printing a dangling (const char*).\n+    const bool canConvertToChar = detail::is_convertible<T,char>::value;\n+    const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;\n+    if(canConvertToChar && *(fmtEnd-1) == 'c')\n+        detail::formatValueAsType<T, char>::invoke(out, value);\n+    else if(canConvertToVoidPtr && *(fmtEnd-1) == 'p')\n+        detail::formatValueAsType<T, const void*>::invoke(out, value);\n+#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+    else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n+#endif\n+    else if(ntrunc >= 0)\n+    {\n+        // Take care not to overread C strings in truncating conversions like\n+        // \"%.4s\" where at most 4 characters may be read.\n+        detail::formatTruncated(out, value, ntrunc);\n+    }\n+    else\n+        out << value;\n+}\n+\n+\n+// Overloaded version for char types to support printing as an integer\n+#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \\\n+inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n+                        const char* fmtEnd, int /**/, charType value) \\\n+{                                                                     \\\n+    switch(*(fmtEnd-1))                                               \\\n+    {                                                                 \\\n+        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \\\n+            out << static_cast<int>(value); break;                    \\\n+        default:                                                      \\\n+            out << value;                   break;                    \\\n+    }                                                                 \\\n+}\n+// per 3.9.1: char, signed char and unsigned char are all distinct types\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)\n+#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR\n+\n+\n+//------------------------------------------------------------------------------\n+// Tools for emulating variadic templates in C++98.  The basic idea here is\n+// stolen from the boost preprocessor metaprogramming library and cut down to\n+// be just general enough for what we need.\n+\n+#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n\n+#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n\n+#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n\n+#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n\n+\n+// To keep it as transparent as possible, the macros below have been generated\n+// using python via the excellent cog.py code generation script.  This avoids\n+// the need for a bunch of complex (but more general) preprocessor tricks as\n+// used in boost.preprocessor.\n+//\n+// To rerun the code generation in place, use `cog.py -r tinyformat.h`\n+// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create\n+// extra versions by hand.\n+\n+/*[[[cog\n+maxParams = 16\n+\n+def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):\n+    for j in range(startInd,maxParams+1):\n+        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])\n+        cog.outl(lineTemplate % {'j':j, 'list':list})\n+\n+makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',\n+                  'class T%(i)d')\n+\n+cog.outl()\n+makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',\n+                  'const T%(i)d& v%(i)d')\n+\n+cog.outl()\n+makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')\n+\n+cog.outl()\n+cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')\n+makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',\n+                  'v%(i)d', startInd = 2)\n+\n+cog.outl()\n+cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\\\\n    ' +\n+         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))\n+]]]*/\n+#define TINYFORMAT_ARGTYPES_1 class T1\n+#define TINYFORMAT_ARGTYPES_2 class T1, class T2\n+#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3\n+#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4\n+#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5\n+#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6\n+#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7\n+#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8\n+#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9\n+#define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10\n+#define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11\n+#define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12\n+#define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13\n+#define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14\n+#define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15\n+#define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16\n+\n+#define TINYFORMAT_VARARGS_1 const T1& v1\n+#define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2\n+#define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3\n+#define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4\n+#define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5\n+#define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6\n+#define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7\n+#define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8\n+#define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9\n+#define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10\n+#define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11\n+#define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12\n+#define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13\n+#define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14\n+#define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15\n+#define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16\n+\n+#define TINYFORMAT_PASSARGS_1 v1\n+#define TINYFORMAT_PASSARGS_2 v1, v2\n+#define TINYFORMAT_PASSARGS_3 v1, v2, v3\n+#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4\n+#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5\n+#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6\n+#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7\n+#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8\n+#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9\n+#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10\n+#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n+#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n+#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n+#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n+#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n+#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n+\n+#define TINYFORMAT_PASSARGS_TAIL_1\n+#define TINYFORMAT_PASSARGS_TAIL_2 , v2\n+#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3\n+#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4\n+#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5\n+#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6\n+#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7\n+#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8\n+#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9\n+#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10\n+#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n+#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n+#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n+#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n+#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n+#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n+\n+#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n+    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)\n+//[[[end]]]\n+\n+\n+\n+namespace detail {\n+\n+// Type-opaque holder for an argument to format(), with associated actions on\n+// the type held as explicit function pointers.  This allows FormatArg's for\n+// each argument to be allocated as a homogenous array inside FormatList\n+// whereas a naive implementation based on inheritance does not.\n+class FormatArg\n+{\n+    public:\n+        FormatArg()\n+            : m_value(NULL),\n+            m_formatImpl(NULL),\n+            m_toIntImpl(NULL)\n+        { }\n+\n+        template<typename T>\n+        FormatArg(const T& value)\n+            : m_value(static_cast<const void*>(&value)),\n+            m_formatImpl(&formatImpl<T>),\n+            m_toIntImpl(&toIntImpl<T>)\n+        { }\n+\n+        void format(std::ostream& out, const char* fmtBegin,\n+                    const char* fmtEnd, int ntrunc) const\n+        {\n+            assert(m_value);\n+            assert(m_formatImpl);\n+            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);\n+        }\n+\n+        int toInt() const\n+        {\n+            assert(m_value);\n+            assert(m_toIntImpl);\n+            return m_toIntImpl(m_value);\n+        }\n+\n+    private:\n+        template<typename T>\n+        TINYFORMAT_HIDDEN static void formatImpl(std::ostream& out, const char* fmtBegin,\n+                        const char* fmtEnd, int ntrunc, const void* value)\n+        {\n+            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));\n+        }\n+\n+        template<typename T>\n+        TINYFORMAT_HIDDEN static int toIntImpl(const void* value)\n+        {\n+            return convertToInt<T>::invoke(*static_cast<const T*>(value));\n+        }\n+\n+        const void* m_value;\n+        void (*m_formatImpl)(std::ostream& out, const char* fmtBegin,\n+                             const char* fmtEnd, int ntrunc, const void* value);\n+        int (*m_toIntImpl)(const void* value);\n+};\n+\n+\n+// Parse and return an integer from the string c, as atoi()\n+// On return, c is set to one past the end of the integer.\n+inline int parseIntAndAdvance(const char*& c)\n+{\n+    int i = 0;\n+    for(;*c >= '0' && *c <= '9'; ++c)\n+        i = 10*i + (*c - '0');\n+    return i;\n+}\n+\n+// Print literal part of format string and return next format spec\n+// position.\n+//\n+// Skips over any occurrences of '%%', printing a literal '%' to the\n+// output.  The position of the first % character of the next\n+// nontrivial format spec is returned, or the end of string.\n+inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n+{\n+    const char* c = fmt;\n+    for(;; ++c)\n+    {\n+        switch(*c)\n+        {\n+            case '\\0':\n+                out.write(fmt, c - fmt);\n+                return c;\n+            case '%':\n+                out.write(fmt, c - fmt);\n+                if(*(c+1) != '%')\n+                    return c;\n+                // for \"%%\", tack trailing % onto next literal section.\n+                fmt = ++c;\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+}\n+\n+\n+// Parse a format string and set the stream state accordingly.\n+//\n+// The format mini-language recognized here is meant to be the one from C99,\n+// with the form \"%[flags][width][.precision][length]type\".\n+//\n+// Formatting options which can't be natively represented using the ostream\n+// state are returned in spacePadPositive (for space padded positive numbers)\n+// and ntrunc (for truncating conversions).  argIndex is incremented if\n+// necessary to pull out variable width and precision .  The function returns a\n+// pointer to the character after the end of the current format spec.\n+inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n+                                         int& ntrunc, const char* fmtStart,\n+                                         const detail::FormatArg* formatters,\n+                                         int& argIndex, int numFormatters)\n+{\n+    if(*fmtStart != '%')\n+    {\n+        TINYFORMAT_ERROR(\"tinyformat: Not enough conversion specifiers in format string\");\n+        return fmtStart;\n+    }\n+    // Reset stream state to defaults.\n+    out.width(0);\n+    out.precision(6);\n+    out.fill(' ');\n+    // Reset most flags; ignore irrelevant unitbuf & skipws.\n+    out.unsetf(std::ios::adjustfield | std::ios::basefield |\n+               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |\n+               std::ios::showpoint | std::ios::showpos | std::ios::uppercase);\n+    bool precisionSet = false;\n+    bool widthSet = false;\n+    int widthExtra = 0;\n+    const char* c = fmtStart + 1;\n+    // 1) Parse flags\n+    for(;; ++c)\n+    {\n+        switch(*c)\n+        {\n+            case '#':\n+                out.setf(std::ios::showpoint | std::ios::showbase);\n+                continue;\n+            case '0':\n+                // overridden by left alignment ('-' flag)\n+                if(!(out.flags() & std::ios::left))\n+                {\n+                    // Use internal padding so that numeric values are\n+                    // formatted correctly, eg -00010 rather than 000-10\n+                    out.fill('0');\n+                    out.setf(std::ios::internal, std::ios::adjustfield);\n+                }\n+                continue;\n+            case '-':\n+                out.fill(' ');\n+                out.setf(std::ios::left, std::ios::adjustfield);\n+                continue;\n+            case ' ':\n+                // overridden by show positive sign, '+' flag.\n+                if(!(out.flags() & std::ios::showpos))\n+                    spacePadPositive = true;\n+                continue;\n+            case '+':\n+                out.setf(std::ios::showpos);\n+                spacePadPositive = false;\n+                widthExtra = 1;\n+                continue;\n+            default:\n+                break;\n+        }\n+        break;\n+    }\n+    // 2) Parse width\n+    if(*c >= '0' && *c <= '9')\n+    {\n+        widthSet = true;\n+        out.width(parseIntAndAdvance(c));\n+    }\n+    if(*c == '*')\n+    {\n+        widthSet = true;\n+        int width = 0;\n+        if(argIndex < numFormatters)\n+            width = formatters[argIndex++].toInt();\n+        else\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width\");\n+        if(width < 0)\n+        {\n+            // negative widths correspond to '-' flag set\n+            out.fill(' ');\n+            out.setf(std::ios::left, std::ios::adjustfield);\n+            width = -width;\n+        }\n+        out.width(width);\n+        ++c;\n+    }\n+    // 3) Parse precision\n+    if(*c == '.')\n+    {\n+        ++c;\n+        int precision = 0;\n+        if(*c == '*')\n+        {\n+            ++c;\n+            if(argIndex < numFormatters)\n+                precision = formatters[argIndex++].toInt();\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable precision\");\n+        }\n+        else\n+        {\n+            if(*c >= '0' && *c <= '9')\n+                precision = parseIntAndAdvance(c);\n+            else if(*c == '-') // negative precisions ignored, treated as zero.\n+                parseIntAndAdvance(++c);\n+        }\n+        out.precision(precision);\n+        precisionSet = true;\n+    }\n+    // 4) Ignore any C99 length modifier\n+    while(*c == 'l' || *c == 'h' || *c == 'L' ||\n+          *c == 'j' || *c == 'z' || *c == 't')\n+        ++c;\n+    // 5) We're up to the conversion specifier character.\n+    // Set stream flags based on conversion specifier (thanks to the\n+    // boost::format class for forging the way here).\n+    bool intConversion = false;\n+    switch(*c)\n+    {\n+        case 'u': case 'd': case 'i':\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'o':\n+            out.setf(std::ios::oct, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'X':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'x': case 'p':\n+            out.setf(std::ios::hex, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'E':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'e':\n+            out.setf(std::ios::scientific, std::ios::floatfield);\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            break;\n+        case 'F':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'f':\n+            out.setf(std::ios::fixed, std::ios::floatfield);\n+            break;\n+        case 'G':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'g':\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            // As in boost::format, let stream decide float format.\n+            out.flags(out.flags() & ~std::ios::floatfield);\n+            break;\n+        case 'a': case 'A':\n+            TINYFORMAT_ERROR(\"tinyformat: the %a and %A conversion specs \"\n+                             \"are not supported\");\n+            break;\n+        case 'c':\n+            // Handled as special case inside formatValue()\n+            break;\n+        case 's':\n+            if(precisionSet)\n+                ntrunc = static_cast<int>(out.precision());\n+            // Make %s print booleans as \"true\" and \"false\"\n+            out.setf(std::ios::boolalpha);\n+            break;\n+        case 'n':\n+            // Not supported - will cause problems!\n+            TINYFORMAT_ERROR(\"tinyformat: %n conversion spec not supported\");\n+            break;\n+        case '\\0':\n+            TINYFORMAT_ERROR(\"tinyformat: Conversion spec incorrectly \"\n+                             \"terminated by end of string\");\n+            return c;\n+        default:\n+            break;\n+    }\n+    if(intConversion && precisionSet && !widthSet)\n+    {\n+        // \"precision\" for integers gives the minimum number of digits (to be\n+        // padded with zeros on the left).  This isn't really supported by the\n+        // iostreams, but we can approximately simulate it with the width if\n+        // the width isn't otherwise used.\n+        out.width(out.precision() + widthExtra);\n+        out.setf(std::ios::internal, std::ios::adjustfield);\n+        out.fill('0');\n+    }\n+    return c+1;\n+}\n+\n+\n+//------------------------------------------------------------------------------\n+inline void formatImpl(std::ostream& out, const char* fmt,\n+                       const detail::FormatArg* formatters,\n+                       int numFormatters)\n+{\n+    // Saved stream state\n+    std::streamsize origWidth = out.width();\n+    std::streamsize origPrecision = out.precision();\n+    std::ios::fmtflags origFlags = out.flags();\n+    char origFill = out.fill();\n+\n+    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)\n+    {\n+        // Parse the format string\n+        fmt = printFormatStringLiteral(out, fmt);\n+        bool spacePadPositive = false;\n+        int ntrunc = -1;\n+        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,\n+                                                   formatters, argIndex, numFormatters);\n+        if (argIndex >= numFormatters)\n+        {\n+            // Check args remain after reading any variable width/precision\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough format arguments\");\n+            return;\n+        }\n+        const FormatArg& arg = formatters[argIndex];\n+        // Format the arg into the stream.\n+        if(!spacePadPositive)\n+            arg.format(out, fmt, fmtEnd, ntrunc);\n+        else\n+        {\n+            // The following is a special case with no direct correspondence\n+            // between stream formatting and the printf() behaviour.  Simulate\n+            // it crudely by formatting into a temporary string stream and\n+            // munging the resulting string.\n+            std::ostringstream tmpStream;\n+            tmpStream.copyfmt(out);\n+            tmpStream.setf(std::ios::showpos);\n+            arg.format(tmpStream, fmt, fmtEnd, ntrunc);\n+            std::string result = tmpStream.str(); // allocates... yuck.\n+            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n+                if(result[i] == '+') result[i] = ' ';\n+            out << result;\n+        }\n+        fmt = fmtEnd;\n+    }\n+\n+    // Print remaining part of format string.\n+    fmt = printFormatStringLiteral(out, fmt);\n+    if(*fmt != '\\0')\n+        TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+\n+    // Restore stream state\n+    out.width(origWidth);\n+    out.precision(origPrecision);\n+    out.flags(origFlags);\n+    out.fill(origFill);\n+}\n+\n+} // namespace detail\n+\n+\n+/// List of template arguments format(), held in a type-opaque way.\n+///\n+/// A const reference to FormatList (typedef'd as FormatListRef) may be\n+/// conveniently used to pass arguments to non-template functions: All type\n+/// information has been stripped from the arguments, leaving just enough of a\n+/// common interface to perform formatting as required.\n+class FormatList\n+{\n+    public:\n+        FormatList(detail::FormatArg* formatters, int N)\n+            : m_formatters(formatters), m_N(N) { }\n+\n+        friend void vformat(std::ostream& out, const char* fmt,\n+                            const FormatList& list);\n+\n+    private:\n+        const detail::FormatArg* m_formatters;\n+        int m_N;\n+};\n+\n+/// Reference to type-opaque format list for passing to vformat()\n+typedef const FormatList& FormatListRef;\n+\n+\n+namespace detail {\n+\n+// Format list subclass with fixed storage to avoid dynamic allocation\n+template<int N>\n+class FormatListN : public FormatList\n+{\n+    public:\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+        template<typename... Args>\n+        FormatListN(const Args&... args)\n+            : FormatList(&m_formatterStore[0], N),\n+            m_formatterStore { FormatArg(args)... }\n+        { static_assert(sizeof...(args) == N, \"Number of args must be N\"); }\n+#else // C++98 version\n+        void init(int) {}\n+#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        FormatListN(TINYFORMAT_VARARGS(n))                     \\\n+            : FormatList(&m_formatterStore[0], n)              \\\n+        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        void init(int i, TINYFORMAT_VARARGS(n))                \\\n+        {                                                      \\\n+            m_formatterStore[i] = FormatArg(v1);               \\\n+            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \\\n+        }\n+\n+        TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)\n+#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR\n+#endif\n+\n+    private:\n+        FormatArg m_formatterStore[N];\n+};\n+\n+// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard\n+template<> class FormatListN<0> : public FormatList\n+{\n+    public: FormatListN() : FormatList(0, 0) {}\n+};\n+\n+} // namespace detail\n+\n+\n+//------------------------------------------------------------------------------\n+// Primary API functions\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+/// Make type-agnostic format list from list of template arguments.\n+///\n+/// The exact return type of this function is an implementation detail and\n+/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:\n+///\n+///   FormatListRef formatList = makeFormatList( /*...*/ );\n+template<typename... Args>\n+detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args)\n+{\n+    return detail::FormatListN<sizeof...(args)>(args...);\n+}\n+\n+#else // C++98 version\n+\n+inline detail::FormatListN<0> makeFormatList()\n+{\n+    return detail::FormatListN<0>();\n+}\n+#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \\\n+template<TINYFORMAT_ARGTYPES(n)>                              \\\n+detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \\\n+{                                                             \\\n+    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \\\n+}\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)\n+#undef TINYFORMAT_MAKE_MAKEFORMATLIST\n+\n+#endif\n+\n+/// Format list of arguments to the stream according to the given format string.\n+///\n+/// The name vformat() is chosen for the semantic similarity to vprintf(): the\n+/// list of format arguments is held in a single function argument.\n+inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)\n+{\n+    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);\n+}\n+\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+/// Format list of arguments to the stream according to given format string.\n+template<typename... Args>\n+void format(std::ostream& out, const char* fmt, const Args&... args)\n+{\n+    vformat(out, fmt, makeFormatList(args...));\n+}\n+\n+/// Format list of arguments according to the given format string and return\n+/// the result as a string.\n+template<typename... Args>\n+std::string format(const char* fmt, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt, args...);\n+    return oss.str();\n+}\n+\n+/// Format list of arguments to std::cout, according to the given format string\n+template<typename... Args>\n+void printf(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+}\n+\n+template<typename... Args>\n+void printfln(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+    std::cout << '\\n';\n+}\n+\n+\n+#else // C++98 version\n+\n+inline void format(std::ostream& out, const char* fmt)\n+{\n+    vformat(out, fmt, makeFormatList());\n+}\n+\n+inline std::string format(const char* fmt)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt);\n+    return oss.str();\n+}\n+\n+inline void printf(const char* fmt)\n+{\n+    format(std::cout, fmt);\n+}\n+\n+inline void printfln(const char* fmt)\n+{\n+    format(std::cout, fmt);\n+    std::cout << '\\n';\n+}\n+\n+#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \\\n+{                                                                         \\\n+    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \\\n+{                                                                         \\\n+    std::ostringstream oss;                                               \\\n+    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \\\n+    return oss.str();                                                     \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n+{                                                                         \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \\\n+{                                                                         \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n+    std::cout << '\\n';                                                    \\\n+}\n+\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)\n+#undef TINYFORMAT_MAKE_FORMAT_FUNCS\n+\n+#endif\n+\n+\n+} // namespace tinyformat\n+\n+#endif // TINYFORMAT_H_INCLUDED"
      },
      {
        "sha": "95aa5b8125c2c74fe59afca42bead7bf487597f6",
        "filename": "src/tinyformat/tinyformat_speed_test.cpp",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/tinyformat_speed_test.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/tinyformat_speed_test.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/tinyformat_speed_test.cpp?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,64 @@\n+#if defined(__linux__) && defined(__clang__)\n+// Workaround for bug in gcc 4.4 standard library headers when compling with\n+// clang in C++11 mode.\n+namespace std { class type_info; }\n+#endif\n+\n+#include <boost/format.hpp>\n+#include <iomanip>\n+#include <stdio.h>\n+#include \"tinyformat.h\"\n+\n+void speedTest(const std::string& which)\n+{\n+    // Following is required so that we're not limited by per-character\n+    // buffering.\n+    std::ios_base::sync_with_stdio(false);\n+    const long maxIter = 2000000L;\n+    if(which == \"printf\")\n+    {\n+        // libc version\n+        for(long i = 0; i < maxIter; ++i)\n+            printf(\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\",\n+                   1.234, 42, 3.13, \"str\", (void*)1000, (int)'X');\n+    }\n+    else if(which == \"iostreams\")\n+    {\n+        // Std iostreams version.  What a mess!!\n+        for(long i = 0; i < maxIter; ++i)\n+            std::cout\n+                << std::setprecision(10) << std::fixed << 1.234\n+                << std::resetiosflags(std::ios::floatfield) << \":\"\n+                << std::setw(4) << std::setfill('0') << 42 << std::setfill(' ') << \":\"\n+                << std::setiosflags(std::ios::showpos) << 3.13 << std::resetiosflags(std::ios::showpos) << \":\"\n+                << \"str\" << \":\"\n+                << (void*)1000 << \":\"\n+                << 'X' << \":%\\n\";\n+    }\n+    else if(which == \"tinyformat\")\n+    {\n+        // tinyformat version.\n+        for(long i = 0; i < maxIter; ++i)\n+            tfm::printf(\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\",\n+                        1.234, 42, 3.13, \"str\", (void*)1000, (int)'X');\n+    }\n+    else if(which == \"boost\")\n+    {\n+        // boost::format version\n+        for(long i = 0; i < maxIter; ++i)\n+            std::cout << boost::format(\"%0.10f:%04d:%+g:%s:%p:%c:%%\\n\")\n+                % 1.234 % 42 % 3.13 % \"str\" % (void*)1000 % (int)'X';\n+    }\n+    else\n+    {\n+        assert(0 && \"speed test for which version?\");\n+    }\n+}\n+\n+\n+int main(int argc, char* argv[])\n+{\n+    if(argc >= 2)\n+        speedTest(argv[1]);\n+    return 0;\n+}"
      },
      {
        "sha": "bcc72780c5ee36b2c2dc1c2b94c3cc8832ebb096",
        "filename": "src/tinyformat/tinyformat_test.cpp",
        "status": "added",
        "additions": 283,
        "deletions": 0,
        "changes": 283,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/tinyformat_test.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat/tinyformat_test.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat/tinyformat_test.cpp?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -0,0 +1,283 @@\n+#if defined(__linux__) && defined(__clang__)\n+// Workaround for bug in gcc 4.4 standard library headers when compling with\n+// clang in C++11 mode.\n+namespace std { class type_info; }\n+#endif\n+\n+#if defined(_MSC_VER) && _MSC_VER == 1800\n+    // Disable spurious warning about printf format string mismatch in VS 2012\n+#   pragma warning(disable:4313)\n+#endif\n+\n+#include <stdexcept>\n+#include <climits>\n+#include <cfloat>\n+#include <cstddef>\n+\n+// Throw instead of abort() so we can test error conditions.\n+#define TINYFORMAT_ERROR(reason) \\\n+    throw std::runtime_error(reason);\n+\n+#include \"tinyformat.h\"\n+#include <cassert>\n+\n+#if 0\n+// Compare result of tfm::format() to C's sprintf().\n+template<typename... Args>\n+void compareSprintf(const Args&... args)\n+{\n+    std::string tfmResult = tfm::format(args...);\n+    char sprintfResult[200];\n+    sprintf(sprintfResult, args...);\n+    if(tfmResult != sprintfResult)\n+    {\n+        std::cout << tfmResult << std::endl;\n+        std::cout << sprintfResult << std::endl;\n+        assert(0 && \"results didn't match, see above.\");\n+    }\n+}\n+#endif\n+\n+#define EXPECT_ERROR(expression)                                \\\n+try                                                             \\\n+{                                                               \\\n+    expression;                                                 \\\n+    std::cout << \"test failed, line \" << __LINE__ << \"\\n\";      \\\n+    std::cout << \"expected exception in \" #expression << \"\\n\";  \\\n+    ++nfailed;                                                  \\\n+}                                                               \\\n+catch(std::runtime_error&) {}                                   \\\n+\n+#define CHECK_EQUAL(a, b)                                  \\\n+if(!((a) == (b)))                                          \\\n+{                                                          \\\n+    std::cout << \"test failed, line \" << __LINE__ << \"\\n\"; \\\n+    std::cout << (a) << \" != \" << (b) << \"\\n\";             \\\n+    std::cout << \"[\" #a \", \" #b \"]\\n\";                     \\\n+    ++nfailed;                                             \\\n+}\n+\n+\n+// Test wrapping to create our own function which calls through to tfm::format\n+struct TestWrap\n+{\n+    std::ostringstream m_oss;\n+    // template<typename... Args>\n+    // std::string error(int code, const char* fmt, const Args&... args);\n+#   define MAKE_ERROR_FUNC(n)                                            \\\n+    template<TINYFORMAT_ARGTYPES(n)>                                     \\\n+    std::string error(int code, const char* fmt, TINYFORMAT_VARARGS(n))  \\\n+    {                                                                    \\\n+        m_oss.clear();                                                   \\\n+        m_oss << code << \": \";                                           \\\n+        tfm::format(m_oss, fmt, TINYFORMAT_PASSARGS(n));                 \\\n+        return m_oss.str();                                              \\\n+    }\n+    TINYFORMAT_FOREACH_ARGNUM(MAKE_ERROR_FUNC)\n+};\n+\n+\n+struct TestExceptionDef : public std::runtime_error\n+{\n+#   define MAKE_CONSTRUCTOR(n)                                          \\\n+    template<TINYFORMAT_ARGTYPES(n)>                                    \\\n+    TestExceptionDef(const char* fmt, TINYFORMAT_VARARGS(n))            \\\n+        : std::runtime_error(tfm::format(fmt, TINYFORMAT_PASSARGS(n)))  \\\n+    { }\n+    TINYFORMAT_FOREACH_ARGNUM(MAKE_CONSTRUCTOR)\n+};\n+\n+\n+struct MyInt {\n+public:\n+    MyInt(int value) : m_value(value) {}\n+    int value() const { return m_value; }\n+private:\n+    int m_value;\n+};\n+\n+std::ostream& operator<<(std::ostream& os, const MyInt& obj) {\n+    os << obj.value();\n+    return os;\n+}\n+\n+\n+int unitTests()\n+{\n+    int nfailed = 0;\n+#   if defined(_MSC_VER) && _MSC_VER < 1900 // VC++ older than 2015\n+    // floats are printed with three digit exponents on windows, which messes\n+    // up the tests.  Turn this off for consistency:\n+    _set_output_format(_TWO_DIGIT_EXPONENT);\n+#   endif\n+    // Test various basic format specs against results of sprintf\n+    CHECK_EQUAL(tfm::format(\"%s\", \"asdf\"), \"asdf\");\n+    CHECK_EQUAL(tfm::format(\"%d\", 1234), \"1234\");\n+    CHECK_EQUAL(tfm::format(\"%i\", -5678), \"-5678\");\n+    CHECK_EQUAL(tfm::format(\"%o\", 012), \"12\");\n+    CHECK_EQUAL(tfm::format(\"%u\", 123456u), \"123456\");\n+    CHECK_EQUAL(tfm::format(\"%x\", 0xdeadbeef), \"deadbeef\");\n+    CHECK_EQUAL(tfm::format(\"%X\", 0xDEADBEEF), \"DEADBEEF\");\n+    CHECK_EQUAL(tfm::format(\"%e\", 1.23456e10), \"1.234560e+10\");\n+    CHECK_EQUAL(tfm::format(\"%E\", -1.23456E10), \"-1.234560E+10\");\n+    CHECK_EQUAL(tfm::format(\"%f\", -9.8765), \"-9.876500\");\n+    CHECK_EQUAL(tfm::format(\"%F\", 9.8765), \"9.876500\");\n+    CHECK_EQUAL(tfm::format(\"%g\", 10), \"10\");\n+    CHECK_EQUAL(tfm::format(\"%G\", 100), \"100\");\n+    CHECK_EQUAL(tfm::format(\"%c\", 65), \"A\");\n+    CHECK_EQUAL(tfm::format(\"%hc\", (short)65), \"A\");\n+    CHECK_EQUAL(tfm::format(\"%lc\", (long)65), \"A\");\n+    CHECK_EQUAL(tfm::format(\"%s\", \"asdf_123098\"), \"asdf_123098\");\n+    // Note: All tests printing pointers are different on windows, since\n+    // there's no standard numerical representation.\n+    // Representation also differs between 32-bit and 64-bit windows.\n+#   ifdef _MSC_VER\n+#   ifdef _WIN64\n+    CHECK_EQUAL(tfm::format(\"%p\", (void*)0x12345), \"0000000000012345\");\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (void*)0x12345), \"00012345\");\n+#   endif // _WIN64\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (void*)0x12345), \"0x12345\");\n+#   endif // _MSC_VER\n+    CHECK_EQUAL(tfm::format(\"%%%s\", \"asdf\"), \"%asdf\"); // note: plain \"%%\" format gives warning with gcc\n+    // chars with int format specs are printed as ints:\n+    CHECK_EQUAL(tfm::format(\"%hhd\", (char)65), \"65\");\n+    CHECK_EQUAL(tfm::format(\"%hhu\", (unsigned char)65), \"65\");\n+    CHECK_EQUAL(tfm::format(\"%hhd\", (signed char)65), \"65\");\n+#   ifdef _MSC_VER\n+#   ifdef _WIN64\n+    CHECK_EQUAL(tfm::format(\"%p\", (const char*)0x10), \"0000000000000010\");\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (const char*)0x10), \"00000010\");\n+#   endif // _WIN64\n+#   else\n+    CHECK_EQUAL(tfm::format(\"%p\", (const char*)0x10), \"0x10\"); // should print address, not string.\n+#   endif // _MSC_VER\n+    // bools with string format spec are printed as \"true\" or \"false\"\n+    CHECK_EQUAL(tfm::format(\"%s\", true), \"true\");\n+    CHECK_EQUAL(tfm::format(\"%d\", true), \"1\");\n+\n+    // Test precision & width\n+    CHECK_EQUAL(tfm::format(\"%10d\", -10), \"       -10\");\n+    CHECK_EQUAL(tfm::format(\"%.4d\", 10), \"0010\");\n+    CHECK_EQUAL(tfm::format(\"%10.4f\", 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%.f\", 10.1), \"10\");\n+    CHECK_EQUAL(tfm::format(\"%.2s\", \"asdf\"), \"as\"); // strings truncate to precision\n+    CHECK_EQUAL(tfm::format(\"%.2s\", std::string(\"asdf\")), \"as\");\n+//    // Test variable precision & width\n+    CHECK_EQUAL(tfm::format(\"%*.4f\", 10, 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%10.*f\", 4, 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%*.*f\", 10, 4, 1234.1234567890), \" 1234.1235\");\n+    CHECK_EQUAL(tfm::format(\"%*.*f\", -10, 4, 1234.1234567890), \"1234.1235 \");\n+\n+    // Test flags\n+    CHECK_EQUAL(tfm::format(\"%#x\", 0x271828), \"0x271828\");\n+    CHECK_EQUAL(tfm::format(\"%#o\", 0x271828), \"011614050\");\n+    CHECK_EQUAL(tfm::format(\"%#f\", 3.0), \"3.000000\");\n+    CHECK_EQUAL(tfm::format(\"%+d\", 3), \"+3\");\n+    CHECK_EQUAL(tfm::format(\"%+d\", 0), \"+0\");\n+    CHECK_EQUAL(tfm::format(\"%+d\", -3), \"-3\");\n+    CHECK_EQUAL(tfm::format(\"%010d\", 100), \"0000000100\");\n+    CHECK_EQUAL(tfm::format(\"%010d\", -10), \"-000000010\"); // sign should extend\n+    CHECK_EQUAL(tfm::format(\"%#010X\", 0xBEEF), \"0X0000BEEF\");\n+    CHECK_EQUAL(tfm::format(\"% d\",  10), \" 10\");\n+    CHECK_EQUAL(tfm::format(\"% d\", -10), \"-10\");\n+    // Test flags with variable precision & width\n+    CHECK_EQUAL(tfm::format(\"%+.2d\", 3), \"+03\");\n+    CHECK_EQUAL(tfm::format(\"%+.2d\", -3), \"-03\");\n+    // flag override precedence\n+    CHECK_EQUAL(tfm::format(\"%+ d\", 10), \"+10\"); // '+' overrides ' '\n+    CHECK_EQUAL(tfm::format(\"% +d\", 10), \"+10\");\n+    CHECK_EQUAL(tfm::format(\"%-010d\", 10), \"10        \"); // '-' overrides '0'\n+    CHECK_EQUAL(tfm::format(\"%0-10d\", 10), \"10        \");\n+\n+    // Check that length modifiers are ignored\n+    CHECK_EQUAL(tfm::format(\"%hd\", (short)1000), \"1000\");\n+    CHECK_EQUAL(tfm::format(\"%ld\", (long)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%lld\", (long long)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%zd\", (size_t)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%td\", (ptrdiff_t)100000), \"100000\");\n+    CHECK_EQUAL(tfm::format(\"%jd\", 100000), \"100000\");\n+\n+    // Check that 0-argument formatting is printf-compatible\n+    CHECK_EQUAL(tfm::format(\"100%%\"), \"100%\");\n+\n+    // printf incompatibilities:\n+    // compareSprintf(\"%6.4x\", 10); // precision & width can't be supported independently\n+    // compareSprintf(\"%.4d\", -10); // negative numbers + precision don't quite work.\n+\n+    // General \"complicated\" format spec test\n+    CHECK_EQUAL(tfm::format(\"%0.10f:%04d:%+g:%s:%#X:%c:%%:%%asdf\",\n+                       1.234, 42, 3.13, \"str\", 0XDEAD, (int)'X'),\n+                \"1.2340000000:0042:+3.13:str:0XDEAD:X:%:%asdf\");\n+\n+    // Test wrong number of args\n+    EXPECT_ERROR( tfm::format(\"%d\", 5, 10) )\n+    EXPECT_ERROR( tfm::format(\"%d %d\", 1)  )\n+    // Unterminated format spec\n+    EXPECT_ERROR( tfm::format(\"%123\", 10)  )\n+    // Types used to specify variable width/precision must be convertible to int.\n+    EXPECT_ERROR( tfm::format(\"%0*d\", \"thing that can't convert to int\", 42)  )\n+    EXPECT_ERROR( tfm::format(\"%0.*d\", \"thing that can't convert to int\", 42) )\n+    // Error required if not enough args for variable width/precision\n+    EXPECT_ERROR( tfm::format(\"%*d\", 1)      )\n+    EXPECT_ERROR( tfm::format(\"%.*d\", 1)     )\n+    EXPECT_ERROR( tfm::format(\"%*.*d\", 1, 2) )\n+\n+    // Unhandled C99 format spec\n+    EXPECT_ERROR( tfm::format(\"%n\", 10) )\n+    EXPECT_ERROR( tfm::format(\"%a\", 10) )\n+    EXPECT_ERROR( tfm::format(\"%A\", 10) )\n+\n+#ifdef TEST_WCHAR_T_COMPILE\n+    // Test wchar_t handling - should fail to compile!\n+    tfm::format(\"%ls\", L\"blah\");\n+#endif\n+\n+    // Test that formatting is independent of underlying stream state.\n+    std::ostringstream oss;\n+    oss.width(20);\n+    oss.precision(10);\n+    oss.fill('*');\n+    oss.setf(std::ios::scientific);\n+    tfm::format(oss, \"%f\", 10.1234123412341234);\n+    CHECK_EQUAL(oss.str(), \"10.123412\");\n+\n+    // Test formatting a custom object\n+    MyInt myobj(42);\n+    CHECK_EQUAL(tfm::format(\"myobj: %s\", myobj), \"myobj: 42\");\n+\n+    // Test that interface wrapping works correctly\n+    TestWrap wrap;\n+    CHECK_EQUAL(wrap.error(10, \"someformat %s:%d:%d\", \"asdf\", 2, 4),\n+                \"10: someformat asdf:2:4\");\n+\n+    TestExceptionDef ex(\"blah %d\", 100);\n+    CHECK_EQUAL(ex.what(), std::string(\"blah 100\"));\n+\n+    // Test tfm::printf by swapping the std::cout stream buffer to capture data\n+    // which would noramlly go to the stdout\n+    std::ostringstream coutCapture;\n+    std::streambuf* coutBuf = std::cout.rdbuf(coutCapture.rdbuf());\n+    tfm::printf(\"%s %s %d\\n\", \"printf\", \"test\", 1);\n+    tfm::printfln(\"%s %s %d\", \"printfln\", \"test\", 1);\n+    std::cout.rdbuf(coutBuf); // restore buffer\n+    CHECK_EQUAL(coutCapture.str(), \"printf test 1\\nprintfln test 1\\n\");\n+\n+    return nfailed;\n+}\n+\n+\n+int main()\n+{\n+    try\n+    {\n+        return unitTests();\n+    }\n+    catch (std::runtime_error & e)\n+    {\n+        std::cout << \"Failure due to uncaught exception: \" << e.what() << std::endl;\n+        return EXIT_FAILURE;\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZmMyOGQ4YzYyOGQ4MGE4ZjhkMmFlNDRkZGViNDliNThlNWNmYTUz",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-08-01T14:25:58Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-08-02T02:08:00Z"
      },
      "message": "Drop src/tinyformat.h in favor of the subtree src/tinyformat/\n\nIntroduce modifications to tinyformat via utilstrprintf.h\n\nThis includes changes in:\n695041e4952ea40e0 - util: Update tinyformat\n1b8fd35aadfad6a1e - Make tinyformat errors raise an exception instead of assert()ing\n9b6d4c5cdc1ad7b12 - Move strprintf define to tinyformat.h\n6e5fd003e04b81115 - Move `*Version()` functions to version.h/cpp\n9eaa0afa6ec5d3dd0 - tinyformat: force USE_VARIADIC_TEMPLATES\nb651270cd6bfdd6d7 - util: Throw tinyformat::format_error on formatting error\n\nThis does not include changes below, and it protects against future unintended\nmodification of upstream code via git-subtree-check:\n64fb0ac016c7fd01c - Declare single-argument (non-converting) constructors \"explicit\"\n4d9b4256d89d1f7c6 - Fix typos\n\nNote I excluded only the tinyformat cpp from the boost lint checks out of an\nabundance of caution - these files are not actually built into bitcoin so are\nnot at risk of pulling in unwanted dependencies, whereas the header, and other\ndependencies might be.",
      "tree": {
        "sha": "7cf06cef085cf51b9e59d298532cbb0219b6bd5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7cf06cef085cf51b9e59d298532cbb0219b6bd5e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJbYmf5AAoJEG7l83hfeLNFAIwH/i4qFYf2lsP5t9EcOLmmHcBz\nw7aDCOKAYmpht4FVcuZRHviaWEy5zo60tgzjQP4oxASNbl9Y2UtjS/wQN8faszLd\noH1Y6FbCuJpldZo9vWJGzUvBra5lPPmJwH0rQ68PVKgDl7gTqpZABqk4C9e/3tw3\nKNq8T7fq2J/M/hSH5b88ETx4UFgoOUiPCwu9EJvUBnsy24US/aQkO4qaSi0Oe0Sm\n8BPN7OlO58f0zAlyYw/ShyjiIrmrx+q5SDw+dK8xDXKhsFXh8AP3x4otRrZ7NdOn\nw2vYyz9cefgzBvLMHcP2pxNWB9mtqBJcnTdbsXa9+P3nSRf/bFz27tmGasCb/3k=\n=Y4pf\n-----END PGP SIGNATURE-----",
        "payload": "tree 7cf06cef085cf51b9e59d298532cbb0219b6bd5e\nparent bc483a29dff28e86fa8224b30799e539c98ed7ec\nauthor Ben Woosley <ben.woosley@gmail.com> 1533133558 +0000\ncommitter Ben Woosley <ben.woosley@gmail.com> 1533175680 -0400\n\nDrop src/tinyformat.h in favor of the subtree src/tinyformat/\n\nIntroduce modifications to tinyformat via utilstrprintf.h\n\nThis includes changes in:\n695041e4952ea40e0 - util: Update tinyformat\n1b8fd35aadfad6a1e - Make tinyformat errors raise an exception instead of assert()ing\n9b6d4c5cdc1ad7b12 - Move strprintf define to tinyformat.h\n6e5fd003e04b81115 - Move `*Version()` functions to version.h/cpp\n9eaa0afa6ec5d3dd0 - tinyformat: force USE_VARIADIC_TEMPLATES\nb651270cd6bfdd6d7 - util: Throw tinyformat::format_error on formatting error\n\nThis does not include changes below, and it protects against future unintended\nmodification of upstream code via git-subtree-check:\n64fb0ac016c7fd01c - Declare single-argument (non-converting) constructors \"explicit\"\n4d9b4256d89d1f7c6 - Fix typos\n\nNote I excluded only the tinyformat cpp from the boost lint checks out of an\nabundance of caution - these files are not actually built into bitcoin so are\nnot at risk of pulling in unwanted dependencies, whereas the header, and other\ndependencies might be.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bc483a29dff28e86fa8224b30799e539c98ed7ec"
      }
    ],
    "stats": {
      "total": 1193,
      "additions": 87,
      "deletions": 1106
    },
    "files": [
      {
        "sha": "13149b4da4c43b46e568d383139a9991afaab6ee",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -148,6 +148,7 @@ jobs:\n         - test/lint/git-subtree-check.sh src/secp256k1\n         - test/lint/git-subtree-check.sh src/univalue\n         - test/lint/git-subtree-check.sh src/leveldb\n+        - test/lint/git-subtree-check.sh src/tinyformat\n         - test/lint/check-doc.py\n         - test/lint/check-rpc-mappings.py .\n         - test/lint/lint-all.sh"
      },
      {
        "sha": "ec9efd679e4e6dc21b0d01bcdaabfdcaf1011710",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -168,7 +168,7 @@ $(BITCOIN_CLI_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n \n if USE_LCOV\n-LCOV_FILTER_PATTERN=-p \"/usr/include/\" -p \"src/leveldb/\" -p \"src/bench/\" -p \"src/univalue\" -p \"src/crypto/ctaes\" -p \"src/secp256k1\"\n+LCOV_FILTER_PATTERN=-p \"/usr/include/\" -p \"src/leveldb/\" -p \"src/bench/\" -p \"src/univalue\" -p \"src/crypto/ctaes\" -p \"src/secp256k1\" -p \"src/tinyformat\"\n \n baseline.info:\n \t$(LCOV) -c -i -d $(abs_builddir)/src -o $@"
      },
      {
        "sha": "d6bba05e2df99f94aff362923ed37e1d82b209f1",
        "filename": "contrib/devtools/copyright_header.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/contrib/devtools/copyright_header.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/contrib/devtools/copyright_header.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/copyright_header.py?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -31,7 +31,7 @@\n     'src/qt/bitcoinstrings.cpp',\n     'src/chainparamsseeds.h',\n     # other external copyrights:\n-    'src/tinyformat.h',\n+    'src/tinyformat/tinyformat.h',\n     'src/leveldb/util/env_win.cc',\n     'src/crypto/ctaes/bench.c',\n     'test/functional/test_framework/bignum.py',"
      },
      {
        "sha": "b62e885b5965559560e98e1176f3303cc559870e",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -698,6 +698,9 @@ Current subtrees include:\n - src/crypto/ctaes\n   - Upstream at https://github.com/bitcoin-core/ctaes ; actively maintained by Core contributors.\n \n+- src/tinyformat\n+  - Upstream at https://github.com/c42f/tinyformat ; report important PRs to Core to avoid delay.\n+\n - src/univalue\n   - Upstream at https://github.com/jgarzik/univalue ; report important PRs to Core to avoid delay.\n "
      },
      {
        "sha": "899cdada18a476785fc92642c190ca9b31e46ce0",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -22,6 +22,7 @@ endif\n BITCOIN_INCLUDES=-I$(builddir) $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\n \n BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n+BITCOIN_INCLUDES += -I$(srcdir)/tinyformat\n BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\n \n LIBBITCOIN_SERVER=libbitcoin_server.a\n@@ -182,6 +183,7 @@ BITCOIN_CORE_H = \\\n   util.h \\\n   utilmemory.h \\\n   utilmoneystr.h \\\n+  utilstrprintf.h \\\n   utiltime.h \\\n   validation.h \\\n   validationinterface.h \\\n@@ -362,11 +364,11 @@ libbitcoin_consensus_a_SOURCES = \\\n   script/script_error.h \\\n   serialize.h \\\n   span.h \\\n-  tinyformat.h \\\n   uint256.cpp \\\n   uint256.h \\\n   utilstrencodings.cpp \\\n   utilstrencodings.h \\\n+  utilstrprintf.h \\\n   version.h\n \n # common: shared between bitcoind, and bitcoin-qt and non-server tools\n@@ -438,8 +440,8 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n #\n \n # bitcoind binary #\n-bitcoind_SOURCES = bitcoind.cpp\n-bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+bitcoind_SOURCES = bitcoind.cpp tinyformat/tinyformat.h\n+bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(srcdir)/tinyformat\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n@@ -514,7 +516,7 @@ endif\n \n libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\n libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\n-libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL\n+libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -I$(srcdir)/tinyformat -DBUILD_BITCOIN_INTERNAL\n libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n endif"
      },
      {
        "sha": "9f94459134c5537d3f2451acb2b9430a926ac24d",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -11,8 +11,8 @@\n #include <hash.h>\n #include <random.h>\n #include <streams.h>\n-#include <tinyformat.h>\n #include <util.h>\n+#include <utilstrprintf.h>\n \n namespace {\n "
      },
      {
        "sha": "92eddf7783f83fb7aefe18ff093162447d35f584",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -9,8 +9,8 @@\n #include <arith_uint256.h>\n #include <consensus/params.h>\n #include <primitives/block.h>\n-#include <tinyformat.h>\n #include <uint256.h>\n+#include <utilstrprintf.h>\n \n #include <vector>\n "
      },
      {
        "sha": "eb09e65c7ca372d5251482131431b677332a36e4",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,9 +6,9 @@\n #include <chainparams.h>\n #include <consensus/merkle.h>\n \n-#include <tinyformat.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n #include <assert.h>\n "
      },
      {
        "sha": "8db6469371cf3dce1f92270f3db456079c11a762",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -5,9 +5,9 @@\n \n #include <chainparamsbase.h>\n \n-#include <tinyformat.h>\n #include <util.h>\n #include <utilmemory.h>\n+#include <utilstrprintf.h>\n \n #include <assert.h>\n "
      },
      {
        "sha": "3a0fcb1aa29630b0ae76d6872f5c6f8ff82bd2d0",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <clientversion.h>\n \n-#include <tinyformat.h>\n+#include <utilstrprintf.h>\n \n \n /**"
      },
      {
        "sha": "46e5e902f8e3020a2187959b12efcb2ee9ad3351",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -5,9 +5,9 @@\n #include <chainparams.h>\n #include <index/base.h>\n #include <shutdown.h>\n-#include <tinyformat.h>\n #include <ui_interface.h>\n #include <util.h>\n+#include <utilstrprintf.h>\n #include <validation.h>\n #include <warnings.h>\n "
      },
      {
        "sha": "7d67f9a18fef4bc014c3330fcd8d060e35f6e2a7",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -7,7 +7,7 @@\n #define BITCOIN_LOGGING_H\n \n #include <fs.h>\n-#include <tinyformat.h>\n+#include <utilstrprintf.h>\n \n #include <atomic>\n #include <cstdint>"
      },
      {
        "sha": "b26e0633606158f7fee85b8d5228e8128acdbb8e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -22,12 +22,12 @@\n #include <random.h>\n #include <reverse_iterator.h>\n #include <scheduler.h>\n-#include <tinyformat.h>\n #include <txmempool.h>\n #include <ui_interface.h>\n #include <util.h>\n #include <utilmoneystr.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n #include <memory>\n "
      },
      {
        "sha": "2ef9602f5654aec11c6b675b3484e264c5653e2b",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,7 +6,7 @@\n #include <netaddress.h>\n #include <hash.h>\n #include <utilstrencodings.h>\n-#include <tinyformat.h>\n+#include <utilstrprintf.h>\n \n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};"
      },
      {
        "sha": "f7037f73f2a8ecf857b989ee6d366eb6c3b02869",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -9,9 +9,9 @@\n #include <sync.h>\n #include <uint256.h>\n #include <random.h>\n-#include <tinyformat.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n #include <atomic>\n "
      },
      {
        "sha": "c83d213837611f41e379ab5c844fa9388b1cd6f6",
        "filename": "src/policy/feerate.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/policy/feerate.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/policy/feerate.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <policy/feerate.h>\n \n-#include <tinyformat.h>\n+#include <utilstrprintf.h>\n \n const std::string CURRENCY_UNIT = \"BTC\";\n "
      },
      {
        "sha": "7036074800010b7eeb33e2564b53894ffe05b205",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -10,9 +10,9 @@\n #include <consensus/validation.h>\n #include <validation.h>\n #include <coins.h>\n-#include <tinyformat.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n \n CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)"
      },
      {
        "sha": "93ff6434e03d97495fdcba8538afbdfeda77948e",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,10 +6,11 @@\n #include <primitives/block.h>\n \n #include <hash.h>\n-#include <tinyformat.h>\n-#include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n #include <crypto/common.h>\n \n+#include <sstream>\n+\n uint256 CBlockHeader::GetHash() const\n {\n     return SerializeHash(*this);"
      },
      {
        "sha": "794f77a105eb19a32e0570f4d441f9148c5607d9",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -10,6 +10,8 @@\n #include <serialize.h>\n #include <uint256.h>\n \n+#include <string>\n+\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block"
      },
      {
        "sha": "3bb01a48f63f7df2c62a0c3a0c581141c60d4019",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,8 +6,8 @@\n #include <primitives/transaction.h>\n \n #include <hash.h>\n-#include <tinyformat.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n std::string COutPoint::ToString() const\n {"
      },
      {
        "sha": "b89631c59f6311cb2b0ad676773794bd614b77da",
        "filename": "src/rpc/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/rpc/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/rpc/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,9 +6,9 @@\n #include <rpc/protocol.h>\n \n #include <random.h>\n-#include <tinyformat.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n #include <utiltime.h>\n #include <version.h>\n "
      },
      {
        "sha": "72a55e609df10a6e9a4fea6fb8aae6c140741fa2",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,8 +6,8 @@\n #include <keystore.h>\n #include <rpc/protocol.h>\n #include <rpc/util.h>\n-#include <tinyformat.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n // Converts a hex string to a public key if possible\n CPubKey HexToPubKey(const std::string& hex_in)"
      },
      {
        "sha": "10a28ba0f7113a46976b66ae75fea344064f189d",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -5,8 +5,8 @@\n \n #include <script/script.h>\n \n-#include <tinyformat.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n const char* GetOpName(opcodetype opcode)\n {"
      },
      {
        "sha": "14b7cd30262fd0a63376329be7a5e7546e7aa19e",
        "filename": "src/tinyformat.h",
        "status": "removed",
        "additions": 0,
        "deletions": 1068,
        "changes": 1068,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc483a29dff28e86fa8224b30799e539c98ed7ec/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=bc483a29dff28e86fa8224b30799e539c98ed7ec",
        "patch": "@@ -1,1068 +0,0 @@\n-// tinyformat.h\n-// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]\n-//\n-// Boost Software License - Version 1.0\n-//\n-// Permission is hereby granted, free of charge, to any person or organization\n-// obtaining a copy of the software and accompanying documentation covered by\n-// this license (the \"Software\") to use, reproduce, display, distribute,\n-// execute, and transmit the Software, and to prepare derivative works of the\n-// Software, and to permit third-parties to whom the Software is furnished to\n-// do so, all subject to the following:\n-//\n-// The copyright notices in the Software and this entire statement, including\n-// the above license grant, this restriction and the following disclaimer,\n-// must be included in all copies of the Software, in whole or in part, and\n-// all derivative works of the Software, unless such copies or derivative\n-// works are solely in the form of machine-executable object code generated by\n-// a source language processor.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n-// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n-// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n-// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-// DEALINGS IN THE SOFTWARE.\n-\n-//------------------------------------------------------------------------------\n-// Tinyformat: A minimal type safe printf replacement\n-//\n-// tinyformat.h is a type safe printf replacement library in a single C++\n-// header file.  Design goals include:\n-//\n-// * Type safety and extensibility for user defined types.\n-// * C99 printf() compatibility, to the extent possible using std::ostream\n-// * Simplicity and minimalism.  A single header file to include and distribute\n-//   with your projects.\n-// * Augment rather than replace the standard stream formatting mechanism\n-// * C++98 support, with optional C++11 niceties\n-//\n-//\n-// Main interface example usage\n-// ----------------------------\n-//\n-// To print a date to std::cout:\n-//\n-//   std::string weekday = \"Wednesday\";\n-//   const char* month = \"July\";\n-//   size_t day = 27;\n-//   long hour = 14;\n-//   int min = 44;\n-//\n-//   tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n-//\n-// The strange types here emphasize the type safety of the interface; it is\n-// possible to print a std::string using the \"%s\" conversion, and a\n-// size_t using the \"%d\" conversion.  A similar result could be achieved\n-// using either of the tfm::format() functions.  One prints on a user provided\n-// stream:\n-//\n-//   tfm::format(std::cerr, \"%s, %s %d, %.2d:%.2d\\n\",\n-//               weekday, month, day, hour, min);\n-//\n-// The other returns a std::string:\n-//\n-//   std::string date = tfm::format(\"%s, %s %d, %.2d:%.2d\\n\",\n-//                                  weekday, month, day, hour, min);\n-//   std::cout << date;\n-//\n-// These are the three primary interface functions.  There is also a\n-// convenience function printfln() which appends a newline to the usual result\n-// of printf() for super simple logging.\n-//\n-//\n-// User defined format functions\n-// -----------------------------\n-//\n-// Simulating variadic templates in C++98 is pretty painful since it requires\n-// writing out the same function for each desired number of arguments.  To make\n-// this bearable tinyformat comes with a set of macros which are used\n-// internally to generate the API, but which may also be used in user code.\n-//\n-// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and\n-// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,\n-// type/name pairs and argument names respectively when called with an integer\n-// n between 1 and 16.  We can use these to define a macro which generates the\n-// desired user defined function with n arguments.  To generate all 16 user\n-// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an\n-// example, see the implementation of printf() at the end of the source file.\n-//\n-// Sometimes it's useful to be able to pass a list of format arguments through\n-// to a non-template function.  The FormatList class is provided as a way to do\n-// this by storing the argument list in a type-opaque way.  Continuing the\n-// example from above, we construct a FormatList using makeFormatList():\n-//\n-//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);\n-//\n-// The format list can now be passed into any non-template function and used\n-// via a call to the vformat() function:\n-//\n-//   tfm::vformat(std::cout, \"%s, %s %d, %.2d:%.2d\\n\", formatList);\n-//\n-//\n-// Additional API information\n-// --------------------------\n-//\n-// Error handling: Define TINYFORMAT_ERROR to customize the error handling for\n-// format strings which are unsupported or have the wrong number of format\n-// specifiers (calls assert() by default).\n-//\n-// User defined types: Uses operator<< for user defined types by default.\n-// Overload formatValue() for more control.\n-\n-\n-#ifndef TINYFORMAT_H_INCLUDED\n-#define TINYFORMAT_H_INCLUDED\n-\n-namespace tinyformat {}\n-//------------------------------------------------------------------------------\n-// Config section.  Customize to your liking!\n-\n-// Namespace alias to encourage brevity\n-namespace tfm = tinyformat;\n-\n-// Error handling; calls assert() by default.\n-#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)\n-\n-// Define for C++11 variadic templates which make the code shorter & more\n-// general.  If you don't define this, C++11 support is autodetected below.\n-#define TINYFORMAT_USE_VARIADIC_TEMPLATES\n-\n-\n-//------------------------------------------------------------------------------\n-// Implementation details.\n-#include <algorithm>\n-#include <cassert>\n-#include <iostream>\n-#include <sstream>\n-#include <stdexcept>\n-\n-#ifndef TINYFORMAT_ERROR\n-#   define TINYFORMAT_ERROR(reason) assert(0 && reason)\n-#endif\n-\n-#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)\n-#   ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#       define TINYFORMAT_USE_VARIADIC_TEMPLATES\n-#   endif\n-#endif\n-\n-#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n-//  std::showpos is broken on old libstdc++ as provided with OSX.  See\n-//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n-#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n-#endif\n-\n-#ifdef __APPLE__\n-// Workaround OSX linker warning: Xcode uses different default symbol\n-// visibilities for static libs vs executables (see issue #25)\n-#   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n-#else\n-#   define TINYFORMAT_HIDDEN\n-#endif\n-\n-namespace tinyformat {\n-\n-class format_error: public std::runtime_error\n-{\n-public:\n-    explicit format_error(const std::string &what): std::runtime_error(what) {\n-    }\n-};\n-\n-//------------------------------------------------------------------------------\n-namespace detail {\n-\n-// Test whether type T1 is convertible to type T2\n-template <typename T1, typename T2>\n-struct is_convertible\n-{\n-    private:\n-        // two types of different size\n-        struct fail { char dummy[2]; };\n-        struct succeed { char dummy; };\n-        // Try to convert a T1 to a T2 by plugging into tryConvert\n-        static fail tryConvert(...);\n-        static succeed tryConvert(const T2&);\n-        static const T1& makeT1();\n-    public:\n-#       ifdef _MSC_VER\n-        // Disable spurious loss of precision warnings in tryConvert(makeT1())\n-#       pragma warning(push)\n-#       pragma warning(disable:4244)\n-#       pragma warning(disable:4267)\n-#       endif\n-        // Standard trick: the (...) version of tryConvert will be chosen from\n-        // the overload set only if the version taking a T2 doesn't match.\n-        // Then we compare the sizes of the return types to check which\n-        // function matched.  Very neat, in a disgusting kind of way :)\n-        static const bool value =\n-            sizeof(tryConvert(makeT1())) == sizeof(succeed);\n-#       ifdef _MSC_VER\n-#       pragma warning(pop)\n-#       endif\n-};\n-\n-\n-// Detect when a type is not a wchar_t string\n-template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };\n-template<> struct is_wchar<wchar_t*> {};\n-template<> struct is_wchar<const wchar_t*> {};\n-template<int n> struct is_wchar<const wchar_t[n]> {};\n-template<int n> struct is_wchar<wchar_t[n]> {};\n-\n-\n-// Format the value by casting to type fmtT.  This default implementation\n-// should never be called.\n-template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>\n-struct formatValueAsType\n-{\n-    static void invoke(std::ostream& /*out*/, const T& /*value*/) { assert(0); }\n-};\n-// Specialized version for types that can actually be converted to fmtT, as\n-// indicated by the \"convertible\" template parameter.\n-template<typename T, typename fmtT>\n-struct formatValueAsType<T,fmtT,true>\n-{\n-    static void invoke(std::ostream& out, const T& value)\n-        { out << static_cast<fmtT>(value); }\n-};\n-\n-#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n-template<typename T, bool convertible = is_convertible<T, int>::value>\n-struct formatZeroIntegerWorkaround\n-{\n-    static bool invoke(std::ostream& /**/, const T& /**/) { return false; }\n-};\n-template<typename T>\n-struct formatZeroIntegerWorkaround<T,true>\n-{\n-    static bool invoke(std::ostream& out, const T& value)\n-    {\n-        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos)\n-        {\n-            out << \"+0\";\n-            return true;\n-        }\n-        return false;\n-    }\n-};\n-#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n-\n-// Convert an arbitrary type to integer.  The version with convertible=false\n-// throws an error.\n-template<typename T, bool convertible = is_convertible<T,int>::value>\n-struct convertToInt\n-{\n-    static int invoke(const T& /*value*/)\n-    {\n-        TINYFORMAT_ERROR(\"tinyformat: Cannot convert from argument type to \"\n-                         \"integer for use as variable width or precision\");\n-        return 0;\n-    }\n-};\n-// Specialization for convertToInt when conversion is possible\n-template<typename T>\n-struct convertToInt<T,true>\n-{\n-    static int invoke(const T& value) { return static_cast<int>(value); }\n-};\n-\n-// Format at most ntrunc characters to the given stream.\n-template<typename T>\n-inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)\n-{\n-    std::ostringstream tmp;\n-    tmp << value;\n-    std::string result = tmp.str();\n-    out.write(result.c_str(), (std::min)(ntrunc, static_cast<int>(result.size())));\n-}\n-#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \\\n-inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \\\n-{                                                           \\\n-    std::streamsize len = 0;                                \\\n-    while(len < ntrunc && value[len] != 0)                  \\\n-        ++len;                                              \\\n-    out.write(value, len);                                  \\\n-}\n-// Overload for const char* and char*.  Could overload for signed & unsigned\n-// char too, but these are technically unneeded for printf compatibility.\n-TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)\n-TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)\n-#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR\n-\n-} // namespace detail\n-\n-\n-//------------------------------------------------------------------------------\n-// Variable formatting functions.  May be overridden for user-defined types if\n-// desired.\n-\n-\n-/// Format a value into a stream, delegating to operator<< by default.\n-///\n-/// Users may override this for their own types.  When this function is called,\n-/// the stream flags will have been modified according to the format string.\n-/// The format specification is provided in the range [fmtBegin, fmtEnd).  For\n-/// truncating conversions, ntrunc is set to the desired maximum number of\n-/// characters, for example \"%.7s\" calls formatValue with ntrunc = 7.\n-///\n-/// By default, formatValue() uses the usual stream insertion operator\n-/// operator<< to format the type T, with special cases for the %c and %p\n-/// conversions.\n-template<typename T>\n-inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n-                        const char* fmtEnd, int ntrunc, const T& value)\n-{\n-#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS\n-    // Since we don't support printing of wchar_t using \"%ls\", make it fail at\n-    // compile time in preference to printing as a void* at runtime.\n-    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;\n-    (void) DummyType(); // avoid unused type warning with gcc-4.8\n-#endif\n-    // The mess here is to support the %c and %p conversions: if these\n-    // conversions are active we try to convert the type to a char or const\n-    // void* respectively and format that instead of the value itself.  For the\n-    // %p conversion it's important to avoid dereferencing the pointer, which\n-    // could otherwise lead to a crash when printing a dangling (const char*).\n-    const bool canConvertToChar = detail::is_convertible<T,char>::value;\n-    const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;\n-    if(canConvertToChar && *(fmtEnd-1) == 'c')\n-        detail::formatValueAsType<T, char>::invoke(out, value);\n-    else if(canConvertToVoidPtr && *(fmtEnd-1) == 'p')\n-        detail::formatValueAsType<T, const void*>::invoke(out, value);\n-#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n-    else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n-#endif\n-    else if(ntrunc >= 0)\n-    {\n-        // Take care not to overread C strings in truncating conversions like\n-        // \"%.4s\" where at most 4 characters may be read.\n-        detail::formatTruncated(out, value, ntrunc);\n-    }\n-    else\n-        out << value;\n-}\n-\n-\n-// Overloaded version for char types to support printing as an integer\n-#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \\\n-inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n-                        const char* fmtEnd, int /**/, charType value) \\\n-{                                                                     \\\n-    switch(*(fmtEnd-1))                                               \\\n-    {                                                                 \\\n-        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \\\n-            out << static_cast<int>(value); break;                    \\\n-        default:                                                      \\\n-            out << value;                   break;                    \\\n-    }                                                                 \\\n-}\n-// per 3.9.1: char, signed char and unsigned char are all distinct types\n-TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)\n-TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)\n-TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)\n-#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR\n-\n-\n-//------------------------------------------------------------------------------\n-// Tools for emulating variadic templates in C++98.  The basic idea here is\n-// stolen from the boost preprocessor metaprogramming library and cut down to\n-// be just general enough for what we need.\n-\n-#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n\n-#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n\n-#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n\n-#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n\n-\n-// To keep it as transparent as possible, the macros below have been generated\n-// using python via the excellent cog.py code generation script.  This avoids\n-// the need for a bunch of complex (but more general) preprocessor tricks as\n-// used in boost.preprocessor.\n-//\n-// To rerun the code generation in place, use `cog.py -r tinyformat.h`\n-// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create\n-// extra versions by hand.\n-\n-/*[[[cog\n-maxParams = 16\n-\n-def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):\n-    for j in range(startInd,maxParams+1):\n-        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])\n-        cog.outl(lineTemplate % {'j':j, 'list':list})\n-\n-makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',\n-                  'class T%(i)d')\n-\n-cog.outl()\n-makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',\n-                  'const T%(i)d& v%(i)d')\n-\n-cog.outl()\n-makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')\n-\n-cog.outl()\n-cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')\n-makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',\n-                  'v%(i)d', startInd = 2)\n-\n-cog.outl()\n-cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\\\\n    ' +\n-         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))\n-]]]*/\n-#define TINYFORMAT_ARGTYPES_1 class T1\n-#define TINYFORMAT_ARGTYPES_2 class T1, class T2\n-#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3\n-#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4\n-#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5\n-#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6\n-#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7\n-#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8\n-#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9\n-#define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10\n-#define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11\n-#define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12\n-#define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13\n-#define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14\n-#define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15\n-#define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16\n-\n-#define TINYFORMAT_VARARGS_1 const T1& v1\n-#define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2\n-#define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3\n-#define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4\n-#define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5\n-#define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6\n-#define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7\n-#define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8\n-#define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9\n-#define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10\n-#define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11\n-#define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12\n-#define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13\n-#define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14\n-#define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15\n-#define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16\n-\n-#define TINYFORMAT_PASSARGS_1 v1\n-#define TINYFORMAT_PASSARGS_2 v1, v2\n-#define TINYFORMAT_PASSARGS_3 v1, v2, v3\n-#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4\n-#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5\n-#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6\n-#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7\n-#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8\n-#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9\n-#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10\n-#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n-#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n-#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n-#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n-#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n-#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n-\n-#define TINYFORMAT_PASSARGS_TAIL_1\n-#define TINYFORMAT_PASSARGS_TAIL_2 , v2\n-#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3\n-#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4\n-#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5\n-#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6\n-#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7\n-#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8\n-#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9\n-#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10\n-#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n-#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n-#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n-#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n-#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n-#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n-\n-#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n-    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)\n-//[[[end]]]\n-\n-\n-\n-namespace detail {\n-\n-// Type-opaque holder for an argument to format(), with associated actions on\n-// the type held as explicit function pointers.  This allows FormatArg's for\n-// each argument to be allocated as a homogenous array inside FormatList\n-// whereas a naive implementation based on inheritance does not.\n-class FormatArg\n-{\n-    public:\n-        FormatArg()\n-             : m_value(nullptr),\n-             m_formatImpl(nullptr),\n-             m_toIntImpl(nullptr)\n-         { }\n-\n-        template<typename T>\n-        explicit FormatArg(const T& value)\n-            : m_value(static_cast<const void*>(&value)),\n-            m_formatImpl(&formatImpl<T>),\n-            m_toIntImpl(&toIntImpl<T>)\n-        { }\n-\n-        void format(std::ostream& out, const char* fmtBegin,\n-                    const char* fmtEnd, int ntrunc) const\n-        {\n-            assert(m_value);\n-            assert(m_formatImpl);\n-            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);\n-        }\n-\n-        int toInt() const\n-        {\n-            assert(m_value);\n-            assert(m_toIntImpl);\n-            return m_toIntImpl(m_value);\n-        }\n-\n-    private:\n-        template<typename T>\n-        TINYFORMAT_HIDDEN static void formatImpl(std::ostream& out, const char* fmtBegin,\n-                        const char* fmtEnd, int ntrunc, const void* value)\n-        {\n-            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));\n-        }\n-\n-        template<typename T>\n-        TINYFORMAT_HIDDEN static int toIntImpl(const void* value)\n-        {\n-            return convertToInt<T>::invoke(*static_cast<const T*>(value));\n-        }\n-\n-        const void* m_value;\n-        void (*m_formatImpl)(std::ostream& out, const char* fmtBegin,\n-                             const char* fmtEnd, int ntrunc, const void* value);\n-        int (*m_toIntImpl)(const void* value);\n-};\n-\n-\n-// Parse and return an integer from the string c, as atoi()\n-// On return, c is set to one past the end of the integer.\n-inline int parseIntAndAdvance(const char*& c)\n-{\n-    int i = 0;\n-    for(;*c >= '0' && *c <= '9'; ++c)\n-        i = 10*i + (*c - '0');\n-    return i;\n-}\n-\n-// Print literal part of format string and return next format spec\n-// position.\n-//\n-// Skips over any occurrences of '%%', printing a literal '%' to the\n-// output.  The position of the first % character of the next\n-// nontrivial format spec is returned, or the end of string.\n-inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n-{\n-    const char* c = fmt;\n-    for(;; ++c)\n-    {\n-        switch(*c)\n-        {\n-            case '\\0':\n-                out.write(fmt, c - fmt);\n-                return c;\n-            case '%':\n-                out.write(fmt, c - fmt);\n-                if(*(c+1) != '%')\n-                    return c;\n-                // for \"%%\", tack trailing % onto next literal section.\n-                fmt = ++c;\n-                break;\n-            default:\n-                break;\n-        }\n-    }\n-}\n-\n-\n-// Parse a format string and set the stream state accordingly.\n-//\n-// The format mini-language recognized here is meant to be the one from C99,\n-// with the form \"%[flags][width][.precision][length]type\".\n-//\n-// Formatting options which can't be natively represented using the ostream\n-// state are returned in spacePadPositive (for space padded positive numbers)\n-// and ntrunc (for truncating conversions).  argIndex is incremented if\n-// necessary to pull out variable width and precision.  The function returns a\n-// pointer to the character after the end of the current format spec.\n-inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n-                                         int& ntrunc, const char* fmtStart,\n-                                         const detail::FormatArg* formatters,\n-                                         int& argIndex, int numFormatters)\n-{\n-    if(*fmtStart != '%')\n-    {\n-        TINYFORMAT_ERROR(\"tinyformat: Not enough conversion specifiers in format string\");\n-        return fmtStart;\n-    }\n-    // Reset stream state to defaults.\n-    out.width(0);\n-    out.precision(6);\n-    out.fill(' ');\n-    // Reset most flags; ignore irrelevant unitbuf & skipws.\n-    out.unsetf(std::ios::adjustfield | std::ios::basefield |\n-               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |\n-               std::ios::showpoint | std::ios::showpos | std::ios::uppercase);\n-    bool precisionSet = false;\n-    bool widthSet = false;\n-    int widthExtra = 0;\n-    const char* c = fmtStart + 1;\n-    // 1) Parse flags\n-    for(;; ++c)\n-    {\n-        switch(*c)\n-        {\n-            case '#':\n-                out.setf(std::ios::showpoint | std::ios::showbase);\n-                continue;\n-            case '0':\n-                // overridden by left alignment ('-' flag)\n-                if(!(out.flags() & std::ios::left))\n-                {\n-                    // Use internal padding so that numeric values are\n-                    // formatted correctly, eg -00010 rather than 000-10\n-                    out.fill('0');\n-                    out.setf(std::ios::internal, std::ios::adjustfield);\n-                }\n-                continue;\n-            case '-':\n-                out.fill(' ');\n-                out.setf(std::ios::left, std::ios::adjustfield);\n-                continue;\n-            case ' ':\n-                // overridden by show positive sign, '+' flag.\n-                if(!(out.flags() & std::ios::showpos))\n-                    spacePadPositive = true;\n-                continue;\n-            case '+':\n-                out.setf(std::ios::showpos);\n-                spacePadPositive = false;\n-                widthExtra = 1;\n-                continue;\n-            default:\n-                break;\n-        }\n-        break;\n-    }\n-    // 2) Parse width\n-    if(*c >= '0' && *c <= '9')\n-    {\n-        widthSet = true;\n-        out.width(parseIntAndAdvance(c));\n-    }\n-    if(*c == '*')\n-    {\n-        widthSet = true;\n-        int width = 0;\n-        if(argIndex < numFormatters)\n-            width = formatters[argIndex++].toInt();\n-        else\n-            TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width\");\n-        if(width < 0)\n-        {\n-            // negative widths correspond to '-' flag set\n-            out.fill(' ');\n-            out.setf(std::ios::left, std::ios::adjustfield);\n-            width = -width;\n-        }\n-        out.width(width);\n-        ++c;\n-    }\n-    // 3) Parse precision\n-    if(*c == '.')\n-    {\n-        ++c;\n-        int precision = 0;\n-        if(*c == '*')\n-        {\n-            ++c;\n-            if(argIndex < numFormatters)\n-                precision = formatters[argIndex++].toInt();\n-            else\n-                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable precision\");\n-        }\n-        else\n-        {\n-            if(*c >= '0' && *c <= '9')\n-                precision = parseIntAndAdvance(c);\n-            else if(*c == '-') // negative precisions ignored, treated as zero.\n-                parseIntAndAdvance(++c);\n-        }\n-        out.precision(precision);\n-        precisionSet = true;\n-    }\n-    // 4) Ignore any C99 length modifier\n-    while(*c == 'l' || *c == 'h' || *c == 'L' ||\n-          *c == 'j' || *c == 'z' || *c == 't')\n-        ++c;\n-    // 5) We're up to the conversion specifier character.\n-    // Set stream flags based on conversion specifier (thanks to the\n-    // boost::format class for forging the way here).\n-    bool intConversion = false;\n-    switch(*c)\n-    {\n-        case 'u': case 'd': case 'i':\n-            out.setf(std::ios::dec, std::ios::basefield);\n-            intConversion = true;\n-            break;\n-        case 'o':\n-            out.setf(std::ios::oct, std::ios::basefield);\n-            intConversion = true;\n-            break;\n-        case 'X':\n-            out.setf(std::ios::uppercase);\n-            // Falls through\n-        case 'x': case 'p':\n-            out.setf(std::ios::hex, std::ios::basefield);\n-            intConversion = true;\n-            break;\n-        case 'E':\n-            out.setf(std::ios::uppercase);\n-            // Falls through\n-        case 'e':\n-            out.setf(std::ios::scientific, std::ios::floatfield);\n-            out.setf(std::ios::dec, std::ios::basefield);\n-            break;\n-        case 'F':\n-            out.setf(std::ios::uppercase);\n-            // Falls through\n-        case 'f':\n-            out.setf(std::ios::fixed, std::ios::floatfield);\n-            break;\n-        case 'G':\n-            out.setf(std::ios::uppercase);\n-            // Falls through\n-        case 'g':\n-            out.setf(std::ios::dec, std::ios::basefield);\n-            // As in boost::format, let stream decide float format.\n-            out.flags(out.flags() & ~std::ios::floatfield);\n-            break;\n-        case 'a': case 'A':\n-            TINYFORMAT_ERROR(\"tinyformat: the %a and %A conversion specs \"\n-                             \"are not supported\");\n-            break;\n-        case 'c':\n-            // Handled as special case inside formatValue()\n-            break;\n-        case 's':\n-            if(precisionSet)\n-                ntrunc = static_cast<int>(out.precision());\n-            // Make %s print booleans as \"true\" and \"false\"\n-            out.setf(std::ios::boolalpha);\n-            break;\n-        case 'n':\n-            // Not supported - will cause problems!\n-            TINYFORMAT_ERROR(\"tinyformat: %n conversion spec not supported\");\n-            break;\n-        case '\\0':\n-            TINYFORMAT_ERROR(\"tinyformat: Conversion spec incorrectly \"\n-                             \"terminated by end of string\");\n-            return c;\n-        default:\n-            break;\n-    }\n-    if(intConversion && precisionSet && !widthSet)\n-    {\n-        // \"precision\" for integers gives the minimum number of digits (to be\n-        // padded with zeros on the left).  This isn't really supported by the\n-        // iostreams, but we can approximately simulate it with the width if\n-        // the width isn't otherwise used.\n-        out.width(out.precision() + widthExtra);\n-        out.setf(std::ios::internal, std::ios::adjustfield);\n-        out.fill('0');\n-    }\n-    return c+1;\n-}\n-\n-\n-//------------------------------------------------------------------------------\n-inline void formatImpl(std::ostream& out, const char* fmt,\n-                       const detail::FormatArg* formatters,\n-                       int numFormatters)\n-{\n-    // Saved stream state\n-    std::streamsize origWidth = out.width();\n-    std::streamsize origPrecision = out.precision();\n-    std::ios::fmtflags origFlags = out.flags();\n-    char origFill = out.fill();\n-\n-    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)\n-    {\n-        // Parse the format string\n-        fmt = printFormatStringLiteral(out, fmt);\n-        bool spacePadPositive = false;\n-        int ntrunc = -1;\n-        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,\n-                                                   formatters, argIndex, numFormatters);\n-        if (argIndex >= numFormatters)\n-        {\n-            // Check args remain after reading any variable width/precision\n-            TINYFORMAT_ERROR(\"tinyformat: Not enough format arguments\");\n-            return;\n-        }\n-        const FormatArg& arg = formatters[argIndex];\n-        // Format the arg into the stream.\n-        if(!spacePadPositive)\n-            arg.format(out, fmt, fmtEnd, ntrunc);\n-        else\n-        {\n-            // The following is a special case with no direct correspondence\n-            // between stream formatting and the printf() behaviour.  Simulate\n-            // it crudely by formatting into a temporary string stream and\n-            // munging the resulting string.\n-            std::ostringstream tmpStream;\n-            tmpStream.copyfmt(out);\n-            tmpStream.setf(std::ios::showpos);\n-            arg.format(tmpStream, fmt, fmtEnd, ntrunc);\n-            std::string result = tmpStream.str(); // allocates... yuck.\n-            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n-                if(result[i] == '+') result[i] = ' ';\n-            out << result;\n-        }\n-        fmt = fmtEnd;\n-    }\n-\n-    // Print remaining part of format string.\n-    fmt = printFormatStringLiteral(out, fmt);\n-    if(*fmt != '\\0')\n-        TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n-\n-    // Restore stream state\n-    out.width(origWidth);\n-    out.precision(origPrecision);\n-    out.flags(origFlags);\n-    out.fill(origFill);\n-}\n-\n-} // namespace detail\n-\n-\n-/// List of template arguments format(), held in a type-opaque way.\n-///\n-/// A const reference to FormatList (typedef'd as FormatListRef) may be\n-/// conveniently used to pass arguments to non-template functions: All type\n-/// information has been stripped from the arguments, leaving just enough of a\n-/// common interface to perform formatting as required.\n-class FormatList\n-{\n-    public:\n-        FormatList(detail::FormatArg* formatters, int N)\n-            : m_formatters(formatters), m_N(N) { }\n-\n-        friend void vformat(std::ostream& out, const char* fmt,\n-                            const FormatList& list);\n-\n-    private:\n-        const detail::FormatArg* m_formatters;\n-        int m_N;\n-};\n-\n-/// Reference to type-opaque format list for passing to vformat()\n-typedef const FormatList& FormatListRef;\n-\n-\n-namespace detail {\n-\n-// Format list subclass with fixed storage to avoid dynamic allocation\n-template<int N>\n-class FormatListN : public FormatList\n-{\n-    public:\n-#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n-        template<typename... Args>\n-        explicit FormatListN(const Args&... args)\n-            : FormatList(&m_formatterStore[0], N),\n-            m_formatterStore { FormatArg(args)... }\n-        { static_assert(sizeof...(args) == N, \"Number of args must be N\"); }\n-#else // C++98 version\n-        void init(int) {}\n-#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \\\n-                                                               \\\n-        template<TINYFORMAT_ARGTYPES(n)>                       \\\n-        explicit FormatListN(TINYFORMAT_VARARGS(n))            \\\n-            : FormatList(&m_formatterStore[0], n)              \\\n-        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \\\n-                                                               \\\n-        template<TINYFORMAT_ARGTYPES(n)>                       \\\n-        void init(int i, TINYFORMAT_VARARGS(n))                \\\n-        {                                                      \\\n-            m_formatterStore[i] = FormatArg(v1);               \\\n-            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \\\n-        }\n-\n-        TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)\n-#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR\n-#endif\n-\n-    private:\n-        FormatArg m_formatterStore[N];\n-};\n-\n-// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard\n-template<> class FormatListN<0> : public FormatList\n-{\n-    public: FormatListN() : FormatList(0, 0) {}\n-};\n-\n-} // namespace detail\n-\n-\n-//------------------------------------------------------------------------------\n-// Primary API functions\n-\n-#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n-\n-/// Make type-agnostic format list from list of template arguments.\n-///\n-/// The exact return type of this function is an implementation detail and\n-/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:\n-///\n-///   FormatListRef formatList = makeFormatList( /*...*/ );\n-template<typename... Args>\n-detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args)\n-{\n-    return detail::FormatListN<sizeof...(args)>(args...);\n-}\n-\n-#else // C++98 version\n-\n-inline detail::FormatListN<0> makeFormatList()\n-{\n-    return detail::FormatListN<0>();\n-}\n-#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \\\n-template<TINYFORMAT_ARGTYPES(n)>                              \\\n-detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \\\n-{                                                             \\\n-    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \\\n-}\n-TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)\n-#undef TINYFORMAT_MAKE_MAKEFORMATLIST\n-\n-#endif\n-\n-/// Format list of arguments to the stream according to the given format string.\n-///\n-/// The name vformat() is chosen for the semantic similarity to vprintf(): the\n-/// list of format arguments is held in a single function argument.\n-inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)\n-{\n-    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);\n-}\n-\n-\n-#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n-\n-/// Format list of arguments to the stream according to given format string.\n-template<typename... Args>\n-void format(std::ostream& out, const char* fmt, const Args&... args)\n-{\n-    vformat(out, fmt, makeFormatList(args...));\n-}\n-\n-/// Format list of arguments according to the given format string and return\n-/// the result as a string.\n-template<typename... Args>\n-std::string format(const char* fmt, const Args&... args)\n-{\n-    std::ostringstream oss;\n-    format(oss, fmt, args...);\n-    return oss.str();\n-}\n-\n-/// Format list of arguments to std::cout, according to the given format string\n-template<typename... Args>\n-void printf(const char* fmt, const Args&... args)\n-{\n-    format(std::cout, fmt, args...);\n-}\n-\n-template<typename... Args>\n-void printfln(const char* fmt, const Args&... args)\n-{\n-    format(std::cout, fmt, args...);\n-    std::cout << '\\n';\n-}\n-\n-#else // C++98 version\n-\n-inline void format(std::ostream& out, const char* fmt)\n-{\n-    vformat(out, fmt, makeFormatList());\n-}\n-\n-inline std::string format(const char* fmt)\n-{\n-    std::ostringstream oss;\n-    format(oss, fmt);\n-    return oss.str();\n-}\n-\n-inline void printf(const char* fmt)\n-{\n-    format(std::cout, fmt);\n-}\n-\n-inline void printfln(const char* fmt)\n-{\n-    format(std::cout, fmt);\n-    std::cout << '\\n';\n-}\n-\n-#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \\\n-                                                                          \\\n-template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \\\n-{                                                                         \\\n-    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \\\n-}                                                                         \\\n-                                                                          \\\n-template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \\\n-{                                                                         \\\n-    std::ostringstream oss;                                               \\\n-    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \\\n-    return oss.str();                                                     \\\n-}                                                                         \\\n-                                                                          \\\n-template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n-{                                                                         \\\n-    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n-}                                                                         \\\n-                                                                          \\\n-template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \\\n-{                                                                         \\\n-    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n-    std::cout << '\\n';                                                    \\\n-}\n-\n-TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)\n-#undef TINYFORMAT_MAKE_FORMAT_FUNCS\n-\n-#endif\n-\n-// Added for Bitcoin Core\n-template<typename... Args>\n-std::string format(const std::string &fmt, const Args&... args)\n-{\n-    std::ostringstream oss;\n-    format(oss, fmt.c_str(), args...);\n-    return oss.str();\n-}\n-\n-} // namespace tinyformat\n-\n-#define strprintf tfm::format\n-\n-#endif // TINYFORMAT_H_INCLUDED"
      },
      {
        "sha": "48e2434f12bfa774f15553c3a08cb2106b4be9d3",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -18,7 +18,7 @@\n #include <fs.h>\n #include <logging.h>\n #include <sync.h>\n-#include <tinyformat.h>\n+#include <utilstrprintf.h>\n #include <utiltime.h>\n #include <utilmemory.h>\n "
      },
      {
        "sha": "c5b1c7f658de3a1bf05f943e242e0c7651b6fbed",
        "filename": "src/utilmoneystr.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utilmoneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utilmoneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilmoneystr.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -6,8 +6,8 @@\n #include <utilmoneystr.h>\n \n #include <primitives/transaction.h>\n-#include <tinyformat.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n \n std::string FormatMoney(const CAmount& n)\n {"
      },
      {
        "sha": "ddbb21f9cd67abd0f77225e04348b3fb1a7c7d3c",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <utilstrencodings.h>\n \n-#include <tinyformat.h>\n+#include <utilstrprintf.h>\n \n #include <cstdlib>\n #include <cstring>\n@@ -543,4 +543,3 @@ bool ParseFixedPoint(const std::string &val, int decimals, int64_t *amount_out)\n \n     return true;\n }\n-"
      },
      {
        "sha": "6f44c2c22a5a929752d42150c6aec2ccfcfc6fe7",
        "filename": "src/utilstrprintf.h",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utilstrprintf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utilstrprintf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrprintf.h?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -0,0 +1,40 @@\n+// Copyright (c) 2014-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTILSTRPRINTF_H\n+#define BITCOIN_UTILSTRPRINTF_H\n+\n+#include <stdexcept>\n+#include <sstream>\n+#include <string>\n+\n+// configure tinyformat prior to inclusion\n+#define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)\n+\n+namespace tinyformat {\n+// must define format_error early to enable expansion of TINYFORMAT_ERROR in tinyformat.h\n+class format_error : public std::runtime_error\n+{\n+public:\n+    format_error(const std::string& what) : std::runtime_error(what) {}\n+};\n+} // namespace tinyformat\n+\n+#include <tinyformat.h>\n+\n+namespace tinyformat {\n+// must define format wrapper template after wrapped format is defined in tinyformat.h\n+template<typename... Args>\n+std::string format(const std::string& fmt, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt.c_str(), args...);\n+    return oss.str();\n+}\n+} // namespace tinyformat\n+\n+#define strprintf tinyformat::format\n+\n+#endif"
      },
      {
        "sha": "83f075bec18d0eab9d21d9be12c689ec2a48764e",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -8,12 +8,12 @@\n #endif\n \n #include <utiltime.h>\n+#include <utilstrprintf.h>\n \n #include <atomic>\n #include <boost/date_time/posix_time/posix_time.hpp>\n #include <boost/thread.hpp>\n #include <ctime>\n-#include <tinyformat.h>\n \n static std::atomic<int64_t> nMockTime(0); //!< For unit testing\n "
      },
      {
        "sha": "f837ad72e7b7217444542861ace7b11a34c9b4a2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -30,14 +30,14 @@\n #include <script/standard.h>\n #include <shutdown.h>\n #include <timedata.h>\n-#include <tinyformat.h>\n #include <txdb.h>\n #include <txmempool.h>\n #include <ui_interface.h>\n #include <undo.h>\n #include <util.h>\n #include <utilmoneystr.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n #include <validationinterface.h>\n #include <warnings.h>\n "
      },
      {
        "sha": "9b0f50883373149670aaf75699b6ad6a53ff5fb0",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -10,9 +10,9 @@\n #include <outputtype.h>\n #include <policy/feerate.h>\n #include <streams.h>\n-#include <tinyformat.h>\n #include <ui_interface.h>\n #include <utilstrencodings.h>\n+#include <utilstrprintf.h>\n #include <validationinterface.h>\n #include <script/ismine.h>\n #include <script/sign.h>"
      },
      {
        "sha": "1fb71d00e79899ac3dc863d07ee844b513d20964",
        "filename": "test/lint/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/README.md?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -17,6 +17,7 @@ To use, make sure that you have fetched the upstream repository branch in which\n maintained:\n * for `src/secp256k1`: https://github.com/bitcoin-core/secp256k1.git (branch master)\n * for `src/leveldb`: https://github.com/bitcoin-core/leveldb.git (branch bitcoin-fork)\n+* for `src/tinyformat`: https://github.com/c42f/tinyformat.git (branch master)\n * for `src/univalue`: https://github.com/bitcoin-core/univalue.git (branch master)\n * for `src/crypto/ctaes`: https://github.com/bitcoin-core/ctaes.git (branch master)\n "
      },
      {
        "sha": "2ea714db1b38a2e1f04bb07e4a67e414ae32598e",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -10,7 +10,7 @@ export LC_ALL=C\n HEADER_ID_PREFIX=\"BITCOIN_\"\n HEADER_ID_SUFFIX=\"_H\"\n \n-REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|secp256k1/|tinyformat.h|univalue/)\"\n+REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes|leveldb|secp256k1|tinyformat|univalue)/\"\n \n EXIT_CODE=0\n for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")"
      },
      {
        "sha": "1bcd08e29ae0c492bf56addfd5d4dc02a97b8b5c",
        "filename": "test/lint/lint-includes.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-includes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-includes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-includes.sh?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -9,7 +9,7 @@\n # Check includes: Check for duplicate includes. Enforce bracket syntax includes.\n \n export LC_ALL=C\n-IGNORE_REGEXP=\"/(leveldb|secp256k1|univalue)/\"\n+IGNORE_REGEXP=\"src/(leveldb|secp256k1|univalue|tinyformat)/\"\n \n filter_suffix() {\n     git ls-files | grep -E \"^src/.*\\.${1}\"'$' | grep -Ev \"${IGNORE_REGEXP}\"\n@@ -79,7 +79,7 @@ EXPECTED_BOOST_INCLUDES=(\n     boost/variant/static_visitor.hpp\n )\n \n-for BOOST_INCLUDE in $(git grep '^#include <boost/' -- \"*.cpp\" \"*.h\" | cut -f2 -d: | cut -f2 -d'<' | cut -f1 -d'>' | sort -u); do\n+for BOOST_INCLUDE in $(git grep '^#include <boost/' -- \"*.cpp\" \"*.h\" | grep -Ev \"src/tinyformat/.+\\.cpp\" | cut -f2 -d: | cut -f2 -d'<' | cut -f1 -d'>' | sort -u); do\n     IS_EXPECTED_INCLUDE=0\n     for EXPECTED_BOOST_INCLUDE in \"${EXPECTED_BOOST_INCLUDES[@]}\"; do\n         if [[ \"${BOOST_INCLUDE}\" == \"${EXPECTED_BOOST_INCLUDE}\" ]]; then"
      },
      {
        "sha": "10d4f81905bf84263757918d859976a0d88fd2ec",
        "filename": "test/lint/lint-locale-dependence.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-locale-dependence.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-locale-dependence.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-locale-dependence.sh?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -36,7 +36,7 @@ KNOWN_VIOLATIONS=(\n     \"src/utilstrencodings.h:.*atoi\"\n )\n \n-REGEXP_IGNORE_EXTERNAL_DEPENDENCIES=\"^src/(crypto/ctaes/|leveldb/|secp256k1/|tinyformat.h|univalue/)\"\n+REGEXP_IGNORE_EXTERNAL_DEPENDENCIES=\"^src/(crypto/ctaes|leveldb|secp256k1|tinyformat|univalue)/\"\n \n LOCALE_DEPENDENT_FUNCTIONS=(\n     alphasort    # LC_COLLATE (via strcoll)"
      },
      {
        "sha": "4833d18b0ff1266909c6733bd9e54e10c93cf4e0",
        "filename": "test/lint/lint-shell-locale.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-shell-locale.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-shell-locale.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-shell-locale.sh?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -11,7 +11,7 @@\n export LC_ALL=C\n \n EXIT_CODE=0\n-for SHELL_SCRIPT in $(git ls-files -- \"*.sh\" | grep -vE \"src/(secp256k1|univalue)/\"); do\n+for SHELL_SCRIPT in $(git ls-files -- \"*.sh\" | grep -vE \"src/(secp256k1|univalue|tinyformat)/\"); do\n     if grep -q \"# This script is intentionally locale dependent by not setting \\\"export LC_ALL=C\\\"\" \"${SHELL_SCRIPT}\"; then\n         continue\n     fi"
      },
      {
        "sha": "62983bd83309380178ccb6cbba80fcc37bf592b9",
        "filename": "test/lint/lint-whitespace.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-whitespace.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53/test/lint/lint-whitespace.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-whitespace.sh?ref=ffc28d8c628d80a8f8d2ae44ddeb49b58e5cfa53",
        "patch": "@@ -31,14 +31,14 @@ if [ -z \"${TRAVIS_COMMIT_RANGE}\" ]; then\n fi\n \n showdiff() {\n-  if ! git diff -U0 \"${TRAVIS_COMMIT_RANGE}\" -- \".\" \":(exclude)depends/patches/\" \":(exclude)src/leveldb/\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\"; then\n+  if ! git diff -U0 \"${TRAVIS_COMMIT_RANGE}\" -- \".\" \":(exclude)depends/patches/\" \":(exclude)src/leveldb/\" \":(exclude)src/secp256k1/\" \":(exclude)src/tinyformat/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\"; then\n     echo \"Failed to get a diff\"\n     exit 1\n   fi\n }\n \n showcodediff() {\n-  if ! git diff -U0 \"${TRAVIS_COMMIT_RANGE}\" -- *.cpp *.h *.md *.py *.sh \":(exclude)src/leveldb/\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\"; then\n+  if ! git diff -U0 \"${TRAVIS_COMMIT_RANGE}\" -- *.cpp *.h *.md *.py *.sh \":(exclude)src/leveldb/\" \":(exclude)src/secp256k1/\" \":(exclude)src/tinyformat/\" \":(exclude)src/univalue/\" \":(exclude)doc/release-notes/\"; then\n     echo \"Failed to get a diff\"\n     exit 1\n   fi"
      }
    ]
  }
]