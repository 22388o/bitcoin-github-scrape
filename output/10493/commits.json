[
  {
    "sha": "680bc2cbb34d6bedd0e64b17d0555216572be4c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODBiYzJjYmIzNGQ2YmVkZDBlNjRiMTdkMDU1NTIxNjU3MmJlNGM4",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-06-04T20:02:43Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-10-09T19:31:58Z"
      },
      "message": "Use range-based for loops (C++11) when looping over map elements\n\nBefore this commit:\n\n  for (std::map<T1, T2>::iterator x = y.begin(); x != y.end(); ++x) {\n  }\n\nAfter this commit:\n\n  for (auto& x : y) {\n  }",
      "tree": {
        "sha": "49556f05754010cf334e67ed322e3a1dc6c29a64",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49556f05754010cf334e67ed322e3a1dc6c29a64"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/680bc2cbb34d6bedd0e64b17d0555216572be4c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/680bc2cbb34d6bedd0e64b17d0555216572be4c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/680bc2cbb34d6bedd0e64b17d0555216572be4c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/680bc2cbb34d6bedd0e64b17d0555216572be4c8/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c63364610f4a041df1c1bd81d01b1f6856160749",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c63364610f4a041df1c1bd81d01b1f6856160749",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c63364610f4a041df1c1bd81d01b1f6856160749"
      }
    ],
    "stats": {
      "total": 148,
      "additions": 74,
      "deletions": 74
    },
    "files": [
      {
        "sha": "7f494ded12ab995709752c174eff16efe5acbab9",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -390,9 +390,9 @@ int CAddrMan::Check_()\n     if (vRandom.size() != nTried + nNew)\n         return -7;\n \n-    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-        int n = (*it).first;\n-        CAddrInfo& info = (*it).second;\n+    for (const auto& entry : mapInfo) {\n+        int n = entry.first;\n+        const CAddrInfo& info = entry.second;\n         if (info.fInTried) {\n             if (!info.nLastSuccess)\n                 return -1;"
      },
      {
        "sha": "e58fb4a3695901ed74b1b30bad134b9cd05f16dd",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -313,18 +313,18 @@ class CAddrMan\n         s << nUBuckets;\n         std::map<int, int> mapUnkIds;\n         int nIds = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            mapUnkIds[(*it).first] = nIds;\n-            const CAddrInfo &info = (*it).second;\n+        for (const auto& entry : mapInfo) {\n+            mapUnkIds[entry.first] = nIds;\n+            const CAddrInfo &info = entry.second;\n             if (info.nRefCount) {\n                 assert(nIds != nNew); // this means nNew was wrong, oh ow\n                 s << info;\n                 nIds++;\n             }\n         }\n         nIds = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            const CAddrInfo &info = (*it).second;\n+        for (const auto& entry : mapInfo) {\n+            const CAddrInfo &info = entry.second;\n             if (info.fInTried) {\n                 assert(nIds != nTried); // this means nTried was wrong, oh ow\n                 s << info;"
      },
      {
        "sha": "0768fd958cd0c9e8d78b6555e02c72e7dc649488",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -110,13 +110,13 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     int nBestReachability = -1;\n     {\n         LOCK(cs_mapLocalHost);\n-        for (std::map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n+        for (const auto& entry : mapLocalHost)\n         {\n-            int nScore = (*it).second.nScore;\n-            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n+            int nScore = entry.second.nScore;\n+            int nReachability = entry.first.GetReachabilityFrom(paddrPeer);\n             if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n             {\n-                addr = CService((*it).first, (*it).second.nPort);\n+                addr = CService(entry.first, entry.second.nPort);\n                 nBestReachability = nReachability;\n                 nBestScore = nScore;\n             }"
      },
      {
        "sha": "90e1eed9a263158f0c89f98cb79cad3ebd19e619",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -55,11 +55,11 @@ class BanTablePriv\n #if QT_VERSION >= 0x040700\n         cachedBanlist.reserve(banMap.size());\n #endif\n-        for (banmap_t::iterator it = banMap.begin(); it != banMap.end(); it++)\n+        for (const auto& entry : banMap)\n         {\n             CCombinedBan banEntry;\n-            banEntry.subnet = (*it).first;\n-            banEntry.banEntry = (*it).second;\n+            banEntry.subnet = entry.first;\n+            banEntry.banEntry = entry.second;\n             cachedBanlist.append(banEntry);\n         }\n "
      },
      {
        "sha": "ff75ab89b9e8f8808bb3780647eb3993ab436e59",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -80,10 +80,10 @@ class TransactionTablePriv\n         cachedWallet.clear();\n         {\n             LOCK2(cs_main, wallet->cs_wallet);\n-            for(std::map<uint256, CWalletTx>::iterator it = wallet->mapWallet.begin(); it != wallet->mapWallet.end(); ++it)\n+            for (const auto& entry : wallet->mapWallet)\n             {\n-                if(TransactionRecord::showTransaction(it->second))\n-                    cachedWallet.append(TransactionRecord::decomposeTransaction(wallet, it->second));\n+                if (TransactionRecord::showTransaction(entry.second))\n+                    cachedWallet.append(TransactionRecord::decomposeTransaction(wallet, entry.second));\n             }\n         }\n     }"
      },
      {
        "sha": "86beba30d53d87e9938a4e8b3aebfc099b1ece2e",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -569,11 +569,11 @@ UniValue listbanned(const JSONRPCRequest& request)\n     g_connman->GetBanned(banMap);\n \n     UniValue bannedAddresses(UniValue::VARR);\n-    for (banmap_t::iterator it = banMap.begin(); it != banMap.end(); it++)\n+    for (const auto& entry : banMap)\n     {\n-        CBanEntry banEntry = (*it).second;\n+        const CBanEntry& banEntry = entry.second;\n         UniValue rec(UniValue::VOBJ);\n-        rec.push_back(Pair(\"address\", (*it).first.ToString()));\n+        rec.push_back(Pair(\"address\", entry.first.ToString()));\n         rec.push_back(Pair(\"banned_until\", banEntry.nBanUntil));\n         rec.push_back(Pair(\"ban_created\", banEntry.nCreateTime));\n         rec.push_back(Pair(\"ban_reason\", banEntry.banReasonToString()));"
      },
      {
        "sha": "53e90b93fded3891cd0be4dcd6dc6fdcffe3a243",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -160,8 +160,8 @@ std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest&\n     std::set<rpcfn_type> setDone;\n     std::vector<std::pair<std::string, const CRPCCommand*> > vCommands;\n \n-    for (std::map<std::string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n-        vCommands.push_back(make_pair(mi->second->category + mi->first, mi->second));\n+    for (const auto& entry : mapCommands)\n+        vCommands.push_back(make_pair(entry.second->category + entry.first, entry.second));\n     sort(vCommands.begin(), vCommands.end());\n \n     JSONRPCRequest jreq(helpreq);"
      },
      {
        "sha": "bb755c9b3dff94f0d8ba3189303f5f5371aacf62",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -732,8 +732,8 @@ template<typename Stream, typename K, typename T, typename Pred, typename A>\n void Serialize(Stream& os, const std::map<K, T, Pred, A>& m)\n {\n     WriteCompactSize(os, m.size());\n-    for (typename std::map<K, T, Pred, A>::const_iterator mi = m.begin(); mi != m.end(); ++mi)\n-        Serialize(os, (*mi));\n+    for (const auto& entry : m)\n+        Serialize(os, entry);\n }\n \n template<typename Stream, typename K, typename T, typename Pred, typename A>"
      },
      {
        "sha": "067eee9dbd37479038803b53b0481169e688d22e",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -81,8 +81,8 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n         // Manually recompute the dynamic usage of the whole data, and compare it.\n         size_t ret = memusage::DynamicUsage(cacheCoins);\n         size_t count = 0;\n-        for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n-            ret += it->second.coin.DynamicMemoryUsage();\n+        for (const auto& entry : cacheCoins) {\n+            ret += entry.second.coin.DynamicMemoryUsage();\n             ++count;\n         }\n         BOOST_CHECK_EQUAL(GetCacheSize(), count);\n@@ -189,15 +189,15 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (auto it = result.begin(); it != result.end(); it++) {\n-                bool have = stack.back()->HaveCoin(it->first);\n-                const Coin& coin = stack.back()->AccessCoin(it->first);\n+            for (const auto& entry : result) {\n+                bool have = stack.back()->HaveCoin(entry.first);\n+                const Coin& coin = stack.back()->AccessCoin(entry.first);\n                 BOOST_CHECK(have == !coin.IsSpent());\n-                BOOST_CHECK(coin == it->second);\n+                BOOST_CHECK(coin == entry.second);\n                 if (coin.IsSpent()) {\n                     missed_an_entry = true;\n                 } else {\n-                    BOOST_CHECK(stack.back()->HaveCoinInCache(it->first));\n+                    BOOST_CHECK(stack.back()->HaveCoinInCache(entry.first));\n                     found_an_entry = true;\n                 }\n             }\n@@ -420,11 +420,11 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (auto it = result.begin(); it != result.end(); it++) {\n-                bool have = stack.back()->HaveCoin(it->first);\n-                const Coin& coin = stack.back()->AccessCoin(it->first);\n+            for (const auto& entry : result) {\n+                bool have = stack.back()->HaveCoin(entry.first);\n+                const Coin& coin = stack.back()->AccessCoin(entry.first);\n                 BOOST_CHECK(have == !coin.IsSpent());\n-                BOOST_CHECK(coin == it->second);\n+                BOOST_CHECK(coin == entry.second);\n             }\n         }\n "
      },
      {
        "sha": "be9cc6f2309b2a35f92921d6a63b303869ad6294",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -3249,8 +3249,8 @@ void PruneOneBlockFile(const int fileNumber)\n {\n     LOCK(cs_LastBlockFile);\n \n-    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {\n-        CBlockIndex* pindex = it->second;\n+    for (const auto& entry : mapBlockIndex) {\n+        CBlockIndex* pindex = entry.second;\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n             pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n@@ -3802,8 +3802,8 @@ bool RewindBlockIndex(const CChainParams& params)\n     // Reduce validity flag and have-data flags.\n     // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n     // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n-    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n-        CBlockIndex* pindexIter = it->second;\n+    for (const auto& entry : mapBlockIndex) {\n+        CBlockIndex* pindexIter = entry.second;\n \n         // Note: If we encounter an insufficiently validated block that\n         // is on chainActive, it must be because we are a pruning node, and\n@@ -4078,8 +4078,8 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n-        forward.insert(std::make_pair(it->second->pprev, it->second));\n+    for (auto& entry : mapBlockIndex) {\n+        forward.insert(std::make_pair(entry.second->pprev, entry.second));\n     }\n \n     assert(forward.size() == mapBlockIndex.size());"
      },
      {
        "sha": "dd4941283089adde9b3e621d3d400543ce10c327",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -1398,14 +1398,14 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n     if (fByAccounts)\n     {\n-        for (std::map<std::string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n+        for (const auto& entry : mapAccountTally)\n         {\n-            CAmount nAmount = (*it).second.nAmount;\n-            int nConf = (*it).second.nConf;\n+            CAmount nAmount = entry.second.nAmount;\n+            int nConf = entry.second.nConf;\n             UniValue obj(UniValue::VOBJ);\n-            if((*it).second.fIsWatchonly)\n+            if (entry.second.fIsWatchonly)\n                 obj.push_back(Pair(\"involvesWatchonly\", true));\n-            obj.push_back(Pair(\"account\",       (*it).first));\n+            obj.push_back(Pair(\"account\",       entry.first));\n             obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n             obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n             ret.push_back(obj);"
      },
      {
        "sha": "e94f5c2c00db6e2b1672d2204d6f420dfa0dcd2c",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -701,9 +701,9 @@ DBErrors CWallet::ReorderTransactions()\n     typedef std::multimap<int64_t, TxPair > TxItems;\n     TxItems txByTime;\n \n-    for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+    for (auto& entry : mapWallet)\n     {\n-        CWalletTx* wtx = &((*it).second);\n+        CWalletTx* wtx = &entry.second;\n         txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, nullptr)));\n     }\n     std::list<CAccountingEntry> acentries;\n@@ -1966,9 +1966,9 @@ CAmount CWallet::GetBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &entry.second;\n             if (pcoin->IsTrusted())\n                 nTotal += pcoin->GetAvailableCredit();\n         }\n@@ -1982,9 +1982,9 @@ CAmount CWallet::GetUnconfirmedBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &entry.second;\n             if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n                 nTotal += pcoin->GetAvailableCredit();\n         }\n@@ -1997,9 +1997,9 @@ CAmount CWallet::GetImmatureBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &entry.second;\n             nTotal += pcoin->GetImmatureCredit();\n         }\n     }\n@@ -2011,9 +2011,9 @@ CAmount CWallet::GetWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &entry.second;\n             if (pcoin->IsTrusted())\n                 nTotal += pcoin->GetAvailableWatchOnlyCredit();\n         }\n@@ -2027,9 +2027,9 @@ CAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &entry.second;\n             if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n                 nTotal += pcoin->GetAvailableWatchOnlyCredit();\n         }\n@@ -2042,9 +2042,9 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &entry.second;\n             nTotal += pcoin->GetImmatureWatchOnlyCredit();\n         }\n     }\n@@ -2118,10 +2118,10 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n \n         CAmount nTotal = 0;\n \n-        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (const auto& entry : mapWallet)\n         {\n-            const uint256& wtxid = it->first;\n-            const CWalletTx* pcoin = &(*it).second;\n+            const uint256& wtxid = entry.first;\n+            const CWalletTx* pcoin = &entry.second;\n \n             if (!CheckFinalTx(*pcoin))\n                 continue;\n@@ -2182,10 +2182,10 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n                 if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n                     continue;\n \n-                if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint((*it).first, i)))\n+                if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n                     continue;\n \n-                if (IsLockedCoin((*it).first, i))\n+                if (IsLockedCoin(entry.first, i))\n                     continue;\n \n                 if (IsSpent(wtxid, i))\n@@ -3640,9 +3640,9 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n \n     // find first block that affects those keys, if there are any left\n     std::vector<CKeyID> vAffected;\n-    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n+    for (const auto& entry : mapWallet) {\n         // iterate over all wallet transactions...\n-        const CWalletTx &wtx = (*it).second;\n+        const CWalletTx &wtx = entry.second;\n         BlockMap::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n         if (blit != mapBlockIndex.end() && chainActive.Contains(blit->second)) {\n             // ... which are already in a block\n@@ -3662,8 +3662,8 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     }\n \n     // Extract block timestamps for those keys\n-    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n-        mapKeyBirth[it->first] = it->second->GetBlockTime() - TIMESTAMP_WINDOW; // block times can be 2h off\n+    for (const auto& entry : mapKeyFirstBlock)\n+        mapKeyBirth[entry.first] = entry.second->GetBlockTime() - TIMESTAMP_WINDOW; // block times can be 2h off\n }\n \n /**"
      },
      {
        "sha": "23669688624411f08f7c2eca54c7d4d0da434549",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/680bc2cbb34d6bedd0e64b17d0555216572be4c8/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=680bc2cbb34d6bedd0e64b17d0555216572be4c8",
        "patch": "@@ -40,15 +40,15 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()\n     factories[\"pubrawblock\"] = CZMQAbstractNotifier::Create<CZMQPublishRawBlockNotifier>;\n     factories[\"pubrawtx\"] = CZMQAbstractNotifier::Create<CZMQPublishRawTransactionNotifier>;\n \n-    for (std::map<std::string, CZMQNotifierFactory>::const_iterator i=factories.begin(); i!=factories.end(); ++i)\n+    for (const auto& entry : factories)\n     {\n-        std::string arg(\"-zmq\" + i->first);\n+        std::string arg(\"-zmq\" + entry.first);\n         if (gArgs.IsArgSet(arg))\n         {\n-            CZMQNotifierFactory factory = i->second;\n+            CZMQNotifierFactory factory = entry.second;\n             std::string address = gArgs.GetArg(arg, \"\");\n             CZMQAbstractNotifier *notifier = factory();\n-            notifier->SetType(i->first);\n+            notifier->SetType(entry.first);\n             notifier->SetAddress(address);\n             notifiers.push_back(notifier);\n         }"
      }
    ]
  }
]