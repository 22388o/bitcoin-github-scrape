[
  {
    "sha": "1f20501efce041d34e63ab9a11359bedf4a82cd5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZjIwNTAxZWZjZTA0MWQzNGU2M2FiOWExMTM1OWJlZGY0YTgyY2Q1",
    "commit": {
      "author": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-05-26T14:36:02Z"
      },
      "committer": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-08-16T05:43:07Z"
      },
      "message": "test: add functional test for multisig flow with descriptor wallets and PSBTs",
      "tree": {
        "sha": "dff6422e7126a4ded19b5d8f99c4f3285180b1eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dff6422e7126a4ded19b5d8f99c4f3285180b1eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f20501efce041d34e63ab9a11359bedf4a82cd5",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENKwpEUV32QrrIOeYc3/VzfHRRrkFAmEZ+usACgkQc3/VzfHR\nRrlcNg//UpCTmOzJ3UEfIxxchYA7UcB27MieQhEcOrlRyfwwtTQZ0XYbojvEMMnQ\nlfBCsr9OTkYHK67PzXtH38ajPaKxlE9Ugc6E6aYwl9rMMWyg0y2qKMkkDwEWThth\niooELutkShyHi7tbIlY7EKjcf691WjIORRGSMHpVJR3XiyPlFaYjez5Rd1cCMYAT\n9ZRKBuWMAIDorpPv2tA/LeTEfneJMkhIkYAXNBAazkV4casAqgvWuS72RCPFclBO\nYg0XxwEi9hRuqe0CQzUx69T+mQ0YernNRNxiJAEM6Ei7acb5V+sHks/4dDAoMXC2\nRI1nPw/ScPwwa8S76iWkXx5xcvYv6n/kj0MZL6gFEKiaRP0morjk8+PTtO05vGzt\nkzLnZnoVj8XybAPUgi+/V1xTRg4EvVunIvy05uuT88z0x0+lfJcD3kJbjPXBGfNj\nPoi02HYtx1DNRth1qtHllCFh3N8KlWvlFOV86XsHJTNYxG5MwGPpXEl/mi4Qw4Zi\nEfRnRXSbHDJ5Le6Lmq48zE5DXeOZnN4eYdCnZ7yczKfjccwSsaAW7sZ521AAdlRL\nHugu9FeBtVzlswONNBKEdccPgfy/RQP+HiPf/KNcOs5OyOug4i9NFs2wsu/GDtJn\nSHbWzVVLs3hm89oz0432uGJsQTQZzVdYdSTJJ4EGbPUyZteO6Kw=\n=/GtZ\n-----END PGP SIGNATURE-----",
        "payload": "tree dff6422e7126a4ded19b5d8f99c4f3285180b1eb\nparent 803ef70fd9f65ef800567ff9456fac525bc3e3c2\nauthor Michael Dietz <michael.dietz@waya.ai> 1622039762 -0400\ncommitter Michael Dietz <michael.dietz@waya.ai> 1629092587 +0500\n\ntest: add functional test for multisig flow with descriptor wallets and PSBTs\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f20501efce041d34e63ab9a11359bedf4a82cd5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1f20501efce041d34e63ab9a11359bedf4a82cd5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f20501efce041d34e63ab9a11359bedf4a82cd5/comments",
    "author": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "803ef70fd9f65ef800567ff9456fac525bc3e3c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/803ef70fd9f65ef800567ff9456fac525bc3e3c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/803ef70fd9f65ef800567ff9456fac525bc3e3c2"
      }
    ],
    "stats": {
      "total": 144,
      "additions": 144,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ade8bf2aa98d88e78a392733d5c23cac7a14f30d",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f20501efce041d34e63ab9a11359bedf4a82cd5/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f20501efce041d34e63ab9a11359bedf4a82cd5/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=1f20501efce041d34e63ab9a11359bedf4a82cd5",
        "patch": "@@ -204,6 +204,7 @@\n     'feature_assumevalid.py',\n     'example_test.py',\n     'wallet_txn_doublespend.py --legacy-wallet',\n+    'wallet_multisig_descriptor_psbt.py',\n     'wallet_txn_doublespend.py --descriptors',\n     'feature_backwards_compatibility.py --legacy-wallet',\n     'feature_backwards_compatibility.py --descriptors',"
      },
      {
        "sha": "e8b9ad8f2a6196cf1278d38e73c5e129fad92e9e",
        "filename": "test/functional/wallet_multisig_descriptor_psbt.py",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f20501efce041d34e63ab9a11359bedf4a82cd5/test/functional/wallet_multisig_descriptor_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f20501efce041d34e63ab9a11359bedf4a82cd5/test/functional/wallet_multisig_descriptor_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multisig_descriptor_psbt.py?ref=1f20501efce041d34e63ab9a11359bedf4a82cd5",
        "patch": "@@ -0,0 +1,143 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a basic M-of-N multisig setup between multiple people using descriptor wallets and PSBTs, as well as a signing flow.\n+\n+This is meant to be documentation as much as functional tests, so it is kept as simple and readable as possible.\n+\"\"\"\n+\n+from test_framework.address import base58_to_byte\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+)\n+\n+\n+class WalletMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 3\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    def _get_xpub(self, wallet):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh\"), wallet.listdescriptors()[\"descriptors\"]))\n+        return descriptor[\"desc\"].split(\"]\")[-1].split(\"/\")[0]\n+\n+    def _check_psbt(self, psbt, to, value, multisig):\n+        \"\"\"Helper method for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def generate_and_exchange_xpubs(self, participants):\n+        \"\"\"Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet. Avoid reusing this wallet for any other purpose..\"\"\"\n+        for i, node in enumerate(participants):\n+            node.createwallet(wallet_name=f\"participant_{i}\", descriptors=True)\n+            yield self._get_xpub(node.get_wallet_rpc(f\"participant_{i}\"))\n+\n+    def participants_import_descriptors(self, participants, xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        # some simple validation\n+        assert_equal(len(xpubs), self.N)\n+        # a sanity-check/assertion, this will throw if the base58 checksum of any of the provided xpubs are invalid\n+        for xpub in xpubs:\n+            base58_to_byte(xpub)\n+\n+        for i, node in enumerate(participants):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            external = multisig.getdescriptorinfo(f\"wsh(sortedmulti({self.M},{f'/{0}/*,'.join(xpubs)}/{0}/*))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(sortedmulti({self.M},{f'/{1}/*,'.join(xpubs)}/{1}/*))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+\n+    def get_multisig_receiving_address(self):\n+        \"\"\"We will send funds to the resulting address (every participant should get the same addresses).\"\"\"\n+        multisig = self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\")\n+        receiving_address = multisig.getnewaddress()\n+        for i in range(1, self.N):\n+            assert_equal(receiving_address, self.nodes[i].get_wallet_rpc(f\"{self.name}_{i}\").getnewaddress())\n+        return receiving_address\n+\n+    def make_sending_transaction(self, to, value):\n+        \"\"\"Make a sending transaction, created using walletcreatefundedpsbt (anyone can initiate this).\"\"\"\n+        return self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").walletcreatefundedpsbt(inputs=[], outputs={to: value}, options={\"feeRate\": 0.00010})\n+\n+    def run_test(self):\n+        self.M = 2\n+        self.N = self.num_nodes\n+        self.name = f\"{self.M}_of_{self.N}_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        xpubs = list(self.generate_and_exchange_xpubs(self.nodes))\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        self.participants_import_descriptors(self.nodes, xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.nodes[0].get_wallet_rpc(f\"participant_{0}\")\n+        coordinator_wallet.generatetoaddress(101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = self.get_multisig_receiving_address()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        for n in range(self.N):\n+            assert_approx(self.nodes[n].get_wallet_rpc(f\"{self.name}_{n}\").getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig!\")\n+        to = self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getnewaddress()\n+        value = 1\n+        psbt = self.make_sending_transaction(to, value)\n+\n+        psbts = []\n+        self.log.info(\"At least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = self.nodes[m].get_wallet_rpc(f\"{self.name}_{m}\")\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = self.nodes[m].get_wallet_rpc(f\"participant_{m}\")\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_approx(self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getbalance(), value)\n+\n+if __name__ == \"__main__\":\n+    WalletMultisigDescriptorPSBTTest().main()"
      }
    ]
  },
  {
    "sha": "17dd6573008c8aca9fc0da9419225c85a4f94330",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxN2RkNjU3MzAwOGM4YWNhOWZjMGRhOTQxOTIyNWM4NWE0Zjk0MzMw",
    "commit": {
      "author": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-05-26T14:37:24Z"
      },
      "committer": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-08-16T05:43:07Z"
      },
      "message": "doc: M-of-N multisig using descriptor wallets and PSBTs, as well as a signing flow",
      "tree": {
        "sha": "ffebe1b4d10fefdf70b481d46268acfda54b3eb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ffebe1b4d10fefdf70b481d46268acfda54b3eb9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/17dd6573008c8aca9fc0da9419225c85a4f94330",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENKwpEUV32QrrIOeYc3/VzfHRRrkFAmEZ+usACgkQc3/VzfHR\nRrnO0Q//SMZmpyB6SwqE09YszWlL01t8UXKa+opKpZ3INMSqYoaKMCx4AU/w5y8r\n8zPe1MbI+DCdQ4otRSQ6d/R7LhjJw53GslKXrnGDYueloKrQrqg2XQKQR/jl/z3c\nxadMuU/vl1xIkKJfjFuh8iScxOs7CvIPx5MlKqimErDH8DrcNGi7d3FRIA4SmbkO\nLX2hmNNG13sjJr4uWZRrpA2ldicAx7sbBwCKZvwG9W4WXE5UjkqxyJuAIRQj61j4\nkKhzo7bLicHqUJ14sQGUCVsjHnKL/SWIoAAbr5p9T52Wfhf2nwULQy1xGzS2hpzi\niRCpQY23Wpv1VAPJQLUmJPxjpQC5CvA94ZJHt7x53ukEOAfEoJ1CX57RHAM34HeC\nv/PJjFz58t6dTZaXxyJ3EYi0OVxfg6wiJNKigwo1Am6xpOhAVPKmWmLo43Kdgd2v\nenpMIFUaddPghZnM1psz0J0rF8bEYEJMIrrqhixRqZaBVdH4tBgP28Jj2Y0g+jnW\nc9TB2i+Gf2Bm7Ptr4jZUPucFJiZ45pJQKj4uXrIF1qmKUrittpssE9OFdOEPObMu\nRnYwond4VoOSAi44zafxgTlX4Olm6vYglPu1UizJ6YcKlUzDzojF4eb7l3l79fhy\nB/EnqtdKmNonTFoQCjwAUtBDWNhFSH2t96em7XDt67u8gPSUwhI=\n=Twst\n-----END PGP SIGNATURE-----",
        "payload": "tree ffebe1b4d10fefdf70b481d46268acfda54b3eb9\nparent 1f20501efce041d34e63ab9a11359bedf4a82cd5\nauthor Michael Dietz <michael.dietz@waya.ai> 1622039844 -0400\ncommitter Michael Dietz <michael.dietz@waya.ai> 1629092587 +0500\n\ndoc: M-of-N multisig using descriptor wallets and PSBTs, as well as a signing flow\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17dd6573008c8aca9fc0da9419225c85a4f94330",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/17dd6573008c8aca9fc0da9419225c85a4f94330",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17dd6573008c8aca9fc0da9419225c85a4f94330/comments",
    "author": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1f20501efce041d34e63ab9a11359bedf4a82cd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f20501efce041d34e63ab9a11359bedf4a82cd5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1f20501efce041d34e63ab9a11359bedf4a82cd5"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 29,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ab04f64b6bf3e97bc9026c5c39cbd04da55a927c",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/17dd6573008c8aca9fc0da9419225c85a4f94330/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/17dd6573008c8aca9fc0da9419225c85a4f94330/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=17dd6573008c8aca9fc0da9419225c85a4f94330",
        "patch": "@@ -139,6 +139,32 @@ Key order does not matter for `sortedmulti()`. `sortedmulti()` behaves in the sa\n as `multi()` does but the keys are reordered in the resulting script such that they\n are lexicographically ordered as described in BIP67.\n \n+#### Basic multisig example\n+\n+For a good example of a basic M-of-N multisig between multiple participants using descriptor\n+wallets and PSBTs, as well as a signing flow, see [this functional test](/test/functional/wallet_multisig_descriptor_psbt.py).\n+The basic steps are:\n+\n+  1. Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+     Avoid reusing this wallet for any other purpose. Hint: extract the wallet's xpubs using `listdescriptors`\n+     and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses)\n+  2. Create a watch-only descriptor wallet (blank, private keys disabled). Now the multisig is created by importing the two descriptors:\n+     `wsh(sortedmulti(<M>,XPUB1/0/*,XPUB2/0/*,\u2026,XPUBN/0/*))` and `wsh(sortedmulti(<M>,XPUB1/1/*,XPUB2/1/*,\u2026,XPUBN/1/*))`\n+     (one descriptor w/ `0` for receiving addresses and another w/ `1` for change). Every participant does this\n+  3. A receiving address is generated for the multisig. As a check to ensure step 2 was done correctly, every participant\n+     should verify they get the same addresses\n+  4. Funds are sent to the resulting address\n+  5. A sending transaction is created using `walletcreatefundedpsbt` (anyone can initiate this). It is simple to do this in\n+     the GUI by going to the `Send` tab in the multisig wallet and creating an unsigned transaction (PSBT)\n+  6. At least `M` users check the PSBT with `decodepsbt` and (if OK) signs it with `walletprocesspsbt`. It is simple to do\n+     this in the GUI by Loading the PSBT from file and signing it\n+  7. The signed PSBTs are collected with `combinepsbt`, finalized w/ `finalizepsbt`, and\n+     then the resulting transaction is broadcasted to the network\n+  8. Checks that balances are correct after the transaction has been included in a block\n+\n+[The test](/test/functional/wallet_multisig_descriptor_psbt.py) is meant to be documentation as much as it is a functional test, so\n+it is kept as simple and readable as possible.\n+\n ### BIP32 derived keys and chains\n \n Most modern wallet software and hardware uses keys that are derived using"
      },
      {
        "sha": "0f31cb8eba633383f9fcb276380d435539322e5f",
        "filename": "doc/psbt.md",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/17dd6573008c8aca9fc0da9419225c85a4f94330/doc/psbt.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/17dd6573008c8aca9fc0da9419225c85a4f94330/doc/psbt.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/psbt.md?ref=17dd6573008c8aca9fc0da9419225c85a4f94330",
        "patch": "@@ -92,6 +92,9 @@ hardware implementations will typically implement multiple roles simultaneously.\n \n #### Multisig with multiple Bitcoin Core instances\n \n+For a quick start see [Basic M-of-N multisig example using descriptor wallets and PSBTs](./descriptors.md#basic-multisig-example).\n+If you are using legacy wallets feel free to continue with the example provided here.\n+\n Alice, Bob, and Carol want to create a 2-of-3 multisig address. They're all using\n Bitcoin Core. We assume their wallets only contain the multisig funds. In case\n they also have a personal wallet, this can be accomplished through the"
      }
    ]
  },
  {
    "sha": "e05cd0546a155afcd45c43ce730c4abecd40dfed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMDVjZDA1NDZhMTU1YWZjZDQ1YzQzY2U3MzBjNGFiZWNkNDBkZmVk",
    "commit": {
      "author": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-05-26T14:38:12Z"
      },
      "committer": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-08-16T05:43:07Z"
      },
      "message": "doc: add another signing flow for multisig with descriptor wallets and PSBTs",
      "tree": {
        "sha": "4b91ec0309644c599afedf34c1e4a65733d73ec2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b91ec0309644c599afedf34c1e4a65733d73ec2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e05cd0546a155afcd45c43ce730c4abecd40dfed",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENKwpEUV32QrrIOeYc3/VzfHRRrkFAmEZ+usACgkQc3/VzfHR\nRrkmrg//Ub/HZlH/lrCe8X+KE6so3JDJbF0ZlhTGMGhZyW7OmofuTzFRSHwDkHXO\nBJ0sKvy04jJ/PiktgVganIg9inR4oz0isu+bXGCzAsFS54YajBbaTfwzk0903hwb\nR66itdgqW5Phe+RSyNo3YUG3CBY4xgsz9EQabsO3T5KqarpAvd2P0ErYo11wt05V\n8vq7Fjv79T6qSQV6p+3X1YpYbjIaWI5qpLzjgml3QWG7KDx5f9ueWgQT6GOdKFX8\nlDUjg//o0SY/bDGF6G50WjuYHG2kpv79bqtZeciUwSwJZeOi2MFVonl+o89+ZM/+\nvrO4TY3Z/qSU3LkzKvwZpH80CeAFJ/TweNXGqEuf5lrHLdOxmaEQzWjJnctnaorm\nPwKEzbcQKHMSRk0GDXSL6tanmePFnQzlko1Dr+rKafIlffmH/bIs5qfr7pl6alUV\nBmTpKaHStEe755TLb73KIR75e9vDJEtCgt/q1KfyxQ/iW+VHFJsV1fdGZyt0gt5q\noqkUcInApKQIGEX6eTujC7TOfGhki8ACg+45qsqEhjFDpQhGvEMqB5TWswjKUW7s\nxHkDxO8b2i0XRMCcT9TkmH8//3Z/8NlBGuAV7kNwcO8NC1xsxX/s5QleoVaiE25u\ngEImdVze9Cu/YvGeJP54nKBPnsaY6dS6m4to3heuOOS81M+KnwM=\n=lLcX\n-----END PGP SIGNATURE-----",
        "payload": "tree 4b91ec0309644c599afedf34c1e4a65733d73ec2\nparent 17dd6573008c8aca9fc0da9419225c85a4f94330\nauthor Michael Dietz <michael.dietz@waya.ai> 1622039892 -0400\ncommitter Michael Dietz <michael.dietz@waya.ai> 1629092587 +0500\n\ndoc: add another signing flow for multisig with descriptor wallets and PSBTs\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e05cd0546a155afcd45c43ce730c4abecd40dfed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e05cd0546a155afcd45c43ce730c4abecd40dfed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e05cd0546a155afcd45c43ce730c4abecd40dfed/comments",
    "author": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "17dd6573008c8aca9fc0da9419225c85a4f94330",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17dd6573008c8aca9fc0da9419225c85a4f94330",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/17dd6573008c8aca9fc0da9419225c85a4f94330"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 21,
      "deletions": 0
    },
    "files": [
      {
        "sha": "75b9582343a923561ed712470f8599102330b0dd",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e05cd0546a155afcd45c43ce730c4abecd40dfed/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e05cd0546a155afcd45c43ce730c4abecd40dfed/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=e05cd0546a155afcd45c43ce730c4abecd40dfed",
        "patch": "@@ -162,6 +162,11 @@ The basic steps are:\n      then the resulting transaction is broadcasted to the network\n   8. Checks that balances are correct after the transaction has been included in a block\n \n+You may prefer a daisy chained signing flow where each participant signs the PSBT one after another until\n+the PSBT has been signed `M` times and is \"complete.\" For the most part, the steps above remain the same, except (6, 7)\n+change slightly from signing the original PSBT in parallel to signing it in series. `combinepsbt` is not necessary with\n+this signing flow and the last (`m`th) signer can just broadcast the PSBT after signing. Note that a parallel signing flow may be\n+preferable in cases where there are more signers. This signing flow is also included in the test / Python example.\n [The test](/test/functional/wallet_multisig_descriptor_psbt.py) is meant to be documentation as much as it is a functional test, so\n it is kept as simple and readable as possible.\n "
      },
      {
        "sha": "59a0b94a9f39c49fb7bf7f37bf5a1bc1e750d7fc",
        "filename": "test/functional/wallet_multisig_descriptor_psbt.py",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e05cd0546a155afcd45c43ce730c4abecd40dfed/test/functional/wallet_multisig_descriptor_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e05cd0546a155afcd45c43ce730c4abecd40dfed/test/functional/wallet_multisig_descriptor_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multisig_descriptor_psbt.py?ref=e05cd0546a155afcd45c43ce730c4abecd40dfed",
        "patch": "@@ -139,5 +139,21 @@ def run_test(self):\n         assert_approx(self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").getbalance(), deposit_amount - value, vspan=0.001)\n         assert_equal(self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getbalance(), value)\n \n+        self.log.info(\"Send another transaction from the multisig, this time with a daisy chained signing flow (one after another in series)!\")\n+        psbt = self.make_sending_transaction(to, value)\n+        for m in range(self.M):\n+            signing_wallet = self.nodes[m].get_wallet_rpc(f\"participant_{m}\")\n+            psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            assert_equal(psbt[\"complete\"], m == self.M - 1)\n+        finalized = coordinator_wallet.finalizepsbt(psbt[\"psbt\"])\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_approx(self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").getbalance(), deposit_amount - (value * 2), vspan=0.001)\n+        assert_equal(self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getbalance(), value * 2)\n+\n+\n if __name__ == \"__main__\":\n     WalletMultisigDescriptorPSBTTest().main()"
      }
    ]
  },
  {
    "sha": "f9479e4626f6b5126ff8cdab3a7e718c609429ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTQ3OWU0NjI2ZjZiNTEyNmZmOGNkYWIzYTdlNzE4YzYwOTQyOWVm",
    "commit": {
      "author": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-09-03T18:36:07Z"
      },
      "committer": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-09-03T18:49:03Z"
      },
      "message": "test, doc: basic M-of-N multisig minor cleanup and clarifications\n\nwallet_multisig_descriptor_psbt.py is refactored in this commit. While\nbehavior doesn't change we do cleanup the way wallets are accessed\nthroughout the test as this is done a lot for the various signers\nand their multisigs. We also get rid of some shallow methods and\ninstead inline them for improved readability.\n\ndescriptors.md is improved to be more explicit about which wallet\n(ie the signer or multisig) is required for each step.",
      "tree": {
        "sha": "4b5815b79437a8772119f47e609b3f3deb1d4290",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b5815b79437a8772119f47e609b3f3deb1d4290"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9479e4626f6b5126ff8cdab3a7e718c609429ef",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENKwpEUV32QrrIOeYc3/VzfHRRrkFAmEybh8ACgkQc3/VzfHR\nRrlExA/+PwGILQFdMtv7zTMprujf6vVwfi00w33AS3j3Nl5kVxNye7y3SyUnbXVE\n5QOGrJuaDoCK5JbAUK5JG9V2+PlRTmrWo8TfuZaajBrXnaIKdRdlhQmlNLJMiG09\nXHHZ3vvn3d3di2aelPRYCD78pNUCcOaXmKK7u2kFCc/ZeG6FjKHhpNyQQZEdBl7/\nHkI24FgWq8Efd2hoUE2UlG8xVZO1OqU8EomB+OKfxsRJoC62hsRUbR/gbTFr5Xt0\nog8WMskg29uYQRZU16CyK5P1hgO89fU6g7garkUf1gApG7znudQnZm6B5zrWA9d9\nfipcGovUiskGtSFKCSfZ80QEom2NQdbcCRsFxUBt9Gp/PIdyxpCmc8XkU/iErczS\n2Gw6/G8IiVoYrXk786S56qyyDG1eeYK8hog+gkh3s0og0cjEBLQ9yGD2RpB+F/y4\nGyGeLQDS0YaVUpLYiPMasuj8yOpNtV3PXjLB0NmxnokzhSp4srCTRSeMHzC4AO4I\n4kRvzlmUxe5JUG6oQdRAncRJTRNdHc3kdXkcgmc6+7/LV6aioUSxWB3kzeBV7m2L\nuZlwILPJP+oKD/UjQVMzbvW09z8+fwqKuykA35i42p7FpxEAozkZGMORFYSLhHQu\nJhkVXUaG0116eVcIxvwAC1nkSDbmbayU9IlMsOis51mXm/L9Obc=\n=tmim\n-----END PGP SIGNATURE-----",
        "payload": "tree 4b5815b79437a8772119f47e609b3f3deb1d4290\nparent e05cd0546a155afcd45c43ce730c4abecd40dfed\nauthor Michael Dietz <michael.dietz@waya.ai> 1630694167 -0500\ncommitter Michael Dietz <michael.dietz@waya.ai> 1630694943 -0500\n\ntest, doc: basic M-of-N multisig minor cleanup and clarifications\n\nwallet_multisig_descriptor_psbt.py is refactored in this commit. While\nbehavior doesn't change we do cleanup the way wallets are accessed\nthroughout the test as this is done a lot for the various signers\nand their multisigs. We also get rid of some shallow methods and\ninstead inline them for improved readability.\n\ndescriptors.md is improved to be more explicit about which wallet\n(ie the signer or multisig) is required for each step.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9479e4626f6b5126ff8cdab3a7e718c609429ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9479e4626f6b5126ff8cdab3a7e718c609429ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9479e4626f6b5126ff8cdab3a7e718c609429ef/comments",
    "author": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e05cd0546a155afcd45c43ce730c4abecd40dfed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e05cd0546a155afcd45c43ce730c4abecd40dfed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e05cd0546a155afcd45c43ce730c4abecd40dfed"
      }
    ],
    "stats": {
      "total": 112,
      "additions": 59,
      "deletions": 53
    },
    "files": [
      {
        "sha": "f38caa81cb706833cc0417c5fb9be717146ee9ee",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 12,
        "deletions": 10,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9479e4626f6b5126ff8cdab3a7e718c609429ef/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9479e4626f6b5126ff8cdab3a7e718c609429ef/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=f9479e4626f6b5126ff8cdab3a7e718c609429ef",
        "patch": "@@ -145,22 +145,24 @@ For a good example of a basic M-of-N multisig between multiple participants usin\n wallets and PSBTs, as well as a signing flow, see [this functional test](/test/functional/wallet_multisig_descriptor_psbt.py).\n The basic steps are:\n \n-  1. Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n-     Avoid reusing this wallet for any other purpose. Hint: extract the wallet's xpubs using `listdescriptors`\n-     and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses)\n+  1. Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet which we will refer to as\n+     the participant's signer wallet. Avoid reusing this wallet for any purpose other than signing transactions from the\n+     corresponding multisig we are about to create. Hint: extract the wallet's xpubs using `listdescriptors` and pick the one from the\n+     `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses)\n   2. Create a watch-only descriptor wallet (blank, private keys disabled). Now the multisig is created by importing the two descriptors:\n      `wsh(sortedmulti(<M>,XPUB1/0/*,XPUB2/0/*,\u2026,XPUBN/0/*))` and `wsh(sortedmulti(<M>,XPUB1/1/*,XPUB2/1/*,\u2026,XPUBN/1/*))`\n      (one descriptor w/ `0` for receiving addresses and another w/ `1` for change). Every participant does this\n   3. A receiving address is generated for the multisig. As a check to ensure step 2 was done correctly, every participant\n      should verify they get the same addresses\n   4. Funds are sent to the resulting address\n-  5. A sending transaction is created using `walletcreatefundedpsbt` (anyone can initiate this). It is simple to do this in\n-     the GUI by going to the `Send` tab in the multisig wallet and creating an unsigned transaction (PSBT)\n-  6. At least `M` users check the PSBT with `decodepsbt` and (if OK) signs it with `walletprocesspsbt`. It is simple to do\n-     this in the GUI by Loading the PSBT from file and signing it\n-  7. The signed PSBTs are collected with `combinepsbt`, finalized w/ `finalizepsbt`, and\n-     then the resulting transaction is broadcasted to the network\n-  8. Checks that balances are correct after the transaction has been included in a block\n+  5. A sending transaction from the multisig is created using `walletcreatefundedpsbt` (anyone can initiate this). It is simple to do\n+     this in the GUI by going to the `Send` tab in the multisig wallet and creating an unsigned transaction (PSBT)\n+  6. At least `M` participants check the PSBT with their multisig using `decodepsbt` to verify the transaction is OK before signing it.\n+  7. (If OK) the participant signs the PSBT with their signer wallet using `walletprocesspsbt`. It is simple to do this in the GUI by\n+     loading the PSBT from file and signing it\n+  8. The signed PSBTs are collected with `combinepsbt`, finalized w/ `finalizepsbt`, and then the resulting transaction is broadcasted\n+     to the network. Note that any wallet (eg one of the signers or multisig) is capable of doing this.\n+  9. Checks that balances are correct after the transaction has been included in a block\n \n You may prefer a daisy chained signing flow where each participant signs the PSBT one after another until\n the PSBT has been signed `M` times and is \"complete.\" For the most part, the steps above remain the same, except (6, 7)"
      },
      {
        "sha": "68c206b0382d16864b5837c243a9233cbc0b45a0",
        "filename": "test/functional/wallet_multisig_descriptor_psbt.py",
        "status": "modified",
        "additions": 47,
        "deletions": 43,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9479e4626f6b5126ff8cdab3a7e718c609429ef/test/functional/wallet_multisig_descriptor_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9479e4626f6b5126ff8cdab3a7e718c609429ef/test/functional/wallet_multisig_descriptor_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multisig_descriptor_psbt.py?ref=f9479e4626f6b5126ff8cdab3a7e718c609429ef",
        "patch": "@@ -26,13 +26,15 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n         self.skip_if_no_sqlite()\n \n-    def _get_xpub(self, wallet):\n+    @staticmethod\n+    def _get_xpub(wallet):\n         \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n         descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh\"), wallet.listdescriptors()[\"descriptors\"]))\n         return descriptor[\"desc\"].split(\"]\")[-1].split(\"/\")[0]\n \n-    def _check_psbt(self, psbt, to, value, multisig):\n-        \"\"\"Helper method for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n         tx = multisig.decodepsbt(psbt)[\"tx\"]\n         amount = 0\n         for vout in tx[\"vout\"]:\n@@ -42,25 +44,19 @@ def _check_psbt(self, psbt, to, value, multisig):\n                 amount += vout[\"value\"]\n         assert_approx(amount, float(value), vspan=0.001)\n \n-    def generate_and_exchange_xpubs(self, participants):\n-        \"\"\"Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet. Avoid reusing this wallet for any other purpose..\"\"\"\n-        for i, node in enumerate(participants):\n-            node.createwallet(wallet_name=f\"participant_{i}\", descriptors=True)\n-            yield self._get_xpub(node.get_wallet_rpc(f\"participant_{i}\"))\n-\n-    def participants_import_descriptors(self, participants, xpubs):\n+    def participants_create_multisigs(self, xpubs):\n         \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n         # some simple validation\n         assert_equal(len(xpubs), self.N)\n         # a sanity-check/assertion, this will throw if the base58 checksum of any of the provided xpubs are invalid\n         for xpub in xpubs:\n             base58_to_byte(xpub)\n \n-        for i, node in enumerate(participants):\n+        for i, node in enumerate(self.nodes):\n             node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n             multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n-            external = multisig.getdescriptorinfo(f\"wsh(sortedmulti({self.M},{f'/{0}/*,'.join(xpubs)}/{0}/*))\")\n-            internal = multisig.getdescriptorinfo(f\"wsh(sortedmulti({self.M},{f'/{1}/*,'.join(xpubs)}/{1}/*))\")\n+            external = multisig.getdescriptorinfo(f\"wsh(sortedmulti({self.M},{f'/0/*,'.join(xpubs)}/0/*))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(sortedmulti({self.M},{f'/1/*,'.join(xpubs)}/1/*))\")\n             result = multisig.importdescriptors([\n                 {  # receiving addresses (internal: False)\n                     \"desc\": external[\"descriptor\"],\n@@ -76,73 +72,81 @@ def participants_import_descriptors(self, participants, xpubs):\n                 },\n             ])\n             assert all(r[\"success\"] for r in result)\n-\n-    def get_multisig_receiving_address(self):\n-        \"\"\"We will send funds to the resulting address (every participant should get the same addresses).\"\"\"\n-        multisig = self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\")\n-        receiving_address = multisig.getnewaddress()\n-        for i in range(1, self.N):\n-            assert_equal(receiving_address, self.nodes[i].get_wallet_rpc(f\"{self.name}_{i}\").getnewaddress())\n-        return receiving_address\n-\n-    def make_sending_transaction(self, to, value):\n-        \"\"\"Make a sending transaction, created using walletcreatefundedpsbt (anyone can initiate this).\"\"\"\n-        return self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").walletcreatefundedpsbt(inputs=[], outputs={to: value}, options={\"feeRate\": 0.00010})\n+            yield multisig\n \n     def run_test(self):\n         self.M = 2\n         self.N = self.num_nodes\n         self.name = f\"{self.M}_of_{self.N}_multisig\"\n         self.log.info(f\"Testing {self.name}...\")\n \n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this justs highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n         self.log.info(\"Generate and exchange xpubs...\")\n-        xpubs = list(self.generate_and_exchange_xpubs(self.nodes))\n+        xpubs = [self._get_xpub(signer) for signer in participants[\"signers\"]]\n \n         self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n-        self.participants_import_descriptors(self.nodes, xpubs)\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n \n         self.log.info(\"Get a mature utxo to send to the multisig...\")\n-        coordinator_wallet = self.nodes[0].get_wallet_rpc(f\"participant_{0}\")\n+        coordinator_wallet = participants[\"signers\"][0]\n         coordinator_wallet.generatetoaddress(101, coordinator_wallet.getnewaddress())\n \n         deposit_amount = 6.15\n-        multisig_receiving_address = self.get_multisig_receiving_address()\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n         self.log.info(\"Send funds to the resulting multisig receiving address...\")\n         coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        for n in range(self.N):\n-            assert_approx(self.nodes[n].get_wallet_rpc(f\"{self.name}_{n}\").getbalance(), deposit_amount, vspan=0.001)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n \n         self.log.info(\"Send a transaction from the multisig!\")\n-        to = self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getnewaddress()\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n         value = 1\n-        psbt = self.make_sending_transaction(to, value)\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, options={\"feeRate\": 0.00010})\n \n         psbts = []\n-        self.log.info(\"At least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n         for m in range(self.M):\n-            signers_multisig = self.nodes[m].get_wallet_rpc(f\"{self.name}_{m}\")\n+            signers_multisig = participants[\"multisigs\"][m]\n             self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n-            signing_wallet = self.nodes[m].get_wallet_rpc(f\"participant_{m}\")\n+            signing_wallet = participants[\"signers\"][m]\n             partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n             psbts.append(partially_signed_psbt[\"psbt\"])\n \n-        self.log.info(\"Collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n         combined = coordinator_wallet.combinepsbt(psbts)\n         finalized = coordinator_wallet.finalizepsbt(combined)\n         coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n \n         self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        assert_approx(self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").getbalance(), deposit_amount - value, vspan=0.001)\n-        assert_equal(self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getbalance(), value)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n \n         self.log.info(\"Send another transaction from the multisig, this time with a daisy chained signing flow (one after another in series)!\")\n-        psbt = self.make_sending_transaction(to, value)\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, options={\"feeRate\": 0.00010})\n         for m in range(self.M):\n-            signing_wallet = self.nodes[m].get_wallet_rpc(f\"participant_{m}\")\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n             psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n             assert_equal(psbt[\"complete\"], m == self.M - 1)\n         finalized = coordinator_wallet.finalizepsbt(psbt[\"psbt\"])\n@@ -151,8 +155,8 @@ def run_test(self):\n         self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        assert_approx(self.nodes[0].get_wallet_rpc(f\"{self.name}_{0}\").getbalance(), deposit_amount - (value * 2), vspan=0.001)\n-        assert_equal(self.nodes[self.N - 1].get_wallet_rpc(f\"participant_{self.N - 1}\").getbalance(), value * 2)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - (value * 2), vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value * 2)\n \n \n if __name__ == \"__main__\":"
      }
    ]
  },
  {
    "sha": "9de0d94508828f5fdfaf688ccda5a91d38b32c58",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZGUwZDk0NTA4ODI4ZjVmZGZhZjY4OGNjZGE1YTkxZDM4YjMyYzU4",
    "commit": {
      "author": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-09-03T18:42:05Z"
      },
      "committer": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2021-09-03T18:49:03Z"
      },
      "message": "doc: add disclaimer highlighting shortcomings of the basic multisig example",
      "tree": {
        "sha": "92b538bae360f85600034f5a11eaa7862c347c6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92b538bae360f85600034f5a11eaa7862c347c6d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9de0d94508828f5fdfaf688ccda5a91d38b32c58",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENKwpEUV32QrrIOeYc3/VzfHRRrkFAmEybh8ACgkQc3/VzfHR\nRrlvKw//f0qrRH8YcKFjOhT4aiRPAMl6KulJ64cQWi8N7YATAq6CB8/OVhCDCwtc\nTsx2FdaqyK6Lj9yma2If5R6tMAx5gHfzTubpzXNvY/ek/fAXRpTEhDao3KNQBhxD\nPHaOOcpQA60FMP0LhWf28W/xnqz3ckS4ixZFbckxoD3aIP4davADcn2eU6Lcwk++\nnQ/eiseP/NTfqfPj9ZFqs8SgWXQhjj8GED6pBZNb6ZTW+fap4eFlvUufyK8itIkg\no0WZySR8Pcwy3fejrf8WgMYNaJsQZl/yw3YGRjWlDx839yxXtsxge6GGp25LM6ll\ndjyQnz7nFIBKqBNTzouywMXskOxVF4zj9MZz8XJGVKR4sjmslyreoPnH9EXXqT1n\nEdlS4qT+JQ7dUNyhnGBtC2rLFzy1sSvyVobh9qdnYzclAyDq/6Qsv+VDFEGQYVeT\nuDuYVTLLE0j4/lbd1V7FffDoH1t5YAgGhC8bWiRlQkdo2zSWXwB4yxVs5QpVaJYK\n6cf8LH8N6y17GKaQ4l3gHuv3NzlkMKFG866Ddmg/yO5/C3k1JDYwl8B8/GgfVDUy\njvECTAwGdCNBCOVzQ8nOt56HtLtlbWG3f2HJS/uv2q47xW4qMas1c8mReuMPJPS+\neR59yH14kXTrHLDXSqArZs7PxOBWCa6IpCAza/NOKUsgCC7r1tw=\n=Xng3\n-----END PGP SIGNATURE-----",
        "payload": "tree 92b538bae360f85600034f5a11eaa7862c347c6d\nparent f9479e4626f6b5126ff8cdab3a7e718c609429ef\nauthor Michael Dietz <michael.dietz@waya.ai> 1630694525 -0500\ncommitter Michael Dietz <michael.dietz@waya.ai> 1630694943 -0500\n\ndoc: add disclaimer highlighting shortcomings of the basic multisig example\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9de0d94508828f5fdfaf688ccda5a91d38b32c58",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9de0d94508828f5fdfaf688ccda5a91d38b32c58",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9de0d94508828f5fdfaf688ccda5a91d38b32c58/comments",
    "author": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following{/other_user}",
      "gists_url": "https://api.github.com/users/mjdietzx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mjdietzx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9479e4626f6b5126ff8cdab3a7e718c609429ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9479e4626f6b5126ff8cdab3a7e718c609429ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9479e4626f6b5126ff8cdab3a7e718c609429ef"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 8,
      "deletions": 0
    },
    "files": [
      {
        "sha": "70d0926a1bc930d48403e2952f21228828c454b3",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9de0d94508828f5fdfaf688ccda5a91d38b32c58/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9de0d94508828f5fdfaf688ccda5a91d38b32c58/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=9de0d94508828f5fdfaf688ccda5a91d38b32c58",
        "patch": "@@ -143,6 +143,14 @@ are lexicographically ordered as described in BIP67.\n \n For a good example of a basic M-of-N multisig between multiple participants using descriptor\n wallets and PSBTs, as well as a signing flow, see [this functional test](/test/functional/wallet_multisig_descriptor_psbt.py).\n+\n+Disclaimers: It is important to note that this example serves as a quick-start and is kept basic for readability. A downside of the approach\n+outlined here is that each participant must maintain (and backup) two separate wallets: a signer and the corresponding multisig.\n+It should also be noted that privacy best-practices are not \"by default\" here - participants should take care to only use the signer to sign\n+transactions related to the multisig. Lastly, it is not recommended to use anything other than a Bitcoin Core descriptor wallet to serve as your\n+signer(s). Other wallets, whether hardware or software, likely impose additional checks and safeguards to prevent users from signing transactions that\n+could lead to loss of funds, or are deemed security hazards. Conforming to various 3rd-party checks and verifications is not in the scope of this example.\n+\n The basic steps are:\n \n   1. Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet which we will refer to as"
      }
    ]
  }
]