[
  {
    "sha": "086ee67d839b33bf475177f680fcc848a0625266",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowODZlZTY3ZDgzOWIzM2JmNDc1MTc3ZjY4MGZjYzg0OGEwNjI1MjY2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-27T12:20:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-28T17:53:55Z"
      },
      "message": "Switch to a more efficient rolling Bloom filter\n\nFor each 'bit' in the filter we really maintain 2 bits, which store either:\n0: not set\n1-3: set in generation N\n\nAfter (nElements / 2) insertions, we switch to a new generation, and wipe\nentries which already had the new generation number, effectively switching\nfrom the last 1.5 * nElements set to the last 1.0 * nElements set.\n\nThis is 25% more space efficient than the previous implementation, and can\n(at peak) store 1.5 times the requested amount of history (though only\n1.0 times the requested history is guaranteed).\n\nThe existing unit tests should be sufficient.",
      "tree": {
        "sha": "068fc2942de60c7c058652bc1d57d99f74908e25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/068fc2942de60c7c058652bc1d57d99f74908e25"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/086ee67d839b33bf475177f680fcc848a0625266",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/086ee67d839b33bf475177f680fcc848a0625266",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/086ee67d839b33bf475177f680fcc848a0625266",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/086ee67d839b33bf475177f680fcc848a0625266/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "92aa7311d64cb1a0109d63d6bf7406c119bf94cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92aa7311d64cb1a0109d63d6bf7406c119bf94cd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/92aa7311d64cb1a0109d63d6bf7406c119bf94cd"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 75,
      "deletions": 30
    },
    "files": [
      {
        "sha": "4bda2bbce42b7899ec84f2ad5dc214656510cf5b",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 24,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086ee67d839b33bf475177f680fcc848a0625266/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086ee67d839b33bf475177f680fcc848a0625266/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=086ee67d839b33bf475177f680fcc848a0625266",
        "patch": "@@ -216,30 +216,54 @@ void CBloomFilter::UpdateEmptyFull()\n     isEmpty = empty;\n }\n \n-CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate) :\n-    b1(nElements * 2, fpRate, 0), b2(nElements * 2, fpRate, 0)\n+CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate)\n {\n-    // Implemented using two bloom filters of 2 * nElements each.\n-    // We fill them up, and clear them, staggered, every nElements\n-    // inserted, so at least one always contains the last nElements\n-    // inserted.\n-    nInsertions = 0;\n-    nBloomSize = nElements * 2;\n-\n+    double logFpRate = log(fpRate);\n+    /* The optimal number of hash functions is log(fpRate) / log(0.5), but\n+     * restrict it to the range 1-50. */\n+    nHashFuncs = std::max(1, std::min((int)round(logFpRate / log(0.5)), 50));\n+    /* In this rolling bloom filter, we'll store between 2 and 3 generations of nElements / 2 entries. */\n+    nEntriesPerGeneration = (nElements + 1) / 2;\n+    uint32_t nMaxElements = nEntriesPerGeneration * 3;\n+    /* The maximum fpRate = pow(1.0 - exp(-nHashFuncs * nMaxElements / nFilterBits), nHashFuncs)\n+     * =>          pow(fpRate, 1.0 / nHashFuncs) = 1.0 - exp(-nHashFuncs * nMaxElements / nFilterBits)\n+     * =>          1.0 - pow(fpRate, 1.0 / nHashFuncs) = exp(-nHashFuncs * nMaxElements / nFilterBits)\n+     * =>          log(1.0 - pow(fpRate, 1.0 / nHashFuncs)) = -nHashFuncs * nMaxElements / nFilterBits\n+     * =>          nFilterBits = -nHashFuncs * nMaxElements / log(1.0 - pow(fpRate, 1.0 / nHashFuncs))\n+     * =>          nFilterBits = -nHashFuncs * nMaxElements / log(1.0 - exp(logFpRate / nHashFuncs))\n+     */\n+    uint32_t nFilterBits = (uint32_t)ceil(-1.0 * nHashFuncs * nMaxElements / log(1.0 - exp(logFpRate / nHashFuncs)));\n+    data.clear();\n+    /* We store up to 16 'bits' per data element. */\n+    data.resize((nFilterBits + 15) / 16);\n     reset();\n }\n \n+/* Similar to CBloomFilter::Hash */\n+inline unsigned int CRollingBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const {\n+    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (data.size() * 16);\n+}\n+\n void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n {\n-    if (nInsertions == 0) {\n-        b1.clear();\n-    } else if (nInsertions == nBloomSize / 2) {\n-        b2.clear();\n+    if (nEntriesThisGeneration == nEntriesPerGeneration) {\n+        nEntriesThisGeneration = 0;\n+        nGeneration++;\n+        if (nGeneration == 4) {\n+            nGeneration = 1;\n+        }\n+        /* Wipe old entries that used this generation number. */\n+        for (uint32_t p = 0; p < data.size() * 16; p++) {\n+            if (get(p) == nGeneration) {\n+                put(p, 0);\n+            }\n+        }\n     }\n-    b1.insert(vKey);\n-    b2.insert(vKey);\n-    if (++nInsertions == nBloomSize) {\n-        nInsertions = 0;\n+    nEntriesThisGeneration++;\n+\n+    for (int n = 0; n < nHashFuncs; n++) {\n+        uint32_t h = Hash(n, vKey);\n+        put(h, nGeneration);\n     }\n }\n \n@@ -251,10 +275,13 @@ void CRollingBloomFilter::insert(const uint256& hash)\n \n bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n {\n-    if (nInsertions < nBloomSize / 2) {\n-        return b2.contains(vKey);\n+    for (int n = 0; n < nHashFuncs; n++) {\n+        uint32_t h = Hash(n, vKey);\n+        if (get(h) == 0) {\n+            return false;\n+        }\n     }\n-    return b1.contains(vKey);\n+    return true;\n }\n \n bool CRollingBloomFilter::contains(const uint256& hash) const\n@@ -265,8 +292,10 @@ bool CRollingBloomFilter::contains(const uint256& hash) const\n \n void CRollingBloomFilter::reset()\n {\n-    unsigned int nNewTweak = GetRand(std::numeric_limits<unsigned int>::max());\n-    b1.reset(nNewTweak);\n-    b2.reset(nNewTweak);\n-    nInsertions = 0;\n+    nTweak = GetRand(std::numeric_limits<unsigned int>::max());\n+    nEntriesThisGeneration = 0;\n+    nGeneration = 1;\n+    for (std::vector<uint32_t>::iterator it = data.begin(); it != data.end(); it++) {\n+        *it = 0;\n+    }\n }"
      },
      {
        "sha": "98cfbdb833f382b236b59cc8e87797690fe61b93",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 21,
        "deletions": 5,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086ee67d839b33bf475177f680fcc848a0625266/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086ee67d839b33bf475177f680fcc848a0625266/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=086ee67d839b33bf475177f680fcc848a0625266",
        "patch": "@@ -110,8 +110,11 @@ class CBloomFilter\n  * reset() is provided, which also changes nTweak to decrease the impact of\n  * false-positives.\n  *\n- * contains(item) will always return true if item was one of the last N things\n+ * contains(item) will always return true if item was one of the last N to 1.5*N\n  * insert()'ed ... but may also return true for items that were not inserted.\n+ *\n+ * It needs around 1.8 bytes per element per factor 0.1 of false positive rate.\n+ * (More accurately: 3/(log(256)*log(2)) * log(1/fpRate) * nElements bytes)\n  */\n class CRollingBloomFilter\n {\n@@ -129,10 +132,23 @@ class CRollingBloomFilter\n     void reset();\n \n private:\n-    unsigned int nBloomSize;\n-    unsigned int nInsertions;\n-    CBloomFilter b1, b2;\n-};\n+    int nEntriesPerGeneration;\n+    int nEntriesThisGeneration;\n+    int nGeneration;\n+    std::vector<uint32_t> data;\n+    unsigned int nTweak;\n+    int nHashFuncs;\n+\n+    unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n+    inline int get(uint32_t position) const {\n+        return (data[(position >> 4) % data.size()] >> (2 * (position & 0xF))) & 0x3;\n+    }\n+\n+    inline void put(uint32_t position, uint32_t val) {\n+        uint32_t& cell = data[(position >> 4) % data.size()];\n+        cell = (cell & ~(((uint32_t)3) << (2 * (position & 0xF)))) | (val << (2 * (position & 0xF)));\n+    }\n+};\n \n #endif // BITCOIN_BLOOM_H"
      },
      {
        "sha": "422b1e7843e965bdae6cd7d10061d74840a924bd",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086ee67d839b33bf475177f680fcc848a0625266/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086ee67d839b33bf475177f680fcc848a0625266/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=086ee67d839b33bf475177f680fcc848a0625266",
        "patch": "@@ -180,7 +180,7 @@ namespace {\n      * million to make it highly unlikely for users to have issues with this\n      * filter.\n      *\n-     * Memory used: 1.7MB\n+     * Memory used: 1.3 MB\n      */\n     boost::scoped_ptr<CRollingBloomFilter> recentRejects;\n     uint256 hashRecentRejectsChainTip;"
      }
    ]
  }
]