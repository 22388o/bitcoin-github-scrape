[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898950491",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-898950491",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 898950491,
    "node_id": "IC_kwDOABII5841lOVb",
    "user": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?u=65406da0f40524c00b8b647f916d31cbbb449edb&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-14T19:38:48Z",
    "updated_at": "2021-08-14T19:38:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "Concept ACK.\n\nWe have to implement crypto ourselves to keep the surface area small and avoid bringing in large dependencies. Differential fuzzing against a reference implementation is a great addition to testing the reference test vectors.\n\nThank you for your work, and welcome to Bitcoin Core!",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898950491/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 2,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898989809",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-898989809",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 898989809,
    "node_id": "IC_kwDOABII5841lX7x",
    "user": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?u=a0e0040aacd7d4f0787481e8ac30b494fa429e11&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-15T03:28:16Z",
    "updated_at": "2021-08-15T03:28:16Z",
    "author_association": "MEMBER",
    "body": "@agroce / @guidovranken this may also interest you.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898989809/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898991078",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-898991078",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 898991078,
    "node_id": "IC_kwDOABII5841lYPm",
    "user": {
      "login": "guidovranken",
      "id": 6846644,
      "node_id": "MDQ6VXNlcjY4NDY2NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6846644?u=793163cde3e2d0e5b555347824f8c01236f3c22f&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/guidovranken",
      "html_url": "https://github.com/guidovranken",
      "followers_url": "https://api.github.com/users/guidovranken/followers",
      "following_url": "https://api.github.com/users/guidovranken/following{/other_user}",
      "gists_url": "https://api.github.com/users/guidovranken/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/guidovranken/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/guidovranken/subscriptions",
      "organizations_url": "https://api.github.com/users/guidovranken/orgs",
      "repos_url": "https://api.github.com/users/guidovranken/repos",
      "events_url": "https://api.github.com/users/guidovranken/events{/privacy}",
      "received_events_url": "https://api.github.com/users/guidovranken/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-15T03:48:35Z",
    "updated_at": "2021-08-15T03:48:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "Essentially this is already done by Cryptofuzz which compares it against the Botan implementation, and is running on OSS-Fuzz in the bitcoin-core project\r\n\r\nhttps://github.com/guidovranken/cryptofuzz/blob/6dddb6bb97a2cd8d7bf915bca00d0411ccf5e1c0/modules/bitcoin/module.cpp#L417-L420",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898991078/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902156184",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902156184",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 902156184,
    "node_id": "IC_kwDOABII5841xc-Y",
    "user": {
      "login": "stratospher",
      "id": 44024636,
      "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/44024636?u=4cfd5362861d6cb4fb970eaa3b0bc20af7abd837&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stratospher",
      "html_url": "https://github.com/stratospher",
      "followers_url": "https://api.github.com/users/stratospher/followers",
      "following_url": "https://api.github.com/users/stratospher/following{/other_user}",
      "gists_url": "https://api.github.com/users/stratospher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
      "organizations_url": "https://api.github.com/users/stratospher/orgs",
      "repos_url": "https://api.github.com/users/stratospher/repos",
      "events_url": "https://api.github.com/users/stratospher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stratospher/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-19T18:48:32Z",
    "updated_at": "2021-08-19T18:48:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "Oh..I wasn't aware of the differential fuzzing for Bitcoin Core cryptographic libraries being done in Cryptofuzz. Crypofuzz is an incredible project! Could you please elaborate more on where the comparison with Botan implementation is happening?\r\n\r\nWould there be incremental value in fuzzing against D.J. Bernstein's reference implementation? And including the Keystream() function too in the Bitcoin Core/Cryptofuzz diferential fuzz tests?",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902156184/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902164938",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902164938",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 902164938,
    "node_id": "IC_kwDOABII5841xfHK",
    "user": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?u=0691974eedcc2ab5366cc1080fb1c030e87244c2&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-19T19:02:11Z",
    "updated_at": "2021-08-19T19:02:11Z",
    "author_association": "MEMBER",
    "body": "btw, I don't mind adding the fuzz test here, even if it is redundant with oss-fuzz. Oss-fuzz is just one fuzzing providre, but I also run my own fuzzing servers to not put all eggs into one basket. I am sure others are running the Bitcoin Core fuzz target, too.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902164938/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902167984",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902167984",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 902167984,
    "node_id": "IC_kwDOABII5841xf2w",
    "user": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?u=65406da0f40524c00b8b647f916d31cbbb449edb&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-19T19:06:03Z",
    "updated_at": "2021-08-19T19:06:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "+1 for what @MarcoFalke said. It'd be nice to be able to run this along with other fuzz targets on personal machines.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902167984/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902254545",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902254545",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 902254545,
    "node_id": "IC_kwDOABII5841x0_R",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?u=5ff13e375b40ea55ecd3c108337dd6a23f68eddf&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-19T21:18:17Z",
    "updated_at": "2021-08-19T21:18:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "Concept ACK for the reasons @MarcoFalke mentioned",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902254545/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902296051",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902296051",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 902296051,
    "node_id": "IC_kwDOABII5841x_Hz",
    "user": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?u=e15de0869a62036529220016b1729fa1a6c18b5b&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-19T22:34:39Z",
    "updated_at": "2021-08-19T22:34:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "There are fuzzers (e.g. https://github.com/bitcoin/bitcoin/pull/22585) not available via OSS-Fuzz, also.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902296051/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942945385",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-942945385",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 942945385,
    "node_id": "IC_kwDOABII5844NDRp",
    "user": {
      "login": "stratospher",
      "id": 44024636,
      "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/44024636?u=4cfd5362861d6cb4fb970eaa3b0bc20af7abd837&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stratospher",
      "html_url": "https://github.com/stratospher",
      "followers_url": "https://api.github.com/users/stratospher/followers",
      "following_url": "https://api.github.com/users/stratospher/following{/other_user}",
      "gists_url": "https://api.github.com/users/stratospher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
      "organizations_url": "https://api.github.com/users/stratospher/orgs",
      "repos_url": "https://api.github.com/users/stratospher/repos",
      "events_url": "https://api.github.com/users/stratospher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stratospher/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-14T04:52:49Z",
    "updated_at": "2021-10-14T04:52:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "Added `LIMITED_WHILE` and updated `ConsumeIntegralInRange()` to `ConsumeBool()` as per discussion in [comments](https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692403396).\r\nReady for further review.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942945385/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/948773721",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-948773721",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
    "id": 948773721,
    "node_id": "IC_kwDOABII5844jSNZ",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-21T16:20:31Z",
    "updated_at": "2021-11-06T00:58:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23441](https://github.com/bitcoin/bitcoin/pull/23441) (fuzz: Differential fuzzing for ChaCha20Forward4064-Poly1305@bitcoin cipher suite by stratospher)\n* [#23322](https://github.com/bitcoin/bitcoin/pull/23322) ([Fuzz] Poly1305 differential fuzzing against Floodyberry's implementation by prakash1512)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/948773721/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692403396",
    "pull_request_review_id": 734359834,
    "id": 692403396,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjQwMzM5Ng==",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": null,
    "original_position": 292,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "a63773439302f2cdef81e36c705bfd59046f6fa0",
    "user": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "how is this different from\r\n\r\n```suggestion\r\n    while (fuzzed_data_provider.ConsumeBool()) {\r\n```\r\n\r\nAlso, could use `LIMITED_WHILE` to avoid unlimited runtime.",
    "created_at": "2021-08-19T18:59:42Z",
    "updated_at": "2021-08-19T19:00:01Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692403396",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692403396"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692403396"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692403396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 292,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692702350",
    "pull_request_review_id": 734714644,
    "id": 692702350,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjcwMjM1MA==",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": null,
    "original_position": 292,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "a63773439302f2cdef81e36c705bfd59046f6fa0",
    "user": {
      "login": "prakash1512",
      "id": 44579179,
      "node_id": "MDQ6VXNlcjQ0NTc5MTc5",
      "avatar_url": "https://avatars.githubusercontent.com/u/44579179?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prakash1512",
      "html_url": "https://github.com/prakash1512",
      "followers_url": "https://api.github.com/users/prakash1512/followers",
      "following_url": "https://api.github.com/users/prakash1512/following{/other_user}",
      "gists_url": "https://api.github.com/users/prakash1512/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prakash1512/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prakash1512/subscriptions",
      "organizations_url": "https://api.github.com/users/prakash1512/orgs",
      "repos_url": "https://api.github.com/users/prakash1512/repos",
      "events_url": "https://api.github.com/users/prakash1512/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prakash1512/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> how is this different from\r\n\r\nIncreased the probability of entering the while loop as `ConsumeBool()` has only 50% chance of returning true while `ConsumeIntegralInRange<uint32_t>(0,100) >= 10` will have 90% chance of returning true.\r\nEssentially we\u2019re trying to get the test running longer for each fuzz seed so multiple functions are exercised per seed, especially since `ChaCha20` maintains an internal state for each seed.",
    "created_at": "2021-08-20T06:37:07Z",
    "updated_at": "2021-08-20T06:37:07Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692702350",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692702350"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692702350"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692702350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 292,
    "side": "RIGHT",
    "in_reply_to_id": 692403396
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692712329",
    "pull_request_review_id": 734726510,
    "id": 692712329,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjcxMjMyOQ==",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": null,
    "original_position": 292,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "a63773439302f2cdef81e36c705bfd59046f6fa0",
    "user": {
      "login": "stratospher",
      "id": 44024636,
      "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stratospher",
      "html_url": "https://github.com/stratospher",
      "followers_url": "https://api.github.com/users/stratospher/followers",
      "following_url": "https://api.github.com/users/stratospher/following{/other_user}",
      "gists_url": "https://api.github.com/users/stratospher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
      "organizations_url": "https://api.github.com/users/stratospher/orgs",
      "repos_url": "https://api.github.com/users/stratospher/repos",
      "events_url": "https://api.github.com/users/stratospher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stratospher/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> Also, could use `LIMITED_WHILE` to avoid unlimited runtime.\r\n\r\nGreat suggestion! Added `LIMITED_WHILE`.",
    "created_at": "2021-08-20T06:57:02Z",
    "updated_at": "2021-08-20T06:57:02Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692712329",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692712329"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692712329"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692712329/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 292,
    "side": "RIGHT",
    "in_reply_to_id": 692403396
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692735180",
    "pull_request_review_id": 734755634,
    "id": 692735180,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjczNTE4MA==",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": null,
    "original_position": 292,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "a63773439302f2cdef81e36c705bfd59046f6fa0",
    "user": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> Essentially we\u2019re trying to get the test running longer\r\n\r\nDo you have data to support that claim? Fuzzing engines will store inputs that increase coverage data and once the data is stored, for replay it doesn't matter whether it was `ConsumeBool` or `ConsumeIntegralInRange` that evaluated to true.",
    "created_at": "2021-08-20T07:38:43Z",
    "updated_at": "2021-08-20T07:38:43Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692735180",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692735180"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692735180"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692735180/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 292,
    "side": "RIGHT",
    "in_reply_to_id": 692403396
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693226653",
    "pull_request_review_id": 735396200,
    "id": 693226653,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIyNjY1Mw==",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": null,
    "original_position": 292,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "a63773439302f2cdef81e36c705bfd59046f6fa0",
    "user": {
      "login": "prakash1512",
      "id": 44579179,
      "node_id": "MDQ6VXNlcjQ0NTc5MTc5",
      "avatar_url": "https://avatars.githubusercontent.com/u/44579179?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prakash1512",
      "html_url": "https://github.com/prakash1512",
      "followers_url": "https://api.github.com/users/prakash1512/followers",
      "following_url": "https://api.github.com/users/prakash1512/following{/other_user}",
      "gists_url": "https://api.github.com/users/prakash1512/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prakash1512/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prakash1512/subscriptions",
      "organizations_url": "https://api.github.com/users/prakash1512/orgs",
      "repos_url": "https://api.github.com/users/prakash1512/repos",
      "events_url": "https://api.github.com/users/prakash1512/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prakash1512/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> Do you have data to support that claim?\r\n\r\nBacking the claim with data was indeed a great suggestion, so we generated the data and plots to verify it.\r\nNow we have results to dismiss that claim :)\r\nSharing our findings here:\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/863100385152335883/878387475096170607/unknown.png\"\r\n\ttitle=\"Plot\" width=\"500\" height=\"300\" />\r\n`x-axis denotes no of iterations`\r\n`y-axis denotes frequency of each iteration`",
    "created_at": "2021-08-20T21:25:22Z",
    "updated_at": "2021-08-20T21:25:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r693226653",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693226653"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r693226653"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693226653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 292,
    "side": "RIGHT",
    "in_reply_to_id": 692403396
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757817842",
    "pull_request_review_id": 817158428,
    "id": 757817842,
    "node_id": "PRRC_kwDOABII584tK2Hy",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": 45,
    "original_position": 45,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "user": {
      "login": "siv2r",
      "id": 56887198,
      "node_id": "MDQ6VXNlcjU2ODg3MTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/siv2r",
      "html_url": "https://github.com/siv2r",
      "followers_url": "https://api.github.com/users/siv2r/followers",
      "following_url": "https://api.github.com/users/siv2r/following{/other_user}",
      "gists_url": "https://api.github.com/users/siv2r/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
      "organizations_url": "https://api.github.com/users/siv2r/orgs",
      "repos_url": "https://api.github.com/users/siv2r/repos",
      "events_url": "https://api.github.com/users/siv2r/events{/privacy}",
      "received_events_url": "https://api.github.com/users/siv2r/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit: it might be useful to add the definition of `ENCRYPT_ctx` in the comments.\r\n```\r\n/* \r\n * ECRYPT_ctx is the structure containing the representation of the\r\n * internal state of your cipher. \r\n */\r\n```",
    "created_at": "2021-11-27T20:34:03Z",
    "updated_at": "2021-11-27T22:28:25Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757817842",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757817842"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757817842"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757817842/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 45,
    "original_line": 45,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818204",
    "pull_request_review_id": 817158428,
    "id": 757818204,
    "node_id": "PRRC_kwDOABII584tK2Nc",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": 97,
    "original_position": 97,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "user": {
      "login": "siv2r",
      "id": 56887198,
      "node_id": "MDQ6VXNlcjU2ODg3MTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/siv2r",
      "html_url": "https://github.com/siv2r",
      "followers_url": "https://api.github.com/users/siv2r/followers",
      "following_url": "https://api.github.com/users/siv2r/following{/other_user}",
      "gists_url": "https://api.github.com/users/siv2r/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
      "organizations_url": "https://api.github.com/users/siv2r/orgs",
      "repos_url": "https://api.github.com/users/siv2r/repos",
      "events_url": "https://api.github.com/users/siv2r/events{/privacy}",
      "received_events_url": "https://api.github.com/users/siv2r/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "```suggestion\r\nstatic const char sigma[16] = \"expand 32-byte k\";\r\nstatic const char tau[16] = \"expand 16-byte k\";\r\n```",
    "created_at": "2021-11-27T20:50:53Z",
    "updated_at": "2021-11-27T22:28:25Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818204",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818204"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818204"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818204/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 96,
    "original_start_line": 96,
    "start_side": "RIGHT",
    "line": 97,
    "original_line": 97,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818918",
    "pull_request_review_id": 817158428,
    "id": 757818918,
    "node_id": "PRRC_kwDOABII584tK2Ym",
    "diff_hunk": "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);",
    "path": "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
    "position": 94,
    "original_position": 94,
    "commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "original_commit_id": "258d751c1c0363a880889275b4c567118b779ba1",
    "user": {
      "login": "siv2r",
      "id": 56887198,
      "node_id": "MDQ6VXNlcjU2ODg3MTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/siv2r",
      "html_url": "https://github.com/siv2r",
      "followers_url": "https://api.github.com/users/siv2r/followers",
      "following_url": "https://api.github.com/users/siv2r/following{/other_user}",
      "gists_url": "https://api.github.com/users/siv2r/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
      "organizations_url": "https://api.github.com/users/siv2r/orgs",
      "repos_url": "https://api.github.com/users/siv2r/repos",
      "events_url": "https://api.github.com/users/siv2r/events{/privacy}",
      "received_events_url": "https://api.github.com/users/siv2r/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "```suggestion\r\n    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\r\n    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\r\n    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\r\n    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\r\n```\r\nnit: this pattern of defining the `QUATERROUND` macro is following in many places ([chacha20.cpp](https://github.com/bitcoin/bitcoin/blob/master/src/crypto/chacha20.cpp#L15)).",
    "created_at": "2021-11-27T22:20:17Z",
    "updated_at": "2021-11-27T22:28:25Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818918",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818918"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818918"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818918/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 87,
    "original_start_line": 87,
    "start_side": "RIGHT",
    "line": 94,
    "original_line": 94,
    "side": "RIGHT"
  }
]