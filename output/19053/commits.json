[
  {
    "sha": "8b3136bd307123a255b9166aa42a497a44bcce70",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjMxMzZiZDMwNzEyM2EyNTViOTE2NmFhNDJhNDk3YTQ0YmNjZTcw",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2020-05-22T15:52:08Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2020-06-01T23:42:55Z"
      },
      "message": "refactor: replace CNode pointers by references within net_processing.{h,cpp}",
      "tree": {
        "sha": "b7906b33b5566177d851675719932f8c4c6729cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7906b33b5566177d851675719932f8c4c6729cc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b3136bd307123a255b9166aa42a497a44bcce70",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b3136bd307123a255b9166aa42a497a44bcce70",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b3136bd307123a255b9166aa42a497a44bcce70",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b3136bd307123a255b9166aa42a497a44bcce70/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9bc7751cadbd038faf8ac1d62cda23fcf00d4cc2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bc7751cadbd038faf8ac1d62cda23fcf00d4cc2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9bc7751cadbd038faf8ac1d62cda23fcf00d4cc2"
      }
    ],
    "stats": {
      "total": 668,
      "additions": 334,
      "deletions": 334
    },
    "files": [
      {
        "sha": "e59ab7e5603e6bb03dc50e616b3aa1d53f237cf1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 330,
        "deletions": 330,
        "changes": 660,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b3136bd307123a255b9166aa42a497a44bcce70/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b3136bd307123a255b9166aa42a497a44bcce70/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8b3136bd307123a255b9166aa42a497a44bcce70",
        "patch": "@@ -441,32 +441,32 @@ static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return &it->second;\n }\n \n-static void UpdatePreferredDownload(CNode* node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n \n     // Whether this node should be marked as a preferred download node.\n-    state->fPreferredDownload = (!node->fInbound || node->HasPermission(PF_NOBAN)) && !node->fOneShot && !node->fClient;\n+    state->fPreferredDownload = (!node.fInbound || node.HasPermission(PF_NOBAN)) && !node.fOneShot && !node.fClient;\n \n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-static void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n+static void PushNodeVersion(CNode& pnode, CConnman* connman, int64_t nTime)\n {\n     // Note that pnode->GetLocalServices() is a reflection of the local\n     // services we were offering when the CNode object was created for this\n     // peer.\n-    ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n-    uint64_t nonce = pnode->GetLocalNonce();\n-    int nNodeStartingHeight = pnode->GetMyStartingHeight();\n-    NodeId nodeid = pnode->GetId();\n-    CAddress addr = pnode->addr;\n+    ServiceFlags nLocalNodeServices = pnode.GetLocalServices();\n+    uint64_t nonce = pnode.GetLocalNonce();\n+    int nNodeStartingHeight = pnode.GetMyStartingHeight();\n+    NodeId nodeid = pnode.GetId();\n+    CAddress addr = pnode.addr;\n \n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n-    connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n-            nonce, strSubVersion, nNodeStartingHeight, ::g_relay_txes && pnode->m_tx_relay != nullptr));\n+    connman->PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+            nonce, strSubVersion, nNodeStartingHeight, ::g_relay_txes && pnode.m_tx_relay != nullptr));\n \n     if (fLogIPs) {\n         LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n@@ -799,9 +799,9 @@ void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n \n // Returns true for outbound peers, excluding manual connections, feelers, and\n // one-shots.\n-static bool IsOutboundDisconnectionCandidate(const CNode *node)\n+static bool IsOutboundDisconnectionCandidate(const CNode& node)\n {\n-    return !(node->fInbound || node->m_manual_connection || node->fFeeler || node->fOneShot);\n+    return !(node.fInbound || node.m_manual_connection || node.fFeeler || node.fOneShot);\n }\n \n void PeerLogicValidation::InitializeNode(CNode *pnode) {\n@@ -813,7 +813,7 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n     if(!pnode->fInbound)\n-        PushNodeVersion(pnode, connman, GetTime());\n+        PushNodeVersion(*pnode, connman, GetTime());\n }\n \n void PeerLogicValidation::ReattemptInitialBroadcast(CScheduler& scheduler) const\n@@ -1462,7 +1462,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, const CConnman&\n     connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, const CInv& inv, CConnman* connman)\n+void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, const CInv& inv, CConnman* connman)\n {\n     bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n@@ -1504,28 +1504,28 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n     if (pindex) {\n         send = BlockRequestAllowed(pindex, consensusParams);\n         if (!send) {\n-            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom.GetId());\n         }\n     }\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     // never disconnect whitelisted nodes\n-    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->HasPermission(PF_NOBAN))\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom.HasPermission(PF_NOBAN))\n     {\n-        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n \n         //disconnect node\n-        pfrom->fDisconnect = true;\n+        pfrom.fDisconnect = true;\n         send = false;\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n-    if (send && !pfrom->HasPermission(PF_NOBAN) && (\n-            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (::ChainActive().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+    if (send && !pfrom.HasPermission(PF_NOBAN) && (\n+            (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (::ChainActive().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n-        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n+        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom.GetId());\n \n         //disconnect node and prevent it from stalling (would otherwise wait for the missing block)\n-        pfrom->fDisconnect = true;\n+        pfrom.fDisconnect = true;\n         send = false;\n     }\n     // Pruned nodes may have deleted the block, so check whether\n@@ -1542,7 +1542,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n             if (!ReadRawBlockFromDisk(block_data, pindex, chainparams.MessageStart())) {\n                 assert(!\"cannot load block from disk\");\n             }\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n             // Don't set pblock as we've sent the block\n         } else {\n             // Send block from disk\n@@ -1553,22 +1553,22 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n         }\n         if (pblock) {\n             if (inv.type == MSG_BLOCK)\n-                connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+                connman->PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n             else if (inv.type == MSG_WITNESS_BLOCK)\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n             else if (inv.type == MSG_FILTERED_BLOCK)\n             {\n                 bool sendMerkleBlock = false;\n                 CMerkleBlock merkleBlock;\n-                if (pfrom->m_tx_relay != nullptr) {\n-                    LOCK(pfrom->m_tx_relay->cs_filter);\n-                    if (pfrom->m_tx_relay->pfilter) {\n+                if (pfrom.m_tx_relay != nullptr) {\n+                    LOCK(pfrom.m_tx_relay->cs_filter);\n+                    if (pfrom.m_tx_relay->pfilter) {\n                         sendMerkleBlock = true;\n-                        merkleBlock = CMerkleBlock(*pblock, *pfrom->m_tx_relay->pfilter);\n+                        merkleBlock = CMerkleBlock(*pblock, *pfrom.m_tx_relay->pfilter);\n                     }\n                 }\n                 if (sendMerkleBlock) {\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n                     // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                     // This avoids hurting performance by pointlessly requiring a round-trip\n                     // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -1577,7 +1577,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n                     // however we MUST always provide at least what the remote peer needs\n                     typedef std::pair<unsigned int, uint256> PairType;\n                     for (PairType& pair : merkleBlock.vMatchedTxn)\n-                        connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+                        connman->PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                 }\n                 // else\n                     // no response\n@@ -1588,44 +1588,44 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n                 // they won't have a useful mempool to match against a compact block,\n                 // and we don't feel like constructing the object for them, so\n                 // instead we respond with the full, non-compact block.\n-                bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n+                bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n                 int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                 if (CanDirectFetch(consensusParams) && pindex->nHeight >= ::ChainActive().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                     if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n-                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                        connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                     } else {\n                         CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                 } else {\n-                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                    connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n                 }\n             }\n         }\n \n         // Trigger the peer node to send a getblocks request for the next batch of inventory\n-        if (inv.hash == pfrom->hashContinue)\n+        if (inv.hash == pfrom.hashContinue)\n         {\n             // Bypass PushInventory, this must send even if redundant,\n             // and we want it right after the last block so they don't\n             // wait for other stuff first.\n             std::vector<CInv> vInv;\n             vInv.push_back(CInv(MSG_BLOCK, ::ChainActive().Tip()->GetBlockHash()));\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n-            pfrom->hashContinue.SetNull();\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            pfrom.hashContinue.SetNull();\n         }\n     }\n }\n \n //! Determine whether or not a peer can request a transaction, and return it (or nullptr if not found or not allowed).\n-CTransactionRef static FindTxForGetData(CNode* peer, const uint256& txid, const std::chrono::seconds mempool_req, const std::chrono::seconds longlived_mempool_time) LOCKS_EXCLUDED(cs_main)\n+CTransactionRef static FindTxForGetData(CNode& peer, const uint256& txid, const std::chrono::seconds mempool_req, const std::chrono::seconds longlived_mempool_time) LOCKS_EXCLUDED(cs_main)\n {\n     // Check if the requested transaction is so recent that we're just\n     // about to announce it to the peer; if so, they certainly shouldn't\n     // know we already have it.\n     {\n-        LOCK(peer->m_tx_relay->cs_tx_inventory);\n-        if (peer->m_tx_relay->setInventoryTxToSend.count(txid)) return {};\n+        LOCK(peer.m_tx_relay->cs_tx_inventory);\n+        if (peer.m_tx_relay->setInventoryTxToSend.count(txid)) return {};\n     }\n \n     {\n@@ -1648,40 +1648,40 @@ CTransactionRef static FindTxForGetData(CNode* peer, const uint256& txid, const\n     return {};\n }\n \n-void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n+void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnman* connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n {\n     AssertLockNotHeld(cs_main);\n \n-    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n+    std::deque<CInv>::iterator it = pfrom.vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n \n     // mempool entries added before this time have likely expired from mapRelay\n     const std::chrono::seconds longlived_mempool_time = GetTime<std::chrono::seconds>() - RELAY_TX_CACHE_TIME;\n     // Get last mempool request time\n-    const std::chrono::seconds mempool_req = pfrom->m_tx_relay != nullptr ? pfrom->m_tx_relay->m_last_mempool_req.load()\n+    const std::chrono::seconds mempool_req = pfrom.m_tx_relay != nullptr ? pfrom.m_tx_relay->m_last_mempool_req.load()\n                                                                           : std::chrono::seconds::min();\n \n     // Process as many TX items from the front of the getdata queue as\n     // possible, since they're common and it's efficient to batch process\n     // them.\n-    while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {\n+    while (it != pfrom.vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {\n         if (interruptMsgProc) return;\n         // The send buffer provides backpressure. If there's no space in\n         // the buffer, pause processing until the next call.\n-        if (pfrom->fPauseSend) break;\n+        if (pfrom.fPauseSend) break;\n \n         const CInv &inv = *it++;\n \n-        if (pfrom->m_tx_relay == nullptr) {\n+        if (pfrom.m_tx_relay == nullptr) {\n             // Ignore GETDATA requests for transactions from blocks-only peers.\n             continue;\n         }\n \n         CTransactionRef tx = FindTxForGetData(pfrom, inv.hash, mempool_req, longlived_mempool_time);\n         if (tx) {\n             int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n-            connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n+            connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n             mempool.RemoveUnbroadcastTx(inv.hash);\n         } else {\n             vNotFound.push_back(inv);\n@@ -1690,7 +1690,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n \n     // Only process one BLOCK item per call, since they're uncommon and can be\n     // expensive to process.\n-    if (it != pfrom->vRecvGetData.end() && !pfrom->fPauseSend) {\n+    if (it != pfrom.vRecvGetData.end() && !pfrom.fPauseSend) {\n         const CInv &inv = *it++;\n         if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK) {\n             ProcessGetBlockData(pfrom, chainparams, inv, connman);\n@@ -1699,7 +1699,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n         // and continue processing the queue on the next call.\n     }\n \n-    pfrom->vRecvGetData.erase(pfrom->vRecvGetData.begin(), it);\n+    pfrom.vRecvGetData.erase(pfrom.vRecvGetData.begin(), it);\n \n     if (!vNotFound.empty()) {\n         // Let the peer know that we didn't find what it asked for, so it doesn't\n@@ -1716,37 +1716,37 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n         // In normal operation, we often send NOTFOUND messages for parents of\n         // transactions that we relay; if a peer is missing a parent, they may\n         // assume we have them and request the parents from us.\n-        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n+        connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n     }\n }\n \n-static uint32_t GetFetchFlags(CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+static uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     uint32_t nFetchFlags = 0;\n-    if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n+    if ((pfrom.GetLocalServices() & NODE_WITNESS) && State(pfrom.GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n     }\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode& pfrom, CConnman* connman) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId()));\n+            Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom.GetId()));\n             return;\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n     }\n     LOCK(cs_main);\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-    int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n+    const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n+    int nSendFlags = State(pfrom.GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+    connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateManager& chainman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateManager& chainman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n {\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n     size_t nCount = headers.size();\n \n     if (nCount == 0) {\n@@ -1758,7 +1758,7 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n     const CBlockIndex *pindexLast = nullptr;\n     {\n         LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeState *nodestate = State(pfrom.GetId());\n \n         // If this looks like it could be a block announcement (nCount <\n         // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n@@ -1770,27 +1770,27 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n                     pindexBestHeader->nHeight,\n-                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n+                    pfrom.GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n             // we can use this peer to download.\n-            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n+            UpdateBlockAvailability(pfrom.GetId(), headers.back().GetHash());\n \n             if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n-                Misbehaving(pfrom->GetId(), 20);\n+                Misbehaving(pfrom.GetId(), 20);\n             }\n             return true;\n         }\n \n         uint256 hashLastBlock;\n         for (const CBlockHeader& header : headers) {\n             if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n-                Misbehaving(pfrom->GetId(), 20, \"non-continuous headers sequence\");\n+                Misbehaving(pfrom.GetId(), 20, \"non-continuous headers sequence\");\n                 return false;\n             }\n             hashLastBlock = header.GetHash();\n@@ -1806,21 +1806,21 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n     BlockValidationState state;\n     if (!chainman.ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n         if (state.IsInvalid()) {\n-            MaybePunishNodeForBlock(pfrom->GetId(), state, via_compact_block, \"invalid header received\");\n+            MaybePunishNodeForBlock(pfrom.GetId(), state, via_compact_block, \"invalid header received\");\n             return false;\n         }\n     }\n \n     {\n         LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeState *nodestate = State(pfrom.GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom.GetId(), nodestate->nUnconnectingHeaders);\n         }\n         nodestate->nUnconnectingHeaders = 0;\n \n         assert(pindexLast);\n-        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+        UpdateBlockAvailability(pfrom.GetId(), pindexLast->GetBlockHash());\n \n         // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n@@ -1834,8 +1834,8 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of ::ChainActive().Tip or pindexBestHeader, continue\n             // from there instead.\n-            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom.GetId(), pfrom.nStartingHeight);\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -1848,7 +1848,7 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n             while (pindexWalk && !::ChainActive().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                         !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n-                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n+                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n                 }\n@@ -1872,9 +1872,9 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(mempool, pfrom->GetId(), pindex->GetBlockHash(), pindex);\n+                    MarkBlockAsInFlight(mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n+                            pindex->GetBlockHash().ToString(), pfrom.GetId());\n                 }\n                 if (vGetData.size() > 1) {\n                     LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n@@ -1885,7 +1885,7 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                 }\n             }\n         }\n@@ -1904,19 +1904,19 @@ bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, ChainstateMan\n                 // nMinimumChainWork, even if a peer has a chain past our tip,\n                 // as an anti-DoS measure.\n                 if (IsOutboundDisconnectionCandidate(pfrom)) {\n-                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n-                    pfrom->fDisconnect = true;\n+                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom.GetId());\n+                    pfrom.fDisconnect = true;\n                 }\n             }\n         }\n \n-        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr && pfrom->m_tx_relay != nullptr) {\n+        if (!pfrom.fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr && pfrom.m_tx_relay != nullptr) {\n             // If this is an outbound full-relay peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n             // Note that block-relay-only peers are already implicitly protected, so we\n             // only consider setting m_protect for the full-relay peers.\n             if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n-                LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n+                LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom.GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++g_outbound_peers_with_protect_from_disconnect;\n             }\n@@ -2203,36 +2203,36 @@ static void ProcessGetCFCheckPt(CNode& pfrom, CDataStream& vRecv, const CChainPa\n     connman.PushMessage(&pfrom, std::move(msg));\n }\n \n-bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, ChainstateManager& chainman, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc)\n+bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, ChainstateManager& chainman, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(msg_type), vRecv.size(), pfrom->GetId());\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(msg_type), vRecv.size(), pfrom.GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n         return true;\n     }\n \n \n-    if (!(pfrom->GetLocalServices() & NODE_BLOOM) &&\n+    if (!(pfrom.GetLocalServices() & NODE_BLOOM) &&\n               (msg_type == NetMsgType::FILTERLOAD ||\n                msg_type == NetMsgType::FILTERADD))\n     {\n-        if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n+        if (pfrom.nVersion >= NO_BLOOM_VERSION) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom.GetId(), 100);\n             return false;\n         } else {\n-            pfrom->fDisconnect = true;\n+            pfrom.fDisconnect = true;\n             return false;\n         }\n     }\n \n     if (msg_type == NetMsgType::VERSION) {\n         // Each connection can only send one version message\n-        if (pfrom->nVersion != 0)\n+        if (pfrom.nVersion != 0)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 1);\n+            Misbehaving(pfrom.GetId(), 1);\n             return false;\n         }\n \n@@ -2251,21 +2251,21 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         vRecv >> nVersion >> nServiceInt >> nTime >> addrMe;\n         nSendVersion = std::min(nVersion, PROTOCOL_VERSION);\n         nServices = ServiceFlags(nServiceInt);\n-        if (!pfrom->fInbound)\n+        if (!pfrom.fInbound)\n         {\n-            connman->SetServices(pfrom->addr, nServices);\n+            connman->SetServices(pfrom.addr, nServices);\n         }\n-        if (!pfrom->fInbound && !pfrom->fFeeler && !pfrom->m_manual_connection && !HasAllDesirableServiceFlags(nServices))\n+        if (!pfrom.fInbound && !pfrom.fFeeler && !pfrom.m_manual_connection && !HasAllDesirableServiceFlags(nServices))\n         {\n-            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, GetDesirableServiceFlags(nServices));\n-            pfrom->fDisconnect = true;\n+            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom.GetId(), nServices, GetDesirableServiceFlags(nServices));\n+            pfrom.fDisconnect = true;\n             return false;\n         }\n \n         if (nVersion < MIN_PEER_PROTO_VERSION) {\n             // disconnect from peers older than this proto version\n-            LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n-            pfrom->fDisconnect = true;\n+            LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom.GetId(), nVersion);\n+            pfrom.fDisconnect = true;\n             return false;\n         }\n \n@@ -2282,165 +2282,165 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (!vRecv.empty())\n             vRecv >> fRelay;\n         // Disconnect if we connected to ourself\n-        if (pfrom->fInbound && !connman->CheckIncomingNonce(nNonce))\n+        if (pfrom.fInbound && !connman->CheckIncomingNonce(nNonce))\n         {\n-            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString());\n-            pfrom->fDisconnect = true;\n+            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom.addr.ToString());\n+            pfrom.fDisconnect = true;\n             return true;\n         }\n \n-        if (pfrom->fInbound && addrMe.IsRoutable())\n+        if (pfrom.fInbound && addrMe.IsRoutable())\n         {\n             SeenLocal(addrMe);\n         }\n \n         // Be shy and don't send version until we hear\n-        if (pfrom->fInbound)\n+        if (pfrom.fInbound)\n             PushNodeVersion(pfrom, connman, GetAdjustedTime());\n \n-        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+        connman->PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n-        pfrom->nServices = nServices;\n-        pfrom->SetAddrLocal(addrMe);\n+        pfrom.nServices = nServices;\n+        pfrom.SetAddrLocal(addrMe);\n         {\n-            LOCK(pfrom->cs_SubVer);\n-            pfrom->cleanSubVer = cleanSubVer;\n+            LOCK(pfrom.cs_SubVer);\n+            pfrom.cleanSubVer = cleanSubVer;\n         }\n-        pfrom->nStartingHeight = nStartingHeight;\n+        pfrom.nStartingHeight = nStartingHeight;\n \n         // set nodes not relaying blocks and tx and not serving (parts) of the historical blockchain as \"clients\"\n-        pfrom->fClient = (!(nServices & NODE_NETWORK) && !(nServices & NODE_NETWORK_LIMITED));\n+        pfrom.fClient = (!(nServices & NODE_NETWORK) && !(nServices & NODE_NETWORK_LIMITED));\n \n         // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n-        pfrom->m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n+        pfrom.m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n-        if (pfrom->m_tx_relay != nullptr) {\n-            LOCK(pfrom->m_tx_relay->cs_filter);\n-            pfrom->m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n+        if (pfrom.m_tx_relay != nullptr) {\n+            LOCK(pfrom.m_tx_relay->cs_filter);\n+            pfrom.m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n         }\n \n         // Change version\n-        pfrom->SetSendVersion(nSendVersion);\n-        pfrom->nVersion = nVersion;\n+        pfrom.SetSendVersion(nSendVersion);\n+        pfrom.nVersion = nVersion;\n \n         if((nServices & NODE_WITNESS))\n         {\n             LOCK(cs_main);\n-            State(pfrom->GetId())->fHaveWitness = true;\n+            State(pfrom.GetId())->fHaveWitness = true;\n         }\n \n         // Potentially mark this peer as a preferred download peer.\n         {\n         LOCK(cs_main);\n-        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n+        UpdatePreferredDownload(pfrom, State(pfrom.GetId()));\n         }\n \n-        if (!pfrom->fInbound && pfrom->IsAddrRelayPeer())\n+        if (!pfrom.fInbound && pfrom.IsAddrRelayPeer())\n         {\n             // Advertise our address\n             if (fListen && !::ChainstateActive().IsInitialBlockDownload())\n             {\n-                CAddress addr = GetLocalAddress(&pfrom->addr, pfrom->GetLocalServices());\n+                CAddress addr = GetLocalAddress(&pfrom.addr, pfrom.GetLocalServices());\n                 FastRandomContext insecure_rand;\n                 if (addr.IsRoutable())\n                 {\n                     LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n-                    pfrom->PushAddress(addr, insecure_rand);\n-                } else if (IsPeerAddrLocalGood(pfrom)) {\n+                    pfrom.PushAddress(addr, insecure_rand);\n+                } else if (IsPeerAddrLocalGood(&pfrom)) {\n                     addr.SetIP(addrMe);\n                     LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n-                    pfrom->PushAddress(addr, insecure_rand);\n+                    pfrom.PushAddress(addr, insecure_rand);\n                 }\n             }\n \n             // Get recent addresses\n-            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman->GetAddressCount() < 1000)\n+            if (pfrom.fOneShot || pfrom.nVersion >= CADDR_TIME_VERSION || connman->GetAddressCount() < 1000)\n             {\n-                connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n-                pfrom->fGetAddr = true;\n+                connman->PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n+                pfrom.fGetAddr = true;\n             }\n-            connman->MarkAddressGood(pfrom->addr);\n+            connman->MarkAddressGood(pfrom.addr);\n         }\n \n         std::string remoteAddr;\n         if (fLogIPs)\n-            remoteAddr = \", peeraddr=\" + pfrom->addr.ToString();\n+            remoteAddr = \", peeraddr=\" + pfrom.addr.ToString();\n \n         LogPrint(BCLog::NET, \"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n-                  cleanSubVer, pfrom->nVersion,\n-                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n+                  cleanSubVer, pfrom.nVersion,\n+                  pfrom.nStartingHeight, addrMe.ToString(), pfrom.GetId(),\n                   remoteAddr);\n \n         int64_t nTimeOffset = nTime - GetTime();\n-        pfrom->nTimeOffset = nTimeOffset;\n-        AddTimeData(pfrom->addr, nTimeOffset);\n+        pfrom.nTimeOffset = nTimeOffset;\n+        AddTimeData(pfrom.addr, nTimeOffset);\n \n         // If the peer is old enough to have the old alert system, send it the final alert.\n-        if (pfrom->nVersion <= 70012) {\n+        if (pfrom.nVersion <= 70012) {\n             CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);\n-            connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n+            connman->PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n         }\n \n         // Feeler connections exist only to verify if address is online.\n-        if (pfrom->fFeeler) {\n-            assert(pfrom->fInbound == false);\n-            pfrom->fDisconnect = true;\n+        if (pfrom.fFeeler) {\n+            assert(pfrom.fInbound == false);\n+            pfrom.fDisconnect = true;\n         }\n         return true;\n     }\n \n-    if (pfrom->nVersion == 0) {\n+    if (pfrom.nVersion == 0) {\n         // Must have a version message before anything else\n         LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n+        Misbehaving(pfrom.GetId(), 1);\n         return false;\n     }\n \n     // At this point, the outgoing message serialization version can't change.\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n \n     if (msg_type == NetMsgType::VERACK)\n     {\n-        pfrom->SetRecvVersion(std::min(pfrom->nVersion.load(), PROTOCOL_VERSION));\n+        pfrom.SetRecvVersion(std::min(pfrom.nVersion.load(), PROTOCOL_VERSION));\n \n-        if (!pfrom->fInbound) {\n+        if (!pfrom.fInbound) {\n             // Mark this node as currently connected, so we update its timestamp later.\n             LOCK(cs_main);\n-            State(pfrom->GetId())->fCurrentlyConnected = true;\n+            State(pfrom.GetId())->fCurrentlyConnected = true;\n             LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s (%s)\\n\",\n-                      pfrom->nVersion.load(), pfrom->nStartingHeight,\n-                      pfrom->GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"),\n-                      pfrom->m_tx_relay == nullptr ? \"block-relay\" : \"full-relay\");\n+                      pfrom.nVersion.load(), pfrom.nStartingHeight,\n+                      pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n+                      pfrom.m_tx_relay == nullptr ? \"block-relay\" : \"full-relay\");\n         }\n \n-        if (pfrom->nVersion >= SENDHEADERS_VERSION) {\n+        if (pfrom.nVersion >= SENDHEADERS_VERSION) {\n             // Tell our peer we prefer to receive headers rather than inv's\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n-        if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n+        if (pfrom.nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n             // However, we do not request new block announcements using\n             // cmpctblock messages.\n             // We send this to non-NODE NETWORK peers as well, because\n             // they may wish to request compact blocks from us\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n-            if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            if (pfrom.GetLocalServices() & NODE_WITNESS)\n+                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n-        pfrom->fSuccessfullyConnected = true;\n+        pfrom.fSuccessfullyConnected = true;\n         return true;\n     }\n \n-    if (!pfrom->fSuccessfullyConnected) {\n+    if (!pfrom.fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n         LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n+        Misbehaving(pfrom.GetId(), 1);\n         return false;\n     }\n \n@@ -2449,15 +2449,15 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         vRecv >> vAddr;\n \n         // Don't want addr from older versions unless seeding\n-        if (pfrom->nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)\n+        if (pfrom.nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)\n             return true;\n-        if (!pfrom->IsAddrRelayPeer()) {\n+        if (!pfrom.IsAddrRelayPeer()) {\n             return true;\n         }\n         if (vAddr.size() > 1000)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n+            Misbehaving(pfrom.GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n             return false;\n         }\n \n@@ -2478,10 +2478,10 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n \n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                 addr.nTime = nNow - 5 * 24 * 60 * 60;\n-            pfrom->AddAddressKnown(addr);\n+            pfrom.AddAddressKnown(addr);\n             if (banman->IsBanned(addr)) continue; // Do not process banned addresses beyond remembering we received them\n             bool fReachable = IsReachable(addr);\n-            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n+            if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n                 RelayAddress(addr, fReachable, *connman);\n@@ -2490,38 +2490,38 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n-        connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);\n+        connman->AddNewAddresses(vAddrOk, pfrom.addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n-            pfrom->fGetAddr = false;\n-        if (pfrom->fOneShot)\n-            pfrom->fDisconnect = true;\n+            pfrom.fGetAddr = false;\n+        if (pfrom.fOneShot)\n+            pfrom.fDisconnect = true;\n         return true;\n     }\n \n     if (msg_type == NetMsgType::SENDHEADERS) {\n         LOCK(cs_main);\n-        State(pfrom->GetId())->fPreferHeaders = true;\n+        State(pfrom.GetId())->fPreferHeaders = true;\n         return true;\n     }\n \n     if (msg_type == NetMsgType::SENDCMPCT) {\n         bool fAnnounceUsingCMPCTBLOCK = false;\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n-        if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n+        if (nCMPCTBLOCKVersion == 1 || ((pfrom.GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n             LOCK(cs_main);\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n-            if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {\n-                State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n-                State(pfrom->GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+            if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n+                State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n+                State(pfrom.GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n             }\n-            if (State(pfrom->GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n-                State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n-            if (!State(pfrom->GetId())->fSupportsDesiredCmpctVersion) {\n-                if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n+            if (State(pfrom.GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n+                State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            if (!State(pfrom.GetId())->fSupportsDesiredCmpctVersion) {\n+                if (pfrom.GetLocalServices() & NODE_WITNESS)\n+                    State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n                 else\n-                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n+                    State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n             }\n         }\n         return true;\n@@ -2533,16 +2533,16 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (vInv.size() > MAX_INV_SZ)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n+            Misbehaving(pfrom.GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n             return false;\n         }\n \n         // We won't accept tx inv's if we're in blocks-only mode, or this is a\n         // block-relay-only peer\n-        bool fBlocksOnly = !g_relay_txes || (pfrom->m_tx_relay == nullptr);\n+        bool fBlocksOnly = !g_relay_txes || (pfrom.m_tx_relay == nullptr);\n \n         // Allow whitelisted peers to send data other than blocks in blocks only mode if whitelistrelay is true\n-        if (pfrom->HasPermission(PF_RELAY))\n+        if (pfrom.HasPermission(PF_RELAY))\n             fBlocksOnly = false;\n \n         LOCK(cs_main);\n@@ -2557,14 +2557,14 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 return true;\n \n             bool fAlreadyHave = AlreadyHave(inv, mempool);\n-            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n             }\n \n             if (inv.type == MSG_BLOCK) {\n-                UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n+                UpdateBlockAvailability(pfrom.GetId(), inv.hash);\n                 if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n                     // Headers-first is the primary method of announcement on\n                     // the network. If a node fell back to sending blocks by inv,\n@@ -2574,20 +2574,20 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                     best_block = &inv.hash;\n                 }\n             } else {\n-                pfrom->AddInventoryKnown(inv);\n+                pfrom.AddInventoryKnown(inv);\n                 if (fBlocksOnly) {\n-                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n-                    pfrom->fDisconnect = true;\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom.GetId());\n+                    pfrom.fDisconnect = true;\n                     return true;\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !::ChainstateActive().IsInitialBlockDownload()) {\n-                    RequestTx(State(pfrom->GetId()), inv.hash, current_time);\n+                    RequestTx(State(pfrom.GetId()), inv.hash, current_time);\n                 }\n             }\n         }\n \n         if (best_block != nullptr) {\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n-            LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom->GetId());\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n+            LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n         return true;\n@@ -2599,17 +2599,17 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (vInv.size() > MAX_INV_SZ)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n+            Misbehaving(pfrom.GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n             return false;\n         }\n \n-        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());\n+        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom.GetId());\n \n         if (vInv.size() > 0) {\n-            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());\n+            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom.GetId());\n         }\n \n-        pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n+        pfrom.vRecvGetData.insert(pfrom.vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom, chainparams, connman, mempool, interruptMsgProc);\n         return true;\n     }\n@@ -2620,8 +2620,8 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         vRecv >> locator >> hashStop;\n \n         if (locator.vHave.size() > MAX_LOCATOR_SZ) {\n-            LogPrint(BCLog::NET, \"getblocks locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom->GetId());\n-            pfrom->fDisconnect = true;\n+            LogPrint(BCLog::NET, \"getblocks locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom.GetId());\n+            pfrom.fDisconnect = true;\n             return true;\n         }\n \n@@ -2653,7 +2653,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (pindex)\n             pindex = ::ChainActive().Next(pindex);\n         int nLimit = 500;\n-        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());\n+        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom.GetId());\n         for (; pindex; pindex = ::ChainActive().Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n@@ -2669,13 +2669,13 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n             }\n-            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+            pfrom.PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n             if (--nLimit <= 0)\n             {\n                 // When this block is requested, we'll send an inv that'll\n                 // trigger the peer to getblocks the next batch of inventory.\n                 LogPrint(BCLog::NET, \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n-                pfrom->hashContinue = pindex->GetBlockHash();\n+                pfrom.hashContinue = pindex->GetBlockHash();\n                 break;\n             }\n         }\n@@ -2702,7 +2702,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n \n         const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);\n         if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom.GetId());\n             return true;\n         }\n \n@@ -2714,11 +2714,11 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom.GetId(), MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n-            inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n+            inv.type = State(pfrom.GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n-            pfrom->vRecvGetData.push_back(inv);\n+            pfrom.vRecvGetData.push_back(inv);\n             // The message processing loop will go around again (without pausing) and we'll respond then (without cs_main)\n             return true;\n         }\n@@ -2737,18 +2737,18 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         vRecv >> locator >> hashStop;\n \n         if (locator.vHave.size() > MAX_LOCATOR_SZ) {\n-            LogPrint(BCLog::NET, \"getheaders locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom->GetId());\n-            pfrom->fDisconnect = true;\n+            LogPrint(BCLog::NET, \"getheaders locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom.GetId());\n+            pfrom.fDisconnect = true;\n             return true;\n         }\n \n         LOCK(cs_main);\n-        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom->HasPermission(PF_NOBAN)) {\n-            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n+        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom.HasPermission(PF_NOBAN)) {\n+            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom.GetId());\n             return true;\n         }\n \n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeState *nodestate = State(pfrom.GetId());\n         const CBlockIndex* pindex = nullptr;\n         if (locator.IsNull())\n         {\n@@ -2759,7 +2759,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             }\n \n             if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {\n-                LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+                LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom.GetId());\n                 return true;\n             }\n         }\n@@ -2774,7 +2774,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());\n+        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom.GetId());\n         for (; pindex; pindex = ::ChainActive().Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -2794,18 +2794,18 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n-        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+        connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n         return true;\n     }\n \n     if (msg_type == NetMsgType::TX) {\n         // Stop processing the transaction early if\n         // 1) We are in blocks only mode and peer has no relay permission\n         // 2) This peer is a block-relay-only peer\n-        if ((!g_relay_txes && !pfrom->HasPermission(PF_RELAY)) || (pfrom->m_tx_relay == nullptr))\n+        if ((!g_relay_txes && !pfrom.HasPermission(PF_RELAY)) || (pfrom.m_tx_relay == nullptr))\n         {\n-            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n-            pfrom->fDisconnect = true;\n+            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n             return true;\n         }\n \n@@ -2814,13 +2814,13 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         const CTransaction& tx = *ptx;\n \n         CInv inv(MSG_TX, tx.GetHash());\n-        pfrom->AddInventoryKnown(inv);\n+        pfrom.AddInventoryKnown(inv);\n \n         LOCK2(cs_main, g_cs_orphans);\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom->GetId());\n+        CNodeState* nodestate = State(pfrom.GetId());\n         nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n         nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n         EraseTxRequest(inv.hash);\n@@ -2835,20 +2835,20 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n                     for (const auto& elem : it_by_prev->second) {\n-                        pfrom->orphan_work_set.insert(elem->first);\n+                        pfrom.orphan_work_set.insert(elem->first);\n                     }\n                 }\n             }\n \n-            pfrom->nLastTXTime = GetTime();\n+            pfrom.nLastTXTime = GetTime();\n \n             LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->GetId(),\n+                pfrom.GetId(),\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n             // Recursively process any orphan transactions that depended on this one\n-            ProcessOrphanTx(connman, mempool, pfrom->orphan_work_set, lRemovedTxn);\n+            ProcessOrphanTx(connman, mempool, pfrom.orphan_work_set, lRemovedTxn);\n         }\n         else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n         {\n@@ -2865,10 +2865,10 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n \n                 for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n-                    pfrom->AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom->GetId()), _inv.hash, current_time);\n+                    pfrom.AddInventoryKnown(_inv);\n+                    if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom.GetId()), _inv.hash, current_time);\n                 }\n-                AddOrphanTx(ptx, pfrom->GetId());\n+                AddOrphanTx(ptx, pfrom.GetId());\n \n                 // DoS prevention: do not allow mapOrphanTransactions to grow unbounded (see CVE-2012-3789)\n                 unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n@@ -2896,15 +2896,15 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 AddToCompactExtraTransactions(ptx);\n             }\n \n-            if (pfrom->HasPermission(PF_FORCERELAY)) {\n+            if (pfrom.HasPermission(PF_FORCERELAY)) {\n                 // Always relay transactions received from whitelisted peers, even\n                 // if they were already in the mempool,\n                 // allowing the node to function as a gateway for\n                 // nodes hidden behind it.\n                 if (!mempool.exists(tx.GetHash())) {\n-                    LogPrintf(\"Not relaying non-mempool transaction %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n+                    LogPrintf(\"Not relaying non-mempool transaction %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n+                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                     RelayTransaction(tx.GetHash(), *connman);\n                 }\n             }\n@@ -2933,9 +2933,9 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (state.IsInvalid())\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->GetId(),\n+                pfrom.GetId(),\n                 state.ToString());\n-            MaybePunishNodeForTx(pfrom->GetId(), state);\n+            MaybePunishNodeForTx(pfrom.GetId(), state);\n         }\n         return true;\n     }\n@@ -2944,7 +2944,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n     {\n         // Ignore cmpctblock received while importing\n         if (fImporting || fReindex) {\n-            LogPrint(BCLog::NET, \"Unexpected cmpctblock message received from peer %d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Unexpected cmpctblock message received from peer %d\\n\", pfrom.GetId());\n             return true;\n         }\n \n@@ -2959,7 +2959,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!::ChainstateActive().IsInitialBlockDownload())\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n \n@@ -2972,7 +2972,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         BlockValidationState state;\n         if (!chainman.ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n             if (state.IsInvalid()) {\n-                MaybePunishNodeForBlock(pfrom->GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n+                MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n                 return true;\n             }\n         }\n@@ -2997,9 +2997,9 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         LOCK2(cs_main, g_cs_orphans);\n         // If AcceptBlockHeader returned true, it set pindex\n         assert(pindex);\n-        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+        UpdateBlockAvailability(pfrom.GetId(), pindex->GetBlockHash());\n \n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeState *nodestate = State(pfrom.GetId());\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n@@ -3020,7 +3020,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n         }\n@@ -3039,9 +3039,9 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= ::ChainActive().Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n-                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(mempool, pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n                     else {\n@@ -3055,13 +3055,13 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n-                    Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId()));\n+                    Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us invalid compact block\\n\", pfrom.GetId()));\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n \n@@ -3078,7 +3078,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                     fProcessBLOCKTXN = true;\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             } else {\n                 // This block is either already in flight from a different\n@@ -3104,7 +3104,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -3130,7 +3130,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             // block that is in flight from some other peer.\n             {\n                 LOCK(cs_main);\n-                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n+                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom.GetId(), false));\n             }\n             bool fNewBlock = false;\n             // Setting fForceProcessing to true means that we bypass some of\n@@ -3144,7 +3144,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             // reconstructed compact blocks as having been requested.\n             chainman.ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n             if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n+                pfrom.nLastBlockTime = GetTime();\n             } else {\n                 LOCK(cs_main);\n                 mapBlockSource.erase(pblock->GetHash());\n@@ -3165,7 +3165,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n     {\n         // Ignore blocktxn received while importing\n         if (fImporting || fReindex) {\n-            LogPrint(BCLog::NET, \"Unexpected blocktxn message received from peer %d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Unexpected blocktxn message received from peer %d\\n\", pfrom.GetId());\n             return true;\n         }\n \n@@ -3179,22 +3179,22 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n \n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n-                    it->second.first != pfrom->GetId()) {\n-                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n+                    it->second.first != pfrom.GetId()) {\n+                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom.GetId());\n                 return true;\n             }\n \n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n-                Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId()));\n+                Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom.GetId()));\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED.\n@@ -3221,7 +3221,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 // BIP 152 permits peers to relay compact blocks after validating\n                 // the header only; we should not punish peers if the block turns\n                 // out to be invalid.\n-                mapBlockSource.emplace(resp.blockhash, std::make_pair(pfrom->GetId(), false));\n+                mapBlockSource.emplace(resp.blockhash, std::make_pair(pfrom.GetId(), false));\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n@@ -3234,7 +3234,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             // in compact block optimistic reconstruction handling.\n             chainman.ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n             if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n+                pfrom.nLastBlockTime = GetTime();\n             } else {\n                 LOCK(cs_main);\n                 mapBlockSource.erase(pblock->GetHash());\n@@ -3247,7 +3247,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n     {\n         // Ignore headers received while importing\n         if (fImporting || fReindex) {\n-            LogPrint(BCLog::NET, \"Unexpected headers message received from peer %d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Unexpected headers message received from peer %d\\n\", pfrom.GetId());\n             return true;\n         }\n \n@@ -3257,7 +3257,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n+            Misbehaving(pfrom.GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n             return false;\n         }\n         headers.resize(nCount);\n@@ -3273,14 +3273,14 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n     {\n         // Ignore block received while importing\n         if (fImporting || fReindex) {\n-            LogPrint(BCLog::NET, \"Unexpected block message received from peer %d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Unexpected block message received from peer %d\\n\", pfrom.GetId());\n             return true;\n         }\n \n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n-        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n+        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom.GetId());\n \n         bool forceProcessing = false;\n         const uint256 hash(pblock->GetHash());\n@@ -3292,12 +3292,12 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             // mapBlockSource is only used for punishing peers and setting\n             // which peers send us compact blocks, so the race between here and\n             // cs_main in ProcessNewBlock is fine.\n-            mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n+            mapBlockSource.emplace(hash, std::make_pair(pfrom.GetId(), true));\n         }\n         bool fNewBlock = false;\n         chainman.ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n         if (fNewBlock) {\n-            pfrom->nLastBlockTime = GetTime();\n+            pfrom.nLastBlockTime = GetTime();\n         } else {\n             LOCK(cs_main);\n             mapBlockSource.erase(pblock->GetHash());\n@@ -3311,64 +3311,64 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         // to users' AddrMan and later request them by sending getaddr messages.\n         // Making nodes which are behind NAT and can only make outgoing connections ignore\n         // the getaddr message mitigates the attack.\n-        if (!pfrom->fInbound) {\n-            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());\n+        if (!pfrom.fInbound) {\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom.GetId());\n             return true;\n         }\n-        if (!pfrom->IsAddrRelayPeer()) {\n-            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from block-relay-only connection. peer=%d\\n\", pfrom->GetId());\n+        if (!pfrom.IsAddrRelayPeer()) {\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from block-relay-only connection. peer=%d\\n\", pfrom.GetId());\n             return true;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n-        if (pfrom->fSentAddr) {\n-            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());\n+        if (pfrom.fSentAddr) {\n+            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom.GetId());\n             return true;\n         }\n-        pfrom->fSentAddr = true;\n+        pfrom.fSentAddr = true;\n \n-        pfrom->vAddrToSend.clear();\n+        pfrom.vAddrToSend.clear();\n         std::vector<CAddress> vAddr = connman->GetAddresses();\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr) {\n             if (!banman->IsBanned(addr)) {\n-                pfrom->PushAddress(addr, insecure_rand);\n+                pfrom.PushAddress(addr, insecure_rand);\n             }\n         }\n         return true;\n     }\n \n     if (msg_type == NetMsgType::MEMPOOL) {\n-        if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->HasPermission(PF_MEMPOOL))\n+        if (!(pfrom.GetLocalServices() & NODE_BLOOM) && !pfrom.HasPermission(PF_MEMPOOL))\n         {\n-            if (!pfrom->HasPermission(PF_NOBAN))\n+            if (!pfrom.HasPermission(PF_NOBAN))\n             {\n-                LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n-                pfrom->fDisconnect = true;\n+                LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom.GetId());\n+                pfrom.fDisconnect = true;\n             }\n             return true;\n         }\n \n-        if (connman->OutboundTargetReached(false) && !pfrom->HasPermission(PF_MEMPOOL))\n+        if (connman->OutboundTargetReached(false) && !pfrom.HasPermission(PF_MEMPOOL))\n         {\n-            if (!pfrom->HasPermission(PF_NOBAN))\n+            if (!pfrom.HasPermission(PF_NOBAN))\n             {\n-                LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n-                pfrom->fDisconnect = true;\n+                LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n+                pfrom.fDisconnect = true;\n             }\n             return true;\n         }\n \n-        if (pfrom->m_tx_relay != nullptr) {\n-            LOCK(pfrom->m_tx_relay->cs_tx_inventory);\n-            pfrom->m_tx_relay->fSendMempool = true;\n+        if (pfrom.m_tx_relay != nullptr) {\n+            LOCK(pfrom.m_tx_relay->cs_tx_inventory);\n+            pfrom.m_tx_relay->fSendMempool = true;\n         }\n         return true;\n     }\n \n     if (msg_type == NetMsgType::PING) {\n-        if (pfrom->nVersion > BIP0031_VERSION)\n+        if (pfrom.nVersion > BIP0031_VERSION)\n         {\n             uint64_t nonce = 0;\n             vRecv >> nonce;\n@@ -3383,7 +3383,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n+            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n         return true;\n     }\n@@ -3399,15 +3399,15 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             vRecv >> nonce;\n \n             // Only process pong message if there is an outstanding ping (old ping without nonce should never pong)\n-            if (pfrom->nPingNonceSent != 0) {\n-                if (nonce == pfrom->nPingNonceSent) {\n+            if (pfrom.nPingNonceSent != 0) {\n+                if (nonce == pfrom.nPingNonceSent) {\n                     // Matching pong received, this ping is no longer outstanding\n                     bPingFinished = true;\n-                    int64_t pingUsecTime = pingUsecEnd - pfrom->nPingUsecStart;\n+                    int64_t pingUsecTime = pingUsecEnd - pfrom.nPingUsecStart;\n                     if (pingUsecTime > 0) {\n                         // Successful ping time measurement, replace previous\n-                        pfrom->nPingUsecTime = pingUsecTime;\n-                        pfrom->nMinPingUsecTime = std::min(pfrom->nMinPingUsecTime.load(), pingUsecTime);\n+                        pfrom.nPingUsecTime = pingUsecTime;\n+                        pfrom.nMinPingUsecTime = std::min(pfrom.nMinPingUsecTime.load(), pingUsecTime);\n                     } else {\n                         // This should never happen\n                         sProblem = \"Timing mishap\";\n@@ -3432,14 +3432,14 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n \n         if (!(sProblem.empty())) {\n             LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->GetId(),\n+                pfrom.GetId(),\n                 sProblem,\n-                pfrom->nPingNonceSent,\n+                pfrom.nPingNonceSent,\n                 nonce,\n                 nAvail);\n         }\n         if (bPingFinished) {\n-            pfrom->nPingNonceSent = 0;\n+            pfrom.nPingNonceSent = 0;\n         }\n         return true;\n     }\n@@ -3452,13 +3452,13 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             // There is no excuse for sending a too-large filter\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom.GetId(), 100);\n         }\n-        else if (pfrom->m_tx_relay != nullptr)\n+        else if (pfrom.m_tx_relay != nullptr)\n         {\n-            LOCK(pfrom->m_tx_relay->cs_filter);\n-            pfrom->m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n-            pfrom->m_tx_relay->fRelayTxes = true;\n+            LOCK(pfrom.m_tx_relay->cs_filter);\n+            pfrom.m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n+            pfrom.m_tx_relay->fRelayTxes = true;\n         }\n         return true;\n     }\n@@ -3472,65 +3472,65 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         bool bad = false;\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n-        } else if (pfrom->m_tx_relay != nullptr) {\n-            LOCK(pfrom->m_tx_relay->cs_filter);\n-            if (pfrom->m_tx_relay->pfilter) {\n-                pfrom->m_tx_relay->pfilter->insert(vData);\n+        } else if (pfrom.m_tx_relay != nullptr) {\n+            LOCK(pfrom.m_tx_relay->cs_filter);\n+            if (pfrom.m_tx_relay->pfilter) {\n+                pfrom.m_tx_relay->pfilter->insert(vData);\n             } else {\n                 bad = true;\n             }\n         }\n         if (bad) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom.GetId(), 100);\n         }\n         return true;\n     }\n \n     if (msg_type == NetMsgType::FILTERCLEAR) {\n-        if (pfrom->m_tx_relay == nullptr) {\n+        if (pfrom.m_tx_relay == nullptr) {\n             return true;\n         }\n-        LOCK(pfrom->m_tx_relay->cs_filter);\n-        if (pfrom->GetLocalServices() & NODE_BLOOM) {\n-            pfrom->m_tx_relay->pfilter = nullptr;\n+        LOCK(pfrom.m_tx_relay->cs_filter);\n+        if (pfrom.GetLocalServices() & NODE_BLOOM) {\n+            pfrom.m_tx_relay->pfilter = nullptr;\n         }\n-        pfrom->m_tx_relay->fRelayTxes = true;\n+        pfrom.m_tx_relay->fRelayTxes = true;\n         return true;\n     }\n \n     if (msg_type == NetMsgType::FEEFILTER) {\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n-            if (pfrom->m_tx_relay != nullptr) {\n-                LOCK(pfrom->m_tx_relay->cs_feeFilter);\n-                pfrom->m_tx_relay->minFeeFilter = newFeeFilter;\n+            if (pfrom.m_tx_relay != nullptr) {\n+                LOCK(pfrom.m_tx_relay->cs_feeFilter);\n+                pfrom.m_tx_relay->minFeeFilter = newFeeFilter;\n             }\n-            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n+            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom.GetId());\n         }\n         return true;\n     }\n \n     if (msg_type == NetMsgType::GETCFILTERS) {\n-        ProcessGetCFilters(*pfrom, vRecv, chainparams, *connman);\n+        ProcessGetCFilters(pfrom, vRecv, chainparams, *connman);\n         return true;\n     }\n \n     if (msg_type == NetMsgType::GETCFHEADERS) {\n-        ProcessGetCFHeaders(*pfrom, vRecv, chainparams, *connman);\n+        ProcessGetCFHeaders(pfrom, vRecv, chainparams, *connman);\n         return true;\n     }\n \n     if (msg_type == NetMsgType::GETCFCHECKPT) {\n-        ProcessGetCFCheckPt(*pfrom, vRecv, chainparams, *connman);\n+        ProcessGetCFCheckPt(pfrom, vRecv, chainparams, *connman);\n         return true;\n     }\n \n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom->GetId());\n+        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n@@ -3553,31 +3553,31 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n     }\n \n     // Ignore unknown commands for extensibility\n-    LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom->GetId());\n+    LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return true;\n }\n \n-bool PeerLogicValidation::CheckIfBanned(CNode* pnode)\n+bool PeerLogicValidation::CheckIfBanned(CNode& pnode)\n {\n     AssertLockHeld(cs_main);\n-    CNodeState &state = *State(pnode->GetId());\n+    CNodeState &state = *State(pnode.GetId());\n \n     if (state.fShouldBan) {\n         state.fShouldBan = false;\n-        if (pnode->HasPermission(PF_NOBAN))\n-            LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n-        else if (pnode->m_manual_connection)\n-            LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode->addr.ToString());\n-        else if (pnode->addr.IsLocal()) {\n+        if (pnode.HasPermission(PF_NOBAN))\n+            LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode.addr.ToString());\n+        else if (pnode.m_manual_connection)\n+            LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode.addr.ToString());\n+        else if (pnode.addr.IsLocal()) {\n             // Disconnect but don't ban _this_ local node\n-            LogPrintf(\"Warning: disconnecting but not banning local peer %s!\\n\", pnode->addr.ToString());\n-            pnode->fDisconnect = true;\n+            LogPrintf(\"Warning: disconnecting but not banning local peer %s!\\n\", pnode.addr.ToString());\n+            pnode.fDisconnect = true;\n         } else {\n             // Disconnect and ban all nodes sharing the address\n             if (m_banman) {\n-                m_banman->Ban(pnode->addr, BanReasonNodeMisbehaving);\n+                m_banman->Ban(pnode.addr, BanReasonNodeMisbehaving);\n             }\n-            connman->DisconnectNode(pnode->addr);\n+            connman->DisconnectNode(pnode.addr);\n         }\n         return true;\n     }\n@@ -3598,7 +3598,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fMoreWork = false;\n \n     if (!pfrom->vRecvGetData.empty())\n-        ProcessGetData(pfrom, chainparams, connman, m_mempool, interruptMsgProc);\n+        ProcessGetData(*pfrom, chainparams, connman, m_mempool, interruptMsgProc);\n \n     if (!pfrom->orphan_work_set.empty()) {\n         std::list<CTransactionRef> removed_txn;\n@@ -3666,7 +3666,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, connman, m_banman, interruptMsgProc);\n+        fRet = ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, connman, m_banman, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3682,17 +3682,17 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     }\n \n     LOCK(cs_main);\n-    CheckIfBanned(pfrom);\n+    CheckIfBanned(*pfrom);\n \n     return fMoreWork;\n }\n \n-void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n+void PeerLogicValidation::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);\n \n-    CNodeState &state = *State(pto->GetId());\n-    const CNetMsgMaker msgMaker(pto->GetSendVersion());\n+    CNodeState &state = *State(pto.GetId());\n+    const CNetMsgMaker msgMaker(pto.GetSendVersion());\n \n     if (!state.m_chain_sync.m_protect && IsOutboundDisconnectionCandidate(pto) && state.fSyncStarted) {\n         // This is an outbound peer subject to disconnection if they don't\n@@ -3721,12 +3721,12 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n             // message to give the peer a chance to update us.\n             if (state.m_chain_sync.m_sent_getheaders) {\n                 // They've run out of time to catch up!\n-                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n-                pto->fDisconnect = true;\n+                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto.GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n+                pto.fDisconnect = true;\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n-                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto.GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n+                connman->PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n@@ -3756,7 +3756,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             AssertLockHeld(cs_main);\n \n             // Ignore non-outbound peers, or nodes marked for disconnect already\n-            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;\n+            if (!IsOutboundDisconnectionCandidate(*pnode) || pnode->fDisconnect) return;\n             CNodeState *state = State(pnode->GetId());\n             if (state == nullptr) return; // shouldn't be possible, but just in case\n             // Don't evict our protected peers\n@@ -3885,7 +3885,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         if (!lockMain)\n             return true;\n \n-        if (CheckIfBanned(pto)) return true;\n+        if (CheckIfBanned(*pto)) return true;\n \n         CNodeState &state = *State(pto->GetId());\n \n@@ -4296,7 +4296,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n         // Check that outbound peers have reasonable chains\n         // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n-        ConsiderEviction(pto, GetTime());\n+        ConsiderEviction(*pto, GetTime());\n \n         //\n         // Message: getdata (blocks)\n@@ -4307,7 +4307,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             for (const CBlockIndex *pindex : vToDownload) {\n-                uint32_t nFetchFlags = GetFetchFlags(pto);\n+                uint32_t nFetchFlags = GetFetchFlags(*pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(m_mempool, pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n@@ -4351,7 +4351,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             // Erase this entry from tx_process_time (it may be added back for\n             // processing at a later time, see below)\n             tx_process_time.erase(tx_process_time.begin());\n-            CInv inv(MSG_TX | GetFetchFlags(pto), txid);\n+            CInv inv(MSG_TX | GetFetchFlags(*pto), txid);\n             if (!AlreadyHave(inv, m_mempool)) {\n                 // If this transaction was last requested more than 1 minute ago,\n                 // then request."
      },
      {
        "sha": "19beca0cc401d983f69fed7499b6c0c702a42006",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b3136bd307123a255b9166aa42a497a44bcce70/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b3136bd307123a255b9166aa42a497a44bcce70/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=8b3136bd307123a255b9166aa42a497a44bcce70",
        "patch": "@@ -31,7 +31,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     ChainstateManager& m_chainman;\n     CTxMemPool& m_mempool;\n \n-    bool CheckIfBanned(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool CheckIfBanned(CNode& pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n public:\n     PeerLogicValidation(CConnman* connman, BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool);\n@@ -74,7 +74,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n-    void ConsiderEviction(CNode *pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound */\n     void CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams);\n     /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */"
      },
      {
        "sha": "ca0365d1724286d06f4b81cb927b6221a71ba656",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b3136bd307123a255b9166aa42a497a44bcce70/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b3136bd307123a255b9166aa42a497a44bcce70/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=8b3136bd307123a255b9166aa42a497a44bcce70",
        "patch": "@@ -29,7 +29,7 @@\n #include <string>\n #include <vector>\n \n-bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, ChainstateManager& chainman, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc);\n+bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, ChainstateManager& chainman, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc);\n \n namespace {\n \n@@ -74,7 +74,7 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     p2p_node.SetSendVersion(PROTOCOL_VERSION);\n     g_setup->m_node.peer_logic->InitializeNode(&p2p_node);\n     try {\n-        (void)ProcessMessage(&p2p_node, random_message_type, random_bytes_data_stream, GetTimeMillis(), Params(), *g_setup->m_node.chainman, *g_setup->m_node.mempool, g_setup->m_node.connman.get(), g_setup->m_node.banman.get(), std::atomic<bool>{false});\n+        (void)ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream, GetTimeMillis(), Params(), *g_setup->m_node.chainman, *g_setup->m_node.mempool, g_setup->m_node.connman.get(), g_setup->m_node.banman.get(), std::atomic<bool>{false});\n     } catch (const std::ios_base::failure&) {\n     }\n     SyncWithValidationInterfaceQueue();"
      }
    ]
  }
]