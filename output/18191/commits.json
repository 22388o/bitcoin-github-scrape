[
  {
    "sha": "8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZTVhYTA4ZGY0ZDBmNTVlYWU4ODQyZDAxYjFhYjNkOWEzYjc0ZmM1",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-01-21T20:44:01Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-06-17T20:33:41Z"
      },
      "message": "Change UpdateForDescendants to use Epochs",
      "tree": {
        "sha": "63ae23950cd436366c99b83127cdf3695e5c0bb7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/63ae23950cd436366c99b83127cdf3695e5c0bb7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd5a02692853f7240a4fdc593d7d0123d7916e45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd5a02692853f7240a4fdc593d7d0123d7916e45",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd5a02692853f7240a4fdc593d7d0123d7916e45"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 80,
      "deletions": 48
    },
    "files": [
      {
        "sha": "d31455b07a942cc3c4b6da18fabc5a9f7b144a46",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 40,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5",
        "patch": "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter& child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter& grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list\n+    for (txiter child_it : new_cache_line) {\n+        const CTxMemPoolEntry& child = *child_it;\n+        modify_size += child.GetTxSize();\n+        modify_fee += child.GetModifiedFee();\n+        modify_count++;\n+        mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n     }\n-    // setAllDescendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int64_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (txiter cit : setAllDescendants) {\n-        if (!setExclude.count(cit->GetTx().GetHash())) {\n-            modifySize += cit->GetTxSize();\n-            modifyFee += cit->GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(cit);\n-            // Update ancestor state for each descendant\n-            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n-        }\n-    }\n-    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n+    mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n }\n \n // vHashesToUpdate is the set of transaction hashes from a disconnected block\n@@ -110,12 +139,11 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n     // in-vHashesToUpdate transactions, so that we don't have to recalculate\n     // descendants when we come across a previously seen entry.\n+    //\n+    // Also use as a set for lookups into vHashesToUpdate (these entries are\n+    // already accounted for in the state of their ancestors)\n     cacheMap mapMemPoolDescendantsToUpdate;\n \n-    // Use a set for lookups into vHashesToUpdate (these entries are already\n-    // accounted for in the state of their ancestors)\n-    std::set<uint256> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n-\n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n     // This maximizes the benefit of the descendant cache and guarantees that\n@@ -139,13 +167,13 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n                 assert(childIter != mapTx.end());\n                 // We can skip updating entries we've encountered before or that\n                 // are in the block (which are already accounted for).\n-                if (!visited(childIter) && !setAlreadyIncluded.count(childHash)) {\n+                if (!visited(childIter) && !mapMemPoolDescendantsToUpdate.count(childIter)) {\n                     UpdateChild(it, childIter, true);\n                     UpdateParent(childIter, it, true);\n                 }\n             }\n         } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded);\n+        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate);\n     }\n }\n "
      },
      {
        "sha": "fad80fbb9f37979d21c6cb9705a0de3bece74937",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=8e5aa08df4d0f55eae8842d01b1ab3d9a3b74fc5",
        "patch": "@@ -530,12 +530,13 @@ class CTxMemPool\n         }\n     };\n     typedef std::set<txiter, CompareIteratorByHash> setEntries;\n+    typedef std::vector<txiter> vecEntries;\n \n     const setEntries & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n-    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n+    typedef std::map<txiter, vecEntries, CompareIteratorByHash> cacheMap;\n \n     struct TxLinks {\n         setEntries parents;\n@@ -706,19 +707,22 @@ class CTxMemPool\n     /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update\n      *  the descendants for a single transaction that has been added to the\n      *  mempool but may have child transactions in the mempool, eg during a\n-     *  chain reorg.  setExclude is the set of descendant transactions in the\n-     *  mempool that must not be accounted for (because any descendants in\n-     *  setExclude were added to the mempool after the transaction being\n-     *  updated and hence their state is already reflected in the parent\n-     *  state).\n+     *  chain reorg.\n      *\n      *  cachedDescendants will be updated with the descendants of the transaction\n      *  being updated, so that future invocations don't need to walk the\n      *  same transaction again, if encountered in another transaction chain.\n+     *\n+     *  cachedDescendants must have an entry for each of the set of descendant\n+     *  transactions in the mempool that must not be accounted for (because any\n+     *  descendants in cache were added to the mempool after the\n+     *  transaction being updated and hence their state is already reflected in\n+     *  the parent state). This is ensured by UpdateTransactionsFromBlock using\n+     *  reverse_iterate.\n+     *\n      */\n     void UpdateForDescendants(txiter updateIt,\n-            cacheMap &cachedDescendants,\n-            const std::set<uint256> &setExclude) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+            cacheMap &cachedDescendants) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Update ancestors of hash to add/remove it as a descendant transaction. */\n     void UpdateAncestorsOf(bool add, txiter hash, setEntries &setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Set ancestor state for an entry */"
      }
    ]
  }
]