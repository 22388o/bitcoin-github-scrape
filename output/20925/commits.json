[
  {
    "sha": "69a7251d05cd41e2804e013679ec371b9a97ba29",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OWE3MjUxZDA1Y2Q0MWUyODA0ZTAxMzY3OWVjMzcxYjlhOTdiYTI5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-13T12:20:41Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-14T11:18:41Z"
      },
      "message": "[net processing] Add peerman_impl.h",
      "tree": {
        "sha": "7e5af50d7ebec672b6552fd063696c7d95e894f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e5af50d7ebec672b6552fd063696c7d95e894f0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69a7251d05cd41e2804e013679ec371b9a97ba29",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a7251d05cd41e2804e013679ec371b9a97ba29",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/69a7251d05cd41e2804e013679ec371b9a97ba29",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a7251d05cd41e2804e013679ec371b9a97ba29/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e7eb37128c3155f074af5f38974934ce6941b0fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7eb37128c3155f074af5f38974934ce6941b0fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e7eb37128c3155f074af5f38974934ce6941b0fb"
      }
    ],
    "stats": {
      "total": 400,
      "additions": 220,
      "deletions": 180
    },
    "files": [
      {
        "sha": "2cdeec083b3b71a4c953baf54faa23bb29e776ba",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a7251d05cd41e2804e013679ec371b9a97ba29/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a7251d05cd41e2804e013679ec371b9a97ba29/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=69a7251d05cd41e2804e013679ec371b9a97ba29",
        "patch": "@@ -179,6 +179,7 @@ BITCOIN_CORE_H = \\\n   noui.h \\\n   optional.h \\\n   outputtype.h \\\n+  peerman_impl.h \\\n   policy/feerate.h \\\n   policy/fees.h \\\n   policy/policy.h \\"
      },
      {
        "sha": "d3df7dca5e8908a1526a487a1243f126458e5732",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 180,
        "changes": 181,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a7251d05cd41e2804e013679ec371b9a97ba29/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a7251d05cd41e2804e013679ec371b9a97ba29/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=69a7251d05cd41e2804e013679ec371b9a97ba29",
        "patch": "@@ -18,6 +18,7 @@\n #include <netmessagemaker.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n+#include <peerman_impl.h>\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n #include <random.h>\n@@ -168,186 +169,6 @@ std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUA\n void EraseOrphansFor(NodeId peer);\n \n // Internal stuff\n-namespace {\n-/**\n- * Data structure for an individual peer. This struct is not protected by\n- * cs_main since it does not contain validation-critical data.\n- *\n- * Memory is owned by shared pointers and this object is destructed when\n- * the refcount drops to zero.\n- *\n- * Mutexes inside this struct must not be held when locking m_peer_mutex.\n- *\n- * TODO: move most members from CNodeState to this structure.\n- * TODO: move remaining application-layer data members from CNode to this structure.\n- */\n-struct Peer {\n-    /** Same id as the CNode object for this peer */\n-    const NodeId m_id{0};\n-\n-    /** Protects misbehavior data members */\n-    Mutex m_misbehavior_mutex;\n-    /** Accumulated misbehavior score for this peer */\n-    int m_misbehavior_score GUARDED_BY(m_misbehavior_mutex){0};\n-    /** Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission). */\n-    bool m_should_discourage GUARDED_BY(m_misbehavior_mutex){false};\n-\n-    /** Protects block inventory data members */\n-    Mutex m_block_inv_mutex;\n-    /** List of blocks that we'll announce via an `inv` message.\n-     * There is no final sorting before sending, as they are always sent\n-     * immediately and in the order requested. */\n-    std::vector<uint256> m_blocks_for_inv_relay GUARDED_BY(m_block_inv_mutex);\n-    /** Unfiltered list of blocks that we'd like to announce via a `headers`\n-     * message. If we can't announce via a `headers` message, we'll fall back to\n-     * announcing via `inv`. */\n-    std::vector<uint256> m_blocks_for_headers_relay GUARDED_BY(m_block_inv_mutex);\n-    /** The final block hash that we sent in an `inv` message to this peer.\n-     * When the peer requests this block, we send an `inv` message to trigger\n-     * the peer to request the next sequence of block hashes.\n-     * Most peers use headers-first syncing, which doesn't use this mechanism */\n-    uint256 m_continuation_block GUARDED_BY(m_block_inv_mutex) {};\n-\n-    /** This peer's reported block height when we connected */\n-    std::atomic<int> m_starting_height{-1};\n-\n-    /** Set of txids to reconsider once their parent transactions have been accepted **/\n-    std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n-\n-    /** Protects m_getdata_requests **/\n-    Mutex m_getdata_requests_mutex;\n-    /** Work queue of items requested by this peer **/\n-    std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n-\n-    explicit Peer(NodeId id) : m_id(id) {}\n-};\n-\n-using PeerRef = std::shared_ptr<Peer>;\n-\n-class PeerManagerImpl final : public PeerManager\n-{\n-public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                    CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                    bool ignore_incoming_txs);\n-\n-    /** Overridden from CValidationInterface. */\n-    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n-    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n-    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n-    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n-    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n-\n-    /** Implement NetEventsInterface */\n-    void InitializeNode(CNode* pnode) override;\n-    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n-    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n-    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n-\n-    /** Implement PeerManager */\n-    void CheckForStaleTipAndEvictPeers() override;\n-    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n-    bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n-    void SetBestHeight(int height) override { m_best_height = height; };\n-    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n-    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n-\n-private:\n-    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n-    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n-    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n-    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n-\n-    /** Get a shared pointer to the Peer object.\n-     *  May return an empty shared_ptr if the Peer object can't be found. */\n-    PeerRef GetPeerRef(NodeId id) const;\n-\n-    /** Get a shared pointer to the Peer object and remove it from m_peer_map.\n-     *  May return an empty shared_ptr if the Peer object can't be found. */\n-    PeerRef RemovePeer(NodeId id);\n-\n-    /**\n-     * Potentially mark a node discouraged based on the contents of a BlockValidationState object\n-     *\n-     * @param[in] via_compact_block this bool is passed in because net_processing should\n-     * punish peers differently depending on whether the data was provided in a compact\n-     * block message or not. If the compact block had a valid header, but contained invalid\n-     * txs, the peer should not be punished. See BIP 152.\n-     *\n-     * @return Returns true if the peer was punished (probably disconnected)\n-     */\n-    bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n-                                 bool via_compact_block, const std::string& message = \"\");\n-\n-    /**\n-     * Potentially disconnect and discourage a node based on the contents of a TxValidationState object\n-     *\n-     * @return Returns true if the peer was punished (probably disconnected)\n-     */\n-    bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message = \"\");\n-\n-    /** Maybe disconnect a peer and discourage future connections from its address.\n-     *\n-     * @param[in]   pnode     The node to check.\n-     * @return                True if the peer was marked for disconnection in this function\n-     */\n-    bool MaybeDiscourageAndDisconnect(CNode& pnode);\n-\n-    void ProcessOrphanTx(std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n-    /** Process a single headers message from a peer. */\n-    void ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n-                               const std::vector<CBlockHeader>& headers,\n-                               bool via_compact_block);\n-\n-    void SendBlockTransactions(CNode& pfrom, const CBlock& block, const BlockTransactionsRequest& req);\n-\n-    /** Register with TxRequestTracker that an INV has been received from a\n-     *  peer. The announcement parameters are decided in PeerManager and then\n-     *  passed to TxRequestTracker. */\n-    void AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n-        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n-\n-    /** Send a version message to a peer */\n-    void PushNodeVersion(CNode& pnode, int64_t nTime);\n-\n-    const CChainParams& m_chainparams;\n-    CConnman& m_connman;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* const m_banman;\n-    ChainstateManager& m_chainman;\n-    CTxMemPool& m_mempool;\n-    TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n-\n-    /** The height of the best chain */\n-    std::atomic<int> m_best_height{-1};\n-\n-    int64_t m_stale_tip_check_time; //!< Next time to check for stale tip\n-\n-    /** Whether this node is running in blocks only mode */\n-    const bool m_ignore_incoming_txs;\n-\n-    /** Whether we've completed initial sync yet, for determining when to turn\n-      * on extra block-relay-only peers. */\n-    bool m_initial_sync_finished{false};\n-\n-    /** Protects m_peer_map. This mutex must not be locked while holding a lock\n-     *  on any of the mutexes inside a Peer object. */\n-    mutable Mutex m_peer_mutex;\n-    /**\n-     * Map of all Peer objects, keyed by peer id. This map is protected\n-     * by the m_peer_mutex. Once a shared pointer reference is\n-     * taken, the lock may be released. Individual fields are protected by\n-     * their own locks.\n-     */\n-    std::map<NodeId, PeerRef> m_peer_map GUARDED_BY(m_peer_mutex);\n-};\n-} // namespace\n-\n namespace {\n     /** Number of nodes with fSyncStarted. */\n     int nSyncStarted GUARDED_BY(cs_main) = 0;"
      },
      {
        "sha": "cbf6537181cabc086d227312e461ef6a0a7299f2",
        "filename": "src/peerman_impl.h",
        "status": "added",
        "additions": 218,
        "deletions": 0,
        "changes": 218,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a7251d05cd41e2804e013679ec371b9a97ba29/src/peerman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a7251d05cd41e2804e013679ec371b9a97ba29/src/peerman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/peerman_impl.h?ref=69a7251d05cd41e2804e013679ec371b9a97ba29",
        "patch": "@@ -0,0 +1,218 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// This file contains internal implementations of Peer and PeerManager. It\n+// should *only* be included by net_processing.cpp and test files.\n+\n+#ifndef BITCOIN_PEERMAN_IMPL_H\n+#define BITCOIN_PEERMAN_IMPL_H\n+\n+#include <net.h>\n+#include <net_processing.h>\n+#include <sync.h>\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <atomic>\n+#include <chrono>\n+#include <deque>\n+#include <memory>\n+#include <set>\n+#include <string>\n+#include <vector>\n+\n+class BanMan;\n+class BlockTransactionsRequest;\n+class BlockValidationState;\n+class CBlock;\n+class CBlockHeader;\n+class CBlockIndex;\n+class CChainParams;\n+class CInv;\n+class CScheduler;\n+class CScheduler;\n+class CTxMemPool;\n+class ChainstateManager;\n+class GenTxid;\n+class TxValidationState;\n+\n+/**\n+ * Data structure for an individual peer. This struct is not protected by\n+ * cs_main since it does not contain validation-critical data.\n+ *\n+ * Memory is owned by shared pointers and this object is destructed when\n+ * the refcount drops to zero.\n+ *\n+ * Mutexes inside this struct must not be held when locking m_peer_mutex.\n+ *\n+ * TODO: move most members from CNodeState to this structure.\n+ * TODO: move remaining application-layer data members from CNode to this structure.\n+ */\n+struct Peer {\n+    /** Same id as the CNode object for this peer */\n+    const NodeId m_id{0};\n+\n+    /** Protects misbehavior data members */\n+    Mutex m_misbehavior_mutex;\n+    /** Accumulated misbehavior score for this peer */\n+    int m_misbehavior_score GUARDED_BY(m_misbehavior_mutex){0};\n+    /** Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission). */\n+    bool m_should_discourage GUARDED_BY(m_misbehavior_mutex){false};\n+\n+    /** Protects block inventory data members */\n+    Mutex m_block_inv_mutex;\n+    /** List of blocks that we'll announce via an `inv` message.\n+     * There is no final sorting before sending, as they are always sent\n+     * immediately and in the order requested. */\n+    std::vector<uint256> m_blocks_for_inv_relay GUARDED_BY(m_block_inv_mutex);\n+    /** Unfiltered list of blocks that we'd like to announce via a `headers`\n+     * message. If we can't announce via a `headers` message, we'll fall back to\n+     * announcing via `inv`. */\n+    std::vector<uint256> m_blocks_for_headers_relay GUARDED_BY(m_block_inv_mutex);\n+    /** The final block hash that we sent in an `inv` message to this peer.\n+     * When the peer requests this block, we send an `inv` message to trigger\n+     * the peer to request the next sequence of block hashes.\n+     * Most peers use headers-first syncing, which doesn't use this mechanism */\n+    uint256 m_continuation_block GUARDED_BY(m_block_inv_mutex) {};\n+\n+    /** This peer's reported block height when we connected */\n+    std::atomic<int> m_starting_height{-1};\n+\n+    /** Set of txids to reconsider once their parent transactions have been accepted **/\n+    std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n+\n+    /** Protects m_getdata_requests **/\n+    Mutex m_getdata_requests_mutex;\n+    /** Work queue of items requested by this peer **/\n+    std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n+\n+    explicit Peer(NodeId id) : m_id(id) {}\n+};\n+\n+using PeerRef = std::shared_ptr<Peer>;\n+\n+class PeerManagerImpl final : public PeerManager\n+{\n+public:\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                    CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                    bool ignore_incoming_txs);\n+\n+    /** Overridden from CValidationInterface. */\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n+    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n+    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+\n+    /** Implement NetEventsInterface */\n+    void InitializeNode(CNode* pnode) override;\n+    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n+    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n+\n+    /** Implement PeerManager */\n+    void CheckForStaleTipAndEvictPeers() override;\n+    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n+    bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n+    void SetBestHeight(int height) override { m_best_height = height; };\n+    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n+    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n+\n+private:\n+    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n+    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n+    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n+    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n+\n+    /** Get a shared pointer to the Peer object.\n+     *  May return an empty shared_ptr if the Peer object can't be found. */\n+    PeerRef GetPeerRef(NodeId id) const;\n+\n+    /** Get a shared pointer to the Peer object and remove it from m_peer_map.\n+     *  May return an empty shared_ptr if the Peer object can't be found. */\n+    PeerRef RemovePeer(NodeId id);\n+\n+    /**\n+     * Potentially mark a node discouraged based on the contents of a BlockValidationState object\n+     *\n+     * @param[in] via_compact_block this bool is passed in because net_processing should\n+     * punish peers differently depending on whether the data was provided in a compact\n+     * block message or not. If the compact block had a valid header, but contained invalid\n+     * txs, the peer should not be punished. See BIP 152.\n+     *\n+     * @return Returns true if the peer was punished (probably disconnected)\n+     */\n+    bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n+                                 bool via_compact_block, const std::string& message = \"\");\n+\n+    /**\n+     * Potentially disconnect and discourage a node based on the contents of a TxValidationState object\n+     *\n+     * @return Returns true if the peer was punished (probably disconnected)\n+     */\n+    bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message = \"\");\n+\n+    /** Maybe disconnect a peer and discourage future connections from its address.\n+     *\n+     * @param[in]   pnode     The node to check.\n+     * @return                True if the peer was marked for disconnection in this function\n+     */\n+    bool MaybeDiscourageAndDisconnect(CNode& pnode);\n+\n+    void ProcessOrphanTx(std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+    /** Process a single headers message from a peer. */\n+    void ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n+                               const std::vector<CBlockHeader>& headers,\n+                               bool via_compact_block);\n+\n+    void SendBlockTransactions(CNode& pfrom, const CBlock& block, const BlockTransactionsRequest& req);\n+\n+    /** Register with TxRequestTracker that an INV has been received from a\n+     *  peer. The announcement parameters are decided in PeerManager and then\n+     *  passed to TxRequestTracker. */\n+    void AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n+        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n+    /** Send a version message to a peer */\n+    void PushNodeVersion(CNode& pnode, int64_t nTime);\n+\n+    const CChainParams& m_chainparams;\n+    CConnman& m_connman;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* const m_banman;\n+    ChainstateManager& m_chainman;\n+    CTxMemPool& m_mempool;\n+    TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n+\n+    /** The height of the best chain */\n+    std::atomic<int> m_best_height{-1};\n+\n+    int64_t m_stale_tip_check_time; //!< Next time to check for stale tip\n+\n+    /** Whether this node is running in blocks only mode */\n+    const bool m_ignore_incoming_txs;\n+\n+    /** Whether we've completed initial sync yet, for determining when to turn\n+      * on extra block-relay-only peers. */\n+    bool m_initial_sync_finished{false};\n+\n+    /** Protects m_peer_map. This mutex must not be locked while holding a lock\n+     *  on any of the mutexes inside a Peer object. */\n+    mutable Mutex m_peer_mutex;\n+    /**\n+     * Map of all Peer objects, keyed by peer id. This map is protected\n+     * by the m_peer_mutex. Once a shared pointer reference is\n+     * taken, the lock may be released. Individual fields are protected by\n+     * their own locks.\n+     */\n+    std::map<NodeId, PeerRef> m_peer_map GUARDED_BY(m_peer_mutex);\n+};\n+\n+#endif // BITCOIN_PEERMAN_IMPL_H"
      }
    ]
  },
  {
    "sha": "687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODcwNjdlZjQxMWE0MGZmMWVlYTI0YmEzY2QzNGZjNmE4Y2QwOGY2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-13T12:24:36Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-14T11:18:45Z"
      },
      "message": "[tests] Use PeerManagerImpl directly in tests",
      "tree": {
        "sha": "836427a286b6ba7b4d080505047cdd851d750e69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/836427a286b6ba7b4d080505047cdd851d750e69"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "69a7251d05cd41e2804e013679ec371b9a97ba29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a7251d05cd41e2804e013679ec371b9a97ba29",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/69a7251d05cd41e2804e013679ec371b9a97ba29"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 13,
      "deletions": 11
    },
    "files": [
      {
        "sha": "b5d4c08a741cefb549787d157f390c03c3dbf271",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
        "patch": "@@ -9,6 +9,7 @@\n #include <chainparams.h>\n #include <net.h>\n #include <net_processing.h>\n+#include <peerman_impl.h>\n #include <pubkey.h>\n #include <script/sign.h>\n #include <script/signingprovider.h>\n@@ -80,8 +81,8 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     const CChainParams& chainparams = Params();\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = MakeUnique<PeerManagerImpl>(chainparams, *connman, nullptr, *m_node.scheduler,\n+                                                 *m_node.chainman, *m_node.mempool, false);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -150,8 +151,8 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     const CChainParams& chainparams = Params();\n     auto connman = MakeUnique<CConnmanTest>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = MakeUnique<PeerManagerImpl>(chainparams, *connman, nullptr, *m_node.scheduler,\n+                                                 *m_node.chainman, *m_node.mempool, false);\n \n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n     CConnman::Options options;\n@@ -224,8 +225,8 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     const CChainParams& chainparams = Params();\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = MakeUnique<PeerManagerImpl>(chainparams, *connman, banman.get(), *m_node.scheduler,\n+                                                 *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -271,8 +272,8 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     const CChainParams& chainparams = Params();\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = MakeUnique<PeerManagerImpl>(chainparams, *connman, banman.get(), *m_node.scheduler,\n+                                                 *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "c7815c348363007a255950519dd474ce42c924e0",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
        "patch": "@@ -16,6 +16,7 @@\n #include <net.h>\n #include <net_processing.h>\n #include <noui.h>\n+#include <peerman_impl.h>\n #include <policy/fees.h>\n #include <pow.h>\n #include <rpc/blockchain.h>\n@@ -192,9 +193,9 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n \n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n-    m_node.peerman = PeerManager::make(chainparams, *m_node.connman, m_node.banman.get(),\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n-                                       false);\n+    m_node.peerman = MakeUnique<PeerManagerImpl>(chainparams, *m_node.connman, m_node.banman.get(),\n+                                                 *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n+                                                 false);\n     {\n         CConnman::Options options;\n         options.m_msgproc = m_node.peerman.get();"
      }
    ]
  },
  {
    "sha": "1363e906ad55035bb529065c4b88dee9dc08ddfb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzYzZTkwNmFkNTUwMzViYjUyOTA2NWM0Yjg4ZGVlOWRjMDhkZGZi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-13T12:29:00Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-14T11:18:45Z"
      },
      "message": "[tests] Move test-only functions out of net_processing.h",
      "tree": {
        "sha": "f27d72757702e53c329e798b0e1a30fb78d76846",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f27d72757702e53c329e798b0e1a30fb78d76846"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1363e906ad55035bb529065c4b88dee9dc08ddfb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1363e906ad55035bb529065c4b88dee9dc08ddfb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1363e906ad55035bb529065c4b88dee9dc08ddfb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1363e906ad55035bb529065c4b88dee9dc08ddfb/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/687067ef411a40ff1eea24ba3cd34fc6a8cd08f6"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 15,
      "deletions": 20
    },
    "files": [
      {
        "sha": "971cca55ba2bca89ea9559a239e5fa594ee735b6",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1363e906ad55035bb529065c4b88dee9dc08ddfb/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1363e906ad55035bb529065c4b88dee9dc08ddfb/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=1363e906ad55035bb529065c4b88dee9dc08ddfb",
        "patch": "@@ -49,23 +49,6 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n \n     /** Set the best height */\n     virtual void SetBestHeight(int height) = 0;\n-\n-    /**\n-     * Increment peer's misbehavior score. If the new value >= DISCOURAGEMENT_THRESHOLD, mark the node\n-     * to be discouraged, meaning the peer might be disconnected and added to the discouragement filter.\n-     * Public for unit testing.\n-     */\n-    virtual void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) = 0;\n-\n-    /**\n-     * Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound.\n-     * Public for unit testing.\n-     */\n-    virtual void CheckForStaleTipAndEvictPeers() = 0;\n-\n-    /** Process a single message from a peer. Public for fuzz testing */\n-    virtual void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                                const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) = 0;\n };\n \n /** Relay transaction to every node */"
      },
      {
        "sha": "91b6feb826fd74a80523c3d1753cf886e132f9cc",
        "filename": "src/peerman_impl.h",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1363e906ad55035bb529065c4b88dee9dc08ddfb/src/peerman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1363e906ad55035bb529065c4b88dee9dc08ddfb/src/peerman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/peerman_impl.h?ref=1363e906ad55035bb529065c4b88dee9dc08ddfb",
        "patch": "@@ -113,13 +113,25 @@ class PeerManagerImpl final : public PeerManager\n     bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n     /** Implement PeerManager */\n-    void CheckForStaleTipAndEvictPeers() override;\n     bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n     bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n     void SetBestHeight(int height) override { m_best_height = height; };\n-    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n+\n+    /** Public for testing */\n+\n+    /**\n+     * Increment peer's misbehavior score. If the new value >= DISCOURAGEMENT_THRESHOLD, mark the node\n+     * to be discouraged, meaning the peer might be disconnected and added to the discouragement filter.\n+     */\n+    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message);\n+\n+    /** Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound. */\n+    void CheckForStaleTipAndEvictPeers();\n+\n+    /** Process a single message from a peer */\n     void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n+                        const std::chrono::microseconds time_received,\n+                        const std::atomic<bool>& interruptMsgProc);\n \n private:\n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */"
      }
    ]
  }
]