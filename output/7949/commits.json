[
  {
    "sha": "ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYTZhM2Y4ODhkZDNmYjhhNDdmYjg1ZDYzYzc2NWFjMDE5MjMxZGZm",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2017-09-28T04:41:57Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2017-10-23T01:28:56Z"
      },
      "message": "Add RPC long poll notifications",
      "tree": {
        "sha": "737ec1623128c980b60274aa90859f5fd59ae0ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/737ec1623128c980b60274aa90859f5fd59ae0ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEyhopCNzi8TB0xizeHrd2uwPHki0FAlntRdkACgkQHrd2uwPH\nki136Q/9Eso6xKJJBCspLbZlbjZD7j5QLCrBNmjyzQDQTQWVcdwuqZVrz1uT8PrU\nTLS59lXcc+HpHQU0+59whG8E0vtF2TBHxu2GUS0GuzlLgMnUjCAbF8PlFRso0IMc\nXY/BVeUpFH0kBOTPXiaaExVnaE9zdqLHf7CPdTrzVOQcM5fQOmiykPGPiFBw9Fvx\nCZq0Lnum/eof0kwwEhHDWmxOeA6maKnG9v7srJD8fhorzlcXlLTdCe3uv1abkBCO\nUXyRIUMd8R4Hc1tfPDd5XT09MSJxCt9jbcxT9P5+HspJtf34TahnH7PRkkkgsNLR\n1aWhIBGeOmcKermPa11Hy6+Qcoz1Vsuyf3pu6bQhvRzmyfDzWbbbqjPb1RGP7GG8\n2a+Uqd/eXEsobwjOQ2w57zNwoqlkt80QNKyMsDZwrg1mqiBKEp9VCXDyPtZphdV6\nBrPIMNkbGQKIHDGeboYbY4igGuQg2Y/TOyky84UxAl7+OF4ASBjsxW2FJyyDdK5q\nM8EdfkSBIHC7dhHyaFMM5g6pvVDNU9ZRqCG0Rf0rMUPF8McUpQhqP4UPLXFkVveQ\nCU/+1dLJHZKOMX/8bUZNn/39NJyFqhbJkFOn4VxDImGyWKyIGuPV0Ucvs+V3pglP\nONBGZxez1dpSrXTuRxIiSPBMrp25SClfHjxu0k3Y5LtWroSNgVs=\n=Prnt\n-----END PGP SIGNATURE-----",
        "payload": "tree 737ec1623128c980b60274aa90859f5fd59ae0ca\nparent ff92fbf24739a022eb677daab03c87c5e6971094\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1506573717 -0700\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1508722136 -1000\n\nAdd RPC long poll notifications\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff92fbf24739a022eb677daab03c87c5e6971094",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff92fbf24739a022eb677daab03c87c5e6971094",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff92fbf24739a022eb677daab03c87c5e6971094"
      }
    ],
    "stats": {
      "total": 402,
      "additions": 402,
      "deletions": 0
    },
    "files": [
      {
        "sha": "fc1cc66a6f58c2183d9a4eee7519f849989c8780",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "patch": "@@ -129,6 +129,7 @@ BITCOIN_CORE_H = \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n   rpc/mining.h \\\n+  rpc/notifications.h \\\n   rpc/protocol.h \\\n   rpc/safemode.h \\\n   rpc/server.h \\\n@@ -210,6 +211,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/mining.cpp \\\n   rpc/misc.cpp \\\n   rpc/net.cpp \\\n+  rpc/notifications.cpp \\\n   rpc/rawtransaction.cpp \\\n   rpc/safemode.cpp \\\n   rpc/server.cpp \\"
      },
      {
        "sha": "5b9c96f19e44aa44a9365c0926965f922e955a46",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "patch": "@@ -32,6 +32,7 @@\n #include \"rpc/register.h\"\n #include \"rpc/safemode.h\"\n #include \"rpc/blockchain.h\"\n+#include \"rpc/notifications.h\"\n #include \"script/standard.h\"\n #include \"script/sigcache.h\"\n #include \"scheduler.h\"\n@@ -1366,6 +1367,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         RegisterValidationInterface(pzmqNotificationInterface);\n     }\n #endif\n+    // register http long poll notifications\n+    RegisterLongPollNotificationsInterface();\n+\n     uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set\n     uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME;\n "
      },
      {
        "sha": "0ba7ad3d1db00baf4d2232610ce60474dc6b1e14",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "patch": "@@ -130,6 +130,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"logging\", 1, \"exclude\" },\n     { \"disconnectnode\", 1, \"nodeid\" },\n     { \"addwitnessaddress\", 1, \"p2sh\" },\n+    { \"setregisterednotifications\", 1, \"type\"},\n+    { \"pollnotifications\", 1, \"timeout\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "1a374d067521ac2c0e86add61e383049e8786f7d",
        "filename": "src/rpc/notifications.cpp",
        "status": "added",
        "additions": 381,
        "deletions": 0,
        "changes": 381,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/notifications.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/notifications.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/notifications.cpp?ref=ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "patch": "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;\n+\n+    NotificationQueue* getQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    NotificationQueue* addQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        m_map_sequence_numbers[clientid] = new NotificationQueue();\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    void NotifyTransaction(const CTransactionRef& ptx)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        for (auto& queueEntry : m_map_sequence_numbers) {\n+            if (!queueEntry.second->isTypeRegistered(NotificationType::Tx)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Tx;\n+            entry.m_notification.setStr(ptx->GetHash().GetHex());\n+            queueEntry.second->addToQueue(entry);\n+        }\n+    }\n+\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction added in the block\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction removed in block disconnection\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockIndex* pindexFork, bool fInitialDownload) override\n+    {\n+        LOCK(m_cs_queue_manager);\n+        BOOST_FOREACH (NotificationQueue* queue, m_map_sequence_numbers | boost::adaptors::map_values) {\n+            if (!queue->isTypeRegistered(NotificationType::Block)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Block;\n+            entry.m_notification.setStr(pindexNew->GetBlockHash().GetHex());\n+            queue->addToQueue(entry);\n+        }\n+    }\n+\n+    void TransactionAddedToMempool(const CTransactionRef& ptx) override\n+    {\n+        NotifyTransaction(ptx);\n+    }\n+};\n+\n+CCriticalSection cs_queueManagerSharedInstance;\n+static NotificationQueueManager* queueManagerSharedInstance = NULL;\n+\n+NotificationQueue* getQueue(const std::string& clientID, bool createIfNotExists)\n+{\n+    LOCK(cs_queueManagerSharedInstance);\n+    NotificationQueue* clientQueue = queueManagerSharedInstance->getQueue(clientID);\n+    if (!clientQueue && !createIfNotExists)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Client UUID not found.\");\n+    if (!clientQueue)\n+        clientQueue = queueManagerSharedInstance->addQueue(clientID);\n+    return clientQueue;\n+}\n+\n+UniValue setregisterednotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 2)\n+        throw std::runtime_error(\n+            \"setregisterednotifications <uuid> [<type>, <type>, ...]\\n\"\n+            \"Register for rpc notification(s).\\n\"\n+            \"Notifications can be polled by calling pollnotifications.\"\n+            \"The client UUID must be unique per client application and will define the used queue.\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"2. \\\"type\\\"         (string, required) The notification type to register for (\\\"hashblock\\\", \\\"hashtx\\\")\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nRegister for block and transaction notifications\\n\" +\n+            HelpExampleCli(\"setregisterednotifications\", \"\\\"[\\\"hashblock\\\", \\\"hashtx\\\"]\\\" \\\"\") +\n+            \"register for transaction and block signals\\n\");\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VARR), true);\n+\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), true);\n+\n+    /* remove all current registered types */\n+    clientQueue->unregisterAllTypes();\n+\n+    UniValue types = request.params[1].get_array();\n+    BOOST_FOREACH (const UniValue& newType, types.getValues()) {\n+        if (!newType.isStr())\n+            continue;\n+\n+        NotificationType type = clientQueue->stringToType(newType.get_str());\n+        if (type == NotificationType::Unknown) {\n+            /* don't register only for a subset of the requested notifications */\n+            clientQueue->unregisterAllTypes();\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Notification type not found\");\n+        }\n+\n+        clientQueue->registerType(type);\n+    }\n+\n+    return NullUniValue;\n+}\n+\n+UniValue getregisterednotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"getregisterednotifications <uuid>\\n\"\n+            \"\\nReturns the currently registered RPC notification types for the given uuid.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"[\\\"\\n\"\n+            \"\\\"  \\\"<signal>\\\"             (string) The registered signal\\n\"\n+            \"\\\"  ,...\\n\"\n+            \"\\\"]\\\"\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate a transaction\\n\" +\n+            HelpExampleCli(\"getregisterednotifications\", \"\") +\n+            \"Get the registered notification types\\n\" + HelpExampleRpc(\"getregisterednotifications\", \"\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR), true);\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), false);\n+\n+    UniValue result = UniValue(UniValue::VARR);\n+    BOOST_FOREACH (NotificationType type, clientQueue->m_registered_notification_types)\n+        result.push_back(clientQueue->typeToString(type));\n+\n+    return result;\n+}\n+\n+UniValue pollnotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"pollnotifications <uuid> <timeout>\\n\"\n+            \"\\nLong poll function to get all available notifications for a given uuid (see setregisterednotifications for how to register for notifications).\\n\"\n+            \"The RPC thread will idle for the via <timeout> defined amount of seconds and/or will immediately response if new notifications are available\\n\"\n+            \"Arguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"2. \\\"timeout\\\"      (numeric, optional) The timeout \\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"[ notification, ... ]\\\"             (object) The notification object\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nPoll notifications for client a8098c1a...\\n\" +\n+            HelpExampleCli(\"pollnotifications\", \"\\\"a8098c1a-f86e-11da-bd1a-00112444be1e\\\" 500\") +\n+            \"Long poll notification (max. 500 seconds)\\n\" + HelpExampleRpc(\"pollnotifications\", \"\\\"a8098c1a-f86e-11da-bd1a-00112444be1e\\\" 500\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM), false);\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), false);\n+\n+    int64_t timeOut = DEFAULT_POLL_TIMEOUT;\n+    if (request.params.size() == 2)\n+        timeOut = request.params[1].get_int64();\n+\n+    int64_t startTime = GetTime();\n+\n+    UniValue result = UniValue(UniValue::VARR);\n+    // allow long polling\n+    while (!ShutdownRequested()) {\n+        if (clientQueue->elementsAvailable()) {\n+            clientQueue->dequeueElements(result);\n+            break;\n+        }\n+        if (startTime + timeOut + (500 / 1000.0) < GetTime())\n+            break;\n+        MilliSleep(500);\n+    }\n+\n+    return result;\n+}\n+\n+static const CRPCCommand commands[] =\n+{ //  category              name                           actor (function)             argNames\n+  //  --------------------- ----------------------------   ---------------------------  ----------\n+    { \"notification\",       \"setregisterednotifications\",  &setregisterednotifications, {\"uuid\",\"type\"} },\n+    { \"notification\",       \"getregisterednotifications\",  &getregisterednotifications, {\"uuid\"} },\n+    { \"notification\",       \"pollnotifications\",           &pollnotifications,          {\"uuid\",\"timeout\"} },\n+\n+};\n+\n+void RegisterLongPollNotificationsRPCCommands(CRPCTable& t)\n+{\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++) {\n+        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n+    }\n+}\n+\n+void RegisterLongPollNotificationsInterface()\n+{\n+    LOCK(cs_queueManagerSharedInstance);\n+    if (!queueManagerSharedInstance) {\n+        queueManagerSharedInstance = new NotificationQueueManager();\n+        RegisterValidationInterface(queueManagerSharedInstance);\n+    }\n+}"
      },
      {
        "sha": "2040a9fef51cea4b9ea21967971e8c8fea2e934e",
        "filename": "src/rpc/notifications.h",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/notifications.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/notifications.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/notifications.h?ref=ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_NOTIFICATIONS_H\n+#define BITCOIN_RPC_NOTIFICATIONS_H\n+\n+void RegisterLongPollNotificationsInterface();\n+\n+#endif //BITCOIN_RPC_NOTIFICATIONS_H"
      },
      {
        "sha": "de1a8576df5cc71c7391de50d42130030c69bf25",
        "filename": "src/rpc/register.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/register.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca6a3f888dd3fb8a47fb85d63c765ac019231dff/src/rpc/register.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/register.h?ref=ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "patch": "@@ -19,6 +19,8 @@ void RegisterMiscRPCCommands(CRPCTable &tableRPC);\n void RegisterMiningRPCCommands(CRPCTable &tableRPC);\n /** Register raw transaction RPC commands */\n void RegisterRawTransactionRPCCommands(CRPCTable &tableRPC);\n+/** Register long poll notifications RPC commands */\n+void RegisterLongPollNotificationsRPCCommands(CRPCTable &tableRPC);\n \n static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n {\n@@ -27,6 +29,7 @@ static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n     RegisterMiscRPCCommands(t);\n     RegisterMiningRPCCommands(t);\n     RegisterRawTransactionRPCCommands(t);\n+    RegisterLongPollNotificationsRPCCommands(t);\n }\n \n #endif"
      }
    ]
  },
  {
    "sha": "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNjUyYzU1YjdhOGE2NWJiZGI4YWQ3YzA5ZGNiMDk4NzBhYTkxM2Yz",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2017-10-20T05:57:45Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2017-10-23T01:29:01Z"
      },
      "message": "[QA] Add rpcnotification test",
      "tree": {
        "sha": "da4316e0e7210ce4d73d046d7720f8672a74c75f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/da4316e0e7210ce4d73d046d7720f8672a74c75f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEyhopCNzi8TB0xizeHrd2uwPHki0FAlntRd0ACgkQHrd2uwPH\nki33Cg//VImxDgmUPZ+8nwCnmPufc1qh8D0hFX4RFHkA2KOpLNoymreAJ1BciwMD\ntxQGxuaiESIMA2acgZy9hPDjY3v7UCxU0kIyniiS1/QyoXaWDriFH+v+P3f97MIL\nI26eoRZRZ81eqCTv4dvU+AneiUjwqBlrQ1PNLA12LWm32qQLhr0MInikvTK5Bii7\nozE5G6jQWsX4BIs+3myPXb7wXf5WHkk3wzfkHAJwZSr76khiUMiXCmzb3Cljcw9q\nF5lnVJzC3WYaEABxp4VIl2irIY+Mag3LTNpnIz7Fw5eZSFYaABZbYvJhV/TLKiC1\nUSe+2Mm/brAuFL2S3bbVuLZyYCRKHw8REjO3f/DcytJJP1vAvQmdX2psPVKwbuy0\nTN+arekGP2wTucXvTP31mkYncBFeh+7gzkBeuA8rTncJ+z9T8ydP7ZyLnos++/qu\n/svD6hSFY3zKNircbRsVkbf+qHUt6MU0SWW9KzDDYY8DAndD1U4cL6+Dq3gPavM+\nHBIOkNIGctJUAjsMjyAixnZqgBJPDQqAuhGAQgTbe6ea6q4yaz6frq0XX0N4h7+p\ntz3F/LmrBHs95qwUEcFDqGA0eT4fTFWFMYsgFzsuYKO+DB2Si8scki+EDM5rzHMt\ncljjsJYpK1KCFqQ+EcDysiZhSlLU6W4l7Voqp5l1h2hehJsL5IA=\n=fqfr\n-----END PGP SIGNATURE-----",
        "payload": "tree da4316e0e7210ce4d73d046d7720f8672a74c75f\nparent ca6a3f888dd3fb8a47fb85d63c765ac019231dff\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1508479065 -0700\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1508722141 -1000\n\n[QA] Add rpcnotification test\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca6a3f888dd3fb8a47fb85d63c765ac019231dff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca6a3f888dd3fb8a47fb85d63c765ac019231dff"
      }
    ],
    "stats": {
      "total": 103,
      "additions": 103,
      "deletions": 0
    },
    "files": [
      {
        "sha": "56cfa322f096d836e92f2df6795e16a5928e863a",
        "filename": "test/functional/rpcnotifications.py",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3/test/functional/rpcnotifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3/test/functional/rpcnotifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcnotifications.py?ref=2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
        "patch": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Exercise the rpc signals API\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import threading\n+import uuid\n+\n+class pollThread (threading.Thread):\n+    def __init__(self, threadID, node, clientUUID):\n+        threading.Thread.__init__(self)\n+        self.threadID = threadID\n+        self.node = node\n+        self.uuid = clientUUID\n+    def run(self):\n+        self.node.pollnotifications(self.uuid, 5)\n+\n+class RpcSignalsTest(BitcoinTestFramework):\n+\n+    def pollthread(self, node):\n+        print(\"thread\")\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def run_test (self):\n+        self.nodes[0].generate(100)\n+        client0UUID = str(uuid.uuid1())\n+        client1UUID = str(uuid.uuid1())\n+        client2UUID = str(uuid.uuid1())\n+        assert_raises_jsonrpc(-8, \"Client UUID not found\", self.nodes[0].getregisterednotifications, client0UUID)\n+\n+        self.nodes[0].setregisterednotifications(client0UUID, [\"hashblock\", \"hashtx\"])\n+        data = self.nodes[0].getregisterednotifications(client0UUID)\n+        assert(\"hashblock\" in data)\n+        assert(\"hashtx\" in data)\n+\n+        self.nodes[0].setregisterednotifications(client1UUID, [\"hashtx\"])\n+        data = self.nodes[0].getregisterednotifications(client1UUID)\n+        assert(\"hashblock\" not in data)\n+        assert(\"hashtx\" in data)\n+\n+        self.nodes[0].setregisterednotifications(client2UUID, [\"hashblock\"])\n+\n+        minedblockhash = self.nodes[0].generate(1)[0]\n+        data = self.nodes[0].pollnotifications(client0UUID, 10)\n+        assert(len(data) == 2)\n+\n+        # poll via thread (5 sec poll)\n+        myThread = pollThread(1, self.nodes[0], client0UUID)\n+        myThread.start()\n+        time.sleep(3)\n+        # thread must still be polling\n+        assert(myThread.isAlive() == True)\n+        time.sleep(5)\n+        # thread poll time must be expired\n+        assert(myThread.isAlive() == False)\n+        myThread.join()\n+\n+        # test mempool transactions\n+        txid0 = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        txid1 = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        data = self.nodes[0].pollnotifications(client0UUID, 10)\n+        assert(len(data) == 2)\n+        assert(data[0]['type'] == \"hashtx\")\n+        assert(data[0]['obj'] == txid0)\n+        assert(data[0]['seq'] == 2)\n+        assert(data[1]['type'] == \"hashtx\")\n+        assert(data[1]['obj'] == txid1)\n+        assert(data[1]['seq'] == 3)\n+\n+        # test second queue with tx only\n+        data = self.nodes[0].pollnotifications(client1UUID, 10)\n+        assert(len(data) == 3)\n+        assert(data[0]['type'] == \"hashtx\")\n+        assert(data[1]['type'] == \"hashtx\")\n+        assert(data[2]['type'] == \"hashtx\")\n+        assert(data[2]['seq'] == 3)\n+\n+        # test if only hashblock reqistered queue has the right content\n+        data = self.nodes[0].pollnotifications(client2UUID, 10)\n+        assert(len(data) == 1)\n+        assert(data[0]['type'] == \"hashblock\")\n+        assert(data[0]['obj'] == minedblockhash)\n+        assert(data[0]['seq'] == 1)\n+\n+        # test unregister\n+        self.nodes[0].setregisterednotifications(client0UUID, [])\n+        data = self.nodes[0].getregisterednotifications(client0UUID)\n+        assert(len(data) == 0)\n+        self.nodes[0].generate(1)\n+        data = self.nodes[0].pollnotifications(client0UUID, 5)\n+        assert(len(data) == 0)\n+\n+if __name__ == '__main__':\n+    RpcSignalsTest().main()\n+"
      },
      {
        "sha": "06f80d69933e7d477438cdba5eef33f7dc7fdfc8",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
        "patch": "@@ -125,6 +125,7 @@\n     'minchainwork.py',\n     'p2p-fingerprint.py',\n     'uacomment.py',\n+    'rpcnotifications.py',\n ]\n \n EXTENDED_SCRIPTS = ["
      }
    ]
  }
]