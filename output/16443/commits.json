[
  {
    "sha": "fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWU2YWI2YWVkM2I5ZmRjOTIwMWJiMTlhMzA3ZGZjM2Q5Yjg5ODkx",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-24T15:45:04Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-08-06T17:13:06Z"
      },
      "message": "refactor: pcoinsTip -> CChainState::CoinsTip()\n\nThis aliasing makes subsequent commits easier to review; eventually CoinsTip()\nwill return the CCoinsViewCache managed by CChainState.",
      "tree": {
        "sha": "32136f410bdb26e8c414caddf9e3c86dbf45a8db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32136f410bdb26e8c414caddf9e3c86dbf45a8db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e5fdda68c6d2313edb74443f0d1e6d2ce2d97f5e"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 70,
      "deletions": 58
    },
    "files": [
      {
        "sha": "fc49817502f5595c8c14f64b9f53bf4393c71b41",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -232,7 +232,7 @@ class NodeImpl : public Node\n     bool getUnspentOutput(const COutPoint& output, Coin& coin) override\n     {\n         LOCK(::cs_main);\n-        return ::pcoinsTip->GetCoin(output, coin);\n+        return ::ChainstateActive().CoinsTip().GetCoin(output, coin);\n     }\n     std::string getWalletDir() override\n     {"
      },
      {
        "sha": "7f2c5720d6e6b0b605231b3884a585f14542eb10",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -1291,11 +1291,12 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 LOCK(g_cs_orphans);\n                 if (mapOrphanTransactions.count(inv.hash)) return true;\n             }\n+            const CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n \n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n-                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n-                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n+                   coins_cache.HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   coins_cache.HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n@@ -1844,7 +1845,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             EraseOrphanTx(orphanHash);\n             done = true;\n         }\n-        mempool.check(pcoinsTip.get());\n+        mempool.check(&::ChainstateActive().CoinsTip());\n     }\n }\n \n@@ -2497,7 +2498,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!AlreadyHave(inv) &&\n             AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-            mempool.check(pcoinsTip.get());\n+            mempool.check(&::ChainstateActive().CoinsTip());\n             RelayTransaction(tx.GetHash(), *connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));"
      },
      {
        "sha": "ad8d1d3af44d61729d2b6af568de80b7ea628a14",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -10,8 +10,7 @@\n void FindCoins(std::map<COutPoint, Coin>& coins)\n {\n     LOCK2(cs_main, ::mempool.cs);\n-    assert(pcoinsTip);\n-    CCoinsViewCache& chain_view = *::pcoinsTip;\n+    CCoinsViewCache& chain_view = ::ChainstateActive().CoinsTip();\n     CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n     for (auto& coin : coins) {\n         if (!mempool_view.GetCoin(coin.first, coin.second)) {"
      },
      {
        "sha": "037576b8284688a1552a4e5a9ebe13eee775903e",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -25,7 +25,7 @@ TransactionError BroadcastTransaction(const CTransactionRef tx, std::string& err\n     LOCK(cs_main);\n     // If the transaction is already confirmed in the chain, don't do anything\n     // and return early.\n-    CCoinsViewCache &view = *pcoinsTip;\n+    CCoinsViewCache &view = ::ChainstateActive().CoinsTip();\n     for (size_t o = 0; o < tx->vout.size(); o++) {\n         const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n         // IsSpent doesnt mean the coin is spent, it means the output doesnt' exist."
      },
      {
        "sha": "2c4d47554267e847803a4620a5d68f6b95d78e92",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -503,12 +503,12 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         if (fCheckMemPool) {\n             // use db+mempool as cache backend in case user likes to query mempool\n             LOCK2(cs_main, mempool.cs);\n-            CCoinsViewCache& viewChain = *pcoinsTip;\n+            CCoinsViewCache& viewChain = ::ChainstateActive().CoinsTip();\n             CCoinsViewMemPool viewMempool(&viewChain, mempool);\n             process_utxos(viewMempool, mempool);\n         } else {\n             LOCK(cs_main);  // no need to lock mempool!\n-            process_utxos(*pcoinsTip, CTxMemPool());\n+            process_utxos(::ChainstateActive().CoinsTip(), CTxMemPool());\n         }\n \n         for (size_t i = 0; i < hits.size(); ++i) {"
      },
      {
        "sha": "c35c478f33979aaa8e599bd3d11700cbc9d08569",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -1126,19 +1126,21 @@ UniValue gettxout(const JSONRPCRequest& request)\n         fMempool = request.params[2].get_bool();\n \n     Coin coin;\n+    CCoinsViewCache* coins_view = &::ChainstateActive().CoinsTip();\n+\n     if (fMempool) {\n         LOCK(mempool.cs);\n-        CCoinsViewMemPool view(pcoinsTip.get(), mempool);\n+        CCoinsViewMemPool view(coins_view, mempool);\n         if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {\n             return NullUniValue;\n         }\n     } else {\n-        if (!pcoinsTip->GetCoin(out, coin)) {\n+        if (!coins_view->GetCoin(out, coin)) {\n             return NullUniValue;\n         }\n     }\n \n-    const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n+    const CBlockIndex* pindex = LookupBlockIndex(coins_view->GetBestBlock());\n     ret.pushKV(\"bestblock\", pindex->GetBlockHash().GetHex());\n     if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.pushKV(\"confirmations\", 0);\n@@ -1180,7 +1182,8 @@ static UniValue verifychain(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n         nCheckDepth = request.params[1].get_int();\n \n-    return CVerifyDB().VerifyDB(Params(), pcoinsTip.get(), nCheckLevel, nCheckDepth);\n+    return CVerifyDB().VerifyDB(\n+        Params(), &::ChainstateActive().CoinsTip(), nCheckLevel, nCheckDepth);\n }\n \n /** Implementation of IsSuperMajority with better feedback */"
      },
      {
        "sha": "ffbad457142dec413ec54f9cd5f50fa8bf8ac6c1",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -259,7 +259,7 @@ static UniValue gettxoutproof(const JSONRPCRequest& request)\n \n         // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n         for (const auto& tx : setTxids) {\n-            const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n+            const Coin& coin = AccessByTxid(::ChainstateActive().CoinsTip(), tx);\n             if (!coin.IsSpent()) {\n                 pblockindex = ::ChainActive()[coin.nHeight];\n                 break;\n@@ -636,7 +636,7 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     {\n         LOCK(cs_main);\n         LOCK(mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n@@ -1505,7 +1505,7 @@ UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n     CCoinsViewCache view(&viewDummy);\n     {\n         LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n "
      },
      {
        "sha": "c9661b730d9528f0726c438284a6056a249aed96",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -372,7 +372,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n         next->phashBlock = new uint256(InsecureRand256());\n-        pcoinsTip->SetBestBlock(next->GetBlockHash());\n+        ::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -384,7 +384,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n         next->phashBlock = new uint256(InsecureRand256());\n-        pcoinsTip->SetBestBlock(next->GetBlockHash());\n+        ::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -414,7 +414,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (::ChainActive().Tip()->nHeight > nHeight) {\n         CBlockIndex* del = ::ChainActive().Tip();\n         ::ChainActive().SetTip(del->pprev);\n-        pcoinsTip->SetBestBlock(del->pprev->GetBlockHash());\n+        ::ChainstateActive().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n         delete del->phashBlock;\n         delete del;\n     }"
      },
      {
        "sha": "e69ebcc2c37844192fa71939701418b132b0bbd7",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -97,7 +97,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK_EQUAL(mempool.size(), 0U);\n }\n \n-// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n+// Run CheckInputs (using CoinsTip()) on the given transaction, for all script\n // flags.  Test that CheckInputs passes for all flags that don't overlap with\n // the failing_flags argument, but otherwise fails.\n // CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n@@ -125,7 +125,7 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n             // WITNESS requires P2SH\n             test_flags |= SCRIPT_VERIFY_P2SH;\n         }\n-        bool ret = CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, nullptr);\n+        bool ret = CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, nullptr);\n         // CheckInputs should succeed iff test_flags doesn't intersect with\n         // failing_flags\n         bool expected_return_value = !(test_flags & failing_flags);\n@@ -135,13 +135,13 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n         if (ret && add_to_cache) {\n             // Check that we get a cache hit if the tx was valid\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK(scriptchecks.empty());\n         } else {\n             // Check that we get script executions to check, if the transaction\n             // was invalid, or we didn't add to cache.\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n         }\n     }\n@@ -204,13 +204,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n@@ -227,7 +227,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n     LOCK(cs_main);\n     BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() == block.GetHash());\n-    BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n+    BOOST_CHECK(::ChainstateActive().CoinsTip().GetBestBlock() == block.GetHash());\n \n     // Test P2SH: construct a transaction that is valid without P2SH, and\n     // then test validity with P2SH.\n@@ -272,7 +272,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -300,7 +300,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n@@ -362,12 +362,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      },
      {
        "sha": "6e5ba445d3da1b836452c808b1d3488ea919e606",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -497,7 +497,7 @@ class CTxMemPool\n      *\n      * 1. Locking both `cs_main` and `mempool.cs` will give a view of mempool\n      *    that is consistent with current chain tip (`::ChainActive()` and\n-     *    `pcoinsTip`) and is fully populated. Fully populated means that if the\n+     *    `CoinsTip()`) and is fully populated. Fully populated means that if the\n      *    current active chain is missing transactions that were present in a\n      *    previously active chain, all the missing transactions will have been\n      *    re-added to the mempool and should be present if they meet size and"
      },
      {
        "sha": "f9d38a30994cc0e6f135f639eb767ccdbef07d76",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 22,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -260,8 +260,8 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n         lockPair.second = lp->time;\n     }\n     else {\n-        // pcoinsTip contains the UTXO set for ::ChainActive().Tip()\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+        // CoinsTip() contains the UTXO set for ::ChainActive().Tip()\n+        CCoinsViewMemPool viewMemPool(&::ChainstateActive().CoinsTip(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n@@ -320,7 +320,7 @@ static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age)\n     std::vector<COutPoint> vNoSpendsRemaining;\n     pool.TrimToSize(limit, &vNoSpendsRemaining);\n     for (const COutPoint& removed : vNoSpendsRemaining)\n-        pcoinsTip->Uncache(removed);\n+        ::ChainstateActive().CoinsTip().Uncache(removed);\n }\n \n static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -382,7 +382,7 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n     mempool.UpdateTransactionsFromBlock(vHashUpdate);\n \n     // We also need to remove any now-immature transactions\n-    mempool.removeForReorg(pcoinsTip.get(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    mempool.removeForReorg(&::ChainstateActive().CoinsTip(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     // Re-limit mempool size, in case we added any transactions\n     LimitMempoolSize(mempool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n@@ -414,7 +414,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n             assert(txFrom->vout.size() > txin.prevout.n);\n             assert(txFrom->vout[txin.prevout.n] == coin.out);\n         } else {\n-            const Coin& coinFromDisk = pcoinsTip->AccessCoin(txin.prevout);\n+            const Coin& coinFromDisk = ::ChainstateActive().CoinsTip().AccessCoin(txin.prevout);\n             assert(!coinFromDisk.IsSpent());\n             assert(coinFromDisk.out == coin.out);\n         }\n@@ -514,12 +514,13 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         CCoinsViewCache view(&dummy);\n \n         LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+        CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+        CCoinsViewMemPool viewMemPool(&coins_cache, pool);\n         view.SetBackend(viewMemPool);\n \n         // do all inputs exist?\n         for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n                 coins_to_uncache.push_back(txin.prevout);\n             }\n \n@@ -530,7 +531,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 // Are inputs missing because we already have the tx?\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n                         return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n@@ -860,7 +861,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n         // (`CCoinsViewCache::cacheCoins`).\n \n         for (const COutPoint& hashTx : coins_to_uncache)\n-            pcoinsTip->Uncache(hashTx);\n+            ::ChainstateActive().CoinsTip().Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n@@ -2014,7 +2015,7 @@ bool CChainState::FlushStateToDisk(\n             nLastFlush = nNow;\n         }\n         int64_t nMempoolSizeMax = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n-        int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n+        int64_t cacheSize = CoinsTip().DynamicMemoryUsage();\n         int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n         // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n         bool fCacheLarge = mode == FlushStateMode::PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n@@ -2058,17 +2059,17 @@ bool CChainState::FlushStateToDisk(\n             nLastWrite = nNow;\n         }\n         // Flush best chain related state. This can only be done if the blocks / block index write was also done.\n-        if (fDoFullFlush && !pcoinsTip->GetBestBlock().IsNull()) {\n+        if (fDoFullFlush && !CoinsTip().GetBestBlock().IsNull()) {\n             // Typical Coin structures on disk are around 48 bytes in size.\n             // Pushing a new one to the database can cause it to be written\n             // twice (once in the log, and once in the tables). This is already\n             // an overestimation, as most will delete an existing entry or\n             // overwrite one. Still, use a conservative safety factor of 2.\n-            if (!CheckDiskSpace(GetDataDir(), 48 * 2 * 2 * pcoinsTip->GetCacheSize())) {\n+            if (!CheckDiskSpace(GetDataDir(), 48 * 2 * 2 * CoinsTip().GetCacheSize())) {\n                 return AbortNode(state, \"Disk space is too low!\", _(\"Error: Disk space is too low!\").translated, CClientUIInterface::MSG_NOPREFIX);\n             }\n             // Flush the chainstate (which may refer to block index entries).\n-            if (!pcoinsTip->Flush())\n+            if (!CoinsTip().Flush())\n                 return AbortNode(state, \"Failed to write to coin database\");\n             nLastFlush = nNow;\n             full_flush_completed = true;\n@@ -2162,7 +2163,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight, pindexNew->nVersion,\n       log(pindexNew->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n       FormatISO8601DateTime(pindexNew->GetBlockTime()),\n-      GuessVerificationProgress(chainParams.TxData(), pindexNew), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize());\n+      GuessVerificationProgress(chainParams.TxData(), pindexNew), ::ChainstateActive().CoinsTip().DynamicMemoryUsage() * (1.0 / (1<<20)), ::ChainstateActive().CoinsTip().GetCacheSize());\n     if (!warningMessages.empty())\n         LogPrintf(\" warning='%s'\", warningMessages); /* Continued */\n     LogPrintf(\"\\n\");\n@@ -2191,7 +2192,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n     // Apply the block atomically to the chain state.\n     int64_t nStart = GetTimeMicros();\n     {\n-        CCoinsViewCache view(pcoinsTip.get());\n+        CCoinsViewCache view(&CoinsTip());\n         assert(view.GetBestBlock() == pindexDelete->GetBlockHash());\n         if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n@@ -2319,7 +2320,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     int64_t nTime3;\n     LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * MILLI, nTimeReadFromDisk * MICRO);\n     {\n-        CCoinsViewCache view(pcoinsTip.get());\n+        CCoinsViewCache view(&CoinsTip());\n         bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);\n         GetMainSignals().BlockChecked(blockConnecting, state);\n         if (!rv) {\n@@ -2506,7 +2507,7 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n         // any disconnected transactions back to the mempool.\n         UpdateMempoolForReorg(disconnectpool, true);\n     }\n-    mempool.check(pcoinsTip.get());\n+    mempool.check(&CoinsTip());\n \n     // Callbacks/notifications for a new best chain.\n     if (fInvalidFound)\n@@ -3508,7 +3509,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n {\n     AssertLockHeld(cs_main);\n     assert(pindexPrev && pindexPrev == ::ChainActive().Tip());\n-    CCoinsViewCache viewNew(pcoinsTip.get());\n+    CCoinsViewCache viewNew(&::ChainstateActive().CoinsTip());\n     uint256 block_hash(block.GetHash());\n     CBlockIndex indexDummy(block);\n     indexDummy.pprev = pindexPrev;\n@@ -3861,12 +3862,14 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_RE\n bool LoadChainTip(const CChainParams& chainparams)\n {\n     AssertLockHeld(cs_main);\n-    assert(!pcoinsTip->GetBestBlock().IsNull()); // Never called when the coins view is empty\n+    const CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+    assert(!coins_cache.GetBestBlock().IsNull()); // Never called when the coins view is empty\n \n-    if (::ChainActive().Tip() && ::ChainActive().Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return true;\n+    if (::ChainActive().Tip() &&\n+        ::ChainActive().Tip()->GetBlockHash() == coins_cache.GetBestBlock()) return true;\n \n     // Load pointer to end of best chain\n-    CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n+    CBlockIndex* pindex = LookupBlockIndex(coins_cache.GetBestBlock());\n     if (!pindex) {\n         return false;\n     }\n@@ -3943,7 +3946,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n             }\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n-        if (nCheckLevel >= 3 && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n+        if (nCheckLevel >= 3 && (coins.DynamicMemoryUsage() + ::ChainstateActive().CoinsTip().DynamicMemoryUsage()) <= nCoinCacheUsage) {\n             assert(coins.GetBestBlock() == pindex->GetBlockHash());\n             DisconnectResult res = ::ChainstateActive().DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {"
      },
      {
        "sha": "6661369bf8170a61019879faf4f760596ec8dc3b",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -505,6 +505,9 @@ class BlockManager {\n         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n+/** Global variable that points to the active CCoinsView (protected by cs_main) */\n+extern std::unique_ptr<CCoinsViewCache> pcoinsTip;\n+\n /**\n  * CChainState stores and provides an API to update our local knowledge of the\n  * current best chain.\n@@ -566,6 +569,12 @@ class CChainState {\n      */\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n \n+    //! @returns A reference to the in-memory cache of the UTXO set.\n+    CCoinsViewCache& CoinsTip()\n+    {\n+        return *::pcoinsTip;\n+    }\n+\n     /**\n      * Update the on-disk chain state.\n      * The caches and indexes are flushed depending on the mode we're called with\n@@ -662,9 +671,6 @@ BlockMap& BlockIndex();\n /** Global variable that points to the coins database (protected by cs_main) */\n extern std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n \n-/** Global variable that points to the active CCoinsView (protected by cs_main) */\n-extern std::unique_ptr<CCoinsViewCache> pcoinsTip;\n-\n /** Global variable that points to the active block tree (protected by cs_main) */\n extern std::unique_ptr<CBlockTreeDB> pblocktree;\n "
      },
      {
        "sha": "b86f6af4ca8d750dc79f646621e00c237824fc70",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "patch": "@@ -58,7 +58,7 @@ def set_test_params(self):\n         self.base_args = [\"-limitdescendantsize=0\", \"-maxmempool=0\", \"-rpcservertimeout=900\", \"-dbbatchsize=200000\"]\n \n         # Set different crash ratios and cache sizes.  Note that not all of\n-        # -dbcache goes to pcoinsTip.\n+        # -dbcache goes to the in-memory coins cache.\n         self.node0_args = [\"-dbcrashratio=8\", \"-dbcache=4\"] + self.base_args\n         self.node1_args = [\"-dbcrashratio=16\", \"-dbcache=8\"] + self.base_args\n         self.node2_args = [\"-dbcrashratio=24\", \"-dbcache=16\"] + self.base_args"
      }
    ]
  },
  {
    "sha": "569353068568444a25b301bbd6513bb510157dc9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NjkzNTMwNjg1Njg0NDRhMjViMzAxYmJkNjUxM2JiNTEwMTU3ZGM5",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-24T17:23:48Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-08-15T15:04:10Z"
      },
      "message": "refactor: have CCoins* data managed under CChainState\n\nThis change encapsulates UTXO set data within CChainState instances, removing\nglobal data `pcoinsTip` and `pcoinsviewdb`. This is necessary if we want to\nmaintain multiple chainstates with their own rendering of the UTXO set.\n\nWe introduce a class CoinsViews which consolidates the construction of a\nCCoins* hierarchy. Construction of its various pieces (db, coinscatcher,\nin-memory cache) is split up so that we avoid flushing bad state to disk if\nstartup is interrupted.\n\nWe also introduce `CChainState::CanFlushToDisk()` which tells us when it is\nsafe to flush the chainstate based on this partial construction.\n\nThis commit could be broken into smaller pieces, but it would require more\nephemeral diffs to, e.g., temporarily change CCoinsViewDB's constructor\ninvocations.\n\nOther changes:\n\n- A parameter has been added to the CCoinsViewDB constructor that allows the\n  name of the corresponding leveldb directory to be specified.\n\nThanks to Russell Yanofsky and Marco Falke for helpful feedback.",
      "tree": {
        "sha": "72a8ffd5e3cbdbc71f5f4957dbb2feab55f6b2c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/72a8ffd5e3cbdbc71f5f4957dbb2feab55f6b2c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/569353068568444a25b301bbd6513bb510157dc9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/569353068568444a25b301bbd6513bb510157dc9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/569353068568444a25b301bbd6513bb510157dc9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/569353068568444a25b301bbd6513bb510157dc9/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fae6ab6aed3b9fdc9201bb19a307dfc3d9b89891"
      }
    ],
    "stats": {
      "total": 213,
      "additions": 170,
      "deletions": 43
    },
    "files": [
      {
        "sha": "50ae0c6252efd180358c28b38dea617e979a7aa1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 21,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -15,7 +15,6 @@\n #include <blockfilter.h>\n #include <chain.h>\n #include <chainparams.h>\n-#include <coins.h>\n #include <compat/sanity.h>\n #include <consensus/validation.h>\n #include <fs.h>\n@@ -149,7 +148,6 @@ NODISCARD static bool CreatePidFile()\n // shutdown thing.\n //\n \n-static std::unique_ptr<CCoinsViewErrorCatcher> pcoinscatcher;\n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n static boost::thread_group threadGroup;\n@@ -234,8 +232,11 @@ void Shutdown(InitInterfaces& interfaces)\n     }\n \n     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n-    if (pcoinsTip != nullptr) {\n-        ::ChainstateActive().ForceFlushStateToDisk();\n+    //\n+    // g_chainstate is referenced here directly (instead of ::ChainstateActive()) because it\n+    // may not have been initialized yet.\n+    if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n+        g_chainstate->ForceFlushStateToDisk();\n     }\n \n     // After there are no more peers/RPC left to give us new data which may generate\n@@ -250,12 +251,10 @@ void Shutdown(InitInterfaces& interfaces)\n \n     {\n         LOCK(cs_main);\n-        if (pcoinsTip != nullptr) {\n-            ::ChainstateActive().ForceFlushStateToDisk();\n+        if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n+            g_chainstate->ForceFlushStateToDisk();\n+            g_chainstate->ResetCoinsViews();\n         }\n-        pcoinsTip.reset();\n-        pcoinscatcher.reset();\n-        pcoinsdbview.reset();\n         pblocktree.reset();\n     }\n     for (const auto& client : interfaces.chain_clients) {\n@@ -1466,10 +1465,10 @@ bool AppInitMain(InitInterfaces& interfaces)\n             bool is_coinsview_empty;\n             try {\n                 LOCK(cs_main);\n+                // This statement makes ::ChainstateActive() usable.\n+                g_chainstate = MakeUnique<CChainState>();\n                 UnloadBlockIndex();\n-                pcoinsTip.reset();\n-                pcoinsdbview.reset();\n-                pcoinscatcher.reset();\n+\n                 // new CBlockTreeDB tries to delete the existing file, which\n                 // fails if it's still open from the previous loop. Close it first:\n                 pblocktree.reset();\n@@ -1520,33 +1519,38 @@ bool AppInitMain(InitInterfaces& interfaces)\n                 // At this point we're either in reindex or we've loaded a useful\n                 // block tree into BlockIndex()!\n \n-                pcoinsdbview.reset(new CCoinsViewDB(nCoinDBCache, false, fReset || fReindexChainState));\n-                pcoinscatcher.reset(new CCoinsViewErrorCatcher(pcoinsdbview.get()));\n-                pcoinscatcher->AddReadErrCallback([]() {\n+                ::ChainstateActive().InitCoinsDB(\n+                    /* cache_size_bytes */ nCoinDBCache,\n+                    /* in_memory */ false,\n+                    /* should_wipe */ fReset || fReindexChainState);\n+\n+                ::ChainstateActive().CoinsErrorCatcher().AddReadErrCallback([]() {\n                     uiInterface.ThreadSafeMessageBox(\n                         _(\"Error reading from database, shutting down.\").translated,\n                         \"\", CClientUIInterface::MSG_ERROR);\n                 });\n \n                 // If necessary, upgrade from older database format.\n                 // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!pcoinsdbview->Upgrade()) {\n+                if (!::ChainstateActive().CoinsDB().Upgrade()) {\n                     strLoadError = _(\"Error upgrading chainstate database\").translated;\n                     break;\n                 }\n \n                 // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!ReplayBlocks(chainparams, pcoinsdbview.get())) {\n+                if (!ReplayBlocks(chainparams, &::ChainstateActive().CoinsDB())) {\n                     strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\").translated;\n                     break;\n                 }\n \n                 // The on-disk coinsdb is now in a good state, create the cache\n-                pcoinsTip.reset(new CCoinsViewCache(pcoinscatcher.get()));\n+                ::ChainstateActive().InitCoinsCache();\n+                assert(::ChainstateActive().CanFlushToDisk());\n \n-                is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n+                is_coinsview_empty = fReset || fReindexChainState ||\n+                    ::ChainstateActive().CoinsTip().GetBestBlock().IsNull();\n                 if (!is_coinsview_empty) {\n-                    // LoadChainTip sets ::ChainActive() based on pcoinsTip's best block\n+                    // LoadChainTip sets ::ChainActive() based on CoinsTip()'s best block\n                     if (!LoadChainTip(chainparams)) {\n                         strLoadError = _(\"Error initializing block database\").translated;\n                         break;\n@@ -1588,7 +1592,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n                         break;\n                     }\n \n-                    if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n+                    if (!CVerifyDB().VerifyDB(chainparams, &::ChainstateActive().CoinsDB(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n                                   gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n                         strLoadError = _(\"Corrupted block database detected\").translated;\n                         break;"
      },
      {
        "sha": "8061939a268ce5629dd863c63132214c440782d3",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -1062,7 +1062,7 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n \n     CCoinsStats stats;\n     ::ChainstateActive().ForceFlushStateToDisk();\n-    if (GetUTXOStats(pcoinsdbview.get(), stats)) {\n+    if (GetUTXOStats(&::ChainstateActive().CoinsDB(), stats)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n         ret.pushKV(\"transactions\", (int64_t)stats.nTransactions);\n@@ -2206,7 +2206,7 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n         {\n             LOCK(cs_main);\n             ::ChainstateActive().ForceFlushStateToDisk();\n-            pcursor = std::unique_ptr<CCoinsViewCursor>(pcoinsdbview->Cursor());\n+            pcursor = std::unique_ptr<CCoinsViewCursor>(::ChainstateActive().CoinsDB().Cursor());\n             assert(pcursor);\n         }\n         bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);"
      },
      {
        "sha": "0ff081e472738ac913aa98afbc6e30e33675560a",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -85,8 +85,12 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n \n     mempool.setSanityCheck(1.0);\n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-    pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-    pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+    g_chainstate = MakeUnique<CChainState>();\n+    ::ChainstateActive().InitCoinsDB(\n+        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+    assert(!::ChainstateActive().CanFlushToDisk());\n+    ::ChainstateActive().InitCoinsCache();\n+    assert(::ChainstateActive().CanFlushToDisk());\n     if (!LoadGenesisBlock(chainparams)) {\n         throw std::runtime_error(\"LoadGenesisBlock failed.\");\n     }\n@@ -113,8 +117,7 @@ TestingSetup::~TestingSetup()\n     g_connman.reset();\n     g_banman.reset();\n     UnloadBlockIndex();\n-    pcoinsTip.reset();\n-    pcoinsdbview.reset();\n+    g_chainstate.reset();\n     pblocktree.reset();\n }\n "
      },
      {
        "sha": "18be07e6dbb023aeb6be2320d35eb150e9d2edc6",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -52,7 +52,7 @@ struct CoinEntry {\n \n }\n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true)\n+CCoinsViewDB::CCoinsViewDB(fs::path ldb_path, size_t nCacheSize, bool fMemory, bool fWipe) : db(ldb_path, nCacheSize, fMemory, fWipe, true)\n {\n }\n "
      },
      {
        "sha": "140ce2c7ff7d2637ef77f8441666303c8d22ef9b",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -48,7 +48,10 @@ class CCoinsViewDB final : public CCoinsView\n protected:\n     CDBWrapper db;\n public:\n-    explicit CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    /**\n+     * @param[in] ldb_path    Location in the filesystem where leveldb data will be stored.\n+     */\n+    explicit CCoinsViewDB(fs::path ldb_path, size_t nCacheSize, bool fMemory, bool fWipe);\n \n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;"
      },
      {
        "sha": "0f24321aaf60930e3b608e28f7fd1ceeb4003e6a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 6,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -82,11 +82,17 @@ namespace {\n BlockManager g_blockman;\n } // anon namespace\n \n-static CChainState g_chainstate(g_blockman);\n+std::unique_ptr<CChainState> g_chainstate;\n \n-CChainState& ChainstateActive() { return g_chainstate; }\n+CChainState& ChainstateActive() {\n+    assert(g_chainstate);\n+    return *g_chainstate;\n+}\n \n-CChain& ChainActive() { return g_chainstate.m_chain; }\n+CChain& ChainActive() {\n+    assert(g_chainstate);\n+    return g_chainstate->m_chain;\n+}\n \n /**\n  * Mutex to guard access to validation specific variables, such as reading\n@@ -173,8 +179,6 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n     return chain.Genesis();\n }\n \n-std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n-std::unique_ptr<CCoinsViewCache> pcoinsTip;\n std::unique_ptr<CBlockTreeDB> pblocktree;\n \n // See definition for documentation\n@@ -525,7 +529,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n \n             // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+            // (CoinsTip().cacheCoins) by way of FetchCoin(). It should be removed\n             // later (via coins_to_uncache) if this tx turns out to be invalid.\n             if (!view.HaveCoin(txin.prevout)) {\n                 // Are inputs missing because we already have the tx?\n@@ -1041,6 +1045,40 @@ CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n     return nSubsidy;\n }\n \n+CoinsViews::CoinsViews(\n+    std::string ldb_name,\n+    size_t cache_size_bytes,\n+    bool in_memory,\n+    bool should_wipe) : m_dbview(\n+                            GetDataDir() / ldb_name, cache_size_bytes, in_memory, should_wipe),\n+                        m_catcherview(&m_dbview) {}\n+\n+void CoinsViews::InitCache()\n+{\n+    m_cacheview = MakeUnique<CCoinsViewCache>(&m_catcherview);\n+}\n+\n+// NOTE: for now m_blockman is set to a global, but this will be changed\n+// in a future commit.\n+CChainState::CChainState() : m_blockman(g_blockman) {}\n+\n+\n+void CChainState::InitCoinsDB(\n+    size_t cache_size_bytes,\n+    bool in_memory,\n+    bool should_wipe,\n+    std::string leveldb_name)\n+{\n+    m_coins_views = MakeUnique<CoinsViews>(\n+        leveldb_name, cache_size_bytes, in_memory, should_wipe);\n+}\n+\n+void CChainState::InitCoinsCache()\n+{\n+    assert(m_coins_views != nullptr);\n+    m_coins_views->InitCache();\n+}\n+\n // Note that though this is marked const, we may end up modifying `m_cached_finished_ibd`, which\n // is a performance-related implementation detail. This function must be marked\n // `const` so that `CValidationInterface` clients (which are given a `const CChainState*`)\n@@ -1982,6 +2020,7 @@ bool CChainState::FlushStateToDisk(\n {\n     int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n     LOCK(cs_main);\n+    assert(this->CanFlushToDisk());\n     static int64_t nLastWrite = 0;\n     static int64_t nLastFlush = 0;\n     std::set<int> setFilesToPrune;"
      },
      {
        "sha": "2a268d8cabe0eeeffa41d3f8ec4365f08b969ba7",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 86,
        "deletions": 8,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/569353068568444a25b301bbd6513bb510157dc9/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/569353068568444a25b301bbd6513bb510157dc9/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=569353068568444a25b301bbd6513bb510157dc9",
        "patch": "@@ -19,6 +19,7 @@\n #include <script/script_error.h>\n #include <sync.h>\n #include <txmempool.h> // For CTxMemPool::cs\n+#include <txdb.h>\n #include <versionbits.h>\n \n #include <algorithm>\n@@ -37,7 +38,6 @@ class CBlockIndex;\n class CBlockTreeDB;\n class CBlockUndo;\n class CChainParams;\n-class CCoinsViewDB;\n class CInv;\n class CConnman;\n class CScriptCheck;\n@@ -505,8 +505,40 @@ class BlockManager {\n         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n-/** Global variable that points to the active CCoinsView (protected by cs_main) */\n-extern std::unique_ptr<CCoinsViewCache> pcoinsTip;\n+/**\n+ * A convenience class for constructing the CCoinsView* hierarchy used\n+ * to facilitate access to the UTXO set.\n+ *\n+ * This class consists of an arrangement of layered CCoinsView objects,\n+ * preferring to store and retrieve coins in memory via `m_cacheview` but\n+ * ultimately falling back on cache misses to the canonical store of UTXOs on\n+ * disk, `m_dbview`.\n+ */\n+class CoinsViews {\n+\n+public:\n+    //! The lowest level of the CoinsViews cache hierarchy sits in a leveldb database on disk.\n+    //! All unspent coins reside in this store.\n+    CCoinsViewDB m_dbview;\n+\n+    //! This view wraps access to the leveldb instance and handles read errors gracefully.\n+    CCoinsViewErrorCatcher m_catcherview;\n+\n+    //! This is the top layer of the cache hierarchy - it keeps as many coins in memory as\n+    //! can fit per the dbcache setting.\n+    std::unique_ptr<CCoinsViewCache> m_cacheview;\n+\n+    //! This constructor initializes CCoinsViewDB and CCoinsViewErrorCatcher instances, but it\n+    //! *does not* create a CCoinsViewCache instance by default. This is done separately because the\n+    //! presence of the cache has implications on whether or not we're allowed to flush the cache's\n+    //! state to disk, which should not be done until the health of the database is verified.\n+    //!\n+    //! All arguments forwarded onto CCoinsViewDB.\n+    CoinsViews(std::string ldb_name, size_t cache_size_bytes, bool in_memory, bool should_wipe);\n+\n+    //! Initialize the CCoinsViewCache member.\n+    void InitCache();\n+};\n \n /**\n  * CChainState stores and provides an API to update our local knowledge of the\n@@ -556,12 +588,39 @@ class CChainState {\n     //! easily as opposed to referencing a global.\n     BlockManager& m_blockman;\n \n+    //! Manages the UTXO set, which is a reflection of the contents of `m_chain`.\n+    std::unique_ptr<CoinsViews> m_coins_views;\n+\n public:\n-    CChainState(BlockManager& blockman) : m_blockman(blockman) { }\n+    CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n+    CChainState();\n+\n+    /**\n+     * Initialize the CoinsViews UTXO set database management data structures. The in-memory\n+     * cache is initialized separately.\n+     *\n+     * All parameters forwarded to CoinsViews.\n+     */\n+    void InitCoinsDB(\n+        size_t cache_size_bytes,\n+        bool in_memory,\n+        bool should_wipe,\n+        std::string leveldb_name = \"chainstate\");\n+\n+    //! Initialize the in-memory coins cache (to be done after the health of the on-disk database\n+    //! is verified).\n+    void InitCoinsCache();\n+\n+    //! @returns whether or not the CoinsViews object has been fully initialized and we can\n+    //!          safely flush this object to disk.\n+    bool CanFlushToDisk() {\n+        return m_coins_views && m_coins_views->m_cacheview;\n+    }\n \n     //! The current chain of blockheaders we consult and build on.\n     //! @see CChain, CBlockIndex.\n     CChain m_chain;\n+\n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n@@ -572,9 +631,26 @@ class CChainState {\n     //! @returns A reference to the in-memory cache of the UTXO set.\n     CCoinsViewCache& CoinsTip()\n     {\n-        return *::pcoinsTip;\n+        assert(m_coins_views->m_cacheview);\n+        return *m_coins_views->m_cacheview.get();\n+    }\n+\n+    //! @returns A reference to the on-disk UTXO set database.\n+    CCoinsViewDB& CoinsDB()\n+    {\n+        return m_coins_views->m_dbview;\n     }\n \n+    //! @returns A reference to a wrapped view of the in-memory UTXO set that\n+    //!     handles disk read errors gracefully.\n+    CCoinsViewErrorCatcher& CoinsErrorCatcher()\n+    {\n+        return m_coins_views->m_catcherview;\n+    }\n+\n+    //! Destructs all objects related to accessing the UTXO set.\n+    void ResetCoinsViews() { m_coins_views.reset(); }\n+\n     /**\n      * Update the on-disk chain state.\n      * The caches and indexes are flushed depending on the mode we're called with\n@@ -606,7 +682,7 @@ class CChainState {\n     bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n                       CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    // Block disconnection on our pcoinsTip:\n+    // Apply the effects of a block disconnection on the UTXO set.\n     bool DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n \n     // Manual block validity manipulation:\n@@ -668,8 +744,10 @@ CChain& ChainActive();\n /** @returns the global block index map. */\n BlockMap& BlockIndex();\n \n-/** Global variable that points to the coins database (protected by cs_main) */\n-extern std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n+// Most often ::ChainstateActive() should be used instead of this, but some code\n+// may not be able to assume that this has been initialized yet and so must use it\n+// directly, e.g. init.cpp.\n+extern std::unique_ptr<CChainState> g_chainstate;\n \n /** Global variable that points to the active block tree (protected by cs_main) */\n extern std::unique_ptr<CBlockTreeDB> pblocktree;"
      }
    ]
  },
  {
    "sha": "582d2cd74754d6b9a2394616a9c82a89d2d71976",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODJkMmNkNzQ3NTRkNmI5YTIzOTQ2MTZhOWM4MmE4OWQyZDcxOTc2",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-07-24T17:39:42Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-08-15T15:19:40Z"
      },
      "message": "Cover UTXO set access with lock annotations\n\ni.e. any CoinsViews members. Adds a lock acquisition to `gettxoutsetinfo` RPC\nto comply with added annotations.\n\nCo-authored-by: Russell Yanofsky <russ@yanofsky.org>",
      "tree": {
        "sha": "6aca21d9b8481b465a74811fb9c2b97ddc9576c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6aca21d9b8481b465a74811fb9c2b97ddc9576c4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/582d2cd74754d6b9a2394616a9c82a89d2d71976",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/582d2cd74754d6b9a2394616a9c82a89d2d71976",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/582d2cd74754d6b9a2394616a9c82a89d2d71976",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/582d2cd74754d6b9a2394616a9c82a89d2d71976/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "569353068568444a25b301bbd6513bb510157dc9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/569353068568444a25b301bbd6513bb510157dc9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/569353068568444a25b301bbd6513bb510157dc9"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 22,
      "deletions": 14
    },
    "files": [
      {
        "sha": "97be4637a6051d261cf01d8d710d002b23ee3169",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=582d2cd74754d6b9a2394616a9c82a89d2d71976",
        "patch": "@@ -235,8 +235,11 @@ void Shutdown(InitInterfaces& interfaces)\n     //\n     // g_chainstate is referenced here directly (instead of ::ChainstateActive()) because it\n     // may not have been initialized yet.\n-    if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n-        g_chainstate->ForceFlushStateToDisk();\n+    {\n+        LOCK(cs_main);\n+        if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n+            g_chainstate->ForceFlushStateToDisk();\n+        }\n     }\n \n     // After there are no more peers/RPC left to give us new data which may generate"
      },
      {
        "sha": "e3d5394a2c22c45df8fae14dca651d3634ae3584",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=582d2cd74754d6b9a2394616a9c82a89d2d71976",
        "patch": "@@ -1062,7 +1062,9 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n \n     CCoinsStats stats;\n     ::ChainstateActive().ForceFlushStateToDisk();\n-    if (GetUTXOStats(&::ChainstateActive().CoinsDB(), stats)) {\n+\n+    CCoinsView* coins_view = WITH_LOCK(cs_main, return &ChainstateActive().CoinsDB());\n+    if (GetUTXOStats(coins_view, stats)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n         ret.pushKV(\"transactions\", (int64_t)stats.nTransactions);"
      },
      {
        "sha": "8f44e2565a889c10f8a82b9ff7b3f6baa637c390",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=582d2cd74754d6b9a2394616a9c82a89d2d71976",
        "patch": "@@ -314,7 +314,8 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n // Returns the script flags which should be checked for a given block\n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n \n-static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age)\n+    EXCLUSIVE_LOCKS_REQUIRED(pool.cs, ::cs_main)\n {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -2160,7 +2161,9 @@ static void AppendWarning(std::string& res, const std::string& warn)\n }\n \n /** Check warning conditions and do some notifications on new chain tip set. */\n-void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainParams) {\n+void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainParams)\n+    EXCLUSIVE_LOCKS_REQUIRED(::cs_main)\n+{\n     // New best block\n     mempool.AddTransactionsUpdated(1);\n "
      },
      {
        "sha": "65f86e30705054e128e5cd09f9a7f1966775ef0d",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/582d2cd74754d6b9a2394616a9c82a89d2d71976/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=582d2cd74754d6b9a2394616a9c82a89d2d71976",
        "patch": "@@ -519,14 +519,14 @@ class CoinsViews {\n public:\n     //! The lowest level of the CoinsViews cache hierarchy sits in a leveldb database on disk.\n     //! All unspent coins reside in this store.\n-    CCoinsViewDB m_dbview;\n+    CCoinsViewDB m_dbview GUARDED_BY(cs_main);\n \n     //! This view wraps access to the leveldb instance and handles read errors gracefully.\n-    CCoinsViewErrorCatcher m_catcherview;\n+    CCoinsViewErrorCatcher m_catcherview GUARDED_BY(cs_main);\n \n     //! This is the top layer of the cache hierarchy - it keeps as many coins in memory as\n     //! can fit per the dbcache setting.\n-    std::unique_ptr<CCoinsViewCache> m_cacheview;\n+    std::unique_ptr<CCoinsViewCache> m_cacheview GUARDED_BY(cs_main);\n \n     //! This constructor initializes CCoinsViewDB and CCoinsViewErrorCatcher instances, but it\n     //! *does not* create a CCoinsViewCache instance by default. This is done separately because the\n@@ -537,7 +537,7 @@ class CoinsViews {\n     CoinsViews(std::string ldb_name, size_t cache_size_bytes, bool in_memory, bool should_wipe);\n \n     //! Initialize the CCoinsViewCache member.\n-    void InitCache();\n+    void InitCache() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n };\n \n /**\n@@ -609,11 +609,11 @@ class CChainState {\n \n     //! Initialize the in-memory coins cache (to be done after the health of the on-disk database\n     //! is verified).\n-    void InitCoinsCache();\n+    void InitCoinsCache() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     //! @returns whether or not the CoinsViews object has been fully initialized and we can\n     //!          safely flush this object to disk.\n-    bool CanFlushToDisk() {\n+    bool CanFlushToDisk() EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n         return m_coins_views && m_coins_views->m_cacheview;\n     }\n \n@@ -629,21 +629,21 @@ class CChainState {\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n \n     //! @returns A reference to the in-memory cache of the UTXO set.\n-    CCoinsViewCache& CoinsTip()\n+    CCoinsViewCache& CoinsTip() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     {\n         assert(m_coins_views->m_cacheview);\n         return *m_coins_views->m_cacheview.get();\n     }\n \n     //! @returns A reference to the on-disk UTXO set database.\n-    CCoinsViewDB& CoinsDB()\n+    CCoinsViewDB& CoinsDB() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     {\n         return m_coins_views->m_dbview;\n     }\n \n     //! @returns A reference to a wrapped view of the in-memory UTXO set that\n     //!     handles disk read errors gracefully.\n-    CCoinsViewErrorCatcher& CoinsErrorCatcher()\n+    CCoinsViewErrorCatcher& CoinsErrorCatcher() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     {\n         return m_coins_views->m_catcherview;\n     }"
      }
    ]
  }
]