[
  {
    "sha": "5cd7f8abe3996d303774b6cddeb419337d605d02",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2Q3ZjhhYmUzOTk2ZDMwMzc3NGI2Y2RkZWI0MTkzMzdkNjA1ZDAy",
    "commit": {
      "author": {
        "name": "Hennadii Stepanov",
        "email": "32963518+hebasto@users.noreply.github.com",
        "date": "2021-01-01T21:10:31Z"
      },
      "committer": {
        "name": "Hennadii Stepanov",
        "email": "32963518+hebasto@users.noreply.github.com",
        "date": "2021-05-23T11:46:21Z"
      },
      "message": "refactor: Do not expose CAddrMan members as protected without need",
      "tree": {
        "sha": "43998131ad7671e0520795ee06a3847b4610bf7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/43998131ad7671e0520795ee06a3847b4610bf7f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5cd7f8abe3996d303774b6cddeb419337d605d02",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE0dvyxLlvLev0wWZUQQEIES5+qB8FAmCqQI0ACgkQQQEIES5+\nqB9uZw//UBb7Ds0UVHmnfpiFPws2Gm6JpFWAQJ/qp63VuqRMhVPzribZAJFIv+0T\nqziQydKuV65c0sq9zL/0hnIrxk3lnuxUhvtRYJDZUJCAW18C+r8fA/7NAMe1a/Kk\nhOBpq4pTmvgU7nV5YbcuUDJnlf1X1TAskK0zzBXIXdwIrWJkghMeXFp7Yb4uIaMy\nbKQjLw4dG4IFz70y0x69RMQc+ufFJ70CGnZgkOHhtnkuhrUWX5GnpKocsxq7q9dw\nkhOKKhQ6L8zABByFemMYd8sVFY/MryGlZ2ZklELlUN1D5ESkIK3W9KPtzYYTAHy6\ncbrPIQgLQOBZXnygn5lk7adHZ7AMwgt1B7t6HpcWXhbgneUZQMrOfeUNbzphUepI\nIVit3vzj4x7YLEKqcqEmJllnmBxDtb8sHfOPN/d280YtPUmh0WIiNgBt95+YQOjX\nuLnoRxVlaKVUh8fVKVOV0LpGlmOejlqmzovcm04YX2Aduybmmr1ejYIuLoPQkNVv\nYZh4jpXoq/+DIM1XfyjAiNXFMQ1FU06agQ1Q5oTOmrjXZiZaWRevEUNr0655s4o1\njoOAbLcVRjBKOENUsPTbC5/ggbyzJK10qx8qyIDgvbM7RhasV9boHyPRL4Oohviz\n3M6M8mmCa9OHizRz+u2/PY+wv2VeVkwmWZprYmFLNgwSn/V0Y88=\n=nUtb\n-----END PGP SIGNATURE-----",
        "payload": "tree 43998131ad7671e0520795ee06a3847b4610bf7f\nparent be4171679b8eab8205e04ff86140329bd67878a0\nauthor Hennadii Stepanov <32963518+hebasto@users.noreply.github.com> 1609535431 +0200\ncommitter Hennadii Stepanov <32963518+hebasto@users.noreply.github.com> 1621770381 +0300\n\nrefactor: Do not expose CAddrMan members as protected without need\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd7f8abe3996d303774b6cddeb419337d605d02",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd7f8abe3996d303774b6cddeb419337d605d02",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd7f8abe3996d303774b6cddeb419337d605d02/comments",
    "author": {
      "login": "hebasto",
      "id": 32963518,
      "node_id": "MDQ6VXNlcjMyOTYzNTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hebasto",
      "html_url": "https://github.com/hebasto",
      "followers_url": "https://api.github.com/users/hebasto/followers",
      "following_url": "https://api.github.com/users/hebasto/following{/other_user}",
      "gists_url": "https://api.github.com/users/hebasto/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
      "organizations_url": "https://api.github.com/users/hebasto/orgs",
      "repos_url": "https://api.github.com/users/hebasto/repos",
      "events_url": "https://api.github.com/users/hebasto/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hebasto/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "hebasto",
      "id": 32963518,
      "node_id": "MDQ6VXNlcjMyOTYzNTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hebasto",
      "html_url": "https://github.com/hebasto",
      "followers_url": "https://api.github.com/users/hebasto/followers",
      "following_url": "https://api.github.com/users/hebasto/following{/other_user}",
      "gists_url": "https://api.github.com/users/hebasto/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
      "organizations_url": "https://api.github.com/users/hebasto/orgs",
      "repos_url": "https://api.github.com/users/hebasto/repos",
      "events_url": "https://api.github.com/users/hebasto/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hebasto/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be4171679b8eab8205e04ff86140329bd67878a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be4171679b8eab8205e04ff86140329bd67878a0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be4171679b8eab8205e04ff86140329bd67878a0"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "9a2cb079a5d96eb3411ba946b3f832cee90793a6",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cd7f8abe3996d303774b6cddeb419337d605d02/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cd7f8abe3996d303774b6cddeb419337d605d02/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=5cd7f8abe3996d303774b6cddeb419337d605d02",
        "patch": "@@ -173,11 +173,10 @@ static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n class CAddrMan\n {\n friend class CAddrManTest;\n-protected:\n+private:\n     //! critical section to protect the inner data structures\n     mutable RecursiveMutex cs;\n \n-private:\n     //! Serialization versions.\n     enum Format : uint8_t {\n         V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n@@ -237,6 +236,7 @@ friend class CAddrManTest;\n     //! Source of random numbers for randomization in inner loops\n     FastRandomContext insecure_rand;\n \n+private:\n     //! Find an entry.\n     CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      }
    ]
  },
  {
    "sha": "8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Y2FmNjBkYmJlMTZhZmEzYzUyNTc0YTdmNjcxMGQ3NGMwYmZkNGFi",
    "commit": {
      "author": {
        "name": "Hennadii Stepanov",
        "email": "32963518+hebasto@users.noreply.github.com",
        "date": "2021-05-24T16:26:49Z"
      },
      "committer": {
        "name": "Hennadii Stepanov",
        "email": "32963518+hebasto@users.noreply.github.com",
        "date": "2021-05-24T16:26:49Z"
      },
      "message": "move-only: Group and re-order CAddrMan members by access type\n\nEasy to verify with `git diff --color-moved=dimmed-zebra`.",
      "tree": {
        "sha": "2a52559c19a0f5fe287a0982dc50cc774ca0afcc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2a52559c19a0f5fe287a0982dc50cc774ca0afcc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE0dvyxLlvLev0wWZUQQEIES5+qB8FAmCr08kACgkQQQEIES5+\nqB+CRQ//d2bx/u+NmOVgrM5gIU1JSs5Iuj3zvESL3pG0Gs9M1CI4I5Rm8uZuOXAx\n1oRC4Ak+vRGK8oVmo3JiclEesl+eR1vbfhZfZrHtTB2mREPf5Qb/krT37AxfxZyB\nWRfxTlpj8E/cVshJj7XYgJFtrb7CDM8GaEl4ReOBC5w1xUyo3qKpYL+0udRfQPo2\nbniBJute405G2QOXLb5Oeeobfc1sGxUmkm+sj/Lx6I5moh1VQovafHW+aNZqVY/U\nnuM/7RFYFRmeexzFJQGlxOQrX/njAR6Ho7RE5GPf0Lq/1RZvQKf8q7LkGgzj2RQY\nAg4xYxKb4UOWNu3v8Ao+UpMFV0TsxCF7ZVQnkQD9Oz3UBjRJ8N6ekM5gDQ7m9nZe\na6rNdN4QZAp8/DP1G0M3M78KPAT8kbRma10qB09tvgutceDn5cRXs66YACdVNsXP\nv1YaHOVe+nw+TRcC8SDzBTHSnlW9keaOVgnswI8W1ED74umzBpmtBCQqpMbMX/kM\nUPvIz/j5akmWlNNOyXGZxP/xrz5xpfnnHOsnFRdxyGkoBhtPDrYuL4q0VyBy8ysW\n2GUIags1akpBRDJYr/Mq319OnURDmZ3iXxIHvkFuty5/ryrZA2Gv27zTGFxH6mGz\nPsX/3udKY+5gOU6ZGQWfWYuAMWVPLI4LCOE3IttJMU2laY7jwv4=\n=P4R1\n-----END PGP SIGNATURE-----",
        "payload": "tree 2a52559c19a0f5fe287a0982dc50cc774ca0afcc\nparent 5cd7f8abe3996d303774b6cddeb419337d605d02\nauthor Hennadii Stepanov <32963518+hebasto@users.noreply.github.com> 1621873609 +0300\ncommitter Hennadii Stepanov <32963518+hebasto@users.noreply.github.com> 1621873609 +0300\n\nmove-only: Group and re-order CAddrMan members by access type\n\nEasy to verify with `git diff --color-moved=dimmed-zebra`.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab/comments",
    "author": {
      "login": "hebasto",
      "id": 32963518,
      "node_id": "MDQ6VXNlcjMyOTYzNTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hebasto",
      "html_url": "https://github.com/hebasto",
      "followers_url": "https://api.github.com/users/hebasto/followers",
      "following_url": "https://api.github.com/users/hebasto/following{/other_user}",
      "gists_url": "https://api.github.com/users/hebasto/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
      "organizations_url": "https://api.github.com/users/hebasto/orgs",
      "repos_url": "https://api.github.com/users/hebasto/repos",
      "events_url": "https://api.github.com/users/hebasto/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hebasto/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "hebasto",
      "id": 32963518,
      "node_id": "MDQ6VXNlcjMyOTYzNTE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hebasto",
      "html_url": "https://github.com/hebasto",
      "followers_url": "https://api.github.com/users/hebasto/followers",
      "following_url": "https://api.github.com/users/hebasto/following{/other_user}",
      "gists_url": "https://api.github.com/users/hebasto/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
      "organizations_url": "https://api.github.com/users/hebasto/orgs",
      "repos_url": "https://api.github.com/users/hebasto/repos",
      "events_url": "https://api.github.com/users/hebasto/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hebasto/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5cd7f8abe3996d303774b6cddeb419337d605d02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd7f8abe3996d303774b6cddeb419337d605d02",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd7f8abe3996d303774b6cddeb419337d605d02"
      }
    ],
    "stats": {
      "total": 266,
      "additions": 132,
      "deletions": 134
    },
    "files": [
      {
        "sha": "41994288dbd69b6c072763ad1caec84cc9673d8f",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 132,
        "deletions": 134,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
        "patch": "@@ -172,139 +172,6 @@ static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n  */\n class CAddrMan\n {\n-friend class CAddrManTest;\n-private:\n-    //! critical section to protect the inner data structures\n-    mutable RecursiveMutex cs;\n-\n-    //! Serialization versions.\n-    enum Format : uint8_t {\n-        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n-        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n-        V2_ASMAP = 2,         //!< for files including asmap version\n-        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n-    };\n-\n-    //! The maximum format this software knows it can unserialize. Also, we always serialize\n-    //! in this format.\n-    //! The format (first byte in the serialized stream) can be higher than this and\n-    //! still this software may be able to unserialize the file - if the second byte\n-    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n-    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n-\n-    //! The initial value of a field that is incremented every time an incompatible format\n-    //! change is made (such that old software versions would not be able to parse and\n-    //! understand the new file format). This is 32 because we overtook the \"key size\"\n-    //! field which was 32 historically.\n-    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n-    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n-\n-    //! last used nId\n-    int nIdCount GUARDED_BY(cs);\n-\n-    //! table with information about all nIds\n-    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n-\n-    //! find an nId based on its network address\n-    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n-\n-    //! randomly-ordered vector of all nIds\n-    std::vector<int> vRandom GUARDED_BY(cs);\n-\n-    // number of \"tried\" entries\n-    int nTried GUARDED_BY(cs);\n-\n-    //! list of \"tried\" buckets\n-    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! number of (unique) \"new\" entries\n-    int nNew GUARDED_BY(cs);\n-\n-    //! list of \"new\" buckets\n-    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! last time Good was called (memory only)\n-    int64_t nLastGood GUARDED_BY(cs);\n-\n-    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n-    std::set<int> m_tried_collisions;\n-\n-protected:\n-    //! secret key to randomize bucket select with\n-    uint256 nKey;\n-\n-    //! Source of random numbers for randomization in inner loops\n-    FastRandomContext insecure_rand;\n-\n-private:\n-    //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! find an entry, creating it if necessary.\n-    //! nTime and nServices of the found node are updated, if necessary.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Swap two elements in vRandom.\n-    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Delete an entry. It must not be in tried, and have refcount 0.\n-    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n-    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Add an entry to the \"new\" table.\n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry as attempted to connect.\n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-#ifdef DEBUG_ADDRMAN\n-    //! Perform consistency check. Returns an error code or zero.\n-    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-#endif\n-\n-    /**\n-     * Return all or many randomly selected addresses, optionally by network.\n-     *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n-     */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    /** We have successfully connected to this peer. Calling this function\n-     *  updates the CAddress's nTime, which is used in our IsTerrible()\n-     *  decisions and gossiped to peers. Callers should be careful that updating\n-     *  this information doesn't leak topology information to network spies.\n-     *\n-     *  net_processing calls this function when it *disconnects* from a peer to\n-     *  not leak information about currently connected peers.\n-     *\n-     * @param[in]   addr     The address of the peer we were connected to\n-     * @param[in]   nTime    The time that we were last connected to this peer\n-     */\n-    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Update an entry's service bits.\n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n public:\n     // Compressed IP->ASN mapping, loaded from a file when a node starts.\n     // Should be always empty if no file was provided.\n@@ -325,7 +192,6 @@ friend class CAddrManTest;\n     // Read asmap from provided binary file\n     static std::vector<bool> DecodeAsmap(fs::path path);\n \n-\n     /**\n      * Serialized format.\n      * * format version byte (@see `Format`)\n@@ -759,6 +625,138 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+protected:\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManTest;\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      }
    ]
  }
]