[
  {
    "sha": "12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmQxYjc3ZjdlYjJjYTI3NDg5MGQ5ZmI0NWQ2YzE5YTQwYmE4Zjc0",
    "commit": {
      "author": {
        "name": "lmanners",
        "email": "lowellmanners@gmail.com",
        "date": "2018-05-08T20:38:44Z"
      },
      "committer": {
        "name": "lmanners",
        "email": "lowellmanners@gmail.com",
        "date": "2018-05-08T22:28:55Z"
      },
      "message": "[tests] Fixed intermittent failure in p2p_sendheaders.py.\n\nAdded handling for the case where headers are announced over more than one message.\nrefs #12453",
      "tree": {
        "sha": "0e79a77ecfda1d38e5f29f4f84f7ae0203f648be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e79a77ecfda1d38e5f29f4f84f7ae0203f648be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74/comments",
    "author": {
      "login": "lmanners",
      "id": 834253,
      "node_id": "MDQ6VXNlcjgzNDI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/834253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lmanners",
      "html_url": "https://github.com/lmanners",
      "followers_url": "https://api.github.com/users/lmanners/followers",
      "following_url": "https://api.github.com/users/lmanners/following{/other_user}",
      "gists_url": "https://api.github.com/users/lmanners/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lmanners/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lmanners/subscriptions",
      "organizations_url": "https://api.github.com/users/lmanners/orgs",
      "repos_url": "https://api.github.com/users/lmanners/repos",
      "events_url": "https://api.github.com/users/lmanners/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lmanners/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lmanners",
      "id": 834253,
      "node_id": "MDQ6VXNlcjgzNDI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/834253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lmanners",
      "html_url": "https://github.com/lmanners",
      "followers_url": "https://api.github.com/users/lmanners/followers",
      "following_url": "https://api.github.com/users/lmanners/following{/other_user}",
      "gists_url": "https://api.github.com/users/lmanners/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lmanners/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lmanners/subscriptions",
      "organizations_url": "https://api.github.com/users/lmanners/orgs",
      "repos_url": "https://api.github.com/users/lmanners/repos",
      "events_url": "https://api.github.com/users/lmanners/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lmanners/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6b824c090f53d0a56833930fd38c41bcaec8ff4a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b824c090f53d0a56833930fd38c41bcaec8ff4a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6b824c090f53d0a56833930fd38c41bcaec8ff4a"
      }
    ],
    "stats": {
      "total": 96,
      "additions": 51,
      "deletions": 45
    },
    "files": [
      {
        "sha": "095cc4b734acf97a8e96c889e1dd6a2c0ecf1b62",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 51,
        "deletions": 45,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=12d1b77f7eb2ca274890d9fb45d6c19a40ba8f74",
        "patch": "@@ -116,6 +116,7 @@ def __init__(self):\n \n         self.block_announced = False\n         self.last_blockhash_announced = None\n+        self.recent_headers_announced = []\n \n     def send_get_data(self, block_hashes):\n         \"\"\"Request data for a list of block hashes.\"\"\"\n@@ -163,40 +164,45 @@ def on_inv(self, message):\n     def on_headers(self, message):\n         if len(message.headers):\n             self.block_announced = True\n-            message.headers[-1].calc_sha256()\n+            for x in message.headers:\n+                x.calc_sha256()\n+                # append because headers may be announced over multiple messages.\n+                self.recent_headers_announced.append(x.sha256)\n             self.last_blockhash_announced = message.headers[-1].sha256\n \n-    def clear_last_announcement(self):\n+    def clear_block_announcements(self):\n         with mininode_lock:\n             self.block_announced = False\n             self.last_message.pop(\"inv\", None)\n             self.last_message.pop(\"headers\", None)\n+            self.recent_headers_announced = []\n \n-    def check_last_announcement(self, headers=None, inv=None):\n-        \"\"\"Test whether the last announcement received had the right header or the right inv.\n \n-        inv and headers should be lists of block hashes.\"\"\"\n+    def check_last_headers_announcement(self, headers):\n+        \"\"\"Test whether the last headers announcements received are right.\n+           Headers may be announced across more than one message.\"\"\"\n+        test_function = lambda: (len(self.recent_headers_announced) >= len(headers))\n+        wait_until(test_function, timeout=60, lock=mininode_lock)\n+        with mininode_lock:\n+            assert_equal(self.recent_headers_announced, headers)\n+            self.block_announced = False\n+            self.last_message.pop(\"headers\", None)\n+            self.recent_headers_announced = []\n+\n+    def check_last_inv_announcement(self, inv):\n+        \"\"\"Test whether the last announcement received had the right inv.\n+        inv should be a list of block hashes.\"\"\"\n \n         test_function = lambda: self.block_announced\n         wait_until(test_function, timeout=60, lock=mininode_lock)\n \n         with mininode_lock:\n-            self.block_announced = False\n-\n             compare_inv = []\n             if \"inv\" in self.last_message:\n                 compare_inv = [x.hash for x in self.last_message[\"inv\"].inv]\n-            if inv is not None:\n-                assert_equal(compare_inv, inv)\n-\n-            compare_headers = []\n-            if \"headers\" in self.last_message:\n-                compare_headers = [x.sha256 for x in self.last_message[\"headers\"].headers]\n-            if headers is not None:\n-                assert_equal(compare_headers, headers)\n-\n+            assert_equal(compare_inv, inv)\n+            self.block_announced = False\n             self.last_message.pop(\"inv\", None)\n-            self.last_message.pop(\"headers\", None)\n \n class SendHeadersTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -206,8 +212,8 @@ def set_test_params(self):\n     def mine_blocks(self, count):\n         \"\"\"Mine count blocks and return the new tip.\"\"\"\n \n-        # Clear out last block announcement from each p2p listener\n-        [x.clear_last_announcement() for x in self.nodes[0].p2ps]\n+        # Clear out block announcements from each p2p listener\n+        [x.clear_block_announcements() for x in self.nodes[0].p2ps]\n         self.nodes[0].generate(count)\n         return int(self.nodes[0].getbestblockhash(), 16)\n \n@@ -222,7 +228,7 @@ def mine_reorg(self, length):\n         sync_blocks(self.nodes, wait=0.1)\n         for x in self.nodes[0].p2ps:\n             x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n-            x.clear_last_announcement()\n+            x.clear_block_announcements()\n \n         tip_height = self.nodes[1].getblockcount()\n         hash_to_invalidate = self.nodes[1].getblockhash(tip_height - (length - 1))\n@@ -255,25 +261,25 @@ def test_null_locators(self, test_node, inv_node):\n         tip = self.nodes[0].getblockheader(self.nodes[0].generate(1)[0])\n         tip_hash = int(tip[\"hash\"], 16)\n \n-        inv_node.check_last_announcement(inv=[tip_hash], headers=[])\n-        test_node.check_last_announcement(inv=[tip_hash], headers=[])\n+        inv_node.check_last_inv_announcement(inv=[tip_hash])\n+        test_node.check_last_inv_announcement(inv=[tip_hash])\n \n         self.log.info(\"Verify getheaders with null locator and valid hashstop returns headers.\")\n-        test_node.clear_last_announcement()\n+        test_node.clear_block_announcements()\n         test_node.send_get_headers(locator=[], hashstop=tip_hash)\n-        test_node.check_last_announcement(headers=[tip_hash])\n+        test_node.check_last_headers_announcement(headers=[tip_hash])\n \n         self.log.info(\"Verify getheaders with null locator and invalid hashstop does not return headers.\")\n         block = create_block(int(tip[\"hash\"], 16), create_coinbase(tip[\"height\"] + 1), tip[\"mediantime\"] + 1)\n         block.solve()\n         test_node.send_header_for_blocks([block])\n-        test_node.clear_last_announcement()\n+        test_node.clear_block_announcements()\n         test_node.send_get_headers(locator=[], hashstop=int(block.hash, 16))\n         test_node.sync_with_ping()\n         assert_equal(test_node.block_announced, False)\n-        inv_node.clear_last_announcement()\n+        inv_node.clear_block_announcements()\n         test_node.send_message(msg_block(block))\n-        inv_node.check_last_announcement(inv=[int(block.hash, 16)], headers=[])\n+        inv_node.check_last_inv_announcement(inv=[int(block.hash, 16)])\n \n     def test_nonnull_locators(self, test_node, inv_node):\n         tip = int(self.nodes[0].getbestblockhash(), 16)\n@@ -284,8 +290,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n         for i in range(4):\n             old_tip = tip\n             tip = self.mine_blocks(1)\n-            inv_node.check_last_announcement(inv=[tip], headers=[])\n-            test_node.check_last_announcement(inv=[tip], headers=[])\n+            inv_node.check_last_inv_announcement(inv=[tip])\n+            test_node.check_last_inv_announcement(inv=[tip])\n             # Try a few different responses; none should affect next announcement\n             if i == 0:\n                 # first request the block\n@@ -296,7 +302,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 test_node.send_get_headers(locator=[old_tip], hashstop=tip)\n                 test_node.send_get_data([tip])\n                 test_node.wait_for_block(tip)\n-                test_node.clear_last_announcement()  # since we requested headers...\n+                test_node.clear_block_announcements()  # since we requested headers...\n             elif i == 2:\n                 # this time announce own block via headers\n                 height = self.nodes[0].getblockcount()\n@@ -308,8 +314,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_message(msg_block(new_block))\n                 test_node.sync_with_ping()  # make sure this block is processed\n-                inv_node.clear_last_announcement()\n-                test_node.clear_last_announcement()\n+                inv_node.clear_block_announcements()\n+                test_node.clear_block_announcements()\n \n         self.log.info(\"Part 1: success!\")\n         self.log.info(\"Part 2: announce blocks with headers after sendheaders message...\")\n@@ -323,8 +329,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n \n         # Now that we've synced headers, headers announcements should work\n         tip = self.mine_blocks(1)\n-        inv_node.check_last_announcement(inv=[tip], headers=[])\n-        test_node.check_last_announcement(headers=[tip])\n+        inv_node.check_last_inv_announcement(inv=[tip])\n+        test_node.check_last_headers_announcement(headers=[tip])\n \n         height = self.nodes[0].getblockcount() + 1\n         block_time += 10  # Advance far enough ahead\n@@ -368,8 +374,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 assert \"inv\" not in inv_node.last_message\n                 assert \"headers\" not in inv_node.last_message\n                 tip = self.mine_blocks(1)\n-                inv_node.check_last_announcement(inv=[tip], headers=[])\n-                test_node.check_last_announcement(headers=[tip])\n+                inv_node.check_last_inv_announcement(inv=[tip])\n+                test_node.check_last_headers_announcement(headers=[tip])\n                 height += 1\n                 block_time += 1\n \n@@ -383,16 +389,16 @@ def test_nonnull_locators(self, test_node, inv_node):\n             # First try mining a reorg that can propagate with header announcement\n             new_block_hashes = self.mine_reorg(length=7)\n             tip = new_block_hashes[-1]\n-            inv_node.check_last_announcement(inv=[tip], headers=[])\n-            test_node.check_last_announcement(headers=new_block_hashes)\n+            inv_node.check_last_inv_announcement(inv=[tip])\n+            test_node.check_last_headers_announcement(headers=new_block_hashes)\n \n             block_time += 8\n \n             # Mine a too-large reorg, which should be announced with a single inv\n             new_block_hashes = self.mine_reorg(length=8)\n             tip = new_block_hashes[-1]\n-            inv_node.check_last_announcement(inv=[tip], headers=[])\n-            test_node.check_last_announcement(inv=[tip], headers=[])\n+            inv_node.check_last_inv_announcement(inv=[tip])\n+            test_node.check_last_inv_announcement(inv=[tip])\n \n             block_time += 9\n \n@@ -401,15 +407,15 @@ def test_nonnull_locators(self, test_node, inv_node):\n \n             # Use getblocks/getdata\n             test_node.send_getblocks(locator=[fork_point])\n-            test_node.check_last_announcement(inv=new_block_hashes, headers=[])\n+            test_node.check_last_inv_announcement(inv=new_block_hashes)\n             test_node.send_get_data(new_block_hashes)\n             test_node.wait_for_block(new_block_hashes[-1])\n \n             for i in range(3):\n                 # Mine another block, still should get only an inv\n                 tip = self.mine_blocks(1)\n-                inv_node.check_last_announcement(inv=[tip], headers=[])\n-                test_node.check_last_announcement(inv=[tip], headers=[])\n+                inv_node.check_last_inv_announcement(inv=[tip])\n+                test_node.check_last_inv_announcement(inv=[tip])\n                 if i == 0:\n                     self.log.debug(\"Just get the data -- shouldn't cause headers announcements to resume\")\n                     test_node.send_get_data([tip])\n@@ -431,8 +437,8 @@ def test_nonnull_locators(self, test_node, inv_node):\n                         test_node.sync_with_ping()\n             # New blocks should now be announced with header\n             tip = self.mine_blocks(1)\n-            inv_node.check_last_announcement(inv=[tip], headers=[])\n-            test_node.check_last_announcement(headers=[tip])\n+            inv_node.check_last_inv_announcement(inv=[tip])\n+            test_node.check_last_headers_announcement(headers=[tip])\n \n         self.log.info(\"Part 3: success!\")\n "
      }
    ]
  }
]