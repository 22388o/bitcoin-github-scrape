TheBlueMatt,2014-12-20T21:15:31Z,"Since travis passes, I figured we might actually consider this...essentially, it asserts that we dont have deadlocks assuming: (a) no locking-conditions are based on data other than the current set of locked locks and (b) if we do a TRY_LOCK, and it fails, we will immediately bail out and just skip that section of code.\nSince DEBUG_LOCKORDER is pretty much travis-only, if it might crash in cases ",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-67750006,67750006,
TheBlueMatt,2014-12-20T21:16:46Z,"Mostly, the DEBUG_LOCKORDER warnings arent even shown by travis anymore (they're just hidden behind the debug.log, so the only thing that flag does is check the lock assertions), so I figure we should have some semi-automated screeching if common-path code has lock inversions.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-67750056,67750056,
laanwj,2015-04-01T12:00:31Z,"Concept ACK, but this makes the deadlock detection code kind of complex. I can't immediately see whether it's correct or wrong.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-88450537,88450537,
gavinandresen,2015-04-01T14:19:22Z,"Hmmm....\n\nWould this work instead? Modify sync.h CMutexLock::TryEnter to only call EnterCritical() if the lock is successfully acquired?\n\n```\n    bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n    {\n        lock.try_lock();\n        if (lock.owns_lock()\n              EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n        return lock.owns_lock();\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-88502698,88502698,
TheBlueMatt,2015-04-03T17:30:00Z,"@gavinandresen No, because often you see warnings because you have a lock(B) followed by a try_lock(A) and a lock(A) followed by a lock(B) at different times, you'll get a warning, but your suggestion would ignore it because you didnt actually see a deadlock.\n\nAlso, you cant just ignore try_locks entirely because it is very easy to create a deadlock with a try_lock.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-89368860,89368860,
gavinandresen,2015-04-03T17:56:19Z,"@TheBlueMatt : maybe I'm being dense... but:\n\nIf we get:  lock(B) then a successful (lock-acquired) try_lock(A), then the lockorders map will contain ""B then A"".\nIf at any point in the future lock(A) is followed by lock(B), a warning will be triggered -- my suggestion doesn't require that there be an actual deadlock.\n\nI'm not suggesting that try_lock be ignored entirely....\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-89375121,89375121,
TheBlueMatt,2015-04-04T04:06:31Z,"@gavinandresen Yes, and if a warning were triggered in that (beningn) case, then you'd see things crash on the new assert?\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-89497295,89497295,
sipa,2015-04-08T04:31:35Z,"Haven't spent too much time thinking about this, but having (A, B) in one place and (B, try A) in another place can never cause a deadlock. I believe that the correct checking behaviour is to add any acquired lock to the table, but never do a deadlock check when entering a try_lock.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-90799721,90799721,
TheBlueMatt,2015-04-08T13:25:46Z,"@sipa: Consider the case A, tryB, C and C, tryB, A. This is actually not a deadlock, but if you simply skip the deadlock check for B, you'll get an error.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-90914584,90914584,
TheBlueMatt,2015-04-08T13:26:04Z,"IIRC, there was a similar case that I saw that prompted this pull.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-90914706,90914706,
gavinandresen,2015-04-08T13:43:45Z,"@TheBlueMatt : sorry, I WAS just being dense.\n\nI'm with @laanwj -- ACK on the concept, but I'm having trouble convincing myself the code is correct (I may just need more caffeine before thinking about it some more). It feels like there should be a simpler solution.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-90921092,90921092,
sipa,2015-04-08T14:45:55Z,"Interesting. I agree (a,try b,c),(c,try b,a)) is not a deadlock, but it is\nnot something any code should be doing - it looks extremely fragile\n(_remove_ a lock, and turn it into a deadlock). So I'd rather trigger\ndeadlock warnings for it too.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-90937577,90937577,
TheBlueMatt,2015-04-08T16:07:42Z,"IIRC we (used to) do something like that. We may not anymore, but some of the network processing stuff is a mess.\n\nOn April 8, 2015 3:46:03 PM GMT+01:00, Pieter Wuille notifications@github.com wrote:\n\n> Interesting. I agree (a,try b,c),(c,try b,a)) is not a deadlock, but it\n> is\n> not something any code should be doing - it looks extremely fragile\n> (_remove_ a lock, and turn it into a dead",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-90961273,90961273,
TheBlueMatt,2015-07-22T23:53:03Z,"@sipa checked, turns out the deadlock detection code never called potential_deadlock_detected for TRY_LOCKs so we definitely still do require the code in this pull before we can assert on deadlocks. Also rebased and added a comment so that this is more readable.\n",https://github.com/bitcoin/bitcoin/pull/5515#issuecomment-123909906,123909906,
