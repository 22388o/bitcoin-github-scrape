[
  {
    "sha": "bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYjkzZTJjYjVkZmJjZmE1ZTIwYzk3NzFmOTYzODM2NDc3NWQ4MzU3",
    "commit": {
      "author": {
        "name": "Ashley Holman",
        "email": "dscvlt@gmail.com",
        "date": "2015-06-24T08:32:20Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "TxMemPool: Change mapTx to a boost::multi_index_container\n\nIndexes on:\n- Tx Hash\n- Fee Rate (fee-per-kb)",
      "tree": {
        "sha": "6a01e4529b2208a068e7002f6089c480611183da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a01e4529b2208a068e7002f6089c480611183da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/comments",
    "author": {
      "login": "ashleyholman",
      "id": 549484,
      "node_id": "MDQ6VXNlcjU0OTQ4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ashleyholman",
      "html_url": "https://github.com/ashleyholman",
      "followers_url": "https://api.github.com/users/ashleyholman/followers",
      "following_url": "https://api.github.com/users/ashleyholman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ashleyholman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ashleyholman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ashleyholman/subscriptions",
      "organizations_url": "https://api.github.com/users/ashleyholman/orgs",
      "repos_url": "https://api.github.com/users/ashleyholman/repos",
      "events_url": "https://api.github.com/users/ashleyholman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ashleyholman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87f37e259d6deb52ee464edde7aece687eea97a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87f37e259d6deb52ee464edde7aece687eea97a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87f37e259d6deb52ee464edde7aece687eea97a5"
      }
    ],
    "stats": {
      "total": 159,
      "additions": 127,
      "deletions": 32
    },
    "files": [
      {
        "sha": "64c1a93239b390ebf178f5b19864160dd9e6da57",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -158,10 +158,10 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n-        for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n+        for (CTxMemPool::indexed_transaction_set::iterator mi = mempool.mapTx.begin();\n              mi != mempool.mapTx.end(); ++mi)\n         {\n-            const CTransaction& tx = mi->second.GetTx();\n+            const CTransaction& tx = mi->GetTx();\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight, pblock->nTime))\n                 continue;\n \n@@ -196,7 +196,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                     }\n                     mapDependers[txin.prevout.hash].push_back(porphan);\n                     porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].GetTx().vout[txin.prevout.n].nValue;\n+                    nTotalIn += mempool.mapTx.find(txin.prevout.hash)->GetTx().vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n                 const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n@@ -226,7 +226,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 porphan->feeRate = feeRate;\n             }\n             else\n-                vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n+                vecPriority.push_back(TxPriority(dPriority, feeRate, &(mi->GetTx())));\n         }\n \n         // Collect transactions into block"
      },
      {
        "sha": "76eae6d434b136219abd818f339ec819aff97247",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -218,10 +218,9 @@ UniValue getrawmempool(const UniValue& params, bool fHelp)\n     {\n         LOCK(mempool.cs);\n         UniValue o(UniValue::VOBJ);\n-        BOOST_FOREACH(const PAIRTYPE(uint256, CTxMemPoolEntry)& entry, mempool.mapTx)\n+        BOOST_FOREACH(const CTxMemPoolEntry& e, mempool.mapTx)\n         {\n-            const uint256& hash = entry.first;\n-            const CTxMemPoolEntry& e = entry.second;\n+            const uint256& hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n             info.push_back(Pair(\"size\", (int)e.GetTxSize()));\n             info.push_back(Pair(\"fee\", ValueFromAmount(e.GetFee())));"
      },
      {
        "sha": "7f82a61bf30cf91bc78db3c26e4598996991a65e",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -100,4 +100,56 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     removed.clear();\n }\n \n+BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+\n+    /* 3rd highest fee */\n+    CMutableTransaction tx1 = CMutableTransaction();\n+    tx1.vout.resize(1);\n+    tx1.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx1.vout[0].nValue = 10 * COIN;\n+    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, true));\n+\n+    /* highest fee */\n+    CMutableTransaction tx2 = CMutableTransaction();\n+    tx2.vout.resize(1);\n+    tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx2.vout[0].nValue = 2 * COIN;\n+    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 20000LL, 0, 9.0, 1, true));\n+\n+    /* lowest fee */\n+    CMutableTransaction tx3 = CMutableTransaction();\n+    tx3.vout.resize(1);\n+    tx3.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx3.vout[0].nValue = 5 * COIN;\n+    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 0LL, 0, 100.0, 1, true));\n+\n+    /* 2nd highest fee */\n+    CMutableTransaction tx4 = CMutableTransaction();\n+    tx4.vout.resize(1);\n+    tx4.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx4.vout[0].nValue = 6 * COIN;\n+    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 15000LL, 0, 1.0, 1, true));\n+\n+    /* equal fee rate to tx1, but newer */\n+    CMutableTransaction tx5 = CMutableTransaction();\n+    tx5.vout.resize(1);\n+    tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx5.vout[0].nValue = 11 * COIN;\n+    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n+\n+    // there should be 4 transactions in the mempool\n+    BOOST_CHECK_EQUAL(pool.size(), 5);\n+\n+    // Check the fee-rate index is in order, should be tx2, tx4, tx1, tx5, tx3\n+    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx2.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx4.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx1.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx5.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx3.GetHash().ToString());\n+    BOOST_CHECK(it == pool.mapTx.get<1>().end());\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c410cd08323b2b28b7cc7b4c159af37896eebc19",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 24,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -32,6 +32,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n     nUsageSize = RecursiveDynamicUsage(tx);\n+    feeRate = CFeeRate(nFee, nTxSize);\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -96,8 +97,8 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n-    mapTx[hash] = entry;\n-    const CTransaction& tx = mapTx[hash].GetTx();\n+    mapTx.insert(entry);\n+    const CTransaction& tx = mapTx.find(hash)->GetTx();\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n         mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n     nTransactionsUpdated++;\n@@ -134,7 +135,7 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n             txToRemove.pop_front();\n             if (!mapTx.count(hash))\n                 continue;\n-            const CTransaction& tx = mapTx[hash].GetTx();\n+            const CTransaction& tx = mapTx.find(hash)->GetTx();\n             if (fRecursive) {\n                 for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                     std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n@@ -147,8 +148,8 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n                 mapNextTx.erase(txin.prevout);\n \n             removed.push_back(tx);\n-            totalTxSize -= mapTx[hash].GetTxSize();\n-            cachedInnerUsage -= mapTx[hash].DynamicMemoryUsage();\n+            totalTxSize -= mapTx.find(hash)->GetTxSize();\n+            cachedInnerUsage -= mapTx.find(hash)->DynamicMemoryUsage();\n             mapTx.erase(hash);\n             nTransactionsUpdated++;\n             minerPolicyEstimator->removeTx(hash);\n@@ -161,10 +162,10 @@ void CTxMemPool::removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned in\n     // Remove transactions spending a coinbase which are now immature\n     LOCK(cs);\n     list<CTransaction> transactionsToRemove;\n-    for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n-        const CTransaction& tx = it->second.GetTx();\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+        const CTransaction& tx = it->GetTx();\n         BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n-            std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end())\n                 continue;\n             const CCoins *coins = pcoins->AccessCoins(txin.prevout.hash);\n@@ -209,8 +210,10 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         uint256 hash = tx.GetHash();\n-        if (mapTx.count(hash))\n-            entries.push_back(mapTx[hash]);\n+\n+        indexed_transaction_set::iterator i = mapTx.find(hash);\n+        if (i != mapTx.end())\n+            entries.push_back(*i);\n     }\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n@@ -247,17 +250,17 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n     LOCK(cs);\n     list<const CTxMemPoolEntry*> waitingOnDependants;\n-    for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n-        checkTotal += it->second.GetTxSize();\n-        innerUsage += it->second.DynamicMemoryUsage();\n-        const CTransaction& tx = it->second.GetTx();\n+        checkTotal += it->GetTxSize();\n+        innerUsage += it->DynamicMemoryUsage();\n+        const CTransaction& tx = it->GetTx();\n         bool fDependsWait = false;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n-            std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n-                const CTransaction& tx2 = it2->second.GetTx();\n+                const CTransaction& tx2 = it2->GetTx();\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 fDependsWait = true;\n             } else {\n@@ -272,7 +275,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             i++;\n         }\n         if (fDependsWait)\n-            waitingOnDependants.push_back(&it->second);\n+            waitingOnDependants.push_back(&(*it));\n         else {\n             CValidationState state;\n             assert(CheckInputs(tx, state, mempoolDuplicate, false, 0, false, NULL));\n@@ -296,8 +299,8 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     }\n     for (std::map<COutPoint, CInPoint>::const_iterator it = mapNextTx.begin(); it != mapNextTx.end(); it++) {\n         uint256 hash = it->second.ptx->GetHash();\n-        map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(hash);\n-        const CTransaction& tx = it2->second.GetTx();\n+        indexed_transaction_set::const_iterator it2 = mapTx.find(hash);\n+        const CTransaction& tx = it2->GetTx();\n         assert(it2 != mapTx.end());\n         assert(&tx == it->second.ptx);\n         assert(tx.vin.size() > it->second.n);\n@@ -314,16 +317,16 @@ void CTxMemPool::queryHashes(vector<uint256>& vtxid)\n \n     LOCK(cs);\n     vtxid.reserve(mapTx.size());\n-    for (map<uint256, CTxMemPoolEntry>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n-        vtxid.push_back((*mi).first);\n+    for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n+        vtxid.push_back(mi->GetTx().GetHash());\n }\n \n bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n {\n     LOCK(cs);\n-    map<uint256, CTxMemPoolEntry>::const_iterator i = mapTx.find(hash);\n+    indexed_transaction_set::const_iterator i = mapTx.find(hash);\n     if (i == mapTx.end()) return false;\n-    result = i->second.GetTx();\n+    result = i->GetTx();\n     return true;\n }\n \n@@ -429,5 +432,6 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n }"
      },
      {
        "sha": "6b6b05454a4eee3fd1dda5bc13993c5f3a2578bc",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 41,
        "deletions": 1,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -13,6 +13,10 @@\n #include \"primitives/transaction.h\"\n #include \"sync.h\"\n \n+#undef foreach\n+#include \"boost/multi_index_container.hpp\"\n+#include \"boost/multi_index/ordered_index.hpp\"\n+\n class CAutoFile;\n \n inline double AllowFreeThreshold()\n@@ -41,6 +45,7 @@ class CTxMemPoolEntry\n     size_t nTxSize; //! ... and avoid recomputing tx size\n     size_t nModSize; //! ... and modified size for priority\n     size_t nUsageSize; //! ... and total memory usage\n+    CFeeRate feeRate; //! ... and fee per kB\n     int64_t nTime; //! Local time when entering the mempool\n     double dPriority; //! Priority when entering the mempool\n     unsigned int nHeight; //! Chain height when entering the mempool\n@@ -55,13 +60,35 @@ class CTxMemPoolEntry\n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n     CAmount GetFee() const { return nFee; }\n+    CFeeRate GetFeeRate() const { return feeRate; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n };\n \n+// extracts a TxMemPoolEntry's transaction hash\n+struct mempoolentry_txid\n+{\n+    typedef uint256 result_type;\n+    result_type operator() (const CTxMemPoolEntry &entry) const\n+    {\n+        return entry.GetTx().GetHash();\n+    }\n+};\n+\n+class CompareTxMemPoolEntryByFee\n+{\n+public:\n+    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n+    {\n+        if (a.GetFeeRate() == b.GetFeeRate())\n+            return a.GetTime() < b.GetTime();\n+        return a.GetFeeRate() > b.GetFeeRate();\n+    }\n+};\n+\n class CBlockPolicyEstimator;\n \n /** An inpoint - a combination of a transaction and an index n into its vin */\n@@ -99,8 +126,21 @@ class CTxMemPool\n     uint64_t cachedInnerUsage; //! sum of dynamic memory usage of all the map elements (NOT the maps themselves)\n \n public:\n+    typedef boost::multi_index_container<\n+        CTxMemPoolEntry,\n+        boost::multi_index::indexed_by<\n+            // sorted by txid\n+            boost::multi_index::ordered_unique<mempoolentry_txid>,\n+            // sorted by fee rate\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::identity<CTxMemPoolEntry>,\n+                CompareTxMemPoolEntryByFee\n+            >\n+        >\n+    > indexed_transaction_set;\n+\n     mutable CCriticalSection cs;\n-    std::map<uint256, CTxMemPoolEntry> mapTx;\n+    indexed_transaction_set mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n "
      }
    ]
  },
  {
    "sha": "9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZGM0ZTcwNTFjMmQ0ZTY1NjlmOTBkOWM3ZTA0N2ZiN2YwZDYwZDlj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2015-07-11T14:49:11Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Move orphan tx handling to a separate log class",
      "tree": {
        "sha": "ff8c125e470a74da02efe9b09af99b801a428fa0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff8c125e470a74da02efe9b09af99b801a428fa0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bb93e2cb5dfbcfa5e20c9771f9638364775d8357"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "cd03649081b8e0d7da9736770e27d948b6ee7892",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
        "patch": "@@ -574,7 +574,7 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n     unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n     if (sz > 5000)\n     {\n-        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n+        LogPrint(\"orphan\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n     }\n \n@@ -583,7 +583,7 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n \n-    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %u prevsz %u)\\n\", hash.ToString(),\n+    LogPrint(\"orphan\", \"stored orphan tx %s (mapsz %u prevsz %u)\\n\", hash.ToString(),\n              mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n     return true;\n }\n@@ -618,7 +618,7 @@ void EraseOrphansFor(NodeId peer)\n             ++nErased;\n         }\n     }\n-    if (nErased > 0) LogPrint(\"mempool\", \"Erased %d orphan tx from peer %d\\n\", nErased, peer);\n+    if (nErased > 0) LogPrint(\"orphan\", \"Erased %d orphan tx from peer %d\\n\", nErased, peer);\n }\n \n \n@@ -4284,7 +4284,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         continue;\n                     if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))\n                     {\n-                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(\"orphan\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx);\n                         vWorkQueue.push_back(orphanHash);\n                         vEraseQueue.push_back(orphanHash);\n@@ -4297,11 +4297,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             // Punish peer that gave us an invalid orphan tx\n                             Misbehaving(fromPeer, nDos);\n                             setMisbehaving.insert(fromPeer);\n-                            LogPrint(\"mempool\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n+                            LogPrint(\"orphan\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n                         // Has inputs but not accepted to mempool\n                         // Probably non-standard or insufficient fee/priority\n-                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(\"orphan\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n                         assert(recentRejects);\n                         recentRejects->insert(orphanHash);\n@@ -4321,7 +4321,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n             unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n             if (nEvicted > 0)\n-                LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                LogPrint(\"orphan\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n         } else {\n             // AcceptToMemoryPool() returned false, possibly because the tx is\n             // already in the mempool; if the tx isn't in the mempool that"
      }
    ]
  },
  {
    "sha": "04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNGNmNGJhZWFlMGExODdjZmZiNzcxY2ViNGVhYzc4YTRiY2RmZGIw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-07-10T21:52:53Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Implement on-the-fly mempool size limitation.",
      "tree": {
        "sha": "ef8ec4308d4432780d79e424cb6be48135943ff3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef8ec4308d4432780d79e424cb6be48135943ff3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c"
      }
    ],
    "stats": {
      "total": 193,
      "additions": 171,
      "deletions": 22
    },
    "files": [
      {
        "sha": "53386c05c7df9dd899f069f903fcf2a1a1d26325",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "patch": "@@ -288,6 +288,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+    strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n #ifndef WIN32"
      },
      {
        "sha": "feefc16a725b1918c7b2a3e9260be03fc776964b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 4,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "patch": "@@ -879,24 +879,31 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CAmount nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());\n \n-        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n+        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n+        // Try to make space in mempool\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+        if (!pool.StageTrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, entry, stagedelete, nFeesDeleted)) {\n+            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+        }\n+\n         // Don't accept it if it can't get into a block\n         CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n         if (fLimitFree && nFees < txMinFee)\n             return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n-                strprintf(\"%d < %d\", nFees, txMinFee));\n+                strprintf(\"%d < %d\", nFees, txMinFee + nFeesDeleted));\n \n         // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+        if (GetBoolArg(\"-relaypriority\", true) && nFees - nFeesDeleted < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n             return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n         }\n \n         // Continuously rate-limit free (really, very-low-fee) transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make others' transactions take longer to confirm.\n-        if (fLimitFree && nFees < ::minRelayTxFee.GetFee(nSize))\n+        if (fLimitFree && nFees - nFeesDeleted < ::minRelayTxFee.GetFee(nSize))\n         {\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n@@ -941,6 +948,12 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 __func__, hash.ToString(), FormatStateMessage(state));\n         }\n \n+        // Delete staged transactions to actually make space in mempool\n+        if (!stagedelete.empty()) {\n+            LogPrint(\"mempool\", \"Removing %u transactions (%d fees) from the mempool to make space for %s\\n\", stagedelete.size(), nFeesDeleted, tx.GetHash().ToString());\n+            pool.RemoveStaged(stagedelete);\n+        }\n+\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n     }"
      },
      {
        "sha": "f72d9ad102c7743d0090857cb41fbb729e204a93",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "patch": "@@ -43,6 +43,8 @@ struct CNodeStateStats;\n static const bool DEFAULT_ALERTS = true;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n+/** Default for -maxmempool, maximum megabytes of mempool memory usage */\n+static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 500;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */"
      },
      {
        "sha": "68be34ca1d7c9fe38b3e141231404759ab7b5ff4",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "patch": "@@ -80,12 +80,24 @@ static inline size_t DynamicUsage(const std::set<X>& s)\n     return MallocUsage(sizeof(stl_tree_node<X>)) * s.size();\n }\n \n+template<typename X>\n+static inline size_t IncrementalDynamicUsage(const std::set<X>& s)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<X>));\n+}\n+\n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::map<X, Y>& m)\n {\n     return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >)) * m.size();\n }\n \n+template<typename X, typename Y>\n+static inline size_t IncrementalDynamicUsage(const std::map<X, Y>& m)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >));\n+}\n+\n // Boost data structures\n \n template<typename X>"
      },
      {
        "sha": "557d7c3323706464056ea2c734b42b4e264fb3e2",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 118,
        "deletions": 11,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "patch": "@@ -32,7 +32,6 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n     nUsageSize = RecursiveDynamicUsage(tx);\n-    feeRate = CFeeRate(nFee, nTxSize);\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -49,9 +48,10 @@ CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n     return dResult;\n }\n \n-CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n-    nTransactionsUpdated(0)\n+CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee)\n {\n+    clear();\n+\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n@@ -109,6 +109,19 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     return true;\n }\n \n+void CTxMemPool::removeUnchecked(const uint256& hash)\n+{\n+    indexed_transaction_set::iterator it = mapTx.find(hash);\n+\n+    BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n+        mapNextTx.erase(txin.prevout);\n+\n+    totalTxSize -= it->GetTxSize();\n+    cachedInnerUsage -= it->DynamicMemoryUsage();\n+    mapTx.erase(it);\n+    nTransactionsUpdated++;\n+    minerPolicyEstimator->removeTx(hash);\n+}\n \n void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& removed, bool fRecursive)\n {\n@@ -144,15 +157,8 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n                     txToRemove.push_back(it->second.ptx->GetHash());\n                 }\n             }\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-                mapNextTx.erase(txin.prevout);\n-\n             removed.push_back(tx);\n-            totalTxSize -= mapTx.find(hash)->GetTxSize();\n-            cachedInnerUsage -= mapTx.find(hash)->DynamicMemoryUsage();\n-            mapTx.erase(hash);\n-            nTransactionsUpdated++;\n-            minerPolicyEstimator->removeTx(hash);\n+            removeUnchecked(hash);\n         }\n     }\n }\n@@ -435,3 +441,104 @@ size_t CTxMemPool::DynamicMemoryUsage() const {\n     // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n }\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeesRemoved) {\n+    size_t nSizeRemoved = 0;\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n+        protect.insert(in.prevout.hash);\n+    }\n+\n+    size_t expsize = DynamicMemoryUsage() + GuessDynamicMemoryUsage(toadd); // Track the expected resulting memory usage of the mempool.\n+    indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n+    int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n+    // Iterate from lowest feerate to highest feerate in the mempool:\n+    while (expsize > sizelimit && it != mapTx.get<1>().rend()) {\n+        const uint256& hash = it->GetTx().GetHash();\n+        if (stage.count(hash)) {\n+            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n+            it++;\n+            continue;\n+        }\n+        if (GetRand(10)) {\n+            // Only try 1/10 of the transactions, in order to have some chance to avoid very big chains.\n+            it++;\n+            continue;\n+        }\n+        if (CompareTxMemPoolEntryByFeeRate()(*it, toadd)) {\n+            // If the transaction's feerate is worse than what we're looking for, we have processed everything in the mempool\n+            // that could improve the staged set. If we don't have an acceptable solution by now, bail out.\n+            return false;\n+        }\n+        std::deque<uint256> todo; // List of hashes that we still need to process (descendants of 'hash').\n+        std::set<uint256> now; // Set of hashes that will need to be added to stage if 'hash' is included.\n+        CAmount nowfee = 0; // Sum of the fees in 'now'.\n+        size_t nowsize = 0; // Sum of the tx sizes in 'now'.\n+        size_t nowusage = 0; // Sum of the memory usages of transactions in 'now'.\n+        int iternow = 0; // Transactions we've inspected so far while determining whether 'hash' is acceptable.\n+        todo.push_back(it->GetTx().GetHash()); // Add 'hash' to the todo list, to initiate processing its children.\n+        bool good = true; // Whether including 'hash' (and all its descendants) is a good idea.\n+        // Iterate breadth-first over all descendants of transaction with hash 'hash'.\n+        while (!todo.empty()) {\n+            uint256 hashnow = todo.front();\n+            if (protect.count(hashnow)) {\n+                // If this transaction is in the protected set, we're done with 'hash'.\n+                good = false;\n+                break;\n+            }\n+            iternow++; // We only count transactions we actually had to go find in the mempool.\n+            if (iternow + fails > 20) {\n+                return false;\n+            }\n+            const CTxMemPoolEntry* origTx = &*mapTx.find(hashnow);\n+            nowfee += origTx->GetFee();\n+            if (nFeesRemoved + nowfee > toadd.GetFee()) {\n+                // If this pushes up to the total fees deleted too high, we're done with 'hash'.\n+                good = false;\n+                break;\n+            }\n+            todo.pop_front();\n+            // Add 'hashnow' to the 'now' set, and update its statistics.\n+            now.insert(hashnow);\n+            nowusage += GuessDynamicMemoryUsage(*origTx);\n+            nowsize += origTx->GetTxSize();\n+            // Find dependencies of 'hashnow' and them to todo.\n+            std::map<COutPoint, CInPoint>::iterator iter = mapNextTx.lower_bound(COutPoint(hashnow, 0));\n+            while (iter != mapNextTx.end() && iter->first.hash == hashnow) {\n+                const uint256& nexthash = iter->second.ptx->GetHash();\n+                if (!(stage.count(nexthash) || now.count(nexthash))) {\n+                    todo.push_back(nexthash);\n+                }\n+                iter++;\n+            }\n+        }\n+        if (good && (double)nowfee * toadd.GetTxSize() > (double)toadd.GetFee() * nowsize) {\n+            // The new transaction's feerate is below that of the set we're removing.\n+            good = false;\n+        }\n+        if (good) {\n+            stage.insert(now.begin(), now.end());\n+            nFeesRemoved += nowfee;\n+            nSizeRemoved += nowsize;\n+            expsize -= nowusage;\n+        } else {\n+            fails += iternow;\n+            if (fails > 10) {\n+                // Bail out after traversing 32 transactions that are not acceptable.\n+                return false;\n+            }\n+        }\n+        it++;\n+    }\n+    return true;\n+}\n+\n+void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {\n+    BOOST_FOREACH(const uint256& hash, stage) {\n+        removeUnchecked(hash);\n+    }\n+}"
      },
      {
        "sha": "191b3794674ab32c4de8b90b88bd8de3fa844b03",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 21,
        "deletions": 7,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "patch": "@@ -45,7 +45,6 @@ class CTxMemPoolEntry\n     size_t nTxSize; //! ... and avoid recomputing tx size\n     size_t nModSize; //! ... and modified size for priority\n     size_t nUsageSize; //! ... and total memory usage\n-    CFeeRate feeRate; //! ... and fee per kB\n     int64_t nTime; //! Local time when entering the mempool\n     double dPriority; //! Priority when entering the mempool\n     unsigned int nHeight; //! Chain height when entering the mempool\n@@ -59,8 +58,7 @@ class CTxMemPoolEntry\n \n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n-    CAmount GetFee() const { return nFee; }\n-    CFeeRate GetFeeRate() const { return feeRate; }\n+    const CAmount& GetFee() const { return nFee; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n@@ -78,14 +76,18 @@ struct mempoolentry_txid\n     }\n };\n \n-class CompareTxMemPoolEntryByFee\n+class CompareTxMemPoolEntryByFeeRate\n {\n public:\n     bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n     {\n-        if (a.GetFeeRate() == b.GetFeeRate())\n+        // Avoid a division by rewriting (a/b > c/d) as (a*d > c*b).\n+        double f1 = (double)a.GetFee() * b.GetTxSize();\n+        double f2 = (double)b.GetFee() * a.GetTxSize();\n+        if (f1 == f2) {\n             return a.GetTime() < b.GetTime();\n-        return a.GetFeeRate() > b.GetFeeRate();\n+        }\n+        return f1 > f2;\n     }\n };\n \n@@ -134,7 +136,7 @@ class CTxMemPool\n             // sorted by fee rate\n             boost::multi_index::ordered_non_unique<\n                 boost::multi_index::identity<CTxMemPoolEntry>,\n-                CompareTxMemPoolEntryByFee\n+                CompareTxMemPoolEntryByFeeRate\n             >\n         >\n     > indexed_transaction_set;\n@@ -157,6 +159,7 @@ class CTxMemPool\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate = true);\n+    void removeUnchecked(const uint256& hash);\n     void remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive = false);\n     void removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);\n@@ -178,6 +181,16 @@ class CTxMemPool\n     void ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta);\n     void ClearPrioritisation(const uint256 hash);\n \n+    /** Build a list of transaction (hashes) to remove such that:\n+     *  - The list is consistent (if a parent is included, all its dependencies are included as well).\n+     *  - No dependencies of toadd are removed.\n+     *  - The total fees removed are not more than the fees added by toadd.\n+     *  - The feerate of what is removed is not better than the feerate of toadd.\n+     *  - Removing said list will reduce the DynamicMemoryUsage after adding toadd, below sizelimit.\n+     */\n+    bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeeRemoved);\n+    void RemoveStaged(std::set<uint256>& stage);\n+\n     unsigned long size()\n     {\n         LOCK(cs);\n@@ -209,6 +222,7 @@ class CTxMemPool\n     bool ReadFeeEstimates(CAutoFile& filein);\n \n     size_t DynamicMemoryUsage() const;\n+    size_t GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const;\n };\n \n /** "
      }
    ]
  },
  {
    "sha": "dac64967038944b4f041b1fa1b7240e8cd098146",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWM2NDk2NzAzODk0NGI0ZjA0MWIxZmExYjcyNDBlOGNkMDk4MTQ2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-07-18T23:48:58Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Mempool expiry",
      "tree": {
        "sha": "d29cd7dfb31d9bfcb43edc58a4d51d3fe3bf09c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d29cd7dfb31d9bfcb43edc58a4d51d3fe3bf09c0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dac64967038944b4f041b1fa1b7240e8cd098146",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac64967038944b4f041b1fa1b7240e8cd098146",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dac64967038944b4f041b1fa1b7240e8cd098146",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac64967038944b4f041b1fa1b7240e8cd098146/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 51,
      "deletions": 3
    },
    "files": [
      {
        "sha": "7943e4533af2d2b3a8e472282e4e4f72b7291fef",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac64967038944b4f041b1fa1b7240e8cd098146/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac64967038944b4f041b1fa1b7240e8cd098146/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=dac64967038944b4f041b1fa1b7240e8cd098146",
        "patch": "@@ -289,6 +289,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n+    strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n #ifndef WIN32"
      },
      {
        "sha": "fce79e6f4cb3f2b11e8516ebc20c21248f21bd0f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac64967038944b4f041b1fa1b7240e8cd098146/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac64967038944b4f041b1fa1b7240e8cd098146/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=dac64967038944b4f041b1fa1b7240e8cd098146",
        "patch": "@@ -875,6 +875,12 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d > %d\", nSigOps, MAX_STANDARD_TX_SIGOPS));\n \n+        // Expire old transactions before trying to replace low-priority ones.\n+        int expired = pool.Expire(GetTime() - GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+        if (expired != 0) {\n+            LogPrint(\"mempool\", \"Expired %i transactions from the memory pool\\n\", expired);\n+        }\n+\n         CAmount nValueOut = tx.GetValueOut();\n         CAmount nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());"
      },
      {
        "sha": "c14d513a67d2d242d4de1487fd5dbf58b9e8933a",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac64967038944b4f041b1fa1b7240e8cd098146/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac64967038944b4f041b1fa1b7240e8cd098146/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=dac64967038944b4f041b1fa1b7240e8cd098146",
        "patch": "@@ -45,6 +45,8 @@ static const bool DEFAULT_ALERTS = true;\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Default for -maxmempool, maximum megabytes of mempool memory usage */\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 500;\n+/** Default for -mempoolexpiry, expiration time for mempool transactions in hours */\n+static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 168;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */"
      },
      {
        "sha": "497ba717c0337efe96a11a1face564af63e6b7e6",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 3,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac64967038944b4f041b1fa1b7240e8cd098146/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac64967038944b4f041b1fa1b7240e8cd098146/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=dac64967038944b4f041b1fa1b7240e8cd098146",
        "patch": "@@ -438,12 +438,12 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n }\n \n size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n }\n \n bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeesRemoved) {\n@@ -542,3 +542,25 @@ void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {\n         removeUnchecked(hash);\n     }\n }\n+\n+int CTxMemPool::Expire(int64_t time) {\n+    indexed_transaction_set::nth_index<2>::type::iterator it = mapTx.get<2>().begin();\n+    std::set<uint256> toremove;\n+    int ret = 0;\n+    while (it != mapTx.get<2>().end() && it->GetTime() < time) {\n+        toremove.insert(it->GetTx().GetHash());\n+        it++;\n+    }\n+    while (!toremove.empty()) {\n+        std::set<uint256>::iterator ite = toremove.begin();\n+        std::map<COutPoint, CInPoint>::iterator iter = mapNextTx.lower_bound(COutPoint(*ite, 0));\n+        while (iter != mapNextTx.end() && iter->first.hash == *ite) {\n+            toremove.insert(iter->second.ptx->GetHash());\n+            iter++;\n+        }\n+        ret++;\n+        removeUnchecked(*ite);\n+        toremove.erase(ite);\n+    }\n+    return ret;\n+}"
      },
      {
        "sha": "ee4a2f5f16a6642a05c96625f8c0f2c9f371a569",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac64967038944b4f041b1fa1b7240e8cd098146/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac64967038944b4f041b1fa1b7240e8cd098146/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=dac64967038944b4f041b1fa1b7240e8cd098146",
        "patch": "@@ -91,6 +91,15 @@ class CompareTxMemPoolEntryByFeeRate\n     }\n };\n \n+class CompareTxMemPoolEntryByEntryTime\n+{\n+public:\n+    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n+    {\n+        return a.GetTime() < b.GetTime();\n+    }\n+};\n+\n class CBlockPolicyEstimator;\n \n /** An inpoint - a combination of a transaction and an index n into its vin */\n@@ -137,6 +146,11 @@ class CTxMemPool\n             boost::multi_index::ordered_non_unique<\n                 boost::multi_index::identity<CTxMemPoolEntry>,\n                 CompareTxMemPoolEntryByFeeRate\n+            >,\n+            // sorted by entry time\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::identity<CTxMemPoolEntry>,\n+                CompareTxMemPoolEntryByEntryTime\n             >\n         >\n     > indexed_transaction_set;\n@@ -191,6 +205,9 @@ class CTxMemPool\n     bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeeRemoved);\n     void RemoveStaged(std::set<uint256>& stage);\n \n+    /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n+    int Expire(int64_t time);\n+\n     unsigned long size()\n     {\n         LOCK(cs);"
      }
    ]
  },
  {
    "sha": "9297953cde2c7a53645acdba7b2994427243f37c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Mjk3OTUzY2RlMmM3YTUzNjQ1YWNkYmE3YjI5OTQ0MjcyNDNmMzdj",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-07-21T17:52:15Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Add a notion of reserved space.\n\nThe mempool will now have a soft cap set below its hard cap.  After it fills up to the soft cap, transactions much first try using StageTrimToSize to evict the amount of size they are adding.  If they fail they can still be let into the mempool if they pass a higher relay minimum.  It doubles 10 times between the soft cap and hard cap.",
      "tree": {
        "sha": "d6ac155f685bd24385e3e722238e67919f56882c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6ac155f685bd24385e3e722238e67919f56882c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9297953cde2c7a53645acdba7b2994427243f37c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9297953cde2c7a53645acdba7b2994427243f37c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9297953cde2c7a53645acdba7b2994427243f37c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9297953cde2c7a53645acdba7b2994427243f37c/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dac64967038944b4f041b1fa1b7240e8cd098146",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac64967038944b4f041b1fa1b7240e8cd098146",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dac64967038944b4f041b1fa1b7240e8cd098146"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 33,
      "deletions": 5
    },
    "files": [
      {
        "sha": "075fcd65f1e8579af1e82ff7187c23e39331a883",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 3,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9297953cde2c7a53645acdba7b2994427243f37c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9297953cde2c7a53645acdba7b2994427243f37c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9297953cde2c7a53645acdba7b2994427243f37c",
        "patch": "@@ -888,11 +888,36 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Try to make space in mempool\n+        // If the predicted mempool usage is under the softcap, StageTrimToSize will return success.\n+        // Otherwise StageTrimToSize will attempt to find appropriate transactions of lesser\n+        // feerate to evict from the mempool.  If this fails and the mempool usage would be under\n+        // the hardcap there is an opportunity for this transaction to enter the mempool anyway if\n+        // it has a fee high enough to pass an increased minimum relay feerate.  The are 10 bands\n+        // of doubling the effective minimum feerate between the softcap and hardcap.\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n         std::set<uint256> stagedelete;\n         CAmount nFeesDeleted = 0;\n-        if (!pool.StageTrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, entry, stagedelete, nFeesDeleted)) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+        if (!pool.StageTrimToSize(softcap, entry, stagedelete, nFeesDeleted)) {\n+            size_t expsize = pool.DynamicMemoryUsage() + pool.GuessDynamicMemoryUsage(entry);\n+            if (expsize > hardcap) {\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\");\n+            } else {\n+                assert(expsize > softcap);\n+                int rateZone = (expsize - softcap)/capstep + 1;\n+                int relayMult = 1 << rateZone;\n+                if (nFees < relayMult * ::minRelayTxFee.GetFee(nSize)) {\n+                    return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\");\n+                } else {\n+                    // The fee rate of this transaction is high enough to enter into the reserve space\n+                    // If stagedelete is non-empty at this point, it has only been populated with sets of transactions\n+                    // that each have lower fee-rate than this transaction.  As such, it is safe to also still delete\n+                    // the partial eviction set, as the effective fee rate for any remaining part of the transaction\n+                    // would only have been higher than the original fee rate, and still passed the test for reserve space.\n+                    LogPrint(\"mempool\", \"Tx %s entering reserve space size/fee %ld %ld at usage of %5.2f and mult of %d\\n\",tx.GetHash().ToString().substr(0,10).c_str(),nSize,nFees, expsize, relayMult);\n+                }\n+            }\n         }\n \n         // Don't accept it if it can't get into a block"
      },
      {
        "sha": "c29084aa4ec6cc03dae948a80a0db6c466b41bd0",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9297953cde2c7a53645acdba7b2994427243f37c/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9297953cde2c7a53645acdba7b2994427243f37c/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=9297953cde2c7a53645acdba7b2994427243f37c",
        "patch": "@@ -453,11 +453,13 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n         protect.insert(in.prevout.hash);\n     }\n \n-    size_t expsize = DynamicMemoryUsage() + GuessDynamicMemoryUsage(toadd); // Track the expected resulting memory usage of the mempool.\n+    size_t incUsage = GuessDynamicMemoryUsage(toadd);\n+    size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n+    size_t usageRemoved = 0;\n     indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n     int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n     // Iterate from lowest feerate to highest feerate in the mempool:\n-    while (expsize > sizelimit && it != mapTx.get<1>().rend()) {\n+    while (expsize > sizelimit && usageRemoved < incUsage && it != mapTx.get<1>().rend()) {\n         const uint256& hash = it->GetTx().GetHash();\n         if (stage.count(hash)) {\n             // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n@@ -524,6 +526,7 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n             stage.insert(now.begin(), now.end());\n             nFeesRemoved += nowfee;\n             nSizeRemoved += nowsize;\n+\t    usageRemoved += nowusage;\n             expsize -= nowusage;\n         } else {\n             fails += iternow;"
      }
    ]
  },
  {
    "sha": "988131646665654d7758b48dafe5b6ad39745134",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ODgxMzE2NDY2NjU2NTRkNzc1OGI0OGRhZmU1YjZhZDM5NzQ1MTM0",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-07-16T14:25:33Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Make StageTrimToSize aware of any minimum relay fee.\n\nStageTrimToSize will make several attempts to find a set of transactions it can evict from the mempool to make room for the new transaction.  It should be aware of any required minimum relay fee that needs to be paid for by the new transaction after accounting for the fees of the deleted transactions.",
      "tree": {
        "sha": "0187db83940eb72328d2c0e49df2a14544345e03",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0187db83940eb72328d2c0e49df2a14544345e03"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/988131646665654d7758b48dafe5b6ad39745134",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/988131646665654d7758b48dafe5b6ad39745134",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/988131646665654d7758b48dafe5b6ad39745134",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/988131646665654d7758b48dafe5b6ad39745134/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9297953cde2c7a53645acdba7b2994427243f37c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9297953cde2c7a53645acdba7b2994427243f37c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9297953cde2c7a53645acdba7b2994427243f37c"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 21,
      "deletions": 15
    },
    "files": [
      {
        "sha": "9a011b7c677339a751c837615bd79733ba3481eb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 12,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/988131646665654d7758b48dafe5b6ad39745134/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/988131646665654d7758b48dafe5b6ad39745134/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=988131646665654d7758b48dafe5b6ad39745134",
        "patch": "@@ -888,6 +888,22 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                                 strprintf(\"%d < %d\", nFees, nFeesRequired));\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n         // If the predicted mempool usage is under the softcap, StageTrimToSize will return success.\n         // Otherwise StageTrimToSize will attempt to find appropriate transactions of lesser\n         // feerate to evict from the mempool.  If this fails and the mempool usage would be under\n@@ -899,7 +915,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         size_t capstep = (hardcap - softcap) / 10;\n         std::set<uint256> stagedelete;\n         CAmount nFeesDeleted = 0;\n-        if (!pool.StageTrimToSize(softcap, entry, stagedelete, nFeesDeleted)) {\n+        if (!pool.StageTrimToSize(softcap, entry, nFeesRequired, stagedelete, nFeesDeleted)) {\n             size_t expsize = pool.DynamicMemoryUsage() + pool.GuessDynamicMemoryUsage(entry);\n             if (expsize > hardcap) {\n                 return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\");\n@@ -920,17 +936,6 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             }\n         }\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n-                strprintf(\"%d < %d\", nFees, txMinFee + nFeesDeleted));\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees - nFeesDeleted < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n-        }\n-\n         // Continuously rate-limit free (really, very-low-fee) transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make others' transactions take longer to confirm."
      },
      {
        "sha": "f3306549e8fdfb0ef6ca36bc229e9e2585c71f53",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/988131646665654d7758b48dafe5b6ad39745134/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/988131646665654d7758b48dafe5b6ad39745134/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=988131646665654d7758b48dafe5b6ad39745134",
        "patch": "@@ -446,7 +446,8 @@ size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n }\n \n-bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeesRemoved) {\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, CAmount nFeesReserved,\n+                                 std::set<uint256>& stage, CAmount& nFeesRemoved) {\n     size_t nSizeRemoved = 0;\n     std::set<uint256> protect;\n     BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n@@ -498,7 +499,7 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n             }\n             const CTxMemPoolEntry* origTx = &*mapTx.find(hashnow);\n             nowfee += origTx->GetFee();\n-            if (nFeesRemoved + nowfee > toadd.GetFee()) {\n+            if (nFeesReserved + nFeesRemoved + nowfee > toadd.GetFee()) {\n                 // If this pushes up to the total fees deleted too high, we're done with 'hash'.\n                 good = false;\n                 break;"
      },
      {
        "sha": "2177348a7d9203d2d97d515a7055c30dc79bb8fc",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/988131646665654d7758b48dafe5b6ad39745134/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/988131646665654d7758b48dafe5b6ad39745134/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=988131646665654d7758b48dafe5b6ad39745134",
        "patch": "@@ -202,7 +202,7 @@ class CTxMemPool\n      *  - The feerate of what is removed is not better than the feerate of toadd.\n      *  - Removing said list will reduce the DynamicMemoryUsage after adding toadd, below sizelimit.\n      */\n-    bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeeRemoved);\n+    bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, CAmount nFeesReserved, std::set<uint256>& stage, CAmount& nFeesRemoved);\n     void RemoveStaged(std::set<uint256>& stage);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */"
      }
    ]
  },
  {
    "sha": "2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZGQxYjRkZGQ5MzMzZDVkMjQ3ZjcyMGRmYzJjZjdiZjkwNWZjYTM1",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-07-22T15:57:03Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Refactor STTS to be usable for surplus trimming as well",
      "tree": {
        "sha": "5806450df30a1e54c2de73934aaf8ada1258cd0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5806450df30a1e54c2de73934aaf8ada1258cd0d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "988131646665654d7758b48dafe5b6ad39745134",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/988131646665654d7758b48dafe5b6ad39745134",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/988131646665654d7758b48dafe5b6ad39745134"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 19,
      "deletions": 10
    },
    "files": [
      {
        "sha": "505c6abc3a94319d9c20d69208df62a1674f124a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 10,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
        "patch": "@@ -448,19 +448,27 @@ size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n \n bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, CAmount nFeesReserved,\n                                  std::set<uint256>& stage, CAmount& nFeesRemoved) {\n-    size_t nSizeRemoved = 0;\n     std::set<uint256> protect;\n     BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n         protect.insert(in.prevout.hash);\n     }\n \n     size_t incUsage = GuessDynamicMemoryUsage(toadd);\n     size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n+    if (expsize > sizelimit) {\n+        size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n+        return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), stage, nFeesRemoved);\n+    } else\n+        return true;\n+}\n+\n+bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+                             std::set<uint256>& stage, CAmount &nFeesRemoved) {\n     size_t usageRemoved = 0;\n     indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n     int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n     // Iterate from lowest feerate to highest feerate in the mempool:\n-    while (expsize > sizelimit && usageRemoved < incUsage && it != mapTx.get<1>().rend()) {\n+    while (usageRemoved < sizeToTrim && it != mapTx.get<1>().rend()) {\n         const uint256& hash = it->GetTx().GetHash();\n         if (stage.count(hash)) {\n             // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n@@ -472,9 +480,9 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n             it++;\n             continue;\n         }\n-        if (CompareTxMemPoolEntryByFeeRate()(*it, toadd)) {\n-            // If the transaction's feerate is worse than what we're looking for, we have processed everything in the mempool\n-            // that could improve the staged set. If we don't have an acceptable solution by now, bail out.\n+        if ((double)it->GetFee() * sizeToUse > (double)feeToUse * it->GetTxSize()) {\n+            // If the transaction's feerate is worse than what we're looking for, nothing else we will iterate over\n+            // could improve the staged set. If we don't have an acceptable solution by now, bail out.\n             return false;\n         }\n         std::deque<uint256> todo; // List of hashes that we still need to process (descendants of 'hash').\n@@ -499,7 +507,7 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n             }\n             const CTxMemPoolEntry* origTx = &*mapTx.find(hashnow);\n             nowfee += origTx->GetFee();\n-            if (nFeesReserved + nFeesRemoved + nowfee > toadd.GetFee()) {\n+            if (nFeesReserved + nFeesRemoved + nowfee > feeToUse) {\n                 // If this pushes up to the total fees deleted too high, we're done with 'hash'.\n                 good = false;\n                 break;\n@@ -519,16 +527,14 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n                 iter++;\n             }\n         }\n-        if (good && (double)nowfee * toadd.GetTxSize() > (double)toadd.GetFee() * nowsize) {\n+        if (good && (double)nowfee * sizeToUse > (double)feeToUse * nowsize) {\n             // The new transaction's feerate is below that of the set we're removing.\n             good = false;\n         }\n         if (good) {\n             stage.insert(now.begin(), now.end());\n             nFeesRemoved += nowfee;\n-            nSizeRemoved += nowsize;\n-\t    usageRemoved += nowusage;\n-            expsize -= nowusage;\n+            usageRemoved += nowusage;\n         } else {\n             fails += iternow;\n             if (fails > 10) {\n@@ -539,6 +545,7 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n         it++;\n     }\n     return true;\n+\n }\n \n void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {"
      },
      {
        "sha": "72955806e9f6e86a25b89967b03960fa88c94011",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
        "patch": "@@ -203,6 +203,8 @@ class CTxMemPool\n      *  - Removing said list will reduce the DynamicMemoryUsage after adding toadd, below sizelimit.\n      */\n     bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, CAmount nFeesReserved, std::set<uint256>& stage, CAmount& nFeesRemoved);\n+    bool TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+\t\t     std::set<uint256>& stage, CAmount &nfeesRemoved);\n     void RemoveStaged(std::set<uint256>& stage);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */"
      }
    ]
  },
  {
    "sha": "40c38f895838651aba327c63db277f2924d4d3d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MGMzOGY4OTU4Mzg2NTFhYmEzMjdjNjNkYjI3N2YyOTI0ZDRkM2Q5",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-07-22T16:11:34Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "Implement Surplus Trim.\n\nUse reserve space between soft cap and hard cap as a reservoir of surplus fees that have been paid above the minRelayTxFee and occasionally use the aggregate usage there to trim from the bottom of the mempool.",
      "tree": {
        "sha": "d122aa69c46030f7aa02e1ff8ad6c637fac29987",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d122aa69c46030f7aa02e1ff8ad6c637fac29987"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/40c38f895838651aba327c63db277f2924d4d3d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40c38f895838651aba327c63db277f2924d4d3d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/40c38f895838651aba327c63db277f2924d4d3d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40c38f895838651aba327c63db277f2924d4d3d9/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 45,
      "deletions": 10
    },
    "files": [
      {
        "sha": "e149cb4d7f558dff0fe1f91c20bcc11b5669fcfe",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40c38f895838651aba327c63db277f2924d4d3d9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40c38f895838651aba327c63db277f2924d4d3d9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=40c38f895838651aba327c63db277f2924d4d3d9",
        "patch": "@@ -206,6 +206,8 @@ namespace {\n \n     /** Dirty block file entries. */\n     set<int> setDirtyFileInfo;\n+    /** Last timestamp we tried to use mempool reserve space to evict. */\n+    int64_t lastSurplusTrimTime = 0;\n } // anon namespace\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -992,6 +994,25 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n+\n+        // Try to use excess relay fees paid by txs above the soft cap to trim in aggregate\n+        int64_t timeNow = GetTime();\n+        size_t curUsage = pool.DynamicMemoryUsage();\n+        size_t trimGoal = 1000000; //Try to trim up to 1MB worth of transactions at a time\n+        if (curUsage > softcap + trimGoal && timeNow > lastSurplusTrimTime) {\n+            // Require at least 1M at highest fee rate we'll try to trim at, and try to trim 1MB\n+            lastSurplusTrimTime = timeNow;\n+            int rateZone = (curUsage - softcap - trimGoal)/capstep + 1;\n+            int rateMultForTrim = 1 << rateZone;\n+            std::set<uint256> stageTrimDelete;\n+            if (pool.SurplusTrim(rateMultForTrim-1, minRelayTxFee, trimGoal, stageTrimDelete)) {\n+                size_t oldUsage = curUsage;\n+                size_t txsToDelete = stageTrimDelete.size();\n+                pool.RemoveStaged(stageTrimDelete);\n+                curUsage = pool.DynamicMemoryUsage();\n+                LogPrint(\"mempool\", \"Removing %u transactions (%ld total usage) using periodic trim from reserve size\\n\", txsToDelete, oldUsage - curUsage);\n+            }\n+        }\n     }\n \n     SyncWithWallets(tx, NULL);"
      },
      {
        "sha": "6dd54f80b50c7b8bf6441099b236867e4cf23e47",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 9,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40c38f895838651aba327c63db277f2924d4d3d9/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40c38f895838651aba327c63db277f2924d4d3d9/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=40c38f895838651aba327c63db277f2924d4d3d9",
        "patch": "@@ -455,15 +455,23 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n \n     size_t incUsage = GuessDynamicMemoryUsage(toadd);\n     size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n-    if (expsize > sizelimit) {\n-        size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n-        return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), stage, nFeesRemoved);\n-    } else\n+    if (expsize <= sizelimit) {\n         return true;\n+    }\n+    size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n+    return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), true, stage, nFeesRemoved);\n+}\n+\n+bool CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, size_t usageToTrim, std::set<uint256>& stage) {\n+    CFeeRate excessRate(multiplier * minRelayRate.GetFeePerK());\n+    std::set<uint256> noprotect;\n+    CAmount nFeesRemoved = 0;\n+    size_t sizeToTrim = usageToTrim / 4;  //Conservatively assume we have transactions at least 1/4 the size of the mempool space they've taken\n+    return TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), false, stage, nFeesRemoved);\n }\n \n bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n-                             std::set<uint256>& stage, CAmount &nFeesRemoved) {\n+                             bool mustTrimAllSize, std::set<uint256>& stage, CAmount &nFeesRemoved) {\n     size_t usageRemoved = 0;\n     indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n     int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n@@ -483,7 +491,7 @@ bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmo\n         if ((double)it->GetFee() * sizeToUse > (double)feeToUse * it->GetTxSize()) {\n             // If the transaction's feerate is worse than what we're looking for, nothing else we will iterate over\n             // could improve the staged set. If we don't have an acceptable solution by now, bail out.\n-            return false;\n+            break;\n         }\n         std::deque<uint256> todo; // List of hashes that we still need to process (descendants of 'hash').\n         std::set<uint256> now; // Set of hashes that will need to be added to stage if 'hash' is included.\n@@ -503,7 +511,8 @@ bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmo\n             }\n             iternow++; // We only count transactions we actually had to go find in the mempool.\n             if (iternow + fails > 20) {\n-                return false;\n+                good = false;\n+                break;\n             }\n             const CTxMemPoolEntry* origTx = &*mapTx.find(hashnow);\n             nowfee += origTx->GetFee();\n@@ -539,13 +548,17 @@ bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmo\n             fails += iternow;\n             if (fails > 10) {\n                 // Bail out after traversing 32 transactions that are not acceptable.\n-                return false;\n+                break;\n             }\n         }\n         it++;\n     }\n+    //We've added all we can.  Is it enough?\n+    if (mustTrimAllSize && usageRemoved < sizeToTrim)\n+        return false;\n+    if (stage.empty() && sizeToTrim > 0)\n+        return false;\n     return true;\n-\n }\n \n void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {"
      },
      {
        "sha": "ca18c41c0a7ae4f820486bf04249e35d0360ec5a",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40c38f895838651aba327c63db277f2924d4d3d9/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40c38f895838651aba327c63db277f2924d4d3d9/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=40c38f895838651aba327c63db277f2924d4d3d9",
        "patch": "@@ -203,8 +203,9 @@ class CTxMemPool\n      *  - Removing said list will reduce the DynamicMemoryUsage after adding toadd, below sizelimit.\n      */\n     bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, CAmount nFeesReserved, std::set<uint256>& stage, CAmount& nFeesRemoved);\n+    bool SurplusTrim(int mutliplier, CFeeRate minRelayRate, size_t usageToTrim, std::set<uint256> &stage);\n     bool TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n-\t\t     std::set<uint256>& stage, CAmount &nfeesRemoved);\n+\t\t     bool mustTrimAllSize, std::set<uint256>& stage, CAmount &nfeesRemoved);\n     void RemoveStaged(std::set<uint256>& stage);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */"
      }
    ]
  },
  {
    "sha": "6e8d3dd36cc82921f312458e17168788016ceee2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZThkM2RkMzZjYzgyOTIxZjMxMjQ1OGUxNzE2ODc4ODAxNmNlZWUy",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-07-23T20:37:16Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-14T18:56:14Z"
      },
      "message": "Various improvements.\n\nImprove logging\nUse insecure_rand in TrimMempool\nTweak logic of TrimMempool\nAdd occasional larger SurplusTrim.\nBypass eviction on disconnected block txs\nAdditional SurplusTrim for bypassed size\nAcquire locks appropriately",
      "tree": {
        "sha": "9a07d16698cb669ebe1af1b21b9129e11a815c3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a07d16698cb669ebe1af1b21b9129e11a815c3d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e8d3dd36cc82921f312458e17168788016ceee2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e8d3dd36cc82921f312458e17168788016ceee2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6e8d3dd36cc82921f312458e17168788016ceee2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e8d3dd36cc82921f312458e17168788016ceee2/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "40c38f895838651aba327c63db277f2924d4d3d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40c38f895838651aba327c63db277f2924d4d3d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/40c38f895838651aba327c63db277f2924d4d3d9"
      }
    ],
    "stats": {
      "total": 148,
      "additions": 98,
      "deletions": 50
    },
    "files": [
      {
        "sha": "f1cc5e313240b957600a4592a7418fcff2a872c0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 25,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e8d3dd36cc82921f312458e17168788016ceee2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e8d3dd36cc82921f312458e17168788016ceee2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6e8d3dd36cc82921f312458e17168788016ceee2",
        "patch": "@@ -781,7 +781,7 @@ static std::string FormatStateMessage(const CValidationState &state)\n }\n \n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, bool fRejectAbsurdFee)\n+                        bool* pfMissingInputs, bool fRejectAbsurdFee, bool safeToEvict)\n {\n     AssertLockHeld(cs_main);\n     if (pfMissingInputs)\n@@ -906,34 +906,56 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n         }\n \n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+\n+        {\n+        LOCK(pool.cs); // Keep holding this lock from when we populate stagedelete, until they are deleted.\n+        size_t curUsage = pool.DynamicMemoryUsage();\n+\n+        // During a reorg, it doesn't make sense to be evicting anything from the mempool to make\n+        // room for txs readded from disconnected blocks.  If however after the reorg, there is significant\n+        // growth in mempool size it could temporarily impede new txs, so it makes sense to try to trim away\n+        // any growth.  We're not worried about free relay in this case, so there is no exact restriction on\n+        // what fee rate we can use for eviction, so just use the highest logical choice which is the fee rate\n+        // of the current ratezone.\n+        if (safeToEvict && pool.bypassedSize) {\n+            if (curUsage > softcap) {\n+                size_t trimGoal = std::min(pool.bypassedSize, curUsage - softcap);\n+                int rateZone = (curUsage - softcap)/capstep + 1;\n+                int rateMultForTrim = 1 << rateZone;\n+                pool.SurplusTrim(rateMultForTrim, ::minRelayTxFee, trimGoal);\n+            }\n+            pool.bypassedSize = 0;\n+        }\n         // If the predicted mempool usage is under the softcap, StageTrimToSize will return success.\n         // Otherwise StageTrimToSize will attempt to find appropriate transactions of lesser\n         // feerate to evict from the mempool.  If this fails and the mempool usage would be under\n         // the hardcap there is an opportunity for this transaction to enter the mempool anyway if\n         // it has a fee high enough to pass an increased minimum relay feerate.  The are 10 bands\n         // of doubling the effective minimum feerate between the softcap and hardcap.\n-        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n-        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n-        size_t capstep = (hardcap - softcap) / 10;\n         std::set<uint256> stagedelete;\n         CAmount nFeesDeleted = 0;\n-        if (!pool.StageTrimToSize(softcap, entry, nFeesRequired, stagedelete, nFeesDeleted)) {\n-            size_t expsize = pool.DynamicMemoryUsage() + pool.GuessDynamicMemoryUsage(entry);\n+        if (safeToEvict && !pool.StageTrimToSize(softcap, entry, nFeesRequired, stagedelete, nFeesDeleted)) {\n+            size_t expsize = curUsage + pool.GuessDynamicMemoryUsage(entry);\n             if (expsize > hardcap) {\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\");\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\", false,\n+                                 strprintf(\"%u > %u\", expsize, hardcap));\n             } else {\n                 assert(expsize > softcap);\n                 int rateZone = (expsize - softcap)/capstep + 1;\n                 int relayMult = 1 << rateZone;\n                 if (nFees < relayMult * ::minRelayTxFee.GetFee(nSize)) {\n-                    return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\");\n+                    return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\", false,\n+                                     strprintf(\"Mult: %d - %d < %d\", relayMult, nFees, relayMult * ::minRelayTxFee.GetFee(nSize)));\n                 } else {\n                     // The fee rate of this transaction is high enough to enter into the reserve space\n                     // If stagedelete is non-empty at this point, it has only been populated with sets of transactions\n                     // that each have lower fee-rate than this transaction.  As such, it is safe to also still delete\n                     // the partial eviction set, as the effective fee rate for any remaining part of the transaction\n                     // would only have been higher than the original fee rate, and still passed the test for reserve space.\n-                    LogPrint(\"mempool\", \"Tx %s entering reserve space size/fee %ld %ld at usage of %5.2f and mult of %d\\n\",tx.GetHash().ToString().substr(0,10).c_str(),nSize,nFees, expsize, relayMult);\n+                    LogPrint(\"mempool\", \"Tx %s eligible for reserve space size/fee %ld %ld at usage of %5.2f and mult of %d\\n\",tx.GetHash().ToString().substr(0,10).c_str(),nSize,nFees, expsize, relayMult);\n                 }\n             }\n         }\n@@ -991,26 +1013,26 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             LogPrint(\"mempool\", \"Removing %u transactions (%d fees) from the mempool to make space for %s\\n\", stagedelete.size(), nFeesDeleted, tx.GetHash().ToString());\n             pool.RemoveStaged(stagedelete);\n         }\n-\n+        }\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n \n         // Try to use excess relay fees paid by txs above the soft cap to trim in aggregate\n         int64_t timeNow = GetTime();\n-        size_t curUsage = pool.DynamicMemoryUsage();\n-        size_t trimGoal = 1000000; //Try to trim up to 1MB worth of transactions at a time\n-        if (curUsage > softcap + trimGoal && timeNow > lastSurplusTrimTime) {\n-            // Require at least 1M at highest fee rate we'll try to trim at, and try to trim 1MB\n-            lastSurplusTrimTime = timeNow;\n-            int rateZone = (curUsage - softcap - trimGoal)/capstep + 1;\n-            int rateMultForTrim = 1 << rateZone;\n-            std::set<uint256> stageTrimDelete;\n-            if (pool.SurplusTrim(rateMultForTrim-1, minRelayTxFee, trimGoal, stageTrimDelete)) {\n-                size_t oldUsage = curUsage;\n-                size_t txsToDelete = stageTrimDelete.size();\n-                pool.RemoveStaged(stageTrimDelete);\n-                curUsage = pool.DynamicMemoryUsage();\n-                LogPrint(\"mempool\", \"Removing %u transactions (%ld total usage) using periodic trim from reserve size\\n\", txsToDelete, oldUsage - curUsage);\n+        {\n+            LOCK(pool.cs);\n+            size_t curUsage = pool.DynamicMemoryUsage();\n+            size_t trimGoal = 1000000; //Try to trim up to 1MB worth of transactions at a time\n+            if (timeNow % 10 == 0) {\n+                // Try to trim larger chunk of transactions on occasion.  It doesn't really matter\n+                // if it turns out 1MB is greater than capstep (maxmempool < 33MB).\n+                trimGoal = capstep;\n+            }\n+            if (safeToEvict && curUsage > softcap + trimGoal && timeNow > lastSurplusTrimTime) {\n+                lastSurplusTrimTime = timeNow;\n+                int rateZone = (curUsage - softcap - trimGoal)/capstep + 1;\n+                int rateMultForTrim = 1 << rateZone;\n+                pool.SurplusTrim(rateMultForTrim - 1, ::minRelayTxFee, trimGoal);\n             }\n         }\n     }\n@@ -2107,7 +2129,7 @@ bool static DisconnectTip(CValidationState &state) {\n         // ignore validation errors in resurrected transactions\n         list<CTransaction> removed;\n         CValidationState stateDummy;\n-        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))\n+        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL, false, false))\n             mempool.remove(tx, removed, true);\n     }\n     mempool.removeCoinbaseSpends(pcoinsTip, pindexDelete->nHeight);\n@@ -2349,8 +2371,14 @@ bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n             if (pindexMostWork == NULL || pindexMostWork == chainActive.Tip())\n                 return true;\n \n+            size_t oldUsage = mempool.DynamicMemoryUsage();\n             if (!ActivateBestChainStep(state, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : NULL))\n                 return false;\n+            size_t newUsage = mempool.DynamicMemoryUsage();\n+            if (newUsage > oldUsage) {\n+                LOCK(mempool.cs);\n+                mempool.bypassedSize += (newUsage - oldUsage);\n+            }\n \n             pindexNewTip = chainActive.Tip();\n             fInitialDownload = IsInitialBlockDownload();"
      },
      {
        "sha": "8b529cef9555c03222c543044235a7d9266ac190",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e8d3dd36cc82921f312458e17168788016ceee2/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e8d3dd36cc82921f312458e17168788016ceee2/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=6e8d3dd36cc82921f312458e17168788016ceee2",
        "patch": "@@ -221,7 +221,7 @@ void PruneAndFlush();\n \n /** (try to) add transaction to memory pool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, bool fRejectAbsurdFee=false);\n+                        bool* pfMissingInputs, bool fRejectAbsurdFee=false, bool safeToEvict=true);\n \n \n struct CNodeStateStats {"
      },
      {
        "sha": "ef56c3cd1c0a30db0aa71c1c85988c3cdee554eb",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 15,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e8d3dd36cc82921f312458e17168788016ceee2/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e8d3dd36cc82921f312458e17168788016ceee2/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=6e8d3dd36cc82921f312458e17168788016ceee2",
        "patch": "@@ -239,6 +239,7 @@ void CTxMemPool::clear()\n     mapNextTx.clear();\n     totalTxSize = 0;\n     cachedInnerUsage = 0;\n+    bypassedSize = 0;\n     ++nTransactionsUpdated;\n }\n \n@@ -412,6 +413,7 @@ void CTxMemPool::ClearPrioritisation(const uint256 hash)\n \n bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n {\n+    LOCK(cs);\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n         if (exists(tx.vin[i].prevout.hash))\n             return false;\n@@ -459,32 +461,43 @@ bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd,\n         return true;\n     }\n     size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n-    return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), true, stage, nFeesRemoved);\n+    return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), true, 10, stage, nFeesRemoved);\n }\n \n-bool CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, size_t usageToTrim, std::set<uint256>& stage) {\n+void CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, size_t usageToTrim) {\n     CFeeRate excessRate(multiplier * minRelayRate.GetFeePerK());\n     std::set<uint256> noprotect;\n     CAmount nFeesRemoved = 0;\n+    std::set<uint256> stageTrimDelete;\n     size_t sizeToTrim = usageToTrim / 4;  //Conservatively assume we have transactions at least 1/4 the size of the mempool space they've taken\n-    return TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), false, stage, nFeesRemoved);\n+    if (TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), false, 100, stageTrimDelete, nFeesRemoved)) {\n+        size_t oldUsage = DynamicMemoryUsage();\n+        size_t txsToDelete = stageTrimDelete.size();\n+        RemoveStaged(stageTrimDelete);\n+        size_t curUsage = DynamicMemoryUsage();\n+        LogPrint(\"mempool\", \"Removing %u transactions (%ld total usage) using periodic trim from reserve size\\n\", txsToDelete, oldUsage - curUsage);\n+    }\n }\n \n bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n-                             bool mustTrimAllSize, std::set<uint256>& stage, CAmount &nFeesRemoved) {\n+                             bool mustTrimAllSize, int iterextra, std::set<uint256>& stage, CAmount &nFeesRemoved) {\n     size_t usageRemoved = 0;\n     indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n     int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n+    int iterperfail = 10;\n+    int itertotal = 0;\n+    int failmax = 10; //Try no more than 10 starting transactions\n+    seed_insecure_rand();\n     // Iterate from lowest feerate to highest feerate in the mempool:\n     while (usageRemoved < sizeToTrim && it != mapTx.get<1>().rend()) {\n-        const uint256& hash = it->GetTx().GetHash();\n-        if (stage.count(hash)) {\n-            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n+        if (insecure_rand()%10) {\n+            // Only try 1/10 of the transactions so we don't get stuck on the same long chains\n             it++;\n             continue;\n         }\n-        if (GetRand(10)) {\n-            // Only try 1/10 of the transactions, in order to have some chance to avoid very big chains.\n+        const uint256& hash = it->GetTx().GetHash();\n+        if (stage.count(hash)) {\n+            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n             it++;\n             continue;\n         }\n@@ -498,7 +511,6 @@ bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmo\n         CAmount nowfee = 0; // Sum of the fees in 'now'.\n         size_t nowsize = 0; // Sum of the tx sizes in 'now'.\n         size_t nowusage = 0; // Sum of the memory usages of transactions in 'now'.\n-        int iternow = 0; // Transactions we've inspected so far while determining whether 'hash' is acceptable.\n         todo.push_back(it->GetTx().GetHash()); // Add 'hash' to the todo list, to initiate processing its children.\n         bool good = true; // Whether including 'hash' (and all its descendants) is a good idea.\n         // Iterate breadth-first over all descendants of transaction with hash 'hash'.\n@@ -509,8 +521,8 @@ bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmo\n                 good = false;\n                 break;\n             }\n-            iternow++; // We only count transactions we actually had to go find in the mempool.\n-            if (iternow + fails > 20) {\n+            itertotal++; // We only count transactions we actually had to go find in the mempool.\n+            if (itertotal > iterextra + iterperfail*(fails+1)) {\n                 good = false;\n                 break;\n             }\n@@ -545,9 +557,9 @@ bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmo\n             nFeesRemoved += nowfee;\n             usageRemoved += nowusage;\n         } else {\n-            fails += iternow;\n-            if (fails > 10) {\n-                // Bail out after traversing 32 transactions that are not acceptable.\n+            fails++;\n+            if (fails > failmax) {\n+                // Bail out after traversing failmax transactions that are not acceptable.\n                 break;\n             }\n         }\n@@ -568,6 +580,7 @@ void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {\n }\n \n int CTxMemPool::Expire(int64_t time) {\n+    LOCK(cs);\n     indexed_transaction_set::nth_index<2>::type::iterator it = mapTx.get<2>().begin();\n     std::set<uint256> toremove;\n     int ret = 0;"
      },
      {
        "sha": "27935a596d2c470f0c225f132c5d390cb3d8a0e3",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e8d3dd36cc82921f312458e17168788016ceee2/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e8d3dd36cc82921f312458e17168788016ceee2/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=6e8d3dd36cc82921f312458e17168788016ceee2",
        "patch": "@@ -159,6 +159,7 @@ class CTxMemPool\n     indexed_transaction_set mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n+    size_t bypassedSize;\n \n     CTxMemPool(const CFeeRate& _minRelayFee);\n     ~CTxMemPool();\n@@ -195,17 +196,23 @@ class CTxMemPool\n     void ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta);\n     void ClearPrioritisation(const uint256 hash);\n \n-    /** Build a list of transaction (hashes) to remove such that:\n-     *  - The list is consistent (if a parent is included, all its dependencies are included as well).\n-     *  - No dependencies of toadd are removed.\n-     *  - The total fees removed are not more than the fees added by toadd.\n-     *  - The feerate of what is removed is not better than the feerate of toadd.\n-     *  - Removing said list will reduce the DynamicMemoryUsage after adding toadd, below sizelimit.\n-     */\n+    // StageTrimToSize will call TrimMempool for any mempool usage over the size limit up to the size of toadd.\n     bool StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, CAmount nFeesReserved, std::set<uint256>& stage, CAmount& nFeesRemoved);\n-    bool SurplusTrim(int mutliplier, CFeeRate minRelayRate, size_t usageToTrim, std::set<uint256> &stage);\n+    // SurplusTrim will call TrimMempool for usageToTrim with synthetic fees and size based on multiplier*minRelayRate.\n+    void SurplusTrim(int mutliplier, CFeeRate minRelayRate, size_t usageToTrim);\n+private:\n+    /** TrimMempool will build a list of transactions (hashes) to remove until it reaches sizeToTrim:\n+     *  - No txs in protect are removed.\n+     *  - The total fees removed are not more than the feeToUse (minus any nFeesReserved).\n+     *  - The feerate of what is removed is not better than the feerate of feeToUse/sizeToUse.\n+     *  - if mustTrimAllSize return false unless sizeToTrim is met\n+     *  - iterextra helps provide a bound on how many txs will be iterated over.\n+     *  - The list returned in stage is consistent (if a parent is included, all its descendants are included as well).\n+     *  - Total fees removed are returned in nfeesRemoved\n+     */\n     bool TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n-\t\t     bool mustTrimAllSize, std::set<uint256>& stage, CAmount &nfeesRemoved);\n+\t\t     bool mustTrimAllSize, int iterextra, std::set<uint256>& stage, CAmount &nfeesRemoved);\n+public:\n     void RemoveStaged(std::set<uint256>& stage);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */"
      }
    ]
  }
]