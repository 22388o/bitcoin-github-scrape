[
  {
    "sha": "695041e4952ea40e02e3b0431d04ca6af7ec9711",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OTUwNDFlNDk1MmVhNDBlMDJlM2IwNDMxZDA0Y2E2YWY3ZWM5NzEx",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-06-27T15:06:47Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-06-27T16:17:27Z"
      },
      "message": "util: Update tinyformat\n\nUpdates `tinyformat.h` to commit\nhttps://github.com/c42f/tinyformat/commit/3a33bbf65442432277eee079e83d3e8fac51730c upstream.\n\nMakes sure that our local changes are kept:\n\n- #3767 1b8fd35aadfad6a1e55391f02add6076c8c9ea8f Make tinyformat errors raise an exception instead of assert()ing\n- #4735 9b6d4c5cdc1ad7b12b8b7ba05125dad9ba2d396e Move strprintf define to tinyformat.h\n- #4748 6e5fd003e04b81115b6b164b21f048472d575535 include stdexcept (for std::exception)\n- #8000 9eaa0afa6ec5d3dd01e4d01121314ef51f2bc305 force USE_VARIADIC_TEMPLATES\n- Add `std::string format(const std::string &fmt...` added this\n  at the time, as we want to be able to do `strprintf(_(...), ...)`\n\nInspired by #8264.",
      "tree": {
        "sha": "ad3f767c21e723e14407fe5f54d1144c04689100",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad3f767c21e723e14407fe5f54d1144c04689100"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/695041e4952ea40e02e3b0431d04ca6af7ec9711",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/695041e4952ea40e02e3b0431d04ca6af7ec9711",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/695041e4952ea40e02e3b0431d04ca6af7ec9711",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/695041e4952ea40e02e3b0431d04ca6af7ec9711/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5a06ebbf2d5f6ff57966c9ea9956cc1b666b3028",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a06ebbf2d5f6ff57966c9ea9956cc1b666b3028",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5a06ebbf2d5f6ff57966c9ea9956cc1b666b3028"
      }
    ],
    "stats": {
      "total": 700,
      "additions": 368,
      "deletions": 332
    },
    "files": [
      {
        "sha": "17f0360c42f24f5dfcfd7c5d69a53b4bddb10454",
        "filename": "src/tinyformat.h",
        "status": "modified",
        "additions": 368,
        "deletions": 332,
        "changes": 700,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/695041e4952ea40e02e3b0431d04ca6af7ec9711/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/695041e4952ea40e02e3b0431d04ca6af7ec9711/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=695041e4952ea40e02e3b0431d04ca6af7ec9711",
        "patch": "@@ -67,7 +67,9 @@\n //                                  weekday, month, day, hour, min);\n //   std::cout << date;\n //\n-// These are the three primary interface functions.\n+// These are the three primary interface functions.  There is also a\n+// convenience function printfln() which appends a newline to the usual result\n+// of printf() for super simple logging.\n //\n //\n // User defined format functions\n@@ -86,6 +88,18 @@\n // defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an\n // example, see the implementation of printf() at the end of the source file.\n //\n+// Sometimes it's useful to be able to pass a list of format arguments through\n+// to a non-template function.  The FormatList class is provided as a way to do\n+// this by storing the argument list in a type-opaque way.  Continuing the\n+// example from above, we construct a FormatList using makeFormatList():\n+//\n+//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);\n+//\n+// The format list can now be passed into any non-template function and used\n+// via a call to the vformat() function:\n+//\n+//   tfm::vformat(std::cout, \"%s, %s %d, %.2d:%.2d\\n\", formatList);\n+//\n //\n // Additional API information\n // --------------------------\n@@ -118,6 +132,7 @@ namespace tfm = tinyformat;\n \n //------------------------------------------------------------------------------\n // Implementation details.\n+#include <algorithm>\n #include <cassert>\n #include <iostream>\n #include <sstream>\n@@ -133,20 +148,20 @@ namespace tfm = tinyformat;\n #   endif\n #endif\n \n-#ifdef __GNUC__\n-#   define TINYFORMAT_NOINLINE __attribute__((noinline))\n-#elif defined(_MSC_VER)\n-#   define TINYFORMAT_NOINLINE __declspec(noinline)\n-#else\n-#   define TINYFORMAT_NOINLINE\n-#endif\n-\n #if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n //  std::showpos is broken on old libstdc++ as provided with OSX.  See\n //  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n #   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n #endif\n \n+#ifdef __APPLE__\n+// Workaround OSX linker warning: xcode uses different default symbol\n+// visibilities for static libs vs executables (see issue #25)\n+#   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n+#else\n+#   define TINYFORMAT_HIDDEN\n+#endif\n+\n namespace tinyformat {\n \n //------------------------------------------------------------------------------\n@@ -247,6 +262,29 @@ struct convertToInt<T,true>\n     static int invoke(const T& value) { return static_cast<int>(value); }\n };\n \n+// Format at most ntrunc characters to the given stream.\n+template<typename T>\n+inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)\n+{\n+    std::ostringstream tmp;\n+    tmp << value;\n+    std::string result = tmp.str();\n+    out.write(result.c_str(), (std::min)(ntrunc, static_cast<int>(result.size())));\n+}\n+#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \\\n+inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \\\n+{                                                           \\\n+    std::streamsize len = 0;                                \\\n+    while(len < ntrunc && value[len] != 0)                  \\\n+        ++len;                                              \\\n+    out.write(value, len);                                  \\\n+}\n+// Overload for const char* and char*.  Could overload for signed & unsigned\n+// char too, but these are technically unneeded for printf compatibility.\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)\n+#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR\n+\n } // namespace detail\n \n \n@@ -255,18 +293,20 @@ struct convertToInt<T,true>\n // desired.\n \n \n-// Format a value into a stream. Called from format() for all types by default.\n-//\n-// Users may override this for their own types.  When this function is called,\n-// the stream flags will have been modified according to the format string.\n-// The format specification is provided in the range [fmtBegin, fmtEnd).\n-//\n-// By default, formatValue() uses the usual stream insertion operator\n-// operator<< to format the type T, with special cases for the %c and %p\n-// conversions.\n+/// Format a value into a stream, delegating to operator<< by default.\n+///\n+/// Users may override this for their own types.  When this function is called,\n+/// the stream flags will have been modified according to the format string.\n+/// The format specification is provided in the range [fmtBegin, fmtEnd).  For\n+/// truncating conversions, ntrunc is set to the desired maximum number of\n+/// characters, for example \"%.7s\" calls formatValue with ntrunc = 7.\n+///\n+/// By default, formatValue() uses the usual stream insertion operator\n+/// operator<< to format the type T, with special cases for the %c and %p\n+/// conversions.\n template<typename T>\n inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n-                        const char* fmtEnd, const T& value)\n+                        const char* fmtEnd, int ntrunc, const T& value)\n {\n #ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS\n     // Since we don't support printing of wchar_t using \"%ls\", make it fail at\n@@ -288,6 +328,12 @@ inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n     else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n #endif\n+    else if(ntrunc >= 0)\n+    {\n+        // Take care not to overread C strings in truncating conversions like\n+        // \"%.4s\" where at most 4 characters may be read.\n+        detail::formatTruncated(out, value, ntrunc);\n+    }\n     else\n         out << value;\n }\n@@ -296,7 +342,7 @@ inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n // Overloaded version for char types to support printing as an integer\n #define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \\\n inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n-                        const char* fmtEnd, charType value)           \\\n+                        const char* fmtEnd, int /**/, charType value) \\\n {                                                                     \\\n     switch(*(fmtEnd-1))                                               \\\n     {                                                                 \\\n@@ -435,225 +481,91 @@ cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\\\\n    ' +\n \n namespace detail {\n \n-// Class holding current position in format string and an output stream into\n-// which arguments are formatted.\n-class FormatIterator\n+// Type-opaque holder for an argument to format(), with associated actions on\n+// the type held as explicit function pointers.  This allows FormatArg's for\n+// each argument to be allocated as a homogenous array inside FormatList\n+// whereas a naive implementation based on inheritance does not.\n+class FormatArg\n {\n     public:\n-        // Flags for features not representable with standard stream state\n-        enum ExtraFormatFlags\n-        {\n-            Flag_None                = 0,\n-            Flag_TruncateToPrecision = 1<<0, // truncate length to stream precision()\n-            Flag_SpacePadPositive    = 1<<1, // pad positive values with spaces\n-            Flag_VariableWidth       = 1<<2, // variable field width in arg list\n-            Flag_VariablePrecision   = 1<<3  // variable field precision in arg list\n-        };\n-\n-        // out is the output stream, fmt is the full format string\n-        FormatIterator(std::ostream& out, const char* fmt)\n-            : m_out(out),\n-            m_fmt(fmt),\n-            m_extraFlags(Flag_None),\n-            m_wantWidth(false),\n-            m_wantPrecision(false),\n-            m_variableWidth(0),\n-            m_variablePrecision(0),\n-            m_origWidth(out.width()),\n-            m_origPrecision(out.precision()),\n-            m_origFlags(out.flags()),\n-            m_origFill(out.fill())\n+        FormatArg() {}\n+\n+        template<typename T>\n+        FormatArg(const T& value)\n+            : m_value(static_cast<const void*>(&value)),\n+            m_formatImpl(&formatImpl<T>),\n+            m_toIntImpl(&toIntImpl<T>)\n         { }\n \n-        // Print remaining part of format string.\n-        void finish()\n+        void format(std::ostream& out, const char* fmtBegin,\n+                    const char* fmtEnd, int ntrunc) const\n         {\n-            // It would be nice if we could do this from the destructor, but we\n-            // can't if TINFORMAT_ERROR is used to throw an exception!\n-            m_fmt = printFormatStringLiteral(m_out, m_fmt);\n-            if(*m_fmt != '\\0')\n-                TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);\n         }\n \n-        ~FormatIterator()\n+        int toInt() const\n         {\n-            // Restore stream state\n-            m_out.width(m_origWidth);\n-            m_out.precision(m_origPrecision);\n-            m_out.flags(m_origFlags);\n-            m_out.fill(m_origFill);\n+            return m_toIntImpl(m_value);\n         }\n \n-        template<typename T>\n-        void accept(const T& value);\n-\n     private:\n-        // Parse and return an integer from the string c, as atoi()\n-        // On return, c is set to one past the end of the integer.\n-        static int parseIntAndAdvance(const char*& c)\n+        template<typename T>\n+        TINYFORMAT_HIDDEN static void formatImpl(std::ostream& out, const char* fmtBegin,\n+                        const char* fmtEnd, int ntrunc, const void* value)\n         {\n-            int i = 0;\n-            for(;*c >= '0' && *c <= '9'; ++c)\n-                i = 10*i + (*c - '0');\n-            return i;\n+            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));\n         }\n \n-        // Format at most truncLen characters of a C string to the given\n-        // stream.  Return true if formatting proceeded (generic version always\n-        // returns false)\n         template<typename T>\n-        static bool formatCStringTruncate(std::ostream& /*out*/, const T& /*value*/,\n-                                        std::streamsize /*truncLen*/)\n+        TINYFORMAT_HIDDEN static int toIntImpl(const void* value)\n         {\n-            return false;\n-        }\n-#       define TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(type)            \\\n-        static bool formatCStringTruncate(std::ostream& out, type* value,  \\\n-                                        std::streamsize truncLen)          \\\n-        {                                                                  \\\n-            std::streamsize len = 0;                                       \\\n-            while(len < truncLen && value[len] != 0)                       \\\n-                ++len;                                                     \\\n-            out.write(value, len);                                         \\\n-            return true;                                                   \\\n-        }\n-        // Overload for const char* and char*.  Could overload for signed &\n-        // unsigned char too, but these are technically unneeded for printf\n-        // compatibility.\n-        TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(const char)\n-        TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(char)\n-#       undef TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE\n-\n-        // Print literal part of format string and return next format spec\n-        // position.\n-        //\n-        // Skips over any occurrences of '%%', printing a literal '%' to the\n-        // output.  The position of the first % character of the next\n-        // nontrivial format spec is returned, or the end of string.\n-        static const char* printFormatStringLiteral(std::ostream& out,\n-                                                    const char* fmt)\n-        {\n-            const char* c = fmt;\n-            for(; true; ++c)\n-            {\n-                switch(*c)\n-                {\n-                    case '\\0':\n-                        out.write(fmt, static_cast<std::streamsize>(c - fmt));\n-                        return c;\n-                    case '%':\n-                        out.write(fmt, static_cast<std::streamsize>(c - fmt));\n-                        if(*(c+1) != '%')\n-                            return c;\n-                        // for \"%%\", tack trailing % onto next literal section.\n-                        fmt = ++c;\n-                        break;\n-                }\n-            }\n+            return convertToInt<T>::invoke(*static_cast<const T*>(value));\n         }\n \n-        static const char* streamStateFromFormat(std::ostream& out,\n-                                                 unsigned int& extraFlags,\n-                                                 const char* fmtStart,\n-                                                 int variableWidth,\n-                                                 int variablePrecision);\n-\n-        // Private copy & assign: Kill gcc warnings with -Weffc++\n-        FormatIterator(const FormatIterator&);\n-        FormatIterator& operator=(const FormatIterator&);\n-\n-        // Stream, current format string & state\n-        std::ostream& m_out;\n-        const char* m_fmt;\n-        unsigned int m_extraFlags;\n-        // State machine info for handling of variable width & precision\n-        bool m_wantWidth;\n-        bool m_wantPrecision;\n-        int m_variableWidth;\n-        int m_variablePrecision;\n-        // Saved stream state\n-        std::streamsize m_origWidth;\n-        std::streamsize m_origPrecision;\n-        std::ios::fmtflags m_origFlags;\n-        char m_origFill;\n+        const void* m_value;\n+        void (*m_formatImpl)(std::ostream& out, const char* fmtBegin,\n+                             const char* fmtEnd, int ntrunc, const void* value);\n+        int (*m_toIntImpl)(const void* value);\n };\n \n \n-// Accept a value for formatting into the internal stream.\n-template<typename T>\n-TINYFORMAT_NOINLINE  // < greatly reduces bloat in optimized builds\n-void FormatIterator::accept(const T& value)\n+// Parse and return an integer from the string c, as atoi()\n+// On return, c is set to one past the end of the integer.\n+inline int parseIntAndAdvance(const char*& c)\n {\n-    // Parse the format string\n-    const char* fmtEnd = 0;\n-    if(m_extraFlags == Flag_None && !m_wantWidth && !m_wantPrecision)\n-    {\n-        m_fmt = printFormatStringLiteral(m_out, m_fmt);\n-        fmtEnd = streamStateFromFormat(m_out, m_extraFlags, m_fmt, 0, 0);\n-        m_wantWidth     = (m_extraFlags & Flag_VariableWidth) != 0;\n-        m_wantPrecision = (m_extraFlags & Flag_VariablePrecision) != 0;\n-    }\n-    // Consume value as variable width and precision specifier if necessary\n-    if(m_extraFlags & (Flag_VariableWidth | Flag_VariablePrecision))\n-    {\n-        if(m_wantWidth || m_wantPrecision)\n-        {\n-            int v = convertToInt<T>::invoke(value);\n-            if(m_wantWidth)\n-            {\n-                m_variableWidth = v;\n-                m_wantWidth = false;\n-            }\n-            else if(m_wantPrecision)\n-            {\n-                m_variablePrecision = v;\n-                m_wantPrecision = false;\n-            }\n-            return;\n-        }\n-        // If we get here, we've set both the variable precision and width as\n-        // required and we need to rerun the stream state setup to insert these.\n-        fmtEnd = streamStateFromFormat(m_out, m_extraFlags, m_fmt,\n-                                       m_variableWidth, m_variablePrecision);\n-    }\n+    int i = 0;\n+    for(;*c >= '0' && *c <= '9'; ++c)\n+        i = 10*i + (*c - '0');\n+    return i;\n+}\n \n-    // Format the value into the stream.\n-    if(!(m_extraFlags & (Flag_SpacePadPositive | Flag_TruncateToPrecision)))\n-        formatValue(m_out, m_fmt, fmtEnd, value);\n-    else\n+// Print literal part of format string and return next format spec\n+// position.\n+//\n+// Skips over any occurrences of '%%', printing a literal '%' to the\n+// output.  The position of the first % character of the next\n+// nontrivial format spec is returned, or the end of string.\n+inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n+{\n+    const char* c = fmt;\n+    for(;; ++c)\n     {\n-        // The following are special cases where there's no direct\n-        // correspondence between stream formatting and the printf() behaviour.\n-        // Instead, we simulate the behaviour crudely by formatting into a\n-        // temporary string stream and munging the resulting string.\n-        std::ostringstream tmpStream;\n-        tmpStream.copyfmt(m_out);\n-        if(m_extraFlags & Flag_SpacePadPositive)\n-            tmpStream.setf(std::ios::showpos);\n-        // formatCStringTruncate is required for truncating conversions like\n-        // \"%.4s\" where at most 4 characters of the c-string should be read.\n-        // If we didn't include this special case, we might read off the end.\n-        if(!( (m_extraFlags & Flag_TruncateToPrecision) &&\n-             formatCStringTruncate(tmpStream, value, m_out.precision()) ))\n-        {\n-            // Not a truncated c-string; just format normally.\n-            formatValue(tmpStream, m_fmt, fmtEnd, value);\n-        }\n-        std::string result = tmpStream.str(); // allocates... yuck.\n-        if(m_extraFlags & Flag_SpacePadPositive)\n+        switch(*c)\n         {\n-            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n-                if(result[i] == '+')\n-                    result[i] = ' ';\n+            case '\\0':\n+                out.write(fmt, c - fmt);\n+                return c;\n+            case '%':\n+                out.write(fmt, c - fmt);\n+                if(*(c+1) != '%')\n+                    return c;\n+                // for \"%%\", tack trailing % onto next literal section.\n+                fmt = ++c;\n+                break;\n+            default:\n+                break;\n         }\n-        if((m_extraFlags & Flag_TruncateToPrecision) &&\n-           (int)result.size() > (int)m_out.precision())\n-            m_out.write(result.c_str(), m_out.precision());\n-        else\n-            m_out << result;\n     }\n-    m_extraFlags = Flag_None;\n-    m_fmt = fmtEnd;\n }\n \n \n@@ -663,13 +575,14 @@ void FormatIterator::accept(const T& value)\n // with the form \"%[flags][width][.precision][length]type\".\n //\n // Formatting options which can't be natively represented using the ostream\n-// state are returned in the extraFlags parameter which is a bitwise\n-// combination of values from the ExtraFormatFlags enum.\n-inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n-                                                         unsigned int& extraFlags,\n-                                                         const char* fmtStart,\n-                                                         int variableWidth,\n-                                                         int variablePrecision)\n+// state are returned in spacePadPositive (for space padded positive numbers)\n+// and ntrunc (for truncating conversions).  argIndex is incremented if\n+// necessary to pull out variable width and precision .  The function returns a\n+// pointer to the character after the end of the current format spec.\n+inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n+                                         int& ntrunc, const char* fmtStart,\n+                                         const detail::FormatArg* formatters,\n+                                         int& argIndex, int numFormatters)\n {\n     if(*fmtStart != '%')\n     {\n@@ -684,9 +597,9 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n     out.unsetf(std::ios::adjustfield | std::ios::basefield |\n                std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |\n                std::ios::showpoint | std::ios::showpos | std::ios::uppercase);\n-    extraFlags = Flag_None;\n     bool precisionSet = false;\n     bool widthSet = false;\n+    int widthExtra = 0;\n     const char* c = fmtStart + 1;\n     // 1) Parse flags\n     for(;; ++c)\n@@ -713,12 +626,15 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n             case ' ':\n                 // overridden by show positive sign, '+' flag.\n                 if(!(out.flags() & std::ios::showpos))\n-                    extraFlags |= Flag_SpacePadPositive;\n+                    spacePadPositive = true;\n                 continue;\n             case '+':\n                 out.setf(std::ios::showpos);\n-                extraFlags &= ~Flag_SpacePadPositive;\n+                spacePadPositive = false;\n+                widthExtra = 1;\n                 continue;\n+            default:\n+                break;\n         }\n         break;\n     }\n@@ -731,15 +647,19 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n     if(*c == '*')\n     {\n         widthSet = true;\n-        if(variableWidth < 0)\n+        int width = 0;\n+        if(argIndex < numFormatters)\n+            width = formatters[argIndex++].toInt();\n+        else\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width\");\n+        if(width < 0)\n         {\n             // negative widths correspond to '-' flag set\n             out.fill(' ');\n             out.setf(std::ios::left, std::ios::adjustfield);\n-            variableWidth = -variableWidth;\n+            width = -width;\n         }\n-        out.width(variableWidth);\n-        extraFlags |= Flag_VariableWidth;\n+        out.width(width);\n         ++c;\n     }\n     // 3) Parse precision\n@@ -750,8 +670,10 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n         if(*c == '*')\n         {\n             ++c;\n-            extraFlags |= Flag_VariablePrecision;\n-            precision = variablePrecision;\n+            if(argIndex < numFormatters)\n+                precision = formatters[argIndex++].toInt();\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable precision\");\n         }\n         else\n         {\n@@ -814,7 +736,7 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n             break;\n         case 's':\n             if(precisionSet)\n-                extraFlags |= Flag_TruncateToPrecision;\n+                ntrunc = static_cast<int>(out.precision());\n             // Make %s print booleans as \"true\" and \"false\"\n             out.setf(std::ios::boolalpha);\n             break;\n@@ -826,185 +748,299 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n             TINYFORMAT_ERROR(\"tinyformat: Conversion spec incorrectly \"\n                              \"terminated by end of string\");\n             return c;\n+        default:\n+            break;\n     }\n     if(intConversion && precisionSet && !widthSet)\n     {\n         // \"precision\" for integers gives the minimum number of digits (to be\n         // padded with zeros on the left).  This isn't really supported by the\n         // iostreams, but we can approximately simulate it with the width if\n         // the width isn't otherwise used.\n-        out.width(out.precision());\n+        out.width(out.precision() + widthExtra);\n         out.setf(std::ios::internal, std::ios::adjustfield);\n         out.fill('0');\n     }\n     return c+1;\n }\n \n \n-\n //------------------------------------------------------------------------------\n-// Private format function on top of which the public interface is implemented.\n-// We enforce a mimimum of one value to be formatted to prevent bugs looking like\n-//\n-//   const char* myStr = \"100% broken\";\n-//   printf(myStr);   // Parses % as a format specifier\n-#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n-\n-template<typename T1>\n-void format(FormatIterator& fmtIter, const T1& value1)\n+inline void formatImpl(std::ostream& out, const char* fmt,\n+                       const detail::FormatArg* formatters,\n+                       int numFormatters)\n {\n-    fmtIter.accept(value1);\n-    fmtIter.finish();\n+    // Saved stream state\n+    std::streamsize origWidth = out.width();\n+    std::streamsize origPrecision = out.precision();\n+    std::ios::fmtflags origFlags = out.flags();\n+    char origFill = out.fill();\n+\n+    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)\n+    {\n+        // Parse the format string\n+        fmt = printFormatStringLiteral(out, fmt);\n+        bool spacePadPositive = false;\n+        int ntrunc = -1;\n+        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,\n+                                                   formatters, argIndex, numFormatters);\n+        if (argIndex >= numFormatters)\n+        {\n+            // Check args remain after reading any variable width/precision\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough format arguments\");\n+            return;\n+        }\n+        const FormatArg& arg = formatters[argIndex];\n+        // Format the arg into the stream.\n+        if(!spacePadPositive)\n+            arg.format(out, fmt, fmtEnd, ntrunc);\n+        else\n+        {\n+            // The following is a special case with no direct correspondence\n+            // between stream formatting and the printf() behaviour.  Simulate\n+            // it crudely by formatting into a temporary string stream and\n+            // munging the resulting string.\n+            std::ostringstream tmpStream;\n+            tmpStream.copyfmt(out);\n+            tmpStream.setf(std::ios::showpos);\n+            arg.format(tmpStream, fmt, fmtEnd, ntrunc);\n+            std::string result = tmpStream.str(); // allocates... yuck.\n+            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n+                if(result[i] == '+') result[i] = ' ';\n+            out << result;\n+        }\n+        fmt = fmtEnd;\n+    }\n+\n+    // Print remaining part of format string.\n+    fmt = printFormatStringLiteral(out, fmt);\n+    if(*fmt != '\\0')\n+        TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+\n+    // Restore stream state\n+    out.width(origWidth);\n+    out.precision(origPrecision);\n+    out.flags(origFlags);\n+    out.fill(origFill);\n }\n \n-// General version for C++11\n-template<typename T1, typename... Args>\n-void format(FormatIterator& fmtIter, const T1& value1, const Args&... args)\n+} // namespace detail\n+\n+\n+/// List of template arguments format(), held in a type-opaque way.\n+///\n+/// A const reference to FormatList (typedef'd as FormatListRef) may be\n+/// conveniently used to pass arguments to non-template functions: All type\n+/// information has been stripped from the arguments, leaving just enough of a\n+/// common interface to perform formatting as required.\n+class FormatList\n {\n-    fmtIter.accept(value1);\n-    format(fmtIter, args...);\n-}\n+    public:\n+        FormatList(detail::FormatArg* formatters, int N)\n+            : m_formatters(formatters), m_N(N) { }\n \n-#else\n+        friend void vformat(std::ostream& out, const char* fmt,\n+                            const FormatList& list);\n \n-inline void format(FormatIterator& fmtIter)\n+    private:\n+        const detail::FormatArg* m_formatters;\n+        int m_N;\n+};\n+\n+/// Reference to type-opaque format list for passing to vformat()\n+typedef const FormatList& FormatListRef;\n+\n+\n+namespace detail {\n+\n+// Format list subclass with fixed storage to avoid dynamic allocation\n+template<int N>\n+class FormatListN : public FormatList\n {\n-    fmtIter.finish();\n-}\n+    public:\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+        template<typename... Args>\n+        FormatListN(const Args&... args)\n+            : FormatList(&m_formatterStore[0], N),\n+            m_formatterStore { FormatArg(args)... }\n+        { static_assert(sizeof...(args) == N, \"Number of args must be N\"); }\n+#else // C++98 version\n+        void init(int) {}\n+#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        FormatListN(TINYFORMAT_VARARGS(n))                     \\\n+            : FormatList(&m_formatterStore[0], n)              \\\n+        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        void init(int i, TINYFORMAT_VARARGS(n))                \\\n+        {                                                      \\\n+            m_formatterStore[i] = FormatArg(v1);               \\\n+            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \\\n+        }\n \n-// General version for C++98\n-#define TINYFORMAT_MAKE_FORMAT_DETAIL(n)                                  \\\n-template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void format(detail::FormatIterator& fmtIter, TINYFORMAT_VARARGS(n))       \\\n-{                                                                         \\\n-    fmtIter.accept(v1);                                                   \\\n-    format(fmtIter TINYFORMAT_PASSARGS_TAIL(n));                          \\\n-}\n+        TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)\n+#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR\n+#endif\n \n-TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_DETAIL)\n-#undef TINYFORMAT_MAKE_FORMAT_DETAIL\n+    private:\n+        FormatArg m_formatterStore[N];\n+};\n \n-#endif // End C++98 variadic template emulation for format()\n+// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard\n+template<> class FormatListN<0> : public FormatList\n+{\n+    public: FormatListN() : FormatList(0, 0) {}\n+};\n \n } // namespace detail\n \n \n //------------------------------------------------------------------------------\n-// Implement all the main interface functions here in terms of detail::format()\n+// Primary API functions\n \n #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n \n-// C++11 - the simple case\n-template<typename T1, typename... Args>\n-void format(std::ostream& out, const char* fmt, const T1& v1, const Args&... args)\n+/// Make type-agnostic format list from list of template arguments.\n+///\n+/// The exact return type of this function is an implementation detail and\n+/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:\n+///\n+///   FormatListRef formatList = makeFormatList( /*...*/ );\n+template<typename... Args>\n+detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args)\n {\n-    detail::FormatIterator fmtIter(out, fmt);\n-    format(fmtIter, v1, args...);\n+    return detail::FormatListN<sizeof...(args)>(args...);\n }\n \n-template<typename T1, typename... Args>\n-std::string format(const char* fmt, const T1& v1, const Args&... args)\n+#else // C++98 version\n+\n+inline detail::FormatListN<0> makeFormatList()\n+{\n+    return detail::FormatListN<0>();\n+}\n+#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \\\n+template<TINYFORMAT_ARGTYPES(n)>                              \\\n+detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \\\n+{                                                             \\\n+    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \\\n+}\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)\n+#undef TINYFORMAT_MAKE_MAKEFORMATLIST\n+\n+#endif\n+\n+/// Format list of arguments to the stream according to the given format string.\n+///\n+/// The name vformat() is chosen for the semantic similarity to vprintf(): the\n+/// list of format arguments is held in a single function argument.\n+inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)\n+{\n+    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);\n+}\n+\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+/// Format list of arguments to the stream according to given format string.\n+template<typename... Args>\n+void format(std::ostream& out, const char* fmt, const Args&... args)\n+{\n+    vformat(out, fmt, makeFormatList(args...));\n+}\n+\n+/// Format list of arguments according to the given format string and return\n+/// the result as a string.\n+template<typename... Args>\n+std::string format(const char* fmt, const Args&... args)\n {\n     std::ostringstream oss;\n-    format(oss, fmt, v1, args...);\n+    format(oss, fmt, args...);\n     return oss.str();\n }\n \n-template<typename T1, typename... Args>\n-std::string format(const std::string &fmt, const T1& v1, const Args&... args)\n+/// Format list of arguments to std::cout, according to the given format string\n+template<typename... Args>\n+void printf(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+}\n+\n+template<typename... Args>\n+void printfln(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+    std::cout << '\\n';\n+}\n+\n+#else // C++98 version\n+\n+inline void format(std::ostream& out, const char* fmt)\n+{\n+    vformat(out, fmt, makeFormatList());\n+}\n+\n+inline std::string format(const char* fmt)\n {\n     std::ostringstream oss;\n-    format(oss, fmt.c_str(), v1, args...);\n+    format(oss, fmt);\n     return oss.str();\n }\n \n-template<typename T1, typename... Args>\n-void printf(const char* fmt, const T1& v1, const Args&... args)\n+inline void printf(const char* fmt)\n {\n-    format(std::cout, fmt, v1, args...);\n+    format(std::cout, fmt);\n }\n \n-#else\n+inline void printfln(const char* fmt)\n+{\n+    format(std::cout, fmt);\n+    std::cout << '\\n';\n+}\n \n-// C++98 - define the interface functions using the wrapping macros\n #define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \\\n {                                                                         \\\n-    tinyformat::detail::FormatIterator fmtIter(out, fmt);                 \\\n-    tinyformat::detail::format(fmtIter, TINYFORMAT_PASSARGS(n));          \\\n+    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \\\n }                                                                         \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \\\n {                                                                         \\\n     std::ostringstream oss;                                               \\\n-    tinyformat::format(oss, fmt, TINYFORMAT_PASSARGS(n));                 \\\n+    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \\\n     return oss.str();                                                     \\\n }                                                                         \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-std::string format(const std::string &fmt, TINYFORMAT_VARARGS(n))         \\\n+void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n {                                                                         \\\n-    std::ostringstream oss;                                               \\\n-    tinyformat::format(oss, fmt.c_str(), TINYFORMAT_PASSARGS(n));         \\\n-    return oss.str();                                                     \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n }                                                                         \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n+void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \\\n {                                                                         \\\n-    tinyformat::format(std::cout, fmt, TINYFORMAT_PASSARGS(n));           \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n+    std::cout << '\\n';                                                    \\\n }\n \n TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)\n #undef TINYFORMAT_MAKE_FORMAT_FUNCS\n-#endif\n-\n \n-//------------------------------------------------------------------------------\n-// Define deprecated wrapping macro for backward compatibility in tinyformat\n-// 1.x.  Will be removed in version 2!\n-#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS\n-#define TINYFORMAT_WRAP_FORMAT_N(n, returnType, funcName, funcDeclSuffix,  \\\n-                                 bodyPrefix, streamName, bodySuffix)       \\\n-template<TINYFORMAT_ARGTYPES(n)>                                           \\\n-returnType funcName(TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS const char* fmt,     \\\n-                    TINYFORMAT_VARARGS(n)) funcDeclSuffix                  \\\n-{                                                                          \\\n-    bodyPrefix                                                             \\\n-    tinyformat::format(streamName, fmt, TINYFORMAT_PASSARGS(n));           \\\n-    bodySuffix                                                             \\\n-}                                                                          \\\n-\n-#define TINYFORMAT_WRAP_FORMAT(returnType, funcName, funcDeclSuffix,       \\\n-                               bodyPrefix, streamName, bodySuffix)         \\\n-inline                                                                     \\\n-returnType funcName(TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS const char* fmt      \\\n-                    ) funcDeclSuffix                                       \\\n-{                                                                          \\\n-    bodyPrefix                                                             \\\n-    tinyformat::detail::FormatIterator(streamName, fmt).finish();          \\\n-    bodySuffix                                                             \\\n-}                                                                          \\\n-TINYFORMAT_WRAP_FORMAT_N(1 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(2 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(3 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(4 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(5 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(6 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(7 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(8 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(9 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(10, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(11, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(12, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(13, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(14, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(15, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(16, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+#endif\n \n+// Added for Bitcoin Core\n+template<typename... Args>\n+std::string format(const std::string &fmt, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt.c_str(), args...);\n+    return oss.str();\n+}\n \n } // namespace tinyformat\n "
      }
    ]
  },
  {
    "sha": "a5072a773071b8f4b644f84a77643e2ad18dba3a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTA3MmE3NzMwNzFiOGY0YjY0NGY4NGE3NzY0M2UyYWQxOGRiYTNh",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-06-27T16:39:25Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-06-27T16:39:25Z"
      },
      "message": "util: Remove zero-argument versions of LogPrint and error\n\nChanges in tinyformat, recently imported from upstream have made the\nzero-argument versions of formatting functions unnecessary. Remove them.\n\nThis is a slight semantic change: `%` characters in the zero-argument\ncall are now regarded and need to be escaped. As for as I know, the only\nuse of this is in `main.cpp`.",
      "tree": {
        "sha": "436173f8092d054d7b26cb53eea3fe19f8c0e659",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/436173f8092d054d7b26cb53eea3fe19f8c0e659"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a5072a773071b8f4b644f84a77643e2ad18dba3a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5072a773071b8f4b644f84a77643e2ad18dba3a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a5072a773071b8f4b644f84a77643e2ad18dba3a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5072a773071b8f4b644f84a77643e2ad18dba3a/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "695041e4952ea40e02e3b0431d04ca6af7ec9711",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/695041e4952ea40e02e3b0431d04ca6af7ec9711",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/695041e4952ea40e02e3b0431d04ca6af7ec9711"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 7,
      "deletions": 23
    },
    "files": [
      {
        "sha": "bb65fc0de3eb88068b2285eef593998f6075a6cb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5072a773071b8f4b644f84a77643e2ad18dba3a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5072a773071b8f4b644f84a77643e2ad18dba3a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=a5072a773071b8f4b644f84a77643e2ad18dba3a",
        "patch": "@@ -4159,7 +4159,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     int nGoodTransactions = 0;\n     CValidationState state;\n     int reportDone = 0;\n-    LogPrintf(\"[0%]...\");\n+    LogPrintf(\"[0%%]...\");\n     for (CBlockIndex* pindex = chainActive.Tip(); pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n         boost::this_thread::interruption_point();"
      },
      {
        "sha": "39328b51ef154c38df64dd7266e9c28039f34f1a",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 6,
        "deletions": 22,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5072a773071b8f4b644f84a77643e2ad18dba3a/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5072a773071b8f4b644f84a77643e2ad18dba3a/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=a5072a773071b8f4b644f84a77643e2ad18dba3a",
        "patch": "@@ -77,33 +77,17 @@ int LogPrintStr(const std::string &str);\n \n #define LogPrintf(...) LogPrint(NULL, __VA_ARGS__)\n \n-template<typename T1, typename... Args>\n-static inline int LogPrint(const char* category, const char* fmt, const T1& v1, const Args&... args)\n+template<typename... Args>\n+static inline int LogPrint(const char* category, const char* fmt, const Args&... args)\n {\n     if(!LogAcceptCategory(category)) return 0;                            \\\n-    return LogPrintStr(tfm::format(fmt, v1, args...));\n+    return LogPrintStr(tfm::format(fmt, args...));\n }\n \n-template<typename T1, typename... Args>\n-bool error(const char* fmt, const T1& v1, const Args&... args)\n+template<typename... Args>\n+bool error(const char* fmt, const Args&... args)\n {\n-    LogPrintStr(\"ERROR: \" + tfm::format(fmt, v1, args...) + \"\\n\");\n-    return false;\n-}\n-\n-/**\n- * Zero-arg versions of logging and error, these are not covered by\n- * the variadic templates above (and don't take format arguments but\n- * bare strings).\n- */\n-static inline int LogPrint(const char* category, const char* s)\n-{\n-    if(!LogAcceptCategory(category)) return 0;\n-    return LogPrintStr(s);\n-}\n-static inline bool error(const char* s)\n-{\n-    LogPrintStr(std::string(\"ERROR: \") + s + \"\\n\");\n+    LogPrintStr(\"ERROR: \" + tfm::format(fmt, args...) + \"\\n\");\n     return false;\n }\n "
      }
    ]
  }
]