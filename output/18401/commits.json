[
  {
    "sha": "f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNjNkZWMxODljM2M4ZWVlMWFiMjE4NzY4MWQ1ZDBiMjUxM2IxYjJl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-02T20:12:08Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-04-12T01:32:45Z"
      },
      "message": "[REFACTOR] Initialize PrecomputedTransactionData in CheckInputScripts\n\nAdd a default constructor to `PrecomputedTransactionData`, which doesn't\ninitialize the struct's members. Instead they're initialized inside the\n`CheckInputScripts()` function. This allows a later commit to add the\nspent UTXOs to that structure.",
      "tree": {
        "sha": "89abc0538b185209bf5b338d6b19b7da760d225f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89abc0538b185209bf5b338d6b19b7da760d225f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5504703a9f8388dff66d33bd077bcc4c82dff6c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5504703a9f8388dff66d33bd077bcc4c82dff6c8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5504703a9f8388dff66d33bd077bcc4c82dff6c8"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 32,
      "deletions": 9
    },
    "files": [
      {
        "sha": "1c3c5e362f6b1c195e4d755abf06b57319b96f21",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
        "patch": "@@ -1279,18 +1279,29 @@ uint256 GetOutputsHash(const T& txTo)\n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo)\n {\n+    assert(!m_ready);\n+\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n         hashPrevouts = GetPrevoutHash(txTo);\n         hashSequence = GetSequenceHash(txTo);\n         hashOutputs = GetOutputsHash(txTo);\n-        ready = true;\n     }\n+\n+    m_ready = true;\n+}\n+\n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo);\n }\n \n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n@@ -1303,7 +1314,7 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n-        const bool cacheready = cache && cache->ready;\n+        const bool cacheready = cache && cache->m_ready;\n \n         if (!(nHashType & SIGHASH_ANYONECANPAY)) {\n             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);"
      },
      {
        "sha": "71f2436369144134c0bf92ec8b280fdd099ea300",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
        "patch": "@@ -121,7 +121,12 @@ bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned i\n struct PrecomputedTransactionData\n {\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool ready = false;\n+    bool m_ready = false;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);"
      },
      {
        "sha": "54671f634ed781d01dcd27b2a0d41d02ac5511f5",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f63dec189c3c8eee1ab2187681d5d0b2513b1b2e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f63dec189c3c8eee1ab2187681d5d0b2513b1b2e",
        "patch": "@@ -1016,7 +1016,7 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n     // scripts (ie, other policy checks pass). We perform the inexpensive\n     // checks first and avoid hashing and signature verification unless those\n     // checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n-    PrecomputedTransactionData txdata(*ptx);\n+    PrecomputedTransactionData txdata;\n \n     if (!PolicyScriptChecks(args, workspace, txdata)) return false;\n \n@@ -1512,6 +1512,10 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         return true;\n     }\n \n+    if (!txdata.m_ready) {\n+        txdata.Init(tx);\n+    }\n+\n     for (unsigned int i = 0; i < tx.vin.size(); i++) {\n         const COutPoint &prevout = tx.vin[i].prevout;\n         const Coin& coin = inputs.AccessCoin(prevout);\n@@ -2075,15 +2079,19 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n \n     CBlockUndo blockundo;\n \n+    // Precomputed transaction data pointers must not be invalidated\n+    // until after `control` has run the script checks (potentially\n+    // in multiple threads). Preallocate the vector size so a new allocation\n+    // doesn't invalidate pointers into the vector, and keep txsdata in scope\n+    // for as long as `control`.\n     CCheckQueueControl<CScriptCheck> control(fScriptChecks && g_parallel_script_checks ? &scriptcheckqueue : nullptr);\n+    std::vector<PrecomputedTransactionData> txsdata(block.vtx.size());\n \n     std::vector<int> prevheights;\n     CAmount nFees = 0;\n     int nInputs = 0;\n     int64_t nSigOpsCost = 0;\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n-    std::vector<PrecomputedTransactionData> txdata;\n-    txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = *(block.vtx[i]);\n@@ -2130,13 +2138,12 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-sigops\");\n         }\n \n-        txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n         {\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n             TxValidationState tx_state;\n-            if (fScriptChecks && !CheckInputScripts(tx, tx_state, view, flags, fCacheResults, fCacheResults, txdata[i], g_parallel_script_checks ? &vChecks : nullptr)) {\n+            if (fScriptChecks && !CheckInputScripts(tx, tx_state, view, flags, fCacheResults, fCacheResults, txsdata[i], g_parallel_script_checks ? &vChecks : nullptr)) {\n                 // Any transaction validation failure in ConnectBlock is a block consensus failure\n                 state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n                               tx_state.GetRejectReason(), tx_state.GetDebugMessage());"
      }
    ]
  }
]