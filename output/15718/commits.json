[
  {
    "sha": "303372c41a8d5c58a46cf9ed595e30e67bd0bc99",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMDMzNzJjNDFhOGQ1YzU4YTQ2Y2Y5ZWQ1OTVlMzBlNjdiZDBiYzk5",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "accounts@carldong.me",
        "date": "2019-04-01T19:22:34Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "accounts@carldong.me",
        "date": "2019-04-10T15:48:47Z"
      },
      "message": "docs: Improve netaddress comments\n\n- Improve IsRFC methods docs\n- Improve {Is,Set}Internal docs\n- Add tor methods docs\n- Add IsIPv{4,6} docs\n- Add IsValid docs\n- Add IsRoutable docs\n- Improve GetGroup docs\n- Add CService::GetSockAddr docs\n- Add CService::GetKey docs\n- Add CSubNet::Match docs\n- Add NetmaskBits docs\n- Add CNetAddr default constructor docs",
      "tree": {
        "sha": "18d7343589ea66c3ee797d280246a791aaf68ffd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/18d7343589ea66c3ee797d280246a791aaf68ffd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/303372c41a8d5c58a46cf9ed595e30e67bd0bc99",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/303372c41a8d5c58a46cf9ed595e30e67bd0bc99",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/303372c41a8d5c58a46cf9ed595e30e67bd0bc99",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/303372c41a8d5c58a46cf9ed595e30e67bd0bc99/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a238fccce84bcd5544e88bdc37bf5b9b387d2164",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a238fccce84bcd5544e88bdc37bf5b9b387d2164",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a238fccce84bcd5544e88bdc37bf5b9b387d2164"
      }
    ],
    "stats": {
      "total": 129,
      "additions": 119,
      "deletions": 10
    },
    "files": [
      {
        "sha": "6ee2d8a4b36b8b4dc6000ec2299673110491b2ac",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 4,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/303372c41a8d5c58a46cf9ed595e30e67bd0bc99/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/303372c41a8d5c58a46cf9ed595e30e67bd0bc99/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=303372c41a8d5c58a46cf9ed595e30e67bd0bc99",
        "patch": "@@ -14,6 +14,11 @@ static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n // 0xFD + sha256(\"bitcoin\")[0:5]\n static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n \n+/**\n+ * Construct an unspecified IPv6 network address (::/128).\n+ *\n+ * @note This address is considered invalid by CNetAddr::IsValid()\n+ */\n CNetAddr::CNetAddr()\n {\n     memset(ip, 0, sizeof(ip));\n@@ -40,6 +45,20 @@ void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n     }\n }\n \n+/**\n+ * Try to make this a dummy address that maps the specified name into IPv6 like\n+ * so: (0xFD + %sha256(\"bitcoin\")[0:5]) + %sha256(name)[0:10]. Such dummy\n+ * addresses have a prefix of fd6b:88c0:8724::/48 and are guaranteed to not be\n+ * publicly routable as it falls under RFC4193's fc00::/7 subnet allocated to\n+ * unique-local addresses.\n+ *\n+ * CAddrMan uses these fake addresses to keep track of which DNS seeds were\n+ * used.\n+ *\n+ * @returns Whether or not the operation was successful.\n+ *\n+ * @see CNetAddr::IsInternal(), CNetAddr::IsRFC4193()\n+ */\n bool CNetAddr::SetInternal(const std::string &name)\n {\n     if (name.empty()) {\n@@ -52,6 +71,16 @@ bool CNetAddr::SetInternal(const std::string &name)\n     return true;\n }\n \n+/**\n+ * Try to make this a dummy address that maps the specified onion address into\n+ * IPv6 using OnionCat's range and encoding. Such dummy addresses have a prefix\n+ * of fd87:d87e:eb43::/48 and are guaranteed to not be publicly routable as they\n+ * fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\n+ *\n+ * @returns Whether or not the operation was successful.\n+ *\n+ * @see CNetAddr::IsTor(), CNetAddr::IsRFC4193()\n+ */\n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n@@ -175,6 +204,12 @@ bool CNetAddr::IsRFC4843() const\n     return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n }\n \n+/**\n+ * @returns Whether or not this is a dummy address that maps an onion address\n+ *          into IPv6.\n+ *\n+ * @see CNetAddr::SetSpecial(const std::string &)\n+ */\n bool CNetAddr::IsTor() const\n {\n     return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n@@ -194,6 +229,16 @@ bool CNetAddr::IsLocal() const\n     return false;\n }\n \n+/**\n+ * @returns Whether or not this network address is a valid address that @a could\n+ *          be used to refer to an actual host.\n+ *\n+ * @note A valid address may or may not be publicly routable on the global\n+ *       internet. As in, the set of valid addreses is a superset of the set of\n+ *       publicly routable addresses.\n+ *\n+ * @see CNetAddr::IsRoutable()\n+ */\n bool CNetAddr::IsValid() const\n {\n     // Cleanup 3-byte shifted addresses caused by garbage in size field\n@@ -233,11 +278,25 @@ bool CNetAddr::IsValid() const\n     return true;\n }\n \n+/**\n+ * @returns Whether or not this network address is publicly routable on the\n+ *          global internet.\n+ *\n+ * @note A routable address is always valid. As in, the set of routable addreses\n+ *       is a subset of the set of valid addresses.\n+ *\n+ * @see CNetAddr::IsValid()\n+ */\n bool CNetAddr::IsRoutable() const\n {\n     return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal() || IsInternal());\n }\n \n+/**\n+ * @returns Whether or not this is a dummy address that maps a name into IPv6.\n+ *\n+ * @see CNetAddr::SetInternal(const std::string &)\n+ */\n bool CNetAddr::IsInternal() const\n {\n    return memcmp(ip, g_internal_prefix, sizeof(g_internal_prefix)) == 0;\n@@ -299,6 +358,16 @@ bool operator<(const CNetAddr& a, const CNetAddr& b)\n     return (memcmp(a.ip, b.ip, 16) < 0);\n }\n \n+/**\n+ * Try to get our IPv4 address.\n+ *\n+ * @param[out] pipv4Addr The in_addr struct to which to copy.\n+ *\n+ * @returns Whether or not the operation was successful, in particular, whether\n+ *          or not our address was an IPv4 address.\n+ *\n+ * @see CNetAddr::IsIPv4()\n+ */\n bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n {\n     if (!IsIPv4())\n@@ -307,6 +376,16 @@ bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n     return true;\n }\n \n+/**\n+ * Try to get our IPv6 address.\n+ *\n+ * @param[out] pipv6Addr The in6_addr struct to which to copy.\n+ *\n+ * @returns Whether or not the operation was successful, in particular, whether\n+ *          or not our address was an IPv6 address.\n+ *\n+ * @see CNetAddr::IsIPv6()\n+ */\n bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n {\n     if (!IsIPv6()) {\n@@ -316,8 +395,16 @@ bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n     return true;\n }\n \n-// get canonical identifier of an address' group\n-// no two connections will be attempted to addresses with the same group\n+/**\n+ * Get the canonical identifier of our network group\n+ *\n+ * The groups are assigned in a way where it should be costly for an attacker to\n+ * obtain addresses with many different group identifiers, even if it is cheap\n+ * to obtain addresses with the same identifier.\n+ *\n+ * @note No two connections will be attempted to addresses with the same network\n+ *       group.\n+ */\n std::vector<unsigned char> CNetAddr::GetGroup() const\n {\n     std::vector<unsigned char> vchRet;\n@@ -379,12 +466,15 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n         nBits = 32;\n \n     vchRet.push_back(nClass);\n+\n+    // push our ip onto vchRet byte by byte...\n     while (nBits >= 8)\n     {\n         vchRet.push_back(GetByte(15 - nStartByte));\n         nStartByte++;\n         nBits -= 8;\n     }\n+    // ...for the last byte, push nBits and for the rest of the byte push 1's\n     if (nBits > 0)\n         vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n \n@@ -526,6 +616,18 @@ bool operator<(const CService& a, const CService& b)\n     return static_cast<CNetAddr>(a) < static_cast<CNetAddr>(b) || (static_cast<CNetAddr>(a) == static_cast<CNetAddr>(b) && a.port < b.port);\n }\n \n+/**\n+ * Obtain the IPv4/6 socket address this represents.\n+ *\n+ * @param[out] paddr The obtained socket address.\n+ * @param[in,out] addrlen The size, in bytes, of the address structure pointed\n+ *                        to by paddr. The value that's pointed to by this\n+ *                        parameter might change after calling this function if\n+ *                        the size of the corresponding address structure\n+ *                        changed.\n+ *\n+ * @returns Whether or not the operation was successful.\n+ */\n bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n {\n     if (IsIPv4()) {\n@@ -556,13 +658,16 @@ bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n     return false;\n }\n \n+/**\n+ * @returns An identifier unique to this service's address and port number.\n+ */\n std::vector<unsigned char> CService::GetKey() const\n {\n      std::vector<unsigned char> vKey;\n      vKey.resize(18);\n      memcpy(vKey.data(), ip, 16);\n-     vKey[16] = port / 0x100;\n-     vKey[17] = port & 0x0FF;\n+     vKey[16] = port / 0x100; // most significant byte of our port\n+     vKey[17] = port & 0x0FF; // least significant byte of our port\n      return vKey;\n }\n \n@@ -641,6 +746,10 @@ CSubNet::CSubNet(const CNetAddr &addr):\n     network = addr;\n }\n \n+/**\n+ * @returns True if this subnet is valid, the specified address is valid, and\n+ *          the specified address belongs in this subnet.\n+ */\n bool CSubNet::Match(const CNetAddr &addr) const\n {\n     if (!valid || !addr.IsValid())\n@@ -651,6 +760,10 @@ bool CSubNet::Match(const CNetAddr &addr) const\n     return true;\n }\n \n+/**\n+ * @returns The number of 1-bits in the prefix of the specified subnet mask. If\n+ *          the specified subnet mask is not a valid one, -1.\n+ */\n static inline int NetmaskBits(uint8_t x)\n {\n     switch(x) {"
      },
      {
        "sha": "8230e40606aeb3525331d542b70dcfc874c90ad4",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/303372c41a8d5c58a46cf9ed595e30e67bd0bc99/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/303372c41a8d5c58a46cf9ed595e30e67bd0bc99/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=303372c41a8d5c58a46cf9ed595e30e67bd0bc99",
        "patch": "@@ -48,10 +48,6 @@ class CNetAddr\n         void SetRaw(Network network, const uint8_t *data);\n \n     public:\n-        /**\n-          * Transform an arbitrary string into a non-routable ipv6 address.\n-          * Useful for mapping resolved addresses back to their source.\n-         */\n         bool SetInternal(const std::string& name);\n \n         bool SetSpecial(const std::string &strName); // for Tor addresses\n@@ -69,8 +65,8 @@ class CNetAddr\n         bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n         bool IsRFC4843() const; // IPv6 ORCHID (2001:10::/28)\n         bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n-        bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)\n-        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n+        bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n+        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n         bool IsTor() const;\n         bool IsLocal() const;\n         bool IsRoutable() const;"
      }
    ]
  }
]