[
  {
    "sha": "8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzI3YzNiNmJmZDY0MTdmMWQ2MmE2YjI1ZjFhZmVlYzBmMWM0Nzcw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-10T14:17:35Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-12T02:16:41Z"
      },
      "message": "protocol: Add BIP 156 message types",
      "tree": {
        "sha": "63f761db8c430508e421d4675c43f5a7780e8177",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/63f761db8c430508e421d4675c43f5a7780e8177"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3e3a50aeb8ad81cbbbcc200683e1adeb2dad19de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e3a50aeb8ad81cbbbcc200683e1adeb2dad19de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3e3a50aeb8ad81cbbbcc200683e1adeb2dad19de"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 52,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4e75938e3d1ed762df65b758335bb54dea40518e",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
        "patch": "@@ -24,6 +24,7 @@ const char *MERKLEBLOCK=\"merkleblock\";\n const char *GETBLOCKS=\"getblocks\";\n const char *GETHEADERS=\"getheaders\";\n const char *TX=\"tx\";\n+const char* TX_DANDELION = \"dandeliontx\";\n const char *HEADERS=\"headers\";\n const char *BLOCK=\"block\";\n const char *GETADDR=\"getaddr\";\n@@ -36,6 +37,7 @@ const char *FILTERADD=\"filteradd\";\n const char *FILTERCLEAR=\"filterclear\";\n const char *REJECT=\"reject\";\n const char *SENDHEADERS=\"sendheaders\";\n+const char* ACCEPT_DANDELION = \"dandelionacc\";\n const char *FEEFILTER=\"feefilter\";\n const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n@@ -56,6 +58,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::GETBLOCKS,\n     NetMsgType::GETHEADERS,\n     NetMsgType::TX,\n+    NetMsgType::TX_DANDELION,\n     NetMsgType::HEADERS,\n     NetMsgType::BLOCK,\n     NetMsgType::GETADDR,\n@@ -68,6 +71,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::FILTERCLEAR,\n     NetMsgType::REJECT,\n     NetMsgType::SENDHEADERS,\n+    NetMsgType::ACCEPT_DANDELION,\n     NetMsgType::FEEFILTER,\n     NetMsgType::SENDCMPCT,\n     NetMsgType::CMPCTBLOCK,"
      },
      {
        "sha": "015c542fa03ac0a7606bacf4c80c1bcd98203871",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
        "patch": "@@ -120,6 +120,11 @@ extern const char *GETHEADERS;\n  * @see https://bitcoin.org/en/developer-reference#tx\n  */\n extern const char *TX;\n+/**\n+ * The dandelion tx message transmits a single transaction.\n+ * @see https://github.com/bitcoin/bips/blob/master/bip-0156.mediawiki\n+ */\n+extern const char* TX_DANDELION;\n /**\n  * The headers message sends one or more block headers to a node which\n  * previously requested certain headers with a getheaders message.\n@@ -206,6 +211,12 @@ extern const char *REJECT;\n  * @see https://bitcoin.org/en/developer-reference#sendheaders\n  */\n extern const char *SENDHEADERS;\n+/**\n+ * The dandelion message tells the receiving peer that we accept txs\n+ * as dandelion tx.\n+ * @see https://github.com/bitcoin/bips/blob/master/bip-0156.mediawiki\n+ */\n+extern const char* ACCEPT_DANDELION;\n /**\n  * The feefilter message tells the receiving peer not to inv us any txs\n  * which do not meet the specified min fee rate."
      },
      {
        "sha": "1294d28581b0d909475bc88150b7dfa408dd834c",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
        "patch": "@@ -1321,6 +1321,39 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n \n+\n+class msg_dandelion_accept():\n+    command = b'dandelionacc'\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_dandelion_accept()\"\n+\n+\n+class msg_dandelion_tx():\n+    command = b'dandeliontx'\n+\n+    def __init__(self, tx=CTransaction()):\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.tx.deserialize(f)\n+\n+    def serialize(self):\n+        return self.tx.serialize_with_witness()\n+\n+    def __repr__(self):\n+        return \"msg_dandelion_tx(tx=%s)\" % (repr(self.tx))\n+\n+\n class msg_getblocktxn():\n     command = b\"getblocktxn\"\n "
      },
      {
        "sha": "53dbaf38f397411095d873ef6e78d0454a1802c0",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
        "patch": "@@ -31,6 +31,8 @@\n     b\"block\": msg_block,\n     b\"blocktxn\": msg_blocktxn,\n     b\"cmpctblock\": msg_cmpctblock,\n+    b\"dandelionacc\": msg_dandelion_accept,\n+    b\"dandeliontx\": msg_dandelion_tx,\n     b\"feefilter\": msg_feefilter,\n     b\"getaddr\": msg_getaddr,\n     b\"getblocks\": msg_getblocks,\n@@ -287,6 +289,8 @@ def on_addr(self, message): pass\n     def on_block(self, message): pass\n     def on_blocktxn(self, message): pass\n     def on_cmpctblock(self, message): pass\n+    def on_dandelionacc(self, message): pass\n+    def on_dandeliontx(self, message): pass\n     def on_feefilter(self, message): pass\n     def on_getaddr(self, message): pass\n     def on_getblocks(self, message): pass"
      }
    ]
  },
  {
    "sha": "3c2921779643e691611b09d73866dbcb75417513",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYzI5MjE3Nzk2NDNlNjkxNjExYjA5ZDczODY2ZGJjYjc1NDE3NTEz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-14T23:19:22Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-14T23:21:38Z"
      },
      "message": "logging: Add BCLog::DANDELION",
      "tree": {
        "sha": "6dc015da584affc3075df4e6316f95d5d7a60d08",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6dc015da584affc3075df4e6316f95d5d7a60d08"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c2921779643e691611b09d73866dbcb75417513",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c2921779643e691611b09d73866dbcb75417513",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3c2921779643e691611b09d73866dbcb75417513",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c2921779643e691611b09d73866dbcb75417513/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c27c3b6bfd6417f1d62a6b25f1afeec0f1c4770"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "074aecbd4a69e64addae8894e8150511de30fe5b",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c2921779643e691611b09d73866dbcb75417513/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c2921779643e691611b09d73866dbcb75417513/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=3c2921779643e691611b09d73866dbcb75417513",
        "patch": "@@ -119,6 +119,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::COINDB, \"coindb\"},\n     {BCLog::QT, \"qt\"},\n     {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::DANDELION, \"dandelion\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "02d7270ec277a94c1e66e52256c1326f7b544864",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c2921779643e691611b09d73866dbcb75417513/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c2921779643e691611b09d73866dbcb75417513/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=3c2921779643e691611b09d73866dbcb75417513",
        "patch": "@@ -53,6 +53,7 @@ namespace BCLog {\n         COINDB      = (1 << 18),\n         QT          = (1 << 19),\n         LEVELDB     = (1 << 20),\n+        DANDELION   = (1 << 21),\n         ALL         = ~(uint32_t)0,\n     };\n "
      }
    ]
  },
  {
    "sha": "c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNWFiYTVjNDRlNmY5NzVjNWZmMTcyZjRjNjRiNTZkYmUzZTRmYmUy",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-12T14:44:09Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-15T12:04:42Z"
      },
      "message": "doc: Dandelion transaction relay (BIP 156)",
      "tree": {
        "sha": "4937db3296d75327dd0e72f517145e17ac86a131",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4937db3296d75327dd0e72f517145e17ac86a131"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3c2921779643e691611b09d73866dbcb75417513",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c2921779643e691611b09d73866dbcb75417513",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3c2921779643e691611b09d73866dbcb75417513"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 7,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6b788084ea6bf98108cfa62e46e84e324a367d3f",
        "filename": "doc/bips.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2/doc/bips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2/doc/bips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bips.md?ref=c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
        "patch": "@@ -33,6 +33,7 @@ BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.17.0**):\n * [`BIP 145`](https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki): getblocktemplate updates for Segregated Witness as of **v0.13.0** ([PR 8149](https://github.com/bitcoin/bitcoin/pull/8149)).\n * [`BIP 147`](https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki): NULLDUMMY softfork as of **v0.13.1** ([PR 8636](https://github.com/bitcoin/bitcoin/pull/8636) and [PR 8937](https://github.com/bitcoin/bitcoin/pull/8937)).\n * [`BIP 152`](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki): Compact block transfer and related optimizations are used as of **v0.13.0** ([PR 8068](https://github.com/bitcoin/bitcoin/pull/8068)).\n+* [`BIP 156`](https://github.com/bitcoin/bips/blob/master/bip-0156.mediawiki): Dandelion transaction relay is supported as of **v0.18.0** ([PR 13947](https://github.com/bitcoin/bitcoin/pull/13947)).\n * [`BIP 159`](https://github.com/bitcoin/bips/blob/master/bip-0159.mediawiki): NODE_NETWORK_LIMITED service bit [signaling only] is supported as of **v0.16.0** ([PR 11740](https://github.com/bitcoin/bitcoin/pull/11740)).\n * [`BIP 173`](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki): Bech32 addresses for native Segregated Witness outputs are supported as of **v0.16.0** ([PR 11167](https://github.com/bitcoin/bitcoin/pull/11167)).\n * [`BIP 174`](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki): RPCs to operate on Partially Signed Bitcoin Transactions (PSBT) are present as of **v0.17.0** ([PR 13557](https://github.com/bitcoin/bitcoin/pull/13557))."
      },
      {
        "sha": "d480bc63126c9d5c162a2a2c40afb88f18368123",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
        "patch": "@@ -157,5 +157,11 @@ Credits\n \n Thanks to everyone who directly contributed to this release:\n \n+Brad Denby\n+Giulia Fanti\n+Andrew Miller\n+Surya Bakshi\n+Shaileshh Bojja Venkatakrishnan\n+Pramod Viswanath\n \n As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      }
    ]
  },
  {
    "sha": "bbe290e2a4e03609ac5ed285163a910c9ceafee3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYmUyOTBlMmE0ZTAzNjA5YWM1ZWQyODUxNjNhOTEwYzljZWFmZWUz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-12T13:26:07Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-21T17:07:11Z"
      },
      "message": "net: Add thread to shuffle potential dandelion stems",
      "tree": {
        "sha": "9315cff8bca3209ccf981ca7849c91cb8ea91591",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9315cff8bca3209ccf981ca7849c91cb8ea91591"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bbe290e2a4e03609ac5ed285163a910c9ceafee3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbe290e2a4e03609ac5ed285163a910c9ceafee3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bbe290e2a4e03609ac5ed285163a910c9ceafee3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbe290e2a4e03609ac5ed285163a910c9ceafee3/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c5aba5c44e6f975c5ff172f4c64b56dbe3e4fbe2"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 191,
      "deletions": 8
    },
    "files": [
      {
        "sha": "fdd838fbd8437a73759ba64bd9bbb6fb36603c04",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "patch": "@@ -399,6 +399,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-bantime=<n>\", strprintf(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\", DEFAULT_MISBEHAVING_BANTIME), false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-bind=<addr>\", \"Bind to given address and always listen on it. Use [host]:port notation for IPv6\", false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-connect=<ip>\", \"Connect only to the specified node; -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-dandelion\", strprintf(\"Probability in percent to extend the stem in Dandelion transaction relay by one hop (default: %d, 0 to disable dandelion)\", DEFAULT_DANDELION_STEM_PERCENTAGE), false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-discover\", \"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\", false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-dns\", strprintf(\"Allow DNS lookups for -addnode, -seednode and -connect (default: %u)\", DEFAULT_NAME_LOOKUP), false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-dnsseed\", \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\", false, OptionsCategory::CONNECTION);\n@@ -793,10 +794,13 @@ void InitParameterInteraction()\n             LogPrintf(\"%s: parameter interaction: -externalip set -> setting -discover=0\\n\", __func__);\n     }\n \n-    // disable whitelistrelay in blocksonly mode\n     if (gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)) {\n+        // disable whitelistrelay and dandelion in blocksonly mode\n         if (gArgs.SoftSetBoolArg(\"-whitelistrelay\", false))\n             LogPrintf(\"%s: parameter interaction: -blocksonly=1 -> setting -whitelistrelay=0\\n\", __func__);\n+        if (gArgs.SoftSetBoolArg(\"-dandelion\", false)) {\n+            LogPrintf(\"%s: parameter interaction: -blocksonly=1 -> setting -dandelion=0\\n\", __func__);\n+        }\n     }\n \n     // Forcing relay from whitelisted hosts implies we will accept relays from them in the first place.\n@@ -1385,7 +1389,19 @@ bool AppInitMain()\n     // see Step 2: parameter interactions for more information about these\n     fListen = gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN);\n     fDiscover = gArgs.GetBoolArg(\"-discover\", true);\n-    fRelayTxes = !gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY);\n+    ::fRelayTxes = !gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY);\n+\n+    {\n+        const int64_t pct = gArgs.GetArg(\"-dandelion\", DEFAULT_DANDELION_STEM_PERCENTAGE);\n+        if (pct < 0 || 100 < pct) return InitError(strprintf(_(\"-dandelion must be 0 or a percentage up to 100, not %s\"), gArgs.GetArg(\"-dandelion\", \"\")));\n+        CNode::m_dandelion_stem_pct_threshold = pct;\n+        if (CNode::IsDandelionEnabled()) {\n+            if (!::fRelayTxes) return InitError(\"Must disable -dandelion when not accepting normal transactions\");\n+            LogPrintf(\"Dandelion transaction relay enabled with fluff probability of %d percent.\\n\", CNode::m_dandelion_stem_pct_threshold);\n+        } else {\n+            LogPrintf(\"Dandelion transaction relay disabled.\\n\");\n+        }\n+    }\n \n     for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) {\n         CService addrLocal;"
      },
      {
        "sha": "4fba09bd1bade0e2984abe03d65c9360a6019aa9",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 1,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "patch": "@@ -790,6 +790,18 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n     return true;\n }\n \n+CNode* CNode::GetDandelionDestination(CConnman* connman)\n+{\n+    if (!m_dandelion_destination) return nullptr;\n+\n+    LOCK(connman->cs_dandelion_peers);\n+    if (!m_dandelion_destination->first) {\n+        // The destination disconnected\n+        connman->AssignNewDandelionDestination(this);\n+    }\n+    return m_dandelion_destination ? m_dandelion_destination->first : nullptr;\n+}\n+\n void CNode::SetSendVersion(int nVersionIn)\n {\n     // Send version may only be changed in the version message, and\n@@ -1741,6 +1753,79 @@ int CConnman::GetExtraOutboundCount()\n     return std::max(nOutbound - nMaxOutbound, 0);\n }\n \n+void CConnman::AssignNewDandelionDestination(CNode* from)\n+{\n+    unsigned min_use{std::numeric_limits<unsigned>::max()};\n+    int max_select = 0;\n+    for (DandelionPeer& peer : m_nodes_dandelion) {\n+        // Skip peers that disconnected and have been replaced\n+        if (!peer.first) continue;\n+\n+        // But consider at most MAX_OUTBOUND_DANDELION peers\n+        ++max_select;\n+        if (max_select > MAX_OUTBOUND_DANDELION) break;\n+\n+        // Src and dst must be different\n+        if (from->GetId() == peer.first->GetId()) continue;\n+\n+        // This is the best candidate so far\n+        if (min_use > peer.second) {\n+            min_use = peer.second;\n+            from->m_dandelion_destination = &peer;\n+            break; // They are sorted by use count, so the first one is one of the best ones\n+        }\n+    }\n+    if (from->m_dandelion_destination) {\n+        // Increase use count\n+        ++(from->m_dandelion_destination->second);\n+    }\n+}\n+\n+void CConnman::ThreadShuffleDandelionDestinations()\n+{\n+    while (!interruptNet) {\n+        auto time_micros = GetTimeMicros();\n+        time_micros = PoissonNextSend(time_micros, INTERVAL_DANDELION) - time_micros;\n+\n+        LogPrint(BCLog::DANDELION, \"Dandelion: Shuffle Dandelion Destinations.\\n\");\n+        {\n+            LOCK(cs_dandelion_peers);\n+\n+            std::vector<CNode*> all_nodes;\n+            ForEachNode([&](CNode* node) { all_nodes.push_back(node); });\n+\n+            // Collect all potential dandelion nodes\n+            m_nodes_dandelion.clear();\n+            for (CNode* node : all_nodes) {\n+                // Ignore inbound nodes\n+                if (node->fInbound) continue;\n+                // Ignore nodes that have an empty mempool\n+                if (!node->fRelayTxes) continue;\n+                // Ignore nodes that are about to be disconnected\n+                if (node->IsEphemeral()) continue;\n+\n+                bool full_dandelion = node->m_accept_dandelion;\n+                bool weak_dandelion = //\n+                    !node->fClient /* ignore nodes that don't serve blocks */ &&\n+                    node->nServices & NODE_WITNESS /* pick nodes that support BIP 144 */ &&\n+                    node->nLastTXTime != 0 /* pick nodes that ever sent us a tx */;\n+                if (full_dandelion || weak_dandelion) m_nodes_dandelion.emplace_back(node, 0);\n+            }\n+\n+            // Shuffle\n+            std::shuffle(m_nodes_dandelion.begin(), m_nodes_dandelion.end(), FastRandomContext());\n+            std::shuffle(all_nodes.begin(), all_nodes.end(), FastRandomContext());\n+            for (CNode* node : all_nodes) {\n+                AssignNewDandelionDestination(node);\n+            }\n+        }\n+\n+        if (!interruptNet.sleep_for(std::chrono::milliseconds(time_micros / 1000))) {\n+            return;\n+        }\n+    }\n+}\n+\n void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n {\n     // Connect to specific addresses\n@@ -2369,8 +2454,14 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n         }\n         return false;\n     }\n-    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())\n+    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty()) {\n         threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, \"opencon\", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));\n+    }\n+\n+    if (CNode::IsDandelionEnabled()) {\n+        // Shuffle dandelion destinations\n+        m_thread_shuffle_dandelion = std::thread(&TraceThread<std::function<void()>>, \"dandelionshuff\", [&] { ThreadShuffleDandelionDestinations(); });\n+    }\n \n     // Process messages\n     threadMessageHandler = std::thread(&TraceThread<std::function<void()> >, \"msghand\", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));\n@@ -2426,6 +2517,8 @@ void CConnman::Stop()\n         threadMessageHandler.join();\n     if (threadOpenConnections.joinable())\n         threadOpenConnections.join();\n+    if (m_thread_shuffle_dandelion.joinable())\n+        m_thread_shuffle_dandelion.join();\n     if (threadOpenAddedConnections.joinable())\n         threadOpenAddedConnections.join();\n     if (threadDNSAddressSeed.joinable())\n@@ -2461,10 +2554,31 @@ void CConnman::Stop()\n     semAddnode.reset();\n }\n \n+void CConnman::RemoveFromDandelionPeers(CNode* node)\n+{\n+    if (!CNode::IsDandelionEnabled()) return;\n+\n+    LOCK(cs_dandelion_peers);\n+    if (!node->fSuccessfullyConnected ||\n+        node->fOneShot ||\n+        node->fFeeler) {\n+        // Was never connected (see CNode::IsEphemeral)\n+        return;\n+    }\n+    for (auto it = m_nodes_dandelion.begin(); it != m_nodes_dandelion.end(); ++it) {\n+        if (it->first && it->first->GetId() == node->GetId()) {\n+            it->first = nullptr;\n+            it->second = -1;\n+            return;\n+        }\n+    }\n+}\n+\n void CConnman::DeleteNode(CNode* pnode)\n {\n     assert(pnode);\n     bool fUpdateConnectionTime = false;\n+    RemoveFromDandelionPeers(pnode);\n     m_msgproc->FinalizeNode(pnode->GetId(), fUpdateConnectionTime);\n     if(fUpdateConnectionTime) {\n         addrman.Connected(pnode->addr);\n@@ -2699,6 +2813,8 @@ int CConnman::GetBestHeight() const\n \n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n \n+int64_t CNode::m_dandelion_stem_pct_threshold = DEFAULT_DANDELION_STEM_PERCENTAGE;\n+\n CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string& addrNameIn, bool fInboundIn) :\n     nTimeConnected(GetSystemTimeInSeconds()),\n     addr(addrIn),"
      },
      {
        "sha": "0661af12a3234dd0de0b53a58354fb579f4ba946",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 44,
        "deletions": 5,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "patch": "@@ -14,20 +14,20 @@\n #include <hash.h>\n #include <limitedmap.h>\n #include <netaddress.h>\n-#include <policy/feerate.h>\n #include <protocol.h>\n #include <random.h>\n #include <streams.h>\n #include <sync.h>\n-#include <uint256.h>\n #include <threadinterrupt.h>\n+#include <uint256.h>\n \n #include <atomic>\n+#include <condition_variable>\n #include <deque>\n+#include <memory>\n+#include <queue>\n #include <stdint.h>\n #include <thread>\n-#include <memory>\n-#include <condition_variable>\n \n #ifndef WIN32\n #include <arpa/inet.h>\n@@ -37,12 +37,16 @@\n class CScheduler;\n class CNode;\n \n+/** Default for -dandelion stem percentage */\n+static constexpr int64_t DEFAULT_DANDELION_STEM_PERCENTAGE = 90;\n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n static const int PING_INTERVAL = 2 * 60;\n /** Time after which to disconnect, after waiting for a ping response (or inactivity). */\n static const int TIMEOUT_INTERVAL = 20 * 60;\n /** Run the feeler connection loop once every 2 minutes or 120 seconds. **/\n static const int FEELER_INTERVAL = 120;\n+/** Pick new dandelion peers once every 10 minutes or 600 seconds. */\n+static constexpr int INTERVAL_DANDELION = 600;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n /** The maximum number of new addresses to accumulate before announcing. */\n@@ -53,6 +57,8 @@ static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n static const unsigned int MAX_SUBVERSION_LENGTH = 256;\n /** Maximum number of automatic outgoing nodes */\n static const int MAX_OUTBOUND_CONNECTIONS = 8;\n+/** Pick that many dandelion destinations from the outbound peers */\n+static constexpr int MAX_OUTBOUND_DANDELION = 2;\n /** Maximum number of addnode outgoing nodes */\n static const int MAX_ADDNODE_CONNECTIONS = 8;\n /** -listen default */\n@@ -317,6 +323,16 @@ class CConnman\n     */\n     int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n+    using DandelionPeer = std::pair<CNode*, /* use count */ unsigned>;\n+\n+    CCriticalSection cs_dandelion_peers;\n+    /** Set of all potential dandelion destinations */\n+    std::vector<DandelionPeer> m_nodes_dandelion GUARDED_BY(cs_dandelion_peers);\n+    /** Assign a new dandelion destination to this peer, if possible */\n+    void AssignNewDandelionDestination(CNode* from) EXCLUSIVE_LOCKS_REQUIRED(cs_dandelion_peers);\n+    /** Remove this node from the current set of dandelion peers */\n+    void RemoveFromDandelionPeers(CNode* node);\n+\n private:\n     struct ListenSocket {\n         SOCKET socket;\n@@ -332,6 +348,7 @@ class CConnman\n     void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n     void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadShuffleDandelionDestinations();\n     void ThreadMessageHandler();\n     void AcceptConnection(const ListenSocket& hListenSocket);\n     void ThreadSocketHandler();\n@@ -433,6 +450,7 @@ class CConnman\n     std::thread threadDNSAddressSeed;\n     std::thread threadSocketHandler;\n     std::thread threadOpenAddedConnections;\n+    std::thread m_thread_shuffle_dandelion;\n     std::thread threadOpenConnections;\n     std::thread threadMessageHandler;\n \n@@ -692,12 +710,17 @@ class CNode\n     int64_t nNextAddrSend;\n     int64_t nNextLocalAddrSend;\n \n+    /** dandelion threshold percentage */\n+    static int64_t m_dandelion_stem_pct_threshold;\n+\n+    std::atomic<bool> m_accept_dandelion{false}; //!< If this peer accepts dandelion txs\n+\n     // inventory based relay\n     CRollingBloomFilter filterInventoryKnown;\n     // Set of transaction ids we still have to announce.\n     // They are sorted by the mempool before relay, so the order is not important.\n     std::set<uint256> setInventoryTxToSend;\n-    // List of block ids we still have announce.\n+    // List of block ids we still have to announce.\n     // There is no final sorting before sending, as they are always sent immediately\n     // and in the order requested.\n     std::vector<uint256> vInventoryBlockToSend;\n@@ -755,6 +778,10 @@ class CNode\n     // Our address, as reported by the peer\n     CService addrLocal;\n     mutable CCriticalSection cs_addrLocal;\n+\n+    /** Our current dandelion destination */\n+    CConnman::DandelionPeer* m_dandelion_destination /* GUARDED_BY(CConnman::cs_dandelion_peers) */ {nullptr};\n+\n public:\n \n     NodeId GetId() const {\n@@ -803,7 +830,19 @@ class CNode\n         nRefCount--;\n     }\n \n+    /** If this peer is not yet connected or soon to be disconnected */\n+    bool IsEphemeral() const\n+    {\n+        return !fSuccessfullyConnected &&\n+               fDisconnect &&\n+               fOneShot &&\n+               fFeeler;\n+    }\n+\n+    static bool IsDandelionEnabled() { return m_dandelion_stem_pct_threshold != 0; }\n \n+    /** Return the current dandelion destination. Try to assign one if it does not exist. */\n+    CNode* GetDandelionDestination(CConnman* connman);\n \n     void AddAddressKnown(const CAddress& _addr)\n     {"
      },
      {
        "sha": "84b2c080fd29612387da1792eda9505cb64123d3",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "patch": "@@ -1821,6 +1821,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                       (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"));\n         }\n \n+        if (CNode::m_dandelion_stem_pct_threshold != 0) {\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::ACCEPT_DANDELION));\n+        }\n+\n         if (pfrom->nVersion >= SENDHEADERS_VERSION) {\n             // Tell our peer we prefer to receive headers rather than inv's\n             // We send this to non-NODE NETWORK peers as well, because even\n@@ -1908,6 +1912,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n+    else if (strCommand == NetMsgType::ACCEPT_DANDELION) {\n+        LogPrint(BCLog::DANDELION, \"Dandelion: peer=%d accepts Dandelion transactions.\\n\", pfrom->GetId());\n+        pfrom->m_accept_dandelion = true;\n+        return true;\n+    }\n+\n     else if (strCommand == NetMsgType::SENDCMPCT)\n     {\n         bool fAnnounceUsingCMPCTBLOCK = false;"
      },
      {
        "sha": "a0925198bde48d4558a7f0ba523539ce24de7842",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbe290e2a4e03609ac5ed285163a910c9ceafee3/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "patch": "@@ -17,6 +17,8 @@ static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n /** Default for BIP61 (sending reject messages) */\n static constexpr bool DEFAULT_ENABLE_BIP61 = true;\n \n+void ShuffleDandelionStems(const CConnman* connman);\n+\n class PeerLogicValidation final : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* const connman;"
      }
    ]
  },
  {
    "sha": "8b533b25fdd074a32077c339932aab30cb02295f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjUzM2IyNWZkZDA3NGEzMjA3N2MzMzk5MzJhYWIzMGNiMDIyOTVm",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-10T16:01:01Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-21T17:07:11Z"
      },
      "message": "p2p: Keep cache of recent Dandelion transactions for stem expiry",
      "tree": {
        "sha": "2983841e8ab747aff168acaf61994f2f1995ea00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2983841e8ab747aff168acaf61994f2f1995ea00"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b533b25fdd074a32077c339932aab30cb02295f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b533b25fdd074a32077c339932aab30cb02295f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b533b25fdd074a32077c339932aab30cb02295f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b533b25fdd074a32077c339932aab30cb02295f/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbe290e2a4e03609ac5ed285163a910c9ceafee3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bbe290e2a4e03609ac5ed285163a910c9ceafee3"
      }
    ],
    "stats": {
      "total": 177,
      "additions": 175,
      "deletions": 2
    },
    "files": [
      {
        "sha": "66ffe19068c8fb2cefe36e3c5e034952fd000ddd",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b533b25fdd074a32077c339932aab30cb02295f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b533b25fdd074a32077c339932aab30cb02295f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8b533b25fdd074a32077c339932aab30cb02295f",
        "patch": "@@ -36,6 +36,8 @@\n \n class CScheduler;\n class CNode;\n+class CTransaction;\n+using CTransactionRef = std::shared_ptr<const CTransaction>;\n \n /** Default for -dandelion stem percentage */\n static constexpr int64_t DEFAULT_DANDELION_STEM_PERCENTAGE = 90;\n@@ -69,6 +71,8 @@ static const bool DEFAULT_UPNP = USE_UPNP;\n #else\n static const bool DEFAULT_UPNP = false;\n #endif\n+/** The maximum size of the per-peer dandelion cache in Byte */\n+static constexpr size_t MAX_DANDELION_CACHE_SZ = 1000 * 1000;\n /** The maximum number of entries in mapAskFor */\n static const size_t MAPASKFOR_MAX_SZ = MAX_INV_SZ;\n /** The maximum number of entries in setAskFor (larger due to getdata latency)*/\n@@ -715,6 +719,19 @@ class CNode\n \n     std::atomic<bool> m_accept_dandelion{false}; //!< If this peer accepts dandelion txs\n \n+    using DandelionCache = std::map</* witness hash */ uint256, std::pair<CTransactionRef, /* expiry */ int64_t>>;\n+    /** The dandelion cache\n+     * Contains transactions that are\n+     * - not in our mempool\n+     * - not mined\n+     * - not expired\n+     */\n+    DandelionCache m_cache_dandelion;\n+    /** The total size of all txs in the cache */\n+    size_t m_cache_dandelion_size{0};\n+    /** To check if a tx in the cache might have expired */\n+    std::priority_queue<int64_t, std::vector<int64_t>, std::greater<int64_t>> m_cache_expiry;\n+\n     // inventory based relay\n     CRollingBloomFilter filterInventoryKnown;\n     // Set of transaction ids we still have to announce."
      },
      {
        "sha": "bc5b3657e063e1bc12930a2bc8758fd0a21e37ae",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 157,
        "deletions": 2,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b533b25fdd074a32077c339932aab30cb02295f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b533b25fdd074a32077c339932aab30cb02295f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8b533b25fdd074a32077c339932aab30cb02295f",
        "patch": "@@ -39,6 +39,10 @@\n static constexpr int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n /** Minimum time between orphan transactions expire time checks in seconds */\n static constexpr int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n+/** Keep Dandelion txs for at least this long in the cache before expiry */\n+static constexpr int64_t EXPIRE_DANDELION_CACHE = 10;\n+/** Per-peer random additional delay for Dandelion cache expiry*/\n+static constexpr int64_t EXPIRE_DANDELION_CACHE_AVG_ADD = 20;\n /** Headers download timeout expressed in microseconds\n  *  Timeout = base + per_header * (expected number of headers) */\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n@@ -1063,12 +1067,63 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n static void RelayTransaction(const CTransaction& tx, CConnman* connman)\n {\n     CInv inv(MSG_TX, tx.GetHash());\n-    connman->ForEachNode([&inv](CNode* pnode)\n-    {\n+    connman->ForEachNode([&inv](CNode* pnode) {\n         pnode->PushInventory(inv);\n+        pnode->m_cache_dandelion.erase(inv.hash);\n     });\n }\n \n+static void FluffTransaction(CTxMemPool& tx_pool, const CNode* from, const CTransactionRef& ptx, CConnman* connman)\n+{\n+    LogPrint(BCLog::DANDELION, \"fluff\\n\");\n+    CValidationState state;\n+    if (!AcceptToMemoryPool(tx_pool, state, ptx, /* pfMissingInputs */ nullptr, /* plTxnReplaced */ nullptr, /* bypass_limits */ false, /* nAbsurdFee */ 0, /* test_accept */ false)) {\n+        // Should never happen, since we checked for validity\n+        LogPrint(BCLog::DANDELION, \"Dandelion transaction fluff failed due to %s\\n\", FormatStateMessage(state));\n+        return;\n+    }\n+    tx_pool.check(pcoinsTip.get());\n+    RelayTransaction(*ptx, connman);\n+    LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+        from->GetId(),\n+        ptx->GetHash().ToString(),\n+        tx_pool.size(), tx_pool.DynamicMemoryUsage() / 1000);\n+}\n+\n+static void RelayDandelionTransaction(CTxMemPool& tx_pool, CNode* node_from, const CTransactionRef& ptx, const CNetMsgMaker& msg_maker, CConnman* connman)\n+{\n+    bool fluff = GetRand(100 * 100) / 100. >= CNode::m_dandelion_stem_pct_threshold;\n+    if (fluff) return FluffTransaction(tx_pool, node_from, ptx, connman);\n+\n+    CNode* dest = node_from->GetDandelionDestination(connman);\n+    if (!dest) {\n+        // Just fall back to full fluff at this point\n+        return FluffTransaction(tx_pool, node_from, ptx, connman);\n+    }\n+\n+    // Dandelion relay (at least one hop)\n+    const int64_t now_micros = GetTimeMicros();\n+    const int64_t expiry = now_micros + EXPIRE_DANDELION_CACHE * 1000 * 1000 + PoissonNextSend(now_micros, EXPIRE_DANDELION_CACHE_AVG_ADD);\n+    node_from->m_cache_dandelion.emplace(std::make_pair(ptx->GetWitnessHash(), std::make_pair(ptx, expiry)));\n+    node_from->m_cache_dandelion_size += ptx->GetTotalSize();\n+    node_from->m_cache_expiry.push(expiry);\n+\n+    static constexpr int DANDELION_SEND_FLAGS{0}; // Always send as witness tx\n+\n+    // Check if the next peer would fluff (assume same probability)\n+    bool force_fluff = GetRand(100 * 100) / 100. >= CNode::m_dandelion_stem_pct_threshold;\n+\n+    if (force_fluff || !dest->m_accept_dandelion) {\n+        // The next peer is going to transition into fluff-phase\n+        LogPrint(BCLog::DANDELION, \"one-hop relay to peer=%d\\n\", dest->GetId());\n+        connman->PushMessage(dest, msg_maker.Make(DANDELION_SEND_FLAGS, NetMsgType::TX, *ptx));\n+        return;\n+    }\n+\n+    LogPrint(BCLog::DANDELION, \"dandelion relay to peer=%d\\n\", dest->GetId());\n+    connman->PushMessage(dest, msg_maker.Make(DANDELION_SEND_FLAGS, NetMsgType::TX_DANDELION, *ptx));\n+}\n+\n static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connman)\n {\n     unsigned int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n@@ -2197,6 +2252,46 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     }\n \n \n+    else if (strCommand == NetMsgType::TX_DANDELION) {\n+        if (!CNode::IsDandelionEnabled()) {\n+            LogPrint(BCLog::NET, \"Dandelion transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n+            return true;\n+        }\n+\n+        CTransactionRef tx;\n+        vRecv >> tx;\n+\n+        LogPrint(BCLog::DANDELION, \"Dandelion: peer=%d: %s \", pfrom->GetId(), tx->GetHash().ToString()); /* Continued */\n+\n+        if (pfrom->m_cache_dandelion_size > MAX_DANDELION_CACHE_SZ) {\n+            LogPrint(BCLog::DANDELION, \"full cache (size: %d)\\n\", pfrom->m_cache_dandelion_size);\n+            return true;\n+        }\n+\n+        LOCK(cs_main);\n+        if (AlreadyHave(CInv{MSG_TX, tx->GetHash()})) {\n+            LogPrint(BCLog::DANDELION, \"already have\\n\");\n+            return true;\n+        }\n+\n+        CValidationState state;\n+        bool missing_inputs;\n+        if (AcceptToMemoryPool(mempool, state, tx, &missing_inputs, nullptr /* lRemovedTxn */, false /* bypass_limits */, 0 /* nAbsurdFee */, true /* test_accept */)) {\n+            RelayDandelionTransaction(mempool, pfrom, tx, msgMaker, connman);\n+            return true;\n+        }\n+        if (missing_inputs) {\n+            LogPrint(BCLog::DANDELION, \"missing inputs\\n\");\n+            return true;\n+        }\n+\n+        LogPrint(BCLog::DANDELION, \"invalid %s\\n\", FormatStateMessage(state));\n+        int penalty = 0;\n+        if (state.IsInvalid(penalty) && penalty) Misbehaving(pfrom->GetId(), penalty);\n+        return true;\n+    }\n+\n+\n     else if (strCommand == NetMsgType::TX)\n     {\n         // Stop processing the transaction early if\n@@ -2977,8 +3072,68 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman, bool en\n     return false;\n }\n \n+/** Check if any dandelion txs expired. If so, relay them. */\n+static void CheckDandelionExpiry(CNode* from, CTxMemPool& tx_pool, CConnman* connman)\n+{\n+    if (from->m_cache_expiry.empty()) return;\n+\n+    const int64_t now_millis = GetTimeMillis();\n+\n+    // Constant time lookup:\n+    if (from->m_cache_expiry.top() >= now_millis) return;\n+\n+    // Otherwise walk the whole cache to look for the expired tx(s)\n+    do {\n+        from->m_cache_expiry.pop();\n+    } while (from->m_cache_expiry.top() < now_millis);\n+\n+    for (auto it = from->m_cache_dandelion.cbegin(); it != from->m_cache_dandelion.cend(); ++it) {\n+        if (it->second.second >= now_millis) continue;\n+\n+        CTransactionRef tx = it->second.first;\n+        from->m_cache_dandelion.erase(it);\n+        from->m_cache_dandelion_size -= tx->GetTotalSize();\n+\n+        LogPrint(BCLog::DANDELION, \"Dandelion: peer=%d: expired %s (cachesz %u txn, %u kB) \", /* Continued */\n+            from->GetId(),\n+            tx->GetHash().ToString(),\n+            from->m_cache_dandelion.size(), from->m_cache_dandelion_size);\n+\n+        LOCK(cs_main);\n+        if (AlreadyHave(CInv{MSG_TX, tx->GetHash()})) {\n+            LogPrint(BCLog::DANDELION, \"already have\\n\");\n+            continue;\n+        }\n+        bool missing_inputs;\n+        CValidationState state;\n+        if (AcceptToMemoryPool(tx_pool, state, std::move(tx), &missing_inputs, /* plTxnReplaced */ nullptr, /* bypass_limits */ false, /* nAbsurdFee */ 0, /* test_accept */ true)) {\n+            LogPrint(BCLog::DANDELION, \"accepted to mempool\\n\");\n+            tx_pool.check(pcoinsTip.get());\n+            RelayTransaction(*tx, connman);\n+            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+                from->GetId(),\n+                tx->GetHash().ToString(),\n+                tx_pool.size(), tx_pool.DynamicMemoryUsage() / 1000);\n+            continue;\n+        }\n+        if (missing_inputs) {\n+            LogPrint(BCLog::DANDELION, \"missing inputs\\n\");\n+            continue;\n+        }\n+\n+        LogPrint(BCLog::DANDELION, \"invalid %s\\n\", FormatStateMessage(state));\n+        int penalty = 0;\n+        if (state.IsInvalid(penalty) && penalty) Misbehaving(from->GetId(), penalty);\n+        continue;\n+    }\n+}\n+\n+\n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n+    // Expire Dandelion cache\n+    CheckDandelionExpiry(pfrom, ::mempool, connman);\n+\n     const CChainParams& chainparams = Params();\n     //\n     // Message format"
      },
      {
        "sha": "3d88ae523924d17f2c4be050e4d90ad508368727",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b533b25fdd074a32077c339932aab30cb02295f/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b533b25fdd074a32077c339932aab30cb02295f/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=8b533b25fdd074a32077c339932aab30cb02295f",
        "patch": "@@ -1170,6 +1170,7 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n     g_connman->ForEachNode([&inv](CNode* pnode)\n     {\n         pnode->PushInventory(inv);\n+        pnode->m_cache_dandelion.erase(inv.hash);\n     });\n \n     return hashTx.GetHex();"
      }
    ]
  }
]