[
  {
    "sha": "1ebd733a94ab515ab6e38510ff91941b5b1c1957",
    "node_id": "C_kwDOABII59oAKDFlYmQ3MzNhOTRhYjUxNWFiNmUzODUxMGZmOTE5NDFiNWIxYzE5NTc",
    "commit": {
      "author": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2020-07-13T23:11:37Z"
      },
      "committer": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2021-11-20T17:06:52Z"
      },
      "message": "util: add CBufferedFile::Skip() to move ahead in the stream\n\nNote that Skip() does read data from the file into the CBufferedFile\nobject (memory), but, unlike this object's read() method, Skip()\ndoesn't transfer data into the user's memory buffer. This is useful\nbecause the user can rewind the stream (SetPos()) and access the object\nmemory.",
      "tree": {
        "sha": "7ec685bd8dd2e698ce7983e44c4573637130df3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7ec685bd8dd2e698ce7983e44c4573637130df3f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ebd733a94ab515ab6e38510ff91941b5b1c1957",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ebd733a94ab515ab6e38510ff91941b5b1c1957",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ebd733a94ab515ab6e38510ff91941b5b1c1957",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ebd733a94ab515ab6e38510ff91941b5b1c1957/comments",
    "author": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "80ae64db6b27d69b0fe7b6583066b1141f7a2f51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/80ae64db6b27d69b0fe7b6583066b1141f7a2f51",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/80ae64db6b27d69b0fe7b6583066b1141f7a2f51"
      }
    ],
    "stats": {
      "total": 99,
      "additions": 84,
      "deletions": 15
    },
    "files": [
      {
        "sha": "0c08df9c5d5211c5caf94011a47f5405a3e162e9",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ebd733a94ab515ab6e38510ff91941b5b1c1957/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ebd733a94ab515ab6e38510ff91941b5b1c1957/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=1ebd733a94ab515ab6e38510ff91941b5b1c1957",
        "patch": "@@ -748,13 +748,20 @@ class CBufferedFile\n                 nNow = vchBuf.size() - pos;\n             if (nNow + nReadPos > nSrcPos)\n                 nNow = nSrcPos - nReadPos;\n-            memcpy(pch, &vchBuf[pos], nNow);\n+            if (pch) {\n+                memcpy(pch, &vchBuf[pos], nNow);\n+                pch += nNow;\n+            }\n             nReadPos += nNow;\n-            pch += nNow;\n             nSize -= nNow;\n         }\n     }\n \n+    //! move ahead in the stream\n+    void Skip(size_t nSize) {\n+        read(nullptr, nSize);\n+    }\n+\n     //! return the current reading position\n     uint64_t GetPos() const {\n         return nReadPos;"
      },
      {
        "sha": "0facd37224b233b2f4cb25aadbc0f78912e6b7ea",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 13,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ebd733a94ab515ab6e38510ff91941b5b1c1957/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ebd733a94ab515ab6e38510ff91941b5b1c1957/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=1ebd733a94ab515ab6e38510ff91941b5b1c1957",
        "patch": "@@ -78,7 +78,7 @@ BOOST_AUTO_TEST_CASE(streams_vector_reader)\n     // Read a single byte as an unsigned char.\n     unsigned char a;\n     reader >> a;\n-    BOOST_CHECK_EQUAL(a, 1);\n+    BOOST_CHECK_EQUAL(a, 1U);\n     BOOST_CHECK_EQUAL(reader.size(), 5U);\n     BOOST_CHECK(!reader.empty());\n \n@@ -244,22 +244,22 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file)\n \n     uint8_t i;\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 0);\n+    BOOST_CHECK_EQUAL(i, 0U);\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 1);\n+    BOOST_CHECK_EQUAL(i, 1U);\n \n     // After reading bytes 0 and 1, we're positioned at 2.\n     BOOST_CHECK_EQUAL(bf.GetPos(), 2U);\n \n     // Rewind to offset 0, ok (within the 10 byte window).\n     BOOST_CHECK(bf.SetPos(0));\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 0);\n+    BOOST_CHECK_EQUAL(i, 0U);\n \n     // We can go forward to where we've been, but beyond may fail.\n     BOOST_CHECK(bf.SetPos(2));\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 2);\n+    BOOST_CHECK_EQUAL(i, 2U);\n \n     // If you know the maximum number of bytes that should be\n     // read to deserialize the variable, you can limit the read\n@@ -289,22 +289,22 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file)\n     BOOST_CHECK(bf.SetPos(0));\n     BOOST_CHECK_EQUAL(bf.GetPos(), 0U);\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 0);\n+    BOOST_CHECK_EQUAL(i, 0U);\n \n     // We can set the position forward again up to the farthest\n     // into the stream we've been, but no farther. (Attempting\n     // to go farther may succeed, but it's not guaranteed.)\n     BOOST_CHECK(bf.SetPos(10));\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 10);\n+    BOOST_CHECK_EQUAL(i, 10U);\n     BOOST_CHECK_EQUAL(bf.GetPos(), 11U);\n \n     // Now it's only guaranteed that we can rewind to offset 1\n     // (current read position, 11, minus rewind amount, 10).\n     BOOST_CHECK(bf.SetPos(1));\n     BOOST_CHECK_EQUAL(bf.GetPos(), 1U);\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 1);\n+    BOOST_CHECK_EQUAL(i, 1U);\n \n     // We can stream into large variables, even larger than\n     // the buffer size.\n@@ -313,7 +313,7 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file)\n         uint8_t a[40 - 11];\n         bf >> a;\n         for (uint8_t j = 0; j < sizeof(a); ++j) {\n-            BOOST_CHECK_EQUAL(a[j], 11 + j);\n+            BOOST_CHECK_EQUAL(a[j], 11U + j);\n         }\n     }\n     BOOST_CHECK_EQUAL(bf.GetPos(), 40U);\n@@ -333,21 +333,72 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file)\n     BOOST_CHECK_EQUAL(bf.GetPos(), 40U);\n     BOOST_CHECK(bf.SetPos(30));\n     bf >> i;\n-    BOOST_CHECK_EQUAL(i, 30);\n+    BOOST_CHECK_EQUAL(i, 30U);\n     BOOST_CHECK_EQUAL(bf.GetPos(), 31U);\n \n     // We're too far to rewind to position zero.\n     BOOST_CHECK(!bf.SetPos(0));\n     // But we should now be positioned at least as far back as allowed\n     // by the rewind window (relative to our farthest read position, 40).\n-    BOOST_CHECK(bf.GetPos() <= 30);\n+    BOOST_CHECK(bf.GetPos() <= 30U);\n \n     // We can explicitly close the file, or the destructor will do it.\n     bf.fclose();\n \n     fs::remove(streams_test_filename);\n }\n \n+BOOST_AUTO_TEST_CASE(streams_buffered_file_skip)\n+{\n+    FILE* file = fsbridge::fopen(\"streams_test_tmp\", \"w+b\");\n+    // The value at each offset is the byte offset (e.g. byte 1 in the file has the value 0x01).\n+    for (uint8_t j = 0; j < 40; ++j) {\n+        fwrite(&j, 1, 1, file);\n+    }\n+    rewind(file);\n+\n+    // The buffer is 25 bytes, allow rewinding 10 bytes.\n+    CBufferedFile bf(file, 25, 10, 222, 333);\n+\n+    uint8_t i;\n+    // This is like bf >> (7-byte-variable), in that it will cause data\n+    // to be read from the file into memory, but it's not copied to us.\n+    bf.Skip(7);\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 7U);\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 7U);\n+\n+    // The bytes in the buffer up to offset 7 are valid and can be read.\n+    BOOST_CHECK(bf.SetPos(0));\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 0U);\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 1U);\n+\n+    // Skip()'s argument is the number of bytes to move forward in the\n+    // file, not the absolute file position. Since bf is currently\n+    // positioned to 2, this will advance it to 11.\n+    bf.Skip(9);\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 11U);\n+\n+    // Skip() honors the transfer limit; this allows only one byte\n+    // to be skipped (or read) since we're at position 12.\n+    bf.SetLimit(13);\n+    try {\n+        bf.Skip(2);\n+        BOOST_CHECK(false);\n+    } catch (const std::exception& e) {\n+        BOOST_CHECK(strstr(e.what(), \"Read attempted past buffer limit\") != nullptr);\n+    }\n+\n+    bf.Skip(1);\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 13U);\n+\n+    bf.fclose();\n+    fs::remove(\"streams_test_tmp\");\n+}\n+\n BOOST_AUTO_TEST_CASE(streams_buffered_file_rand)\n {\n     // Make this test deterministic.\n@@ -379,7 +430,7 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file_rand)\n             // sizes; the boundaries of the objects can interact arbitrarily\n             // with the CBufferFile's internal buffer. These first three\n             // cases simulate objects of various sizes (1, 2, 5 bytes).\n-            switch (InsecureRandRange(5)) {\n+            switch (InsecureRandRange(6)) {\n             case 0: {\n                 uint8_t a[1];\n                 if (currentPos + 1 > fileSize)\n@@ -417,6 +468,17 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file_rand)\n                 break;\n             }\n             case 3: {\n+                // Skip is similar to the \"read\" cases above, except\n+                // we don't receive the data.\n+                size_t nSize = InsecureRandRange(5);\n+                if (currentPos + nSize > fileSize)\n+                    continue;\n+                bf.SetLimit(currentPos + nSize);\n+                bf.Skip(nSize);\n+                currentPos += nSize;\n+                break;\n+            }\n+            case 4: {\n                 // Find a byte value (that is at or ahead of the current position).\n                 size_t find = currentPos + InsecureRandRange(8);\n                 if (find >= fileSize)\n@@ -433,7 +495,7 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file_rand)\n                 currentPos++;\n                 break;\n             }\n-            case 4: {\n+            case 5: {\n                 size_t requestPos = InsecureRandRange(maxPos + 4);\n                 bool okay = bf.SetPos(requestPos);\n                 // The new position may differ from the requested position"
      }
    ]
  },
  {
    "sha": "0908d01954e737bb7309941f5a6eaff930ba4f30",
    "node_id": "C_kwDOABII59oAKDA5MDhkMDE5NTRlNzM3YmI3MzA5OTQxZjVhNmVhZmY5MzBiYTRmMzA",
    "commit": {
      "author": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2020-08-07T21:07:21Z"
      },
      "committer": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2021-11-20T17:06:52Z"
      },
      "message": "Faster -reindex by initially deserializing only headers\n\nThe changes to feature_reindex.py don't test new functionality, as there\nis no new functionality. It only increases test coverage to include the\nother changes in this PR.",
      "tree": {
        "sha": "5655cb7eb72582eb8367c6b7b1c4a842a4049a2c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5655cb7eb72582eb8367c6b7b1c4a842a4049a2c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0908d01954e737bb7309941f5a6eaff930ba4f30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0908d01954e737bb7309941f5a6eaff930ba4f30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0908d01954e737bb7309941f5a6eaff930ba4f30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0908d01954e737bb7309941f5a6eaff930ba4f30/comments",
    "author": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1ebd733a94ab515ab6e38510ff91941b5b1c1957",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ebd733a94ab515ab6e38510ff91941b5b1c1957",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1ebd733a94ab515ab6e38510ff91941b5b1c1957"
      }
    ],
    "stats": {
      "total": 78,
      "additions": 67,
      "deletions": 11
    },
    "files": [
      {
        "sha": "25316d2b96a59ea17dde570bdd9bc3b9de17f83f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 11,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0908d01954e737bb7309941f5a6eaff930ba4f30/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0908d01954e737bb7309941f5a6eaff930ba4f30/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0908d01954e737bb7309941f5a6eaff930ba4f30",
        "patch": "@@ -4174,31 +4174,44 @@ void CChainState::LoadExternalBlockFile(FILE* fileIn, FlatFilePos* dbp)\n                     continue;\n             } catch (const std::exception&) {\n                 // no valid block header found; don't complain\n+                // (this happens at the end of every blk.dat file)\n                 break;\n             }\n             try {\n-                // read block\n+                // read block header\n                 uint64_t nBlockPos = blkdat.GetPos();\n                 if (dbp)\n                     dbp->nPos = nBlockPos;\n                 blkdat.SetLimit(nBlockPos + nSize);\n-                std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n-                CBlock& block = *pblock;\n-                blkdat >> block;\n-                nRewind = blkdat.GetPos();\n+                CBlockHeader header;\n+                blkdat >> header;\n \n-                uint256 hash = block.GetHash();\n+                // Read the rest of the block (from the end of its header to the end\n+                // of the block) to ensure it's in memory while holding cs_main (below).\n+                blkdat.Skip(nBlockPos + nSize - blkdat.GetPos());\n+\n+                const uint256 hash = header.GetHash();\n                 {\n                     LOCK(cs_main);\n-                    // detect out of order blocks, and store them for later\n-                    if (hash != m_params.GetConsensus().hashGenesisBlock && !m_blockman.LookupBlockIndex(block.hashPrevBlock)) {\n+                    // Store positions of out of order blocks for later.\n+                    if (hash != m_params.GetConsensus().hashGenesisBlock && !m_blockman.LookupBlockIndex(header.hashPrevBlock)) {\n                         LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n-                                block.hashPrevBlock.ToString());\n+                            header.hashPrevBlock.ToString());\n                         if (dbp)\n-                            mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n+                            mapBlocksUnknownParent.insert(std::make_pair(header.hashPrevBlock, *dbp));\n+\n+                        // Skip the rest of this block; position to the marker before the next block.\n+                        nRewind = nBlockPos + nSize;\n                         continue;\n                     }\n \n+                    // This block can be processed immediately; rewind to its start then read it.\n+                    blkdat.SetPos(nBlockPos);\n+                    std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n+                    CBlock& block = *pblock;\n+                    blkdat >> block;\n+                    nRewind = blkdat.GetPos();\n+\n                     // process in case the block isn't known yet\n                     CBlockIndex* pindex = m_blockman.LookupBlockIndex(hash);\n                     if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n@@ -4256,7 +4269,8 @@ void CChainState::LoadExternalBlockFile(FILE* fileIn, FlatFilePos* dbp)\n     } catch (const std::runtime_error& e) {\n         AbortNode(std::string(\"System error: \") + e.what());\n     }\n-    LogPrintf(\"Loaded %i blocks from external file in %dms\\n\", nLoaded, GetTimeMillis() - nStart);\n+    LogPrintf(\"Loaded %i blocks in %dms pending %i\\n\",\n+              nLoaded, GetTimeMillis() - nStart, mapBlocksUnknownParent.size());\n }\n \n void CChainState::CheckBlockIndex()"
      },
      {
        "sha": "54deddee654d04f7d4a5ed5ea866b61d57a405cb",
        "filename": "test/functional/feature_reindex.py",
        "status": "modified",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0908d01954e737bb7309941f5a6eaff930ba4f30/test/functional/feature_reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0908d01954e737bb7309941f5a6eaff930ba4f30/test/functional/feature_reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_reindex.py?ref=0908d01954e737bb7309941f5a6eaff930ba4f30",
        "patch": "@@ -7,8 +7,10 @@\n - Start a single node and generate 3 blocks.\n - Stop the node and restart it with -reindex. Verify that the node has reindexed up to block 3.\n - Stop the node and restart it with -reindex-chainstate. Verify that the node has reindexed up to block 3.\n+- Verify that out-of-order blocks are correctly processed, see LoadExternalBlockFile()\n \"\"\"\n \n+import os\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n@@ -27,11 +29,51 @@ def reindex(self, justchainstate=False):\n         assert_equal(self.nodes[0].getblockcount(), blockcount)  # start_node is blocking on reindex\n         self.log.info(\"Success\")\n \n+    # Check that blocks can be processed out of order\n+    def out_of_order(self):\n+        # The previous test created 12 blocks\n+        assert_equal(self.nodes[0].getblockcount(), 12)\n+        self.stop_nodes()\n+\n+        # In this test environment, blocks will always be in order (since\n+        # we're generating them rather than getting them from peers), so to\n+        # test out-of-order handling, swap blocks 1 and 2 on disk.\n+        blk0 = os.path.join(self.nodes[0].datadir, self.nodes[0].chain, 'blocks', 'blk00000.dat')\n+        with open(blk0, 'r+b') as bf:\n+            b = bf.read(814)\n+\n+            # This is really just checking the test; blocks in the blk.dat\n+            # files are preceded by 4 marker bytes (see pchMessageStart[]),\n+            # the first of which is 0xfa for regtest. In this test, there are\n+            # four blocks. These byte offsets are unlikely ever to change.\n+            assert_equal(b[0], 0xfa)\n+            assert_equal(b[293], 0xfa)\n+            assert_equal(b[553], 0xfa)\n+            assert_equal(b[813], 0xfa)\n+\n+            # Swap the same-size second and third blocks (don't change genesis).\n+            bf.seek(293)\n+            bf.write(b[553:813])\n+            bf.write(b[293:553])\n+\n+        with self.nodes[0].assert_debug_log([\n+            'LoadExternalBlockFile: Out of order block',\n+            'LoadExternalBlockFile: Processing out of order child',\n+        ]):\n+            extra_args = [[\"-reindex\"]]\n+            self.start_nodes(extra_args)\n+\n+        # All blocks should be accepted and processed.\n+        assert_equal(self.nodes[0].getblockcount(), 12)\n+\n     def run_test(self):\n         self.reindex(False)\n         self.reindex(True)\n         self.reindex(False)\n         self.reindex(True)\n \n+        self.out_of_order()\n+\n+\n if __name__ == '__main__':\n     ReindexTest().main()"
      }
    ]
  },
  {
    "sha": "f8f9ba31f3bc927c0295dac342b77e655129a616",
    "node_id": "C_kwDOABII59oAKGY4ZjliYTMxZjNiYzkyN2MwMjk1ZGFjMzQyYjc3ZTY1NTEyOWE2MTY",
    "commit": {
      "author": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2020-08-24T04:29:00Z"
      },
      "committer": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2021-11-20T17:06:52Z"
      },
      "message": "reindex: don't deserialize block if already in index\n\nDeserializing only the block header is sufficient to\ndetermine if the block already exists in the block index.\nThis is only a (further) performance improvement.",
      "tree": {
        "sha": "4ec2801a5c42ffc9139af681eef1438513381dd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ec2801a5c42ffc9139af681eef1438513381dd5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8f9ba31f3bc927c0295dac342b77e655129a616",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8f9ba31f3bc927c0295dac342b77e655129a616",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8f9ba31f3bc927c0295dac342b77e655129a616",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8f9ba31f3bc927c0295dac342b77e655129a616/comments",
    "author": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0908d01954e737bb7309941f5a6eaff930ba4f30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0908d01954e737bb7309941f5a6eaff930ba4f30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0908d01954e737bb7309941f5a6eaff930ba4f30"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 14,
      "deletions": 14
    },
    "files": [
      {
        "sha": "d243cc38f80be3f1ad1c6c6989ed5010e0411b77",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8f9ba31f3bc927c0295dac342b77e655129a616/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8f9ba31f3bc927c0295dac342b77e655129a616/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f8f9ba31f3bc927c0295dac342b77e655129a616",
        "patch": "@@ -4205,23 +4205,23 @@ void CChainState::LoadExternalBlockFile(FILE* fileIn, FlatFilePos* dbp)\n                         continue;\n                     }\n \n-                    // This block can be processed immediately; rewind to its start then read it.\n-                    blkdat.SetPos(nBlockPos);\n-                    std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n-                    CBlock& block = *pblock;\n-                    blkdat >> block;\n-                    nRewind = blkdat.GetPos();\n-\n                     // process in case the block isn't known yet\n                     CBlockIndex* pindex = m_blockman.LookupBlockIndex(hash);\n                     if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n-                      BlockValidationState state;\n-                      if (AcceptBlock(pblock, state, nullptr, true, dbp, nullptr)) {\n-                          nLoaded++;\n-                      }\n-                      if (state.IsError()) {\n-                          break;\n-                      }\n+                        // This block can be processed immediately; rewind to its start then read it.\n+                        blkdat.SetPos(nBlockPos);\n+                        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n+                        CBlock& block = *pblock;\n+                        blkdat >> block;\n+                        nRewind = blkdat.GetPos();\n+\n+                        BlockValidationState state;\n+                        if (AcceptBlock(pblock, state, nullptr, true, dbp, nullptr)) {\n+                            nLoaded++;\n+                        }\n+                        if (state.IsError()) {\n+                            break;\n+                        }\n                     } else if (hash != m_params.GetConsensus().hashGenesisBlock && pindex->nHeight % 1000 == 0) {\n                         LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), pindex->nHeight);\n                     }"
      }
    ]
  }
]