[
  {
    "sha": "eaca9bb7e69819012196c93a8e4a506a17f4400c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYWNhOWJiN2U2OTgxOTAxMjE5NmM5M2E4ZTRhNTA2YTE3ZjQ0MDBj",
    "commit": {
      "author": {
        "name": "lachlangreenbank",
        "email": "lachlan.greenbank@gmail.com",
        "date": "2018-04-06T02:09:28Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2018-04-06T02:09:28Z"
      },
      "message": "Comment cleanup and consistency",
      "tree": {
        "sha": "ced9b15876c2d9cf1f8b59df5225acc2d02bd5a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ced9b15876c2d9cf1f8b59df5225acc2d02bd5a1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eaca9bb7e69819012196c93a8e4a506a17f4400c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaxtbYCRBK7hj4Ov3rIwAAdHIIAKbCgANle440j56/v/FHT3Pf\n/st/ohAbuVx23zjIOfXcNh+FrcJBlwuS+5u9vK+CNUBqd1zlib7ZJcSzGzoxLNjl\nRNAKwjL2taspOajZ6zveZoK7qOJl1SkYYzzmvGrmq2F70p1knc+Tal7uOx7nsKVE\nXBAh9YHssxzboXFl0RyqRCawCeDliFook6/YhSd7JwbhAoM4H+pIBDAhey+Jt+kJ\nA8i2L9QYH2x05GMPWVVPBiwti+XQaFTxyhYR6NCqIo0nnBCPYLwbmrPtW0s5vi61\nya/Z/cyj+TGr3gVcyqDEdVGbZhZfMITOHK1S++HW2xxnbOgsJ6OdaeLINmCD7I8=\n=eWDv\n-----END PGP SIGNATURE-----\n",
        "payload": "tree ced9b15876c2d9cf1f8b59df5225acc2d02bd5a1\nparent 5f0c6a7b0e47e03f848dc992d37fe209dd9c6975\nauthor lachlangreenbank <lachlan.greenbank@gmail.com> 1522980568 +1000\ncommitter GitHub <noreply@github.com> 1522980568 +1000\n\nComment cleanup and consistency"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaca9bb7e69819012196c93a8e4a506a17f4400c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eaca9bb7e69819012196c93a8e4a506a17f4400c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaca9bb7e69819012196c93a8e4a506a17f4400c/comments",
    "author": {
      "login": "lachlangreenbank",
      "id": 16291813,
      "node_id": "MDQ6VXNlcjE2MjkxODEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/16291813?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lachlangreenbank",
      "html_url": "https://github.com/lachlangreenbank",
      "followers_url": "https://api.github.com/users/lachlangreenbank/followers",
      "following_url": "https://api.github.com/users/lachlangreenbank/following{/other_user}",
      "gists_url": "https://api.github.com/users/lachlangreenbank/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lachlangreenbank/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lachlangreenbank/subscriptions",
      "organizations_url": "https://api.github.com/users/lachlangreenbank/orgs",
      "repos_url": "https://api.github.com/users/lachlangreenbank/repos",
      "events_url": "https://api.github.com/users/lachlangreenbank/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lachlangreenbank/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5f0c6a7b0e47e03f848dc992d37fe209dd9c6975",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5f0c6a7b0e47e03f848dc992d37fe209dd9c6975",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5f0c6a7b0e47e03f848dc992d37fe209dd9c6975"
      }
    ],
    "stats": {
      "total": 99,
      "additions": 50,
      "deletions": 49
    },
    "files": [
      {
        "sha": "e3b165ce2d34faffa61e27bd433c6accd4dd81b6",
        "filename": "src/bech32.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 49,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eaca9bb7e69819012196c93a8e4a506a17f4400c/src/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eaca9bb7e69819012196c93a8e4a506a17f4400c/src/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.cpp?ref=eaca9bb7e69819012196c93a8e4a506a17f4400c",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2017 Pieter Wuille\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/** Copyright (c) 2017 Pieter Wuille\n+ * Distributed under the MIT software license, see the accompanying\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php. */\n \n #include <bech32.h>\n \n@@ -36,54 +36,55 @@ data Cat(data x, const data& y)\n  *  bits correspond to earlier values. */\n uint32_t PolyMod(const data& v)\n {\n-    // The input is interpreted as a list of coefficients of a polynomial over F = GF(32), with an\n-    // implicit 1 in front. If the input is [v0,v1,v2,v3,v4], that polynomial is v(x) =\n-    // 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4. The implicit 1 guarantees that\n-    // [v0,v1,v2,...] has a distinct checksum from [0,v0,v1,v2,...].\n-\n-    // The output is a 30-bit integer whose 5-bit groups are the coefficients of the remainder of\n-    // v(x) mod g(x), where g(x) is the Bech32 generator,\n-    // x^6 + {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}. g(x) is chosen in such a way\n-    // that the resulting code is a BCH code, guaranteeing detection of up to 3 errors within a\n-    // window of 1023 characters. Among the various possible BCH codes, one was selected to in\n-    // fact guarantee detection of up to 4 errors within a window of 89 characters.\n-\n-    // Note that the coefficients are elements of GF(32), here represented as decimal numbers\n-    // between {}. In this finite field, addition is just XOR of the corresponding numbers. For\n-    // example, {27} + {13} = {27 ^ 13} = {22}. Multiplication is more complicated, and requires\n-    // treating the bits of values themselves as coefficients of a polynomial over a smaller field,\n-    // GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example, {5} * {26} =\n-    // (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 + a^3 + a) = a^6 + a^5 + a^4 + a\n-    // = a^3 + 1 (mod a^5 + a^3 + 1) = {9}.\n-\n-    // During the course of the loop below, `c` contains the bitpacked coefficients of the\n-    // polynomial constructed from just the values of v that were processed so far, mod g(x). In\n-    // the above example, `c` initially corresponds to 1 mod (x), and after processing 2 inputs of\n-    // v, it corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the starting value\n-    // for `c`.\n+   /** The input is interpreted as a list of coefficients of a polynomial over F = GF(32), with an\n+    *  implicit 1 in front. If the input is [v0,v1,v2,v3,v4], that polynomial is v(x) =\n+    *  1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4. The implicit 1 guarantees that\n+    *  [v0,v1,v2,...] has a distinct checksum from [0,v0,v1,v2,...].\n+\n+    *  The output is a 30-bit integer whose 5-bit groups are the coefficients of the remainder of\n+    *  v(x) mod g(x), where g(x) is the Bech32 generator,\n+    *  x^6 + {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}. g(x) is chosen in such a way\n+    *  that the resulting code is a BCH code, guaranteeing detection of up to 3 errors within a\n+    *  window of 1023 characters. Among the various possible BCH codes, one was selected to in\n+    *  fact guarantee detection of up to 4 errors within a window of 89 characters.\n+\n+    *  Note that the coefficients are elements of GF(32), here represented as decimal numbers\n+    *  between {}. In this finite field, addition is just XOR of the corresponding numbers. For\n+    *  example, {27} + {13} = {27 ^ 13} = {22}. Multiplication is more complicated, and requires\n+    *  treating the bits of values themselves as coefficients of a polynomial over a smaller field,\n+    *  GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example, {5} * {26} =\n+    *  (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 + a^3 + a) = a^6 + a^5 + a^4 + a\n+    *  = a^3 + 1 (mod a^5 + a^3 + 1) = {9}.\n+\n+    *  During the course of the loop below, `c` contains the bitpacked coefficients of the\n+    *  polynomial constructed from just the values of v that were processed so far, mod g(x). In\n+    *  the above example, `c` initially corresponds to 1 mod (x), and after processing 2 inputs of\n+    *  v, it corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the starting value\n+    *  for `c`. */\n+\n     uint32_t c = 1;\n     for (auto v_i : v) {\n-        // We want to update `c` to correspond to a polynomial with one extra term. If the initial\n-        // value of `c` consists of the coefficients of c(x) = f(x) mod g(x), we modify it to\n-        // correspond to c'(x) = (f(x) * x + v_i) mod g(x), where v_i is the next input to\n-        // process. Simplifying:\n-        // c'(x) = (f(x) * x + v_i) mod g(x)\n-        //         ((f(x) mod g(x)) * x + v_i) mod g(x)\n-        //         (c(x) * x + v_i) mod g(x)\n-        // If c(x) = c0*x^5 + c1*x^4 + c2*x^3 + c3*x^2 + c4*x + c5, we want to compute\n-        // c'(x) = (c0*x^5 + c1*x^4 + c2*x^3 + c3*x^2 + c4*x + c5) * x + v_i mod g(x)\n-        //       = c0*x^6 + c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i mod g(x)\n-        //       = c0*(x^6 mod g(x)) + c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i\n-        // If we call (x^6 mod g(x)) = k(x), this can be written as\n-        // c'(x) = (c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i) + c0*k(x)\n-\n-        // First, determine the value of c0:\n+       /** We want to update `c` to correspond to a polynomial with one extra term. If the initial\n+        *  value of `c` consists of the coefficients of c(x) = f(x) mod g(x), we modify it to\n+        *  correspond to c'(x) = (f(x) * x + v_i) mod g(x), where v_i is the next input to\n+        *  process. Simplifying:\n+        *  c'(x) = (f(x) * x + v_i) mod g(x)\n+        *          ((f(x) mod g(x)) * x + v_i) mod g(x)\n+        *          (c(x) * x + v_i) mod g(x)\n+        *  If c(x) = c0*x^5 + c1*x^4 + c2*x^3 + c3*x^2 + c4*x + c5, we want to compute\n+        *  c'(x) = (c0*x^5 + c1*x^4 + c2*x^3 + c3*x^2 + c4*x + c5) * x + v_i mod g(x)\n+        *        = c0*x^6 + c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i mod g(x)\n+        *        = c0*(x^6 mod g(x)) + c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i\n+        *  If we call (x^6 mod g(x)) = k(x), this can be written as\n+        *  c'(x) = (c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i) + c0*k(x) */\n+\n+        /** First, determine the value of c0: */\n         uint8_t c0 = c >> 25;\n \n-        // Then compute c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i:\n+        /** Then compute c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i: */\n         c = ((c & 0x1ffffff) << 5) ^ v_i;\n \n-        // Finally, for each set bit n in c0, conditionally add {2^n}k(x):\n+        /** Finally, for each set bit n in c0, conditionally add {2^n}k(x): */\n         if (c0 & 1)  c ^= 0x3b6a57b2; //     k(x) = {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}\n         if (c0 & 2)  c ^= 0x26508e6d; //  {2}k(x) = {19}x^5 +  {5}x^4 +     x^3 +  {3}x^2 + {19}x + {13}\n         if (c0 & 4)  c ^= 0x1ea119fa; //  {4}k(x) = {15}x^5 + {10}x^4 +  {2}x^3 +  {6}x^2 + {15}x + {26}\n@@ -117,10 +118,10 @@ data ExpandHRP(const std::string& hrp)\n /** Verify a checksum. */\n bool VerifyChecksum(const std::string& hrp, const data& values)\n {\n-    // PolyMod computes what value to xor into the final values to make the checksum 0. However,\n-    // if we required that the checksum was 0, it would be the case that appending a 0 to a valid\n-    // list of values would result in a new valid list. For that reason, Bech32 requires the\n-    // resulting checksum to be 1 instead.\n+   /** PolyMod computes what value to xor into the final values to make the checksum 0. However,\n+     * if we required that the checksum was 0, it would be the case that appending a 0 to a valid\n+     * list of values would result in a new valid list. For that reason, Bech32 requires the\n+     * resulting checksum to be 1 instead. */\n     return PolyMod(Cat(ExpandHRP(hrp), values)) == 1;\n }\n "
      }
    ]
  }
]