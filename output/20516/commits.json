[
  {
    "sha": "8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Y2Q4ZjM3ZGZlM2ZmYjczYTA5ZjNhZDc3MzYwM2Q5ZDg5NDUyMjQ1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-11-27T00:46:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-05-25T01:06:31Z"
      },
      "message": "Introduce well-defined CAddress disk serialization\n\nBefore this commit, CAddress disk serialization was messy. It stored\nCLIENT_VERSION in the first 4 bytes, optionally OR'ed with ADDRV2_FORMAT.\n - All bits except ADDRV2_FORMAT were ignored, making it hard to use for actual\n   future format changes.\n - ADDRV2_FORMAT determines whether or not nServices is serialized in LE64\n   format or in CompactSize format.\n - Whether or not the embedded CService is serialized in V1 or V2 format is\n   determined by the stream's version having ADDRV2_FORMAT (as opposed to the\n   nServices encoding, which is determined by the disk version).\n\nTo improve the situation, this commit introduces the following disk\nserialization format, compatible with earlier versions, but better defined for\nfuture changes:\n - The first 4 bytes store a format version number. Its low 19 bits are ignored\n   (as it historically stored the CLIENT_VERSION), but its high 13 bits specify\n   the serialization exactly:\n   - 0x00000000: LE64 encoding for nServices, V1 encoding for CService\n   - 0x20000000: CompactSize encoding for nServices, V2 encoding for CService\n   - Any other value triggers an unsupported format error on deserialization,\n     and can be used for future format changes.\n - The ADDRV2_FORMAT flag in the stream's version does not impact the actual\n   serialization format; it only determines whether V2 encoding is permitted;\n   whether it's actually enabled depends solely on the disk version number.\n\nOperationally the changes to the deserializer are:\n - Failure when the stored format version number is unexpected.\n - The embedded CService's format is determined by the stored format version\n   number rather than the stream's version number.\n\nThese do no introduce incompatibilities, as no code versions exist that write\nany value other than 0 or 0x20000000 in the top 13 bits, and no code paths\nwhere the stream's version differs from the stored version.",
      "tree": {
        "sha": "815e6a873753f17cf6a7e7bdad563d4ef220ed52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/815e6a873753f17cf6a7e7bdad563d4ef220ed52"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cd8f37dfe3ffb73a09f3ad773603d9d89452245/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b295395664bd37e26d168c329f238237b34aef8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b295395664bd37e26d168c329f238237b34aef8c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b295395664bd37e26d168c329f238237b34aef8c"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 65,
      "deletions": 11
    },
    "files": [
      {
        "sha": "251b8892cf30b7f01955f926cb2c8d6b509f7f88",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 65,
        "deletions": 11,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cd8f37dfe3ffb73a09f3ad773603d9d89452245/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cd8f37dfe3ffb73a09f3ad773603d9d89452245/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
        "patch": "@@ -13,6 +13,7 @@\n #include <netaddress.h>\n #include <primitives/transaction.h>\n #include <serialize.h>\n+#include <streams.h>\n #include <uint256.h>\n #include <version.h>\n \n@@ -358,42 +359,95 @@ class CAddress : public CService\n {\n     static constexpr uint32_t TIME_INIT{100000000};\n \n+    /** Historically, CAddress disk serialization stored the CLIENT_VERSION, optionally OR'ed with\n+     *  the ADDRV2_FORMAT flag to indicate V2 serialization. The first field has since been\n+     *  disentangled from client versioning, and now instead:\n+     *  - The low bits (masked by DISK_VERSION_IGNORE_MASK) store the fixed value DISK_VERSION_INIT,\n+     *    (in case any code exists that treats it as a client version) but are ignored on\n+     *    deserialization.\n+     *  - The high bits (masked by ~DISK_VERSION_IGNORE_MASK) store actual serialization information.\n+     *    Only 0 or DISK_VERSION_ADDRV2 (equal to the historical ADDRV2_FORMAT) are valid now, and\n+     *    any other value triggers a deserialization failure. Other values can be added later if\n+     *    needed.\n+     *\n+     *  For disk deserialization, ADDRV2_FORMAT in the stream version signals that ADDRV2\n+     *  deserialization is permitted, but the actual format is determined by the high bits in the\n+     *  stored version field. For network serialization, the stream version having ADDRV2_FORMAT or\n+     *  not determines the actual format used (as it has no embedded version number).\n+     */\n+    static constexpr uint32_t DISK_VERSION_INIT{220000};\n+    static constexpr uint32_t DISK_VERSION_IGNORE_MASK{0b00000000'00000111'11111111'11111111};\n+    /** The version number written in disk serialized addresses to indicate V2 serializations.\n+     * It must be exactly 1<<29, as that is the value that historical versions used for this\n+     * (they used their internal ADDRV2_FORMAT flag here). */\n+    static constexpr uint32_t DISK_VERSION_ADDRV2{1 << 29};\n+    static_assert((DISK_VERSION_INIT & ~DISK_VERSION_IGNORE_MASK) == 0, \"DISK_VERSION_INIT must be covered by DISK_VERSION_IGNORE_MASK\");\n+    static_assert((DISK_VERSION_ADDRV2 & DISK_VERSION_IGNORE_MASK) == 0, \"DISK_VERSION_ADDRV2 must not be covered by DISK_VERSION_IGNORE_MASK\");\n+\n public:\n     CAddress() : CService{} {};\n     CAddress(CService ipIn, ServiceFlags nServicesIn) : CService{ipIn}, nServices{nServicesIn} {};\n     CAddress(CService ipIn, ServiceFlags nServicesIn, uint32_t nTimeIn) : CService{ipIn}, nTime{nTimeIn}, nServices{nServicesIn} {};\n \n     SERIALIZE_METHODS(CAddress, obj)\n     {\n-        SER_READ(obj, obj.nTime = TIME_INIT);\n-        int nVersion = s.GetVersion();\n+        // CAddress has a distinct network serialization and a disk serialization, but it should never\n+        // be hashed (except through CHashWriter in addrdb.cpp, which sets SER_DISK), and it's\n+        // ambiguous what that would mean. Make sure no code relying on that is introduced:\n+        assert(!(s.GetType() & SER_GETHASH));\n+        bool use_v2;\n+        bool store_time;\n         if (s.GetType() & SER_DISK) {\n-            READWRITE(nVersion);\n-        }\n-        if ((s.GetType() & SER_DISK) ||\n-            (nVersion != INIT_PROTO_VERSION && !(s.GetType() & SER_GETHASH))) {\n+            // In the disk serialization format, the encoding (v1 or v2) is determined by a flag version\n+            // that's part of the serialization itself. ADDRV2_FORMAT in the stream version only determines\n+            // whether V2 is chosen/permitted at all.\n+            uint32_t stored_format_version = DISK_VERSION_INIT;\n+            if (s.GetVersion() & ADDRV2_FORMAT) stored_format_version |= DISK_VERSION_ADDRV2;\n+            READWRITE(stored_format_version);\n+            stored_format_version &= ~DISK_VERSION_IGNORE_MASK; // ignore low bits\n+            if (stored_format_version == 0) {\n+                use_v2 = false;\n+            } else if (stored_format_version == DISK_VERSION_ADDRV2 && (s.GetVersion() & ADDRV2_FORMAT)) {\n+                // Only support v2 deserialization if ADDRV2_FORMAT is set.\n+                use_v2 = true;\n+            } else {\n+                throw std::ios_base::failure(\"Unsupported CAddress disk format version\");\n+            }\n+            store_time = true;\n+        } else {\n+            // In the network serialization format, the encoding (v1 or v2) is determined directly by\n+            // the value of ADDRV2_FORMAT in the stream version, as no explicitly encoded version\n+            // exists in the stream.\n+            assert(s.GetType() & SER_NETWORK);\n+            use_v2 = s.GetVersion() & ADDRV2_FORMAT;\n             // The only time we serialize a CAddress object without nTime is in\n             // the initial VERSION messages which contain two CAddress records.\n             // At that point, the serialization version is INIT_PROTO_VERSION.\n             // After the version handshake, serialization version is >=\n             // MIN_PEER_PROTO_VERSION and all ADDR messages are serialized with\n             // nTime.\n-            READWRITE(obj.nTime);\n+            store_time = s.GetVersion() != INIT_PROTO_VERSION;\n         }\n-        if (nVersion & ADDRV2_FORMAT) {\n+\n+        SER_READ(obj, obj.nTime = TIME_INIT);\n+        if (store_time) READWRITE(obj.nTime);\n+        // nServices is serialized as CompactSize in V2; as uint64_t in V1.\n+        if (use_v2) {\n             uint64_t services_tmp;\n             SER_WRITE(obj, services_tmp = obj.nServices);\n             READWRITE(Using<CompactSizeFormatter<false>>(services_tmp));\n             SER_READ(obj, obj.nServices = static_cast<ServiceFlags>(services_tmp));\n         } else {\n             READWRITE(Using<CustomUintFormatter<8>>(obj.nServices));\n         }\n-        READWRITEAS(CService, obj);\n+        // Invoke V1/V2 serializer for CService parent object.\n+        OverrideStream<Stream> os(&s, s.GetType(), use_v2 ? ADDRV2_FORMAT : 0);\n+        SerReadWriteMany(os, ser_action, ReadWriteAsHelper<CService>(obj));\n     }\n \n-    // disk and network only\n+    //! Always included in serialization, except in the network format on INIT_PROTO_VERSION.\n     uint32_t nTime{TIME_INIT};\n-\n+    //! Serialized as uint64_t in V1, and as CompactSize in V2.\n     ServiceFlags nServices{NODE_NONE};\n };\n "
      }
    ]
  },
  {
    "sha": "e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMmYwNTQ4YjUyYTRiMmJhM2VkZjc3ZTNmMjEzNjVmMWU4ZjI3MGE0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-11-26T21:59:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-05-25T01:06:35Z"
      },
      "message": "Use addrv2 serialization in anchors.dat",
      "tree": {
        "sha": "843fc16fb0c2747f03c2adf17bc6c7151b1bd9bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/843fc16fb0c2747f03c2adf17bc6c7151b1bd9bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cd8f37dfe3ffb73a09f3ad773603d9d89452245",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8cd8f37dfe3ffb73a09f3ad773603d9d89452245"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "bf2f6c7614ef9a11ec794ea3e5ff245a7ca221c8",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
        "patch": "@@ -23,7 +23,7 @@ bool SerializeDB(Stream& stream, const Data& data)\n {\n     // Write and commit header, data\n     try {\n-        CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n+        CHashWriter hasher(stream.GetType(), stream.GetVersion());\n         stream << Params().MessageStart() << data;\n         hasher << Params().MessageStart() << data;\n         stream << hasher.GetHash();\n@@ -35,7 +35,7 @@ bool SerializeDB(Stream& stream, const Data& data)\n }\n \n template <typename Data>\n-bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)\n+bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data, int version)\n {\n     // Generate random temporary filename\n     uint16_t randv = 0;\n@@ -45,7 +45,7 @@ bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data\n     // open temp output file, and associate with CAutoFile\n     fs::path pathTmp = gArgs.GetDataDirNet() / tmpfn;\n     FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n-    CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n+    CAutoFile fileout(file, SER_DISK, version);\n     if (fileout.IsNull()) {\n         fileout.fclose();\n         remove(pathTmp);\n@@ -106,11 +106,11 @@ bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n }\n \n template <typename Data>\n-bool DeserializeFileDB(const fs::path& path, Data& data)\n+bool DeserializeFileDB(const fs::path& path, Data& data, int version)\n {\n     // open input file, and associate with CAutoFile\n     FILE* file = fsbridge::fopen(path, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n+    CAutoFile filein(file, SER_DISK, version);\n     if (filein.IsNull()) {\n         LogPrintf(\"Missing or invalid file %s\\n\", path.string());\n         return false;\n@@ -125,12 +125,12 @@ CBanDB::CBanDB(fs::path ban_list_path) : m_ban_list_path(std::move(ban_list_path\n \n bool CBanDB::Write(const banmap_t& banSet)\n {\n-    return SerializeFileDB(\"banlist\", m_ban_list_path, banSet);\n+    return SerializeFileDB(\"banlist\", m_ban_list_path, banSet, CLIENT_VERSION);\n }\n \n bool CBanDB::Read(banmap_t& banSet)\n {\n-    return DeserializeFileDB(m_ban_list_path, banSet);\n+    return DeserializeFileDB(m_ban_list_path, banSet, CLIENT_VERSION);\n }\n \n CAddrDB::CAddrDB()\n@@ -140,12 +140,12 @@ CAddrDB::CAddrDB()\n \n bool CAddrDB::Write(const CAddrMan& addr)\n {\n-    return SerializeFileDB(\"peers\", pathAddr, addr);\n+    return SerializeFileDB(\"peers\", pathAddr, addr, CLIENT_VERSION);\n }\n \n bool CAddrDB::Read(CAddrMan& addr)\n {\n-    return DeserializeFileDB(pathAddr, addr);\n+    return DeserializeFileDB(pathAddr, addr, CLIENT_VERSION);\n }\n \n bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n@@ -161,13 +161,13 @@ bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)\n {\n     LOG_TIME_SECONDS(strprintf(\"Flush %d outbound block-relay-only peer addresses to anchors.dat\", anchors.size()));\n-    SerializeFileDB(\"anchors\", anchors_db_path, anchors);\n+    SerializeFileDB(\"anchors\", anchors_db_path, anchors, CLIENT_VERSION | ADDRV2_FORMAT);\n }\n \n std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)\n {\n     std::vector<CAddress> anchors;\n-    if (DeserializeFileDB(anchors_db_path, anchors)) {\n+    if (DeserializeFileDB(anchors_db_path, anchors, CLIENT_VERSION | ADDRV2_FORMAT)) {\n         LogPrintf(\"Loaded %i addresses from %s\\n\", anchors.size(), anchors_db_path.filename());\n     } else {\n         anchors.clear();"
      }
    ]
  },
  {
    "sha": "f8866e8c324be3322fa507c2ceb1de35d148d0f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmODg2NmU4YzMyNGJlMzMyMmZhNTA3YzJjZWIxZGUzNWQxNDhkMGYx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-11-27T02:13:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-05-25T01:06:35Z"
      },
      "message": "Add roundtrip fuzz tests for CAddress serialization",
      "tree": {
        "sha": "577779ec6abb8acafa18bc3d111d49b094315cdb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/577779ec6abb8acafa18bc3d111d49b094315cdb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8866e8c324be3322fa507c2ceb1de35d148d0f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8866e8c324be3322fa507c2ceb1de35d148d0f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8866e8c324be3322fa507c2ceb1de35d148d0f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8866e8c324be3322fa507c2ceb1de35d148d0f1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e2f0548b52a4b2ba3edf77e3f21365f1e8f270a4"
      }
    ],
    "stats": {
      "total": 51,
      "additions": 43,
      "deletions": 8
    },
    "files": [
      {
        "sha": "f9248899dc5e8fba30c7f1d0832501cd3c9aa2c8",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8866e8c324be3322fa507c2ceb1de35d148d0f1/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8866e8c324be3322fa507c2ceb1de35d148d0f1/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=f8866e8c324be3322fa507c2ceb1de35d148d0f1",
        "patch": "@@ -449,6 +449,13 @@ class CAddress : public CService\n     uint32_t nTime{TIME_INIT};\n     //! Serialized as uint64_t in V1, and as CompactSize in V2.\n     ServiceFlags nServices{NODE_NONE};\n+\n+    friend bool operator==(const CAddress& a, const CAddress& b)\n+    {\n+        return a.nTime == b.nTime &&\n+               a.nServices == b.nServices &&\n+               static_cast<const CService&>(a) == static_cast<const CService&>(b);\n+    }\n };\n \n /** getdata message type flags */"
      },
      {
        "sha": "decfc2610cbde36bd83fb19f8862bbb6eabe7642",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 8,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8866e8c324be3322fa507c2ceb1de35d148d0f1/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8866e8c324be3322fa507c2ceb1de35d148d0f1/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=f8866e8c324be3322fa507c2ceb1de35d148d0f1",
        "patch": "@@ -53,9 +53,9 @@ struct invalid_fuzzing_input_exception : public std::exception {\n };\n \n template <typename T>\n-CDataStream Serialize(const T& obj, const int version = INIT_PROTO_VERSION)\n+CDataStream Serialize(const T& obj, const int version = INIT_PROTO_VERSION, const int ser_type = SER_NETWORK)\n {\n-    CDataStream ds(SER_NETWORK, version);\n+    CDataStream ds(ser_type, version);\n     ds << obj;\n     return ds;\n }\n@@ -69,9 +69,9 @@ T Deserialize(CDataStream ds)\n }\n \n template <typename T>\n-void DeserializeFromFuzzingInput(FuzzBufferType buffer, T& obj, const std::optional<int> protocol_version = std::nullopt)\n+void DeserializeFromFuzzingInput(FuzzBufferType buffer, T& obj, const std::optional<int> protocol_version = std::nullopt, const int ser_type = SER_NETWORK)\n {\n-    CDataStream ds(buffer, SER_NETWORK, INIT_PROTO_VERSION);\n+    CDataStream ds(buffer, ser_type, INIT_PROTO_VERSION);\n     if (protocol_version) {\n         ds.SetVersion(*protocol_version);\n     } else {\n@@ -92,9 +92,9 @@ void DeserializeFromFuzzingInput(FuzzBufferType buffer, T& obj, const std::optio\n }\n \n template <typename T>\n-void AssertEqualAfterSerializeDeserialize(const T& obj, const int version = INIT_PROTO_VERSION)\n+void AssertEqualAfterSerializeDeserialize(const T& obj, const int version = INIT_PROTO_VERSION, const int ser_type = SER_NETWORK)\n {\n-    assert(Deserialize<T>(Serialize(obj, version)) == obj);\n+    assert(Deserialize<T>(Serialize(obj, version, ser_type)) == obj);\n }\n \n } // namespace\n@@ -251,9 +251,37 @@ FUZZ_TARGET_DESERIALIZE(messageheader_deserialize, {\n         DeserializeFromFuzzingInput(buffer, mh);\n         (void)mh.IsCommandValid();\n })\n-FUZZ_TARGET_DESERIALIZE(address_deserialize, {\n+FUZZ_TARGET_DESERIALIZE(address_deserialize_v1_notime, {\n         CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a);\n+        DeserializeFromFuzzingInput(buffer, a, INIT_PROTO_VERSION);\n+        // A CAddress without nTime (as is expected under INIT_PROTO_VERSION) will roundtrip\n+        // in all 5 formats (with/without nTime, v1/v2, network/disk)\n+        AssertEqualAfterSerializeDeserialize(a, INIT_PROTO_VERSION);\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+})\n+FUZZ_TARGET_DESERIALIZE(address_deserialize_v1_withtime, {\n+        CAddress a;\n+        DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION);\n+        // A CAddress in V1 mode will roundtrip in all 4 formats that have nTime.\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+})\n+FUZZ_TARGET_DESERIALIZE(address_deserialize_v2, {\n+        CAddress a;\n+        DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+        // A CAddress in V2 mode will roundtrip in both V2 formats, and also in the V1 formats\n+        // with time if it's V1 compatible.\n+        if (a.IsAddrV1Compatible()) {\n+            AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+            AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+        }\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(inv_deserialize, {\n         CInv i;"
      }
    ]
  }
]