[
  {
    "sha": "086b7c85e2bee50eb2055214a48ce41a2345eed5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowODZiN2M4NWUyYmVlNTBlYjIwNTUyMTRhNDhjZTQxYTIzNDVlZWQ1",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@monetize.io",
        "date": "2014-08-14T11:54:05Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-02T14:28:30Z"
      },
      "message": "Rename script.h/.cpp to scriptutils.h/.cpp (plus remove duplicated includes)",
      "tree": {
        "sha": "9198ea3231a49684508c7c1a9a65bd32e958cc9b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9198ea3231a49684508c7c1a9a65bd32e958cc9b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/086b7c85e2bee50eb2055214a48ce41a2345eed5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/086b7c85e2bee50eb2055214a48ce41a2345eed5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/086b7c85e2bee50eb2055214a48ce41a2345eed5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/086b7c85e2bee50eb2055214a48ce41a2345eed5/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8d92236f61699846f67d8ce6cb55458a46f9de1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8d92236f61699846f67d8ce6cb55458a46f9de1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8d92236f61699846f67d8ce6cb55458a46f9de1"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 25,
      "deletions": 29
    },
    "files": [
      {
        "sha": "e6fc1fdbefaf45d7578668f54583b1d056419c69",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -98,7 +98,7 @@ BITCOIN_CORE_H = \\\n   rpcclient.h \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n-  script.h \\\n+  scriptutils.h \\\n   serialize.h \\\n   sync.h \\\n   threadsafety.h \\\n@@ -206,7 +206,7 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n-  script.cpp \\\n+  scriptutils.cpp \\\n   $(BITCOIN_CORE_H)\n \n # util: shared between all executables."
      },
      {
        "sha": "a4dc7267670b0a0b43798ed3f5827fc6fb54a546",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -16,7 +16,7 @@\n \n #include \"chainparams.h\"\n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <string>\n #include <vector>"
      },
      {
        "sha": "07990beb15e76050f3323c7f0b189abf445226f6",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -5,7 +5,7 @@\n #include \"bloom.h\"\n \n #include \"core.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <math.h>\n #include <stdlib.h>"
      },
      {
        "sha": "62342d270232c92919008724db13bb4f00a18fce",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -6,7 +6,7 @@\n #ifndef BITCOIN_CORE_H\n #define BITCOIN_CORE_H\n \n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n "
      },
      {
        "sha": "41d8d6b492704642331d36d45d88a56562abcc47",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -5,7 +5,7 @@\n #include \"core_io.h\"\n #include \"core.h\"\n #include \"serialize.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n \n #include <boost/assign/list_of.hpp>"
      },
      {
        "sha": "e816611809aa4050400af5220fb3319c2f1d095c",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -4,7 +4,7 @@\n \n #include \"core_io.h\"\n #include \"univalue/univalue.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"core.h\"\n #include \"serialize.h\"\n #include \"util.h\""
      },
      {
        "sha": "ac5c8952e6383bd9dd81ad2448f77af2eff5b975",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -4,7 +4,7 @@\n \n #include \"crypter.h\"\n \n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n \n #include <string>"
      },
      {
        "sha": "e273bbb1de96abd682a7f1dd39f19535da0d3e08",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -7,7 +7,7 @@\n \n #include \"crypter.h\"\n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>"
      },
      {
        "sha": "0b13ef8eb0fe405e133f161a3fd290b44811e8f8",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -15,7 +15,7 @@\n #include \"core.h\"\n #include \"net.h\"\n #include \"pow.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"sync.h\"\n #include \"txmempool.h\"\n #include \"uint256.h\""
      },
      {
        "sha": "d1feeef17949d372a08a69966bc408cdb575b64d",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -11,7 +11,7 @@\n #include \"db.h\"\n #include \"main.h\"\n #include \"paymentserver.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"transactionrecord.h\"\n #include \"timedata.h\"\n #include \"ui_interface.h\""
      },
      {
        "sha": "b858d485ea8ea8bac9d97a673557e54335c897d2",
        "filename": "src/scriptutils.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"",
        "previous_filename": "src/script.cpp"
      },
      {
        "sha": "44f18483c38911ae82cba2dc2b3ff3844de04dda",
        "filename": "src/scriptutils.h",
        "status": "renamed",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef H_BITCOIN_SCRIPT\n-#define H_BITCOIN_SCRIPT\n+#ifndef H_BITCOIN_SCRIPTUTILS\n+#define H_BITCOIN_SCRIPTUTILS\n \n #include \"key.h\"\n #include \"utilstrencodings.h\"",
        "previous_filename": "src/script.h"
      },
      {
        "sha": "a1134258917bf374eafb2f16a7c3c45a19f20d46",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -12,7 +12,7 @@\n #include \"main.h\"\n #include \"net.h\"\n #include \"pow.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"serialize.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "0587ddac849368a13bea09e3e6389c599773988e",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -9,7 +9,7 @@\n #include \"data/base58_keys_valid.json.h\"\n \n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "2d2a600740106f4c489735874f51891be491fb56",
        "filename": "src/test/canonical_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/canonical_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/canonical_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/canonical_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -9,7 +9,7 @@\n #include \"data/sig_noncanonical.json.h\"\n #include \"data/sig_canonical.json.h\"\n #include \"random.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>"
      },
      {
        "sha": "c6bf0db3af3f3d9fe9f10e9cca8a61c20473f60c",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -5,7 +5,7 @@\n #include \"key.h\"\n \n #include \"base58.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "2e45a7a0229ceba9766595ff34489f757fda0b42",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -5,7 +5,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n \n #include <boost/assign/std/vector.hpp>"
      },
      {
        "sha": "d27fc71598619b08f634c4c04b7a6899d7b01067",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -2,12 +2,10 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"script.h\"\n-\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <vector>\n "
      },
      {
        "sha": "a8ccd5059804230c5babf6f808dc4590cb13440c",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -2,15 +2,13 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"script.h\"\n-\n #include \"data/script_invalid.json.h\"\n #include \"data/script_valid.json.h\"\n \n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"core_io.h\"\n \n #include <fstream>"
      },
      {
        "sha": "c3cd41cf84525137b731941e48c06ea566dc5933",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"bignum.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include <boost/test/unit_test.hpp>\n #include <limits.h>\n #include <stdint.h>"
      },
      {
        "sha": "53f4d443c4b436f71eca9011a11614ad7a4b786e",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -6,7 +6,7 @@\n #include \"main.h\"\n #include \"random.h\"\n #include \"serialize.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n #include \"version.h\"\n "
      },
      {
        "sha": "963ccf560d3ccbda36571817d851fb74cc001555",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n \n #include <vector>"
      },
      {
        "sha": "2b5161b0cf69c3a5ddcf949468cf6e62ffd1cbca",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/086b7c85e2bee50eb2055214a48ce41a2345eed5/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "patch": "@@ -8,7 +8,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"core_io.h\"\n \n #include <map>"
      }
    ]
  },
  {
    "sha": "3b64c914aea4c82e53fc1db92c05fc72cacb0924",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYjY0YzkxNGFlYTRjODJlNTNmYzFkYjkyYzA1ZmM3MmNhY2IwOTI0",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@monetize.io",
        "date": "2014-08-20T15:37:40Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-02T14:28:30Z"
      },
      "message": "Move CScript class and dependencies to script/script",
      "tree": {
        "sha": "28c9276f45d75d25a552c62a9aae28e81a4097cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28c9276f45d75d25a552c62a9aae28e81a4097cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3b64c914aea4c82e53fc1db92c05fc72cacb0924",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b64c914aea4c82e53fc1db92c05fc72cacb0924",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3b64c914aea4c82e53fc1db92c05fc72cacb0924",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b64c914aea4c82e53fc1db92c05fc72cacb0924/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/086b7c85e2bee50eb2055214a48ce41a2345eed5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/086b7c85e2bee50eb2055214a48ce41a2345eed5"
      }
    ],
    "stats": {
      "total": 1891,
      "additions": 957,
      "deletions": 934
    },
    "files": [
      {
        "sha": "a9f1ceeeba896809f39e85461aa99765ebd6fb2c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -98,6 +98,7 @@ BITCOIN_CORE_H = \\\n   rpcclient.h \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n+  script/script.h \\\n   scriptutils.h \\\n   serialize.h \\\n   sync.h \\\n@@ -206,6 +207,7 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n+  script/script.cpp \\\n   scriptutils.cpp \\\n   $(BITCOIN_CORE_H)\n "
      },
      {
        "sha": "216aca3648599b8a11ba9d3b920531a702548968",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -16,7 +16,7 @@\n \n #include \"chainparams.h\"\n #include \"key.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n \n #include <string>\n #include <vector>"
      },
      {
        "sha": "efcecb106ff63469b86feb61fe4b89083c0c0245",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -5,7 +5,7 @@\n #include \"core_io.h\"\n #include \"core.h\"\n #include \"serialize.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"util.h\"\n \n #include <boost/assign/list_of.hpp>"
      },
      {
        "sha": "3df13021df162699ab493606c15309f9eb24e000",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -4,7 +4,7 @@\n \n #include \"crypter.h\"\n \n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"util.h\"\n \n #include <string>"
      },
      {
        "sha": "98bc0e9e28b4aecaacb4132506725f1193cd614e",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -7,7 +7,7 @@\n \n #include \"crypter.h\"\n #include \"key.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>"
      },
      {
        "sha": "727b8dc66dac59ea6dfede8ec11c46863d955d3c",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -11,7 +11,7 @@\n #include \"db.h\"\n #include \"main.h\"\n #include \"paymentserver.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"transactionrecord.h\"\n #include \"timedata.h\"\n #include \"ui_interface.h\""
      },
      {
        "sha": "60d1beac95eb29db499b954213f74e857c15c600",
        "filename": "src/script/script.cpp",
        "status": "added",
        "additions": 295,
        "deletions": 0,
        "changes": 295,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -0,0 +1,295 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script.h\"\n+\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+const char* GetOpName(opcodetype opcode)\n+{\n+    switch (opcode)\n+    {\n+    // push value\n+    case OP_0                      : return \"0\";\n+    case OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n+    case OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n+    case OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n+    case OP_1NEGATE                : return \"-1\";\n+    case OP_RESERVED               : return \"OP_RESERVED\";\n+    case OP_1                      : return \"1\";\n+    case OP_2                      : return \"2\";\n+    case OP_3                      : return \"3\";\n+    case OP_4                      : return \"4\";\n+    case OP_5                      : return \"5\";\n+    case OP_6                      : return \"6\";\n+    case OP_7                      : return \"7\";\n+    case OP_8                      : return \"8\";\n+    case OP_9                      : return \"9\";\n+    case OP_10                     : return \"10\";\n+    case OP_11                     : return \"11\";\n+    case OP_12                     : return \"12\";\n+    case OP_13                     : return \"13\";\n+    case OP_14                     : return \"14\";\n+    case OP_15                     : return \"15\";\n+    case OP_16                     : return \"16\";\n+\n+    // control\n+    case OP_NOP                    : return \"OP_NOP\";\n+    case OP_VER                    : return \"OP_VER\";\n+    case OP_IF                     : return \"OP_IF\";\n+    case OP_NOTIF                  : return \"OP_NOTIF\";\n+    case OP_VERIF                  : return \"OP_VERIF\";\n+    case OP_VERNOTIF               : return \"OP_VERNOTIF\";\n+    case OP_ELSE                   : return \"OP_ELSE\";\n+    case OP_ENDIF                  : return \"OP_ENDIF\";\n+    case OP_VERIFY                 : return \"OP_VERIFY\";\n+    case OP_RETURN                 : return \"OP_RETURN\";\n+\n+    // stack ops\n+    case OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n+    case OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n+    case OP_2DROP                  : return \"OP_2DROP\";\n+    case OP_2DUP                   : return \"OP_2DUP\";\n+    case OP_3DUP                   : return \"OP_3DUP\";\n+    case OP_2OVER                  : return \"OP_2OVER\";\n+    case OP_2ROT                   : return \"OP_2ROT\";\n+    case OP_2SWAP                  : return \"OP_2SWAP\";\n+    case OP_IFDUP                  : return \"OP_IFDUP\";\n+    case OP_DEPTH                  : return \"OP_DEPTH\";\n+    case OP_DROP                   : return \"OP_DROP\";\n+    case OP_DUP                    : return \"OP_DUP\";\n+    case OP_NIP                    : return \"OP_NIP\";\n+    case OP_OVER                   : return \"OP_OVER\";\n+    case OP_PICK                   : return \"OP_PICK\";\n+    case OP_ROLL                   : return \"OP_ROLL\";\n+    case OP_ROT                    : return \"OP_ROT\";\n+    case OP_SWAP                   : return \"OP_SWAP\";\n+    case OP_TUCK                   : return \"OP_TUCK\";\n+\n+    // splice ops\n+    case OP_CAT                    : return \"OP_CAT\";\n+    case OP_SUBSTR                 : return \"OP_SUBSTR\";\n+    case OP_LEFT                   : return \"OP_LEFT\";\n+    case OP_RIGHT                  : return \"OP_RIGHT\";\n+    case OP_SIZE                   : return \"OP_SIZE\";\n+\n+    // bit logic\n+    case OP_INVERT                 : return \"OP_INVERT\";\n+    case OP_AND                    : return \"OP_AND\";\n+    case OP_OR                     : return \"OP_OR\";\n+    case OP_XOR                    : return \"OP_XOR\";\n+    case OP_EQUAL                  : return \"OP_EQUAL\";\n+    case OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n+    case OP_RESERVED1              : return \"OP_RESERVED1\";\n+    case OP_RESERVED2              : return \"OP_RESERVED2\";\n+\n+    // numeric\n+    case OP_1ADD                   : return \"OP_1ADD\";\n+    case OP_1SUB                   : return \"OP_1SUB\";\n+    case OP_2MUL                   : return \"OP_2MUL\";\n+    case OP_2DIV                   : return \"OP_2DIV\";\n+    case OP_NEGATE                 : return \"OP_NEGATE\";\n+    case OP_ABS                    : return \"OP_ABS\";\n+    case OP_NOT                    : return \"OP_NOT\";\n+    case OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n+    case OP_ADD                    : return \"OP_ADD\";\n+    case OP_SUB                    : return \"OP_SUB\";\n+    case OP_MUL                    : return \"OP_MUL\";\n+    case OP_DIV                    : return \"OP_DIV\";\n+    case OP_MOD                    : return \"OP_MOD\";\n+    case OP_LSHIFT                 : return \"OP_LSHIFT\";\n+    case OP_RSHIFT                 : return \"OP_RSHIFT\";\n+    case OP_BOOLAND                : return \"OP_BOOLAND\";\n+    case OP_BOOLOR                 : return \"OP_BOOLOR\";\n+    case OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n+    case OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n+    case OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n+    case OP_LESSTHAN               : return \"OP_LESSTHAN\";\n+    case OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n+    case OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n+    case OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n+    case OP_MIN                    : return \"OP_MIN\";\n+    case OP_MAX                    : return \"OP_MAX\";\n+    case OP_WITHIN                 : return \"OP_WITHIN\";\n+\n+    // crypto\n+    case OP_RIPEMD160              : return \"OP_RIPEMD160\";\n+    case OP_SHA1                   : return \"OP_SHA1\";\n+    case OP_SHA256                 : return \"OP_SHA256\";\n+    case OP_HASH160                : return \"OP_HASH160\";\n+    case OP_HASH256                : return \"OP_HASH256\";\n+    case OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n+    case OP_CHECKSIG               : return \"OP_CHECKSIG\";\n+    case OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n+    case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n+    case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n+\n+    // expanson\n+    case OP_NOP1                   : return \"OP_NOP1\";\n+    case OP_NOP2                   : return \"OP_NOP2\";\n+    case OP_NOP3                   : return \"OP_NOP3\";\n+    case OP_NOP4                   : return \"OP_NOP4\";\n+    case OP_NOP5                   : return \"OP_NOP5\";\n+    case OP_NOP6                   : return \"OP_NOP6\";\n+    case OP_NOP7                   : return \"OP_NOP7\";\n+    case OP_NOP8                   : return \"OP_NOP8\";\n+    case OP_NOP9                   : return \"OP_NOP9\";\n+    case OP_NOP10                  : return \"OP_NOP10\";\n+\n+    case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n+\n+    // Note:\n+    //  The template matching params OP_SMALLDATA/etc are defined in opcodetype enum\n+    //  as kind of implementation hack, they are *NOT* real opcodes.  If found in real\n+    //  Script, just let the default: case deal with them.\n+\n+    default:\n+        return \"OP_UNKNOWN\";\n+    }\n+}\n+\n+unsigned int CScript::GetSigOpCount(bool fAccurate) const\n+{\n+    unsigned int n = 0;\n+    const_iterator pc = begin();\n+    opcodetype lastOpcode = OP_INVALIDOPCODE;\n+    while (pc < end())\n+    {\n+        opcodetype opcode;\n+        if (!GetOp(pc, opcode))\n+            break;\n+        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n+            n++;\n+        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n+        {\n+            if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)\n+                n += DecodeOP_N(lastOpcode);\n+            else\n+                n += 20;\n+        }\n+        lastOpcode = opcode;\n+    }\n+    return n;\n+}\n+\n+unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n+{\n+    if (!IsPayToScriptHash())\n+        return GetSigOpCount(true);\n+\n+    // This is a pay-to-script-hash scriptPubKey;\n+    // get the last item that the scriptSig\n+    // pushes onto the stack:\n+    const_iterator pc = scriptSig.begin();\n+    vector<unsigned char> data;\n+    while (pc < scriptSig.end())\n+    {\n+        opcodetype opcode;\n+        if (!scriptSig.GetOp(pc, opcode, data))\n+            return 0;\n+        if (opcode > OP_16)\n+            return 0;\n+    }\n+\n+    /// ... and return its opcount:\n+    CScript subscript(data.begin(), data.end());\n+    return subscript.GetSigOpCount(true);\n+}\n+\n+bool CScript::IsPayToScriptHash() const\n+{\n+    // Extra-fast test for pay-to-script-hash CScripts:\n+    return (this->size() == 23 &&\n+            this->at(0) == OP_HASH160 &&\n+            this->at(1) == 0x14 &&\n+            this->at(22) == OP_EQUAL);\n+}\n+\n+bool CScript::IsPushOnly() const\n+{\n+    const_iterator pc = begin();\n+    while (pc < end())\n+    {\n+        opcodetype opcode;\n+        if (!GetOp(pc, opcode))\n+            return false;\n+        // Note that IsPushOnly() *does* consider OP_RESERVED to be a\n+        // push-type opcode, however execution of OP_RESERVED fails, so\n+        // it's not relevant to P2SH as the scriptSig would fail prior to\n+        // the P2SH special validation code being executed.\n+        if (opcode > OP_16)\n+            return false;\n+    }\n+    return true;\n+}\n+\n+bool CScript::HasCanonicalPushes() const\n+{\n+    const_iterator pc = begin();\n+    while (pc < end())\n+    {\n+        opcodetype opcode;\n+        std::vector<unsigned char> data;\n+        if (!GetOp(pc, opcode, data))\n+            return false;\n+        if (opcode > OP_16)\n+            continue;\n+        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n+            // Could have used an OP_n code, rather than a 1-byte push.\n+            return false;\n+        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n+            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n+            return false;\n+        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n+            // Could have used an OP_PUSHDATA1.\n+            return false;\n+        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n+            // Could have used an OP_PUSHDATA2.\n+            return false;\n+    }\n+    return true;\n+}\n+\n+class CScriptVisitor : public boost::static_visitor<bool>\n+{\n+private:\n+    CScript *script;\n+public:\n+    CScriptVisitor(CScript *scriptin) { script = scriptin; }\n+\n+    bool operator()(const CNoDestination &dest) const {\n+        script->clear();\n+        return false;\n+    }\n+\n+    bool operator()(const CKeyID &keyID) const {\n+        script->clear();\n+        *script << OP_DUP << OP_HASH160 << keyID << OP_EQUALVERIFY << OP_CHECKSIG;\n+        return true;\n+    }\n+\n+    bool operator()(const CScriptID &scriptID) const {\n+        script->clear();\n+        *script << OP_HASH160 << scriptID << OP_EQUAL;\n+        return true;\n+    }\n+};\n+\n+void CScript::SetDestination(const CTxDestination& dest)\n+{\n+    boost::apply_visitor(CScriptVisitor(this), dest);\n+}\n+\n+void CScript::SetMultisig(int nRequired, const std::vector<CPubKey>& keys)\n+{\n+    this->clear();\n+\n+    *this << EncodeOP_N(nRequired);\n+    BOOST_FOREACH(const CPubKey& key, keys)\n+        *this << key;\n+    *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n+}"
      },
      {
        "sha": "21847c09bd8a5ffc82d1010745b4fffc7e4bf221",
        "filename": "src/script/script.h",
        "status": "added",
        "additions": 645,
        "deletions": 0,
        "changes": 645,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -0,0 +1,645 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef H_BITCOIN_SCRIPT\n+#define H_BITCOIN_SCRIPT\n+\n+#include \"key.h\"\n+#include \"tinyformat.h\"\n+#include \"utilstrencodings.h\"\n+\n+#include <stdexcept>\n+\n+#include <boost/variant.hpp>\n+\n+static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n+\n+/** Script opcodes */\n+enum opcodetype\n+{\n+    // push value\n+    OP_0 = 0x00,\n+    OP_FALSE = OP_0,\n+    OP_PUSHDATA1 = 0x4c,\n+    OP_PUSHDATA2 = 0x4d,\n+    OP_PUSHDATA4 = 0x4e,\n+    OP_1NEGATE = 0x4f,\n+    OP_RESERVED = 0x50,\n+    OP_1 = 0x51,\n+    OP_TRUE=OP_1,\n+    OP_2 = 0x52,\n+    OP_3 = 0x53,\n+    OP_4 = 0x54,\n+    OP_5 = 0x55,\n+    OP_6 = 0x56,\n+    OP_7 = 0x57,\n+    OP_8 = 0x58,\n+    OP_9 = 0x59,\n+    OP_10 = 0x5a,\n+    OP_11 = 0x5b,\n+    OP_12 = 0x5c,\n+    OP_13 = 0x5d,\n+    OP_14 = 0x5e,\n+    OP_15 = 0x5f,\n+    OP_16 = 0x60,\n+\n+    // control\n+    OP_NOP = 0x61,\n+    OP_VER = 0x62,\n+    OP_IF = 0x63,\n+    OP_NOTIF = 0x64,\n+    OP_VERIF = 0x65,\n+    OP_VERNOTIF = 0x66,\n+    OP_ELSE = 0x67,\n+    OP_ENDIF = 0x68,\n+    OP_VERIFY = 0x69,\n+    OP_RETURN = 0x6a,\n+\n+    // stack ops\n+    OP_TOALTSTACK = 0x6b,\n+    OP_FROMALTSTACK = 0x6c,\n+    OP_2DROP = 0x6d,\n+    OP_2DUP = 0x6e,\n+    OP_3DUP = 0x6f,\n+    OP_2OVER = 0x70,\n+    OP_2ROT = 0x71,\n+    OP_2SWAP = 0x72,\n+    OP_IFDUP = 0x73,\n+    OP_DEPTH = 0x74,\n+    OP_DROP = 0x75,\n+    OP_DUP = 0x76,\n+    OP_NIP = 0x77,\n+    OP_OVER = 0x78,\n+    OP_PICK = 0x79,\n+    OP_ROLL = 0x7a,\n+    OP_ROT = 0x7b,\n+    OP_SWAP = 0x7c,\n+    OP_TUCK = 0x7d,\n+\n+    // splice ops\n+    OP_CAT = 0x7e,\n+    OP_SUBSTR = 0x7f,\n+    OP_LEFT = 0x80,\n+    OP_RIGHT = 0x81,\n+    OP_SIZE = 0x82,\n+\n+    // bit logic\n+    OP_INVERT = 0x83,\n+    OP_AND = 0x84,\n+    OP_OR = 0x85,\n+    OP_XOR = 0x86,\n+    OP_EQUAL = 0x87,\n+    OP_EQUALVERIFY = 0x88,\n+    OP_RESERVED1 = 0x89,\n+    OP_RESERVED2 = 0x8a,\n+\n+    // numeric\n+    OP_1ADD = 0x8b,\n+    OP_1SUB = 0x8c,\n+    OP_2MUL = 0x8d,\n+    OP_2DIV = 0x8e,\n+    OP_NEGATE = 0x8f,\n+    OP_ABS = 0x90,\n+    OP_NOT = 0x91,\n+    OP_0NOTEQUAL = 0x92,\n+\n+    OP_ADD = 0x93,\n+    OP_SUB = 0x94,\n+    OP_MUL = 0x95,\n+    OP_DIV = 0x96,\n+    OP_MOD = 0x97,\n+    OP_LSHIFT = 0x98,\n+    OP_RSHIFT = 0x99,\n+\n+    OP_BOOLAND = 0x9a,\n+    OP_BOOLOR = 0x9b,\n+    OP_NUMEQUAL = 0x9c,\n+    OP_NUMEQUALVERIFY = 0x9d,\n+    OP_NUMNOTEQUAL = 0x9e,\n+    OP_LESSTHAN = 0x9f,\n+    OP_GREATERTHAN = 0xa0,\n+    OP_LESSTHANOREQUAL = 0xa1,\n+    OP_GREATERTHANOREQUAL = 0xa2,\n+    OP_MIN = 0xa3,\n+    OP_MAX = 0xa4,\n+\n+    OP_WITHIN = 0xa5,\n+\n+    // crypto\n+    OP_RIPEMD160 = 0xa6,\n+    OP_SHA1 = 0xa7,\n+    OP_SHA256 = 0xa8,\n+    OP_HASH160 = 0xa9,\n+    OP_HASH256 = 0xaa,\n+    OP_CODESEPARATOR = 0xab,\n+    OP_CHECKSIG = 0xac,\n+    OP_CHECKSIGVERIFY = 0xad,\n+    OP_CHECKMULTISIG = 0xae,\n+    OP_CHECKMULTISIGVERIFY = 0xaf,\n+\n+    // expansion\n+    OP_NOP1 = 0xb0,\n+    OP_NOP2 = 0xb1,\n+    OP_NOP3 = 0xb2,\n+    OP_NOP4 = 0xb3,\n+    OP_NOP5 = 0xb4,\n+    OP_NOP6 = 0xb5,\n+    OP_NOP7 = 0xb6,\n+    OP_NOP8 = 0xb7,\n+    OP_NOP9 = 0xb8,\n+    OP_NOP10 = 0xb9,\n+\n+\n+    // template matching params\n+    OP_SMALLDATA = 0xf9,\n+    OP_SMALLINTEGER = 0xfa,\n+    OP_PUBKEYS = 0xfb,\n+    OP_PUBKEYHASH = 0xfd,\n+    OP_PUBKEY = 0xfe,\n+\n+    OP_INVALIDOPCODE = 0xff,\n+};\n+\n+const char* GetOpName(opcodetype opcode);\n+\n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+public:\n+\n+    explicit CScriptNum(const int64_t& n)\n+    {\n+        m_value = n;\n+    }\n+\n+    explicit CScriptNum(const std::vector<unsigned char>& vch)\n+    {\n+        if (vch.size() > nMaxNumSize)\n+            throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+        m_value = set_vch(vch);\n+    }\n+\n+    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+    inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+    inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+    inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+    inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+    inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+    inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+    inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+    inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+    inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+    inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+    inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+    inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+    inline CScriptNum operator-()                         const\n+    {\n+        assert(m_value != std::numeric_limits<int64_t>::min());\n+        return CScriptNum(-m_value);\n+    }\n+\n+    inline CScriptNum& operator=( const int64_t& rhs)\n+    {\n+        m_value = rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum& operator+=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n+                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n+        m_value += rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum& operator-=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n+                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n+        m_value -= rhs;\n+        return *this;\n+    }\n+\n+    int getint() const\n+    {\n+        if (m_value > std::numeric_limits<int>::max())\n+            return std::numeric_limits<int>::max();\n+        else if (m_value < std::numeric_limits<int>::min())\n+            return std::numeric_limits<int>::min();\n+        return m_value;\n+    }\n+\n+    std::vector<unsigned char> getvch() const\n+    {\n+        return serialize(m_value);\n+    }\n+\n+    static std::vector<unsigned char> serialize(const int64_t& value)\n+    {\n+        if(value == 0)\n+            return std::vector<unsigned char>();\n+\n+        std::vector<unsigned char> result;\n+        const bool neg = value < 0;\n+        uint64_t absvalue = neg ? -value : value;\n+\n+        while(absvalue)\n+        {\n+            result.push_back(absvalue & 0xff);\n+            absvalue >>= 8;\n+        }\n+\n+//    - If the most significant byte is >= 0x80 and the value is positive, push a\n+//    new zero-byte to make the significant byte < 0x80 again.\n+\n+//    - If the most significant byte is >= 0x80 and the value is negative, push a\n+//    new 0x80 byte that will be popped off when converting to an integral.\n+\n+//    - If the most significant byte is < 0x80 and the value is negative, add\n+//    0x80 to it, since it will be subtracted and interpreted as a negative when\n+//    converting to an integral.\n+\n+        if (result.back() & 0x80)\n+            result.push_back(neg ? 0x80 : 0);\n+        else if (neg)\n+            result.back() |= 0x80;\n+\n+        return result;\n+    }\n+\n+    static const size_t nMaxNumSize = 4;\n+\n+private:\n+    static int64_t set_vch(const std::vector<unsigned char>& vch)\n+    {\n+      if (vch.empty())\n+          return 0;\n+\n+      int64_t result = 0;\n+      for (size_t i = 0; i != vch.size(); ++i)\n+          result |= static_cast<int64_t>(vch[i]) << 8*i;\n+\n+      // If the input vector's most significant byte is 0x80, remove it from\n+      // the result's msb and return a negative.\n+      if (vch.back() & 0x80)\n+          return -(result & ~(0x80ULL << (8 * (vch.size() - 1))));\n+\n+      return result;\n+    }\n+\n+    int64_t m_value;\n+};\n+\n+inline std::string ValueString(const std::vector<unsigned char>& vch)\n+{\n+    if (vch.size() <= 4)\n+        return strprintf(\"%d\", CScriptNum(vch).getint());\n+    else\n+        return HexStr(vch);\n+}\n+\n+class CNoDestination {\n+public:\n+    friend bool operator==(const CNoDestination &a, const CNoDestination &b) { return true; }\n+    friend bool operator<(const CNoDestination &a, const CNoDestination &b) { return true; }\n+};\n+\n+/** A txout script template with a specific destination. It is either:\n+ *  * CNoDestination: no destination set\n+ *  * CKeyID: TX_PUBKEYHASH destination\n+ *  * CScriptID: TX_SCRIPTHASH destination\n+ *  A CTxDestination is the internal data type encoded in a CBitcoinAddress\n+ */\n+typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n+\n+/** Serialized script, used inside transaction inputs and outputs */\n+class CScript : public std::vector<unsigned char>\n+{\n+protected:\n+    CScript& push_int64(int64_t n)\n+    {\n+        if (n == -1 || (n >= 1 && n <= 16))\n+        {\n+            push_back(n + (OP_1 - 1));\n+        }\n+        else\n+        {\n+            *this << CScriptNum::serialize(n);\n+        }\n+        return *this;\n+    }\n+public:\n+    CScript() { }\n+    CScript(const CScript& b) : std::vector<unsigned char>(b.begin(), b.end()) { }\n+    CScript(const_iterator pbegin, const_iterator pend) : std::vector<unsigned char>(pbegin, pend) { }\n+#ifndef _MSC_VER\n+    CScript(const unsigned char* pbegin, const unsigned char* pend) : std::vector<unsigned char>(pbegin, pend) { }\n+#endif\n+\n+    CScript& operator+=(const CScript& b)\n+    {\n+        insert(end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    friend CScript operator+(const CScript& a, const CScript& b)\n+    {\n+        CScript ret = a;\n+        ret += b;\n+        return ret;\n+    }\n+\n+    CScript(int64_t b)        { operator<<(b); }\n+\n+    explicit CScript(opcodetype b)     { operator<<(b); }\n+    explicit CScript(const uint256& b) { operator<<(b); }\n+    explicit CScript(const CScriptNum& b) { operator<<(b); }\n+    explicit CScript(const std::vector<unsigned char>& b) { operator<<(b); }\n+\n+\n+    CScript& operator<<(int64_t b) { return push_int64(b); }\n+\n+    CScript& operator<<(opcodetype opcode)\n+    {\n+        if (opcode < 0 || opcode > 0xff)\n+            throw std::runtime_error(\"CScript::operator<<() : invalid opcode\");\n+        insert(end(), (unsigned char)opcode);\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const uint160& b)\n+    {\n+        insert(end(), sizeof(b));\n+        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const uint256& b)\n+    {\n+        insert(end(), sizeof(b));\n+        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const CPubKey& key)\n+    {\n+        assert(key.size() < OP_PUSHDATA1);\n+        insert(end(), (unsigned char)key.size());\n+        insert(end(), key.begin(), key.end());\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const CScriptNum& b)\n+    {\n+        *this << b.getvch();\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const std::vector<unsigned char>& b)\n+    {\n+        if (b.size() < OP_PUSHDATA1)\n+        {\n+            insert(end(), (unsigned char)b.size());\n+        }\n+        else if (b.size() <= 0xff)\n+        {\n+            insert(end(), OP_PUSHDATA1);\n+            insert(end(), (unsigned char)b.size());\n+        }\n+        else if (b.size() <= 0xffff)\n+        {\n+            insert(end(), OP_PUSHDATA2);\n+            unsigned short nSize = b.size();\n+            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+        }\n+        else\n+        {\n+            insert(end(), OP_PUSHDATA4);\n+            unsigned int nSize = b.size();\n+            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+        }\n+        insert(end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const CScript& b)\n+    {\n+        // I'm not sure if this should push the script or concatenate scripts.\n+        // If there's ever a use for pushing a script onto a script, delete this member fn\n+        assert(!\"Warning: Pushing a CScript onto a CScript with << is probably not intended, use + to concatenate!\");\n+        return *this;\n+    }\n+\n+\n+    bool GetOp(iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet)\n+    {\n+         // Wrapper so it can be called with either iterator or const_iterator\n+         const_iterator pc2 = pc;\n+         bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n+         pc = begin() + (pc2 - begin());\n+         return fRet;\n+    }\n+\n+    bool GetOp(iterator& pc, opcodetype& opcodeRet)\n+    {\n+         const_iterator pc2 = pc;\n+         bool fRet = GetOp2(pc2, opcodeRet, NULL);\n+         pc = begin() + (pc2 - begin());\n+         return fRet;\n+    }\n+\n+    bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n+    {\n+        return GetOp2(pc, opcodeRet, &vchRet);\n+    }\n+\n+    bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n+    {\n+        return GetOp2(pc, opcodeRet, NULL);\n+    }\n+\n+    bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n+    {\n+        opcodeRet = OP_INVALIDOPCODE;\n+        if (pvchRet)\n+            pvchRet->clear();\n+        if (pc >= end())\n+            return false;\n+\n+        // Read instruction\n+        if (end() - pc < 1)\n+            return false;\n+        unsigned int opcode = *pc++;\n+\n+        // Immediate operand\n+        if (opcode <= OP_PUSHDATA4)\n+        {\n+            unsigned int nSize = 0;\n+            if (opcode < OP_PUSHDATA1)\n+            {\n+                nSize = opcode;\n+            }\n+            else if (opcode == OP_PUSHDATA1)\n+            {\n+                if (end() - pc < 1)\n+                    return false;\n+                nSize = *pc++;\n+            }\n+            else if (opcode == OP_PUSHDATA2)\n+            {\n+                if (end() - pc < 2)\n+                    return false;\n+                nSize = 0;\n+                memcpy(&nSize, &pc[0], 2);\n+                pc += 2;\n+            }\n+            else if (opcode == OP_PUSHDATA4)\n+            {\n+                if (end() - pc < 4)\n+                    return false;\n+                memcpy(&nSize, &pc[0], 4);\n+                pc += 4;\n+            }\n+            if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n+                return false;\n+            if (pvchRet)\n+                pvchRet->assign(pc, pc + nSize);\n+            pc += nSize;\n+        }\n+\n+        opcodeRet = (opcodetype)opcode;\n+        return true;\n+    }\n+\n+    // Encode/decode small integers:\n+    static int DecodeOP_N(opcodetype opcode)\n+    {\n+        if (opcode == OP_0)\n+            return 0;\n+        assert(opcode >= OP_1 && opcode <= OP_16);\n+        return (int)opcode - (int)(OP_1 - 1);\n+    }\n+    static opcodetype EncodeOP_N(int n)\n+    {\n+        assert(n >= 0 && n <= 16);\n+        if (n == 0)\n+            return OP_0;\n+        return (opcodetype)(OP_1+n-1);\n+    }\n+\n+    int FindAndDelete(const CScript& b)\n+    {\n+        int nFound = 0;\n+        if (b.empty())\n+            return nFound;\n+        iterator pc = begin();\n+        opcodetype opcode;\n+        do\n+        {\n+            while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n+            {\n+                erase(pc, pc + b.size());\n+                ++nFound;\n+            }\n+        }\n+        while (GetOp(pc, opcode));\n+        return nFound;\n+    }\n+    int Find(opcodetype op) const\n+    {\n+        int nFound = 0;\n+        opcodetype opcode;\n+        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n+            if (opcode == op)\n+                ++nFound;\n+        return nFound;\n+    }\n+\n+    // Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs\n+    // as 20 sigops. With pay-to-script-hash, that changed:\n+    // CHECKMULTISIGs serialized in scriptSigs are\n+    // counted more accurately, assuming they are of the form\n+    //  ... OP_N CHECKMULTISIG ...\n+    unsigned int GetSigOpCount(bool fAccurate) const;\n+\n+    // Accurately count sigOps, including sigOps in\n+    // pay-to-script-hash transactions:\n+    unsigned int GetSigOpCount(const CScript& scriptSig) const;\n+\n+    bool IsPayToScriptHash() const;\n+\n+    // Called by IsStandardTx and P2SH VerifyScript (which makes it consensus-critical).\n+    bool IsPushOnly() const;\n+\n+    // Called by IsStandardTx.\n+    bool HasCanonicalPushes() const;\n+\n+    // Returns whether the script is guaranteed to fail at execution,\n+    // regardless of the initial stack. This allows outputs to be pruned\n+    // instantly when entering the UTXO set.\n+    bool IsUnspendable() const\n+    {\n+        return (size() > 0 && *begin() == OP_RETURN);\n+    }\n+\n+    void SetDestination(const CTxDestination& address);\n+    void SetMultisig(int nRequired, const std::vector<CPubKey>& keys);\n+\n+    std::string ToString() const\n+    {\n+        std::string str;\n+        opcodetype opcode;\n+        std::vector<unsigned char> vch;\n+        const_iterator pc = begin();\n+        while (pc < end())\n+        {\n+            if (!str.empty())\n+                str += \" \";\n+            if (!GetOp(pc, opcode, vch))\n+            {\n+                str += \"[error]\";\n+                return str;\n+            }\n+            if (0 <= opcode && opcode <= OP_PUSHDATA4)\n+                str += ValueString(vch);\n+            else\n+                str += GetOpName(opcode);\n+        }\n+        return str;\n+    }\n+\n+    CScriptID GetID() const\n+    {\n+        return CScriptID(Hash160(*this));\n+    }\n+\n+    void clear()\n+    {\n+        // The default std::vector::clear() does not release memory.\n+        std::vector<unsigned char>().swap(*this);\n+    }\n+};\n+\n+#endif"
      },
      {
        "sha": "c1fc83328e4d552963846fb28f3fe0a106aec5dc",
        "filename": "src/scriptutils.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 288,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -83,150 +83,6 @@ const char* GetTxnOutputType(txnouttype t)\n     return NULL;\n }\n \n-\n-const char* GetOpName(opcodetype opcode)\n-{\n-    switch (opcode)\n-    {\n-    // push value\n-    case OP_0                      : return \"0\";\n-    case OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n-    case OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n-    case OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n-    case OP_1NEGATE                : return \"-1\";\n-    case OP_RESERVED               : return \"OP_RESERVED\";\n-    case OP_1                      : return \"1\";\n-    case OP_2                      : return \"2\";\n-    case OP_3                      : return \"3\";\n-    case OP_4                      : return \"4\";\n-    case OP_5                      : return \"5\";\n-    case OP_6                      : return \"6\";\n-    case OP_7                      : return \"7\";\n-    case OP_8                      : return \"8\";\n-    case OP_9                      : return \"9\";\n-    case OP_10                     : return \"10\";\n-    case OP_11                     : return \"11\";\n-    case OP_12                     : return \"12\";\n-    case OP_13                     : return \"13\";\n-    case OP_14                     : return \"14\";\n-    case OP_15                     : return \"15\";\n-    case OP_16                     : return \"16\";\n-\n-    // control\n-    case OP_NOP                    : return \"OP_NOP\";\n-    case OP_VER                    : return \"OP_VER\";\n-    case OP_IF                     : return \"OP_IF\";\n-    case OP_NOTIF                  : return \"OP_NOTIF\";\n-    case OP_VERIF                  : return \"OP_VERIF\";\n-    case OP_VERNOTIF               : return \"OP_VERNOTIF\";\n-    case OP_ELSE                   : return \"OP_ELSE\";\n-    case OP_ENDIF                  : return \"OP_ENDIF\";\n-    case OP_VERIFY                 : return \"OP_VERIFY\";\n-    case OP_RETURN                 : return \"OP_RETURN\";\n-\n-    // stack ops\n-    case OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n-    case OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n-    case OP_2DROP                  : return \"OP_2DROP\";\n-    case OP_2DUP                   : return \"OP_2DUP\";\n-    case OP_3DUP                   : return \"OP_3DUP\";\n-    case OP_2OVER                  : return \"OP_2OVER\";\n-    case OP_2ROT                   : return \"OP_2ROT\";\n-    case OP_2SWAP                  : return \"OP_2SWAP\";\n-    case OP_IFDUP                  : return \"OP_IFDUP\";\n-    case OP_DEPTH                  : return \"OP_DEPTH\";\n-    case OP_DROP                   : return \"OP_DROP\";\n-    case OP_DUP                    : return \"OP_DUP\";\n-    case OP_NIP                    : return \"OP_NIP\";\n-    case OP_OVER                   : return \"OP_OVER\";\n-    case OP_PICK                   : return \"OP_PICK\";\n-    case OP_ROLL                   : return \"OP_ROLL\";\n-    case OP_ROT                    : return \"OP_ROT\";\n-    case OP_SWAP                   : return \"OP_SWAP\";\n-    case OP_TUCK                   : return \"OP_TUCK\";\n-\n-    // splice ops\n-    case OP_CAT                    : return \"OP_CAT\";\n-    case OP_SUBSTR                 : return \"OP_SUBSTR\";\n-    case OP_LEFT                   : return \"OP_LEFT\";\n-    case OP_RIGHT                  : return \"OP_RIGHT\";\n-    case OP_SIZE                   : return \"OP_SIZE\";\n-\n-    // bit logic\n-    case OP_INVERT                 : return \"OP_INVERT\";\n-    case OP_AND                    : return \"OP_AND\";\n-    case OP_OR                     : return \"OP_OR\";\n-    case OP_XOR                    : return \"OP_XOR\";\n-    case OP_EQUAL                  : return \"OP_EQUAL\";\n-    case OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n-    case OP_RESERVED1              : return \"OP_RESERVED1\";\n-    case OP_RESERVED2              : return \"OP_RESERVED2\";\n-\n-    // numeric\n-    case OP_1ADD                   : return \"OP_1ADD\";\n-    case OP_1SUB                   : return \"OP_1SUB\";\n-    case OP_2MUL                   : return \"OP_2MUL\";\n-    case OP_2DIV                   : return \"OP_2DIV\";\n-    case OP_NEGATE                 : return \"OP_NEGATE\";\n-    case OP_ABS                    : return \"OP_ABS\";\n-    case OP_NOT                    : return \"OP_NOT\";\n-    case OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n-    case OP_ADD                    : return \"OP_ADD\";\n-    case OP_SUB                    : return \"OP_SUB\";\n-    case OP_MUL                    : return \"OP_MUL\";\n-    case OP_DIV                    : return \"OP_DIV\";\n-    case OP_MOD                    : return \"OP_MOD\";\n-    case OP_LSHIFT                 : return \"OP_LSHIFT\";\n-    case OP_RSHIFT                 : return \"OP_RSHIFT\";\n-    case OP_BOOLAND                : return \"OP_BOOLAND\";\n-    case OP_BOOLOR                 : return \"OP_BOOLOR\";\n-    case OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n-    case OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n-    case OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n-    case OP_LESSTHAN               : return \"OP_LESSTHAN\";\n-    case OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n-    case OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n-    case OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n-    case OP_MIN                    : return \"OP_MIN\";\n-    case OP_MAX                    : return \"OP_MAX\";\n-    case OP_WITHIN                 : return \"OP_WITHIN\";\n-\n-    // crypto\n-    case OP_RIPEMD160              : return \"OP_RIPEMD160\";\n-    case OP_SHA1                   : return \"OP_SHA1\";\n-    case OP_SHA256                 : return \"OP_SHA256\";\n-    case OP_HASH160                : return \"OP_HASH160\";\n-    case OP_HASH256                : return \"OP_HASH256\";\n-    case OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n-    case OP_CHECKSIG               : return \"OP_CHECKSIG\";\n-    case OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n-    case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n-    case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n-\n-    // expanson\n-    case OP_NOP1                   : return \"OP_NOP1\";\n-    case OP_NOP2                   : return \"OP_NOP2\";\n-    case OP_NOP3                   : return \"OP_NOP3\";\n-    case OP_NOP4                   : return \"OP_NOP4\";\n-    case OP_NOP5                   : return \"OP_NOP5\";\n-    case OP_NOP6                   : return \"OP_NOP6\";\n-    case OP_NOP7                   : return \"OP_NOP7\";\n-    case OP_NOP8                   : return \"OP_NOP8\";\n-    case OP_NOP9                   : return \"OP_NOP9\";\n-    case OP_NOP10                  : return \"OP_NOP10\";\n-\n-    case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n-\n-    // Note:\n-    //  The template matching params OP_SMALLDATA/etc are defined in opcodetype enum\n-    //  as kind of implementation hack, they are *NOT* real opcodes.  If found in real\n-    //  Script, just let the default: case deal with them.\n-\n-    default:\n-        return \"OP_UNKNOWN\";\n-    }\n-}\n-\n bool IsCanonicalPubKey(const valtype &vchPubKey, unsigned int flags) {\n     if (!(flags & SCRIPT_VERIFY_STRICTENC))\n         return true;\n@@ -1815,150 +1671,6 @@ CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsign\n     return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n }\n \n-unsigned int CScript::GetSigOpCount(bool fAccurate) const\n-{\n-    unsigned int n = 0;\n-    const_iterator pc = begin();\n-    opcodetype lastOpcode = OP_INVALIDOPCODE;\n-    while (pc < end())\n-    {\n-        opcodetype opcode;\n-        if (!GetOp(pc, opcode))\n-            break;\n-        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n-            n++;\n-        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n-        {\n-            if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)\n-                n += DecodeOP_N(lastOpcode);\n-            else\n-                n += 20;\n-        }\n-        lastOpcode = opcode;\n-    }\n-    return n;\n-}\n-\n-unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n-{\n-    if (!IsPayToScriptHash())\n-        return GetSigOpCount(true);\n-\n-    // This is a pay-to-script-hash scriptPubKey;\n-    // get the last item that the scriptSig\n-    // pushes onto the stack:\n-    const_iterator pc = scriptSig.begin();\n-    vector<unsigned char> data;\n-    while (pc < scriptSig.end())\n-    {\n-        opcodetype opcode;\n-        if (!scriptSig.GetOp(pc, opcode, data))\n-            return 0;\n-        if (opcode > OP_16)\n-            return 0;\n-    }\n-\n-    /// ... and return its opcount:\n-    CScript subscript(data.begin(), data.end());\n-    return subscript.GetSigOpCount(true);\n-}\n-\n-bool CScript::IsPayToScriptHash() const\n-{\n-    // Extra-fast test for pay-to-script-hash CScripts:\n-    return (this->size() == 23 &&\n-            this->at(0) == OP_HASH160 &&\n-            this->at(1) == 0x14 &&\n-            this->at(22) == OP_EQUAL);\n-}\n-\n-bool CScript::IsPushOnly() const\n-{\n-    const_iterator pc = begin();\n-    while (pc < end())\n-    {\n-        // Note how a script with an invalid PUSHDATA returns False.\n-        opcodetype opcode;\n-        if (!GetOp(pc, opcode))\n-            return false;\n-\n-        // Note that IsPushOnly() *does* consider OP_RESERVED to be a\n-        // push-type opcode, however execution of OP_RESERVED fails, so\n-        // it's not relevant to P2SH as the scriptSig would fail prior to\n-        // the P2SH special validation code being executed.\n-        if (opcode > OP_16)\n-            return false;\n-    }\n-    return true;\n-}\n-\n-bool CScript::HasCanonicalPushes() const\n-{\n-    const_iterator pc = begin();\n-    while (pc < end())\n-    {\n-        opcodetype opcode;\n-        std::vector<unsigned char> data;\n-        if (!GetOp(pc, opcode, data))\n-            return false;\n-        if (opcode > OP_16)\n-            continue;\n-        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n-            // Could have used an OP_n code, rather than a 1-byte push.\n-            return false;\n-        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n-            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n-            return false;\n-        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n-            // Could have used an OP_PUSHDATA1.\n-            return false;\n-        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n-            // Could have used an OP_PUSHDATA2.\n-            return false;\n-    }\n-    return true;\n-}\n-\n-class CScriptVisitor : public boost::static_visitor<bool>\n-{\n-private:\n-    CScript *script;\n-public:\n-    CScriptVisitor(CScript *scriptin) { script = scriptin; }\n-\n-    bool operator()(const CNoDestination &dest) const {\n-        script->clear();\n-        return false;\n-    }\n-\n-    bool operator()(const CKeyID &keyID) const {\n-        script->clear();\n-        *script << OP_DUP << OP_HASH160 << keyID << OP_EQUALVERIFY << OP_CHECKSIG;\n-        return true;\n-    }\n-\n-    bool operator()(const CScriptID &scriptID) const {\n-        script->clear();\n-        *script << OP_HASH160 << scriptID << OP_EQUAL;\n-        return true;\n-    }\n-};\n-\n-void CScript::SetDestination(const CTxDestination& dest)\n-{\n-    boost::apply_visitor(CScriptVisitor(this), dest);\n-}\n-\n-void CScript::SetMultisig(int nRequired, const std::vector<CPubKey>& keys)\n-{\n-    this->clear();\n-\n-    *this << EncodeOP_N(nRequired);\n-    BOOST_FOREACH(const CPubKey& key, keys)\n-        *this << key;\n-    *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n-}\n-\n bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n {\n     if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160"
      },
      {
        "sha": "4f29f7ab29dcc2b63900376030e1ed120cdd7118",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 1,
        "deletions": 636,
        "changes": 637,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -7,172 +7,19 @@\n #define H_BITCOIN_SCRIPTUTILS\n \n #include \"key.h\"\n-#include \"utilstrencodings.h\"\n-#include \"tinyformat.h\"\n+#include \"script/script.h\"\n \n #include <stdexcept>\n #include <stdint.h>\n #include <string>\n #include <vector>\n \n-#include <boost/variant.hpp>\n-\n class CKeyStore;\n class CTransaction;\n struct CMutableTransaction;\n \n-static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n-class scriptnum_error : public std::runtime_error\n-{\n-public:\n-    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n-};\n-\n-class CScriptNum\n-{\n-// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n-// The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],\n-// but results may overflow (and are valid as long as they are not used in a subsequent\n-// numeric operation). CScriptNum enforces those semantics by storing results as\n-// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n-// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n-public:\n-\n-    explicit CScriptNum(const int64_t& n)\n-    {\n-        m_value = n;\n-    }\n-\n-    explicit CScriptNum(const std::vector<unsigned char>& vch)\n-    {\n-        if (vch.size() > nMaxNumSize)\n-            throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n-        m_value = set_vch(vch);\n-    }\n-\n-    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n-    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n-    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n-    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n-    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n-    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n-\n-    inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n-    inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n-    inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n-    inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n-    inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n-    inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n-\n-    inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n-    inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n-    inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n-    inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n-\n-    inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n-    inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n-\n-    inline CScriptNum operator-()                         const\n-    {\n-        assert(m_value != std::numeric_limits<int64_t>::min());\n-        return CScriptNum(-m_value);\n-    }\n-\n-    inline CScriptNum& operator=( const int64_t& rhs)\n-    {\n-        m_value = rhs;\n-        return *this;\n-    }\n-\n-    inline CScriptNum& operator+=( const int64_t& rhs)\n-    {\n-        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n-                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n-        m_value += rhs;\n-        return *this;\n-    }\n-\n-    inline CScriptNum& operator-=( const int64_t& rhs)\n-    {\n-        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n-                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n-        m_value -= rhs;\n-        return *this;\n-    }\n-\n-    int getint() const\n-    {\n-        if (m_value > std::numeric_limits<int>::max())\n-            return std::numeric_limits<int>::max();\n-        else if (m_value < std::numeric_limits<int>::min())\n-            return std::numeric_limits<int>::min();\n-        return m_value;\n-    }\n-\n-    std::vector<unsigned char> getvch() const\n-    {\n-        return serialize(m_value);\n-    }\n-\n-    static std::vector<unsigned char> serialize(const int64_t& value)\n-    {\n-        if(value == 0)\n-            return std::vector<unsigned char>();\n-\n-        std::vector<unsigned char> result;\n-        const bool neg = value < 0;\n-        uint64_t absvalue = neg ? -value : value;\n-\n-        while(absvalue)\n-        {\n-            result.push_back(absvalue & 0xff);\n-            absvalue >>= 8;\n-        }\n-\n-\n-//    - If the most significant byte is >= 0x80 and the value is positive, push a\n-//    new zero-byte to make the significant byte < 0x80 again.\n-\n-//    - If the most significant byte is >= 0x80 and the value is negative, push a\n-//    new 0x80 byte that will be popped off when converting to an integral.\n-\n-//    - If the most significant byte is < 0x80 and the value is negative, add\n-//    0x80 to it, since it will be subtracted and interpreted as a negative when\n-//    converting to an integral.\n-\n-        if (result.back() & 0x80)\n-            result.push_back(neg ? 0x80 : 0);\n-        else if (neg)\n-            result.back() |= 0x80;\n-\n-        return result;\n-    }\n-\n-    static const size_t nMaxNumSize = 4;\n-\n-private:\n-    static int64_t set_vch(const std::vector<unsigned char>& vch)\n-    {\n-      if (vch.empty())\n-          return 0;\n-\n-      int64_t result = 0;\n-      for (size_t i = 0; i != vch.size(); ++i)\n-          result |= static_cast<int64_t>(vch[i]) << 8*i;\n-\n-      // If the input vector's most significant byte is 0x80, remove it from\n-      // the result's msb and return a negative.\n-      if (vch.back() & 0x80)\n-          return -(result & ~(0x80ULL << (8 * (vch.size() - 1))));\n-\n-      return result;\n-    }\n-\n-    int64_t m_value;\n-};\n-\n /** Signature hash types/flags */\n enum\n {\n@@ -234,490 +81,8 @@ enum txnouttype\n     TX_NULL_DATA,\n };\n \n-class CNoDestination {\n-public:\n-    friend bool operator==(const CNoDestination &a, const CNoDestination &b) { return true; }\n-    friend bool operator<(const CNoDestination &a, const CNoDestination &b) { return true; }\n-};\n-\n-/** A txout script template with a specific destination. It is either:\n- *  * CNoDestination: no destination set\n- *  * CKeyID: TX_PUBKEYHASH destination\n- *  * CScriptID: TX_SCRIPTHASH destination\n- *  A CTxDestination is the internal data type encoded in a CBitcoinAddress\n- */\n-typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n-\n const char* GetTxnOutputType(txnouttype t);\n \n-/** Script opcodes */\n-enum opcodetype\n-{\n-    // push value\n-    OP_0 = 0x00,\n-    OP_FALSE = OP_0,\n-    OP_PUSHDATA1 = 0x4c,\n-    OP_PUSHDATA2 = 0x4d,\n-    OP_PUSHDATA4 = 0x4e,\n-    OP_1NEGATE = 0x4f,\n-    OP_RESERVED = 0x50,\n-    OP_1 = 0x51,\n-    OP_TRUE=OP_1,\n-    OP_2 = 0x52,\n-    OP_3 = 0x53,\n-    OP_4 = 0x54,\n-    OP_5 = 0x55,\n-    OP_6 = 0x56,\n-    OP_7 = 0x57,\n-    OP_8 = 0x58,\n-    OP_9 = 0x59,\n-    OP_10 = 0x5a,\n-    OP_11 = 0x5b,\n-    OP_12 = 0x5c,\n-    OP_13 = 0x5d,\n-    OP_14 = 0x5e,\n-    OP_15 = 0x5f,\n-    OP_16 = 0x60,\n-\n-    // control\n-    OP_NOP = 0x61,\n-    OP_VER = 0x62,\n-    OP_IF = 0x63,\n-    OP_NOTIF = 0x64,\n-    OP_VERIF = 0x65,\n-    OP_VERNOTIF = 0x66,\n-    OP_ELSE = 0x67,\n-    OP_ENDIF = 0x68,\n-    OP_VERIFY = 0x69,\n-    OP_RETURN = 0x6a,\n-\n-    // stack ops\n-    OP_TOALTSTACK = 0x6b,\n-    OP_FROMALTSTACK = 0x6c,\n-    OP_2DROP = 0x6d,\n-    OP_2DUP = 0x6e,\n-    OP_3DUP = 0x6f,\n-    OP_2OVER = 0x70,\n-    OP_2ROT = 0x71,\n-    OP_2SWAP = 0x72,\n-    OP_IFDUP = 0x73,\n-    OP_DEPTH = 0x74,\n-    OP_DROP = 0x75,\n-    OP_DUP = 0x76,\n-    OP_NIP = 0x77,\n-    OP_OVER = 0x78,\n-    OP_PICK = 0x79,\n-    OP_ROLL = 0x7a,\n-    OP_ROT = 0x7b,\n-    OP_SWAP = 0x7c,\n-    OP_TUCK = 0x7d,\n-\n-    // splice ops\n-    OP_CAT = 0x7e,\n-    OP_SUBSTR = 0x7f,\n-    OP_LEFT = 0x80,\n-    OP_RIGHT = 0x81,\n-    OP_SIZE = 0x82,\n-\n-    // bit logic\n-    OP_INVERT = 0x83,\n-    OP_AND = 0x84,\n-    OP_OR = 0x85,\n-    OP_XOR = 0x86,\n-    OP_EQUAL = 0x87,\n-    OP_EQUALVERIFY = 0x88,\n-    OP_RESERVED1 = 0x89,\n-    OP_RESERVED2 = 0x8a,\n-\n-    // numeric\n-    OP_1ADD = 0x8b,\n-    OP_1SUB = 0x8c,\n-    OP_2MUL = 0x8d,\n-    OP_2DIV = 0x8e,\n-    OP_NEGATE = 0x8f,\n-    OP_ABS = 0x90,\n-    OP_NOT = 0x91,\n-    OP_0NOTEQUAL = 0x92,\n-\n-    OP_ADD = 0x93,\n-    OP_SUB = 0x94,\n-    OP_MUL = 0x95,\n-    OP_DIV = 0x96,\n-    OP_MOD = 0x97,\n-    OP_LSHIFT = 0x98,\n-    OP_RSHIFT = 0x99,\n-\n-    OP_BOOLAND = 0x9a,\n-    OP_BOOLOR = 0x9b,\n-    OP_NUMEQUAL = 0x9c,\n-    OP_NUMEQUALVERIFY = 0x9d,\n-    OP_NUMNOTEQUAL = 0x9e,\n-    OP_LESSTHAN = 0x9f,\n-    OP_GREATERTHAN = 0xa0,\n-    OP_LESSTHANOREQUAL = 0xa1,\n-    OP_GREATERTHANOREQUAL = 0xa2,\n-    OP_MIN = 0xa3,\n-    OP_MAX = 0xa4,\n-\n-    OP_WITHIN = 0xa5,\n-\n-    // crypto\n-    OP_RIPEMD160 = 0xa6,\n-    OP_SHA1 = 0xa7,\n-    OP_SHA256 = 0xa8,\n-    OP_HASH160 = 0xa9,\n-    OP_HASH256 = 0xaa,\n-    OP_CODESEPARATOR = 0xab,\n-    OP_CHECKSIG = 0xac,\n-    OP_CHECKSIGVERIFY = 0xad,\n-    OP_CHECKMULTISIG = 0xae,\n-    OP_CHECKMULTISIGVERIFY = 0xaf,\n-\n-    // expansion\n-    OP_NOP1 = 0xb0,\n-    OP_NOP2 = 0xb1,\n-    OP_NOP3 = 0xb2,\n-    OP_NOP4 = 0xb3,\n-    OP_NOP5 = 0xb4,\n-    OP_NOP6 = 0xb5,\n-    OP_NOP7 = 0xb6,\n-    OP_NOP8 = 0xb7,\n-    OP_NOP9 = 0xb8,\n-    OP_NOP10 = 0xb9,\n-\n-\n-\n-    // template matching params\n-    OP_SMALLDATA = 0xf9,\n-    OP_SMALLINTEGER = 0xfa,\n-    OP_PUBKEYS = 0xfb,\n-    OP_PUBKEYHASH = 0xfd,\n-    OP_PUBKEY = 0xfe,\n-\n-    OP_INVALIDOPCODE = 0xff,\n-};\n-\n-const char* GetOpName(opcodetype opcode);\n-\n-\n-\n-inline std::string ValueString(const std::vector<unsigned char>& vch)\n-{\n-    if (vch.size() <= 4)\n-        return strprintf(\"%d\", CScriptNum(vch).getint());\n-    else\n-        return HexStr(vch);\n-}\n-\n-/** Serialized script, used inside transaction inputs and outputs */\n-class CScript : public std::vector<unsigned char>\n-{\n-protected:\n-    CScript& push_int64(int64_t n)\n-    {\n-        if (n == -1 || (n >= 1 && n <= 16))\n-        {\n-            push_back(n + (OP_1 - 1));\n-        }\n-        else\n-        {\n-            *this << CScriptNum::serialize(n);\n-        }\n-        return *this;\n-    }\n-public:\n-    CScript() { }\n-    CScript(const CScript& b) : std::vector<unsigned char>(b.begin(), b.end()) { }\n-    CScript(const_iterator pbegin, const_iterator pend) : std::vector<unsigned char>(pbegin, pend) { }\n-#ifndef _MSC_VER\n-    CScript(const unsigned char* pbegin, const unsigned char* pend) : std::vector<unsigned char>(pbegin, pend) { }\n-#endif\n-\n-    CScript& operator+=(const CScript& b)\n-    {\n-        insert(end(), b.begin(), b.end());\n-        return *this;\n-    }\n-\n-    friend CScript operator+(const CScript& a, const CScript& b)\n-    {\n-        CScript ret = a;\n-        ret += b;\n-        return ret;\n-    }\n-\n-\n-    CScript(int64_t b)        { operator<<(b); }\n-\n-    explicit CScript(opcodetype b)     { operator<<(b); }\n-    explicit CScript(const uint256& b) { operator<<(b); }\n-    explicit CScript(const CScriptNum& b) { operator<<(b); }\n-    explicit CScript(const std::vector<unsigned char>& b) { operator<<(b); }\n-\n-\n-    CScript& operator<<(int64_t b) { return push_int64(b); }\n-\n-    CScript& operator<<(opcodetype opcode)\n-    {\n-        if (opcode < 0 || opcode > 0xff)\n-            throw std::runtime_error(\"CScript::operator<<() : invalid opcode\");\n-        insert(end(), (unsigned char)opcode);\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const uint160& b)\n-    {\n-        insert(end(), sizeof(b));\n-        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const uint256& b)\n-    {\n-        insert(end(), sizeof(b));\n-        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const CPubKey& key)\n-    {\n-        assert(key.size() < OP_PUSHDATA1);\n-        insert(end(), (unsigned char)key.size());\n-        insert(end(), key.begin(), key.end());\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const CScriptNum& b)\n-    {\n-        *this << b.getvch();\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const std::vector<unsigned char>& b)\n-    {\n-        if (b.size() < OP_PUSHDATA1)\n-        {\n-            insert(end(), (unsigned char)b.size());\n-        }\n-        else if (b.size() <= 0xff)\n-        {\n-            insert(end(), OP_PUSHDATA1);\n-            insert(end(), (unsigned char)b.size());\n-        }\n-        else if (b.size() <= 0xffff)\n-        {\n-            insert(end(), OP_PUSHDATA2);\n-            unsigned short nSize = b.size();\n-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-        }\n-        else\n-        {\n-            insert(end(), OP_PUSHDATA4);\n-            unsigned int nSize = b.size();\n-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-        }\n-        insert(end(), b.begin(), b.end());\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const CScript& b)\n-    {\n-        // I'm not sure if this should push the script or concatenate scripts.\n-        // If there's ever a use for pushing a script onto a script, delete this member fn\n-        assert(!\"Warning: Pushing a CScript onto a CScript with << is probably not intended, use + to concatenate!\");\n-        return *this;\n-    }\n-\n-\n-    bool GetOp(iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet)\n-    {\n-         // Wrapper so it can be called with either iterator or const_iterator\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n-    }\n-\n-    bool GetOp(iterator& pc, opcodetype& opcodeRet)\n-    {\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, NULL);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n-    }\n-\n-    bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n-    {\n-        return GetOp2(pc, opcodeRet, &vchRet);\n-    }\n-\n-    bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n-    {\n-        return GetOp2(pc, opcodeRet, NULL);\n-    }\n-\n-    bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n-    {\n-        opcodeRet = OP_INVALIDOPCODE;\n-        if (pvchRet)\n-            pvchRet->clear();\n-        if (pc >= end())\n-            return false;\n-\n-        // Read instruction\n-        if (end() - pc < 1)\n-            return false;\n-        unsigned int opcode = *pc++;\n-\n-        // Immediate operand\n-        if (opcode <= OP_PUSHDATA4)\n-        {\n-            unsigned int nSize = 0;\n-            if (opcode < OP_PUSHDATA1)\n-            {\n-                nSize = opcode;\n-            }\n-            else if (opcode == OP_PUSHDATA1)\n-            {\n-                if (end() - pc < 1)\n-                    return false;\n-                nSize = *pc++;\n-            }\n-            else if (opcode == OP_PUSHDATA2)\n-            {\n-                if (end() - pc < 2)\n-                    return false;\n-                nSize = 0;\n-                memcpy(&nSize, &pc[0], 2);\n-                pc += 2;\n-            }\n-            else if (opcode == OP_PUSHDATA4)\n-            {\n-                if (end() - pc < 4)\n-                    return false;\n-                memcpy(&nSize, &pc[0], 4);\n-                pc += 4;\n-            }\n-            if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n-                return false;\n-            if (pvchRet)\n-                pvchRet->assign(pc, pc + nSize);\n-            pc += nSize;\n-        }\n-\n-        opcodeRet = (opcodetype)opcode;\n-        return true;\n-    }\n-\n-    // Encode/decode small integers:\n-    static int DecodeOP_N(opcodetype opcode)\n-    {\n-        if (opcode == OP_0)\n-            return 0;\n-        assert(opcode >= OP_1 && opcode <= OP_16);\n-        return (int)opcode - (int)(OP_1 - 1);\n-    }\n-    static opcodetype EncodeOP_N(int n)\n-    {\n-        assert(n >= 0 && n <= 16);\n-        if (n == 0)\n-            return OP_0;\n-        return (opcodetype)(OP_1+n-1);\n-    }\n-\n-    int FindAndDelete(const CScript& b)\n-    {\n-        int nFound = 0;\n-        if (b.empty())\n-            return nFound;\n-        iterator pc = begin();\n-        opcodetype opcode;\n-        do\n-        {\n-            while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n-            {\n-                erase(pc, pc + b.size());\n-                ++nFound;\n-            }\n-        }\n-        while (GetOp(pc, opcode));\n-        return nFound;\n-    }\n-    int Find(opcodetype op) const\n-    {\n-        int nFound = 0;\n-        opcodetype opcode;\n-        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n-            if (opcode == op)\n-                ++nFound;\n-        return nFound;\n-    }\n-\n-    // Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs\n-    // as 20 sigops. With pay-to-script-hash, that changed:\n-    // CHECKMULTISIGs serialized in scriptSigs are\n-    // counted more accurately, assuming they are of the form\n-    //  ... OP_N CHECKMULTISIG ...\n-    unsigned int GetSigOpCount(bool fAccurate) const;\n-\n-    // Accurately count sigOps, including sigOps in\n-    // pay-to-script-hash transactions:\n-    unsigned int GetSigOpCount(const CScript& scriptSig) const;\n-\n-    bool IsPayToScriptHash() const;\n-\n-    // Called by IsStandardTx and P2SH VerifyScript (which makes it consensus-critical).\n-    bool IsPushOnly() const;\n-\n-    // Called by IsStandardTx.\n-    bool HasCanonicalPushes() const;\n-\n-    // Returns whether the script is guaranteed to fail at execution,\n-    // regardless of the initial stack. This allows outputs to be pruned\n-    // instantly when entering the UTXO set.\n-    bool IsUnspendable() const\n-    {\n-        return (size() > 0 && *begin() == OP_RETURN);\n-    }\n-\n-    void SetDestination(const CTxDestination& address);\n-    void SetMultisig(int nRequired, const std::vector<CPubKey>& keys);\n-\n-    std::string ToString() const\n-    {\n-        std::string str;\n-        opcodetype opcode;\n-        std::vector<unsigned char> vch;\n-        const_iterator pc = begin();\n-        while (pc < end())\n-        {\n-            if (!str.empty())\n-                str += \" \";\n-            if (!GetOp(pc, opcode, vch))\n-            {\n-                str += \"[error]\";\n-                return str;\n-            }\n-            if (0 <= opcode && opcode <= OP_PUSHDATA4)\n-                str += ValueString(vch);\n-            else\n-                str += GetOpName(opcode);\n-        }\n-        return str;\n-    }\n-\n-    CScriptID GetID() const\n-    {\n-        return CScriptID(Hash160(*this));\n-    }\n-\n-    void clear()\n-    {\n-        // The default std::vector::clear() does not release memory.\n-        std::vector<unsigned char>().swap(*this);\n-    }\n-};\n-\n /** Compact serializer for scripts.\n  *\n  *  It detects common cases and encodes them much more efficiently."
      },
      {
        "sha": "fe68e9e9744f07e55a3db792a3442dce8e4ff4bf",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -9,7 +9,7 @@\n #include \"data/base58_keys_valid.json.h\"\n \n #include \"key.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "203c20731afc6aacaeeb5ab519b7817174045b35",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -5,7 +5,7 @@\n #include \"key.h\"\n \n #include \"base58.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "aa9b0de4ce89210705600b3b0cbf51575c8450dc",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -5,6 +5,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n+#include \"script/script.h\"\n #include \"scriptutils.h\"\n #include \"uint256.h\"\n "
      },
      {
        "sha": "9136d6229286a2804e660a5a7c7a0c534024b452",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -5,6 +5,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n+#include \"script/script.h\"\n #include \"scriptutils.h\"\n \n #include <vector>"
      },
      {
        "sha": "ff56bdf13bae4ab2f74cbc1def863dba5ab12632",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -8,6 +8,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n+#include \"script/script.h\"\n #include \"scriptutils.h\"\n #include \"core_io.h\"\n "
      },
      {
        "sha": "ac60fa426f895bfbb97f4be1136a7a0c19700595",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"bignum.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include <boost/test/unit_test.hpp>\n #include <limits.h>\n #include <stdint.h>"
      },
      {
        "sha": "1421288eed30ddc0d2158de62ec85e39d1b96fe7",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -6,6 +6,7 @@\n #include \"main.h\"\n #include \"random.h\"\n #include \"serialize.h\"\n+#include \"script/script.h\"\n #include \"scriptutils.h\"\n #include \"util.h\"\n #include \"version.h\""
      },
      {
        "sha": "2d10c356ac1a23b752e03d4e6fdd5b1ba2e3de21",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"key.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"uint256.h\"\n \n #include <vector>"
      },
      {
        "sha": "943568e89d2508c3c3e446c301f8300badf18b3c",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3b64c914aea4c82e53fc1db92c05fc72cacb0924/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "patch": "@@ -8,7 +8,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n #include \"core_io.h\"\n \n #include <map>"
      }
    ]
  },
  {
    "sha": "9e58782428e01db92578bffdf68e64bad45815e0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTU4NzgyNDI4ZTAxZGI5MjU3OGJmZmRmNjhlNjRiYWQ0NTgxNWUw",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-08-27T18:11:41Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-02T14:28:30Z"
      },
      "message": "Separate script/interpreter",
      "tree": {
        "sha": "118f70270493605bf45586bc14a069dc934dc4b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/118f70270493605bf45586bc14a069dc934dc4b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e58782428e01db92578bffdf68e64bad45815e0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e58782428e01db92578bffdf68e64bad45815e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e58782428e01db92578bffdf68e64bad45815e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e58782428e01db92578bffdf68e64bad45815e0/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3b64c914aea4c82e53fc1db92c05fc72cacb0924",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3b64c914aea4c82e53fc1db92c05fc72cacb0924"
      }
    ],
    "stats": {
      "total": 2189,
      "additions": 1101,
      "deletions": 1088
    },
    "files": [
      {
        "sha": "a3fdd3ee6a60544d20faf0b867ef4bd3c02ba043",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -98,6 +98,7 @@ BITCOIN_CORE_H = \\\n   rpcclient.h \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n+  script/interpreter.h \\\n   script/script.h \\\n   scriptutils.h \\\n   serialize.h \\\n@@ -207,6 +208,7 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n+  script/interpreter.cpp \\\n   script/script.cpp \\\n   scriptutils.cpp \\\n   $(BITCOIN_CORE_H)"
      },
      {
        "sha": "2ba04b86aaf4529f243914c0e57f9a6bf4ae6cb3",
        "filename": "src/script/interpreter.cpp",
        "status": "added",
        "additions": 1048,
        "deletions": 0,
        "changes": 1048,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -0,0 +1,1048 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"interpreter.h\"\n+\n+#include \"core.h\"\n+#include \"crypto/ripemd160.h\"\n+#include \"crypto/sha1.h\"\n+#include \"crypto/sha2.h\"\n+#include \"random.h\"\n+#include \"script/script.h\"\n+#include \"uint256.h\"\n+#include \"util.h\"\n+\n+#include <boost/thread.hpp>\n+#include <boost/tuple/tuple_comparison.hpp>\n+\n+using namespace std;\n+\n+typedef vector<unsigned char> valtype;\n+static const valtype vchFalse(0);\n+static const valtype vchZero(0);\n+static const valtype vchTrue(1, 1);\n+static const CScriptNum bnZero(0);\n+static const CScriptNum bnOne(1);\n+static const CScriptNum bnFalse(0);\n+static const CScriptNum bnTrue(1);\n+\n+bool CastToBool(const valtype& vch)\n+{\n+    for (unsigned int i = 0; i < vch.size(); i++)\n+    {\n+        if (vch[i] != 0)\n+        {\n+            // Can be negative zero\n+            if (i == vch.size()-1 && vch[i] == 0x80)\n+                return false;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+//\n+// Script is a stack machine (like Forth) that evaluates a predicate\n+// returning a bool indicating valid or not.  There are no loops.\n+//\n+#define stacktop(i)  (stack.at(stack.size()+(i)))\n+#define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n+static inline void popstack(vector<valtype>& stack)\n+{\n+    if (stack.empty())\n+        throw runtime_error(\"popstack() : stack empty\");\n+    stack.pop_back();\n+}\n+\n+bool IsCanonicalPubKey(const valtype &vchPubKey, unsigned int flags) {\n+    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n+        return true;\n+\n+    if (vchPubKey.size() < 33)\n+        return error(\"Non-canonical public key: too short\");\n+    if (vchPubKey[0] == 0x04) {\n+        if (vchPubKey.size() != 65)\n+            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n+        if (vchPubKey.size() != 33)\n+            return error(\"Non-canonical public key: invalid length for compressed key\");\n+    } else {\n+        return error(\"Non-canonical public key: compressed nor uncompressed\");\n+    }\n+    return true;\n+}\n+\n+bool IsCanonicalSignature(const valtype &vchSig, unsigned int flags) {\n+    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n+        return true;\n+\n+    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n+    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n+    // Where R and S are not negative (their first byte has its highest bit not set), and not\n+    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n+    // in which case a single 0 byte is necessary and even required).\n+    if (vchSig.size() < 9)\n+        return error(\"Non-canonical signature: too short\");\n+    if (vchSig.size() > 73)\n+        return error(\"Non-canonical signature: too long\");\n+    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n+    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n+        return error(\"Non-canonical signature: unknown hashtype byte\");\n+    if (vchSig[0] != 0x30)\n+        return error(\"Non-canonical signature: wrong type\");\n+    if (vchSig[1] != vchSig.size()-3)\n+        return error(\"Non-canonical signature: wrong length marker\");\n+    unsigned int nLenR = vchSig[3];\n+    if (5 + nLenR >= vchSig.size())\n+        return error(\"Non-canonical signature: S length misplaced\");\n+    unsigned int nLenS = vchSig[5+nLenR];\n+    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n+        return error(\"Non-canonical signature: R+S length mismatch\");\n+\n+    const unsigned char *R = &vchSig[4];\n+    if (R[-2] != 0x02)\n+        return error(\"Non-canonical signature: R value type mismatch\");\n+    if (nLenR == 0)\n+        return error(\"Non-canonical signature: R length is zero\");\n+    if (R[0] & 0x80)\n+        return error(\"Non-canonical signature: R value negative\");\n+    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n+        return error(\"Non-canonical signature: R value excessively padded\");\n+\n+    const unsigned char *S = &vchSig[6+nLenR];\n+    if (S[-2] != 0x02)\n+        return error(\"Non-canonical signature: S value type mismatch\");\n+    if (nLenS == 0)\n+        return error(\"Non-canonical signature: S length is zero\");\n+    if (S[0] & 0x80)\n+        return error(\"Non-canonical signature: S value negative\");\n+    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n+        return error(\"Non-canonical signature: S value excessively padded\");\n+\n+    if (flags & SCRIPT_VERIFY_LOW_S) {\n+        // If the S value is above the order of the curve divided by two, its\n+        // complement modulo the order could have been used instead, which is\n+        // one byte shorter when encoded correctly.\n+        if (!CKey::CheckSignatureElement(S, nLenS, true))\n+            return error(\"Non-canonical signature: S value is unnecessarily high\");\n+    }\n+\n+    return true;\n+}\n+\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType)\n+{\n+    CScript::const_iterator pc = script.begin();\n+    CScript::const_iterator pend = script.end();\n+    CScript::const_iterator pbegincodehash = script.begin();\n+    opcodetype opcode;\n+    valtype vchPushValue;\n+    vector<bool> vfExec;\n+    vector<valtype> altstack;\n+    if (script.size() > 10000)\n+        return false;\n+    int nOpCount = 0;\n+\n+    try\n+    {\n+        while (pc < pend)\n+        {\n+            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n+\n+            //\n+            // Read instruction\n+            //\n+            if (!script.GetOp(pc, opcode, vchPushValue))\n+                return false;\n+            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n+                return false;\n+\n+            // Note how OP_RESERVED does not count towards the opcode limit.\n+            if (opcode > OP_16 && ++nOpCount > 201)\n+                return false;\n+\n+            if (opcode == OP_CAT ||\n+                opcode == OP_SUBSTR ||\n+                opcode == OP_LEFT ||\n+                opcode == OP_RIGHT ||\n+                opcode == OP_INVERT ||\n+                opcode == OP_AND ||\n+                opcode == OP_OR ||\n+                opcode == OP_XOR ||\n+                opcode == OP_2MUL ||\n+                opcode == OP_2DIV ||\n+                opcode == OP_MUL ||\n+                opcode == OP_DIV ||\n+                opcode == OP_MOD ||\n+                opcode == OP_LSHIFT ||\n+                opcode == OP_RSHIFT)\n+                return false; // Disabled opcodes.\n+\n+            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n+                stack.push_back(vchPushValue);\n+            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n+            switch (opcode)\n+            {\n+                //\n+                // Push value\n+                //\n+                case OP_1NEGATE:\n+                case OP_1:\n+                case OP_2:\n+                case OP_3:\n+                case OP_4:\n+                case OP_5:\n+                case OP_6:\n+                case OP_7:\n+                case OP_8:\n+                case OP_9:\n+                case OP_10:\n+                case OP_11:\n+                case OP_12:\n+                case OP_13:\n+                case OP_14:\n+                case OP_15:\n+                case OP_16:\n+                {\n+                    // ( -- value)\n+                    CScriptNum bn((int)opcode - (int)(OP_1 - 1));\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+\n+                //\n+                // Control\n+                //\n+                case OP_NOP:\n+                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n+                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n+                break;\n+\n+                case OP_IF:\n+                case OP_NOTIF:\n+                {\n+                    // <expression> if [statements] [else [statements]] endif\n+                    bool fValue = false;\n+                    if (fExec)\n+                    {\n+                        if (stack.size() < 1)\n+                            return false;\n+                        valtype& vch = stacktop(-1);\n+                        fValue = CastToBool(vch);\n+                        if (opcode == OP_NOTIF)\n+                            fValue = !fValue;\n+                        popstack(stack);\n+                    }\n+                    vfExec.push_back(fValue);\n+                }\n+                break;\n+\n+                case OP_ELSE:\n+                {\n+                    if (vfExec.empty())\n+                        return false;\n+                    vfExec.back() = !vfExec.back();\n+                }\n+                break;\n+\n+                case OP_ENDIF:\n+                {\n+                    if (vfExec.empty())\n+                        return false;\n+                    vfExec.pop_back();\n+                }\n+                break;\n+\n+                case OP_VERIFY:\n+                {\n+                    // (true -- ) or\n+                    // (false -- false) and return\n+                    if (stack.size() < 1)\n+                        return false;\n+                    bool fValue = CastToBool(stacktop(-1));\n+                    if (fValue)\n+                        popstack(stack);\n+                    else\n+                        return false;\n+                }\n+                break;\n+\n+                case OP_RETURN:\n+                {\n+                    return false;\n+                }\n+                break;\n+\n+\n+                //\n+                // Stack ops\n+                //\n+                case OP_TOALTSTACK:\n+                {\n+                    if (stack.size() < 1)\n+                        return false;\n+                    altstack.push_back(stacktop(-1));\n+                    popstack(stack);\n+                }\n+                break;\n+\n+                case OP_FROMALTSTACK:\n+                {\n+                    if (altstack.size() < 1)\n+                        return false;\n+                    stack.push_back(altstacktop(-1));\n+                    popstack(altstack);\n+                }\n+                break;\n+\n+                case OP_2DROP:\n+                {\n+                    // (x1 x2 -- )\n+                    if (stack.size() < 2)\n+                        return false;\n+                    popstack(stack);\n+                    popstack(stack);\n+                }\n+                break;\n+\n+                case OP_2DUP:\n+                {\n+                    // (x1 x2 -- x1 x2 x1 x2)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype vch1 = stacktop(-2);\n+                    valtype vch2 = stacktop(-1);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                }\n+                break;\n+\n+                case OP_3DUP:\n+                {\n+                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n+                    if (stack.size() < 3)\n+                        return false;\n+                    valtype vch1 = stacktop(-3);\n+                    valtype vch2 = stacktop(-2);\n+                    valtype vch3 = stacktop(-1);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                    stack.push_back(vch3);\n+                }\n+                break;\n+\n+                case OP_2OVER:\n+                {\n+                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n+                    if (stack.size() < 4)\n+                        return false;\n+                    valtype vch1 = stacktop(-4);\n+                    valtype vch2 = stacktop(-3);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                }\n+                break;\n+\n+                case OP_2ROT:\n+                {\n+                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n+                    if (stack.size() < 6)\n+                        return false;\n+                    valtype vch1 = stacktop(-6);\n+                    valtype vch2 = stacktop(-5);\n+                    stack.erase(stack.end()-6, stack.end()-4);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                }\n+                break;\n+\n+                case OP_2SWAP:\n+                {\n+                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n+                    if (stack.size() < 4)\n+                        return false;\n+                    swap(stacktop(-4), stacktop(-2));\n+                    swap(stacktop(-3), stacktop(-1));\n+                }\n+                break;\n+\n+                case OP_IFDUP:\n+                {\n+                    // (x - 0 | x x)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype vch = stacktop(-1);\n+                    if (CastToBool(vch))\n+                        stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_DEPTH:\n+                {\n+                    // -- stacksize\n+                    CScriptNum bn(stack.size());\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+                case OP_DROP:\n+                {\n+                    // (x -- )\n+                    if (stack.size() < 1)\n+                        return false;\n+                    popstack(stack);\n+                }\n+                break;\n+\n+                case OP_DUP:\n+                {\n+                    // (x -- x x)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype vch = stacktop(-1);\n+                    stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_NIP:\n+                {\n+                    // (x1 x2 -- x2)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    stack.erase(stack.end() - 2);\n+                }\n+                break;\n+\n+                case OP_OVER:\n+                {\n+                    // (x1 x2 -- x1 x2 x1)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype vch = stacktop(-2);\n+                    stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_PICK:\n+                case OP_ROLL:\n+                {\n+                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n+                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    int n = CScriptNum(stacktop(-1)).getint();\n+                    popstack(stack);\n+                    if (n < 0 || n >= (int)stack.size())\n+                        return false;\n+                    valtype vch = stacktop(-n-1);\n+                    if (opcode == OP_ROLL)\n+                        stack.erase(stack.end()-n-1);\n+                    stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_ROT:\n+                {\n+                    // (x1 x2 x3 -- x2 x3 x1)\n+                    //  x2 x1 x3  after first swap\n+                    //  x2 x3 x1  after second swap\n+                    if (stack.size() < 3)\n+                        return false;\n+                    swap(stacktop(-3), stacktop(-2));\n+                    swap(stacktop(-2), stacktop(-1));\n+                }\n+                break;\n+\n+                case OP_SWAP:\n+                {\n+                    // (x1 x2 -- x2 x1)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    swap(stacktop(-2), stacktop(-1));\n+                }\n+                break;\n+\n+                case OP_TUCK:\n+                {\n+                    // (x1 x2 -- x2 x1 x2)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype vch = stacktop(-1);\n+                    stack.insert(stack.end()-2, vch);\n+                }\n+                break;\n+\n+\n+                case OP_SIZE:\n+                {\n+                    // (in -- in size)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    CScriptNum bn(stacktop(-1).size());\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+\n+                //\n+                // Bitwise logic\n+                //\n+                case OP_EQUAL:\n+                case OP_EQUALVERIFY:\n+                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n+                {\n+                    // (x1 x2 - bool)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype& vch1 = stacktop(-2);\n+                    valtype& vch2 = stacktop(-1);\n+                    bool fEqual = (vch1 == vch2);\n+                    // OP_NOTEQUAL is disabled because it would be too easy to say\n+                    // something like n != 1 and have some wiseguy pass in 1 with extra\n+                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n+                    //if (opcode == OP_NOTEQUAL)\n+                    //    fEqual = !fEqual;\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(fEqual ? vchTrue : vchFalse);\n+                    if (opcode == OP_EQUALVERIFY)\n+                    {\n+                        if (fEqual)\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+\n+                //\n+                // Numeric\n+                //\n+                case OP_1ADD:\n+                case OP_1SUB:\n+                case OP_NEGATE:\n+                case OP_ABS:\n+                case OP_NOT:\n+                case OP_0NOTEQUAL:\n+                {\n+                    // (in -- out)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    CScriptNum bn(stacktop(-1));\n+                    switch (opcode)\n+                    {\n+                    case OP_1ADD:       bn += bnOne; break;\n+                    case OP_1SUB:       bn -= bnOne; break;\n+                    case OP_NEGATE:     bn = -bn; break;\n+                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n+                    case OP_NOT:        bn = (bn == bnZero); break;\n+                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n+                    default:            assert(!\"invalid opcode\"); break;\n+                    }\n+                    popstack(stack);\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+                case OP_ADD:\n+                case OP_SUB:\n+                case OP_BOOLAND:\n+                case OP_BOOLOR:\n+                case OP_NUMEQUAL:\n+                case OP_NUMEQUALVERIFY:\n+                case OP_NUMNOTEQUAL:\n+                case OP_LESSTHAN:\n+                case OP_GREATERTHAN:\n+                case OP_LESSTHANOREQUAL:\n+                case OP_GREATERTHANOREQUAL:\n+                case OP_MIN:\n+                case OP_MAX:\n+                {\n+                    // (x1 x2 -- out)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    CScriptNum bn1(stacktop(-2));\n+                    CScriptNum bn2(stacktop(-1));\n+                    CScriptNum bn(0);\n+                    switch (opcode)\n+                    {\n+                    case OP_ADD:\n+                        bn = bn1 + bn2;\n+                        break;\n+\n+                    case OP_SUB:\n+                        bn = bn1 - bn2;\n+                        break;\n+\n+                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n+                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n+                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n+                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n+                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n+                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n+                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n+                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n+                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n+                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n+                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n+                    default:                     assert(!\"invalid opcode\"); break;\n+                    }\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(bn.getvch());\n+\n+                    if (opcode == OP_NUMEQUALVERIFY)\n+                    {\n+                        if (CastToBool(stacktop(-1)))\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+                case OP_WITHIN:\n+                {\n+                    // (x min max -- out)\n+                    if (stack.size() < 3)\n+                        return false;\n+                    CScriptNum bn1(stacktop(-3));\n+                    CScriptNum bn2(stacktop(-2));\n+                    CScriptNum bn3(stacktop(-1));\n+                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(fValue ? vchTrue : vchFalse);\n+                }\n+                break;\n+\n+\n+                //\n+                // Crypto\n+                //\n+                case OP_RIPEMD160:\n+                case OP_SHA1:\n+                case OP_SHA256:\n+                case OP_HASH160:\n+                case OP_HASH256:\n+                {\n+                    // (in -- hash)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype& vch = stacktop(-1);\n+                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n+                    if (opcode == OP_RIPEMD160)\n+                        CRIPEMD160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_SHA1)\n+                        CSHA1().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_SHA256)\n+                        CSHA256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_HASH160)\n+                        CHash160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_HASH256)\n+                        CHash256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    popstack(stack);\n+                    stack.push_back(vchHash);\n+                }\n+                break;\n+\n+                case OP_CODESEPARATOR:\n+                {\n+                    // Hash starts after the code separator\n+                    pbegincodehash = pc;\n+                }\n+                break;\n+\n+                case OP_CHECKSIG:\n+                case OP_CHECKSIGVERIFY:\n+                {\n+                    // (sig pubkey -- bool)\n+                    if (stack.size() < 2)\n+                        return false;\n+\n+                    valtype& vchSig    = stacktop(-2);\n+                    valtype& vchPubKey = stacktop(-1);\n+\n+                    // Subset of script starting at the most recent codeseparator\n+                    CScript scriptCode(pbegincodehash, pend);\n+\n+                    // Drop the signature, since there's no way for a signature to sign itself\n+                    scriptCode.FindAndDelete(CScript(vchSig));\n+\n+                    bool fSuccess = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n+                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n+\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+                    if (opcode == OP_CHECKSIGVERIFY)\n+                    {\n+                        if (fSuccess)\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+                case OP_CHECKMULTISIG:\n+                case OP_CHECKMULTISIGVERIFY:\n+                {\n+                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n+\n+                    int i = 1;\n+                    if ((int)stack.size() < i)\n+                        return false;\n+\n+                    int nKeysCount = CScriptNum(stacktop(-i)).getint();\n+                    if (nKeysCount < 0 || nKeysCount > 20)\n+                        return false;\n+                    nOpCount += nKeysCount;\n+                    if (nOpCount > 201)\n+                        return false;\n+                    int ikey = ++i;\n+                    i += nKeysCount;\n+                    if ((int)stack.size() < i)\n+                        return false;\n+\n+                    int nSigsCount = CScriptNum(stacktop(-i)).getint();\n+                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n+                        return false;\n+                    int isig = ++i;\n+                    i += nSigsCount;\n+                    if ((int)stack.size() < i)\n+                        return false;\n+\n+                    // Subset of script starting at the most recent codeseparator\n+                    CScript scriptCode(pbegincodehash, pend);\n+\n+                    // Drop the signatures, since there's no way for a signature to sign itself\n+                    for (int k = 0; k < nSigsCount; k++)\n+                    {\n+                        valtype& vchSig = stacktop(-isig-k);\n+                        scriptCode.FindAndDelete(CScript(vchSig));\n+                    }\n+\n+                    bool fSuccess = true;\n+                    while (fSuccess && nSigsCount > 0)\n+                    {\n+                        valtype& vchSig    = stacktop(-isig);\n+                        valtype& vchPubKey = stacktop(-ikey);\n+\n+                        // Check signature\n+                        bool fOk = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n+                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n+\n+                        if (fOk) {\n+                            isig++;\n+                            nSigsCount--;\n+                        }\n+                        ikey++;\n+                        nKeysCount--;\n+\n+                        // If there are more signatures left than keys left,\n+                        // then too many signatures have failed\n+                        if (nSigsCount > nKeysCount)\n+                            fSuccess = false;\n+                    }\n+\n+                    // Clean up stack of actual arguments\n+                    while (i-- > 1)\n+                        popstack(stack);\n+\n+                    // A bug causes CHECKMULTISIG to consume one extra argument\n+                    // whose contents were not checked in any way.\n+                    //\n+                    // Unfortunately this is a potential source of mutability,\n+                    // so optionally verify it is exactly equal to zero prior\n+                    // to removing it from the stack.\n+                    if (stack.size() < 1)\n+                        return false;\n+                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n+                        return error(\"CHECKMULTISIG dummy argument not null\");\n+                    popstack(stack);\n+\n+                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+\n+                    if (opcode == OP_CHECKMULTISIGVERIFY)\n+                    {\n+                        if (fSuccess)\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+                default:\n+                    return false;\n+            }\n+\n+            // Size limits\n+            if (stack.size() + altstack.size() > 1000)\n+                return false;\n+        }\n+    }\n+    catch (...)\n+    {\n+        return false;\n+    }\n+\n+    if (!vfExec.empty())\n+        return false;\n+\n+    return true;\n+}\n+\n+namespace {\n+\n+/** Wrapper that serializes like CTransaction, but with the modifications\n+ *  required for the signature hash done in-place\n+ */\n+class CTransactionSignatureSerializer {\n+private:\n+    const CTransaction &txTo;  // reference to the spending transaction (the one being serialized)\n+    const CScript &scriptCode; // output script being consumed\n+    const unsigned int nIn;    // input index of txTo being signed\n+    const bool fAnyoneCanPay;  // whether the hashtype has the SIGHASH_ANYONECANPAY flag set\n+    const bool fHashSingle;    // whether the hashtype is SIGHASH_SINGLE\n+    const bool fHashNone;      // whether the hashtype is SIGHASH_NONE\n+\n+public:\n+    CTransactionSignatureSerializer(const CTransaction &txToIn, const CScript &scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n+        txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n+        fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n+        fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n+        fHashNone((nHashTypeIn & 0x1f) == SIGHASH_NONE) {}\n+\n+    /** Serialize the passed scriptCode, skipping OP_CODESEPARATORs */\n+    template<typename S>\n+    void SerializeScriptCode(S &s, int nType, int nVersion) const {\n+        CScript::const_iterator it = scriptCode.begin();\n+        CScript::const_iterator itBegin = it;\n+        opcodetype opcode;\n+        unsigned int nCodeSeparators = 0;\n+        while (scriptCode.GetOp(it, opcode)) {\n+            if (opcode == OP_CODESEPARATOR)\n+                nCodeSeparators++;\n+        }\n+        ::WriteCompactSize(s, scriptCode.size() - nCodeSeparators);\n+        it = itBegin;\n+        while (scriptCode.GetOp(it, opcode)) {\n+            if (opcode == OP_CODESEPARATOR) {\n+                s.write((char*)&itBegin[0], it-itBegin-1);\n+                itBegin = it;\n+            }\n+        }\n+        s.write((char*)&itBegin[0], it-itBegin);\n+    }\n+\n+    /** Serialize an input of txTo */\n+    template<typename S>\n+    void SerializeInput(S &s, unsigned int nInput, int nType, int nVersion) const {\n+        // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized\n+        if (fAnyoneCanPay)\n+            nInput = nIn;\n+        // Serialize the prevout\n+        ::Serialize(s, txTo.vin[nInput].prevout, nType, nVersion);\n+        // Serialize the script\n+        if (nInput != nIn)\n+            // Blank out other inputs' signatures\n+            ::Serialize(s, CScript(), nType, nVersion);\n+        else\n+            SerializeScriptCode(s, nType, nVersion);\n+        // Serialize the nSequence\n+        if (nInput != nIn && (fHashSingle || fHashNone))\n+            // let the others update at will\n+            ::Serialize(s, (int)0, nType, nVersion);\n+        else\n+            ::Serialize(s, txTo.vin[nInput].nSequence, nType, nVersion);\n+    }\n+\n+    /** Serialize an output of txTo */\n+    template<typename S>\n+    void SerializeOutput(S &s, unsigned int nOutput, int nType, int nVersion) const {\n+        if (fHashSingle && nOutput != nIn)\n+            // Do not lock-in the txout payee at other indices as txin\n+            ::Serialize(s, CTxOut(), nType, nVersion);\n+        else\n+            ::Serialize(s, txTo.vout[nOutput], nType, nVersion);\n+    }\n+\n+    /** Serialize txTo */\n+    template<typename S>\n+    void Serialize(S &s, int nType, int nVersion) const {\n+        // Serialize nVersion\n+        ::Serialize(s, txTo.nVersion, nType, nVersion);\n+        // Serialize vin\n+        unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();\n+        ::WriteCompactSize(s, nInputs);\n+        for (unsigned int nInput = 0; nInput < nInputs; nInput++)\n+             SerializeInput(s, nInput, nType, nVersion);\n+        // Serialize vout\n+        unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());\n+        ::WriteCompactSize(s, nOutputs);\n+        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)\n+             SerializeOutput(s, nOutput, nType, nVersion);\n+        // Serialie nLockTime\n+        ::Serialize(s, txTo.nLockTime, nType, nVersion);\n+    }\n+};\n+\n+} // anon namespace\n+\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+{\n+    if (nIn >= txTo.vin.size()) {\n+        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+        return 1;\n+    }\n+\n+    // Check for invalid use of SIGHASH_SINGLE\n+    if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n+        if (nIn >= txTo.vout.size()) {\n+            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n+            return 1;\n+        }\n+    }\n+\n+    // Wrapper to serialize only the necessary parts of the transaction being signed\n+    CTransactionSignatureSerializer txTmp(txTo, scriptCode, nIn, nHashType);\n+\n+    // Serialize and hash\n+    CHashWriter ss(SER_GETHASH, 0);\n+    ss << txTmp << nHashType;\n+    return ss.GetHash();\n+}\n+\n+// Valid signature cache, to avoid doing expensive ECDSA signature checking\n+// twice for every transaction (once when accepted into memory pool, and\n+// again when accepted into the block chain)\n+class CSignatureCache\n+{\n+private:\n+     // sigdata_type is (signature hash, signature, public key):\n+    typedef boost::tuple<uint256, std::vector<unsigned char>, CPubKey> sigdata_type;\n+    std::set< sigdata_type> setValid;\n+    boost::shared_mutex cs_sigcache;\n+\n+public:\n+    bool\n+    Get(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n+    {\n+        boost::shared_lock<boost::shared_mutex> lock(cs_sigcache);\n+\n+        sigdata_type k(hash, vchSig, pubKey);\n+        std::set<sigdata_type>::iterator mi = setValid.find(k);\n+        if (mi != setValid.end())\n+            return true;\n+        return false;\n+    }\n+\n+    void Set(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n+    {\n+        // DoS prevention: limit cache size to less than 10MB\n+        // (~200 bytes per cache entry times 50,000 entries)\n+        // Since there are a maximum of 20,000 signature operations per block\n+        // 50,000 is a reasonable default.\n+        int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n+        if (nMaxCacheSize <= 0) return;\n+\n+        boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n+\n+        while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n+        {\n+            // Evict a random entry. Random because that helps\n+            // foil would-be DoS attackers who might try to pre-generate\n+            // and re-use a set of valid signatures just-slightly-greater\n+            // than our cache size.\n+            uint256 randomHash = GetRandHash();\n+            std::vector<unsigned char> unused;\n+            std::set<sigdata_type>::iterator it =\n+                setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n+            if (it == setValid.end())\n+                it = setValid.begin();\n+            setValid.erase(*it);\n+        }\n+\n+        sigdata_type k(hash, vchSig, pubKey);\n+        setValid.insert(k);\n+    }\n+};\n+\n+bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags)\n+{\n+    static CSignatureCache signatureCache;\n+\n+    CPubKey pubkey(vchPubKey);\n+    if (!pubkey.IsValid())\n+        return false;\n+\n+    // Hash type is one byte tacked on to the end of the signature\n+    if (vchSig.empty())\n+        return false;\n+    if (nHashType == 0)\n+        nHashType = vchSig.back();\n+    else if (nHashType != vchSig.back())\n+        return false;\n+    vchSig.pop_back();\n+\n+    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n+\n+    if (signatureCache.Get(sighash, vchSig, pubkey))\n+        return true;\n+\n+    if (!pubkey.Verify(sighash, vchSig))\n+        return false;\n+\n+    if (!(flags & SCRIPT_VERIFY_NOCACHE))\n+        signatureCache.Set(sighash, vchSig, pubkey);\n+\n+    return true;\n+}\n+\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                  unsigned int flags, int nHashType)\n+{\n+    vector<vector<unsigned char> > stack, stackCopy;\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, flags, nHashType))\n+        return false;\n+    if (flags & SCRIPT_VERIFY_P2SH)\n+        stackCopy = stack;\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, flags, nHashType))\n+        return false;\n+    if (stack.empty())\n+        return false;\n+\n+    if (CastToBool(stack.back()) == false)\n+        return false;\n+\n+    // Additional validation for spend-to-script-hash transactions:\n+    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n+    {\n+        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n+            return false;            // or validation fails\n+\n+        // stackCopy cannot be empty here, because if it was the\n+        // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n+        // an empty stack and the EvalScript above would return false.\n+        assert(!stackCopy.empty());\n+\n+        const valtype& pubKeySerialized = stackCopy.back();\n+        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n+        popstack(stackCopy);\n+\n+        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, flags, nHashType))\n+            return false;\n+        if (stackCopy.empty())\n+            return false;\n+        return CastToBool(stackCopy.back());\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "0c6f8b9d134a89fc246db20213144c0673c10716",
        "filename": "src/script/interpreter.h",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -0,0 +1,45 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef H_BITCOIN_SCRIPT_INTERPRETER\n+#define H_BITCOIN_SCRIPT_INTERPRETER\n+\n+#include <vector>\n+#include <stdint.h>\n+#include <string>\n+\n+class uint256;\n+class CScript;\n+class CTransaction;\n+\n+/** Signature hash types/flags */\n+enum\n+{\n+    SIGHASH_ALL = 1,\n+    SIGHASH_NONE = 2,\n+    SIGHASH_SINGLE = 3,\n+    SIGHASH_ANYONECANPAY = 0x80,\n+};\n+\n+/** Script verification flags */\n+enum\n+{\n+    SCRIPT_VERIFY_NONE      = 0,\n+    SCRIPT_VERIFY_P2SH      = (1U << 0), // evaluate P2SH (BIP16) subscripts\n+    SCRIPT_VERIFY_STRICTENC = (1U << 1), // enforce strict conformance to DER and SEC2 for signatures and pubkeys\n+    SCRIPT_VERIFY_LOW_S     = (1U << 2), // enforce low S values (<n/2) in signatures (depends on STRICTENC)\n+    SCRIPT_VERIFY_NOCACHE   = (1U << 3), // do not store results in signature cache (but do query it)\n+    SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n+};\n+\n+bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey, unsigned int flags);\n+bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig, unsigned int flags);\n+\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+bool CheckSig(std::vector<unsigned char> vchSig, const std::vector<unsigned char> &vchPubKey, const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+\n+#endif"
      },
      {
        "sha": "fb3766ab158d86f014789eb524a9630081100f6d",
        "filename": "src/scriptutils.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1060,
        "changes": 1060,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -5,69 +5,17 @@\n \n #include \"scriptutils.h\"\n \n-#include \"crypto/ripemd160.h\"\n-#include \"crypto/sha1.h\"\n-#include \"crypto/sha2.h\"\n #include \"core.h\"\n-#include \"hash.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n-#include \"random.h\"\n-#include \"sync.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n \n-#include <boost/foreach.hpp>\n-#include <boost/thread.hpp>\n-#include <boost/tuple/tuple_comparison.hpp>\n-#include <boost/tuple/tuple.hpp>\n-\n #include <boost/foreach.hpp>\n \n using namespace std;\n-using namespace boost;\n \n typedef vector<unsigned char> valtype;\n-static const valtype vchFalse(0);\n-static const valtype vchZero(0);\n-static const valtype vchTrue(1, 1);\n-static const CScriptNum bnZero(0);\n-static const CScriptNum bnOne(1);\n-static const CScriptNum bnFalse(0);\n-static const CScriptNum bnTrue(1);\n-\n-bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags);\n-\n-bool CastToBool(const valtype& vch)\n-{\n-    for (unsigned int i = 0; i < vch.size(); i++)\n-    {\n-        if (vch[i] != 0)\n-        {\n-            // Can be negative zero\n-            if (i == vch.size()-1 && vch[i] == 0x80)\n-                return false;\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-\n-\n-//\n-// Script is a stack machine (like Forth) that evaluates a predicate\n-// returning a bool indicating valid or not.  There are no loops.\n-//\n-#define stacktop(i)  (stack.at(stack.size()+(i)))\n-#define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n-static inline void popstack(vector<valtype>& stack)\n-{\n-    if (stack.empty())\n-        throw runtime_error(\"popstack() : stack empty\");\n-    stack.pop_back();\n-}\n-\n \n const char* GetTxnOutputType(txnouttype t)\n {\n@@ -83,972 +31,6 @@ const char* GetTxnOutputType(txnouttype t)\n     return NULL;\n }\n \n-bool IsCanonicalPubKey(const valtype &vchPubKey, unsigned int flags) {\n-    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n-        return true;\n-\n-    if (vchPubKey.size() < 33)\n-        return error(\"Non-canonical public key: too short\");\n-    if (vchPubKey[0] == 0x04) {\n-        if (vchPubKey.size() != 65)\n-            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n-    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n-        if (vchPubKey.size() != 33)\n-            return error(\"Non-canonical public key: invalid length for compressed key\");\n-    } else {\n-        return error(\"Non-canonical public key: compressed nor uncompressed\");\n-    }\n-    return true;\n-}\n-\n-bool IsCanonicalSignature(const valtype &vchSig, unsigned int flags) {\n-    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n-        return true;\n-\n-    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n-    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n-    // Where R and S are not negative (their first byte has its highest bit not set), and not\n-    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n-    // in which case a single 0 byte is necessary and even required).\n-    if (vchSig.size() < 9)\n-        return error(\"Non-canonical signature: too short\");\n-    if (vchSig.size() > 73)\n-        return error(\"Non-canonical signature: too long\");\n-    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n-    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n-        return error(\"Non-canonical signature: unknown hashtype byte\");\n-    if (vchSig[0] != 0x30)\n-        return error(\"Non-canonical signature: wrong type\");\n-    if (vchSig[1] != vchSig.size()-3)\n-        return error(\"Non-canonical signature: wrong length marker\");\n-    unsigned int nLenR = vchSig[3];\n-    if (5 + nLenR >= vchSig.size())\n-        return error(\"Non-canonical signature: S length misplaced\");\n-    unsigned int nLenS = vchSig[5+nLenR];\n-    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n-        return error(\"Non-canonical signature: R+S length mismatch\");\n-\n-    const unsigned char *R = &vchSig[4];\n-    if (R[-2] != 0x02)\n-        return error(\"Non-canonical signature: R value type mismatch\");\n-    if (nLenR == 0)\n-        return error(\"Non-canonical signature: R length is zero\");\n-    if (R[0] & 0x80)\n-        return error(\"Non-canonical signature: R value negative\");\n-    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n-        return error(\"Non-canonical signature: R value excessively padded\");\n-\n-    const unsigned char *S = &vchSig[6+nLenR];\n-    if (S[-2] != 0x02)\n-        return error(\"Non-canonical signature: S value type mismatch\");\n-    if (nLenS == 0)\n-        return error(\"Non-canonical signature: S length is zero\");\n-    if (S[0] & 0x80)\n-        return error(\"Non-canonical signature: S value negative\");\n-    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n-        return error(\"Non-canonical signature: S value excessively padded\");\n-\n-    if (flags & SCRIPT_VERIFY_LOW_S) {\n-        // If the S value is above the order of the curve divided by two, its\n-        // complement modulo the order could have been used instead, which is\n-        // one byte shorter when encoded correctly.\n-        if (!CKey::CheckSignatureElement(S, nLenS, true))\n-            return error(\"Non-canonical signature: S value is unnecessarily high\");\n-    }\n-\n-    return true;\n-}\n-\n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType)\n-{\n-    CScript::const_iterator pc = script.begin();\n-    CScript::const_iterator pend = script.end();\n-    CScript::const_iterator pbegincodehash = script.begin();\n-    opcodetype opcode;\n-    valtype vchPushValue;\n-    vector<bool> vfExec;\n-    vector<valtype> altstack;\n-    if (script.size() > 10000)\n-        return false;\n-    int nOpCount = 0;\n-\n-    try\n-    {\n-        while (pc < pend)\n-        {\n-            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n-\n-            //\n-            // Read instruction\n-            //\n-            if (!script.GetOp(pc, opcode, vchPushValue))\n-                return false;\n-            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-                return false;\n-\n-            // Note how OP_RESERVED does not count towards the opcode limit.\n-            if (opcode > OP_16 && ++nOpCount > 201)\n-                return false;\n-\n-            if (opcode == OP_CAT ||\n-                opcode == OP_SUBSTR ||\n-                opcode == OP_LEFT ||\n-                opcode == OP_RIGHT ||\n-                opcode == OP_INVERT ||\n-                opcode == OP_AND ||\n-                opcode == OP_OR ||\n-                opcode == OP_XOR ||\n-                opcode == OP_2MUL ||\n-                opcode == OP_2DIV ||\n-                opcode == OP_MUL ||\n-                opcode == OP_DIV ||\n-                opcode == OP_MOD ||\n-                opcode == OP_LSHIFT ||\n-                opcode == OP_RSHIFT)\n-                return false; // Disabled opcodes.\n-\n-            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n-                stack.push_back(vchPushValue);\n-            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n-            switch (opcode)\n-            {\n-                //\n-                // Push value\n-                //\n-                case OP_1NEGATE:\n-                case OP_1:\n-                case OP_2:\n-                case OP_3:\n-                case OP_4:\n-                case OP_5:\n-                case OP_6:\n-                case OP_7:\n-                case OP_8:\n-                case OP_9:\n-                case OP_10:\n-                case OP_11:\n-                case OP_12:\n-                case OP_13:\n-                case OP_14:\n-                case OP_15:\n-                case OP_16:\n-                {\n-                    // ( -- value)\n-                    CScriptNum bn((int)opcode - (int)(OP_1 - 1));\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-\n-                //\n-                // Control\n-                //\n-                case OP_NOP:\n-                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n-                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n-                break;\n-\n-                case OP_IF:\n-                case OP_NOTIF:\n-                {\n-                    // <expression> if [statements] [else [statements]] endif\n-                    bool fValue = false;\n-                    if (fExec)\n-                    {\n-                        if (stack.size() < 1)\n-                            return false;\n-                        valtype& vch = stacktop(-1);\n-                        fValue = CastToBool(vch);\n-                        if (opcode == OP_NOTIF)\n-                            fValue = !fValue;\n-                        popstack(stack);\n-                    }\n-                    vfExec.push_back(fValue);\n-                }\n-                break;\n-\n-                case OP_ELSE:\n-                {\n-                    if (vfExec.empty())\n-                        return false;\n-                    vfExec.back() = !vfExec.back();\n-                }\n-                break;\n-\n-                case OP_ENDIF:\n-                {\n-                    if (vfExec.empty())\n-                        return false;\n-                    vfExec.pop_back();\n-                }\n-                break;\n-\n-                case OP_VERIFY:\n-                {\n-                    // (true -- ) or\n-                    // (false -- false) and return\n-                    if (stack.size() < 1)\n-                        return false;\n-                    bool fValue = CastToBool(stacktop(-1));\n-                    if (fValue)\n-                        popstack(stack);\n-                    else\n-                        return false;\n-                }\n-                break;\n-\n-                case OP_RETURN:\n-                {\n-                    return false;\n-                }\n-                break;\n-\n-\n-                //\n-                // Stack ops\n-                //\n-                case OP_TOALTSTACK:\n-                {\n-                    if (stack.size() < 1)\n-                        return false;\n-                    altstack.push_back(stacktop(-1));\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_FROMALTSTACK:\n-                {\n-                    if (altstack.size() < 1)\n-                        return false;\n-                    stack.push_back(altstacktop(-1));\n-                    popstack(altstack);\n-                }\n-                break;\n-\n-                case OP_2DROP:\n-                {\n-                    // (x1 x2 -- )\n-                    if (stack.size() < 2)\n-                        return false;\n-                    popstack(stack);\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_2DUP:\n-                {\n-                    // (x1 x2 -- x1 x2 x1 x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch1 = stacktop(-2);\n-                    valtype vch2 = stacktop(-1);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_3DUP:\n-                {\n-                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    valtype vch1 = stacktop(-3);\n-                    valtype vch2 = stacktop(-2);\n-                    valtype vch3 = stacktop(-1);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                    stack.push_back(vch3);\n-                }\n-                break;\n-\n-                case OP_2OVER:\n-                {\n-                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n-                    if (stack.size() < 4)\n-                        return false;\n-                    valtype vch1 = stacktop(-4);\n-                    valtype vch2 = stacktop(-3);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_2ROT:\n-                {\n-                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n-                    if (stack.size() < 6)\n-                        return false;\n-                    valtype vch1 = stacktop(-6);\n-                    valtype vch2 = stacktop(-5);\n-                    stack.erase(stack.end()-6, stack.end()-4);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_2SWAP:\n-                {\n-                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n-                    if (stack.size() < 4)\n-                        return false;\n-                    swap(stacktop(-4), stacktop(-2));\n-                    swap(stacktop(-3), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_IFDUP:\n-                {\n-                    // (x - 0 | x x)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    if (CastToBool(vch))\n-                        stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_DEPTH:\n-                {\n-                    // -- stacksize\n-                    CScriptNum bn(stack.size());\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-                case OP_DROP:\n-                {\n-                    // (x -- )\n-                    if (stack.size() < 1)\n-                        return false;\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_DUP:\n-                {\n-                    // (x -- x x)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_NIP:\n-                {\n-                    // (x1 x2 -- x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    stack.erase(stack.end() - 2);\n-                }\n-                break;\n-\n-                case OP_OVER:\n-                {\n-                    // (x1 x2 -- x1 x2 x1)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch = stacktop(-2);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_PICK:\n-                case OP_ROLL:\n-                {\n-                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n-                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    int n = CScriptNum(stacktop(-1)).getint();\n-                    popstack(stack);\n-                    if (n < 0 || n >= (int)stack.size())\n-                        return false;\n-                    valtype vch = stacktop(-n-1);\n-                    if (opcode == OP_ROLL)\n-                        stack.erase(stack.end()-n-1);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_ROT:\n-                {\n-                    // (x1 x2 x3 -- x2 x3 x1)\n-                    //  x2 x1 x3  after first swap\n-                    //  x2 x3 x1  after second swap\n-                    if (stack.size() < 3)\n-                        return false;\n-                    swap(stacktop(-3), stacktop(-2));\n-                    swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_SWAP:\n-                {\n-                    // (x1 x2 -- x2 x1)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_TUCK:\n-                {\n-                    // (x1 x2 -- x2 x1 x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    stack.insert(stack.end()-2, vch);\n-                }\n-                break;\n-\n-\n-                case OP_SIZE:\n-                {\n-                    // (in -- in size)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    CScriptNum bn(stacktop(-1).size());\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-\n-                //\n-                // Bitwise logic\n-                //\n-                case OP_EQUAL:\n-                case OP_EQUALVERIFY:\n-                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n-                {\n-                    // (x1 x2 - bool)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype& vch1 = stacktop(-2);\n-                    valtype& vch2 = stacktop(-1);\n-                    bool fEqual = (vch1 == vch2);\n-                    // OP_NOTEQUAL is disabled because it would be too easy to say\n-                    // something like n != 1 and have some wiseguy pass in 1 with extra\n-                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n-                    //if (opcode == OP_NOTEQUAL)\n-                    //    fEqual = !fEqual;\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fEqual ? vchTrue : vchFalse);\n-                    if (opcode == OP_EQUALVERIFY)\n-                    {\n-                        if (fEqual)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-\n-                //\n-                // Numeric\n-                //\n-                case OP_1ADD:\n-                case OP_1SUB:\n-                case OP_NEGATE:\n-                case OP_ABS:\n-                case OP_NOT:\n-                case OP_0NOTEQUAL:\n-                {\n-                    // (in -- out)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    CScriptNum bn(stacktop(-1));\n-                    switch (opcode)\n-                    {\n-                    case OP_1ADD:       bn += bnOne; break;\n-                    case OP_1SUB:       bn -= bnOne; break;\n-                    case OP_NEGATE:     bn = -bn; break;\n-                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n-                    case OP_NOT:        bn = (bn == bnZero); break;\n-                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n-                    default:            assert(!\"invalid opcode\"); break;\n-                    }\n-                    popstack(stack);\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-                case OP_ADD:\n-                case OP_SUB:\n-                case OP_BOOLAND:\n-                case OP_BOOLOR:\n-                case OP_NUMEQUAL:\n-                case OP_NUMEQUALVERIFY:\n-                case OP_NUMNOTEQUAL:\n-                case OP_LESSTHAN:\n-                case OP_GREATERTHAN:\n-                case OP_LESSTHANOREQUAL:\n-                case OP_GREATERTHANOREQUAL:\n-                case OP_MIN:\n-                case OP_MAX:\n-                {\n-                    // (x1 x2 -- out)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    CScriptNum bn1(stacktop(-2));\n-                    CScriptNum bn2(stacktop(-1));\n-                    CScriptNum bn(0);\n-                    switch (opcode)\n-                    {\n-                    case OP_ADD:\n-                        bn = bn1 + bn2;\n-                        break;\n-\n-                    case OP_SUB:\n-                        bn = bn1 - bn2;\n-                        break;\n-\n-                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n-                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n-                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n-                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n-                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n-                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n-                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n-                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n-                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n-                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n-                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n-                    default:                     assert(!\"invalid opcode\"); break;\n-                    }\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(bn.getvch());\n-\n-                    if (opcode == OP_NUMEQUALVERIFY)\n-                    {\n-                        if (CastToBool(stacktop(-1)))\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                case OP_WITHIN:\n-                {\n-                    // (x min max -- out)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    CScriptNum bn1(stacktop(-3));\n-                    CScriptNum bn2(stacktop(-2));\n-                    CScriptNum bn3(stacktop(-1));\n-                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n-                    popstack(stack);\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fValue ? vchTrue : vchFalse);\n-                }\n-                break;\n-\n-\n-                //\n-                // Crypto\n-                //\n-                case OP_RIPEMD160:\n-                case OP_SHA1:\n-                case OP_SHA256:\n-                case OP_HASH160:\n-                case OP_HASH256:\n-                {\n-                    // (in -- hash)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype& vch = stacktop(-1);\n-                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n-                    if (opcode == OP_RIPEMD160)\n-                        CRIPEMD160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_SHA1)\n-                        CSHA1().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_SHA256)\n-                        CSHA256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_HASH160)\n-                        CHash160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_HASH256)\n-                        CHash256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    popstack(stack);\n-                    stack.push_back(vchHash);\n-                }\n-                break;\n-\n-                case OP_CODESEPARATOR:\n-                {\n-                    // Hash starts after the code separator\n-                    pbegincodehash = pc;\n-                }\n-                break;\n-\n-                case OP_CHECKSIG:\n-                case OP_CHECKSIGVERIFY:\n-                {\n-                    // (sig pubkey -- bool)\n-                    if (stack.size() < 2)\n-                        return false;\n-\n-                    valtype& vchSig    = stacktop(-2);\n-                    valtype& vchPubKey = stacktop(-1);\n-\n-                    // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n-\n-                    // Drop the signature, since there's no way for a signature to sign itself\n-                    scriptCode.FindAndDelete(CScript(vchSig));\n-\n-                    bool fSuccess = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n-                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n-\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-                    if (opcode == OP_CHECKSIGVERIFY)\n-                    {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                case OP_CHECKMULTISIG:\n-                case OP_CHECKMULTISIGVERIFY:\n-                {\n-                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n-\n-                    int i = 1;\n-                    if ((int)stack.size() < i)\n-                        return false;\n-\n-                    int nKeysCount = CScriptNum(stacktop(-i)).getint();\n-                    if (nKeysCount < 0 || nKeysCount > 20)\n-                        return false;\n-                    nOpCount += nKeysCount;\n-                    if (nOpCount > 201)\n-                        return false;\n-                    int ikey = ++i;\n-                    i += nKeysCount;\n-                    if ((int)stack.size() < i)\n-                        return false;\n-\n-                    int nSigsCount = CScriptNum(stacktop(-i)).getint();\n-                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n-                        return false;\n-                    int isig = ++i;\n-                    i += nSigsCount;\n-                    if ((int)stack.size() < i)\n-                        return false;\n-\n-                    // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n-\n-                    // Drop the signatures, since there's no way for a signature to sign itself\n-                    for (int k = 0; k < nSigsCount; k++)\n-                    {\n-                        valtype& vchSig = stacktop(-isig-k);\n-                        scriptCode.FindAndDelete(CScript(vchSig));\n-                    }\n-\n-                    bool fSuccess = true;\n-                    while (fSuccess && nSigsCount > 0)\n-                    {\n-                        valtype& vchSig    = stacktop(-isig);\n-                        valtype& vchPubKey = stacktop(-ikey);\n-\n-                        // Check signature\n-                        bool fOk = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n-                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n-\n-                        if (fOk) {\n-                            isig++;\n-                            nSigsCount--;\n-                        }\n-                        ikey++;\n-                        nKeysCount--;\n-\n-                        // If there are more signatures left than keys left,\n-                        // then too many signatures have failed\n-                        if (nSigsCount > nKeysCount)\n-                            fSuccess = false;\n-                    }\n-\n-                    // Clean up stack of actual arguments\n-                    while (i-- > 1)\n-                        popstack(stack);\n-\n-                    // A bug causes CHECKMULTISIG to consume one extra argument\n-                    // whose contents were not checked in any way.\n-                    //\n-                    // Unfortunately this is a potential source of mutability,\n-                    // so optionally verify it is exactly equal to zero prior\n-                    // to removing it from the stack.\n-                    if (stack.size() < 1)\n-                        return false;\n-                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n-                        return error(\"CHECKMULTISIG dummy argument not null\");\n-                    popstack(stack);\n-\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-\n-                    if (opcode == OP_CHECKMULTISIGVERIFY)\n-                    {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                default:\n-                    return false;\n-            }\n-\n-            // Size limits\n-            if (stack.size() + altstack.size() > 1000)\n-                return false;\n-        }\n-    }\n-    catch (...)\n-    {\n-        return false;\n-    }\n-\n-\n-    if (!vfExec.empty())\n-        return false;\n-\n-    return true;\n-}\n-\n-\n-\n-\n-\n-\n-\n-namespace {\n-\n-/** Wrapper that serializes like CTransaction, but with the modifications\n- *  required for the signature hash done in-place\n- */\n-class CTransactionSignatureSerializer {\n-private:\n-    const CTransaction &txTo;  // reference to the spending transaction (the one being serialized)\n-    const CScript &scriptCode; // output script being consumed\n-    const unsigned int nIn;    // input index of txTo being signed\n-    const bool fAnyoneCanPay;  // whether the hashtype has the SIGHASH_ANYONECANPAY flag set\n-    const bool fHashSingle;    // whether the hashtype is SIGHASH_SINGLE\n-    const bool fHashNone;      // whether the hashtype is SIGHASH_NONE\n-\n-public:\n-    CTransactionSignatureSerializer(const CTransaction &txToIn, const CScript &scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n-        txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n-        fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n-        fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n-        fHashNone((nHashTypeIn & 0x1f) == SIGHASH_NONE) {}\n-\n-    /** Serialize the passed scriptCode, skipping OP_CODESEPARATORs */\n-    template<typename S>\n-    void SerializeScriptCode(S &s, int nType, int nVersion) const {\n-        CScript::const_iterator it = scriptCode.begin();\n-        CScript::const_iterator itBegin = it;\n-        opcodetype opcode;\n-        unsigned int nCodeSeparators = 0;\n-        while (scriptCode.GetOp(it, opcode)) {\n-            if (opcode == OP_CODESEPARATOR)\n-                nCodeSeparators++;\n-        }\n-        ::WriteCompactSize(s, scriptCode.size() - nCodeSeparators);\n-        it = itBegin;\n-        while (scriptCode.GetOp(it, opcode)) {\n-            if (opcode == OP_CODESEPARATOR) {\n-                s.write((char*)&itBegin[0], it-itBegin-1);\n-                itBegin = it;\n-            }\n-        }\n-        s.write((char*)&itBegin[0], it-itBegin);\n-    }\n-\n-    /** Serialize an input of txTo */\n-    template<typename S>\n-    void SerializeInput(S &s, unsigned int nInput, int nType, int nVersion) const {\n-        // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized\n-        if (fAnyoneCanPay)\n-            nInput = nIn;\n-        // Serialize the prevout\n-        ::Serialize(s, txTo.vin[nInput].prevout, nType, nVersion);\n-        // Serialize the script\n-        if (nInput != nIn)\n-            // Blank out other inputs' signatures\n-            ::Serialize(s, CScript(), nType, nVersion);\n-        else\n-            SerializeScriptCode(s, nType, nVersion);\n-        // Serialize the nSequence\n-        if (nInput != nIn && (fHashSingle || fHashNone))\n-            // let the others update at will\n-            ::Serialize(s, (int)0, nType, nVersion);\n-        else\n-            ::Serialize(s, txTo.vin[nInput].nSequence, nType, nVersion);\n-    }\n-\n-    /** Serialize an output of txTo */\n-    template<typename S>\n-    void SerializeOutput(S &s, unsigned int nOutput, int nType, int nVersion) const {\n-        if (fHashSingle && nOutput != nIn)\n-            // Do not lock-in the txout payee at other indices as txin\n-            ::Serialize(s, CTxOut(), nType, nVersion);\n-        else\n-            ::Serialize(s, txTo.vout[nOutput], nType, nVersion);\n-    }\n-\n-    /** Serialize txTo */\n-    template<typename S>\n-    void Serialize(S &s, int nType, int nVersion) const {\n-        // Serialize nVersion\n-        ::Serialize(s, txTo.nVersion, nType, nVersion);\n-        // Serialize vin\n-        unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();\n-        ::WriteCompactSize(s, nInputs);\n-        for (unsigned int nInput = 0; nInput < nInputs; nInput++)\n-             SerializeInput(s, nInput, nType, nVersion);\n-        // Serialize vout\n-        unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());\n-        ::WriteCompactSize(s, nOutputs);\n-        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)\n-             SerializeOutput(s, nOutput, nType, nVersion);\n-        // Serialie nLockTime\n-        ::Serialize(s, txTo.nLockTime, nType, nVersion);\n-    }\n-};\n-\n-} // anon namespace\n-\n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n-{\n-    if (nIn >= txTo.vin.size()) {\n-        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n-        return 1;\n-    }\n-\n-    // Check for invalid use of SIGHASH_SINGLE\n-    if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n-        if (nIn >= txTo.vout.size()) {\n-            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n-            return 1;\n-        }\n-    }\n-\n-    // Wrapper to serialize only the necessary parts of the transaction being signed\n-    CTransactionSignatureSerializer txTmp(txTo, scriptCode, nIn, nHashType);\n-\n-    // Serialize and hash\n-    CHashWriter ss(SER_GETHASH, 0);\n-    ss << txTmp << nHashType;\n-    return ss.GetHash();\n-}\n-\n-// Valid signature cache, to avoid doing expensive ECDSA signature checking\n-// twice for every transaction (once when accepted into memory pool, and\n-// again when accepted into the block chain)\n-class CSignatureCache\n-{\n-private:\n-     // sigdata_type is (signature hash, signature, public key):\n-    typedef boost::tuple<uint256, std::vector<unsigned char>, CPubKey> sigdata_type;\n-    std::set< sigdata_type> setValid;\n-    boost::shared_mutex cs_sigcache;\n-\n-public:\n-    bool\n-    Get(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n-    {\n-        boost::shared_lock<boost::shared_mutex> lock(cs_sigcache);\n-\n-        sigdata_type k(hash, vchSig, pubKey);\n-        std::set<sigdata_type>::iterator mi = setValid.find(k);\n-        if (mi != setValid.end())\n-            return true;\n-        return false;\n-    }\n-\n-    void Set(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n-    {\n-        // DoS prevention: limit cache size to less than 10MB\n-        // (~200 bytes per cache entry times 50,000 entries)\n-        // Since there are a maximum of 20,000 signature operations per block\n-        // 50,000 is a reasonable default.\n-        int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n-        if (nMaxCacheSize <= 0) return;\n-\n-        boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n-\n-        while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n-        {\n-            // Evict a random entry. Random because that helps\n-            // foil would-be DoS attackers who might try to pre-generate\n-            // and re-use a set of valid signatures just-slightly-greater\n-            // than our cache size.\n-            uint256 randomHash = GetRandHash();\n-            std::vector<unsigned char> unused;\n-            std::set<sigdata_type>::iterator it =\n-                setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n-            if (it == setValid.end())\n-                it = setValid.begin();\n-            setValid.erase(*it);\n-        }\n-\n-        sigdata_type k(hash, vchSig, pubKey);\n-        setValid.insert(k);\n-    }\n-};\n-\n-bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode,\n-              const CTransaction& txTo, unsigned int nIn, int nHashType, int flags)\n-{\n-    static CSignatureCache signatureCache;\n-\n-    CPubKey pubkey(vchPubKey);\n-    if (!pubkey.IsValid())\n-        return false;\n-\n-    // Hash type is one byte tacked on to the end of the signature\n-    if (vchSig.empty())\n-        return false;\n-    if (nHashType == 0)\n-        nHashType = vchSig.back();\n-    else if (nHashType != vchSig.back())\n-        return false;\n-    vchSig.pop_back();\n-\n-    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n-\n-    if (signatureCache.Get(sighash, vchSig, pubkey))\n-        return true;\n-\n-    if (!pubkey.Verify(sighash, vchSig))\n-        return false;\n-\n-    if (!(flags & SCRIPT_VERIFY_NOCACHE))\n-        signatureCache.Set(sighash, vchSig, pubkey);\n-\n-    return true;\n-}\n-\n-\n-\n-\n-\n-\n-\n-\n-\n //\n // Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n //\n@@ -1461,48 +443,6 @@ void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey,\n     CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                  unsigned int flags, int nHashType)\n-{\n-    vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, flags, nHashType))\n-        return false;\n-    if (flags & SCRIPT_VERIFY_P2SH)\n-        stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, flags, nHashType))\n-        return false;\n-    if (stack.empty())\n-        return false;\n-\n-    if (CastToBool(stack.back()) == false)\n-        return false;\n-\n-    // Additional validation for spend-to-script-hash transactions:\n-    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n-    {\n-        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n-            return false;            // or validation fails\n-\n-        // stackCopy cannot be empty here, because if it was the\n-        // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n-        // an empty stack and the EvalScript above would return false.\n-        assert(!stackCopy.empty());\n-\n-        const valtype& pubKeySerialized = stackCopy.back();\n-        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n-        popstack(stackCopy);\n-\n-        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, flags, nHashType))\n-            return false;\n-        if (stackCopy.empty())\n-            return false;\n-        return CastToBool(stackCopy.back());\n-    }\n-\n-    return true;\n-}\n-\n-\n bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());"
      },
      {
        "sha": "1df95b1fa08c1636e8cb1bea133f8142d8b15792",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 1,
        "deletions": 26,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"key.h\"\n #include \"script/script.h\"\n+#include \"script/interpreter.h\"\n \n #include <stdexcept>\n #include <stdint.h>\n@@ -20,26 +21,6 @@ struct CMutableTransaction;\n \n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n-/** Signature hash types/flags */\n-enum\n-{\n-    SIGHASH_ALL = 1,\n-    SIGHASH_NONE = 2,\n-    SIGHASH_SINGLE = 3,\n-    SIGHASH_ANYONECANPAY = 0x80,\n-};\n-\n-/** Script verification flags */\n-enum\n-{\n-    SCRIPT_VERIFY_NONE      = 0,\n-    SCRIPT_VERIFY_P2SH      = (1U << 0), // evaluate P2SH (BIP16) subscripts\n-    SCRIPT_VERIFY_STRICTENC = (1U << 1), // enforce strict conformance to DER and SEC2 for signatures and pubkeys\n-    SCRIPT_VERIFY_LOW_S     = (1U << 2), // enforce low S values (<n/2) in signatures (depends on STRICTENC)\n-    SCRIPT_VERIFY_NOCACHE   = (1U << 3), // do not store results in signature cache (but do query it)\n-    SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n-};\n-\n /** IsMine() return codes */\n enum isminetype\n {\n@@ -156,11 +137,6 @@ class CScriptCompressor\n     }\n };\n \n-bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey, unsigned int flags);\n-bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig, unsigned int flags);\n-\n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n@@ -171,7 +147,6 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n \n // Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n // combine them intelligently and return the result."
      },
      {
        "sha": "a17099de72752307ddfe015f985abaf9221c1bb3",
        "filename": "src/test/canonical_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/test/canonical_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/test/canonical_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/canonical_tests.cpp?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -8,9 +8,11 @@\n \n #include \"data/sig_noncanonical.json.h\"\n #include \"data/sig_canonical.json.h\"\n+#include \"key.h\"\n #include \"random.h\"\n-#include \"scriptutils.h\"\n+#include \"script/interpreter.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n \n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "e28682522bbe0661fccc82619fc5a13a1402ea70",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -6,6 +6,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n+#include \"script/interpreter.h\"\n #include \"scriptutils.h\"\n #include \"uint256.h\"\n "
      },
      {
        "sha": "8abde887ceef9c828bb968e641c4dff6a41b31f1",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e58782428e01db92578bffdf68e64bad45815e0/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e58782428e01db92578bffdf68e64bad45815e0/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=9e58782428e01db92578bffdf68e64bad45815e0",
        "patch": "@@ -7,7 +7,7 @@\n #include \"random.h\"\n #include \"serialize.h\"\n #include \"script/script.h\"\n-#include \"scriptutils.h\"\n+#include \"script/interpreter.h\"\n #include \"util.h\"\n #include \"version.h\"\n "
      }
    ]
  },
  {
    "sha": "fbff412eb239595cf30f21e115ef0be97e379f8b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYmZmNDEyZWIyMzk1OTVjZjMwZjIxZTExNWVmMGJlOTdlMzc5Zjhi",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@monetize.io",
        "date": "2014-08-23T01:35:51Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-02T14:28:30Z"
      },
      "message": "Separate script/standard",
      "tree": {
        "sha": "ed5dfb3212a03e9c0936bb6a9b398f57ade6054a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed5dfb3212a03e9c0936bb6a9b398f57ade6054a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fbff412eb239595cf30f21e115ef0be97e379f8b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbff412eb239595cf30f21e115ef0be97e379f8b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fbff412eb239595cf30f21e115ef0be97e379f8b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbff412eb239595cf30f21e115ef0be97e379f8b/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e58782428e01db92578bffdf68e64bad45815e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e58782428e01db92578bffdf68e64bad45815e0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e58782428e01db92578bffdf68e64bad45815e0"
      }
    ],
    "stats": {
      "total": 607,
      "additions": 324,
      "deletions": 283
    },
    "files": [
      {
        "sha": "c3e2f7ed824319b3a78c9ccee574023cc14ce68f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -100,6 +100,7 @@ BITCOIN_CORE_H = \\\n   rpcserver.h \\\n   script/interpreter.h \\\n   script/script.h \\\n+  script/standard.h \\\n   scriptutils.h \\\n   serialize.h \\\n   sync.h \\\n@@ -210,6 +211,7 @@ libbitcoin_common_a_SOURCES = \\\n   protocol.cpp \\\n   script/interpreter.cpp \\\n   script/script.cpp \\\n+  script/standard.cpp \\\n   scriptutils.cpp \\\n   $(BITCOIN_CORE_H)\n "
      },
      {
        "sha": "3f12304bb20f0e5737d3ac277592558b171a8bca",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -8,6 +8,8 @@\n #include \"core.h\"\n #include \"main.h\"         // for MAX_BLOCK_SIZE\n #include \"keystore.h\"\n+#include \"script/script.h\"\n+#include \"scriptutils.h\"\n #include \"ui_interface.h\" // for _(...)\n #include \"univalue/univalue.h\"\n #include \"core_io.h\""
      },
      {
        "sha": "cef74a3a545a2a79b1d69c7f3cfe146399576725",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -5,7 +5,8 @@\n #include \"bloom.h\"\n \n #include \"core.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n \n #include <math.h>\n #include <stdlib.h>"
      },
      {
        "sha": "62712b1ba061a1cf44eb6011e9860be8ccd5815d",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -4,7 +4,8 @@\n \n #include \"core_io.h\"\n #include \"univalue/univalue.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n #include \"core.h\"\n #include \"serialize.h\"\n #include \"util.h\""
      },
      {
        "sha": "ad1c1fbcee19f318f6d784f270da5d29898424ba",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -15,7 +15,8 @@\n #include \"core.h\"\n #include \"net.h\"\n #include \"pow.h\"\n-#include \"scriptutils.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n #include \"sync.h\"\n #include \"txmempool.h\"\n #include \"uint256.h\""
      },
      {
        "sha": "a8904a2313263aede27819b4addbfedfae69d33f",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -11,6 +11,8 @@\n #include \"main.h\"\n #include \"net.h\"\n #include \"rpcserver.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n #include \"uint256.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet.h\""
      },
      {
        "sha": "684edff4d23049554cfcf3e09255a4b7231ac547",
        "filename": "src/script/standard.cpp",
        "status": "added",
        "additions": 254,
        "deletions": 0,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -0,0 +1,254 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script/standard.h\"\n+\n+#include \"script/script.h\"\n+#include \"util.h\"\n+\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+typedef vector<unsigned char> valtype;\n+\n+const char* GetTxnOutputType(txnouttype t)\n+{\n+    switch (t)\n+    {\n+    case TX_NONSTANDARD: return \"nonstandard\";\n+    case TX_PUBKEY: return \"pubkey\";\n+    case TX_PUBKEYHASH: return \"pubkeyhash\";\n+    case TX_SCRIPTHASH: return \"scripthash\";\n+    case TX_MULTISIG: return \"multisig\";\n+    case TX_NULL_DATA: return \"nulldata\";\n+    }\n+    return NULL;\n+}\n+\n+//\n+// Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n+//\n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n+{\n+    // Templates\n+    static multimap<txnouttype, CScript> mTemplates;\n+    if (mTemplates.empty())\n+    {\n+        // Standard tx, sender provides pubkey, receiver adds signature\n+        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n+\n+        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n+        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n+\n+        // Sender provides N pubkeys, receivers provides M signatures\n+        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n+\n+        // Empty, provably prunable, data-carrying output\n+        if (GetBoolArg(\"-datacarrier\", true))\n+            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN << OP_SMALLDATA));\n+        mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN));\n+    }\n+\n+    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n+    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n+    if (scriptPubKey.IsPayToScriptHash())\n+    {\n+        typeRet = TX_SCRIPTHASH;\n+        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n+        vSolutionsRet.push_back(hashBytes);\n+        return true;\n+    }\n+\n+    // Scan templates\n+    const CScript& script1 = scriptPubKey;\n+    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n+    {\n+        const CScript& script2 = tplate.second;\n+        vSolutionsRet.clear();\n+\n+        opcodetype opcode1, opcode2;\n+        vector<unsigned char> vch1, vch2;\n+\n+        // Compare\n+        CScript::const_iterator pc1 = script1.begin();\n+        CScript::const_iterator pc2 = script2.begin();\n+        while (true)\n+        {\n+            if (pc1 == script1.end() && pc2 == script2.end())\n+            {\n+                // Found a match\n+                typeRet = tplate.first;\n+                if (typeRet == TX_MULTISIG)\n+                {\n+                    // Additional checks for TX_MULTISIG:\n+                    unsigned char m = vSolutionsRet.front()[0];\n+                    unsigned char n = vSolutionsRet.back()[0];\n+                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n+                        return false;\n+                }\n+                return true;\n+            }\n+            if (!script1.GetOp(pc1, opcode1, vch1))\n+                break;\n+            if (!script2.GetOp(pc2, opcode2, vch2))\n+                break;\n+\n+            // Template matching opcodes:\n+            if (opcode2 == OP_PUBKEYS)\n+            {\n+                while (vch1.size() >= 33 && vch1.size() <= 65)\n+                {\n+                    vSolutionsRet.push_back(vch1);\n+                    if (!script1.GetOp(pc1, opcode1, vch1))\n+                        break;\n+                }\n+                if (!script2.GetOp(pc2, opcode2, vch2))\n+                    break;\n+                // Normal situation is to fall through\n+                // to other if/else statements\n+            }\n+\n+            if (opcode2 == OP_PUBKEY)\n+            {\n+                if (vch1.size() < 33 || vch1.size() > 65)\n+                    break;\n+                vSolutionsRet.push_back(vch1);\n+            }\n+            else if (opcode2 == OP_PUBKEYHASH)\n+            {\n+                if (vch1.size() != sizeof(uint160))\n+                    break;\n+                vSolutionsRet.push_back(vch1);\n+            }\n+            else if (opcode2 == OP_SMALLINTEGER)\n+            {   // Single-byte small integer pushed onto vSolutions\n+                if (opcode1 == OP_0 ||\n+                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n+                {\n+                    char n = (char)CScript::DecodeOP_N(opcode1);\n+                    vSolutionsRet.push_back(valtype(1, n));\n+                }\n+                else\n+                    break;\n+            }\n+            else if (opcode2 == OP_SMALLDATA)\n+            {\n+                // small pushdata, <= MAX_OP_RETURN_RELAY bytes\n+                if (vch1.size() > MAX_OP_RETURN_RELAY)\n+                    break;\n+            }\n+            else if (opcode1 != opcode2 || vch1 != vch2)\n+            {\n+                // Others must match exactly\n+                break;\n+            }\n+        }\n+    }\n+\n+    vSolutionsRet.clear();\n+    typeRet = TX_NONSTANDARD;\n+    return false;\n+}\n+\n+int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n+{\n+    switch (t)\n+    {\n+    case TX_NONSTANDARD:\n+    case TX_NULL_DATA:\n+        return -1;\n+    case TX_PUBKEY:\n+        return 1;\n+    case TX_PUBKEYHASH:\n+        return 2;\n+    case TX_MULTISIG:\n+        if (vSolutions.size() < 1 || vSolutions[0].size() < 1)\n+            return -1;\n+        return vSolutions[0][0] + 1;\n+    case TX_SCRIPTHASH:\n+        return 1; // doesn't include args needed by the script\n+    }\n+    return -1;\n+}\n+\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)\n+{\n+    vector<valtype> vSolutions;\n+    if (!Solver(scriptPubKey, whichType, vSolutions))\n+        return false;\n+\n+    if (whichType == TX_MULTISIG)\n+    {\n+        unsigned char m = vSolutions.front()[0];\n+        unsigned char n = vSolutions.back()[0];\n+        // Support up to x-of-3 multisig txns as standard\n+        if (n < 1 || n > 3)\n+            return false;\n+        if (m < 1 || m > n)\n+            return false;\n+    }\n+\n+    return whichType != TX_NONSTANDARD;\n+}\n+\n+bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n+{\n+    vector<valtype> vSolutions;\n+    txnouttype whichType;\n+    if (!Solver(scriptPubKey, whichType, vSolutions))\n+        return false;\n+\n+    if (whichType == TX_PUBKEY)\n+    {\n+        addressRet = CPubKey(vSolutions[0]).GetID();\n+        return true;\n+    }\n+    else if (whichType == TX_PUBKEYHASH)\n+    {\n+        addressRet = CKeyID(uint160(vSolutions[0]));\n+        return true;\n+    }\n+    else if (whichType == TX_SCRIPTHASH)\n+    {\n+        addressRet = CScriptID(uint160(vSolutions[0]));\n+        return true;\n+    }\n+    // Multisig txns have more than one address...\n+    return false;\n+}\n+\n+bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n+{\n+    addressRet.clear();\n+    typeRet = TX_NONSTANDARD;\n+    vector<valtype> vSolutions;\n+    if (!Solver(scriptPubKey, typeRet, vSolutions))\n+        return false;\n+    if (typeRet == TX_NULL_DATA){\n+        // This is data, not addresses\n+        return false;\n+    }\n+\n+    if (typeRet == TX_MULTISIG)\n+    {\n+        nRequiredRet = vSolutions.front()[0];\n+        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n+        {\n+            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n+            addressRet.push_back(address);\n+        }\n+    }\n+    else\n+    {\n+        nRequiredRet = 1;\n+        CTxDestination address;\n+        if (!ExtractDestination(scriptPubKey, address))\n+           return false;\n+        addressRet.push_back(address);\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "18092e879e7ec55e848f53b6e72a480b881b7818",
        "filename": "src/script/standard.h",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -0,0 +1,56 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef H_BITCOIN_SCRIPT_STANDARD\n+#define H_BITCOIN_SCRIPT_STANDARD\n+\n+#include \"script/script.h\"\n+#include \"script/interpreter.h\"\n+\n+#include <stdint.h>\n+\n+class CScript;\n+\n+static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n+\n+// Mandatory script verification flags that all new blocks must comply with for\n+// them to be valid. (but old blocks may not comply with) Currently just P2SH,\n+// but in the future other flags may be added, such as a soft-fork to enforce\n+// strict DER encoding.\n+//\n+// Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n+// details.\n+static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n+\n+// Standard script verification flags that standard transactions will comply\n+// with. However scripts violating these flags may still be present in valid\n+// blocks and we must accept those blocks.\n+static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n+                                                         SCRIPT_VERIFY_STRICTENC |\n+                                                         SCRIPT_VERIFY_NULLDUMMY;\n+\n+// For convenience, standard but not mandatory verify flags.\n+static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n+\n+enum txnouttype\n+{\n+    TX_NONSTANDARD,\n+    // 'standard' transaction types:\n+    TX_PUBKEY,\n+    TX_PUBKEYHASH,\n+    TX_SCRIPTHASH,\n+    TX_MULTISIG,\n+    TX_NULL_DATA,\n+};\n+\n+const char* GetTxnOutputType(txnouttype t);\n+\n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n+int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n+bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet);\n+bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n+\n+#endif"
      },
      {
        "sha": "cede11d6a7481da477156b1034f9822bd7473b35",
        "filename": "src/scriptutils.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 241,
        "changes": 241,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -17,146 +17,6 @@ using namespace std;\n \n typedef vector<unsigned char> valtype;\n \n-const char* GetTxnOutputType(txnouttype t)\n-{\n-    switch (t)\n-    {\n-    case TX_NONSTANDARD: return \"nonstandard\";\n-    case TX_PUBKEY: return \"pubkey\";\n-    case TX_PUBKEYHASH: return \"pubkeyhash\";\n-    case TX_SCRIPTHASH: return \"scripthash\";\n-    case TX_MULTISIG: return \"multisig\";\n-    case TX_NULL_DATA: return \"nulldata\";\n-    }\n-    return NULL;\n-}\n-\n-//\n-// Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n-//\n-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n-{\n-    // Templates\n-    static multimap<txnouttype, CScript> mTemplates;\n-    if (mTemplates.empty())\n-    {\n-        // Standard tx, sender provides pubkey, receiver adds signature\n-        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n-\n-        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n-\n-        // Sender provides N pubkeys, receivers provides M signatures\n-        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n-\n-        // Empty, provably prunable, data-carrying output\n-        if (GetBoolArg(\"-datacarrier\", true))\n-            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN << OP_SMALLDATA));\n-        mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN));\n-    }\n-\n-    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n-    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n-    if (scriptPubKey.IsPayToScriptHash())\n-    {\n-        typeRet = TX_SCRIPTHASH;\n-        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n-        vSolutionsRet.push_back(hashBytes);\n-        return true;\n-    }\n-\n-    // Scan templates\n-    const CScript& script1 = scriptPubKey;\n-    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n-    {\n-        const CScript& script2 = tplate.second;\n-        vSolutionsRet.clear();\n-\n-        opcodetype opcode1, opcode2;\n-        vector<unsigned char> vch1, vch2;\n-\n-        // Compare\n-        CScript::const_iterator pc1 = script1.begin();\n-        CScript::const_iterator pc2 = script2.begin();\n-        while (true)\n-        {\n-            if (pc1 == script1.end() && pc2 == script2.end())\n-            {\n-                // Found a match\n-                typeRet = tplate.first;\n-                if (typeRet == TX_MULTISIG)\n-                {\n-                    // Additional checks for TX_MULTISIG:\n-                    unsigned char m = vSolutionsRet.front()[0];\n-                    unsigned char n = vSolutionsRet.back()[0];\n-                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n-                        return false;\n-                }\n-                return true;\n-            }\n-            if (!script1.GetOp(pc1, opcode1, vch1))\n-                break;\n-            if (!script2.GetOp(pc2, opcode2, vch2))\n-                break;\n-\n-            // Template matching opcodes:\n-            if (opcode2 == OP_PUBKEYS)\n-            {\n-                while (vch1.size() >= 33 && vch1.size() <= 65)\n-                {\n-                    vSolutionsRet.push_back(vch1);\n-                    if (!script1.GetOp(pc1, opcode1, vch1))\n-                        break;\n-                }\n-                if (!script2.GetOp(pc2, opcode2, vch2))\n-                    break;\n-                // Normal situation is to fall through\n-                // to other if/else statements\n-            }\n-\n-            if (opcode2 == OP_PUBKEY)\n-            {\n-                if (vch1.size() < 33 || vch1.size() > 65)\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_PUBKEYHASH)\n-            {\n-                if (vch1.size() != sizeof(uint160))\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_SMALLINTEGER)\n-            {   // Single-byte small integer pushed onto vSolutions\n-                if (opcode1 == OP_0 ||\n-                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n-                {\n-                    char n = (char)CScript::DecodeOP_N(opcode1);\n-                    vSolutionsRet.push_back(valtype(1, n));\n-                }\n-                else\n-                    break;\n-            }\n-            else if (opcode2 == OP_SMALLDATA)\n-            {\n-                // small pushdata, <= MAX_OP_RETURN_RELAY bytes\n-                if (vch1.size() > MAX_OP_RETURN_RELAY)\n-                    break;\n-            }\n-            else if (opcode1 != opcode2 || vch1 != vch2)\n-            {\n-                // Others must match exactly\n-                break;\n-            }\n-        }\n-    }\n-\n-    vSolutionsRet.clear();\n-    typeRet = TX_NONSTANDARD;\n-    return false;\n-}\n-\n-\n bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n {\n     CKey key;\n@@ -231,48 +91,6 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n     return false;\n }\n \n-int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n-{\n-    switch (t)\n-    {\n-    case TX_NONSTANDARD:\n-    case TX_NULL_DATA:\n-        return -1;\n-    case TX_PUBKEY:\n-        return 1;\n-    case TX_PUBKEYHASH:\n-        return 2;\n-    case TX_MULTISIG:\n-        if (vSolutions.size() < 1 || vSolutions[0].size() < 1)\n-            return -1;\n-        return vSolutions[0][0] + 1;\n-    case TX_SCRIPTHASH:\n-        return 1; // doesn't include args needed by the script\n-    }\n-    return -1;\n-}\n-\n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)\n-{\n-    vector<valtype> vSolutions;\n-    if (!Solver(scriptPubKey, whichType, vSolutions))\n-        return false;\n-\n-    if (whichType == TX_MULTISIG)\n-    {\n-        unsigned char m = vSolutions.front()[0];\n-        unsigned char n = vSolutions.back()[0];\n-        // Support up to x-of-3 multisig txns as standard\n-        if (n < 1 || n > 3)\n-            return false;\n-        if (m < 1 || m > n)\n-            return false;\n-    }\n-\n-    return whichType != TX_NONSTANDARD;\n-}\n-\n-\n unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n {\n     unsigned int nResult = 0;\n@@ -348,65 +166,6 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n     return ISMINE_NO;\n }\n \n-bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n-{\n-    vector<valtype> vSolutions;\n-    txnouttype whichType;\n-    if (!Solver(scriptPubKey, whichType, vSolutions))\n-        return false;\n-\n-    if (whichType == TX_PUBKEY)\n-    {\n-        addressRet = CPubKey(vSolutions[0]).GetID();\n-        return true;\n-    }\n-    else if (whichType == TX_PUBKEYHASH)\n-    {\n-        addressRet = CKeyID(uint160(vSolutions[0]));\n-        return true;\n-    }\n-    else if (whichType == TX_SCRIPTHASH)\n-    {\n-        addressRet = CScriptID(uint160(vSolutions[0]));\n-        return true;\n-    }\n-    // Multisig txns have more than one address...\n-    return false;\n-}\n-\n-bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n-{\n-    addressRet.clear();\n-    typeRet = TX_NONSTANDARD;\n-    vector<valtype> vSolutions;\n-    if (!Solver(scriptPubKey, typeRet, vSolutions))\n-        return false;\n-    if (typeRet == TX_NULL_DATA){\n-        // This is data, not addresses\n-        return false;\n-    }\n-\n-    if (typeRet == TX_MULTISIG)\n-    {\n-        nRequiredRet = vSolutions.front()[0];\n-        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n-        {\n-            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n-            addressRet.push_back(address);\n-        }\n-    }\n-    else\n-    {\n-        nRequiredRet = 1;\n-        CTxDestination address;\n-        if (!ExtractDestination(scriptPubKey, address))\n-           return false;\n-        addressRet.push_back(address);\n-    }\n-\n-    return true;\n-}\n-\n class CAffectedKeysVisitor : public boost::static_visitor<void> {\n private:\n     const CKeyStore &keystore;"
      },
      {
        "sha": "7ea2c9e6a59e824fbb4d113162a65a9aca55e95b",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 1,
        "deletions": 39,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -9,6 +9,7 @@\n #include \"key.h\"\n #include \"script/script.h\"\n #include \"script/interpreter.h\"\n+#include \"script/standard.h\"\n \n #include <stdexcept>\n #include <stdint.h>\n@@ -19,8 +20,6 @@ class CKeyStore;\n class CTransaction;\n struct CMutableTransaction;\n \n-static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n-\n /** IsMine() return codes */\n enum isminetype\n {\n@@ -32,38 +31,6 @@ enum isminetype\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-// Mandatory script verification flags that all new blocks must comply with for\n-// them to be valid. (but old blocks may not comply with) Currently just P2SH,\n-// but in the future other flags may be added, such as a soft-fork to enforce\n-// strict DER encoding.\n-//\n-// Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n-// details.\n-static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n-\n-// Standard script verification flags that standard transactions will comply\n-// with. However scripts violating these flags may still be present in valid\n-// blocks and we must accept those blocks.\n-static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n-                                                         SCRIPT_VERIFY_STRICTENC |\n-                                                         SCRIPT_VERIFY_NULLDUMMY;\n-\n-// For convenience, standard but not mandatory verify flags.\n-static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n-\n-enum txnouttype\n-{\n-    TX_NONSTANDARD,\n-    // 'standard' transaction types:\n-    TX_PUBKEY,\n-    TX_PUBKEYHASH,\n-    TX_SCRIPTHASH,\n-    TX_MULTISIG,\n-    TX_NULL_DATA,\n-};\n-\n-const char* GetTxnOutputType(txnouttype t);\n-\n /** Compact serializer for scripts.\n  *\n  *  It detects common cases and encodes them much more efficiently.\n@@ -137,14 +104,9 @@ class CScriptCompressor\n     }\n };\n \n-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n-int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys);\n-bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet);\n-bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n "
      },
      {
        "sha": "24e8a51f7dcf070cef222478657822eefa796d69",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbff412eb239595cf30f21e115ef0be97e379f8b/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbff412eb239595cf30f21e115ef0be97e379f8b/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=fbff412eb239595cf30f21e115ef0be97e379f8b",
        "patch": "@@ -11,6 +11,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n+#include \"scriptutils.h\"\n #include \"ui_interface.h\"\n #include \"walletdb.h\"\n "
      }
    ]
  },
  {
    "sha": "db8931883160950724443c56d2883815db8a4bd6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjg5MzE4ODMxNjA5NTA3MjQ0NDNjNTZkMjg4MzgxNWRiOGE0YmQ2",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@monetize.io",
        "date": "2014-08-20T16:33:30Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-02T14:28:30Z"
      },
      "message": "Separate CScriptCompressor",
      "tree": {
        "sha": "0bc5605f1723ef28b64f3838d8cf67d6b1920d61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0bc5605f1723ef28b64f3838d8cf67d6b1920d61"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db8931883160950724443c56d2883815db8a4bd6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db8931883160950724443c56d2883815db8a4bd6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db8931883160950724443c56d2883815db8a4bd6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db8931883160950724443c56d2883815db8a4bd6/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fbff412eb239595cf30f21e115ef0be97e379f8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbff412eb239595cf30f21e115ef0be97e379f8b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fbff412eb239595cf30f21e115ef0be97e379f8b"
      }
    ],
    "stats": {
      "total": 410,
      "additions": 215,
      "deletions": 195
    },
    "files": [
      {
        "sha": "efa55f0dc2c74ca3ca80f5045d06f8ff9c7dbe27",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db8931883160950724443c56d2883815db8a4bd6/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db8931883160950724443c56d2883815db8a4bd6/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=db8931883160950724443c56d2883815db8a4bd6",
        "patch": "@@ -99,6 +99,7 @@ BITCOIN_CORE_H = \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n   script/interpreter.h \\\n+  script/compressor.h \\\n   script/script.h \\\n   script/standard.h \\\n   scriptutils.h \\\n@@ -210,6 +211,7 @@ libbitcoin_common_a_SOURCES = \\\n   netbase.cpp \\\n   protocol.cpp \\\n   script/interpreter.cpp \\\n+  script/compressor.cpp \\\n   script/script.cpp \\\n   script/standard.cpp \\\n   scriptutils.cpp \\"
      },
      {
        "sha": "02e167a3ce26f9f5eba6858ea06f5a86e1686641",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db8931883160950724443c56d2883815db8a4bd6/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db8931883160950724443c56d2883815db8a4bd6/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=db8931883160950724443c56d2883815db8a4bd6",
        "patch": "@@ -6,7 +6,8 @@\n #ifndef BITCOIN_CORE_H\n #define BITCOIN_CORE_H\n \n-#include \"scriptutils.h\"\n+#include \"script/compressor.h\"\n+#include \"script/script.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n "
      },
      {
        "sha": "2f8df602bf54d1fa18ccb7ffd97f97b526d0a782",
        "filename": "src/script/compressor.cpp",
        "status": "added",
        "additions": 127,
        "deletions": 0,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db8931883160950724443c56d2883815db8a4bd6/src/script/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db8931883160950724443c56d2883815db8a4bd6/src/script/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/compressor.cpp?ref=db8931883160950724443c56d2883815db8a4bd6",
        "patch": "@@ -0,0 +1,127 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"compressor.h\"\n+\n+bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n+{\n+    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n+                            && script[2] == 20 && script[23] == OP_EQUALVERIFY\n+                            && script[24] == OP_CHECKSIG) {\n+        memcpy(&hash, &script[3], 20);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n+{\n+    if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n+                            && script[22] == OP_EQUAL) {\n+        memcpy(&hash, &script[2], 20);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n+{\n+    if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n+                            && (script[1] == 0x02 || script[1] == 0x03)) {\n+        pubkey.Set(&script[1], &script[34]);\n+        return true;\n+    }\n+    if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n+                            && script[1] == 0x04) {\n+        pubkey.Set(&script[1], &script[66]);\n+        return pubkey.IsFullyValid(); // if not fully valid, a case that would not be compressible\n+    }\n+    return false;\n+}\n+\n+bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n+{\n+    CKeyID keyID;\n+    if (IsToKeyID(keyID)) {\n+        out.resize(21);\n+        out[0] = 0x00;\n+        memcpy(&out[1], &keyID, 20);\n+        return true;\n+    }\n+    CScriptID scriptID;\n+    if (IsToScriptID(scriptID)) {\n+        out.resize(21);\n+        out[0] = 0x01;\n+        memcpy(&out[1], &scriptID, 20);\n+        return true;\n+    }\n+    CPubKey pubkey;\n+    if (IsToPubKey(pubkey)) {\n+        out.resize(33);\n+        memcpy(&out[1], &pubkey[1], 32);\n+        if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n+            out[0] = pubkey[0];\n+            return true;\n+        } else if (pubkey[0] == 0x04) {\n+            out[0] = 0x04 | (pubkey[64] & 0x01);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n+{\n+    if (nSize == 0 || nSize == 1)\n+        return 20;\n+    if (nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5)\n+        return 32;\n+    return 0;\n+}\n+\n+bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n+{\n+    switch(nSize) {\n+    case 0x00:\n+        script.resize(25);\n+        script[0] = OP_DUP;\n+        script[1] = OP_HASH160;\n+        script[2] = 20;\n+        memcpy(&script[3], &in[0], 20);\n+        script[23] = OP_EQUALVERIFY;\n+        script[24] = OP_CHECKSIG;\n+        return true;\n+    case 0x01:\n+        script.resize(23);\n+        script[0] = OP_HASH160;\n+        script[1] = 20;\n+        memcpy(&script[2], &in[0], 20);\n+        script[22] = OP_EQUAL;\n+        return true;\n+    case 0x02:\n+    case 0x03:\n+        script.resize(35);\n+        script[0] = 33;\n+        script[1] = nSize;\n+        memcpy(&script[2], &in[0], 32);\n+        script[34] = OP_CHECKSIG;\n+        return true;\n+    case 0x04:\n+    case 0x05:\n+        unsigned char vch[33] = {};\n+        vch[0] = nSize - 2;\n+        memcpy(&vch[1], &in[0], 32);\n+        CPubKey pubkey(&vch[0], &vch[33]);\n+        if (!pubkey.Decompress())\n+            return false;\n+        assert(pubkey.size() == 65);\n+        script.resize(67);\n+        script[0] = 65;\n+        memcpy(&script[1], pubkey.begin(), 65);\n+        script[66] = OP_CHECKSIG;\n+        return true;\n+    }\n+    return false;\n+}"
      },
      {
        "sha": "f0a3754f02b475a07d116b49023be8d54d129652",
        "filename": "src/script/compressor.h",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db8931883160950724443c56d2883815db8a4bd6/src/script/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db8931883160950724443c56d2883815db8a4bd6/src/script/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/compressor.h?ref=db8931883160950724443c56d2883815db8a4bd6",
        "patch": "@@ -0,0 +1,84 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef H_BITCOIN_SCRIPT_COMPRESSOR\n+#define H_BITCOIN_SCRIPT_COMPRESSOR\n+\n+#include \"script/script.h\"\n+\n+/** Compact serializer for scripts.\n+ *\n+ *  It detects common cases and encodes them much more efficiently.\n+ *  3 special cases are defined:\n+ *  * Pay to pubkey hash (encoded as 21 bytes)\n+ *  * Pay to script hash (encoded as 21 bytes)\n+ *  * Pay to pubkey starting with 0x02, 0x03 or 0x04 (encoded as 33 bytes)\n+ *\n+ *  Other scripts up to 121 bytes require 1 byte + script length. Above\n+ *  that, scripts up to 16505 bytes require 2 bytes + script length.\n+ */\n+class CScriptCompressor\n+{\n+private:\n+    // make this static for now (there are only 6 special scripts defined)\n+    // this can potentially be extended together with a new nVersion for\n+    // transactions, in which case this value becomes dependent on nVersion\n+    // and nHeight of the enclosing transaction.\n+    static const unsigned int nSpecialScripts = 6;\n+\n+    CScript &script;\n+protected:\n+    // These check for scripts for which a special case with a shorter encoding is defined.\n+    // They are implemented separately from the CScript test, as these test for exact byte\n+    // sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n+    // whether the public key is valid (as invalid ones cannot be represented in compressed\n+    // form).\n+    bool IsToKeyID(CKeyID &hash) const;\n+    bool IsToScriptID(CScriptID &hash) const;\n+    bool IsToPubKey(CPubKey &pubkey) const;\n+\n+    bool Compress(std::vector<unsigned char> &out) const;\n+    unsigned int GetSpecialSize(unsigned int nSize) const;\n+    bool Decompress(unsigned int nSize, const std::vector<unsigned char> &out);\n+public:\n+    CScriptCompressor(CScript &scriptIn) : script(scriptIn) { }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+        std::vector<unsigned char> compr;\n+        if (Compress(compr))\n+            return compr.size();\n+        unsigned int nSize = script.size() + nSpecialScripts;\n+        return script.size() + VARINT(nSize).GetSerializeSize(nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersion) const {\n+        std::vector<unsigned char> compr;\n+        if (Compress(compr)) {\n+            s << CFlatData(compr);\n+            return;\n+        }\n+        unsigned int nSize = script.size() + nSpecialScripts;\n+        s << VARINT(nSize);\n+        s << CFlatData(script);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s, int nType, int nVersion) {\n+        unsigned int nSize = 0;\n+        s >> VARINT(nSize);\n+        if (nSize < nSpecialScripts) {\n+            std::vector<unsigned char> vch(GetSpecialSize(nSize), 0x00);\n+            s >> REF(CFlatData(vch));\n+            Decompress(nSize, vch);\n+            return;\n+        }\n+        nSize -= nSpecialScripts;\n+        script.resize(nSize);\n+        s >> REF(CFlatData(script));\n+    }\n+};\n+\n+#endif"
      },
      {
        "sha": "cc38706d34d3163f9a1664f536e36eef9480522b",
        "filename": "src/scriptutils.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 121,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db8931883160950724443c56d2883815db8a4bd6/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db8931883160950724443c56d2883815db8a4bd6/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=db8931883160950724443c56d2883815db8a4bd6",
        "patch": "@@ -369,124 +369,3 @@ CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsign\n \n     return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n }\n-\n-bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n-{\n-    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n-                            && script[2] == 20 && script[23] == OP_EQUALVERIFY\n-                            && script[24] == OP_CHECKSIG) {\n-        memcpy(&hash, &script[3], 20);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n-{\n-    if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n-                            && script[22] == OP_EQUAL) {\n-        memcpy(&hash, &script[2], 20);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n-{\n-    if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n-                            && (script[1] == 0x02 || script[1] == 0x03)) {\n-        pubkey.Set(&script[1], &script[34]);\n-        return true;\n-    }\n-    if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n-                            && script[1] == 0x04) {\n-        pubkey.Set(&script[1], &script[66]);\n-        return pubkey.IsFullyValid(); // if not fully valid, a case that would not be compressible\n-    }\n-    return false;\n-}\n-\n-bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n-{\n-    CKeyID keyID;\n-    if (IsToKeyID(keyID)) {\n-        out.resize(21);\n-        out[0] = 0x00;\n-        memcpy(&out[1], &keyID, 20);\n-        return true;\n-    }\n-    CScriptID scriptID;\n-    if (IsToScriptID(scriptID)) {\n-        out.resize(21);\n-        out[0] = 0x01;\n-        memcpy(&out[1], &scriptID, 20);\n-        return true;\n-    }\n-    CPubKey pubkey;\n-    if (IsToPubKey(pubkey)) {\n-        out.resize(33);\n-        memcpy(&out[1], &pubkey[1], 32);\n-        if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n-            out[0] = pubkey[0];\n-            return true;\n-        } else if (pubkey[0] == 0x04) {\n-            out[0] = 0x04 | (pubkey[64] & 0x01);\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n-{\n-    if (nSize == 0 || nSize == 1)\n-        return 20;\n-    if (nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5)\n-        return 32;\n-    return 0;\n-}\n-\n-bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n-{\n-    switch(nSize) {\n-    case 0x00:\n-        script.resize(25);\n-        script[0] = OP_DUP;\n-        script[1] = OP_HASH160;\n-        script[2] = 20;\n-        memcpy(&script[3], &in[0], 20);\n-        script[23] = OP_EQUALVERIFY;\n-        script[24] = OP_CHECKSIG;\n-        return true;\n-    case 0x01:\n-        script.resize(23);\n-        script[0] = OP_HASH160;\n-        script[1] = 20;\n-        memcpy(&script[2], &in[0], 20);\n-        script[22] = OP_EQUAL;\n-        return true;\n-    case 0x02:\n-    case 0x03:\n-        script.resize(35);\n-        script[0] = 33;\n-        script[1] = nSize;\n-        memcpy(&script[2], &in[0], 32);\n-        script[34] = OP_CHECKSIG;\n-        return true;\n-    case 0x04:\n-    case 0x05:\n-        unsigned char vch[33] = {};\n-        vch[0] = nSize - 2;\n-        memcpy(&vch[1], &in[0], 32);\n-        CPubKey pubkey(&vch[0], &vch[33]);\n-        if (!pubkey.Decompress())\n-            return false;\n-        assert(pubkey.size() == 65);\n-        script.resize(67);\n-        script[0] = 65;\n-        memcpy(&script[1], pubkey.begin(), 65);\n-        script[66] = OP_CHECKSIG;\n-        return true;\n-    }\n-    return false;\n-}"
      },
      {
        "sha": "1c7408124e10850fdefb53f6cac24d1a490ea7da",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 0,
        "deletions": 73,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db8931883160950724443c56d2883815db8a4bd6/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db8931883160950724443c56d2883815db8a4bd6/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=db8931883160950724443c56d2883815db8a4bd6",
        "patch": "@@ -31,79 +31,6 @@ enum isminetype\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-/** Compact serializer for scripts.\n- *\n- *  It detects common cases and encodes them much more efficiently.\n- *  3 special cases are defined:\n- *  * Pay to pubkey hash (encoded as 21 bytes)\n- *  * Pay to script hash (encoded as 21 bytes)\n- *  * Pay to pubkey starting with 0x02, 0x03 or 0x04 (encoded as 33 bytes)\n- *\n- *  Other scripts up to 121 bytes require 1 byte + script length. Above\n- *  that, scripts up to 16505 bytes require 2 bytes + script length.\n- */\n-class CScriptCompressor\n-{\n-private:\n-    // make this static for now (there are only 6 special scripts defined)\n-    // this can potentially be extended together with a new nVersion for\n-    // transactions, in which case this value becomes dependent on nVersion\n-    // and nHeight of the enclosing transaction.\n-    static const unsigned int nSpecialScripts = 6;\n-\n-    CScript &script;\n-protected:\n-    // These check for scripts for which a special case with a shorter encoding is defined.\n-    // They are implemented separately from the CScript test, as these test for exact byte\n-    // sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n-    // whether the public key is valid (as invalid ones cannot be represented in compressed\n-    // form).\n-    bool IsToKeyID(CKeyID &hash) const;\n-    bool IsToScriptID(CScriptID &hash) const;\n-    bool IsToPubKey(CPubKey &pubkey) const;\n-\n-    bool Compress(std::vector<unsigned char> &out) const;\n-    unsigned int GetSpecialSize(unsigned int nSize) const;\n-    bool Decompress(unsigned int nSize, const std::vector<unsigned char> &out);\n-public:\n-    CScriptCompressor(CScript &scriptIn) : script(scriptIn) { }\n-\n-    unsigned int GetSerializeSize(int nType, int nVersion) const {\n-        std::vector<unsigned char> compr;\n-        if (Compress(compr))\n-            return compr.size();\n-        unsigned int nSize = script.size() + nSpecialScripts;\n-        return script.size() + VARINT(nSize).GetSerializeSize(nType, nVersion);\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream &s, int nType, int nVersion) const {\n-        std::vector<unsigned char> compr;\n-        if (Compress(compr)) {\n-            s << CFlatData(compr);\n-            return;\n-        }\n-        unsigned int nSize = script.size() + nSpecialScripts;\n-        s << VARINT(nSize);\n-        s << CFlatData(script);\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream &s, int nType, int nVersion) {\n-        unsigned int nSize = 0;\n-        s >> VARINT(nSize);\n-        if (nSize < nSpecialScripts) {\n-            std::vector<unsigned char> vch(GetSpecialSize(nSize), 0x00);\n-            s >> REF(CFlatData(vch));\n-            Decompress(nSize, vch);\n-            return;\n-        }\n-        nSize -= nSpecialScripts;\n-        script.resize(nSize);\n-        s >> REF(CFlatData(script));\n-    }\n-};\n-\n isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys);"
      }
    ]
  },
  {
    "sha": "ff51b1a1169c2bb271006620a4b648dc1385f081",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjUxYjFhMTE2OWMyYmIyNzEwMDY2MjBhNGI2NDhkYzEzODVmMDgx",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-08-27T15:22:33Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-02T14:28:31Z"
      },
      "message": "Separate script/sign",
      "tree": {
        "sha": "ffbfe9451824728e5ee7e00f996ee37351178a91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ffbfe9451824728e5ee7e00f996ee37351178a91"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff51b1a1169c2bb271006620a4b648dc1385f081",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff51b1a1169c2bb271006620a4b648dc1385f081",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff51b1a1169c2bb271006620a4b648dc1385f081",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff51b1a1169c2bb271006620a4b648dc1385f081/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db8931883160950724443c56d2883815db8a4bd6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db8931883160950724443c56d2883815db8a4bd6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db8931883160950724443c56d2883815db8a4bd6"
      }
    ],
    "stats": {
      "total": 557,
      "additions": 294,
      "deletions": 263
    },
    "files": [
      {
        "sha": "9b7e99861dd65e1cf3b19012929d42982908707c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -101,6 +101,7 @@ BITCOIN_CORE_H = \\\n   script/interpreter.h \\\n   script/compressor.h \\\n   script/script.h \\\n+  script/sign.h \\\n   script/standard.h \\\n   scriptutils.h \\\n   serialize.h \\\n@@ -213,6 +214,7 @@ libbitcoin_common_a_SOURCES = \\\n   script/interpreter.cpp \\\n   script/compressor.cpp \\\n   script/script.cpp \\\n+  script/sign.cpp \\\n   script/standard.cpp \\\n   scriptutils.cpp \\\n   $(BITCOIN_CORE_H)"
      },
      {
        "sha": "c455351411df7aac593f89b4bebcf177c9af8998",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -9,7 +9,7 @@\n #include \"main.h\"         // for MAX_BLOCK_SIZE\n #include \"keystore.h\"\n #include \"script/script.h\"\n-#include \"scriptutils.h\"\n+#include \"script/sign.h\"\n #include \"ui_interface.h\" // for _(...)\n #include \"univalue/univalue.h\"\n #include \"core_io.h\""
      },
      {
        "sha": "f2736c4f63f066809fac140e905497e19a5b5d1a",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -13,6 +13,7 @@\n #include \"rpcserver.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n+#include \"script/sign.h\"\n #include \"uint256.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet.h\""
      },
      {
        "sha": "958177de3d8024b51c5e5a12fcb826d0a27e00db",
        "filename": "src/script/sign.cpp",
        "status": "added",
        "additions": 260,
        "deletions": 0,
        "changes": 260,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -0,0 +1,260 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script/sign.h\"\n+\n+#include \"core.h\"\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/standard.h\"\n+#include \"uint256.h\"\n+\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+typedef vector<unsigned char> valtype;\n+\n+bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n+{\n+    CKey key;\n+    if (!keystore.GetKey(address, key))\n+        return false;\n+\n+    vector<unsigned char> vchSig;\n+    if (!key.Sign(hash, vchSig))\n+        return false;\n+    vchSig.push_back((unsigned char)nHashType);\n+    scriptSigRet << vchSig;\n+\n+    return true;\n+}\n+\n+bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n+{\n+    int nSigned = 0;\n+    int nRequired = multisigdata.front()[0];\n+    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n+    {\n+        const valtype& pubkey = multisigdata[i];\n+        CKeyID keyID = CPubKey(pubkey).GetID();\n+        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n+            ++nSigned;\n+    }\n+    return nSigned==nRequired;\n+}\n+\n+//\n+// Sign scriptPubKey with private keys stored in keystore, given transaction hash and hash type.\n+// Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n+// unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n+// Returns false if scriptPubKey could not be completely satisfied.\n+//\n+bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n+                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n+{\n+    scriptSigRet.clear();\n+\n+    vector<valtype> vSolutions;\n+    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n+        return false;\n+\n+    CKeyID keyID;\n+    switch (whichTypeRet)\n+    {\n+    case TX_NONSTANDARD:\n+    case TX_NULL_DATA:\n+        return false;\n+    case TX_PUBKEY:\n+        keyID = CPubKey(vSolutions[0]).GetID();\n+        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n+    case TX_PUBKEYHASH:\n+        keyID = CKeyID(uint160(vSolutions[0]));\n+        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n+            return false;\n+        else\n+        {\n+            CPubKey vch;\n+            keystore.GetPubKey(keyID, vch);\n+            scriptSigRet << vch;\n+        }\n+        return true;\n+    case TX_SCRIPTHASH:\n+        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n+\n+    case TX_MULTISIG:\n+        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n+        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n+    }\n+    return false;\n+}\n+\n+bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+{\n+    assert(nIn < txTo.vin.size());\n+    CTxIn& txin = txTo.vin[nIn];\n+\n+    // Leave out the signature from the hash, since a signature can't sign itself.\n+    // The checksig op will also drop the signatures from its hash.\n+    uint256 hash = SignatureHash(fromPubKey, txTo, nIn, nHashType);\n+\n+    txnouttype whichType;\n+    if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n+        return false;\n+\n+    if (whichType == TX_SCRIPTHASH)\n+    {\n+        // Solver returns the subscript that need to be evaluated;\n+        // the final scriptSig is the signatures from that\n+        // and then the serialized subscript:\n+        CScript subscript = txin.scriptSig;\n+\n+        // Recompute txn hash using subscript in place of scriptPubKey:\n+        uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n+\n+        txnouttype subType;\n+        bool fSolved =\n+            Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n+        // Append serialized subscript whether or not it is completely signed:\n+        txin.scriptSig << static_cast<valtype>(subscript);\n+        if (!fSolved) return false;\n+    }\n+\n+    // Test solution\n+    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, STANDARD_SCRIPT_VERIFY_FLAGS, 0);\n+}\n+\n+bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+{\n+    assert(nIn < txTo.vin.size());\n+    CTxIn& txin = txTo.vin[nIn];\n+    assert(txin.prevout.n < txFrom.vout.size());\n+    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n+\n+    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n+}\n+\n+static CScript PushAll(const vector<valtype>& values)\n+{\n+    CScript result;\n+    BOOST_FOREACH(const valtype& v, values)\n+        result << v;\n+    return result;\n+}\n+\n+static CScript CombineMultisig(CScript scriptPubKey, const CMutableTransaction& txTo, unsigned int nIn,\n+                               const vector<valtype>& vSolutions,\n+                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n+{\n+    // Combine all the signatures we've got:\n+    set<valtype> allsigs;\n+    BOOST_FOREACH(const valtype& v, sigs1)\n+    {\n+        if (!v.empty())\n+            allsigs.insert(v);\n+    }\n+    BOOST_FOREACH(const valtype& v, sigs2)\n+    {\n+        if (!v.empty())\n+            allsigs.insert(v);\n+    }\n+\n+    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+    assert(vSolutions.size() > 1);\n+    unsigned int nSigsRequired = vSolutions.front()[0];\n+    unsigned int nPubKeys = vSolutions.size()-2;\n+    map<valtype, valtype> sigs;\n+    BOOST_FOREACH(const valtype& sig, allsigs)\n+    {\n+        for (unsigned int i = 0; i < nPubKeys; i++)\n+        {\n+            const valtype& pubkey = vSolutions[i+1];\n+            if (sigs.count(pubkey))\n+                continue; // Already got a sig for this pubkey\n+\n+            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0, 0))\n+            {\n+                sigs[pubkey] = sig;\n+                break;\n+            }\n+        }\n+    }\n+    // Now build a merged CScript:\n+    unsigned int nSigsHave = 0;\n+    CScript result; result << OP_0; // pop-one-too-many workaround\n+    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n+    {\n+        if (sigs.count(vSolutions[i+1]))\n+        {\n+            result << sigs[vSolutions[i+1]];\n+            ++nSigsHave;\n+        }\n+    }\n+    // Fill any missing with OP_0:\n+    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n+        result << OP_0;\n+\n+    return result;\n+}\n+\n+static CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                                 const txnouttype txType, const vector<valtype>& vSolutions,\n+                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n+{\n+    switch (txType)\n+    {\n+    case TX_NONSTANDARD:\n+    case TX_NULL_DATA:\n+        // Don't know anything about this, assume bigger one is correct:\n+        if (sigs1.size() >= sigs2.size())\n+            return PushAll(sigs1);\n+        return PushAll(sigs2);\n+    case TX_PUBKEY:\n+    case TX_PUBKEYHASH:\n+        // Signatures are bigger than placeholders or empty scripts:\n+        if (sigs1.empty() || sigs1[0].empty())\n+            return PushAll(sigs2);\n+        return PushAll(sigs1);\n+    case TX_SCRIPTHASH:\n+        if (sigs1.empty() || sigs1.back().empty())\n+            return PushAll(sigs2);\n+        else if (sigs2.empty() || sigs2.back().empty())\n+            return PushAll(sigs1);\n+        else\n+        {\n+            // Recur to combine:\n+            valtype spk = sigs1.back();\n+            CScript pubKey2(spk.begin(), spk.end());\n+\n+            txnouttype txType2;\n+            vector<vector<unsigned char> > vSolutions2;\n+            Solver(pubKey2, txType2, vSolutions2);\n+            sigs1.pop_back();\n+            sigs2.pop_back();\n+            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n+            result << spk;\n+            return result;\n+        }\n+    case TX_MULTISIG:\n+        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n+    }\n+\n+    return CScript();\n+}\n+\n+CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                          const CScript& scriptSig1, const CScript& scriptSig2)\n+{\n+    txnouttype txType;\n+    vector<vector<unsigned char> > vSolutions;\n+    Solver(scriptPubKey, txType, vSolutions);\n+\n+    vector<valtype> stack1;\n+    EvalScript(stack1, scriptSig1, CTransaction(), 0, SCRIPT_VERIFY_STRICTENC, 0);\n+    vector<valtype> stack2;\n+    EvalScript(stack2, scriptSig2, CTransaction(), 0, SCRIPT_VERIFY_STRICTENC, 0);\n+\n+    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n+}"
      },
      {
        "sha": "51723b53af552da084283fc74c2039d73a8142be",
        "filename": "src/script/sign.h",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -0,0 +1,23 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef H_BITCOIN_SCRIPT_SIGN\n+#define H_BITCOIN_SCRIPT_SIGN\n+\n+#include \"script/interpreter.h\"\n+\n+class CKeyStore;\n+class CScript;\n+class CTransaction;\n+struct CMutableTransaction;\n+\n+bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n+bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n+\n+// Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n+// combine them intelligently and return the result.\n+CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CScript& scriptSig1, const CScript& scriptSig2);\n+\n+#endif"
      },
      {
        "sha": "a636eeedab774e4a5499f9b34f17b4d1712b030d",
        "filename": "src/scriptutils.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 245,
        "changes": 246,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -5,92 +5,16 @@\n \n #include \"scriptutils.h\"\n \n-#include \"core.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n-#include \"uint256.h\"\n-#include \"util.h\"\n+#include \"script/standard.h\"\n \n #include <boost/foreach.hpp>\n \n using namespace std;\n \n typedef vector<unsigned char> valtype;\n \n-bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n-{\n-    CKey key;\n-    if (!keystore.GetKey(address, key))\n-        return false;\n-\n-    vector<unsigned char> vchSig;\n-    if (!key.Sign(hash, vchSig))\n-        return false;\n-    vchSig.push_back((unsigned char)nHashType);\n-    scriptSigRet << vchSig;\n-\n-    return true;\n-}\n-\n-bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n-{\n-    int nSigned = 0;\n-    int nRequired = multisigdata.front()[0];\n-    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n-    {\n-        const valtype& pubkey = multisigdata[i];\n-        CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n-            ++nSigned;\n-    }\n-    return nSigned==nRequired;\n-}\n-\n-//\n-// Sign scriptPubKey with private keys stored in keystore, given transaction hash and hash type.\n-// Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n-// unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n-// Returns false if scriptPubKey could not be completely satisfied.\n-//\n-bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n-                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n-{\n-    scriptSigRet.clear();\n-\n-    vector<valtype> vSolutions;\n-    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n-        return false;\n-\n-    CKeyID keyID;\n-    switch (whichTypeRet)\n-    {\n-    case TX_NONSTANDARD:\n-    case TX_NULL_DATA:\n-        return false;\n-    case TX_PUBKEY:\n-        keyID = CPubKey(vSolutions[0]).GetID();\n-        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n-    case TX_PUBKEYHASH:\n-        keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n-            return false;\n-        else\n-        {\n-            CPubKey vch;\n-            keystore.GetPubKey(keyID, vch);\n-            scriptSigRet << vch;\n-        }\n-        return true;\n-    case TX_SCRIPTHASH:\n-        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n-\n-    case TX_MULTISIG:\n-        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n-        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n-    }\n-    return false;\n-}\n-\n unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n {\n     unsigned int nResult = 0;\n@@ -201,171 +125,3 @@ class CAffectedKeysVisitor : public boost::static_visitor<void> {\n void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys) {\n     CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n }\n-\n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n-{\n-    assert(nIn < txTo.vin.size());\n-    CTxIn& txin = txTo.vin[nIn];\n-\n-    // Leave out the signature from the hash, since a signature can't sign itself.\n-    // The checksig op will also drop the signatures from its hash.\n-    uint256 hash = SignatureHash(fromPubKey, txTo, nIn, nHashType);\n-\n-    txnouttype whichType;\n-    if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n-        return false;\n-\n-    if (whichType == TX_SCRIPTHASH)\n-    {\n-        // Solver returns the subscript that need to be evaluated;\n-        // the final scriptSig is the signatures from that\n-        // and then the serialized subscript:\n-        CScript subscript = txin.scriptSig;\n-\n-        // Recompute txn hash using subscript in place of scriptPubKey:\n-        uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n-\n-        txnouttype subType;\n-        bool fSolved =\n-            Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n-        // Append serialized subscript whether or not it is completely signed:\n-        txin.scriptSig << static_cast<valtype>(subscript);\n-        if (!fSolved) return false;\n-    }\n-\n-    // Test solution\n-    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, STANDARD_SCRIPT_VERIFY_FLAGS, 0);\n-}\n-\n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n-{\n-    assert(nIn < txTo.vin.size());\n-    CTxIn& txin = txTo.vin[nIn];\n-    assert(txin.prevout.n < txFrom.vout.size());\n-    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n-\n-    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n-}\n-\n-static CScript PushAll(const vector<valtype>& values)\n-{\n-    CScript result;\n-    BOOST_FOREACH(const valtype& v, values)\n-        result << v;\n-    return result;\n-}\n-\n-static CScript CombineMultisig(CScript scriptPubKey, const CMutableTransaction& txTo, unsigned int nIn,\n-                               const vector<valtype>& vSolutions,\n-                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n-{\n-    // Combine all the signatures we've got:\n-    set<valtype> allsigs;\n-    BOOST_FOREACH(const valtype& v, sigs1)\n-    {\n-        if (!v.empty())\n-            allsigs.insert(v);\n-    }\n-    BOOST_FOREACH(const valtype& v, sigs2)\n-    {\n-        if (!v.empty())\n-            allsigs.insert(v);\n-    }\n-\n-    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n-    assert(vSolutions.size() > 1);\n-    unsigned int nSigsRequired = vSolutions.front()[0];\n-    unsigned int nPubKeys = vSolutions.size()-2;\n-    map<valtype, valtype> sigs;\n-    BOOST_FOREACH(const valtype& sig, allsigs)\n-    {\n-        for (unsigned int i = 0; i < nPubKeys; i++)\n-        {\n-            const valtype& pubkey = vSolutions[i+1];\n-            if (sigs.count(pubkey))\n-                continue; // Already got a sig for this pubkey\n-\n-            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0, 0))\n-            {\n-                sigs[pubkey] = sig;\n-                break;\n-            }\n-        }\n-    }\n-    // Now build a merged CScript:\n-    unsigned int nSigsHave = 0;\n-    CScript result; result << OP_0; // pop-one-too-many workaround\n-    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n-    {\n-        if (sigs.count(vSolutions[i+1]))\n-        {\n-            result << sigs[vSolutions[i+1]];\n-            ++nSigsHave;\n-        }\n-    }\n-    // Fill any missing with OP_0:\n-    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n-        result << OP_0;\n-\n-    return result;\n-}\n-\n-static CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                                 const txnouttype txType, const vector<valtype>& vSolutions,\n-                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n-{\n-    switch (txType)\n-    {\n-    case TX_NONSTANDARD:\n-    case TX_NULL_DATA:\n-        // Don't know anything about this, assume bigger one is correct:\n-        if (sigs1.size() >= sigs2.size())\n-            return PushAll(sigs1);\n-        return PushAll(sigs2);\n-    case TX_PUBKEY:\n-    case TX_PUBKEYHASH:\n-        // Signatures are bigger than placeholders or empty scripts:\n-        if (sigs1.empty() || sigs1[0].empty())\n-            return PushAll(sigs2);\n-        return PushAll(sigs1);\n-    case TX_SCRIPTHASH:\n-        if (sigs1.empty() || sigs1.back().empty())\n-            return PushAll(sigs2);\n-        else if (sigs2.empty() || sigs2.back().empty())\n-            return PushAll(sigs1);\n-        else\n-        {\n-            // Recur to combine:\n-            valtype spk = sigs1.back();\n-            CScript pubKey2(spk.begin(), spk.end());\n-\n-            txnouttype txType2;\n-            vector<vector<unsigned char> > vSolutions2;\n-            Solver(pubKey2, txType2, vSolutions2);\n-            sigs1.pop_back();\n-            sigs2.pop_back();\n-            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n-            result << spk;\n-            return result;\n-        }\n-    case TX_MULTISIG:\n-        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n-    }\n-\n-    return CScript();\n-}\n-\n-CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                          const CScript& scriptSig1, const CScript& scriptSig2)\n-{\n-    txnouttype txType;\n-    vector<vector<unsigned char> > vSolutions;\n-    Solver(scriptPubKey, txType, vSolutions);\n-\n-    vector<valtype> stack1;\n-    EvalScript(stack1, scriptSig1, CTransaction(), 0, SCRIPT_VERIFY_STRICTENC, 0);\n-    vector<valtype> stack2;\n-    EvalScript(stack2, scriptSig2, CTransaction(), 0, SCRIPT_VERIFY_STRICTENC, 0);\n-\n-    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n-}"
      },
      {
        "sha": "98080fc456cbde128531308ff62acbc53a8031ae",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -8,17 +8,8 @@\n \n #include \"key.h\"\n #include \"script/script.h\"\n-#include \"script/interpreter.h\"\n-#include \"script/standard.h\"\n-\n-#include <stdexcept>\n-#include <stdint.h>\n-#include <string>\n-#include <vector>\n \n class CKeyStore;\n-class CTransaction;\n-struct CMutableTransaction;\n \n /** IsMine() return codes */\n enum isminetype\n@@ -34,11 +25,5 @@ typedef uint8_t isminefilter;\n isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys);\n-bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-\n-// Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n-// combine them intelligently and return the result.\n-CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CScript& scriptSig1, const CScript& scriptSig2);\n \n #endif // H_BITCOIN_SCRIPT"
      },
      {
        "sha": "fa4edff63f1e9b7aba3bb454200e07193e6d1bc5",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -12,7 +12,7 @@\n #include \"main.h\"\n #include \"net.h\"\n #include \"pow.h\"\n-#include \"scriptutils.h\"\n+#include \"script/sign.h\"\n #include \"serialize.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "6c5afa130c76c406a5eeb2cc05d2cc2faf9914b3",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -7,6 +7,7 @@\n #include \"main.h\"\n #include \"script/script.h\"\n #include \"script/interpreter.h\"\n+#include \"script/sign.h\"\n #include \"scriptutils.h\"\n #include \"uint256.h\"\n "
      },
      {
        "sha": "b7e7487bb2bb8b39d7d84257148f03c1e42cb240",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -6,6 +6,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n+#include \"script/sign.h\"\n #include \"scriptutils.h\"\n \n #include <vector>"
      },
      {
        "sha": "88efc3896493b4461b8dbbf928fee41d73954d23",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -9,7 +9,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n-#include \"scriptutils.h\"\n+#include \"script/sign.h\"\n #include \"core_io.h\"\n \n #include <fstream>"
      },
      {
        "sha": "55cc6e04ed45fcce40fd1ef1ee4624ac88b0eee3",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff51b1a1169c2bb271006620a4b648dc1385f081/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff51b1a1169c2bb271006620a4b648dc1385f081/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=ff51b1a1169c2bb271006620a4b648dc1385f081",
        "patch": "@@ -9,6 +9,8 @@\n #include \"checkpoints.h\"\n #include \"coincontrol.h\"\n #include \"net.h\"\n+#include \"script/script.h\"\n+#include \"script/sign.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\""
      }
    ]
  }
]