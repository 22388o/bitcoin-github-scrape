[
  {
    "sha": "be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTlmMzhjNjEzMWFiMGM3YWQ5NmU0ZjZmM2Q4YjVhZTZmODcwZWE5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-30T22:56:37Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-09T23:41:18Z"
      },
      "message": "Do not make it trivial for inbound peers to generate log entries\n\nWe should generally avoid writing to debug.log unconditionally for\ninbound peers which misbehave (the peer being about to be banned\nbeing an exception, since they cannot do this twice).\n\nTo avoid removing logs for outbound peers, a new log is added to\nnotify users when a new outbound peer is connected which mimics\nthe version print.",
      "tree": {
        "sha": "c1eb34294a5c39304b360c541d07d0185c0eabb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c1eb34294a5c39304b360c541d07d0185c0eabb5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3788a8479b4efd481f3e91419bcf347113375112",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3788a8479b4efd481f3e91419bcf347113375112",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3788a8479b4efd481f3e91419bcf347113375112"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 23,
      "deletions": 14
    },
    "files": [
      {
        "sha": "4453f409ad1ffdccb78e290c8b285ef117b6b2ac",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
        "patch": "@@ -1111,7 +1111,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     if (IsBanned(addr) && !whitelisted)\n     {\n-        LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+        LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());\n         CloseSocket(hSocket);\n         return;\n     }"
      },
      {
        "sha": "8e76dabc85c4c0e3b0186703c13b30feaade9e09",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 13,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
        "patch": "@@ -1042,7 +1042,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     }\n                     send = BlockRequestAllowed(mi->second, consensusParams);\n                     if (!send) {\n-                        LogPrintf(\"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+                        LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n                     }\n                 }\n                 // disconnect node in case we have reached the outbound limit for serving historical blocks\n@@ -1511,7 +1511,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n+            LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n             connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n@@ -1611,7 +1611,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (fLogIPs)\n             remoteAddr = \", peeraddr=\" + pfrom->addr.ToString();\n \n-        LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n+        LogPrint(BCLog::NET, \"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                   cleanSubVer, pfrom->nVersion,\n                   pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                   remoteAddr);\n@@ -1654,6 +1654,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Mark this node as currently connected, so we update its timestamp later.\n             LOCK(cs_main);\n             State(pfrom->GetId())->fCurrentlyConnected = true;\n+            LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s\\n\",\n+                      pfrom->nVersion.load(), pfrom->nStartingHeight, pfrom->GetId(),\n+                      (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"));\n         }\n \n         if (pfrom->nVersion >= SENDHEADERS_VERSION) {\n@@ -1932,7 +1935,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1984,7 +1987,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pindex = (*mi).second;\n \n             if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {\n-                LogPrintf(\"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+                LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());\n                 return true;\n             }\n         }\n@@ -2232,10 +2235,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             int nDoS;\n             if (state.IsInvalid(nDoS)) {\n                 if (nDoS > 0) {\n+                    LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n+                } else {\n+                    LogPrint(BCLog::NET, \"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                 }\n-                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                 return true;\n             }\n         }\n@@ -2837,7 +2842,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     msg.SetVersion(pfrom->GetRecvVersion());\n     // Scan for message start\n     if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n-        LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());\n+        LogPrint(BCLog::NET, \"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());\n         pfrom->fDisconnect = true;\n         return false;\n     }\n@@ -2846,7 +2851,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     CMessageHeader& hdr = msg.hdr;\n     if (!hdr.IsValid(chainparams.MessageStart()))\n     {\n-        LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());\n+        LogPrint(BCLog::NET, \"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());\n         return fMoreWork;\n     }\n     std::string strCommand = hdr.GetCommand();\n@@ -2859,7 +2864,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     const uint256& hash = msg.GetMessageHash();\n     if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n     {\n-        LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n+        LogPrint(BCLog::NET, \"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n            SanitizeString(strCommand), nMessageSize,\n            HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n            HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n@@ -2882,17 +2887,17 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         if (strstr(e.what(), \"end of data\"))\n         {\n             // Allow exceptions from under-length message on vRecv\n-            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n+            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n         else if (strstr(e.what(), \"size too large\"))\n         {\n             // Allow exceptions from over-long size\n-            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n+            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n         else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n         {\n             // Allow exceptions from non-canonical encoding\n-            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n+            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n         else\n         {\n@@ -2906,7 +2911,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     }\n \n     if (!fRet) {\n-        LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n+        LogPrint(BCLog::NET, \"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n     }\n \n     LOCK(cs_main);"
      },
      {
        "sha": "a0c4b33ad4c14c6ccd5837e4e8fe3fb3ffcd0347",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=be9f38c6131ab0c7ad96e4f6f3d8b5ae6f870ea9",
        "patch": "@@ -132,6 +132,10 @@ template<typename T, typename... Args> static inline void MarkUsed(const T& t, c\n     MarkUsed(args...);\n }\n \n+// Be conservative when using LogPrintf/error or other things which\n+// unconditionally log to debug.log! It should not be the case that an inbound\n+// peer can fill up a users disk with debug.log entries.\n+\n #ifdef USE_COVERAGE\n #define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n #define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)"
      }
    ]
  }
]