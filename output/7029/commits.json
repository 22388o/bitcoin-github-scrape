[
  {
    "sha": "c800c95997fc6365165e0d2645517f738aa4aad4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjODAwYzk1OTk3ZmM2MzY1MTY1ZTBkMjY0NTUxN2Y3MzhhYTRhYWQ0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-11-16T14:45:57Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-11-16T14:50:50Z"
      },
      "message": "Remove unmaintained example test script_test.py",
      "tree": {
        "sha": "f8459af254539abfa14bea067832300dcc704d83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f8459af254539abfa14bea067832300dcc704d83"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c800c95997fc6365165e0d2645517f738aa4aad4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c800c95997fc6365165e0d2645517f738aa4aad4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c800c95997fc6365165e0d2645517f738aa4aad4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c800c95997fc6365165e0d2645517f738aa4aad4/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e54ebbf6009716a7abcd4d8d3f7bd910e88decdc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e54ebbf6009716a7abcd4d8d3f7bd910e88decdc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e54ebbf6009716a7abcd4d8d3f7bd910e88decdc"
      }
    ],
    "stats": {
      "total": 260,
      "additions": 0,
      "deletions": 260
    },
    "files": [
      {
        "sha": "57f9f9bfa6595bf03436ea89b49dda4973cee34b",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c800c95997fc6365165e0d2645517f738aa4aad4/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c800c95997fc6365165e0d2645517f738aa4aad4/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=c800c95997fc6365165e0d2645517f738aa4aad4",
        "patch": "@@ -106,7 +106,6 @@\n     'keypool.py',\n     'receivedby.py',\n #    'rpcbind_test.py', #temporary, bug in libevent, see #6655\n-#    'script_test.py', #used for manual comparison of 2 binaries\n     'smartfees.py',\n     'maxblocksinflight.py',\n     'invalidblockrequest.py',"
      },
      {
        "sha": "afc44b51b5416b9bfa5589a5e8653ee5dfbffad7",
        "filename": "qa/rpc-tests/script_test.py",
        "status": "removed",
        "additions": 0,
        "deletions": 259,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e54ebbf6009716a7abcd4d8d3f7bd910e88decdc/qa/rpc-tests/script_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e54ebbf6009716a7abcd4d8d3f7bd910e88decdc/qa/rpc-tests/script_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/script_test.py?ref=e54ebbf6009716a7abcd4d8d3f7bd910e88decdc",
        "patch": "@@ -1,259 +0,0 @@\n-#!/usr/bin/env python2\n-#\n-# Distributed under the MIT/X11 software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#\n-\n-'''\n-Test notes:\n-This test uses the script_valid and script_invalid tests from the unittest\n-framework to do end-to-end testing where we compare that two nodes agree on\n-whether blocks containing a given test script are valid.\n-\n-We generally ignore the script flags associated with each test (since we lack\n-the precision to test each script using those flags in this framework), but\n-for tests with SCRIPT_VERIFY_P2SH, we can use a block time after the BIP16 \n-switchover date to try to test with that flag enabled (and for tests without\n-that flag, we use a block time before the switchover date).\n-\n-NOTE: This test is very slow and may take more than 40 minutes to run.\n-'''\n-\n-from test_framework.test_framework import ComparisonTestFramework\n-from test_framework.util import *\n-from test_framework.comptool import TestInstance, TestManager\n-from test_framework.mininode import *\n-from test_framework.blocktools import *\n-from test_framework.script import *\n-import logging\n-import copy\n-import json\n-\n-script_valid_file   = \"../../src/test/data/script_valid.json\"\n-script_invalid_file = \"../../src/test/data/script_invalid.json\"\n-\n-# Pass in a set of json files to open. \n-class ScriptTestFile(object):\n-\n-    def __init__(self, files):\n-        self.files = files\n-        self.index = -1\n-        self.data = []\n-\n-    def load_files(self):\n-        for f in self.files:\n-            self.data.extend(json.loads(open(os.path.dirname(os.path.abspath(__file__))+\"/\"+f).read()))\n-\n-    # Skip over records that are not long enough to be tests\n-    def get_records(self):\n-        while (self.index < len(self.data)):\n-            if len(self.data[self.index]) >= 3:\n-                yield self.data[self.index]\n-            self.index += 1\n-\n-\n-# Helper for parsing the flags specified in the .json files\n-SCRIPT_VERIFY_NONE = 0\n-SCRIPT_VERIFY_P2SH = 1 \n-SCRIPT_VERIFY_STRICTENC = 1 << 1\n-SCRIPT_VERIFY_DERSIG = 1 << 2\n-SCRIPT_VERIFY_LOW_S = 1 << 3\n-SCRIPT_VERIFY_NULLDUMMY = 1 << 4\n-SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5\n-SCRIPT_VERIFY_MINIMALDATA = 1 << 6\n-SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7\n-SCRIPT_VERIFY_CLEANSTACK = 1 << 8\n-\n-flag_map = { \n-    \"\": SCRIPT_VERIFY_NONE,\n-    \"NONE\": SCRIPT_VERIFY_NONE, \n-    \"P2SH\": SCRIPT_VERIFY_P2SH,\n-    \"STRICTENC\": SCRIPT_VERIFY_STRICTENC,\n-    \"DERSIG\": SCRIPT_VERIFY_DERSIG,\n-    \"LOW_S\": SCRIPT_VERIFY_LOW_S,\n-    \"NULLDUMMY\": SCRIPT_VERIFY_NULLDUMMY,\n-    \"SIGPUSHONLY\": SCRIPT_VERIFY_SIGPUSHONLY,\n-    \"MINIMALDATA\": SCRIPT_VERIFY_MINIMALDATA,\n-    \"DISCOURAGE_UPGRADABLE_NOPS\": SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS,\n-    \"CLEANSTACK\": SCRIPT_VERIFY_CLEANSTACK,\n-}\n-\n-def ParseScriptFlags(flag_string):\n-    flags = 0\n-    for x in flag_string.split(\",\"):\n-        if x in flag_map:\n-            flags |= flag_map[x]\n-        else:\n-            print \"Error: unrecognized script flag: \", x\n-    return flags\n-\n-'''\n-Given a string that is a scriptsig or scriptpubkey from the .json files above,\n-convert it to a CScript()\n-'''\n-# Replicates behavior from core_read.cpp\n-def ParseScript(json_script):\n-    script = json_script.split(\" \")\n-    parsed_script = CScript()\n-    for x in script:\n-        if len(x) == 0:\n-            # Empty string, ignore.\n-            pass\n-        elif x.isdigit() or (len(x) >= 1 and x[0] == \"-\" and x[1:].isdigit()):\n-            # Number\n-            n = int(x, 0)\n-            if (n == -1) or (n >= 1 and n <= 16):\n-                parsed_script = CScript(bytes(parsed_script) + bytes(CScript([n])))\n-            else:\n-                parsed_script += CScriptNum(int(x, 0))\n-        elif x.startswith(\"0x\"):\n-            # Raw hex data, inserted NOT pushed onto stack:\n-            for i in xrange(2, len(x), 2):\n-                parsed_script = CScript(bytes(parsed_script) + bytes(chr(int(x[i:i+2],16))))\n-        elif x.startswith(\"'\") and x.endswith(\"'\") and len(x) >= 2:\n-            # Single-quoted string, pushed as data.\n-            parsed_script += CScript([x[1:-1]])\n-        else:\n-            # opcode, e.g. OP_ADD or ADD:\n-            tryopname = \"OP_\" + x\n-            if tryopname in OPCODES_BY_NAME:\n-                parsed_script += CScriptOp(OPCODES_BY_NAME[\"OP_\" + x])\n-            else:\n-                print \"ParseScript: error parsing '%s'\" % x\n-                return \"\"\n-    return parsed_script\n-            \n-class TestBuilder(object):\n-    def create_credit_tx(self, scriptPubKey, height):\n-        # self.tx1 is a coinbase transaction, modeled after the one created by script_tests.cpp\n-        # This allows us to reuse signatures created in the unit test framework.\n-        self.tx1 = create_coinbase(height)                 # this has a bip34 scriptsig,\n-        self.tx1.vin[0].scriptSig = CScript([0, 0])  # but this matches the unit tests\n-        self.tx1.vout[0].nValue = 0\n-        self.tx1.vout[0].scriptPubKey = scriptPubKey\n-        self.tx1.rehash()\n-    def create_spend_tx(self, scriptSig):\n-        self.tx2 = create_transaction(self.tx1, 0, CScript(), 0)\n-        self.tx2.vin[0].scriptSig = scriptSig\n-        self.tx2.vout[0].scriptPubKey = CScript()\n-        self.tx2.rehash()\n-    def rehash(self):\n-        self.tx1.rehash()\n-        self.tx2.rehash()\n-\n-# This test uses the (default) two nodes provided by ComparisonTestFramework,\n-# specified on the command line with --testbinary and --refbinary.\n-# See comptool.py\n-class ScriptTest(ComparisonTestFramework):\n-\n-    def run_test(self):\n-        # Set up the comparison tool TestManager\n-        test = TestManager(self, self.options.tmpdir)\n-        test.add_all_connections(self.nodes)\n-\n-        # Load scripts\n-        self.scripts = ScriptTestFile([script_valid_file, script_invalid_file])\n-        self.scripts.load_files()\n-\n-        # Some variables we re-use between test instances (to build blocks)\n-        self.tip = None\n-        self.block_time = None\n-\n-        NetworkThread().start()  # Start up network handling in another thread\n-        test.run()\n-\n-    def generate_test_instance(self, pubkeystring, scriptsigstring):\n-        scriptpubkey = ParseScript(pubkeystring)\n-        scriptsig = ParseScript(scriptsigstring)\n-\n-        test = TestInstance(sync_every_block=False)\n-        test_build = TestBuilder()\n-        test_build.create_credit_tx(scriptpubkey, self.height)\n-        test_build.create_spend_tx(scriptsig)\n-        test_build.rehash()\n-\n-        block = create_block(self.tip, test_build.tx1, self.block_time)\n-        self.block_time += 1\n-        block.solve()\n-        self.tip = block.sha256\n-        self.height += 1\n-        test.blocks_and_transactions = [[block, True]]\n-\n-        for i in xrange(100):\n-            block = create_block(self.tip, create_coinbase(self.height), self.block_time)\n-            self.block_time += 1\n-            block.solve()\n-            self.tip = block.sha256\n-            self.height += 1\n-            test.blocks_and_transactions.append([block, True])\n-\n-        block = create_block(self.tip, create_coinbase(self.height), self.block_time)\n-        self.block_time += 1\n-        block.vtx.append(test_build.tx2)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n-        block.solve()\n-        test.blocks_and_transactions.append([block, None])\n-        return test   \n-\n-    # This generates the tests for TestManager.\n-    def get_tests(self):\n-        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n-        self.block_time = 1333230000  # before the BIP16 switchover\n-        self.height = 1\n-\n-        '''\n-        Create a new block with an anyone-can-spend coinbase\n-        '''\n-        block = create_block(self.tip, create_coinbase(self.height), self.block_time)\n-        self.block_time += 1\n-        block.solve()\n-        self.tip = block.sha256\n-        self.height += 1\n-        yield TestInstance(objects=[[block, True]])\n-\n-        '''\n-        Build out to 100 blocks total, maturing the coinbase.\n-        '''\n-        test = TestInstance(objects=[], sync_every_block=False, sync_every_tx=False)\n-        for i in xrange(100):\n-            b = create_block(self.tip, create_coinbase(self.height), self.block_time)\n-            b.solve()\n-            test.blocks_and_transactions.append([b, True])\n-            self.tip = b.sha256\n-            self.block_time += 1\n-            self.height += 1\n-        yield test\n- \n-        ''' Iterate through script tests. '''\n-        counter = 0\n-        for script_test in self.scripts.get_records():\n-            ''' Reset the blockchain to genesis block + 100 blocks. '''\n-            if self.nodes[0].getblockcount() > 101:\n-                self.nodes[0].invalidateblock(self.nodes[0].getblockhash(102))\n-                self.nodes[1].invalidateblock(self.nodes[1].getblockhash(102))\n-\n-            self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n-            self.height = 102\n-\n-            [scriptsig, scriptpubkey, flags] = script_test[0:3]\n-            flags = ParseScriptFlags(flags)\n-\n-            # We can use block time to determine whether the nodes should be\n-            # enforcing BIP16.\n-            #\n-            # We intentionally let the block time grow by 1 each time.\n-            # This forces the block hashes to differ between tests, so that\n-            # a call to invalidateblock doesn't interfere with a later test.\n-            if (flags & SCRIPT_VERIFY_P2SH):\n-                self.block_time = 1333238400 + counter # Advance to enforcing BIP16\n-            else:\n-                self.block_time = 1333230000 + counter # Before the BIP16 switchover\n-\n-            print \"Script test: [%s]\" % script_test\n-\n-            yield self.generate_test_instance(scriptpubkey, scriptsig)\n-            counter += 1\n-\n-if __name__ == '__main__':\n-    ScriptTest().main()"
      }
    ]
  }
]