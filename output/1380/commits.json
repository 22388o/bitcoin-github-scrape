[
  {
    "sha": "acf513cfe75f43165ac626a608ce9cde817d97bc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphY2Y1MTNjZmU3NWY0MzE2NWFjNjI2YTYwOGNlOWNkZTgxN2Q5N2Jj",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-22T17:56:14Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-22T18:15:11Z"
      },
      "message": "Move signature cache from CKey::Verify to CheckSig in script.cpp\n\nMore than doubles the speed of verifying already-cached signatures\nthat use compressed pubkeys:\nBefore: ~200 microseconds\nAfter:  ~80 microseconds\n(no caching at all: ~3,300 microseconds per signature)\n\nAlso encapsulates the signature cache code in a class\nand fixes a signed/unsigned comparison warning.",
      "tree": {
        "sha": "4a9ca1fcc82b33e210813c1cdf71e1861cf0c26f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4a9ca1fcc82b33e210813c1cdf71e1861cf0c26f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/acf513cfe75f43165ac626a608ce9cde817d97bc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/acf513cfe75f43165ac626a608ce9cde817d97bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/acf513cfe75f43165ac626a608ce9cde817d97bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/acf513cfe75f43165ac626a608ce9cde817d97bc/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d1edab602a3ee729b308378d9d456f01e6933cfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d1edab602a3ee729b308378d9d456f01e6933cfb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d1edab602a3ee729b308378d9d456f01e6933cfb"
      }
    ],
    "stats": {
      "total": 144,
      "additions": 75,
      "deletions": 69
    },
    "files": [
      {
        "sha": "9485b477cb14d68aab4257c4def4473b52fdad74",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 65,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/acf513cfe75f43165ac626a608ce9cde817d97bc/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/acf513cfe75f43165ac626a608ce9cde817d97bc/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=acf513cfe75f43165ac626a608ce9cde817d97bc",
        "patch": "@@ -4,13 +4,10 @@\n \n #include <map>\n \n-#include <boost/tuple/tuple.hpp>\n #include <openssl/ecdsa.h>\n #include <openssl/obj_mac.h>\n \n #include \"key.h\"\n-#include \"sync.h\"\n-#include \"util.h\"\n \n // Generate a private key from just the secret parameter\n int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n@@ -352,85 +349,23 @@ bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& v\n     return false;\n }\n \n-// Valid signature cache, to avoid doing expensive ECDSA signature checking\n-// twice for every transaction (once when accepted into memory pool, and\n-// again when accepted into the block chain)\n-\n-// sigdata_type is (signature hash, signature, public key):\n-typedef boost::tuple<uint256, std::vector<unsigned char>, std::vector<unsigned char> > sigdata_type;\n-static std::set< sigdata_type> setValidSigCache;\n-static CCriticalSection cs_sigcache;\n-\n-static bool\n-GetValidSigCache(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n-{\n-    LOCK(cs_sigcache);\n-\n-    sigdata_type k(hash, vchSig, pubKey);\n-    std::set<sigdata_type>::iterator mi = setValidSigCache.find(k);\n-    if (mi != setValidSigCache.end())\n-        return true;\n-    return false;\n-}\n-\n-static void\n-SetValidSigCache(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n-{\n-    // DoS prevention: limit cache size to less than 10MB\n-    // (~200 bytes per cache entry times 50,000 entries)\n-    // Since there are a maximum of 20,000 signature operations per block\n-    // 50,000 is a reasonable default.\n-    int64 nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n-    if (nMaxCacheSize <= 0) return;\n-\n-    LOCK(cs_sigcache);\n-\n-    while (setValidSigCache.size() > nMaxCacheSize)\n-    {\n-        // Evict a random entry. Random because that helps\n-        // foil would-be DoS attackers who might try to pre-generate\n-        // and re-use a set of valid signatures just-slightly-greater\n-        // than our cache size.\n-        uint256 randomHash = GetRandHash();\n-        std::vector<unsigned char> unused;\n-        std::set<sigdata_type>::iterator it =\n-            setValidSigCache.lower_bound(sigdata_type(randomHash, unused, unused));\n-        if (it == setValidSigCache.end())\n-            it = setValidSigCache.begin();\n-        setValidSigCache.erase(*it);\n-    }\n-\n-    sigdata_type k(hash, vchSig, pubKey);\n-    setValidSigCache.insert(k);\n-}\n-\n-\n bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n {\n-    if (GetValidSigCache(hash, vchSig, GetPubKey()))\n-        return true;\n-\n     // -1 = error, 0 = bad sig, 1 = good\n     if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n         return false;\n \n-    // good sig\n-    SetValidSigCache(hash, vchSig, GetPubKey());\n     return true;\n }\n \n bool CKey::VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n {\n-    if (GetValidSigCache(hash, vchSig, GetPubKey()))\n-        return true;\n-\n     CKey key;\n     if (!key.SetCompactSignature(hash, vchSig))\n         return false;\n     if (GetPubKey() != key.GetPubKey())\n         return false;\n \n-    SetValidSigCache(hash, vchSig, GetPubKey());\n     return true;\n }\n "
      },
      {
        "sha": "0620fba234ea32490c985f201632e019631c97bb",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 4,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/acf513cfe75f43165ac626a608ce9cde817d97bc/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/acf513cfe75f43165ac626a608ce9cde817d97bc/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=acf513cfe75f43165ac626a608ce9cde817d97bc",
        "patch": "@@ -3,6 +3,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include <boost/foreach.hpp>\n+#include <boost/tuple/tuple.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -12,6 +13,8 @@ using namespace boost;\n #include \"bignum.h\"\n #include \"key.h\"\n #include \"main.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n \n bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n \n@@ -1099,12 +1102,67 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n }\n \n \n+// Valid signature cache, to avoid doing expensive ECDSA signature checking\n+// twice for every transaction (once when accepted into memory pool, and\n+// again when accepted into the block chain)\n+\n+class CSignatureCache\n+{\n+private:\n+     // sigdata_type is (signature hash, signature, public key):\n+    typedef boost::tuple<uint256, std::vector<unsigned char>, std::vector<unsigned char> > sigdata_type;\n+    std::set< sigdata_type> setValid;\n+    CCriticalSection cs_sigcache;\n+\n+public:\n+    bool\n+    Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n+    {\n+        LOCK(cs_sigcache);\n+\n+        sigdata_type k(hash, vchSig, pubKey);\n+        std::set<sigdata_type>::iterator mi = setValid.find(k);\n+        if (mi != setValid.end())\n+            return true;\n+        return false;\n+    }\n+\n+    void\n+    Set(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n+    {\n+        // DoS prevention: limit cache size to less than 10MB\n+        // (~200 bytes per cache entry times 50,000 entries)\n+        // Since there are a maximum of 20,000 signature operations per block\n+        // 50,000 is a reasonable default.\n+        int64 nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n+        if (nMaxCacheSize <= 0) return;\n+\n+        LOCK(cs_sigcache);\n+\n+        while (static_cast<int64>(setValid.size()) > nMaxCacheSize)\n+        {\n+            // Evict a random entry. Random because that helps\n+            // foil would-be DoS attackers who might try to pre-generate\n+            // and re-use a set of valid signatures just-slightly-greater\n+            // than our cache size.\n+            uint256 randomHash = GetRandHash();\n+            std::vector<unsigned char> unused;\n+            std::set<sigdata_type>::iterator it =\n+                setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n+            if (it == setValid.end())\n+                it = setValid.begin();\n+            setValid.erase(*it);\n+        }\n+\n+        sigdata_type k(hash, vchSig, pubKey);\n+        setValid.insert(k);\n+    }\n+};\n+\n bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n               const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n-    CKey key;\n-    if (!key.SetPubKey(vchPubKey))\n-        return false;\n+    static CSignatureCache signatureCache;\n \n     // Hash type is one byte tacked on to the end of the signature\n     if (vchSig.empty())\n@@ -1115,7 +1173,20 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n         return false;\n     vchSig.pop_back();\n \n-    return key.Verify(SignatureHash(scriptCode, txTo, nIn, nHashType), vchSig);\n+    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n+\n+    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n+        return true;\n+\n+    CKey key;\n+    if (!key.SetPubKey(vchPubKey))\n+        return false;\n+\n+    if (!key.Verify(sighash, vchSig))\n+        return false;\n+\n+    signatureCache.Set(sighash, vchSig, vchPubKey);\n+    return true;\n }\n \n "
      }
    ]
  }
]