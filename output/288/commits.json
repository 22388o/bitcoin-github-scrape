[
  {
    "sha": "e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplODliOWY2YTJhYmFhMTIwZmYwZmMzY2VhOWFlMzY0ZThjYmQyNWU0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-06-01T16:27:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-06-15T09:05:55Z"
      },
      "message": "move wallet code to separate file\n\nThis introduces two new source files, keystore.cpp and wallet.cpp with\ncorresponding headers. Code is moved from main and db, in a preparation\nfor a follow-up commit which introduces the classes CWallet and CKeyStore.",
      "tree": {
        "sha": "ef0789aeadd8ff3e53c2705ea9153f0e612f689c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef0789aeadd8ff3e53c2705ea9153f0e612f689c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "19ea44208f7c2cf335c654126deb81406036e328",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19ea44208f7c2cf335c654126deb81406036e328",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/19ea44208f7c2cf335c654126deb81406036e328"
      }
    ],
    "stats": {
      "total": 3425,
      "additions": 1735,
      "deletions": 1690
    },
    "files": [
      {
        "sha": "30e4bb0d8b84cd6f750690ab69356f04201293f6",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 103,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -584,9 +584,6 @@ bool LoadAddresses()\n // CWalletDB\n //\n \n-static set<int64> setKeyPool;\n-static CCriticalSection cs_setKeyPool;\n-\n bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n {\n     account.SetNull();\n@@ -831,34 +828,6 @@ bool CWalletDB::LoadWallet()\n     return true;\n }\n \n-bool LoadWallet(bool& fFirstRunRet)\n-{\n-    fFirstRunRet = false;\n-    if (!CWalletDB(\"cr+\").LoadWallet())\n-        return false;\n-    fFirstRunRet = vchDefaultKey.empty();\n-\n-    if (mapKeys.count(vchDefaultKey))\n-    {\n-        // Set keyUser\n-        keyUser.SetPubKey(vchDefaultKey);\n-        keyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n-    }\n-    else\n-    {\n-        // Create new keyUser and set as default key\n-        RandAddSeedPerfmon();\n-\n-        CWalletDB walletdb;\n-        vchDefaultKey = GetKeyFromKeyPool();\n-        walletdb.WriteDefaultKey(vchDefaultKey);\n-        walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n-    }\n-\n-    CreateThread(ThreadFlushWalletDB, NULL);\n-    return true;\n-}\n-\n void ThreadFlushWalletDB(void* parg)\n {\n     static bool fOneThread;\n@@ -954,75 +923,3 @@ void BackupWallet(const string& strDest)\n }\n \n \n-void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n-{\n-    nIndex = -1;\n-    keypool.vchPubKey.clear();\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_setKeyPool)\n-    {\n-        // Top up key pool\n-        int64 nTargetSize = max(GetArg(\"-keypool\", 100), (int64)0);\n-        while (setKeyPool.size() < nTargetSize+1)\n-        {\n-            int64 nEnd = 1;\n-            if (!setKeyPool.empty())\n-                nEnd = *(--setKeyPool.end()) + 1;\n-            if (!Write(make_pair(string(\"pool\"), nEnd), CKeyPool(GenerateNewKey())))\n-                throw runtime_error(\"ReserveKeyFromKeyPool() : writing generated key failed\");\n-            setKeyPool.insert(nEnd);\n-            printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n-        }\n-\n-        // Get the oldest key\n-        assert(!setKeyPool.empty());\n-        nIndex = *(setKeyPool.begin());\n-        setKeyPool.erase(setKeyPool.begin());\n-        if (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n-        if (!mapKeys.count(keypool.vchPubKey))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n-        assert(!keypool.vchPubKey.empty());\n-        printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n-    }\n-}\n-\n-void CWalletDB::KeepKey(int64 nIndex)\n-{\n-    // Remove from key pool\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        Erase(make_pair(string(\"pool\"), nIndex));\n-    }\n-    printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n-}\n-\n-void CWalletDB::ReturnKey(int64 nIndex)\n-{\n-    // Return to key pool\n-    CRITICAL_BLOCK(cs_setKeyPool)\n-        setKeyPool.insert(nIndex);\n-    printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n-}\n-\n-vector<unsigned char> GetKeyFromKeyPool()\n-{\n-    CWalletDB walletdb;\n-    int64 nIndex = 0;\n-    CKeyPool keypool;\n-    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n-    walletdb.KeepKey(nIndex);\n-    return keypool.vchPubKey;\n-}\n-\n-int64 GetOldestKeyPoolTime()\n-{\n-    CWalletDB walletdb;\n-    int64 nIndex = 0;\n-    CKeyPool keypool;\n-    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n-    walletdb.ReturnKey(nIndex);\n-    return keypool.nTime;\n-}"
      },
      {
        "sha": "577983725b0551c30f350bc797554edfd587ea99",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 5,
        "deletions": 29,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -25,8 +25,6 @@ class CAccount;\n class CAccountingEntry;\n class CBlockLocator;\n \n-extern std::map<std::string, std::string> mapAddressBook;\n-extern CCriticalSection cs_mapAddressBook;\n extern std::vector<unsigned char> vchDefaultKey;\n extern bool fClient;\n extern int nBestHeight;\n@@ -39,6 +37,8 @@ extern DbEnv dbenv;\n extern void DBFlush(bool fShutdown);\n extern std::vector<unsigned char> GetKeyFromKeyPool();\n extern int64 GetOldestKeyPoolTime();\n+extern void ThreadFlushWalletDB(void* parg);\n+\n \n \n \n@@ -494,33 +494,9 @@ class CReserveKey\n             ReturnKey();\n     }\n \n-    std::vector<unsigned char> GetReservedKey()\n-    {\n-        if (nIndex == -1)\n-        {\n-            CKeyPool keypool;\n-            CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n-            vchPubKey = keypool.vchPubKey;\n-        }\n-        assert(!vchPubKey.empty());\n-        return vchPubKey;\n-    }\n-\n-    void KeepKey()\n-    {\n-        if (nIndex != -1)\n-            CWalletDB().KeepKey(nIndex);\n-        nIndex = -1;\n-        vchPubKey.clear();\n-    }\n-\n-    void ReturnKey()\n-    {\n-        if (nIndex != -1)\n-            CWalletDB::ReturnKey(nIndex);\n-        nIndex = -1;\n-        vchPubKey.clear();\n-    }\n+    std::vector<unsigned char> GetReservedKey();\n+    void KeepKey();\n+    void ReturnKey();\n };\n \n #endif"
      },
      {
        "sha": "d1844eb24e30ae8fb62711a612328ad4106e668a",
        "filename": "src/headers.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/headers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/headers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/headers.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -91,10 +91,8 @@\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n-#include \"key.h\"\n #include \"bignum.h\"\n #include \"base58.h\"\n-#include \"script.h\"\n #include \"main.h\"\n #ifdef GUI\n #include \"uibase.h\""
      },
      {
        "sha": "51f39a5251dfdf3142bf5d922f5c59120c16a1b3",
        "filename": "src/keystore.cpp",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -0,0 +1,33 @@\n+// Copyright (c) 2009-2011 Satoshi Nakamoto & Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"headers.h\"\n+#include \"db.h\"\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// mapKeys\n+//\n+\n+std::vector<unsigned char> GenerateNewKey()\n+{\n+    RandAddSeedPerfmon();\n+    CKey key;\n+    key.MakeNewKey();\n+    if (!AddKey(key))\n+        throw std::runtime_error(\"GenerateNewKey() : AddKey failed\");\n+    return key.GetPubKey();\n+}\n+\n+bool AddKey(const CKey& key)\n+{\n+    CRITICAL_BLOCK(cs_mapKeys)\n+    {\n+        mapKeys[key.GetPubKey()] = key.GetPrivKey();\n+        mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();\n+    }\n+    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());\n+}"
      },
      {
        "sha": "2f37ec5078310c1f69275f5f0d24386e0e455464",
        "filename": "src/keystore.h",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright (c) 2009-2011 Satoshi Nakamoto & Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_KEYSTORE_H\n+#define BITCOIN_KEYSTORE_H\n+\n+bool AddKey(const CKey& key);\n+std::vector<unsigned char> GenerateNewKey();\n+\n+#endif"
      },
      {
        "sha": "8949b97be659fedc3a40b48d14551252589f8d06",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 165,
        "deletions": 1116,
        "changes": 1281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -54,6 +54,9 @@ CCriticalSection cs_mapRequestCount;\n map<string, string> mapAddressBook;\n CCriticalSection cs_mapAddressBook;\n \n+set<int64> setKeyPool;\n+CCriticalSection cs_setKeyPool;\n+\n vector<unsigned char> vchDefaultKey;\n \n double dHashesPerSec;\n@@ -79,160 +82,6 @@ int fUseUPnP = false;\n \n \n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// mapKeys\n-//\n-\n-bool AddKey(const CKey& key)\n-{\n-    CRITICAL_BLOCK(cs_mapKeys)\n-    {\n-        mapKeys[key.GetPubKey()] = key.GetPrivKey();\n-        mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();\n-    }\n-    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());\n-}\n-\n-vector<unsigned char> GenerateNewKey()\n-{\n-    RandAddSeedPerfmon();\n-    CKey key;\n-    key.MakeNewKey();\n-    if (!AddKey(key))\n-        throw runtime_error(\"GenerateNewKey() : AddKey failed\");\n-    return key.GetPubKey();\n-}\n-\n-\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// mapWallet\n-//\n-\n-bool AddToWallet(const CWalletTx& wtxIn)\n-{\n-    uint256 hash = wtxIn.GetHash();\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        // Inserts only if not already there, returns tx inserted or tx found\n-        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n-        CWalletTx& wtx = (*ret.first).second;\n-        bool fInsertedNew = ret.second;\n-        if (fInsertedNew)\n-            wtx.nTimeReceived = GetAdjustedTime();\n-\n-        bool fUpdated = false;\n-        if (!fInsertedNew)\n-        {\n-            // Merge\n-            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n-            {\n-                wtx.hashBlock = wtxIn.hashBlock;\n-                fUpdated = true;\n-            }\n-            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n-            {\n-                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n-                wtx.nIndex = wtxIn.nIndex;\n-                fUpdated = true;\n-            }\n-            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n-            {\n-                wtx.fFromMe = wtxIn.fFromMe;\n-                fUpdated = true;\n-            }\n-            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n-        }\n-\n-        //// debug print\n-        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n-\n-        // Write to disk\n-        if (fInsertedNew || fUpdated)\n-            if (!wtx.WriteToDisk())\n-                return false;\n-\n-        // If default receiving address gets used, replace it with a new one\n-        CScript scriptDefaultKey;\n-        scriptDefaultKey.SetBitcoinAddress(vchDefaultKey);\n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-        {\n-            if (txout.scriptPubKey == scriptDefaultKey)\n-            {\n-                CWalletDB walletdb;\n-                vchDefaultKey = GetKeyFromKeyPool();\n-                walletdb.WriteDefaultKey(vchDefaultKey);\n-                walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n-            }\n-        }\n-\n-        // Notify UI\n-        vWalletUpdated.push_back(hash);\n-    }\n-\n-    // Refresh UI\n-    MainFrameRepaint();\n-    return true;\n-}\n-\n-bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false)\n-{\n-    uint256 hash = tx.GetHash();\n-    bool fExisted = mapWallet.count(hash);\n-    if (fExisted && !fUpdate) return false;\n-    if (fExisted || tx.IsMine() || tx.IsFromMe())\n-    {\n-        CWalletTx wtx(tx);\n-        // Get merkle branch if transaction was found in a block\n-        if (pblock)\n-            wtx.SetMerkleBranch(pblock);\n-        return AddToWallet(wtx);\n-    }\n-    return false;\n-}\n-\n-bool EraseFromWallet(uint256 hash)\n-{\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        if (mapWallet.erase(hash))\n-            CWalletDB().EraseTx(hash);\n-    }\n-    return true;\n-}\n-\n-void WalletUpdateSpent(const COutPoint& prevout)\n-{\n-    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n-    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n-    // restored from backup or the user making copies of wallet.dat.\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n-        if (mi != mapWallet.end())\n-        {\n-            CWalletTx& wtx = (*mi).second;\n-            if (!wtx.IsSpent(prevout.n) && wtx.vout[prevout.n].IsMine())\n-            {\n-                printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n-                wtx.MarkSpent(prevout.n);\n-                wtx.WriteToDisk();\n-                vWalletUpdated.push_back(prevout.hash);\n-            }\n-        }\n-    }\n-}\n-\n-\n-\n-\n-\n-\n-\n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // mapOrphanTransactions\n@@ -312,190 +161,6 @@ bool CTransaction::ReadFromDisk(COutPoint prevout)\n     return ReadFromDisk(txdb, prevout, txindex);\n }\n \n-bool CTxIn::IsMine() const\n-{\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n-        if (mi != mapWallet.end())\n-        {\n-            const CWalletTx& prev = (*mi).second;\n-            if (prevout.n < prev.vout.size())\n-                if (prev.vout[prevout.n].IsMine())\n-                    return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-int64 CTxIn::GetDebit() const\n-{\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n-        if (mi != mapWallet.end())\n-        {\n-            const CWalletTx& prev = (*mi).second;\n-            if (prevout.n < prev.vout.size())\n-                if (prev.vout[prevout.n].IsMine())\n-                    return prev.vout[prevout.n].nValue;\n-        }\n-    }\n-    return 0;\n-}\n-\n-int64 CWalletTx::GetTxTime() const\n-{\n-    if (!fTimeReceivedIsTxTime && hashBlock != 0)\n-    {\n-        // If we did not receive the transaction directly, we rely on the block's\n-        // time to figure out when it happened.  We use the median over a range\n-        // of blocks to try to filter out inaccurate block times.\n-        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end())\n-        {\n-            CBlockIndex* pindex = (*mi).second;\n-            if (pindex)\n-                return pindex->GetMedianTime();\n-        }\n-    }\n-    return nTimeReceived;\n-}\n-\n-int CWalletTx::GetRequestCount() const\n-{\n-    // Returns -1 if it wasn't being tracked\n-    int nRequests = -1;\n-    CRITICAL_BLOCK(cs_mapRequestCount)\n-    {\n-        if (IsCoinBase())\n-        {\n-            // Generated block\n-            if (hashBlock != 0)\n-            {\n-                map<uint256, int>::iterator mi = mapRequestCount.find(hashBlock);\n-                if (mi != mapRequestCount.end())\n-                    nRequests = (*mi).second;\n-            }\n-        }\n-        else\n-        {\n-            // Did anyone request this transaction?\n-            map<uint256, int>::iterator mi = mapRequestCount.find(GetHash());\n-            if (mi != mapRequestCount.end())\n-            {\n-                nRequests = (*mi).second;\n-\n-                // How about the block it's in?\n-                if (nRequests == 0 && hashBlock != 0)\n-                {\n-                    map<uint256, int>::iterator mi = mapRequestCount.find(hashBlock);\n-                    if (mi != mapRequestCount.end())\n-                        nRequests = (*mi).second;\n-                    else\n-                        nRequests = 1; // If it's in someone else's block it must have got out\n-                }\n-            }\n-        }\n-    }\n-    return nRequests;\n-}\n-\n-void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, list<pair<string, int64> >& listReceived,\n-                           list<pair<string, int64> >& listSent, int64& nFee, string& strSentAccount) const\n-{\n-    nGeneratedImmature = nGeneratedMature = nFee = 0;\n-    listReceived.clear();\n-    listSent.clear();\n-    strSentAccount = strFromAccount;\n-\n-    if (IsCoinBase())\n-    {\n-        if (GetBlocksToMaturity() > 0)\n-            nGeneratedImmature = CTransaction::GetCredit();\n-        else\n-            nGeneratedMature = GetCredit();\n-        return;\n-    }\n-\n-    // Compute fee:\n-    int64 nDebit = GetDebit();\n-    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n-    {\n-        int64 nValueOut = GetValueOut();\n-        nFee = nDebit - nValueOut;\n-    }\n-\n-    // Sent/received.  Standard client will never generate a send-to-multiple-recipients,\n-    // but non-standard clients might (so return a list of address/amount pairs)\n-    BOOST_FOREACH(const CTxOut& txout, vout)\n-    {\n-        string address;\n-        uint160 hash160;\n-        vector<unsigned char> vchPubKey;\n-        if (ExtractHash160(txout.scriptPubKey, hash160))\n-            address = Hash160ToAddress(hash160);\n-        else if (ExtractPubKey(txout.scriptPubKey, false, vchPubKey))\n-            address = PubKeyToAddress(vchPubKey);\n-        else\n-        {\n-            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n-                   this->GetHash().ToString().c_str());\n-            address = \" unknown \";\n-        }\n-\n-        // Don't report 'change' txouts\n-        if (nDebit > 0 && txout.IsChange())\n-            continue;\n-\n-        if (nDebit > 0)\n-            listSent.push_back(make_pair(address, txout.nValue));\n-\n-        if (txout.IsMine())\n-            listReceived.push_back(make_pair(address, txout.nValue));\n-    }\n-\n-}\n-\n-void CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, int64& nReceived, \n-                                  int64& nSent, int64& nFee) const\n-{\n-    nGenerated = nReceived = nSent = nFee = 0;\n-\n-    int64 allGeneratedImmature, allGeneratedMature, allFee;\n-    allGeneratedImmature = allGeneratedMature = allFee = 0;\n-    string strSentAccount;\n-    list<pair<string, int64> > listReceived;\n-    list<pair<string, int64> > listSent;\n-    GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n-\n-    if (strAccount == \"\")\n-        nGenerated = allGeneratedMature;\n-    if (strAccount == strSentAccount)\n-    {\n-        BOOST_FOREACH(const PAIRTYPE(string,int64)& s, listSent)\n-            nSent += s.second;\n-        nFee = allFee;\n-    }\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n-    {\n-        BOOST_FOREACH(const PAIRTYPE(string,int64)& r, listReceived)\n-        {\n-            if (mapAddressBook.count(r.first))\n-            {\n-                if (mapAddressBook[r.first] == strAccount)\n-                {\n-                    nReceived += r.second;\n-                }\n-            }\n-            else if (strAccount.empty())\n-            {\n-                nReceived += r.second;\n-            }\n-        }\n-    }\n-}\n-\n \n \n int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n@@ -551,69 +216,6 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n \n \n \n-void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n-{\n-    vtxPrev.clear();\n-\n-    const int COPY_DEPTH = 3;\n-    if (SetMerkleBranch() < COPY_DEPTH)\n-    {\n-        vector<uint256> vWorkQueue;\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-            vWorkQueue.push_back(txin.prevout.hash);\n-\n-        // This critsect is OK because txdb is already open\n-        CRITICAL_BLOCK(cs_mapWallet)\n-        {\n-            map<uint256, const CMerkleTx*> mapWalletPrev;\n-            set<uint256> setAlreadyDone;\n-            for (int i = 0; i < vWorkQueue.size(); i++)\n-            {\n-                uint256 hash = vWorkQueue[i];\n-                if (setAlreadyDone.count(hash))\n-                    continue;\n-                setAlreadyDone.insert(hash);\n-\n-                CMerkleTx tx;\n-                if (mapWallet.count(hash))\n-                {\n-                    tx = mapWallet[hash];\n-                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, mapWallet[hash].vtxPrev)\n-                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n-                }\n-                else if (mapWalletPrev.count(hash))\n-                {\n-                    tx = *mapWalletPrev[hash];\n-                }\n-                else if (!fClient && txdb.ReadDiskTx(hash, tx))\n-                {\n-                    ;\n-                }\n-                else\n-                {\n-                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n-                    continue;\n-                }\n-\n-                int nDepth = tx.SetMerkleBranch();\n-                vtxPrev.push_back(tx);\n-\n-                if (nDepth < COPY_DEPTH)\n-                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-                        vWorkQueue.push_back(txin.prevout.hash);\n-            }\n-        }\n-    }\n-\n-    reverse(vtxPrev.begin(), vtxPrev.end());\n-}\n-\n-\n-\n-\n-\n-\n-\n \n \n \n@@ -784,6 +386,11 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     return true;\n }\n \n+bool CTransaction::AcceptToMemoryPool(bool fCheckInputs, bool* pfMissingInputs)\n+{\n+    CTxDB txdb(\"r\");\n+    return AcceptToMemoryPool(txdb, fCheckInputs, pfMissingInputs);\n+}\n \n bool CTransaction::AddToMemoryPoolUnchecked()\n {\n@@ -867,6 +474,12 @@ bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n     }\n }\n \n+bool CMerkleTx::AcceptToMemoryPool()\n+{\n+    CTxDB txdb(\"r\");\n+    return AcceptToMemoryPool(txdb);\n+}\n+\n \n \n bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n@@ -888,148 +501,10 @@ bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n     return false;\n }\n \n-int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n-{\n-    int ret = 0;\n-\n-    CBlockIndex* pindex = pindexStart;\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        while (pindex)\n-        {\n-            CBlock block;\n-            block.ReadFromDisk(pindex, true);\n-            BOOST_FOREACH(CTransaction& tx, block.vtx)\n-            {\n-                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n-                    ret++;\n-            }\n-            pindex = pindex->pnext;\n-        }\n-    }\n-    return ret;\n-}\n-\n-void ReacceptWalletTransactions()\n-{\n-    CTxDB txdb(\"r\");\n-    bool fRepeat = true;\n-    while (fRepeat) CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        fRepeat = false;\n-        vector<CDiskTxPos> vMissingTx;\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n-        {\n-            CWalletTx& wtx = item.second;\n-            if (wtx.IsCoinBase() && wtx.IsSpent(0))\n-                continue;\n-\n-            CTxIndex txindex;\n-            bool fUpdated = false;\n-            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n-            {\n-                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n-                if (txindex.vSpent.size() != wtx.vout.size())\n-                {\n-                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %d != wtx.vout.size() %d\\n\", txindex.vSpent.size(), wtx.vout.size());\n-                    continue;\n-                }\n-                for (int i = 0; i < txindex.vSpent.size(); i++)\n-                {\n-                    if (wtx.IsSpent(i))\n-                        continue;\n-                    if (!txindex.vSpent[i].IsNull() && wtx.vout[i].IsMine())\n-                    {\n-                        wtx.MarkSpent(i);\n-                        fUpdated = true;\n-                        vMissingTx.push_back(txindex.vSpent[i]);\n-                    }\n-                }\n-                if (fUpdated)\n-                {\n-                    printf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n-                    wtx.MarkDirty();\n-                    wtx.WriteToDisk();\n-                }\n-            }\n-            else\n-            {\n-                // Reaccept any txes of ours that aren't already in a block\n-                if (!wtx.IsCoinBase())\n-                    wtx.AcceptWalletTransaction(txdb, false);\n-            }\n-        }\n-        if (!vMissingTx.empty())\n-        {\n-            // TODO: optimize this to scan just part of the block chain?\n-            if (ScanForWalletTransactions(pindexGenesisBlock))\n-                fRepeat = true;  // Found missing transactions: re-do Reaccept.\n-        }\n-    }\n-}\n-\n-\n-void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n-{\n-    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n-    {\n-        if (!tx.IsCoinBase())\n-        {\n-            uint256 hash = tx.GetHash();\n-            if (!txdb.ContainsTx(hash))\n-                RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n-        }\n-    }\n-    if (!IsCoinBase())\n-    {\n-        uint256 hash = GetHash();\n-        if (!txdb.ContainsTx(hash))\n-        {\n-            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n-            RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n-        }\n-    }\n-}\n-\n-void ResendWalletTransactions()\n+bool CWalletTx::AcceptWalletTransaction() \n {\n-    // Do this infrequently and randomly to avoid giving away\n-    // that these are our transactions.\n-    static int64 nNextTime;\n-    if (GetTime() < nNextTime)\n-        return;\n-    bool fFirst = (nNextTime == 0);\n-    nNextTime = GetTime() + GetRand(30 * 60);\n-    if (fFirst)\n-        return;\n-\n-    // Only do it if there's been a new block since last time\n-    static int64 nLastTime;\n-    if (nTimeBestReceived < nLastTime)\n-        return;\n-    nLastTime = GetTime();\n-\n-    // Rebroadcast any of our txes that aren't in a block yet\n-    printf(\"ResendWalletTransactions()\\n\");\n     CTxDB txdb(\"r\");\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        // Sort them in chronological order\n-        multimap<unsigned int, CWalletTx*> mapSorted;\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n-        {\n-            CWalletTx& wtx = item.second;\n-            // Don't rebroadcast until it's had plenty of time that\n-            // it should have gotten in already by now.\n-            if (nTimeBestReceived - (int64)wtx.nTimeReceived > 5 * 60)\n-                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n-        }\n-        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n-        {\n-            CWalletTx& wtx = *item.second;\n-            wtx.RelayWalletTransaction(txdb);\n-        }\n-    }\n+    return AcceptWalletTransaction(txdb);\n }\n \n int CTxIndex::GetDepthInMainChain() const\n@@ -1076,6 +551,7 @@ bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n     return true;\n }\n \n+\n uint256 GetOrphanRoot(const CBlock* pblock)\n {\n     // Work back to the first block in the orphan chain\n@@ -2221,127 +1697,6 @@ bool AlreadyHave(CTxDB& txdb, const CInv& inv)\n char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n \n \n-bool ProcessMessages(CNode* pfrom)\n-{\n-    CDataStream& vRecv = pfrom->vRecv;\n-    if (vRecv.empty())\n-        return true;\n-    //if (fDebug)\n-    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n-\n-    //\n-    // Message format\n-    //  (4) message start\n-    //  (12) command\n-    //  (4) size\n-    //  (4) checksum\n-    //  (x) data\n-    //\n-\n-    loop\n-    {\n-        // Scan for message start\n-        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n-        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n-        if (vRecv.end() - pstart < nHeaderSize)\n-        {\n-            if (vRecv.size() > nHeaderSize)\n-            {\n-                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n-                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n-            }\n-            break;\n-        }\n-        if (pstart - vRecv.begin() > 0)\n-            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n-        vRecv.erase(vRecv.begin(), pstart);\n-\n-        // Read header\n-        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n-        CMessageHeader hdr;\n-        vRecv >> hdr;\n-        if (!hdr.IsValid())\n-        {\n-            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n-            continue;\n-        }\n-        string strCommand = hdr.GetCommand();\n-\n-        // Message size\n-        unsigned int nMessageSize = hdr.nMessageSize;\n-        if (nMessageSize > MAX_SIZE)\n-        {\n-            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n-            continue;\n-        }\n-        if (nMessageSize > vRecv.size())\n-        {\n-            // Rewind and wait for rest of message\n-            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n-            break;\n-        }\n-\n-        // Checksum\n-        if (vRecv.GetVersion() >= 209)\n-        {\n-            uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n-            unsigned int nChecksum = 0;\n-            memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-            if (nChecksum != hdr.nChecksum)\n-            {\n-                printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n-                       strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n-                continue;\n-            }\n-        }\n-\n-        // Copy message to its own buffer\n-        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n-        vRecv.ignore(nMessageSize);\n-\n-        // Process message\n-        bool fRet = false;\n-        try\n-        {\n-            CRITICAL_BLOCK(cs_main)\n-                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n-            if (fShutdown)\n-                return true;\n-        }\n-        catch (std::ios_base::failure& e)\n-        {\n-            if (strstr(e.what(), \"end of data\"))\n-            {\n-                // Allow exceptions from underlength message on vRecv\n-                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"size too large\"))\n-            {\n-                // Allow exceptions from overlong size\n-                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n-            }\n-            else\n-            {\n-                PrintExceptionContinue(&e, \"ProcessMessage()\");\n-            }\n-        }\n-        catch (std::exception& e) {\n-            PrintExceptionContinue(&e, \"ProcessMessage()\");\n-        } catch (...) {\n-            PrintExceptionContinue(NULL, \"ProcessMessage()\");\n-        }\n-\n-        if (!fRet)\n-            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n-    }\n-\n-    vRecv.Compact();\n-    return true;\n-}\n-\n-\n-\n-\n bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n {\n     static map<unsigned int, vector<unsigned char> > mapReuseKey;\n@@ -2885,9 +2240,123 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n }\n \n \n+bool ProcessMessages(CNode* pfrom)\n+{\n+    CDataStream& vRecv = pfrom->vRecv;\n+    if (vRecv.empty())\n+        return true;\n+    //if (fDebug)\n+    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n \n+    //\n+    // Message format\n+    //  (4) message start\n+    //  (12) command\n+    //  (4) size\n+    //  (4) checksum\n+    //  (x) data\n+    //\n \n+    loop\n+    {\n+        // Scan for message start\n+        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n+        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n+        if (vRecv.end() - pstart < nHeaderSize)\n+        {\n+            if (vRecv.size() > nHeaderSize)\n+            {\n+                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n+                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n+            }\n+            break;\n+        }\n+        if (pstart - vRecv.begin() > 0)\n+            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n+        vRecv.erase(vRecv.begin(), pstart);\n \n+        // Read header\n+        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n+        CMessageHeader hdr;\n+        vRecv >> hdr;\n+        if (!hdr.IsValid())\n+        {\n+            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n+            continue;\n+        }\n+        string strCommand = hdr.GetCommand();\n+\n+        // Message size\n+        unsigned int nMessageSize = hdr.nMessageSize;\n+        if (nMessageSize > MAX_SIZE)\n+        {\n+            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n+            continue;\n+        }\n+        if (nMessageSize > vRecv.size())\n+        {\n+            // Rewind and wait for rest of message\n+            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n+            break;\n+        }\n+\n+        // Checksum\n+        if (vRecv.GetVersion() >= 209)\n+        {\n+            uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n+            unsigned int nChecksum = 0;\n+            memcpy(&nChecksum, &hash, sizeof(nChecksum));\n+            if (nChecksum != hdr.nChecksum)\n+            {\n+                printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n+                       strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n+                continue;\n+            }\n+        }\n+\n+        // Copy message to its own buffer\n+        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n+        vRecv.ignore(nMessageSize);\n+\n+        // Process message\n+        bool fRet = false;\n+        try\n+        {\n+            CRITICAL_BLOCK(cs_main)\n+                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n+            if (fShutdown)\n+                return true;\n+        }\n+        catch (std::ios_base::failure& e)\n+        {\n+            if (strstr(e.what(), \"end of data\"))\n+            {\n+                // Allow exceptions from underlength message on vRecv\n+                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n+            }\n+            else if (strstr(e.what(), \"size too large\"))\n+            {\n+                // Allow exceptions from overlong size\n+                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n+            }\n+            else\n+            {\n+                PrintExceptionContinue(&e, \"ProcessMessage()\");\n+            }\n+        }\n+        catch (std::exception& e) {\n+            PrintExceptionContinue(&e, \"ProcessMessage()\");\n+        } catch (...) {\n+            PrintExceptionContinue(NULL, \"ProcessMessage()\");\n+        }\n+\n+        if (!fRet)\n+            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n+    }\n+\n+    vRecv.Compact();\n+    return true;\n+}\n \n \n \n@@ -3096,56 +2565,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n // BitcoinMiner\n //\n \n-void GenerateBitcoins(bool fGenerate)\n-{\n-    if (fGenerateBitcoins != fGenerate)\n-    {\n-        fGenerateBitcoins = fGenerate;\n-        CWalletDB().WriteSetting(\"fGenerateBitcoins\", fGenerateBitcoins);\n-        MainFrameRepaint();\n-    }\n-    if (fGenerateBitcoins)\n-    {\n-        int nProcessors = boost::thread::hardware_concurrency();\n-        printf(\"%d processors\\n\", nProcessors);\n-        if (nProcessors < 1)\n-            nProcessors = 1;\n-        if (fLimitProcessors && nProcessors > nLimitProcessors)\n-            nProcessors = nLimitProcessors;\n-        int nAddThreads = nProcessors - vnThreadsRunning[3];\n-        printf(\"Starting %d BitcoinMiner threads\\n\", nAddThreads);\n-        for (int i = 0; i < nAddThreads; i++)\n-        {\n-            if (!CreateThread(ThreadBitcoinMiner, NULL))\n-                printf(\"Error: CreateThread(ThreadBitcoinMiner) failed\\n\");\n-            Sleep(10);\n-        }\n-    }\n-}\n-\n-void ThreadBitcoinMiner(void* parg)\n-{\n-    try\n-    {\n-        vnThreadsRunning[3]++;\n-        BitcoinMiner();\n-        vnThreadsRunning[3]--;\n-    }\n-    catch (std::exception& e) {\n-        vnThreadsRunning[3]--;\n-        PrintException(&e, \"ThreadBitcoinMiner()\");\n-    } catch (...) {\n-        vnThreadsRunning[3]--;\n-        PrintException(NULL, \"ThreadBitcoinMiner()\");\n-    }\n-    UIThreadCall(boost::bind(CalledSetStatusBar, \"\", 0));\n-    nHPSTimerStart = 0;\n-    if (vnThreadsRunning[3] == 0)\n-        dHashesPerSec = 0;\n-    printf(\"ThreadBitcoinMiner exiting, %d threads remaining\\n\", vnThreadsRunning[3]);\n-}\n-\n-\n int FormatHashBlocks(void* pbuffer, unsigned int len)\n {\n     unsigned char* pdata = (unsigned char*)pbuffer;\n@@ -3473,7 +2892,6 @@ bool CheckWork(CBlock* pblock, CReserveKey& reservekey)\n     return true;\n }\n \n-\n void BitcoinMiner()\n {\n     printf(\"BitcoinMiner started\\n\");\n@@ -3617,421 +3035,52 @@ void BitcoinMiner()\n     }\n }\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// Actions\n-//\n-\n-\n-int64 GetBalance()\n-{\n-    int64 nStart = GetTimeMillis();\n-\n-    int64 nTotal = 0;\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-        {\n-            CWalletTx* pcoin = &(*it).second;\n-            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n-                continue;\n-            nTotal += pcoin->GetAvailableCredit();\n-        }\n-    }\n-\n-    //printf(\"GetBalance() %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n-    return nTotal;\n-}\n-\n-\n-bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet)\n+void ThreadBitcoinMiner(void* parg)\n {\n-    setCoinsRet.clear();\n-    nValueRet = 0;\n-\n-    // List of values less than target\n-    pair<int64, pair<CWalletTx*,unsigned int> > coinLowestLarger;\n-    coinLowestLarger.first = INT64_MAX;\n-    coinLowestLarger.second.first = NULL;\n-    vector<pair<int64, pair<CWalletTx*,unsigned int> > > vValue;\n-    int64 nTotalLower = 0;\n-\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    {\n-       vector<CWalletTx*> vCoins;\n-       vCoins.reserve(mapWallet.size());\n-       for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-           vCoins.push_back(&(*it).second);\n-       random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n-\n-       BOOST_FOREACH(CWalletTx* pcoin, vCoins)\n-       {\n-            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n-                continue;\n-\n-            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n-                continue;\n-\n-            int nDepth = pcoin->GetDepthInMainChain();\n-            if (nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n-                continue;\n-\n-            for (int i = 0; i < pcoin->vout.size(); i++)\n-            {\n-                if (pcoin->IsSpent(i) || !pcoin->vout[i].IsMine())\n-                    continue;\n-\n-                int64 n = pcoin->vout[i].nValue;\n-\n-                if (n <= 0)\n-                    continue;\n-\n-                pair<int64,pair<CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n-\n-                if (n == nTargetValue)\n-                {\n-                    setCoinsRet.insert(coin.second);\n-                    nValueRet += coin.first;\n-                    return true;\n-                }\n-                else if (n < nTargetValue + CENT)\n-                {\n-                    vValue.push_back(coin);\n-                    nTotalLower += n;\n-                }\n-                else if (n < coinLowestLarger.first)\n-                {\n-                    coinLowestLarger = coin;\n-                }\n-            }\n-        }\n-    }\n-\n-    if (nTotalLower == nTargetValue || nTotalLower == nTargetValue + CENT)\n-    {\n-        for (int i = 0; i < vValue.size(); ++i)\n-        {\n-            setCoinsRet.insert(vValue[i].second);\n-            nValueRet += vValue[i].first;\n-        }\n-        return true;\n-    }\n-\n-    if (nTotalLower < nTargetValue + (coinLowestLarger.second.first ? CENT : 0))\n-    {\n-        if (coinLowestLarger.second.first == NULL)\n-            return false;\n-        setCoinsRet.insert(coinLowestLarger.second);\n-        nValueRet += coinLowestLarger.first;\n-        return true;\n-    }\n-\n-    if (nTotalLower >= nTargetValue + CENT)\n-        nTargetValue += CENT;\n-\n-    // Solve subset sum by stochastic approximation\n-    sort(vValue.rbegin(), vValue.rend());\n-    vector<char> vfIncluded;\n-    vector<char> vfBest(vValue.size(), true);\n-    int64 nBest = nTotalLower;\n-\n-    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)\n-    {\n-        vfIncluded.assign(vValue.size(), false);\n-        int64 nTotal = 0;\n-        bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n-            for (int i = 0; i < vValue.size(); i++)\n-            {\n-                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n-                {\n-                    nTotal += vValue[i].first;\n-                    vfIncluded[i] = true;\n-                    if (nTotal >= nTargetValue)\n-                    {\n-                        fReachedTarget = true;\n-                        if (nTotal < nBest)\n-                        {\n-                            nBest = nTotal;\n-                            vfBest = vfIncluded;\n-                        }\n-                        nTotal -= vValue[i].first;\n-                        vfIncluded[i] = false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // If the next larger is still closer, return it\n-    if (coinLowestLarger.second.first && coinLowestLarger.first - nTargetValue <= nBest - nTargetValue)\n+    try\n     {\n-        setCoinsRet.insert(coinLowestLarger.second);\n-        nValueRet += coinLowestLarger.first;\n+        vnThreadsRunning[3]++;\n+        BitcoinMiner();\n+        vnThreadsRunning[3]--;\n     }\n-    else {\n-        for (int i = 0; i < vValue.size(); i++)\n-            if (vfBest[i])\n-            {\n-                setCoinsRet.insert(vValue[i].second);\n-                nValueRet += vValue[i].first;\n-            }\n-\n-        //// debug print\n-        printf(\"SelectCoins() best subset: \");\n-        for (int i = 0; i < vValue.size(); i++)\n-            if (vfBest[i])\n-                printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n-        printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n+    catch (std::exception& e) {\n+        vnThreadsRunning[3]--;\n+        PrintException(&e, \"ThreadBitcoinMiner()\");\n+    } catch (...) {\n+        vnThreadsRunning[3]--;\n+        PrintException(NULL, \"ThreadBitcoinMiner()\");\n     }\n-\n-    return true;\n-}\n-\n-bool SelectCoins(int64 nTargetValue, set<pair<CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet)\n-{\n-    return (SelectCoinsMinConf(nTargetValue, 1, 6, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 1, 1, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 0, 1, setCoinsRet, nValueRet));\n+    UIThreadCall(boost::bind(CalledSetStatusBar, \"\", 0));\n+    nHPSTimerStart = 0;\n+    if (vnThreadsRunning[3] == 0)\n+        dHashesPerSec = 0;\n+    printf(\"ThreadBitcoinMiner exiting, %d threads remaining\\n\", vnThreadsRunning[3]);\n }\n \n \n-\n-\n-bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n+void GenerateBitcoins(bool fGenerate)\n {\n-    int64 nValue = 0;\n-    BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n-    {\n-        if (nValue < 0)\n-            return false;\n-        nValue += s.second;\n-    }\n-    if (vecSend.empty() || nValue < 0)\n-        return false;\n-\n-    CRITICAL_BLOCK(cs_main)\n+    if (fGenerateBitcoins != fGenerate)\n     {\n-        // txdb must be opened before the mapWallet lock\n-        CTxDB txdb(\"r\");\n-        CRITICAL_BLOCK(cs_mapWallet)\n-        {\n-            nFeeRet = nTransactionFee;\n-            loop\n-            {\n-                wtxNew.vin.clear();\n-                wtxNew.vout.clear();\n-                wtxNew.fFromMe = true;\n-\n-                int64 nTotalValue = nValue + nFeeRet;\n-                double dPriority = 0;\n-                // vouts to the payees\n-                BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n-                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n-\n-                // Choose coins to use\n-                set<pair<CWalletTx*,unsigned int> > setCoins;\n-                int64 nValueIn = 0;\n-                if (!SelectCoins(nTotalValue, setCoins, nValueIn))\n-                    return false;\n-                BOOST_FOREACH(PAIRTYPE(CWalletTx*, unsigned int) pcoin, setCoins)\n-                {\n-                    int64 nCredit = pcoin.first->vout[pcoin.second].nValue;\n-                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n-                }\n-\n-                int64 nChange = nValueIn - nValue - nFeeRet;\n-\n-                // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n-                // or until nChange becomes zero\n-                if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n-                {\n-                    int64 nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n-                    nChange -= nMoveToFee;\n-                    nFeeRet += nMoveToFee;\n-                }\n-\n-                if (nChange > 0)\n-                {\n-                    // Note: We use a new key here to keep it from being obvious which side is the change.\n-                    //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                    //  backup is restored, if the backup doesn't have the new private key for the change.\n-                    //  If we reused the old key, it would be possible to add code to look for and\n-                    //  rediscover unknown transactions that were written with keys of ours to recover\n-                    //  post-backup change.\n-\n-                    // Reserve a new key pair from key pool\n-                    vector<unsigned char> vchPubKey = reservekey.GetReservedKey();\n-                    assert(mapKeys.count(vchPubKey));\n-\n-                    // Fill a vout to ourself, using same address type as the payment\n-                    CScript scriptChange;\n-                    if (vecSend[0].first.GetBitcoinAddressHash160() != 0)\n-                        scriptChange.SetBitcoinAddress(vchPubKey);\n-                    else\n-                        scriptChange << vchPubKey << OP_CHECKSIG;\n-\n-                    // Insert change txn at random position:\n-                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n-                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n-                }\n-                else\n-                    reservekey.ReturnKey();\n-\n-                // Fill vin\n-                BOOST_FOREACH(const PAIRTYPE(CWalletTx*,unsigned int)& coin, setCoins)\n-                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n-\n-                // Sign\n-                int nIn = 0;\n-                BOOST_FOREACH(const PAIRTYPE(CWalletTx*,unsigned int)& coin, setCoins)\n-                    if (!SignSignature(*coin.first, wtxNew, nIn++))\n-                        return false;\n-\n-                // Limit size\n-                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK);\n-                if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n-                    return false;\n-                dPriority /= nBytes;\n-\n-                // Check that enough fee is included\n-                int64 nPayFee = nTransactionFee * (1 + (int64)nBytes / 1000);\n-                bool fAllowFree = CTransaction::AllowFree(dPriority);\n-                int64 nMinFee = wtxNew.GetMinFee(1, fAllowFree);\n-                if (nFeeRet < max(nPayFee, nMinFee))\n-                {\n-                    nFeeRet = max(nPayFee, nMinFee);\n-                    continue;\n-                }\n-\n-                // Fill vtxPrev by copying from previous transactions vtxPrev\n-                wtxNew.AddSupportingTransactions(txdb);\n-                wtxNew.fTimeReceivedIsTxTime = true;\n-\n-                break;\n-            }\n-        }\n+        fGenerateBitcoins = fGenerate;\n+        CWalletDB().WriteSetting(\"fGenerateBitcoins\", fGenerateBitcoins);\n+        MainFrameRepaint();\n     }\n-    return true;\n-}\n-\n-bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n-{\n-    vector< pair<CScript, int64> > vecSend;\n-    vecSend.push_back(make_pair(scriptPubKey, nValue));\n-    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet);\n-}\n-\n-// Call after CreateTransaction unless you want to abort\n-bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n-{\n-    CRITICAL_BLOCK(cs_main)\n+    if (fGenerateBitcoins)\n     {\n-        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n-        CRITICAL_BLOCK(cs_mapWallet)\n-        {\n-            // This is only to keep the database open to defeat the auto-flush for the\n-            // duration of this scope.  This is the only place where this optimization\n-            // maybe makes sense; please don't do it anywhere else.\n-            CWalletDB walletdb(\"r\");\n-\n-            // Take key pair from key pool so it won't be used again\n-            reservekey.KeepKey();\n-\n-            // Add tx to wallet, because if it has change it's also ours,\n-            // otherwise just for transaction history.\n-            AddToWallet(wtxNew);\n-\n-            // Mark old coins as spent\n-            set<CWalletTx*> setCoins;\n-            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n-            {\n-                CWalletTx &pcoin = mapWallet[txin.prevout.hash];\n-                pcoin.MarkSpent(txin.prevout.n);\n-                pcoin.WriteToDisk();\n-                vWalletUpdated.push_back(pcoin.GetHash());\n-            }\n-        }\n-\n-        // Track how many getdata requests our transaction gets\n-        CRITICAL_BLOCK(cs_mapRequestCount)\n-            mapRequestCount[wtxNew.GetHash()] = 0;\n-\n-        // Broadcast\n-        if (!wtxNew.AcceptToMemoryPool())\n+        int nProcessors = boost::thread::hardware_concurrency();\n+        printf(\"%d processors\\n\", nProcessors);\n+        if (nProcessors < 1)\n+            nProcessors = 1;\n+        if (fLimitProcessors && nProcessors > nLimitProcessors)\n+            nProcessors = nLimitProcessors;\n+        int nAddThreads = nProcessors - vnThreadsRunning[3];\n+        printf(\"Starting %d BitcoinMiner threads\\n\", nAddThreads);\n+        for (int i = 0; i < nAddThreads; i++)\n         {\n-            // This must not fail. The transaction has already been signed and recorded.\n-            printf(\"CommitTransaction() : Error: Transaction not valid\");\n-            return false;\n+            if (!CreateThread(ThreadBitcoinMiner, NULL))\n+                printf(\"Error: CreateThread(ThreadBitcoinMiner) failed\\n\");\n+            Sleep(10);\n         }\n-        wtxNew.RelayWalletTransaction();\n-    }\n-    MainFrameRepaint();\n-    return true;\n-}\n-\n-\n-\n-\n-// requires cs_main lock\n-string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n-{\n-    CReserveKey reservekey;\n-    int64 nFeeRequired;\n-    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n-    {\n-        string strError;\n-        if (nValue + nFeeRequired > GetBalance())\n-            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n-        else\n-            strError = _(\"Error: Transaction creation failed  \");\n-        printf(\"SendMoney() : %s\", strError.c_str());\n-        return strError;\n     }\n-\n-    if (fAskFee && !ThreadSafeAskFee(nFeeRequired, _(\"Sending...\"), NULL))\n-        return \"ABORTED\";\n-\n-    if (!CommitTransaction(wtxNew, reservekey))\n-        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n-\n-    MainFrameRepaint();\n-    return \"\";\n-}\n-\n-\n-\n-// requires cs_main lock\n-string SendMoneyToBitcoinAddress(string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n-{\n-    // Check amount\n-    if (nValue <= 0)\n-        return _(\"Invalid amount\");\n-    if (nValue + nTransactionFee > GetBalance())\n-        return _(\"Insufficient funds\");\n-\n-    // Parse bitcoin address\n-    CScript scriptPubKey;\n-    if (!scriptPubKey.SetBitcoinAddress(strAddress))\n-        return _(\"Invalid bitcoin address\");\n-\n-    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n }"
      },
      {
        "sha": "2ebb8b867e53f3fd2a8ed0764c535867cbdc7f0d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 9,
        "deletions": 437,
        "changes": 446,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -7,7 +7,6 @@\n #include \"bignum.h\"\n #include \"net.h\"\n #include \"key.h\"\n-#include \"db.h\"\n #include \"script.h\"\n \n #include <list>\n@@ -22,6 +21,7 @@ class CTransaction;\n class CBlock;\n class CBlockIndex;\n class CWalletTx;\n+class CWallet;\n class CKeyItem;\n \n class CMessageHeader;\n@@ -62,14 +62,15 @@ extern CBigNum bnBestChainWork;\n extern CBigNum bnBestInvalidWork;\n extern uint256 hashBestChain;\n extern CBlockIndex* pindexBest;\n+extern std::set<int64> setKeyPool;\n+extern CCriticalSection cs_setKeyPool;\n extern unsigned int nTransactionsUpdated;\n-extern std::map<uint256, int> mapRequestCount;\n-extern CCriticalSection cs_mapRequestCount;\n-extern std::map<std::string, std::string> mapAddressBook;\n-extern CCriticalSection cs_mapAddressBook;\n-extern std::vector<unsigned char> vchDefaultKey;\n extern double dHashesPerSec;\n extern int64 nHPSTimerStart;\n+extern int64 nTimeBestReceived;\n+extern std::map<std::string, std::string> mapAddressBook;\n+extern CCriticalSection cs_mapAddressBook;\n+\n \n // Settings\n extern int fGenerateBitcoins;\n@@ -92,24 +93,11 @@ class CTxIndex;\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=\"rb\");\n FILE* AppendBlockFile(unsigned int& nFileRet);\n-bool AddKey(const CKey& key);\n-std::vector<unsigned char> GenerateNewKey();\n-bool AddToWallet(const CWalletTx& wtxIn);\n-void WalletUpdateSpent(const COutPoint& prevout);\n-int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n-void ReacceptWalletTransactions();\n bool LoadBlockIndex(bool fAllowNew=true);\n void PrintBlockTree();\n bool ProcessMessages(CNode* pfrom);\n bool ProcessMessage(CNode* pfrom, std::string strCommand, CDataStream& vRecv);\n bool SendMessages(CNode* pto, bool fSendTrickle);\n-int64 GetBalance();\n-bool CreateTransaction(const std::vector<std::pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n-bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n-bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n-bool BroadcastTransaction(CWalletTx& wtxNew);\n-std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n-std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n void GenerateBitcoins(bool fGenerate);\n void ThreadBitcoinMiner(void* parg);\n CBlock* CreateNewBlock(CReserveKey& reservekey);\n@@ -721,11 +709,7 @@ class CTransaction\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n-    bool AcceptToMemoryPool(bool fCheckInputs=true, bool* pfMissingInputs=NULL)\n-    {\n-        CTxDB txdb(\"r\");\n-        return AcceptToMemoryPool(txdb, fCheckInputs, pfMissingInputs);\n-    }\n+    bool AcceptToMemoryPool(bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n protected:\n     bool AddToMemoryPoolUnchecked();\n public:\n@@ -784,307 +768,7 @@ class CMerkleTx : public CTransaction\n     bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n     int GetBlocksToMaturity() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true);\n-    bool AcceptToMemoryPool() { CTxDB txdb(\"r\"); return AcceptToMemoryPool(txdb); }\n-};\n-\n-\n-\n-\n-//\n-// A transaction with a bunch of additional info that only the owner cares\n-// about.  It includes any unrecorded transactions needed to link it back\n-// to the block chain.\n-//\n-class CWalletTx : public CMerkleTx\n-{\n-public:\n-    std::vector<CMerkleTx> vtxPrev;\n-    std::map<std::string, std::string> mapValue;\n-    std::vector<std::pair<std::string, std::string> > vOrderForm;\n-    unsigned int fTimeReceivedIsTxTime;\n-    unsigned int nTimeReceived;  // time received by this node\n-    char fFromMe;\n-    std::string strFromAccount;\n-    std::vector<char> vfSpent;\n-\n-    // memory only\n-    mutable char fDebitCached;\n-    mutable char fCreditCached;\n-    mutable char fAvailableCreditCached;\n-    mutable char fChangeCached;\n-    mutable int64 nDebitCached;\n-    mutable int64 nCreditCached;\n-    mutable int64 nAvailableCreditCached;\n-    mutable int64 nChangeCached;\n-\n-    // memory only UI hints\n-    mutable unsigned int nTimeDisplayed;\n-    mutable int nLinesDisplayed;\n-    mutable char fConfirmedDisplayed;\n-\n-\n-    CWalletTx()\n-    {\n-        Init();\n-    }\n-\n-    CWalletTx(const CMerkleTx& txIn) : CMerkleTx(txIn)\n-    {\n-        Init();\n-    }\n-\n-    CWalletTx(const CTransaction& txIn) : CMerkleTx(txIn)\n-    {\n-        Init();\n-    }\n-\n-    void Init()\n-    {\n-        vtxPrev.clear();\n-        mapValue.clear();\n-        vOrderForm.clear();\n-        fTimeReceivedIsTxTime = false;\n-        nTimeReceived = 0;\n-        fFromMe = false;\n-        strFromAccount.clear();\n-        vfSpent.clear();\n-        fDebitCached = false;\n-        fCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fChangeCached = false;\n-        nDebitCached = 0;\n-        nCreditCached = 0;\n-        nAvailableCreditCached = 0;\n-        nChangeCached = 0;\n-        nTimeDisplayed = 0;\n-        nLinesDisplayed = 0;\n-        fConfirmedDisplayed = false;\n-    }\n-\n-    IMPLEMENT_SERIALIZE\n-    (\n-        CWalletTx* pthis = const_cast<CWalletTx*>(this);\n-        if (fRead)\n-            pthis->Init();\n-        char fSpent = false;\n-\n-        if (!fRead)\n-        {\n-            pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n-\n-            std::string str;\n-            BOOST_FOREACH(char f, vfSpent)\n-            {\n-                str += (f ? '1' : '0');\n-                if (f)\n-                    fSpent = true;\n-            }\n-            pthis->mapValue[\"spent\"] = str;\n-        }\n-\n-        nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n-        READWRITE(vtxPrev);\n-        READWRITE(mapValue);\n-        READWRITE(vOrderForm);\n-        READWRITE(fTimeReceivedIsTxTime);\n-        READWRITE(nTimeReceived);\n-        READWRITE(fFromMe);\n-        READWRITE(fSpent);\n-\n-        if (fRead)\n-        {\n-            pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n-\n-            if (mapValue.count(\"spent\"))\n-                BOOST_FOREACH(char c, pthis->mapValue[\"spent\"])\n-                    pthis->vfSpent.push_back(c != '0');\n-            else\n-                pthis->vfSpent.assign(vout.size(), fSpent);\n-        }\n-\n-        pthis->mapValue.erase(\"fromaccount\");\n-        pthis->mapValue.erase(\"version\");\n-        pthis->mapValue.erase(\"spent\");\n-    )\n-\n-    // marks certain txout's as spent\n-    // returns true if any update took place\n-    bool UpdateSpent(const std::vector<char>& vfNewSpent)\n-    {\n-        bool fReturn = false;\n-        for (int i=0; i < vfNewSpent.size(); i++)\n-        {\n-            if (i == vfSpent.size())\n-                break;\n-\n-            if (vfNewSpent[i] && !vfSpent[i])\n-            {\n-                vfSpent[i] = true;\n-                fReturn = true;\n-                fAvailableCreditCached = false;\n-            }\n-        }\n-        return fReturn;\n-    }\n-\n-    void MarkDirty()\n-    {\n-        fCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fDebitCached = false;\n-        fChangeCached = false;\n-    }\n-\n-    void MarkSpent(unsigned int nOut)\n-    {\n-        if (nOut >= vout.size())\n-            throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n-        vfSpent.resize(vout.size());\n-        if (!vfSpent[nOut])\n-        {\n-            vfSpent[nOut] = true;\n-            fAvailableCreditCached = false;\n-        }\n-    }\n-\n-    bool IsSpent(unsigned int nOut) const\n-    {\n-        if (nOut >= vout.size())\n-            throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n-        if (nOut >= vfSpent.size())\n-            return false;\n-        return (!!vfSpent[nOut]);\n-    }\n-\n-    int64 GetDebit() const\n-    {\n-        if (vin.empty())\n-            return 0;\n-        if (fDebitCached)\n-            return nDebitCached;\n-        nDebitCached = CTransaction::GetDebit();\n-        fDebitCached = true;\n-        return nDebitCached;\n-    }\n-\n-    int64 GetCredit(bool fUseCache=true) const\n-    {\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n-\n-        // GetBalance can assume transactions in mapWallet won't change\n-        if (fUseCache && fCreditCached)\n-            return nCreditCached;\n-        nCreditCached = CTransaction::GetCredit();\n-        fCreditCached = true;\n-        return nCreditCached;\n-    }\n-\n-    int64 GetAvailableCredit(bool fUseCache=true) const\n-    {\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n-\n-        if (fUseCache && fAvailableCreditCached)\n-            return nAvailableCreditCached;\n-\n-        int64 nCredit = 0;\n-        for (int i = 0; i < vout.size(); i++)\n-        {\n-            if (!IsSpent(i))\n-            {\n-                const CTxOut &txout = vout[i];\n-                nCredit += txout.GetCredit();\n-                if (!MoneyRange(nCredit))\n-                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n-            }\n-        }\n-\n-        nAvailableCreditCached = nCredit;\n-        fAvailableCreditCached = true;\n-        return nCredit;\n-    }\n-\n-\n-    int64 GetChange() const\n-    {\n-        if (fChangeCached)\n-            return nChangeCached;\n-        nChangeCached = CTransaction::GetChange();\n-        fChangeCached = true;\n-        return nChangeCached;\n-    }\n-\n-    void GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, std::list<std::pair<std::string /* address */, int64> >& listReceived,\n-                    std::list<std::pair<std::string /* address */, int64> >& listSent, int64& nFee, std::string& strSentAccount) const;\n-\n-    void GetAccountAmounts(const std::string& strAccount, int64& nGenerated, int64& nReceived,\n-                           int64& nSent, int64& nFee) const;\n-\n-    bool IsFromMe() const\n-    {\n-        return (GetDebit() > 0);\n-    }\n-\n-    bool IsConfirmed() const\n-    {\n-        // Quick answer in most cases\n-        if (!IsFinal())\n-            return false;\n-        if (GetDepthInMainChain() >= 1)\n-            return true;\n-        if (!IsFromMe()) // using wtx's cached debit\n-            return false;\n-\n-        // If no confirmations but it's from us, we can still\n-        // consider it confirmed if all dependencies are confirmed\n-        std::map<uint256, const CMerkleTx*> mapPrev;\n-        std::vector<const CMerkleTx*> vWorkQueue;\n-        vWorkQueue.reserve(vtxPrev.size()+1);\n-        vWorkQueue.push_back(this);\n-        for (int i = 0; i < vWorkQueue.size(); i++)\n-        {\n-            const CMerkleTx* ptx = vWorkQueue[i];\n-\n-            if (!ptx->IsFinal())\n-                return false;\n-            if (ptx->GetDepthInMainChain() >= 1)\n-                continue;\n-            if (!ptx->IsFromMe())\n-                return false;\n-\n-            if (mapPrev.empty())\n-                BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n-                    mapPrev[tx.GetHash()] = &tx;\n-\n-            BOOST_FOREACH(const CTxIn& txin, ptx->vin)\n-            {\n-                if (!mapPrev.count(txin.prevout.hash))\n-                    return false;\n-                vWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    bool WriteToDisk()\n-    {\n-        return CWalletDB().WriteTx(GetHash(), *this);\n-    }\n-\n-\n-    int64 GetTxTime() const;\n-    int GetRequestCount() const;\n-\n-    void AddSupportingTransactions(CTxDB& txdb);\n-\n-    bool AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs=true);\n-    bool AcceptWalletTransaction() { CTxDB txdb(\"r\"); return AcceptWalletTransaction(txdb); }\n-\n-    void RelayWalletTransaction(CTxDB& txdb);\n-    void RelayWalletTransaction() { CTxDB txdb(\"r\"); RelayWalletTransaction(txdb); }\n+    bool AcceptToMemoryPool();\n };\n \n \n@@ -1744,114 +1428,6 @@ class CBlockLocator\n \n \n \n-//\n-// Private key that includes an expiration date in case it never gets used.\n-//\n-class CWalletKey\n-{\n-public:\n-    CPrivKey vchPrivKey;\n-    int64 nTimeCreated;\n-    int64 nTimeExpires;\n-    std::string strComment;\n-    //// todo: add something to note what created it (user, getnewaddress, change)\n-    ////   maybe should have a map<string, string> property map\n-\n-    CWalletKey(int64 nExpires=0)\n-    {\n-        nTimeCreated = (nExpires ? GetTime() : 0);\n-        nTimeExpires = nExpires;\n-    }\n-\n-    IMPLEMENT_SERIALIZE\n-    (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vchPrivKey);\n-        READWRITE(nTimeCreated);\n-        READWRITE(nTimeExpires);\n-        READWRITE(strComment);\n-    )\n-};\n-\n-\n-\n-\n-\n-\n-//\n-// Account information.\n-// Stored in wallet with key \"acc\"+string account name\n-//\n-class CAccount\n-{\n-public:\n-    std::vector<unsigned char> vchPubKey;\n-\n-    CAccount()\n-    {\n-        SetNull();\n-    }\n-\n-    void SetNull()\n-    {\n-        vchPubKey.clear();\n-    }\n-\n-    IMPLEMENT_SERIALIZE\n-    (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vchPubKey);\n-    )\n-};\n-\n-\n-\n-//\n-// Internal transfers.\n-// Database key is acentry<account><counter>\n-//\n-class CAccountingEntry\n-{\n-public:\n-    std::string strAccount;\n-    int64 nCreditDebit;\n-    int64 nTime;\n-    std::string strOtherAccount;\n-    std::string strComment;\n-\n-    CAccountingEntry()\n-    {\n-        SetNull();\n-    }\n-\n-    void SetNull()\n-    {\n-        nCreditDebit = 0;\n-        nTime = 0;\n-        strAccount.clear();\n-        strOtherAccount.clear();\n-        strComment.clear();\n-    }\n-\n-    IMPLEMENT_SERIALIZE\n-    (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        // Note: strAccount is serialized as part of the key, not here.\n-        READWRITE(nCreditDebit);\n-        READWRITE(nTime);\n-        READWRITE(strOtherAccount);\n-        READWRITE(strComment);\n-    )\n-};\n-\n-\n-\n-\n-\n-\n \n \n \n@@ -2064,12 +1640,8 @@ class CAlert : public CUnsignedAlert\n \n \n extern std::map<uint256, CTransaction> mapTransactions;\n-extern std::map<uint256, CWalletTx> mapWallet;\n-extern std::vector<uint256> vWalletUpdated;\n-extern CCriticalSection cs_mapWallet;\n extern std::map<std::vector<unsigned char>, CPrivKey> mapKeys;\n extern std::map<uint160, std::vector<unsigned char> > mapPubKeys;\n extern CCriticalSection cs_mapKeys;\n-extern CKey keyUser;\n \n #endif"
      },
      {
        "sha": "fccc0e36af57e2df6ecfab810e42a6cfbfc00a06",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -33,7 +33,7 @@ DEFS=-DWIN32 -D__WXMSW__ -D_WINDOWS -DNOPCH -DUSE_SSL\n DEBUGFLAGS=-g -D__WXDEBUG__\n CFLAGS=-mthreads -O2 -w -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS) $(INCLUDEPATHS)\n HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \\\n-    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h\n+    script.h db.h net.h irc.h keystore.h main.h wallet.h rpc.h uibase.h ui.h noui.h init.h\n \n ifdef USE_UPNP\n  INCLUDEPATHS += -I\"C:\\upnpc-exe-win32-20110215\"\n@@ -50,7 +50,9 @@ OBJS= \\\n     obj/db.o \\\n     obj/net.o \\\n     obj/irc.o \\\n+    obj/keystore.o \\\n     obj/main.o \\\n+    obj/wallet.o \\\n     obj/rpc.o \\\n     obj/init.o \\\n     cryptopp/obj/sha.o \\"
      },
      {
        "sha": "4e173a9dfa0723ad8a3b2b044a54b0cb7f7f874d",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -33,15 +33,17 @@ DEBUGFLAGS=-g -DwxDEBUG_LEVEL=0\n # ppc doesn't work because we don't support big-endian\n CFLAGS=-mmacosx-version-min=10.5 -arch i386 -arch x86_64 -O3 -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS) $(INCLUDEPATHS)\n HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \\\n-    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h\n+    script.h db.h net.h irc.h keystore.h main.h wallet.h rpc.h uibase.h ui.h noui.h init.h\n \n OBJS= \\\n     obj/util.o \\\n     obj/script.o \\\n     obj/db.o \\\n     obj/net.o \\\n     obj/irc.o \\\n+    obj/keystore.o \\\n     obj/main.o \\\n+    obj/wallet.o \\\n     obj/rpc.o \\\n     obj/init.o \\\n     cryptopp/obj/sha.o \\"
      },
      {
        "sha": "f2d85b9dd31d48529f271149705b7204109208d1",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -39,15 +39,17 @@ LIBS+= \\\n DEBUGFLAGS=-g -D__WXDEBUG__\n CXXFLAGS=-O2 -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS)\n HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \\\n-    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h\n+    script.h db.h net.h irc.h keystore.h main.h wallet.h rpc.h uibase.h ui.h noui.h init.h\n \n OBJS= \\\n     obj/util.o \\\n     obj/script.o \\\n     obj/db.o \\\n     obj/net.o \\\n     obj/irc.o \\\n+    obj/keystore.o \\\n     obj/main.o \\\n+    obj/wallet.o \\\n     obj/rpc.o \\\n     obj/init.o \\\n     cryptopp/obj/sha.o \\"
      },
      {
        "sha": "d0072df7f22942b765051790045c0679be08a8cb",
        "filename": "src/noui.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/noui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/noui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -5,6 +5,8 @@\n #define BITCOIN_NOUI_H\n \n #include <string>\n+#include <boost/function.hpp>\n+#include \"wallet.h\"\n \n typedef void wxWindow;\n #define wxYES                   0x00000002"
      },
      {
        "sha": "efafec4470297065eaa8d9b8a62f8f8ba0ff62fd",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -5,6 +5,7 @@\n #define H_BITCOIN_SCRIPT\n \n #include \"base58.h\"\n+#include \"keystore.h\"\n \n #include <string>\n #include <vector>"
      },
      {
        "sha": "72e8fe2ec830957cd78f6ee12c5648822779ab12",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -3,6 +3,7 @@\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"headers.h\"\n+#include \"db.h\"\n #include \"init.h\"\n #include \"strlcpy.h\"\n #include <boost/filesystem/fstream.hpp>"
      },
      {
        "sha": "3f06ad90cb640e5bd9ffa3d7490d3a4b1ee46bd9",
        "filename": "src/ui.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/ui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/ui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -4,6 +4,9 @@\n #ifndef BITCOIN_UI_H\n #define BITCOIN_UI_H\n \n+#include <boost/function.hpp>\n+#include \"wallet.h\"\n+\n DECLARE_EVENT_TYPE(wxEVT_UITHREADCALL, -1)\n \n "
      },
      {
        "sha": "a9fc92fd78cef2aa1190866368d2b758d1cecf99",
        "filename": "src/wallet.cpp",
        "status": "added",
        "additions": 1056,
        "deletions": 0,
        "changes": 1056,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -0,0 +1,1056 @@\n+// Copyright (c) 2009-2011 Satoshi Nakamoto & Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"headers.h\"\n+#include \"db.h\"\n+#include \"cryptopp/sha.h\"\n+\n+using namespace std;\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// mapWallet\n+//\n+\n+void WalletUpdateSpent(const COutPoint& prevout)\n+{\n+    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n+    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n+    // restored from backup or the user making copies of wallet.dat.\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n+        if (mi != mapWallet.end())\n+        {\n+            CWalletTx& wtx = (*mi).second;\n+            if (!wtx.IsSpent(prevout.n) && wtx.vout[prevout.n].IsMine())\n+            {\n+                printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                wtx.MarkSpent(prevout.n);\n+                wtx.WriteToDisk();\n+                vWalletUpdated.push_back(prevout.hash);\n+            }\n+        }\n+    }\n+}\n+\n+bool AddToWallet(const CWalletTx& wtxIn)\n+{\n+    uint256 hash = wtxIn.GetHash();\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        // Inserts only if not already there, returns tx inserted or tx found\n+        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n+        CWalletTx& wtx = (*ret.first).second;\n+        bool fInsertedNew = ret.second;\n+        if (fInsertedNew)\n+            wtx.nTimeReceived = GetAdjustedTime();\n+\n+        bool fUpdated = false;\n+        if (!fInsertedNew)\n+        {\n+            // Merge\n+            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n+            {\n+                wtx.hashBlock = wtxIn.hashBlock;\n+                fUpdated = true;\n+            }\n+            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n+            {\n+                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n+                wtx.nIndex = wtxIn.nIndex;\n+                fUpdated = true;\n+            }\n+            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n+            {\n+                wtx.fFromMe = wtxIn.fFromMe;\n+                fUpdated = true;\n+            }\n+            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n+        }\n+\n+        //// debug print\n+        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n+\n+        // Write to disk\n+        if (fInsertedNew || fUpdated)\n+            if (!wtx.WriteToDisk())\n+                return false;\n+\n+        // If default receiving address gets used, replace it with a new one\n+        CScript scriptDefaultKey;\n+        scriptDefaultKey.SetBitcoinAddress(vchDefaultKey);\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+        {\n+            if (txout.scriptPubKey == scriptDefaultKey)\n+            {\n+                CWalletDB walletdb;\n+                vchDefaultKey = GetKeyFromKeyPool();\n+                walletdb.WriteDefaultKey(vchDefaultKey);\n+                walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n+            }\n+        }\n+\n+        // Notify UI\n+        vWalletUpdated.push_back(hash);\n+    }\n+\n+    // Refresh UI\n+    MainFrameRepaint();\n+    return true;\n+}\n+\n+bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n+{\n+    uint256 hash = tx.GetHash();\n+    bool fExisted = mapWallet.count(hash);\n+    if (fExisted && !fUpdate) return false;\n+    if (fExisted || tx.IsMine() || tx.IsFromMe())\n+    {\n+        CWalletTx wtx(tx);\n+        // Get merkle branch if transaction was found in a block\n+        if (pblock)\n+            wtx.SetMerkleBranch(pblock);\n+        return AddToWallet(wtx);\n+    }\n+    return false;\n+}\n+\n+bool EraseFromWallet(uint256 hash)\n+{\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        if (mapWallet.erase(hash))\n+            CWalletDB().EraseTx(hash);\n+    }\n+    return true;\n+}\n+\n+\n+bool CTxIn::IsMine() const\n+{\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n+        if (mi != mapWallet.end())\n+        {\n+            const CWalletTx& prev = (*mi).second;\n+            if (prevout.n < prev.vout.size())\n+                if (prev.vout[prevout.n].IsMine())\n+                    return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+int64 CTxIn::GetDebit() const\n+{\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n+        if (mi != mapWallet.end())\n+        {\n+            const CWalletTx& prev = (*mi).second;\n+            if (prevout.n < prev.vout.size())\n+                if (prev.vout[prevout.n].IsMine())\n+                    return prev.vout[prevout.n].nValue;\n+        }\n+    }\n+    return 0;\n+}\n+\n+int64 CWalletTx::GetTxTime() const\n+{\n+    if (!fTimeReceivedIsTxTime && hashBlock != 0)\n+    {\n+        // If we did not receive the transaction directly, we rely on the block's\n+        // time to figure out when it happened.  We use the median over a range\n+        // of blocks to try to filter out inaccurate block times.\n+        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n+        if (mi != mapBlockIndex.end())\n+        {\n+            CBlockIndex* pindex = (*mi).second;\n+            if (pindex)\n+                return pindex->GetMedianTime();\n+        }\n+    }\n+    return nTimeReceived;\n+}\n+\n+int CWalletTx::GetRequestCount() const\n+{\n+    // Returns -1 if it wasn't being tracked\n+    int nRequests = -1;\n+    CRITICAL_BLOCK(cs_mapRequestCount)\n+    {\n+        if (IsCoinBase())\n+        {\n+            // Generated block\n+            if (hashBlock != 0)\n+            {\n+                map<uint256, int>::iterator mi = mapRequestCount.find(hashBlock);\n+                if (mi != mapRequestCount.end())\n+                    nRequests = (*mi).second;\n+            }\n+        }\n+        else\n+        {\n+            // Did anyone request this transaction?\n+            map<uint256, int>::iterator mi = mapRequestCount.find(GetHash());\n+            if (mi != mapRequestCount.end())\n+            {\n+                nRequests = (*mi).second;\n+\n+                // How about the block it's in?\n+                if (nRequests == 0 && hashBlock != 0)\n+                {\n+                    map<uint256, int>::iterator mi = mapRequestCount.find(hashBlock);\n+                    if (mi != mapRequestCount.end())\n+                        nRequests = (*mi).second;\n+                    else\n+                        nRequests = 1; // If it's in someone else's block it must have got out\n+                }\n+            }\n+        }\n+    }\n+    return nRequests;\n+}\n+\n+void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, list<pair<string, int64> >& listReceived,\n+                           list<pair<string, int64> >& listSent, int64& nFee, string& strSentAccount) const\n+{\n+    nGeneratedImmature = nGeneratedMature = nFee = 0;\n+    listReceived.clear();\n+    listSent.clear();\n+    strSentAccount = strFromAccount;\n+\n+    if (IsCoinBase())\n+    {\n+        if (GetBlocksToMaturity() > 0)\n+            nGeneratedImmature = CTransaction::GetCredit();\n+        else\n+            nGeneratedMature = GetCredit();\n+        return;\n+    }\n+\n+    // Compute fee:\n+    int64 nDebit = GetDebit();\n+    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n+    {\n+        int64 nValueOut = GetValueOut();\n+        nFee = nDebit - nValueOut;\n+    }\n+\n+    // Sent/received.  Standard client will never generate a send-to-multiple-recipients,\n+    // but non-standard clients might (so return a list of address/amount pairs)\n+    BOOST_FOREACH(const CTxOut& txout, vout)\n+    {\n+        string address;\n+        uint160 hash160;\n+        vector<unsigned char> vchPubKey;\n+        if (ExtractHash160(txout.scriptPubKey, hash160))\n+            address = Hash160ToAddress(hash160);\n+        else if (ExtractPubKey(txout.scriptPubKey, false, vchPubKey))\n+            address = PubKeyToAddress(vchPubKey);\n+        else\n+        {\n+            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n+                   this->GetHash().ToString().c_str());\n+            address = \" unknown \";\n+        }\n+\n+        // Don't report 'change' txouts\n+        if (nDebit > 0 && txout.IsChange())\n+            continue;\n+\n+        if (nDebit > 0)\n+            listSent.push_back(make_pair(address, txout.nValue));\n+\n+        if (txout.IsMine())\n+            listReceived.push_back(make_pair(address, txout.nValue));\n+    }\n+\n+}\n+\n+void CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, int64& nReceived, \n+                                  int64& nSent, int64& nFee) const\n+{\n+    nGenerated = nReceived = nSent = nFee = 0;\n+\n+    int64 allGeneratedImmature, allGeneratedMature, allFee;\n+    allGeneratedImmature = allGeneratedMature = allFee = 0;\n+    string strSentAccount;\n+    list<pair<string, int64> > listReceived;\n+    list<pair<string, int64> > listSent;\n+    GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n+\n+    if (strAccount == \"\")\n+        nGenerated = allGeneratedMature;\n+    if (strAccount == strSentAccount)\n+    {\n+        BOOST_FOREACH(const PAIRTYPE(string,int64)& s, listSent)\n+            nSent += s.second;\n+        nFee = allFee;\n+    }\n+    CRITICAL_BLOCK(cs_mapAddressBook)\n+    {\n+        BOOST_FOREACH(const PAIRTYPE(string,int64)& r, listReceived)\n+        {\n+            if (mapAddressBook.count(r.first))\n+            {\n+                if (mapAddressBook[r.first] == strAccount)\n+                {\n+                    nReceived += r.second;\n+                }\n+            }\n+            else if (strAccount.empty())\n+            {\n+                nReceived += r.second;\n+            }\n+        }\n+    }\n+}\n+\n+void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n+{\n+    vtxPrev.clear();\n+\n+    const int COPY_DEPTH = 3;\n+    if (SetMerkleBranch() < COPY_DEPTH)\n+    {\n+        vector<uint256> vWorkQueue;\n+        BOOST_FOREACH(const CTxIn& txin, vin)\n+            vWorkQueue.push_back(txin.prevout.hash);\n+\n+        // This critsect is OK because txdb is already open\n+        CRITICAL_BLOCK(cs_mapWallet)\n+        {\n+            map<uint256, const CMerkleTx*> mapWalletPrev;\n+            set<uint256> setAlreadyDone;\n+            for (int i = 0; i < vWorkQueue.size(); i++)\n+            {\n+                uint256 hash = vWorkQueue[i];\n+                if (setAlreadyDone.count(hash))\n+                    continue;\n+                setAlreadyDone.insert(hash);\n+\n+                CMerkleTx tx;\n+                if (mapWallet.count(hash))\n+                {\n+                    tx = mapWallet[hash];\n+                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, mapWallet[hash].vtxPrev)\n+                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n+                }\n+                else if (mapWalletPrev.count(hash))\n+                {\n+                    tx = *mapWalletPrev[hash];\n+                }\n+                else if (!fClient && txdb.ReadDiskTx(hash, tx))\n+                {\n+                    ;\n+                }\n+                else\n+                {\n+                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n+                    continue;\n+                }\n+\n+                int nDepth = tx.SetMerkleBranch();\n+                vtxPrev.push_back(tx);\n+\n+                if (nDepth < COPY_DEPTH)\n+                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+                        vWorkQueue.push_back(txin.prevout.hash);\n+            }\n+        }\n+    }\n+\n+    reverse(vtxPrev.begin(), vtxPrev.end());\n+}\n+\n+bool CWalletTx::WriteToDisk()\n+{\n+    return CWalletDB().WriteTx(GetHash(), *this);\n+}\n+\n+int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n+{\n+    int ret = 0;\n+\n+    CBlockIndex* pindex = pindexStart;\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        while (pindex)\n+        {\n+            CBlock block;\n+            block.ReadFromDisk(pindex, true);\n+            BOOST_FOREACH(CTransaction& tx, block.vtx)\n+            {\n+                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n+                    ret++;\n+            }\n+            pindex = pindex->pnext;\n+        }\n+    }\n+    return ret;\n+}\n+\n+void ReacceptWalletTransactions()\n+{\n+    CTxDB txdb(\"r\");\n+    bool fRepeat = true;\n+    while (fRepeat) CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        fRepeat = false;\n+        vector<CDiskTxPos> vMissingTx;\n+        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n+        {\n+            CWalletTx& wtx = item.second;\n+            if (wtx.IsCoinBase() && wtx.IsSpent(0))\n+                continue;\n+\n+            CTxIndex txindex;\n+            bool fUpdated = false;\n+            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n+            {\n+                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n+                if (txindex.vSpent.size() != wtx.vout.size())\n+                {\n+                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %d != wtx.vout.size() %d\\n\", txindex.vSpent.size(), wtx.vout.size());\n+                    continue;\n+                }\n+                for (int i = 0; i < txindex.vSpent.size(); i++)\n+                {\n+                    if (wtx.IsSpent(i))\n+                        continue;\n+                    if (!txindex.vSpent[i].IsNull() && wtx.vout[i].IsMine())\n+                    {\n+                        wtx.MarkSpent(i);\n+                        fUpdated = true;\n+                        vMissingTx.push_back(txindex.vSpent[i]);\n+                    }\n+                }\n+                if (fUpdated)\n+                {\n+                    printf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                    wtx.MarkDirty();\n+                    wtx.WriteToDisk();\n+                }\n+            }\n+            else\n+            {\n+                // Reaccept any txes of ours that aren't already in a block\n+                if (!wtx.IsCoinBase())\n+                    wtx.AcceptWalletTransaction(txdb, false);\n+            }\n+        }\n+        if (!vMissingTx.empty())\n+        {\n+            // TODO: optimize this to scan just part of the block chain?\n+            if (ScanForWalletTransactions(pindexGenesisBlock))\n+                fRepeat = true;  // Found missing transactions: re-do Reaccept.\n+        }\n+    }\n+}\n+\n+void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n+{\n+    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n+    {\n+        if (!tx.IsCoinBase())\n+        {\n+            uint256 hash = tx.GetHash();\n+            if (!txdb.ContainsTx(hash))\n+                RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n+        }\n+    }\n+    if (!IsCoinBase())\n+    {\n+        uint256 hash = GetHash();\n+        if (!txdb.ContainsTx(hash))\n+        {\n+            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n+            RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n+        }\n+    }\n+}\n+\n+void CWalletTx::RelayWalletTransaction()\n+{\n+   CTxDB txdb(\"r\");\n+   RelayWalletTransaction(txdb);\n+}\n+\n+void ResendWalletTransactions()\n+{\n+    // Do this infrequently and randomly to avoid giving away\n+    // that these are our transactions.\n+    static int64 nNextTime;\n+    if (GetTime() < nNextTime)\n+        return;\n+    bool fFirst = (nNextTime == 0);\n+    nNextTime = GetTime() + GetRand(30 * 60);\n+    if (fFirst)\n+        return;\n+\n+    // Only do it if there's been a new block since last time\n+    static int64 nLastTime;\n+    if (nTimeBestReceived < nLastTime)\n+        return;\n+    nLastTime = GetTime();\n+\n+    // Rebroadcast any of our txes that aren't in a block yet\n+    printf(\"ResendWalletTransactions()\\n\");\n+    CTxDB txdb(\"r\");\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        // Sort them in chronological order\n+        multimap<unsigned int, CWalletTx*> mapSorted;\n+        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n+        {\n+            CWalletTx& wtx = item.second;\n+            // Don't rebroadcast until it's had plenty of time that\n+            // it should have gotten in already by now.\n+            if (nTimeBestReceived - (int64)wtx.nTimeReceived > 5 * 60)\n+                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n+        }\n+        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n+        {\n+            CWalletTx& wtx = *item.second;\n+            wtx.RelayWalletTransaction(txdb);\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// Actions\n+//\n+\n+\n+int64 GetBalance()\n+{\n+    int64 nStart = GetTimeMillis();\n+\n+    int64 nTotal = 0;\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            CWalletTx* pcoin = &(*it).second;\n+            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+                continue;\n+            nTotal += pcoin->GetAvailableCredit();\n+        }\n+    }\n+\n+    //printf(\"GetBalance() %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+    return nTotal;\n+}\n+\n+\n+bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet)\n+{\n+    setCoinsRet.clear();\n+    nValueRet = 0;\n+\n+    // List of values less than target\n+    pair<int64, pair<CWalletTx*,unsigned int> > coinLowestLarger;\n+    coinLowestLarger.first = INT64_MAX;\n+    coinLowestLarger.second.first = NULL;\n+    vector<pair<int64, pair<CWalletTx*,unsigned int> > > vValue;\n+    int64 nTotalLower = 0;\n+\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+       vector<CWalletTx*> vCoins;\n+       vCoins.reserve(mapWallet.size());\n+       for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+           vCoins.push_back(&(*it).second);\n+       random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n+\n+       BOOST_FOREACH(CWalletTx* pcoin, vCoins)\n+       {\n+            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+                continue;\n+\n+            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+                continue;\n+\n+            int nDepth = pcoin->GetDepthInMainChain();\n+            if (nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n+                continue;\n+\n+            for (int i = 0; i < pcoin->vout.size(); i++)\n+            {\n+                if (pcoin->IsSpent(i) || !pcoin->vout[i].IsMine())\n+                    continue;\n+\n+                int64 n = pcoin->vout[i].nValue;\n+\n+                if (n <= 0)\n+                    continue;\n+\n+                pair<int64,pair<CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n+\n+                if (n == nTargetValue)\n+                {\n+                    setCoinsRet.insert(coin.second);\n+                    nValueRet += coin.first;\n+                    return true;\n+                }\n+                else if (n < nTargetValue + CENT)\n+                {\n+                    vValue.push_back(coin);\n+                    nTotalLower += n;\n+                }\n+                else if (n < coinLowestLarger.first)\n+                {\n+                    coinLowestLarger = coin;\n+                }\n+            }\n+        }\n+    }\n+\n+    if (nTotalLower == nTargetValue || nTotalLower == nTargetValue + CENT)\n+    {\n+        for (int i = 0; i < vValue.size(); ++i)\n+        {\n+            setCoinsRet.insert(vValue[i].second);\n+            nValueRet += vValue[i].first;\n+        }\n+        return true;\n+    }\n+\n+    if (nTotalLower < nTargetValue + (coinLowestLarger.second.first ? CENT : 0))\n+    {\n+        if (coinLowestLarger.second.first == NULL)\n+            return false;\n+        setCoinsRet.insert(coinLowestLarger.second);\n+        nValueRet += coinLowestLarger.first;\n+        return true;\n+    }\n+\n+    if (nTotalLower >= nTargetValue + CENT)\n+        nTargetValue += CENT;\n+\n+    // Solve subset sum by stochastic approximation\n+    sort(vValue.rbegin(), vValue.rend());\n+    vector<char> vfIncluded;\n+    vector<char> vfBest(vValue.size(), true);\n+    int64 nBest = nTotalLower;\n+\n+    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)\n+    {\n+        vfIncluded.assign(vValue.size(), false);\n+        int64 nTotal = 0;\n+        bool fReachedTarget = false;\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        {\n+            for (int i = 0; i < vValue.size(); i++)\n+            {\n+                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n+                {\n+                    nTotal += vValue[i].first;\n+                    vfIncluded[i] = true;\n+                    if (nTotal >= nTargetValue)\n+                    {\n+                        fReachedTarget = true;\n+                        if (nTotal < nBest)\n+                        {\n+                            nBest = nTotal;\n+                            vfBest = vfIncluded;\n+                        }\n+                        nTotal -= vValue[i].first;\n+                        vfIncluded[i] = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // If the next larger is still closer, return it\n+    if (coinLowestLarger.second.first && coinLowestLarger.first - nTargetValue <= nBest - nTargetValue)\n+    {\n+        setCoinsRet.insert(coinLowestLarger.second);\n+        nValueRet += coinLowestLarger.first;\n+    }\n+    else {\n+        for (int i = 0; i < vValue.size(); i++)\n+            if (vfBest[i])\n+            {\n+                setCoinsRet.insert(vValue[i].second);\n+                nValueRet += vValue[i].first;\n+            }\n+\n+        //// debug print\n+        printf(\"SelectCoins() best subset: \");\n+        for (int i = 0; i < vValue.size(); i++)\n+            if (vfBest[i])\n+                printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n+        printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n+    }\n+\n+    return true;\n+}\n+\n+bool SelectCoins(int64 nTargetValue, set<pair<CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet)\n+{\n+    return (SelectCoinsMinConf(nTargetValue, 1, 6, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 1, 1, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 0, 1, setCoinsRet, nValueRet));\n+}\n+\n+\n+\n+\n+bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n+{\n+    int64 nValue = 0;\n+    BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n+    {\n+        if (nValue < 0)\n+            return false;\n+        nValue += s.second;\n+    }\n+    if (vecSend.empty() || nValue < 0)\n+        return false;\n+\n+    CRITICAL_BLOCK(cs_main)\n+    {\n+        // txdb must be opened before the mapWallet lock\n+        CTxDB txdb(\"r\");\n+        CRITICAL_BLOCK(cs_mapWallet)\n+        {\n+            nFeeRet = nTransactionFee;\n+            loop\n+            {\n+                wtxNew.vin.clear();\n+                wtxNew.vout.clear();\n+                wtxNew.fFromMe = true;\n+\n+                int64 nTotalValue = nValue + nFeeRet;\n+                double dPriority = 0;\n+                // vouts to the payees\n+                BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n+                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n+\n+                // Choose coins to use\n+                set<pair<CWalletTx*,unsigned int> > setCoins;\n+                int64 nValueIn = 0;\n+                if (!SelectCoins(nTotalValue, setCoins, nValueIn))\n+                    return false;\n+                BOOST_FOREACH(PAIRTYPE(CWalletTx*, unsigned int) pcoin, setCoins)\n+                {\n+                    int64 nCredit = pcoin.first->vout[pcoin.second].nValue;\n+                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n+                }\n+\n+                // Fill a vout back to self with any change\n+                int64 nChange = nValueIn - nTotalValue;\n+                if (nChange >= CENT)\n+                {\n+                    // Note: We use a new key here to keep it from being obvious which side is the change.\n+                    //  The drawback is that by not reusing a previous key, the change may be lost if a\n+                    //  backup is restored, if the backup doesn't have the new private key for the change.\n+                    //  If we reused the old key, it would be possible to add code to look for and\n+                    //  rediscover unknown transactions that were written with keys of ours to recover\n+                    //  post-backup change.\n+\n+                    // Reserve a new key pair from key pool\n+                    vector<unsigned char> vchPubKey = reservekey.GetReservedKey();\n+                    assert(mapKeys.count(vchPubKey));\n+\n+                    // Fill a vout to ourself, using same address type as the payment\n+                    CScript scriptChange;\n+                    if (vecSend[0].first.GetBitcoinAddressHash160() != 0)\n+                        scriptChange.SetBitcoinAddress(vchPubKey);\n+                    else\n+                        scriptChange << vchPubKey << OP_CHECKSIG;\n+\n+                    // Insert change txn at random position:\n+                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n+                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n+                }\n+                else\n+                    reservekey.ReturnKey();\n+\n+                // Fill vin\n+                BOOST_FOREACH(const PAIRTYPE(CWalletTx*,unsigned int)& coin, setCoins)\n+                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n+\n+                // Sign\n+                int nIn = 0;\n+                BOOST_FOREACH(const PAIRTYPE(CWalletTx*,unsigned int)& coin, setCoins)\n+                    if (!SignSignature(*coin.first, wtxNew, nIn++))\n+                        return false;\n+\n+                // Limit size\n+                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK);\n+                if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n+                    return false;\n+                dPriority /= nBytes;\n+\n+                // Check that enough fee is included\n+                int64 nPayFee = nTransactionFee * (1 + (int64)nBytes / 1000);\n+                bool fAllowFree = CTransaction::AllowFree(dPriority);\n+                int64 nMinFee = wtxNew.GetMinFee(1, fAllowFree);\n+                if (nFeeRet < max(nPayFee, nMinFee))\n+                {\n+                    nFeeRet = max(nPayFee, nMinFee);\n+                    continue;\n+                }\n+\n+                // Fill vtxPrev by copying from previous transactions vtxPrev\n+                wtxNew.AddSupportingTransactions(txdb);\n+                wtxNew.fTimeReceivedIsTxTime = true;\n+\n+                break;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n+{\n+    vector< pair<CScript, int64> > vecSend;\n+    vecSend.push_back(make_pair(scriptPubKey, nValue));\n+    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet);\n+}\n+\n+// Call after CreateTransaction unless you want to abort\n+bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n+{\n+    CRITICAL_BLOCK(cs_main)\n+    {\n+        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n+        CRITICAL_BLOCK(cs_mapWallet)\n+        {\n+            // This is only to keep the database open to defeat the auto-flush for the\n+            // duration of this scope.  This is the only place where this optimization\n+            // maybe makes sense; please don't do it anywhere else.\n+            CWalletDB walletdb(\"r\");\n+\n+            // Take key pair from key pool so it won't be used again\n+            reservekey.KeepKey();\n+\n+            // Add tx to wallet, because if it has change it's also ours,\n+            // otherwise just for transaction history.\n+            AddToWallet(wtxNew);\n+\n+            // Mark old coins as spent\n+            set<CWalletTx*> setCoins;\n+            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n+            {\n+                CWalletTx &pcoin = mapWallet[txin.prevout.hash];\n+                pcoin.MarkSpent(txin.prevout.n);\n+                pcoin.WriteToDisk();\n+                vWalletUpdated.push_back(pcoin.GetHash());\n+            }\n+        }\n+\n+        // Track how many getdata requests our transaction gets\n+        CRITICAL_BLOCK(cs_mapRequestCount)\n+            mapRequestCount[wtxNew.GetHash()] = 0;\n+\n+        // Broadcast\n+        if (!wtxNew.AcceptToMemoryPool())\n+        {\n+            // This must not fail. The transaction has already been signed and recorded.\n+            printf(\"CommitTransaction() : Error: Transaction not valid\");\n+            return false;\n+        }\n+        wtxNew.RelayWalletTransaction();\n+    }\n+    MainFrameRepaint();\n+    return true;\n+}\n+\n+\n+\n+\n+// requires cs_main lock\n+string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n+{\n+    CReserveKey reservekey;\n+    int64 nFeeRequired;\n+    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n+    {\n+        string strError;\n+        if (nValue + nFeeRequired > GetBalance())\n+            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n+        else\n+            strError = _(\"Error: Transaction creation failed  \");\n+        printf(\"SendMoney() : %s\", strError.c_str());\n+        return strError;\n+    }\n+\n+    if (fAskFee && !ThreadSafeAskFee(nFeeRequired, _(\"Sending...\"), NULL))\n+        return \"ABORTED\";\n+\n+    if (!CommitTransaction(wtxNew, reservekey))\n+        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n+\n+    MainFrameRepaint();\n+    return \"\";\n+}\n+\n+\n+\n+// requires cs_main lock\n+string SendMoneyToBitcoinAddress(string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n+{\n+    // Check amount\n+    if (nValue <= 0)\n+        return _(\"Invalid amount\");\n+    if (nValue + nTransactionFee > GetBalance())\n+        return _(\"Insufficient funds\");\n+\n+    // Parse bitcoin address\n+    CScript scriptPubKey;\n+    if (!scriptPubKey.SetBitcoinAddress(strAddress))\n+        return _(\"Invalid bitcoin address\");\n+\n+    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n+}\n+\n+\n+\n+\n+bool LoadWallet(bool& fFirstRunRet)\n+{\n+    fFirstRunRet = false;\n+    if (!CWalletDB(\"cr+\").LoadWallet())\n+        return false;\n+    fFirstRunRet = vchDefaultKey.empty();\n+\n+    if (mapKeys.count(vchDefaultKey))\n+    {\n+        // Set keyUser\n+        keyUser.SetPubKey(vchDefaultKey);\n+        keyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n+    }\n+    else\n+    {\n+        // Create new keyUser and set as default key\n+        RandAddSeedPerfmon();\n+\n+        CWalletDB walletdb;\n+        vchDefaultKey = GetKeyFromKeyPool();\n+        walletdb.WriteDefaultKey(vchDefaultKey);\n+        walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n+    }\n+\n+    CreateThread(ThreadFlushWalletDB, NULL);\n+    return true;\n+}\n+\n+void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n+{\n+    nIndex = -1;\n+    keypool.vchPubKey.clear();\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_setKeyPool)\n+    {\n+        // Top up key pool\n+        int64 nTargetSize = max(GetArg(\"-keypool\", 100), (int64)0);\n+        while (setKeyPool.size() < nTargetSize+1)\n+        {\n+            int64 nEnd = 1;\n+            if (!setKeyPool.empty())\n+                nEnd = *(--setKeyPool.end()) + 1;\n+            if (!Write(make_pair(string(\"pool\"), nEnd), CKeyPool(GenerateNewKey())))\n+                throw runtime_error(\"ReserveKeyFromKeyPool() : writing generated key failed\");\n+            setKeyPool.insert(nEnd);\n+            printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n+        }\n+\n+        // Get the oldest key\n+        assert(!setKeyPool.empty());\n+        nIndex = *(setKeyPool.begin());\n+        setKeyPool.erase(setKeyPool.begin());\n+        if (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n+            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n+        if (!mapKeys.count(keypool.vchPubKey))\n+            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n+        assert(!keypool.vchPubKey.empty());\n+        printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n+    }\n+}\n+\n+void CWalletDB::KeepKey(int64 nIndex)\n+{\n+    // Remove from key pool\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        Erase(make_pair(string(\"pool\"), nIndex));\n+    }\n+    printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n+}\n+\n+void CWalletDB::ReturnKey(int64 nIndex)\n+{\n+    // Return to key pool\n+    CRITICAL_BLOCK(cs_setKeyPool)\n+        setKeyPool.insert(nIndex);\n+    printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n+}\n+\n+vector<unsigned char> GetKeyFromKeyPool()\n+{\n+    CWalletDB walletdb;\n+    int64 nIndex = 0;\n+    CKeyPool keypool;\n+    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n+    walletdb.KeepKey(nIndex);\n+    return keypool.vchPubKey;\n+}\n+\n+int64 GetOldestKeyPoolTime()\n+{\n+    CWalletDB walletdb;\n+    int64 nIndex = 0;\n+    CKeyPool keypool;\n+    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n+    walletdb.ReturnKey(nIndex);\n+    return keypool.nTime;\n+}\n+\n+std::vector<unsigned char> CReserveKey::GetReservedKey()\n+{\n+    if (nIndex == -1)\n+    {\n+        CKeyPool keypool;\n+        CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n+        vchPubKey = keypool.vchPubKey;\n+    }\n+    assert(!vchPubKey.empty());\n+    return vchPubKey;\n+}\n+\n+void CReserveKey::KeepKey()\n+{\n+    if (nIndex != -1)\n+        CWalletDB().KeepKey(nIndex);\n+    nIndex = -1;\n+    vchPubKey.clear();\n+}\n+\n+void CReserveKey::ReturnKey()\n+{\n+    if (nIndex != -1)\n+        CWalletDB::ReturnKey(nIndex);\n+    nIndex = -1;\n+    vchPubKey.clear();\n+}"
      },
      {
        "sha": "f9d2ea0989a91d9e90ef4f7cfb59c17c2fbc83c9",
        "filename": "src/wallet.h",
        "status": "added",
        "additions": 441,
        "deletions": 0,
        "changes": 441,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "patch": "@@ -0,0 +1,441 @@\n+// Copyright (c) 2009-2011 Satoshi Nakamoto & Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_WALLET_H\n+#define BITCOIN_WALLET_H\n+\n+#include \"bignum.h\"\n+#include \"script.h\"\n+\n+class CWalletTx;\n+class CReserveKey;\n+class CWalletDB;\n+\n+extern std::map<uint256, CWalletTx> mapWallet;\n+extern std::vector<uint256> vWalletUpdated;\n+extern CCriticalSection cs_mapWallet;\n+\n+extern std::map<uint256, int> mapRequestCount;\n+extern CCriticalSection cs_mapRequestCount;\n+\n+extern std::map<std::string, std::string> mapAddressBook;\n+extern CCriticalSection cs_mapAddressBook;\n+\n+extern std::vector<unsigned char> vchDefaultKey;\n+extern CKey keyUser;\n+\n+bool AddToWallet(const CWalletTx& wtxIn);\n+bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false);\n+bool EraseFromWallet(uint256 hash);\n+void WalletUpdateSpent(const COutPoint& prevout);\n+int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n+void ReacceptWalletTransactions();\n+void ResendWalletTransactions();\n+int64 GetBalance();\n+bool CreateTransaction(const std::vector<std::pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n+bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n+bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n+bool BroadcastTransaction(CWalletTx& wtxNew);\n+std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+\n+\n+\n+//\n+// A transaction with a bunch of additional info that only the owner cares\n+// about.  It includes any unrecorded transactions needed to link it back\n+// to the block chain.\n+//\n+class CWalletTx : public CMerkleTx\n+{\n+public:\n+    std::vector<CMerkleTx> vtxPrev;\n+    std::map<std::string, std::string> mapValue;\n+    std::vector<std::pair<std::string, std::string> > vOrderForm;\n+    unsigned int fTimeReceivedIsTxTime;\n+    unsigned int nTimeReceived;  // time received by this node\n+    char fFromMe;\n+    std::string strFromAccount;\n+    std::vector<char> vfSpent;\n+\n+    // memory only\n+    mutable char fDebitCached;\n+    mutable char fCreditCached;\n+    mutable char fAvailableCreditCached;\n+    mutable char fChangeCached;\n+    mutable int64 nDebitCached;\n+    mutable int64 nCreditCached;\n+    mutable int64 nAvailableCreditCached;\n+    mutable int64 nChangeCached;\n+\n+    // memory only UI hints\n+    mutable unsigned int nTimeDisplayed;\n+    mutable int nLinesDisplayed;\n+    mutable char fConfirmedDisplayed;\n+\n+\n+    CWalletTx()\n+    {\n+        Init();\n+    }\n+\n+    CWalletTx(const CMerkleTx& txIn) : CMerkleTx(txIn)\n+    {\n+        Init();\n+    }\n+\n+    CWalletTx(const CTransaction& txIn) : CMerkleTx(txIn)\n+    {\n+        Init();\n+    }\n+\n+    void Init()\n+    {\n+        vtxPrev.clear();\n+        mapValue.clear();\n+        vOrderForm.clear();\n+        fTimeReceivedIsTxTime = false;\n+        nTimeReceived = 0;\n+        fFromMe = false;\n+        strFromAccount.clear();\n+        vfSpent.clear();\n+        fDebitCached = false;\n+        fCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fChangeCached = false;\n+        nDebitCached = 0;\n+        nCreditCached = 0;\n+        nAvailableCreditCached = 0;\n+        nChangeCached = 0;\n+        nTimeDisplayed = 0;\n+        nLinesDisplayed = 0;\n+        fConfirmedDisplayed = false;\n+    }\n+\n+    IMPLEMENT_SERIALIZE\n+    (\n+        CWalletTx* pthis = const_cast<CWalletTx*>(this);\n+        if (fRead)\n+            pthis->Init();\n+        char fSpent = false;\n+\n+        if (!fRead)\n+        {\n+            pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n+\n+            std::string str;\n+            BOOST_FOREACH(char f, vfSpent)\n+            {\n+                str += (f ? '1' : '0');\n+                if (f)\n+                    fSpent = true;\n+            }\n+            pthis->mapValue[\"spent\"] = str;\n+        }\n+\n+        nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n+        READWRITE(vtxPrev);\n+        READWRITE(mapValue);\n+        READWRITE(vOrderForm);\n+        READWRITE(fTimeReceivedIsTxTime);\n+        READWRITE(nTimeReceived);\n+        READWRITE(fFromMe);\n+        READWRITE(fSpent);\n+\n+        if (fRead)\n+        {\n+            pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n+\n+            if (mapValue.count(\"spent\"))\n+                BOOST_FOREACH(char c, pthis->mapValue[\"spent\"])\n+                    pthis->vfSpent.push_back(c != '0');\n+            else\n+                pthis->vfSpent.assign(vout.size(), fSpent);\n+        }\n+\n+        pthis->mapValue.erase(\"fromaccount\");\n+        pthis->mapValue.erase(\"version\");\n+        pthis->mapValue.erase(\"spent\");\n+    )\n+\n+    // marks certain txout's as spent\n+    // returns true if any update took place\n+    bool UpdateSpent(const std::vector<char>& vfNewSpent)\n+    {\n+        bool fReturn = false;\n+        for (int i=0; i < vfNewSpent.size(); i++)\n+        {\n+            if (i == vfSpent.size())\n+                break;\n+\n+            if (vfNewSpent[i] && !vfSpent[i])\n+            {\n+                vfSpent[i] = true;\n+                fReturn = true;\n+                fAvailableCreditCached = false;\n+            }\n+        }\n+        return fReturn;\n+    }\n+\n+    void MarkDirty()\n+    {\n+        fCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fDebitCached = false;\n+        fChangeCached = false;\n+    }\n+\n+    void MarkSpent(unsigned int nOut)\n+    {\n+        if (nOut >= vout.size())\n+            throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n+        vfSpent.resize(vout.size());\n+        if (!vfSpent[nOut])\n+        {\n+            vfSpent[nOut] = true;\n+            fAvailableCreditCached = false;\n+        }\n+    }\n+\n+    bool IsSpent(unsigned int nOut) const\n+    {\n+        if (nOut >= vout.size())\n+            throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n+        if (nOut >= vfSpent.size())\n+            return false;\n+        return (!!vfSpent[nOut]);\n+    }\n+\n+    int64 GetDebit() const\n+    {\n+        if (vin.empty())\n+            return 0;\n+        if (fDebitCached)\n+            return nDebitCached;\n+        nDebitCached = CTransaction::GetDebit();\n+        fDebitCached = true;\n+        return nDebitCached;\n+    }\n+\n+    int64 GetCredit(bool fUseCache=true) const\n+    {\n+        // Must wait until coinbase is safely deep enough in the chain before valuing it\n+        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n+            return 0;\n+\n+        // GetBalance can assume transactions in mapWallet won't change\n+        if (fUseCache && fCreditCached)\n+            return nCreditCached;\n+        nCreditCached = CTransaction::GetCredit();\n+        fCreditCached = true;\n+        return nCreditCached;\n+    }\n+\n+    int64 GetAvailableCredit(bool fUseCache=true) const\n+    {\n+        // Must wait until coinbase is safely deep enough in the chain before valuing it\n+        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n+            return 0;\n+\n+        if (fUseCache && fAvailableCreditCached)\n+            return nAvailableCreditCached;\n+\n+        int64 nCredit = 0;\n+        for (int i = 0; i < vout.size(); i++)\n+        {\n+            if (!IsSpent(i))\n+            {\n+                const CTxOut &txout = vout[i];\n+                nCredit += txout.GetCredit();\n+                if (!MoneyRange(nCredit))\n+                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+            }\n+        }\n+\n+        nAvailableCreditCached = nCredit;\n+        fAvailableCreditCached = true;\n+        return nCredit;\n+    }\n+\n+\n+    int64 GetChange() const\n+    {\n+        if (fChangeCached)\n+            return nChangeCached;\n+        nChangeCached = CTransaction::GetChange();\n+        fChangeCached = true;\n+        return nChangeCached;\n+    }\n+\n+    void GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, std::list<std::pair<std::string /* address */, int64> >& listReceived,\n+                    std::list<std::pair<std::string /* address */, int64> >& listSent, int64& nFee, std::string& strSentAccount) const;\n+\n+    void GetAccountAmounts(const std::string& strAccount, int64& nGenerated, int64& nReceived,\n+                           int64& nSent, int64& nFee) const;\n+\n+    bool IsFromMe() const\n+    {\n+        return (GetDebit() > 0);\n+    }\n+\n+    bool IsConfirmed() const\n+    {\n+        // Quick answer in most cases\n+        if (!IsFinal())\n+            return false;\n+        if (GetDepthInMainChain() >= 1)\n+            return true;\n+        if (!IsFromMe()) // using wtx's cached debit\n+            return false;\n+\n+        // If no confirmations but it's from us, we can still\n+        // consider it confirmed if all dependencies are confirmed\n+        std::map<uint256, const CMerkleTx*> mapPrev;\n+        std::vector<const CMerkleTx*> vWorkQueue;\n+        vWorkQueue.reserve(vtxPrev.size()+1);\n+        vWorkQueue.push_back(this);\n+        for (int i = 0; i < vWorkQueue.size(); i++)\n+        {\n+            const CMerkleTx* ptx = vWorkQueue[i];\n+\n+            if (!ptx->IsFinal())\n+                return false;\n+            if (ptx->GetDepthInMainChain() >= 1)\n+                continue;\n+            if (!ptx->IsFromMe())\n+                return false;\n+\n+            if (mapPrev.empty())\n+                BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n+                    mapPrev[tx.GetHash()] = &tx;\n+\n+            BOOST_FOREACH(const CTxIn& txin, ptx->vin)\n+            {\n+                if (!mapPrev.count(txin.prevout.hash))\n+                    return false;\n+                vWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    bool WriteToDisk();\n+\n+    int64 GetTxTime() const;\n+    int GetRequestCount() const;\n+\n+    void AddSupportingTransactions(CTxDB& txdb);\n+\n+    bool AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs=true);\n+    bool AcceptWalletTransaction();\n+\n+    void RelayWalletTransaction(CTxDB& txdb);\n+    void RelayWalletTransaction();\n+};\n+\n+\n+//\n+// Private key that includes an expiration date in case it never gets used.\n+//\n+class CWalletKey\n+{\n+public:\n+    CPrivKey vchPrivKey;\n+    int64 nTimeCreated;\n+    int64 nTimeExpires;\n+    std::string strComment;\n+    //// todo: add something to note what created it (user, getnewaddress, change)\n+    ////   maybe should have a map<string, string> property map\n+\n+    CWalletKey(int64 nExpires=0)\n+    {\n+        nTimeCreated = (nExpires ? GetTime() : 0);\n+        nTimeExpires = nExpires;\n+    }\n+\n+    IMPLEMENT_SERIALIZE\n+    (\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(vchPrivKey);\n+        READWRITE(nTimeCreated);\n+        READWRITE(nTimeExpires);\n+        READWRITE(strComment);\n+    )\n+};\n+\n+\n+\n+\n+\n+\n+//\n+// Account information.\n+// Stored in wallet with key \"acc\"+string account name\n+//\n+class CAccount\n+{\n+public:\n+    std::vector<unsigned char> vchPubKey;\n+\n+    CAccount()\n+    {\n+        SetNull();\n+    }\n+\n+    void SetNull()\n+    {\n+        vchPubKey.clear();\n+    }\n+\n+    IMPLEMENT_SERIALIZE\n+    (\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(vchPubKey);\n+    )\n+};\n+\n+\n+\n+//\n+// Internal transfers.\n+// Database key is acentry<account><counter>\n+//\n+class CAccountingEntry\n+{\n+public:\n+    std::string strAccount;\n+    int64 nCreditDebit;\n+    int64 nTime;\n+    std::string strOtherAccount;\n+    std::string strComment;\n+\n+    CAccountingEntry()\n+    {\n+        SetNull();\n+    }\n+\n+    void SetNull()\n+    {\n+        nCreditDebit = 0;\n+        nTime = 0;\n+        strAccount.clear();\n+        strOtherAccount.clear();\n+        strComment.clear();\n+    }\n+\n+    IMPLEMENT_SERIALIZE\n+    (\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        // Note: strAccount is serialized as part of the key, not here.\n+        READWRITE(nCreditDebit);\n+        READWRITE(nTime);\n+        READWRITE(strOtherAccount);\n+        READWRITE(strComment);\n+    )\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NGM3ZWU3ZTZiOWMwNTlkOTlhYWE0OTNjNzRhNjcwM2M2YjBmYzgw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-06-01T16:28:20Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-06-15T09:05:55Z"
      },
      "message": "CWallet class\n\n* A new class CKeyStore manages private keys, and script.cpp depends on access to CKeyStore.\n* A new class CWallet extends CKeyStore, and contains all former wallet-specific globals; CWallet depends on script.cpp, not the other way around.\n* Wallet-specific functions in CTransaction/CTxIn/CTxOut (GetDebit, GetCredit, GetChange, IsMine, IsFromMe), are moved to CWallet, taking their former 'this' argument as an explicit parameter\n* CWalletTx objects know which CWallet they belong to, for convenience, so they have their own direct (and caching) GetDebit/... functions.\n* Some code was moved from CWalletDB to CWallet, such as handling of reserve keys.\n* Main.cpp keeps a set of all 'registered' wallets, which should be informed about updates to the block chain, and does not have any notion about any 'main' wallet. Function in main.cpp that require a wallet (such as GenerateCoins), take an explicit CWallet* argument.\n* The actual CWallet instance used by the application is defined in init.cpp as \"CWallet* pwalletMain\". rpc.cpp and ui.cpp use this variable.\n* Functions in main.cpp and db.cpp that are not used by other modules are marked static.\n* The code for handling the 'submitorder' message is removed, as it not really compatible with the idea that a node is independent from the wallet(s) connected to it, and obsolete anyway.",
      "tree": {
        "sha": "5ffafe3c7e4486f7b5ff2594bdbbf67e62560677",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ffafe3c7e4486f7b5ff2594bdbbf67e62560677"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e89b9f6a2abaa120ff0fc3cea9ae364e8cbd25e4"
      }
    ],
    "stats": {
      "total": 1493,
      "additions": 829,
      "deletions": 664
    },
    "files": [
      {
        "sha": "d5405d70e542fe0b4f4bda133e83ba1e01e2dfb6",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 26,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -10,8 +10,6 @@\n using namespace std;\n using namespace boost;\n \n-void ThreadFlushWalletDB(void* parg);\n-\n \n unsigned int nWalletDBUpdated;\n uint64 nAccountingEntryNumber = 0;\n@@ -150,7 +148,7 @@ void CDB::Close()\n         --mapFileUseCount[strFile];\n }\n \n-void CloseDb(const string& strFile)\n+void static CloseDb(const string& strFile)\n {\n     CRITICAL_BLOCK(cs_db)\n     {\n@@ -359,7 +357,7 @@ bool CTxDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n     return Write(string(\"bnBestInvalidWork\"), bnBestInvalidWork);\n }\n \n-CBlockIndex* InsertBlockIndex(uint256 hash)\n+CBlockIndex static * InsertBlockIndex(uint256 hash)\n {\n     if (hash == 0)\n         return NULL;\n@@ -584,6 +582,20 @@ bool LoadAddresses()\n // CWalletDB\n //\n \n+bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n+{\n+    nWalletDBUpdated++;\n+    return Write(make_pair(string(\"name\"), strAddress), strName);\n+}\n+\n+bool CWalletDB::EraseName(const string& strAddress)\n+{\n+    // This should only be used for sending addresses, never for receiving addresses,\n+    // receiving addresses must always have an address book entry if they're not change return.\n+    nWalletDBUpdated++;\n+    return Erase(make_pair(string(\"name\"), strAddress));\n+}\n+\n bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n {\n     account.SetNull();\n@@ -657,9 +669,9 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n }\n \n \n-bool CWalletDB::LoadWallet()\n+bool CWalletDB::LoadWallet(CWallet* pwallet)\n {\n-    vchDefaultKey.clear();\n+    pwallet->vchDefaultKey.clear();\n     int nFileVersion = 0;\n     vector<uint256> vWalletUpgrade;\n \n@@ -671,8 +683,8 @@ bool CWalletDB::LoadWallet()\n #endif\n \n     //// todo: shouldn't we catch exceptions and try to recover and continue?\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_mapKeys)\n+    CRITICAL_BLOCK(pwallet->cs_mapWallet)\n+    CRITICAL_BLOCK(pwallet->cs_mapKeys)\n     {\n         // Get cursor\n         Dbc* pcursor = GetCursor();\n@@ -699,14 +711,15 @@ bool CWalletDB::LoadWallet()\n             {\n                 string strAddress;\n                 ssKey >> strAddress;\n-                ssValue >> mapAddressBook[strAddress];\n+                ssValue >> pwallet->mapAddressBook[strAddress];\n             }\n             else if (strType == \"tx\")\n             {\n                 uint256 hash;\n                 ssKey >> hash;\n-                CWalletTx& wtx = mapWallet[hash];\n+                CWalletTx& wtx = pwallet->mapWallet[hash];\n                 ssValue >> wtx;\n+                wtx.pwallet = pwallet;\n \n                 if (wtx.GetHash() != hash)\n                     printf(\"Error in wallet.dat, hash mismatch\\n\");\n@@ -757,18 +770,18 @@ bool CWalletDB::LoadWallet()\n                 else\n                     ssValue >> wkey;\n \n-                mapKeys[vchPubKey] = wkey.vchPrivKey;\n+                pwallet->mapKeys[vchPubKey] = wkey.vchPrivKey;\n                 mapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n             }\n             else if (strType == \"defaultkey\")\n             {\n-                ssValue >> vchDefaultKey;\n+                ssValue >> pwallet->vchDefaultKey;\n             }\n             else if (strType == \"pool\")\n             {\n                 int64 nIndex;\n                 ssKey >> nIndex;\n-                setKeyPool.insert(nIndex);\n+                pwallet->setKeyPool.insert(nIndex);\n             }\n             else if (strType == \"version\")\n             {\n@@ -800,7 +813,7 @@ bool CWalletDB::LoadWallet()\n     }\n \n     BOOST_FOREACH(uint256 hash, vWalletUpgrade)\n-        WriteTx(hash, mapWallet[hash]);\n+        WriteTx(hash, pwallet->mapWallet[hash]);\n \n     printf(\"nFileVersion = %d\\n\", nFileVersion);\n     printf(\"fGenerateBitcoins = %d\\n\", fGenerateBitcoins);\n@@ -830,6 +843,7 @@ bool CWalletDB::LoadWallet()\n \n void ThreadFlushWalletDB(void* parg)\n {\n+    const string& strFile = ((const string*)parg)[0];\n     static bool fOneThread;\n     if (fOneThread)\n         return;\n@@ -865,7 +879,6 @@ void ThreadFlushWalletDB(void* parg)\n \n                 if (nRefCount == 0 && !fShutdown)\n                 {\n-                    string strFile = \"wallet.dat\";\n                     map<string, int>::iterator mi = mapFileUseCount.find(strFile);\n                     if (mi != mapFileUseCount.end())\n                     {\n@@ -888,38 +901,38 @@ void ThreadFlushWalletDB(void* parg)\n     }\n }\n \n-void BackupWallet(const string& strDest)\n+bool BackupWallet(const CWallet& wallet, const string& strDest)\n {\n+    if (!wallet.fFileBacked)\n+        return false;\n     while (!fShutdown)\n     {\n         CRITICAL_BLOCK(cs_db)\n         {\n-            const string strFile = \"wallet.dat\";\n-            if (!mapFileUseCount.count(strFile) || mapFileUseCount[strFile] == 0)\n+            if (!mapFileUseCount.count(wallet.strWalletFile) || mapFileUseCount[wallet.strWalletFile] == 0)\n             {\n                 // Flush log data to the dat file\n-                CloseDb(strFile);\n+                CloseDb(wallet.strWalletFile);\n                 dbenv.txn_checkpoint(0, 0, 0);\n-                dbenv.lsn_reset(strFile.c_str(), 0);\n-                mapFileUseCount.erase(strFile);\n+                dbenv.lsn_reset(wallet.strWalletFile.c_str(), 0);\n+                mapFileUseCount.erase(wallet.strWalletFile);\n \n                 // Copy wallet.dat\n-                filesystem::path pathSrc(GetDataDir() + \"/\" + strFile);\n+                filesystem::path pathSrc(GetDataDir() + \"/\" + wallet.strWalletFile);\n                 filesystem::path pathDest(strDest);\n                 if (filesystem::is_directory(pathDest))\n-                    pathDest = pathDest / strFile;\n+                    pathDest = pathDest / wallet.strWalletFile;\n #if BOOST_VERSION >= 104000\n                 filesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n #else\n                 filesystem::copy_file(pathSrc, pathDest);\n #endif\n                 printf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n \n-                return;\n+                return true;\n             }\n         }\n         Sleep(100);\n     }\n+    return false;\n }\n-\n-"
      },
      {
        "sha": "b89b34e0098b072ebd1c019954e7062a37b39537",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 24,
        "deletions": 70,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -12,33 +12,25 @@\n \n #include <db_cxx.h>\n \n-class CTransaction;\n class CTxIndex;\n class CDiskBlockIndex;\n class CDiskTxPos;\n class COutPoint;\n-class CUser;\n-class CReview;\n class CAddress;\n class CWalletTx;\n+class CWallet;\n class CAccount;\n class CAccountingEntry;\n class CBlockLocator;\n \n-extern std::vector<unsigned char> vchDefaultKey;\n-extern bool fClient;\n-extern int nBestHeight;\n-\n \n extern unsigned int nWalletDBUpdated;\n extern DbEnv dbenv;\n \n \n extern void DBFlush(bool fShutdown);\n-extern std::vector<unsigned char> GetKeyFromKeyPool();\n-extern int64 GetOldestKeyPoolTime();\n-extern void ThreadFlushWalletDB(void* parg);\n-\n+void ThreadFlushWalletDB(void* parg);\n+bool BackupWallet(const CWallet& wallet, const std::string& strDest);\n \n \n \n@@ -321,9 +313,6 @@ bool LoadAddresses();\n \n \n \n-\n-\n-\n class CKeyPool\n {\n public:\n@@ -356,7 +345,7 @@ class CKeyPool\n class CWalletDB : public CDB\n {\n public:\n-    CWalletDB(const char* pszMode=\"r+\") : CDB(\"wallet.dat\", pszMode)\n+    CWalletDB(std::string strFilename, const char* pszMode=\"r+\") : CDB(strFilename.c_str(), pszMode)\n     {\n     }\n private:\n@@ -369,23 +358,9 @@ class CWalletDB : public CDB\n         return Read(std::make_pair(std::string(\"name\"), strAddress), strName);\n     }\n \n-    bool WriteName(const std::string& strAddress, const std::string& strName)\n-    {\n-        CRITICAL_BLOCK(cs_mapAddressBook)\n-            mapAddressBook[strAddress] = strName;\n-        nWalletDBUpdated++;\n-        return Write(std::make_pair(std::string(\"name\"), strAddress), strName);\n-    }\n+    bool WriteName(const std::string& strAddress, const std::string& strName);\n \n-    bool EraseName(const std::string& strAddress)\n-    {\n-        // This should only be used for sending addresses, never for receiving addresses,\n-        // receiving addresses must always have an address book entry if they're not change return.\n-        CRITICAL_BLOCK(cs_mapAddressBook)\n-            mapAddressBook.erase(strAddress);\n-        nWalletDBUpdated++;\n-        return Erase(std::make_pair(std::string(\"name\"), strAddress));\n-    }\n+    bool EraseName(const std::string& strAddress);\n \n     bool ReadTx(uint256 hash, CWalletTx& wtx)\n     {\n@@ -435,11 +410,27 @@ class CWalletDB : public CDB\n \n     bool WriteDefaultKey(const std::vector<unsigned char>& vchPubKey)\n     {\n-        vchDefaultKey = vchPubKey;\n         nWalletDBUpdated++;\n         return Write(std::string(\"defaultkey\"), vchPubKey);\n     }\n \n+    bool ReadPool(int64 nPool, CKeyPool& keypool)\n+    {\n+        return Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+    }\n+\n+    bool WritePool(int64 nPool, const CKeyPool& keypool)\n+    {\n+        nWalletDBUpdated++;\n+        return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+    }\n+\n+    bool ErasePool(int64 nPool)\n+    {\n+        nWalletDBUpdated++;\n+        return Erase(std::make_pair(std::string(\"pool\"), nPool));\n+    }\n+\n     template<typename T>\n     bool ReadSetting(const std::string& strKey, T& value)\n     {\n@@ -459,44 +450,7 @@ class CWalletDB : public CDB\n     int64 GetAccountCreditDebit(const std::string& strAccount);\n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);\n \n-    bool LoadWallet();\n-protected:\n-    void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);\n-    void KeepKey(int64 nIndex);\n-    static void ReturnKey(int64 nIndex);\n-    friend class CReserveKey;\n-    friend std::vector<unsigned char> GetKeyFromKeyPool();\n-    friend int64 GetOldestKeyPoolTime();\n-};\n-\n-bool LoadWallet(bool& fFirstRunRet);\n-void BackupWallet(const std::string& strDest);\n-\n-inline bool SetAddressBookName(const std::string& strAddress, const std::string& strName)\n-{\n-    return CWalletDB().WriteName(strAddress, strName);\n-}\n-\n-class CReserveKey\n-{\n-protected:\n-    int64 nIndex;\n-    std::vector<unsigned char> vchPubKey;\n-public:\n-    CReserveKey()\n-    {\n-        nIndex = -1;\n-    }\n-\n-    ~CReserveKey()\n-    {\n-        if (!fShutdown)\n-            ReturnKey();\n-    }\n-\n-    std::vector<unsigned char> GetReservedKey();\n-    void KeepKey();\n-    void ReturnKey();\n+    bool LoadWallet(CWallet* pwallet);\n };\n \n #endif"
      },
      {
        "sha": "62bf1693f10cebb69c238aa54b646bf849f7c1db",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 7,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -13,6 +13,8 @@\n using namespace std;\n using namespace boost;\n \n+CWallet* pwalletMain;\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Shutdown\n@@ -45,6 +47,8 @@ void Shutdown(void* parg)\n         StopNode();\n         DBFlush(true);\n         boost::filesystem::remove(GetPidFile());\n+        UnregisterWallet(pwalletMain);\n+        delete pwalletMain;\n         CreateThread(ExitTimeout, NULL);\n         Sleep(50);\n         printf(\"Bitcoin exiting\\n\\n\");\n@@ -372,16 +376,19 @@ bool AppInit2(int argc, char* argv[])\n     printf(\"Loading wallet...\\n\");\n     nStart = GetTimeMillis();\n     bool fFirstRun;\n-    if (!LoadWallet(fFirstRun))\n+    pwalletMain = new CWallet(\"wallet.dat\");\n+    if (!pwalletMain->LoadWallet(fFirstRun))\n         strErrors += _(\"Error loading wallet.dat      \\n\");\n     printf(\" wallet      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n+    RegisterWallet(pwalletMain);\n+\n     CBlockIndex *pindexRescan = pindexBest;\n     if (GetBoolArg(\"-rescan\"))\n         pindexRescan = pindexGenesisBlock;\n     else\n     {\n-        CWalletDB walletdb;\n+        CWalletDB walletdb(\"wallet.dat\");\n         CBlockLocator locator;\n         if (walletdb.ReadBestBlock(locator))\n             pindexRescan = locator.GetBlockIndex();\n@@ -390,7 +397,7 @@ bool AppInit2(int argc, char* argv[])\n     {\n         printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n         nStart = GetTimeMillis();\n-        ScanForWalletTransactions(pindexRescan, true);\n+        pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n         printf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n     }\n \n@@ -399,10 +406,11 @@ bool AppInit2(int argc, char* argv[])\n         //// debug print\n         printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n         printf(\"nBestHeight = %d\\n\",            nBestHeight);\n-        printf(\"mapKeys.size() = %d\\n\",         mapKeys.size());\n+        printf(\"mapKeys.size() = %d\\n\",         pwalletMain->mapKeys.size());\n+        printf(\"setKeyPool.size() = %d\\n\",      pwalletMain->setKeyPool.size());\n         printf(\"mapPubKeys.size() = %d\\n\",      mapPubKeys.size());\n-        printf(\"mapWallet.size() = %d\\n\",       mapWallet.size());\n-        printf(\"mapAddressBook.size() = %d\\n\",  mapAddressBook.size());\n+        printf(\"mapWallet.size() = %d\\n\",       pwalletMain->mapWallet.size());\n+        printf(\"mapAddressBook.size() = %d\\n\",  pwalletMain->mapAddressBook.size());\n \n     if (!strErrors.empty())\n     {\n@@ -411,7 +419,7 @@ bool AppInit2(int argc, char* argv[])\n     }\n \n     // Add wallet transactions that aren't already in a block to mapTransactions\n-    ReacceptWalletTransactions();\n+    pwalletMain->ReacceptWalletTransactions();\n \n     //\n     // Parameters"
      },
      {
        "sha": "a02260c2939921befc13203c69f102605447d851",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -4,6 +4,8 @@\n #ifndef BITCOIN_INIT_H\n #define BITCOIN_INIT_H\n \n+extern CWallet* pwalletMain;\n+\n void Shutdown(void* parg);\n bool AppInit(int argc, char* argv[]);\n bool AppInit2(int argc, char* argv[]);"
      },
      {
        "sha": "7dd045fe5f99e20ff7d74cc25b9b2f466ff96291",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -12,7 +12,7 @@\n // mapKeys\n //\n \n-std::vector<unsigned char> GenerateNewKey()\n+std::vector<unsigned char> CKeyStore::GenerateNewKey()\n {\n     RandAddSeedPerfmon();\n     CKey key;\n@@ -22,12 +22,12 @@ std::vector<unsigned char> GenerateNewKey()\n     return key.GetPubKey();\n }\n \n-bool AddKey(const CKey& key)\n+bool CKeyStore::AddKey(const CKey& key)\n {\n     CRITICAL_BLOCK(cs_mapKeys)\n     {\n         mapKeys[key.GetPubKey()] = key.GetPrivKey();\n         mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();\n     }\n-    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());\n }\n+"
      },
      {
        "sha": "3b6869b42d487bba5296ec04141e58ebf025fb02",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -4,7 +4,23 @@\n #ifndef BITCOIN_KEYSTORE_H\n #define BITCOIN_KEYSTORE_H\n \n-bool AddKey(const CKey& key);\n-std::vector<unsigned char> GenerateNewKey();\n+class CKeyStore\n+{\n+public:\n+    std::map<std::vector<unsigned char>, CPrivKey> mapKeys;\n+    mutable CCriticalSection cs_mapKeys;\n+    virtual bool AddKey(const CKey& key);\n+    bool HaveKey(const std::vector<unsigned char> &vchPubKey) const\n+    {\n+        return (mapKeys.count(vchPubKey) > 0);\n+    }\n+    CPrivKey GetPrivKey(const std::vector<unsigned char> &vchPubKey) const\n+    {\n+        std::map<std::vector<unsigned char>, CPrivKey>::const_iterator mi = mapKeys.find(vchPubKey);\n+        if (mi != mapKeys.end())\n+            return (*mi).second;\n+    }\n+    std::vector<unsigned char> GenerateNewKey();\n+};\n \n #endif"
      },
      {
        "sha": "e3ec47d2f30cdc489696194a3278907193fc76a2",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 134,
        "deletions": 122,
        "changes": 256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -15,8 +15,14 @@ using namespace boost;\n // Global state\n //\n \n+CCriticalSection cs_setpwalletRegistered;\n+set<CWallet*> setpwalletRegistered;\n+\n CCriticalSection cs_main;\n \n+CCriticalSection cs_mapPubKeys;\n+map<uint160, vector<unsigned char> > mapPubKeys;\n+\n map<uint256, CTransaction> mapTransactions;\n CCriticalSection cs_mapTransactions;\n unsigned int nTransactionsUpdated = 0;\n@@ -39,25 +45,6 @@ multimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n map<uint256, CDataStream*> mapOrphanTransactions;\n multimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n \n-map<uint256, CWalletTx> mapWallet;\n-vector<uint256> vWalletUpdated;\n-CCriticalSection cs_mapWallet;\n-\n-map<vector<unsigned char>, CPrivKey> mapKeys;\n-map<uint160, vector<unsigned char> > mapPubKeys;\n-CCriticalSection cs_mapKeys;\n-CKey keyUser;\n-\n-map<uint256, int> mapRequestCount;\n-CCriticalSection cs_mapRequestCount;\n-\n-map<string, string> mapAddressBook;\n-CCriticalSection cs_mapAddressBook;\n-\n-set<int64> setKeyPool;\n-CCriticalSection cs_setKeyPool;\n-\n-vector<unsigned char> vchDefaultKey;\n \n double dHashesPerSec;\n int64 nHPSTimerStart;\n@@ -82,12 +69,97 @@ int fUseUPnP = false;\n \n \n \n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// dispatching functions\n+//\n+\n+void RegisterWallet(CWallet* pwalletIn)\n+{\n+    CRITICAL_BLOCK(cs_setpwalletRegistered)\n+    {\n+        setpwalletRegistered.insert(pwalletIn);\n+    }\n+}\n+\n+void UnregisterWallet(CWallet* pwalletIn)\n+{\n+    CRITICAL_BLOCK(cs_setpwalletRegistered)\n+    {\n+        setpwalletRegistered.erase(pwalletIn);\n+    }\n+}\n+\n+bool static IsFromMe(CTransaction& tx)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        if (pwallet->IsFromMe(tx))\n+            return true;\n+    return false;\n+}\n+\n+bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        if (pwallet->GetTransaction(hashTx,wtx))\n+            return true;\n+    return false;\n+}\n+\n+void static EraseFromWallets(uint256 hash)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->EraseFromWallet(hash);\n+}\n+\n+void static SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n+}\n+\n+void static SetBestChain(const CBlockLocator& loc)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->SetBestChain(loc);\n+}\n+\n+void static UpdatedTransaction(const uint256& hashTx)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->UpdatedTransaction(hashTx);\n+}\n+\n+void static PrintWallets(const CBlock& block)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->PrintWallet(block);\n+}\n+\n+void static Inventory(const uint256& hash)\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->Inventory(hash);\n+}\n+\n+void static ResendWalletTransactions()\n+{\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->ResendWalletTransactions();\n+}\n+\n+\n+\n+\n+\n+\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // mapOrphanTransactions\n //\n \n-void AddOrphanTx(const CDataStream& vMsg)\n+void static AddOrphanTx(const CDataStream& vMsg)\n {\n     CTransaction tx;\n     CDataStream(vMsg) >> tx;\n@@ -99,7 +171,7 @@ void AddOrphanTx(const CDataStream& vMsg)\n         mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pvMsg));\n }\n \n-void EraseOrphanTx(uint256 hash)\n+void static EraseOrphanTx(uint256 hash)\n {\n     if (!mapOrphanTransactions.count(hash))\n         return;\n@@ -357,7 +429,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n                 nLastTime = nNow;\n                 // -limitfreerelay unit is thousand-bytes-per-minute\n                 // At default rate it would take over a month to fill 1GB\n-                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe())\n+                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(*this))\n                     return error(\"AcceptToMemoryPool() : free transaction rejected by rate limiter\");\n                 if (fDebug)\n                     printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n@@ -380,7 +452,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     ///// are we sure this is ok when loading transactions or restoring block txes\n     // If updated, erase old tx from wallet\n     if (ptxOld)\n-        EraseFromWallet(ptxOld->GetHash());\n+        EraseFromWallets(ptxOld->GetHash());\n \n     printf(\"AcceptToMemoryPool(): accepted %s\\n\", hash.ToString().substr(0,10).c_str());\n     return true;\n@@ -551,16 +623,15 @@ bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n     return true;\n }\n \n-\n-uint256 GetOrphanRoot(const CBlock* pblock)\n+uint256 static GetOrphanRoot(const CBlock* pblock)\n {\n     // Work back to the first block in the orphan chain\n     while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n         pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n     return pblock->GetHash();\n }\n \n-int64 GetBlockValue(int nHeight, int64 nFees)\n+int64 static GetBlockValue(int nHeight, int64 nFees)\n {\n     int64 nSubsidy = 50 * COIN;\n \n@@ -570,7 +641,7 @@ int64 GetBlockValue(int nHeight, int64 nFees)\n     return nSubsidy + nFees;\n }\n \n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast)\n+unsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast)\n {\n     const int64 nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n     const int64 nTargetSpacing = 10 * 60;\n@@ -647,7 +718,7 @@ bool IsInitialBlockDownload()\n             pindexBest->GetBlockTime() < GetTime() - 24 * 60 * 60);\n }\n \n-void InvalidChainFound(CBlockIndex* pindexNew)\n+void static InvalidChainFound(CBlockIndex* pindexNew)\n {\n     if (pindexNew->bnChainWork > bnBestInvalidWork)\n     {\n@@ -923,12 +994,12 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n \n     // Watch for transactions paying to me\n     BOOST_FOREACH(CTransaction& tx, vtx)\n-        AddToWalletIfInvolvingMe(tx, this, true);\n+        SyncWithWallets(tx, this, true);\n \n     return true;\n }\n \n-bool Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n+bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n {\n     printf(\"REORGANIZE\\n\");\n \n@@ -1066,10 +1137,8 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n     // Update best block in wallet (so we can detect restored wallets)\n     if (!IsInitialBlockDownload())\n     {\n-        CWalletDB walletdb;\n         const CBlockLocator locator(pindexNew);\n-        if (!walletdb.WriteBestBlock(locator))\n-            return error(\"SetBestChain() : WriteWalletBest failed\");\n+        ::SetBestChain(locator);\n     }\n \n     // New best block\n@@ -1123,8 +1192,7 @@ bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n     {\n         // Notify UI to display prev block's coinbase if it was ours\n         static uint256 hashPrevBestCoinBase;\n-        CRITICAL_BLOCK(cs_mapWallet)\n-            vWalletUpdated.push_back(hashPrevBestCoinBase);\n+        UpdatedTransaction(hashPrevBestCoinBase);\n         hashPrevBestCoinBase = vtx[0].GetHash();\n     }\n \n@@ -1233,7 +1301,7 @@ bool CBlock::AcceptBlock()\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool static ProcessBlock(CNode* pfrom, CBlock* pblock)\n {\n     // Check for duplicate\n     uint256 hash = pblock->GetHash();\n@@ -1295,7 +1363,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n \n \n template<typename Stream>\n-bool ScanMessageStart(Stream& s)\n+bool static ScanMessageStart(Stream& s)\n {\n     // Scan ahead to the next pchMessageStart, which should normally be immediately\n     // at the file pointer.  Leaves file pointer at end of pchMessageStart.\n@@ -1510,7 +1578,7 @@ void PrintBlockTree()\n             for (int i = 0; i < nCol; i++)\n                 printf(\"| \");\n             printf(\"|\\n\");\n-        }\n+       }\n         nPrevCol = nCol;\n \n         // print columns\n@@ -1528,16 +1596,7 @@ void PrintBlockTree()\n             DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n             block.vtx.size());\n \n-        CRITICAL_BLOCK(cs_mapWallet)\n-        {\n-            if (mapWallet.count(block.vtx[0].GetHash()))\n-            {\n-                CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n-                printf(\"    mine:  %d  %d  %d\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n-            }\n-        }\n-        printf(\"\\n\");\n-\n+        PrintWallets(block);\n \n         // put the main timechain first\n         vector<CBlockIndex*>& vNext = mapNext[pindex];\n@@ -1677,7 +1736,7 @@ bool CAlert::ProcessAlert()\n //\n \n \n-bool AlreadyHave(CTxDB& txdb, const CInv& inv)\n+bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n {\n     switch (inv.type)\n     {\n@@ -1697,7 +1756,7 @@ bool AlreadyHave(CTxDB& txdb, const CInv& inv)\n char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n \n \n-bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n+bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n {\n     static map<unsigned int, vector<unsigned char> > mapReuseKey;\n     RandAddSeedPerfmon();\n@@ -1894,12 +1953,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n \n             // Track requests for our stuff\n-            CRITICAL_BLOCK(cs_mapRequestCount)\n-            {\n-                map<uint256, int>::iterator mi = mapRequestCount.find(inv.hash);\n-                if (mi != mapRequestCount.end())\n-                    (*mi).second++;\n-            }\n+            Inventory(inv.hash);\n         }\n     }\n \n@@ -1952,12 +2006,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             }\n \n             // Track requests for our stuff\n-            CRITICAL_BLOCK(cs_mapRequestCount)\n-            {\n-                map<uint256, int>::iterator mi = mapRequestCount.find(inv.hash);\n-                if (mi != mapRequestCount.end())\n-                    (*mi).second++;\n-            }\n+            Inventory(inv.hash);\n         }\n     }\n \n@@ -2045,7 +2094,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         bool fMissingInputs = false;\n         if (tx.AcceptToMemoryPool(true, &fMissingInputs))\n         {\n-            AddToWalletIfInvolvingMe(tx, NULL, true);\n+            SyncWithWallets(tx, NULL, true);\n             RelayMessage(inv, vMsg);\n             mapAlreadyAskedFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n@@ -2066,7 +2115,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     if (tx.AcceptToMemoryPool(true))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n-                        AddToWalletIfInvolvingMe(tx, NULL, true);\n+                        SyncWithWallets(tx, NULL, true);\n                         RelayMessage(inv, vMsg);\n                         mapAlreadyAskedFor.erase(inv);\n                         vWorkQueue.push_back(inv.hash);\n@@ -2143,7 +2192,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         // Keep giving the same key to the same ip until they use it\n         if (!mapReuseKey.count(pfrom->addr.ip))\n-            mapReuseKey[pfrom->addr.ip] = GetKeyFromKeyPool();\n+            mapReuseKey[pfrom->addr.ip] = pwalletMain->GetKeyFromKeyPool();\n \n         // Send back approval of order and pubkey to use\n         CScript scriptPubKey;\n@@ -2152,37 +2201,6 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     }\n \n \n-    else if (strCommand == \"submitorder\")\n-    {\n-        uint256 hashReply;\n-        vRecv >> hashReply;\n-\n-        if (!GetBoolArg(\"-allowreceivebyip\"))\n-        {\n-            pfrom->PushMessage(\"reply\", hashReply, (int)2);\n-            return true;\n-        }\n-\n-        CWalletTx wtxNew;\n-        vRecv >> wtxNew;\n-        wtxNew.fFromMe = false;\n-\n-        // Broadcast\n-        if (!wtxNew.AcceptWalletTransaction())\n-        {\n-            pfrom->PushMessage(\"reply\", hashReply, (int)1);\n-            return error(\"submitorder AcceptWalletTransaction() failed, returning error 1\");\n-        }\n-        wtxNew.fTimeReceivedIsTxTime = true;\n-        AddToWallet(wtxNew);\n-        wtxNew.RelayWalletTransaction();\n-        mapReuseKey.erase(pfrom->addr.ip);\n-\n-        // Send back confirmation\n-        pfrom->PushMessage(\"reply\", hashReply, (int)0);\n-    }\n-\n-\n     else if (strCommand == \"reply\")\n     {\n         uint256 hashReply;\n@@ -2239,7 +2257,6 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     return true;\n }\n \n-\n bool ProcessMessages(CNode* pfrom)\n {\n     CDataStream& vRecv = pfrom->vRecv;\n@@ -2359,8 +2376,6 @@ bool ProcessMessages(CNode* pfrom)\n }\n \n \n-\n-\n bool SendMessages(CNode* pto, bool fSendTrickle)\n {\n     CRITICAL_BLOCK(cs_main)\n@@ -2483,16 +2498,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     // always trickle our own transactions\n                     if (!fTrickleWait)\n                     {\n-                        TRY_CRITICAL_BLOCK(cs_mapWallet)\n-                        {\n-                            map<uint256, CWalletTx>::iterator mi = mapWallet.find(inv.hash);\n-                            if (mi != mapWallet.end())\n-                            {\n-                                CWalletTx& wtx = (*mi).second;\n-                                if (wtx.fFromMe)\n-                                    fTrickleWait = true;\n-                            }\n-                        }\n+                        CWalletTx wtx;\n+                        if (GetTransaction(inv.hash, wtx))\n+                            if (wtx.fFromMe)\n+                                fTrickleWait = true;\n                     }\n \n                     if (fTrickleWait)\n@@ -2565,7 +2574,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n // BitcoinMiner\n //\n \n-int FormatHashBlocks(void* pbuffer, unsigned int len)\n+int static FormatHashBlocks(void* pbuffer, unsigned int len)\n {\n     unsigned char* pdata = (unsigned char*)pbuffer;\n     unsigned int blocks = 1 + ((len + 8) / 64);\n@@ -2598,7 +2607,7 @@ inline void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n // between calls, but periodically or if nNonce is 0xffff0000 or above,\n // the block is rebuilt and nNonce starts over at zero.\n //\n-unsigned int ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n+unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n {\n     unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n     for (;;)\n@@ -2855,7 +2864,7 @@ void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash\n }\n \n \n-bool CheckWork(CBlock* pblock, CReserveKey& reservekey)\n+bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n {\n     uint256 hash = pblock->GetHash();\n     uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n@@ -2880,8 +2889,8 @@ bool CheckWork(CBlock* pblock, CReserveKey& reservekey)\n         reservekey.KeepKey();\n \n         // Track how many getdata requests this block gets\n-        CRITICAL_BLOCK(cs_mapRequestCount)\n-            mapRequestCount[pblock->GetHash()] = 0;\n+        CRITICAL_BLOCK(wallet.cs_mapRequestCount)\n+            wallet.mapRequestCount[pblock->GetHash()] = 0;\n \n         // Process this block the same as if we had received it from another node\n         if (!ProcessBlock(NULL, pblock))\n@@ -2892,13 +2901,15 @@ bool CheckWork(CBlock* pblock, CReserveKey& reservekey)\n     return true;\n }\n \n-void BitcoinMiner()\n+void static ThreadBitcoinMiner(void* parg);\n+\n+void static BitcoinMiner(CWallet *pwallet)\n {\n     printf(\"BitcoinMiner started\\n\");\n     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n \n     // Each thread has its own key and counter\n-    CReserveKey reservekey;\n+    CReserveKey reservekey(pwallet);\n     unsigned int nExtraNonce = 0;\n     int64 nPrevTime = 0;\n \n@@ -2974,7 +2985,7 @@ void BitcoinMiner()\n                     assert(hash == pblock->GetHash());\n \n                     SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                    CheckWork(pblock.get(), reservekey);\n+                    CheckWork(pblock.get(), *pwalletMain, reservekey);\n                     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n                     break;\n                 }\n@@ -3035,12 +3046,13 @@ void BitcoinMiner()\n     }\n }\n \n-void ThreadBitcoinMiner(void* parg)\n+void static ThreadBitcoinMiner(void* parg)\n {\n+    CWallet* pwallet = (CWallet*)parg;\n     try\n     {\n         vnThreadsRunning[3]++;\n-        BitcoinMiner();\n+        BitcoinMiner(pwallet);\n         vnThreadsRunning[3]--;\n     }\n     catch (std::exception& e) {\n@@ -3058,12 +3070,12 @@ void ThreadBitcoinMiner(void* parg)\n }\n \n \n-void GenerateBitcoins(bool fGenerate)\n+void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n {\n     if (fGenerateBitcoins != fGenerate)\n     {\n         fGenerateBitcoins = fGenerate;\n-        CWalletDB().WriteSetting(\"fGenerateBitcoins\", fGenerateBitcoins);\n+        WriteSetting(\"fGenerateBitcoins\", fGenerateBitcoins);\n         MainFrameRepaint();\n     }\n     if (fGenerateBitcoins)\n@@ -3078,7 +3090,7 @@ void GenerateBitcoins(bool fGenerate)\n         printf(\"Starting %d BitcoinMiner threads\\n\", nAddThreads);\n         for (int i = 0; i < nAddThreads; i++)\n         {\n-            if (!CreateThread(ThreadBitcoinMiner, NULL))\n+            if (!CreateThread(ThreadBitcoinMiner, pwallet))\n                 printf(\"Error: CreateThread(ThreadBitcoinMiner) failed\\n\");\n             Sleep(10);\n         }"
      },
      {
        "sha": "3b35387c9836371b8147cbd145279a7fd194d677",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 28,
        "deletions": 103,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -8,21 +8,17 @@\n #include \"net.h\"\n #include \"key.h\"\n #include \"script.h\"\n+#include \"db.h\"\n \n #include <list>\n \n-class COutPoint;\n-class CInPoint;\n-class CDiskTxPos;\n-class CCoinBase;\n-class CTxIn;\n-class CTxOut;\n-class CTransaction;\n class CBlock;\n class CBlockIndex;\n class CWalletTx;\n class CWallet;\n class CKeyItem;\n+class CReserveKey;\n+class CWalletDB;\n \n class CMessageHeader;\n class CAddress;\n@@ -62,15 +58,12 @@ extern CBigNum bnBestChainWork;\n extern CBigNum bnBestInvalidWork;\n extern uint256 hashBestChain;\n extern CBlockIndex* pindexBest;\n-extern std::set<int64> setKeyPool;\n-extern CCriticalSection cs_setKeyPool;\n extern unsigned int nTransactionsUpdated;\n extern double dHashesPerSec;\n extern int64 nHPSTimerStart;\n extern int64 nTimeBestReceived;\n-extern std::map<std::string, std::string> mapAddressBook;\n-extern CCriticalSection cs_mapAddressBook;\n-\n+extern CCriticalSection cs_setpwalletRegistered;\n+extern std::set<CWallet*> setpwalletRegistered;\n \n // Settings\n extern int fGenerateBitcoins;\n@@ -90,21 +83,20 @@ class CReserveKey;\n class CTxDB;\n class CTxIndex;\n \n+void RegisterWallet(CWallet* pwalletIn);\n+void UnregisterWallet(CWallet* pwalletIn);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=\"rb\");\n FILE* AppendBlockFile(unsigned int& nFileRet);\n bool LoadBlockIndex(bool fAllowNew=true);\n void PrintBlockTree();\n bool ProcessMessages(CNode* pfrom);\n-bool ProcessMessage(CNode* pfrom, std::string strCommand, CDataStream& vRecv);\n bool SendMessages(CNode* pto, bool fSendTrickle);\n-void GenerateBitcoins(bool fGenerate);\n-void ThreadBitcoinMiner(void* parg);\n+void GenerateBitcoins(bool fGenerate, CWallet* pwallet);\n CBlock* CreateNewBlock(CReserveKey& reservekey);\n void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce, int64& nPrevTime);\n void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1);\n-bool CheckWork(CBlock* pblock, CReserveKey& reservekey);\n-void BitcoinMiner();\n+bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\n bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n bool IsInitialBlockDownload();\n std::string GetWarnings(std::string strFor);\n@@ -120,6 +112,23 @@ std::string GetWarnings(std::string strFor);\n \n \n \n+bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n+\n+template<typename T>\n+bool WriteSetting(const std::string& strKey, const T& value)\n+{\n+    bool fOk = false;\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+    {\n+        std::string strWalletFile;\n+        if (!GetWalletFile(pwallet, strWalletFile))\n+            continue;\n+        fOk |= CWalletDB(strWalletFile).WriteSetting(strKey, value);\n+    }\n+    return fOk;\n+}\n+\n+\n class CDiskTxPos\n {\n public:\n@@ -302,9 +311,6 @@ class CTxIn\n     {\n         printf(\"%s\\n\", ToString().c_str());\n     }\n-\n-    bool IsMine() const;\n-    int64 GetDebit() const;\n };\n \n \n@@ -353,36 +359,6 @@ class CTxOut\n         return SerializeHash(*this);\n     }\n \n-    bool IsMine() const\n-    {\n-        return ::IsMine(scriptPubKey);\n-    }\n-\n-    int64 GetCredit() const\n-    {\n-        if (!MoneyRange(nValue))\n-            throw std::runtime_error(\"CTxOut::GetCredit() : value out of range\");\n-        return (IsMine() ? nValue : 0);\n-    }\n-\n-    bool IsChange() const\n-    {\n-        // On a debit transaction, a txout that's mine but isn't in the address book is change\n-        std::vector<unsigned char> vchPubKey;\n-        if (ExtractPubKey(scriptPubKey, true, vchPubKey))\n-            CRITICAL_BLOCK(cs_mapAddressBook)\n-                if (!mapAddressBook.count(PubKeyToAddress(vchPubKey)))\n-                    return true;\n-        return false;\n-    }\n-\n-    int64 GetChange() const\n-    {\n-        if (!MoneyRange(nValue))\n-            throw std::runtime_error(\"CTxOut::GetChange() : value out of range\");\n-        return (IsChange() ? nValue : 0);\n-    }\n-\n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n     {\n         return (a.nValue       == b.nValue &&\n@@ -527,57 +503,6 @@ class CTransaction\n         return true;\n     }\n \n-    bool IsMine() const\n-    {\n-        BOOST_FOREACH(const CTxOut& txout, vout)\n-            if (txout.IsMine())\n-                return true;\n-        return false;\n-    }\n-\n-    bool IsFromMe() const\n-    {\n-        return (GetDebit() > 0);\n-    }\n-\n-    int64 GetDebit() const\n-    {\n-        int64 nDebit = 0;\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-        {\n-            nDebit += txin.GetDebit();\n-            if (!MoneyRange(nDebit))\n-                throw std::runtime_error(\"CTransaction::GetDebit() : value out of range\");\n-        }\n-        return nDebit;\n-    }\n-\n-    int64 GetCredit() const\n-    {\n-        int64 nCredit = 0;\n-        BOOST_FOREACH(const CTxOut& txout, vout)\n-        {\n-            nCredit += txout.GetCredit();\n-            if (!MoneyRange(nCredit))\n-                throw std::runtime_error(\"CTransaction::GetCredit() : value out of range\");\n-        }\n-        return nCredit;\n-    }\n-\n-    int64 GetChange() const\n-    {\n-        if (IsCoinBase())\n-            return 0;\n-        int64 nChange = 0;\n-        BOOST_FOREACH(const CTxOut& txout, vout)\n-        {\n-            nChange += txout.GetChange();\n-            if (!MoneyRange(nChange))\n-                throw std::runtime_error(\"CTransaction::GetChange() : value out of range\");\n-        }\n-        return nChange;\n-    }\n-\n     int64 GetValueOut() const\n     {\n         int64 nValueOut = 0;\n@@ -1639,9 +1564,9 @@ class CAlert : public CUnsignedAlert\n \n \n \n+\n extern std::map<uint256, CTransaction> mapTransactions;\n-extern std::map<std::vector<unsigned char>, CPrivKey> mapKeys;\n extern std::map<uint160, std::vector<unsigned char> > mapPubKeys;\n-extern CCriticalSection cs_mapKeys;\n+extern CCriticalSection cs_mapPubKeys;\n \n #endif"
      },
      {
        "sha": "4b13726230bda6a5bf82a1f073f69289e70a823b",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -1117,7 +1117,7 @@ void MapPort(bool fMapPort)\n     if (fUseUPnP != fMapPort)\n     {\n         fUseUPnP = fMapPort;\n-        CWalletDB().WriteSetting(\"fUseUPnP\", fUseUPnP);\n+        WriteSetting(\"fUseUPnP\", fUseUPnP);\n     }\n     if (fUseUPnP && vnThreadsRunning[5] < 1)\n     {\n@@ -1698,7 +1698,7 @@ void StartNode(void* parg)\n         printf(\"Error: CreateThread(ThreadMessageHandler) failed\\n\");\n \n     // Generate coins in the background\n-    GenerateBitcoins(fGenerateBitcoins);\n+    GenerateBitcoins(fGenerateBitcoins, pwalletMain);\n }\n \n bool StopNode()"
      },
      {
        "sha": "5b395f9470b6fcacf3b3a87288620c0e1a3ff91c",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 74,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -264,14 +264,14 @@ Value setgenerate(const Array& params, bool fHelp)\n     {\n         int nGenProcLimit = params[1].get_int();\n         fLimitProcessors = (nGenProcLimit != -1);\n-        CWalletDB().WriteSetting(\"fLimitProcessors\", fLimitProcessors);\n+        WriteSetting(\"fLimitProcessors\", fLimitProcessors);\n         if (nGenProcLimit != -1)\n-            CWalletDB().WriteSetting(\"nLimitProcessors\", nLimitProcessors = nGenProcLimit);\n+            WriteSetting(\"nLimitProcessors\", nLimitProcessors = nGenProcLimit);\n         if (nGenProcLimit == 0)\n             fGenerate = false;\n     }\n \n-    GenerateBitcoins(fGenerate);\n+    GenerateBitcoins(fGenerate, pwalletMain);\n     return Value::null;\n }\n \n@@ -298,7 +298,7 @@ Value getinfo(const Array& params, bool fHelp)\n \n     Object obj;\n     obj.push_back(Pair(\"version\",       (int)VERSION));\n-    obj.push_back(Pair(\"balance\",       ValueFromAmount(GetBalance())));\n+    obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n     obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n     obj.push_back(Pair(\"proxy\",         (fUseProxy ? addrProxy.ToStringIPPort() : string())));\n@@ -307,7 +307,7 @@ Value getinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"hashespersec\",  gethashespersec(params, false)));\n     obj.push_back(Pair(\"testnet\",       fTestNet));\n-    obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)GetOldestKeyPoolTime()));\n+    obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)pwalletMain->GetOldestKeyPoolTime()));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(nTransactionFee)));\n     obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n     return obj;\n@@ -329,9 +329,9 @@ Value getnewaddress(const Array& params, bool fHelp)\n         strAccount = AccountFromValue(params[0]);\n \n     // Generate a new key that is added to wallet\n-    string strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+    string strAddress = PubKeyToAddress(pwalletMain->GetKeyFromKeyPool());\n \n-    SetAddressBookName(strAddress, strAccount);\n+    pwalletMain->SetAddressBookName(strAddress, strAccount);\n     return strAddress;\n }\n \n@@ -341,7 +341,7 @@ string GetAccountAddress(string strAccount, bool bForceNew=false)\n {\n     string strAddress;\n \n-    CWalletDB walletdb;\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n     walletdb.TxnBegin();\n \n     CAccount account;\n@@ -352,8 +352,8 @@ string GetAccountAddress(string strAccount, bool bForceNew=false)\n     {\n         CScript scriptPubKey;\n         scriptPubKey.SetBitcoinAddress(account.vchPubKey);\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n-             it != mapWallet.end() && !account.vchPubKey.empty();\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n+             it != pwalletMain->mapWallet.end() && !account.vchPubKey.empty();\n              ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n@@ -366,9 +366,9 @@ string GetAccountAddress(string strAccount, bool bForceNew=false)\n     // Generate a new key\n     if (account.vchPubKey.empty() || bForceNew)\n     {\n-        account.vchPubKey = GetKeyFromKeyPool();\n+        account.vchPubKey = pwalletMain->GetKeyFromKeyPool();\n         string strAddress = PubKeyToAddress(account.vchPubKey);\n-        SetAddressBookName(strAddress, strAccount);\n+        pwalletMain->SetAddressBookName(strAddress, strAccount);\n         walletdb.WriteAccount(strAccount, account);\n     }\n \n@@ -391,7 +391,7 @@ Value getaccountaddress(const Array& params, bool fHelp)\n     Value ret;\n \n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n         ret = GetAccountAddress(strAccount);\n     }\n@@ -421,18 +421,18 @@ Value setaccount(const Array& params, bool fHelp)\n \n     // Detect when changing the account of an address that is the 'unused current key' of another account:\n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n-        if (mapAddressBook.count(strAddress))\n+        if (pwalletMain->mapAddressBook.count(strAddress))\n         {\n-            string strOldAccount = mapAddressBook[strAddress];\n+            string strOldAccount = pwalletMain->mapAddressBook[strAddress];\n             if (strAddress == GetAccountAddress(strOldAccount))\n                 GetAccountAddress(strOldAccount, true);\n         }\n     }\n \n-    SetAddressBookName(strAddress, strAccount);\n+    pwalletMain->SetAddressBookName(strAddress, strAccount);\n     return Value::null;\n }\n \n@@ -447,10 +447,10 @@ Value getaccount(const Array& params, bool fHelp)\n     string strAddress = params[0].get_str();\n \n     string strAccount;\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n-        map<string, string>::iterator mi = mapAddressBook.find(strAddress);\n-        if (mi != mapAddressBook.end() && !(*mi).second.empty())\n+        map<string, string>::iterator mi = pwalletMain->mapAddressBook.find(strAddress);\n+        if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.empty())\n             strAccount = (*mi).second;\n     }\n     return strAccount;\n@@ -468,9 +468,9 @@ Value getaddressesbyaccount(const Array& params, bool fHelp)\n \n     // Find all addresses that have the given account\n     Array ret;\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapAddressBook)\n+        BOOST_FOREACH(const PAIRTYPE(string, string)& item, pwalletMain->mapAddressBook)\n         {\n             const string& strAddress = item.first;\n             const string& strName = item.second;\n@@ -523,7 +523,7 @@ Value sendtoaddress(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     {\n-        string strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n+        string strError = pwalletMain->SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n         if (strError != \"\")\n             throw JSONRPCError(-4, strError);\n     }\n@@ -544,7 +544,7 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n     CScript scriptPubKey;\n     if (!scriptPubKey.SetBitcoinAddress(strAddress))\n         throw JSONRPCError(-5, \"Invalid bitcoin address\");\n-    if (!IsMine(scriptPubKey))\n+    if (!IsMine(*pwalletMain,scriptPubKey))\n         return (double)0.0;\n \n     // Minimum confirmations\n@@ -554,9 +554,9 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n \n     // Tally\n     int64 nAmount = 0;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (wtx.IsCoinBase() || !wtx.IsFinal())\n@@ -575,9 +575,9 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n \n void GetAccountPubKeys(string strAccount, set<CScript>& setPubKey)\n {\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapAddressBook)\n+        BOOST_FOREACH(const PAIRTYPE(string, string)& item, pwalletMain->mapAddressBook)\n         {\n             const string& strAddress = item.first;\n             const string& strName = item.second;\n@@ -586,7 +586,7 @@ void GetAccountPubKeys(string strAccount, set<CScript>& setPubKey)\n                 // We're only counting our own valid bitcoin addresses and not ip addresses\n                 CScript scriptPubKey;\n                 if (scriptPubKey.SetBitcoinAddress(strAddress))\n-                    if (IsMine(scriptPubKey))\n+                    if (IsMine(*pwalletMain,scriptPubKey))\n                         setPubKey.insert(scriptPubKey);\n             }\n         }\n@@ -613,9 +613,9 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n \n     // Tally\n     int64 nAmount = 0;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (wtx.IsCoinBase() || !wtx.IsFinal())\n@@ -635,10 +635,10 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n int64 GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n {\n     int64 nBalance = 0;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n         // Tally wallet transactions\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (!wtx.IsFinal())\n@@ -661,7 +661,7 @@ int64 GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinD\n \n int64 GetAccountBalance(const string& strAccount, int nMinDepth)\n {\n-    CWalletDB walletdb;\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n     return GetAccountBalance(walletdb, strAccount, nMinDepth);\n }\n \n@@ -675,7 +675,7 @@ Value getbalance(const Array& params, bool fHelp)\n             \"If [account] is specified, returns the balance in the account.\");\n \n     if (params.size() == 0)\n-        return  ValueFromAmount(GetBalance());\n+        return  ValueFromAmount(pwalletMain->GetBalance());\n \n     int nMinDepth = 1;\n     if (params.size() > 1)\n@@ -686,7 +686,7 @@ Value getbalance(const Array& params, bool fHelp)\n         // (GetBalance() sums up all unspent TxOuts)\n         // getbalance and getbalance '*' should always return the same number.\n         int64 nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (!wtx.IsFinal())\n@@ -734,9 +734,9 @@ Value movecmd(const Array& params, bool fHelp)\n     if (params.size() > 4)\n         strComment = params[4].get_str();\n \n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n-        CWalletDB walletdb;\n+        CWalletDB walletdb(pwalletMain->strWalletFile);\n         walletdb.TxnBegin();\n \n         int64 nNow = GetAdjustedTime();\n@@ -787,15 +787,15 @@ Value sendfrom(const Array& params, bool fHelp)\n         wtx.mapValue[\"to\"]      = params[5].get_str();\n \n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n         // Check funds\n         int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n         if (nAmount > nBalance)\n             throw JSONRPCError(-6, \"Account has insufficient funds\");\n \n         // Send\n-        string strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n+        string strError = pwalletMain->SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n         if (strError != \"\")\n             throw JSONRPCError(-4, strError);\n     }\n@@ -844,24 +844,24 @@ Value sendmany(const Array& params, bool fHelp)\n     }\n \n     CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n         // Check funds\n         int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n         if (totalAmount > nBalance)\n             throw JSONRPCError(-6, \"Account has insufficient funds\");\n \n         // Send\n-        CReserveKey keyChange;\n+        CReserveKey keyChange(pwalletMain);\n         int64 nFeeRequired = 0;\n-        bool fCreated = CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n+        bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n         if (!fCreated)\n         {\n-            if (totalAmount + nFeeRequired > GetBalance())\n+            if (totalAmount + nFeeRequired > pwalletMain->GetBalance())\n                 throw JSONRPCError(-6, \"Insufficient funds\");\n             throw JSONRPCError(-4, \"Transaction creation failed\");\n         }\n-        if (!CommitTransaction(wtx, keyChange))\n+        if (!pwalletMain->CommitTransaction(wtx, keyChange))\n             throw JSONRPCError(-4, \"Transaction commit failed\");\n     }\n \n@@ -894,9 +894,9 @@ Value ListReceived(const Array& params, bool fByAccounts)\n \n     // Tally\n     map<uint160, tallyitem> mapTally;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (wtx.IsCoinBase() || !wtx.IsFinal())\n@@ -923,9 +923,9 @@ Value ListReceived(const Array& params, bool fByAccounts)\n     // Reply\n     Array ret;\n     map<string, tallyitem> mapAccountTally;\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapAddressBook)\n+        BOOST_FOREACH(const PAIRTYPE(string, string)& item, pwalletMain->mapAddressBook)\n         {\n             const string& strAddress = item.first;\n             const string& strAccount = item.second;\n@@ -1061,13 +1061,13 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n \n     // Received\n     if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-        CRITICAL_BLOCK(cs_mapAddressBook)\n+        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n         {\n             BOOST_FOREACH(const PAIRTYPE(string, int64)& r, listReceived)\n             {\n                 string account;\n-                if (mapAddressBook.count(r.first))\n-                    account = mapAddressBook[r.first];\n+                if (pwalletMain->mapAddressBook.count(r.first))\n+                    account = pwalletMain->mapAddressBook[r.first];\n                 if (fAllAccounts || (account == strAccount))\n                 {\n                     Object entry;\n@@ -1119,16 +1119,16 @@ Value listtransactions(const Array& params, bool fHelp)\n         nFrom = params[2].get_int();\n \n     Array ret;\n-    CWalletDB walletdb;\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n \n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n         // Firs: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap:\n         typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n         typedef multimap<int64, TxPair > TxItems;\n         TxItems txByTime;\n \n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             CWalletTx* wtx = &((*it).second);\n             txByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n@@ -1180,16 +1180,16 @@ Value listaccounts(const Array& params, bool fHelp)\n         nMinDepth = params[0].get_int();\n \n     map<string, int64> mapAccountBalances;\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(string, string)& entry, mapAddressBook) {\n+        BOOST_FOREACH(const PAIRTYPE(string, string)& entry, pwalletMain->mapAddressBook) {\n             uint160 hash160;\n             if(AddressToHash160(entry.first, hash160) && mapPubKeys.count(hash160)) // This address belongs to me\n                 mapAccountBalances[entry.second] = 0;\n         }\n \n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             int64 nGeneratedImmature, nGeneratedMature, nFee;\n@@ -1204,16 +1204,16 @@ Value listaccounts(const Array& params, bool fHelp)\n             {\n                 mapAccountBalances[\"\"] += nGeneratedMature;\n                 BOOST_FOREACH(const PAIRTYPE(string, int64)& r, listReceived)\n-                    if (mapAddressBook.count(r.first))\n-                        mapAccountBalances[mapAddressBook[r.first]] += r.second;\n+                    if (pwalletMain->mapAddressBook.count(r.first))\n+                        mapAccountBalances[pwalletMain->mapAddressBook[r.first]] += r.second;\n                     else\n                         mapAccountBalances[\"\"] += r.second;\n             }\n         }\n     }\n \n     list<CAccountingEntry> acentries;\n-    CWalletDB().ListAccountCreditDebit(\"*\", acentries);\n+    CWalletDB(pwalletMain->strWalletFile).ListAccountCreditDebit(\"*\", acentries);\n     BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n@@ -1235,11 +1235,11 @@ Value gettransaction(const Array& params, bool fHelp)\n     hash.SetHex(params[0].get_str());\n \n     Object entry;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n-        if (!mapWallet.count(hash))\n+        if (!pwalletMain->mapWallet.count(hash))\n             throw JSONRPCError(-5, \"Invalid or non-wallet transaction id\");\n-        const CWalletTx& wtx = mapWallet[hash];\n+        const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n \n         int64 nCredit = wtx.GetCredit();\n         int64 nDebit = wtx.GetDebit();\n@@ -1250,10 +1250,10 @@ Value gettransaction(const Array& params, bool fHelp)\n         if (wtx.IsFromMe())\n             entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n \n-        WalletTxToJSON(mapWallet[hash], entry);\n+        WalletTxToJSON(pwalletMain->mapWallet[hash], entry);\n \n         Array details;\n-        ListTransactions(mapWallet[hash], \"*\", 0, false, details);\n+        ListTransactions(pwalletMain->mapWallet[hash], \"*\", 0, false, details);\n         entry.push_back(Pair(\"details\", details));\n     }\n \n@@ -1269,7 +1269,7 @@ Value backupwallet(const Array& params, bool fHelp)\n             \"Safely copies wallet.dat to destination, which can be a directory or a path with filename.\");\n \n     string strDest = params[0].get_str();\n-    BackupWallet(strDest);\n+    BackupWallet(*pwalletMain, strDest);\n \n     return Value::null;\n }\n@@ -1295,10 +1295,10 @@ Value validateaddress(const Array& params, bool fHelp)\n         string currentAddress = Hash160ToAddress(hash160);\n         ret.push_back(Pair(\"address\", currentAddress));\n         ret.push_back(Pair(\"ismine\", (mapPubKeys.count(hash160) > 0)));\n-        CRITICAL_BLOCK(cs_mapAddressBook)\n+        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n         {\n-            if (mapAddressBook.count(currentAddress))\n-                ret.push_back(Pair(\"account\", mapAddressBook[currentAddress]));\n+            if (pwalletMain->mapAddressBook.count(currentAddress))\n+                ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[currentAddress]));\n         }\n     }\n     return ret;\n@@ -1325,7 +1325,7 @@ Value getwork(const Array& params, bool fHelp)\n \n     static map<uint256, pair<CBlock*, unsigned int> > mapNewBlock;\n     static vector<CBlock*> vNewBlock;\n-    static CReserveKey reservekey;\n+    static CReserveKey reservekey(pwalletMain);\n \n     if (params.size() == 0)\n     {\n@@ -1406,7 +1406,7 @@ Value getwork(const Array& params, bool fHelp)\n         pblock->vtx[0].vin[0].scriptSig = CScript() << pblock->nBits << CBigNum(nExtraNonce);\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n \n-        return CheckWork(pblock, reservekey);\n+        return CheckWork(pblock, *pwalletMain, reservekey);\n     }\n }\n "
      },
      {
        "sha": "e1b5ae8959e1be5a3a3bdee59d2eebea44c8a50c",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 18,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -1021,7 +1021,7 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n }\n \n \n-bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)\n+bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)\n {\n     scriptSigRet.clear();\n \n@@ -1030,20 +1030,20 @@ bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& s\n         return false;\n \n     // Compile solution\n-    CRITICAL_BLOCK(cs_mapKeys)\n+    CRITICAL_BLOCK(keystore.cs_mapKeys)\n     {\n         BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n         {\n             if (item.first == OP_PUBKEY)\n             {\n                 // Sign\n                 const valtype& vchPubKey = item.second;\n-                if (!mapKeys.count(vchPubKey))\n+                if (!keystore.HaveKey(vchPubKey))\n                     return false;\n                 if (hash != 0)\n                 {\n                     vector<unsigned char> vchSig;\n-                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+                    if (!CKey::Sign(keystore.GetPrivKey(vchPubKey), hash, vchSig))\n                         return false;\n                     vchSig.push_back((unsigned char)nHashType);\n                     scriptSigRet << vchSig;\n@@ -1056,12 +1056,12 @@ bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& s\n                 if (mi == mapPubKeys.end())\n                     return false;\n                 const vector<unsigned char>& vchPubKey = (*mi).second;\n-                if (!mapKeys.count(vchPubKey))\n+                if (!keystore.HaveKey(vchPubKey))\n                     return false;\n                 if (hash != 0)\n                 {\n                     vector<unsigned char> vchSig;\n-                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+                    if (!CKey::Sign(keystore.GetPrivKey(vchPubKey), hash, vchSig))\n                         return false;\n                     vchSig.push_back((unsigned char)nHashType);\n                     scriptSigRet << vchSig << vchPubKey;\n@@ -1085,22 +1085,22 @@ bool IsStandard(const CScript& scriptPubKey)\n }\n \n \n-bool IsMine(const CScript& scriptPubKey)\n+bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n {\n     CScript scriptSig;\n-    return Solver(scriptPubKey, 0, 0, scriptSig);\n+    return Solver(keystore, scriptPubKey, 0, 0, scriptSig);\n }\n \n \n-bool ExtractPubKey(const CScript& scriptPubKey, bool fMineOnly, vector<unsigned char>& vchPubKeyRet)\n+bool ExtractPubKey(const CScript& scriptPubKey, const CKeyStore* keystore, vector<unsigned char>& vchPubKeyRet)\n {\n     vchPubKeyRet.clear();\n \n     vector<pair<opcodetype, valtype> > vSolution;\n     if (!Solver(scriptPubKey, vSolution))\n         return false;\n \n-    CRITICAL_BLOCK(cs_mapKeys)\n+    CRITICAL_BLOCK(cs_mapPubKeys)\n     {\n         BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n         {\n@@ -1116,7 +1116,7 @@ bool ExtractPubKey(const CScript& scriptPubKey, bool fMineOnly, vector<unsigned\n                     continue;\n                 vchPubKey = (*mi).second;\n             }\n-            if (!fMineOnly || mapKeys.count(vchPubKey))\n+            if (keystore == NULL || keystore->HaveKey(vchPubKey))\n             {\n                 vchPubKeyRet = vchPubKey;\n                 return true;\n@@ -1160,7 +1160,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n }\n \n \n-bool SignSignature(const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType, CScript scriptPrereq)\n+bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType, CScript scriptPrereq)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n@@ -1171,7 +1171,7 @@ bool SignSignature(const CTransaction& txFrom, CTransaction& txTo, unsigned int\n     // The checksig op will also drop the signatures from its hash.\n     uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType);\n \n-    if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig))\n+    if (!Solver(keystore, txout.scriptPubKey, hash, nHashType, txin.scriptSig))\n         return false;\n \n     txin.scriptSig = scriptPrereq + txin.scriptSig;\n@@ -1199,10 +1199,5 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType))\n         return false;\n \n-    // Anytime a signature is successfully verified, it's proof the outpoint is spent,\n-    // so lets update the wallet spent flag if it doesn't know due to wallet.dat being\n-    // restored from backup or the user making copies of wallet.dat.\n-    WalletUpdateSpent(txin.prevout);\n-\n     return true;\n }"
      },
      {
        "sha": "ae9fdfffa2bd955a3b500dacf27c1dbace274ab7",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -708,12 +708,11 @@ class CScript : public std::vector<unsigned char>\n \n \n \n-uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n bool IsStandard(const CScript& scriptPubKey);\n-bool IsMine(const CScript& scriptPubKey);\n-bool ExtractPubKey(const CScript& scriptPubKey, bool fMineOnly, std::vector<unsigned char>& vchPubKeyRet);\n+bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n+bool ExtractPubKey(const CScript& scriptPubKey, const CKeyStore* pkeystore, std::vector<unsigned char>& vchPubKeyRet);\n bool ExtractHash160(const CScript& scriptPubKey, uint160& hash160Ret);\n-bool SignSignature(const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL, CScript scriptPrereq=CScript());\n+bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL, CScript scriptPrereq=CScript());\n bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType=0);\n \n #endif"
      },
      {
        "sha": "a49741f54f7da1956cf940211e09dba613c0a56a",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 93,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -240,7 +240,7 @@ void SetDefaultReceivingAddress(const string& strAddress)\n             return;\n         if (!mapPubKeys.count(hash160))\n             return;\n-        CWalletDB().WriteDefaultKey(mapPubKeys[hash160]);\n+        CWalletDB(pwalletMain->strWalletFile).WriteDefaultKey(mapPubKeys[hash160]);\n         pframeMain->m_textCtrlAddress->SetValue(strAddress);\n     }\n }\n@@ -290,7 +290,7 @@ CMainFrame::CMainFrame(wxWindow* parent) : CMainFrameBase(parent)\n     dResize = 1.22;\n     SetSize(dResize * GetSize().GetWidth(), 1.15 * GetSize().GetHeight());\n #endif\n-    m_staticTextBalance->SetLabel(FormatMoney(GetBalance()) + \"  \");\n+    m_staticTextBalance->SetLabel(FormatMoney(pwalletMain->GetBalance()) + \"  \");\n     m_listCtrl->SetFocus();\n     ptaskbaricon = new CMyTaskBarIcon();\n #ifdef __WXMAC_OSX__\n@@ -330,7 +330,7 @@ CMainFrame::CMainFrame(wxWindow* parent) : CMainFrameBase(parent)\n \n     // Fill your address text box\n     vector<unsigned char> vchPubKey;\n-    if (CWalletDB(\"r\").ReadDefaultKey(vchPubKey))\n+    if (CWalletDB(pwalletMain->strWalletFile,\"r\").ReadDefaultKey(vchPubKey))\n         m_textCtrlAddress->SetValue(PubKeyToAddress(vchPubKey));\n \n     // Fill listctrl with wallet transactions\n@@ -625,7 +625,7 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n             {\n                 int64 nUnmatured = 0;\n                 BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                    nUnmatured += txout.GetCredit();\n+                    nUnmatured += pwalletMain->GetCredit(txout);\n                 if (wtx.IsInMainChain())\n                 {\n                     strDescription = strprintf(_(\"Generated (%s matures in %d more blocks)\"), FormatMoney(nUnmatured).c_str(), wtx.GetBlocksToMaturity());\n@@ -661,19 +661,19 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n                 return false;\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n             {\n-                if (txout.IsMine())\n+                if (pwalletMain->IsMine(txout))\n                 {\n                     vector<unsigned char> vchPubKey;\n-                    if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))\n+                    if (ExtractPubKey(txout.scriptPubKey, pwalletMain, vchPubKey))\n                     {\n-                        CRITICAL_BLOCK(cs_mapAddressBook)\n+                        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n                         {\n                             //strDescription += _(\"Received payment to \");\n                             //strDescription += _(\"Received with address \");\n                             strDescription += _(\"Received with: \");\n                             string strAddress = PubKeyToAddress(vchPubKey);\n-                            map<string, string>::iterator mi = mapAddressBook.find(strAddress);\n-                            if (mi != mapAddressBook.end() && !(*mi).second.empty())\n+                            map<string, string>::iterator mi = pwalletMain->mapAddressBook.find(strAddress);\n+                            if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.empty())\n                             {\n                                 string strLabel = (*mi).second;\n                                 strDescription += strAddress.substr(0,12) + \"... \";\n@@ -703,11 +703,11 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n     {\n         bool fAllFromMe = true;\n         BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-            fAllFromMe = fAllFromMe && txin.IsMine();\n+            fAllFromMe = fAllFromMe && pwalletMain->IsMine(txin);\n \n         bool fAllToMe = true;\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            fAllToMe = fAllToMe && txout.IsMine();\n+            fAllToMe = fAllToMe && pwalletMain->IsMine(txout);\n \n         if (fAllFromMe && fAllToMe)\n         {\n@@ -733,7 +733,7 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n             for (int nOut = 0; nOut < wtx.vout.size(); nOut++)\n             {\n                 const CTxOut& txout = wtx.vout[nOut];\n-                if (txout.IsMine())\n+                if (pwalletMain->IsMine(txout))\n                     continue;\n \n                 string strAddress;\n@@ -751,9 +751,9 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n                 }\n \n                 string strDescription = _(\"To: \");\n-                CRITICAL_BLOCK(cs_mapAddressBook)\n-                    if (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n-                        strDescription += mapAddressBook[strAddress] + \" \";\n+                CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+                    if (pwalletMain->mapAddressBook.count(strAddress) && !pwalletMain->mapAddressBook[strAddress].empty())\n+                        strDescription += pwalletMain->mapAddressBook[strAddress] + \" \";\n                 strDescription += strAddress;\n                 if (!mapValue[\"message\"].empty())\n                 {\n@@ -792,9 +792,9 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n             //\n             bool fAllMine = true;\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                fAllMine = fAllMine && txout.IsMine();\n+                fAllMine = fAllMine && pwalletMain->IsMine(txout);\n             BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                fAllMine = fAllMine && txin.IsMine();\n+                fAllMine = fAllMine && pwalletMain->IsMine(txin);\n \n             InsertLine(fNew, nIndex, hash, strSort, colour,\n                        strStatus,\n@@ -821,16 +821,16 @@ void CMainFrame::OnIdle(wxIdleEvent& event)\n         // Collect list of wallet transactions and sort newest first\n         bool fEntered = false;\n         vector<pair<unsigned int, uint256> > vSorted;\n-        TRY_CRITICAL_BLOCK(cs_mapWallet)\n+        TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n         {\n             printf(\"RefreshListCtrl starting\\n\");\n             fEntered = true;\n             fRefreshListCtrl = false;\n-            vWalletUpdated.clear();\n+            pwalletMain->vWalletUpdated.clear();\n \n             // Do the newest transactions first\n-            vSorted.reserve(mapWallet.size());\n-            for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+            vSorted.reserve(pwalletMain->mapWallet.size());\n+            for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n             {\n                 const CWalletTx& wtx = (*it).second;\n                 unsigned int nTime = UINT_MAX - wtx.GetTxTime();\n@@ -849,12 +849,12 @@ void CMainFrame::OnIdle(wxIdleEvent& event)\n             if (fShutdown)\n                 return;\n             bool fEntered = false;\n-            TRY_CRITICAL_BLOCK(cs_mapWallet)\n+            TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n             {\n                 fEntered = true;\n                 uint256& hash = vSorted[i++].second;\n-                map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-                if (mi != mapWallet.end())\n+                map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n+                if (mi != pwalletMain->mapWallet.end())\n                     InsertTransaction((*mi).second, true);\n             }\n             if (!fEntered || i == 100 || i % 500 == 0)\n@@ -872,10 +872,10 @@ void CMainFrame::OnIdle(wxIdleEvent& event)\n         static int64 nLastTime;\n         if (GetTime() > nLastTime + 30)\n         {\n-            TRY_CRITICAL_BLOCK(cs_mapWallet)\n+            TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n             {\n                 nLastTime = GetTime();\n-                for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+                for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n                 {\n                     CWalletTx& wtx = (*it).second;\n                     if (wtx.nTimeDisplayed && wtx.nTimeDisplayed != wtx.GetTxTime())\n@@ -896,7 +896,7 @@ void CMainFrame::RefreshStatusColumn()\n     if (nTop == nLastTop && pindexLastBest == pindexBest)\n         return;\n \n-    TRY_CRITICAL_BLOCK(cs_mapWallet)\n+    TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n         int nStart = nTop;\n         int nEnd = min(nStart + 100, m_listCtrl->GetItemCount());\n@@ -916,8 +916,8 @@ void CMainFrame::RefreshStatusColumn()\n         for (int nIndex = nStart; nIndex < min(nEnd, m_listCtrl->GetItemCount()); nIndex++)\n         {\n             uint256 hash((string)GetItemText(m_listCtrl, nIndex, 1));\n-            map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-            if (mi == mapWallet.end())\n+            map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n+            if (mi == pwalletMain->mapWallet.end())\n             {\n                 printf(\"CMainFrame::RefreshStatusColumn() : tx not found in mapWallet\\n\");\n                 continue;\n@@ -1014,41 +1014,41 @@ void CMainFrame::OnPaintListCtrl(wxPaintEvent& event)\n         nLastRepaintTime = GetTimeMillis();\n \n         // Update listctrl contents\n-        if (!vWalletUpdated.empty())\n+        if (!pwalletMain->vWalletUpdated.empty())\n         {\n-            TRY_CRITICAL_BLOCK(cs_mapWallet)\n+            TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n             {\n                 string strTop;\n                 if (m_listCtrl->GetItemCount())\n                     strTop = (string)m_listCtrl->GetItemText(0);\n-                BOOST_FOREACH(uint256 hash, vWalletUpdated)\n+                BOOST_FOREACH(uint256 hash, pwalletMain->vWalletUpdated)\n                 {\n-                    map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-                    if (mi != mapWallet.end())\n+                    map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n+                    if (mi != pwalletMain->mapWallet.end())\n                         InsertTransaction((*mi).second, false);\n                 }\n-                vWalletUpdated.clear();\n+                pwalletMain->vWalletUpdated.clear();\n                 if (m_listCtrl->GetItemCount() && strTop != (string)m_listCtrl->GetItemText(0))\n                     m_listCtrl->ScrollList(0, INT_MIN/2);\n             }\n         }\n \n         // Balance total\n-        TRY_CRITICAL_BLOCK(cs_mapWallet)\n+        TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n         {\n             fPaintedBalance = true;\n-            m_staticTextBalance->SetLabel(FormatMoney(GetBalance()) + \"  \");\n+            m_staticTextBalance->SetLabel(FormatMoney(pwalletMain->GetBalance()) + \"  \");\n \n             // Count hidden and multi-line transactions\n             nTransactionCount = 0;\n-            for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+            for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n             {\n                 CWalletTx& wtx = (*it).second;\n                 nTransactionCount += wtx.nLinesDisplayed;\n             }\n         }\n     }\n-    if (!vWalletUpdated.empty() || !fPaintedBalance)\n+    if (!pwalletMain->vWalletUpdated.empty() || !fPaintedBalance)\n         nNeedRepaint++;\n \n     // Update status column of visible items only\n@@ -1074,7 +1074,7 @@ void CMainFrame::OnPaintListCtrl(wxPaintEvent& event)\n     m_statusBar->SetStatusText(strStatus, 2);\n \n     // Update receiving address\n-    string strDefaultAddress = PubKeyToAddress(vchDefaultKey);\n+    string strDefaultAddress = PubKeyToAddress(pwalletMain->vchDefaultKey);\n     if (m_textCtrlAddress->GetValue() != strDefaultAddress)\n         m_textCtrlAddress->SetValue(strDefaultAddress);\n }\n@@ -1183,10 +1183,10 @@ void CMainFrame::OnButtonNew(wxCommandEvent& event)\n     string strName = dialog.GetValue();\n \n     // Generate new key\n-    string strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+    string strAddress = PubKeyToAddress(pwalletMain->GetKeyFromKeyPool());\n \n     // Save\n-    SetAddressBookName(strAddress, strName);\n+    pwalletMain->SetAddressBookName(strAddress, strName);\n     SetDefaultReceivingAddress(strAddress);\n }\n \n@@ -1204,10 +1204,10 @@ void CMainFrame::OnListItemActivated(wxListEvent& event)\n {\n     uint256 hash((string)GetItemText(m_listCtrl, event.GetIndex(), 1));\n     CWalletTx wtx;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n     {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n-        if (mi == mapWallet.end())\n+        map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n+        if (mi == pwalletMain->mapWallet.end())\n         {\n             printf(\"CMainFrame::OnListItemActivated() : tx not found in mapWallet\\n\");\n             return;\n@@ -1235,7 +1235,7 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n #ifdef __WXMSW__\n     SetSize(nScaleX * GetSize().GetWidth(), nScaleY * GetSize().GetHeight());\n #endif\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n         string strHTML;\n         strHTML.reserve(4000);\n@@ -1285,19 +1285,19 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n                 // Credit\n                 BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n                 {\n-                    if (txout.IsMine())\n+                    if (pwalletMain->IsMine(txout))\n                     {\n                         vector<unsigned char> vchPubKey;\n-                        if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))\n+                        if (ExtractPubKey(txout.scriptPubKey, pwalletMain, vchPubKey))\n                         {\n                             string strAddress = PubKeyToAddress(vchPubKey);\n-                            if (mapAddressBook.count(strAddress))\n+                            if (pwalletMain->mapAddressBook.count(strAddress))\n                             {\n                                 strHTML += string() + _(\"<b>From:</b> \") + _(\"unknown\") + \"<br>\";\n                                 strHTML += _(\"<b>To:</b> \");\n                                 strHTML += HtmlEscape(strAddress);\n-                                if (!mapAddressBook[strAddress].empty())\n-                                    strHTML += _(\" (yours, label: \") + mapAddressBook[strAddress] + \")\";\n+                                if (!pwalletMain->mapAddressBook[strAddress].empty())\n+                                    strHTML += _(\" (yours, label: \") + pwalletMain->mapAddressBook[strAddress] + \")\";\n                                 else\n                                     strHTML += _(\" (yours)\");\n                                 strHTML += \"<br>\";\n@@ -1319,8 +1319,8 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n             // Online transaction\n             strAddress = wtx.mapValue[\"to\"];\n             strHTML += _(\"<b>To:</b> \");\n-            if (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n-                strHTML += mapAddressBook[strAddress] + \" \";\n+            if (pwalletMain->mapAddressBook.count(strAddress) && !pwalletMain->mapAddressBook[strAddress].empty())\n+                strHTML += pwalletMain->mapAddressBook[strAddress] + \" \";\n             strHTML += HtmlEscape(strAddress) + \"<br>\";\n         }\n \n@@ -1335,7 +1335,7 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n             //\n             int64 nUnmatured = 0;\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                nUnmatured += txout.GetCredit();\n+                nUnmatured += pwalletMain->GetCredit(txout);\n             strHTML += _(\"<b>Credit:</b> \");\n             if (wtx.IsInMainChain())\n                 strHTML += strprintf(_(\"(%s matures in %d more blocks)\"), FormatMoney(nUnmatured).c_str(), wtx.GetBlocksToMaturity());\n@@ -1354,11 +1354,11 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n         {\n             bool fAllFromMe = true;\n             BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                fAllFromMe = fAllFromMe && txin.IsMine();\n+                fAllFromMe = fAllFromMe && pwalletMain->IsMine(txin);\n \n             bool fAllToMe = true;\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                fAllToMe = fAllToMe && txout.IsMine();\n+                fAllToMe = fAllToMe && pwalletMain->IsMine(txout);\n \n             if (fAllFromMe)\n             {\n@@ -1367,7 +1367,7 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n                 //\n                 BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n                 {\n-                    if (txout.IsMine())\n+                    if (pwalletMain->IsMine(txout))\n                         continue;\n \n                     if (wtx.mapValue[\"to\"].empty())\n@@ -1378,8 +1378,8 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n                         {\n                             string strAddress = Hash160ToAddress(hash160);\n                             strHTML += _(\"<b>To:</b> \");\n-                            if (mapAddressBook.count(strAddress) && !mapAddressBook[strAddress].empty())\n-                                strHTML += mapAddressBook[strAddress] + \" \";\n+                            if (pwalletMain->mapAddressBook.count(strAddress) && !pwalletMain->mapAddressBook[strAddress].empty())\n+                                strHTML += pwalletMain->mapAddressBook[strAddress] + \" \";\n                             strHTML += strAddress;\n                             strHTML += \"<br>\";\n                         }\n@@ -1407,11 +1407,11 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n                 // Mixed debit transaction\n                 //\n                 BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                    if (txin.IsMine())\n-                        strHTML += _(\"<b>Debit:</b> \") + FormatMoney(-txin.GetDebit()) + \"<br>\";\n+                    if (pwalletMain->IsMine(txin))\n+                        strHTML += _(\"<b>Debit:</b> \") + FormatMoney(-pwalletMain->GetDebit(txin)) + \"<br>\";\n                 BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                    if (txout.IsMine())\n-                        strHTML += _(\"<b>Credit:</b> \") + FormatMoney(txout.GetCredit()) + \"<br>\";\n+                    if (pwalletMain->IsMine(txout))\n+                        strHTML += _(\"<b>Credit:</b> \") + FormatMoney(pwalletMain->GetCredit(txout)) + \"<br>\";\n             }\n         }\n \n@@ -1437,30 +1437,30 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n         {\n             strHTML += \"<hr><br>debug print<br><br>\";\n             BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-                if (txin.IsMine())\n-                    strHTML += \"<b>Debit:</b> \" + FormatMoney(-txin.GetDebit()) + \"<br>\";\n+                if (pwalletMain->IsMine(txin))\n+                    strHTML += \"<b>Debit:</b> \" + FormatMoney(-pwalletMain->GetDebit(txin)) + \"<br>\";\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                if (txout.IsMine())\n-                    strHTML += \"<b>Credit:</b> \" + FormatMoney(txout.GetCredit()) + \"<br>\";\n+                if (pwalletMain->IsMine(txout))\n+                    strHTML += \"<b>Credit:</b> \" + FormatMoney(pwalletMain->GetCredit(txout)) + \"<br>\";\n \n             strHTML += \"<br><b>Transaction:</b><br>\";\n             strHTML += HtmlEscape(wtx.ToString(), true);\n \n             strHTML += \"<br><b>Inputs:</b><br>\";\n-            CRITICAL_BLOCK(cs_mapWallet)\n+            CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n             {\n                 BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n                 {\n                     COutPoint prevout = txin.prevout;\n-                    map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n-                    if (mi != mapWallet.end())\n+                    map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(prevout.hash);\n+                    if (mi != pwalletMain->mapWallet.end())\n                     {\n                         const CWalletTx& prev = (*mi).second;\n                         if (prevout.n < prev.vout.size())\n                         {\n                             strHTML += HtmlEscape(prev.ToString(), true);\n                             strHTML += \" &nbsp;&nbsp; \" + FormatTxStatus(prev) + \", \";\n-                            strHTML = strHTML + \"IsMine=\" + (prev.vout[prevout.n].IsMine() ? \"true\" : \"false\") + \"<br>\";\n+                            strHTML = strHTML + \"IsMine=\" + (pwalletMain->IsMine(prev.vout[prevout.n]) ? \"true\" : \"false\") + \"<br>\";\n                         }\n                     }\n                 }\n@@ -1751,7 +1751,7 @@ void COptionsDialog::OnButtonCancel(wxCommandEvent& event)\n \n void COptionsDialog::OnButtonApply(wxCommandEvent& event)\n {\n-    CWalletDB walletdb;\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n \n     int64 nPrevTransactionFee = nTransactionFee;\n     if (ParseMoney(m_textCtrlTransactionFee->GetValue(), nTransactionFee) && nTransactionFee != nPrevTransactionFee)\n@@ -1928,12 +1928,12 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n             wxMessageBox(_(\"Error in amount  \"), _(\"Send Coins\"));\n             return;\n         }\n-        if (nValue > GetBalance())\n+        if (nValue > pwalletMain->GetBalance())\n         {\n             wxMessageBox(_(\"Amount exceeds your balance  \"), _(\"Send Coins\"));\n             return;\n         }\n-        if (nValue + nTransactionFee > GetBalance())\n+        if (nValue + nTransactionFee > pwalletMain->GetBalance())\n         {\n             wxMessageBox(string(_(\"Total exceeds your balance when the \")) + FormatMoney(nTransactionFee) + _(\" transaction fee is included  \"), _(\"Send Coins\"));\n             return;\n@@ -1951,7 +1951,7 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n                 CScript scriptPubKey;\n                 scriptPubKey << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n \n-                string strError = SendMoney(scriptPubKey, nValue, wtx, true);\n+                string strError = pwalletMain->SendMoney(scriptPubKey, nValue, wtx, true);\n                 if (strError == \"\")\n                     wxMessageBox(_(\"Payment sent  \"), _(\"Sending...\"));\n                 else if (strError == \"ABORTED\")\n@@ -1983,9 +1983,9 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n                 return;\n         }\n \n-        CRITICAL_BLOCK(cs_mapAddressBook)\n-            if (!mapAddressBook.count(strAddress))\n-                SetAddressBookName(strAddress, \"\");\n+        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+            if (!pwalletMain->mapAddressBook.count(strAddress))\n+                pwalletMain->SetAddressBookName(strAddress, \"\");\n \n         EndModal(true);\n     }\n@@ -2169,7 +2169,7 @@ void SendingDialogStartTransfer(void* parg)\n void CSendingDialog::StartTransfer()\n {\n     // Make sure we have enough money\n-    if (nPrice + nTransactionFee > GetBalance())\n+    if (nPrice + nTransactionFee > pwalletMain->GetBalance())\n     {\n         Error(_(\"Insufficient funds\"));\n         return;\n@@ -2240,16 +2240,16 @@ void CSendingDialog::OnReply2(CDataStream& vRecv)\n         // Pay\n         if (!Status(_(\"Creating transaction...\")))\n             return;\n-        if (nPrice + nTransactionFee > GetBalance())\n+        if (nPrice + nTransactionFee > pwalletMain->GetBalance())\n         {\n             Error(_(\"Insufficient funds\"));\n             return;\n         }\n-        CReserveKey reservekey;\n+        CReserveKey reservekey(pwalletMain);\n         int64 nFeeRequired;\n-        if (!CreateTransaction(scriptPubKey, nPrice, wtx, reservekey, nFeeRequired))\n+        if (!pwalletMain->CreateTransaction(scriptPubKey, nPrice, wtx, reservekey, nFeeRequired))\n         {\n-            if (nPrice + nFeeRequired > GetBalance())\n+            if (nPrice + nFeeRequired > pwalletMain->GetBalance())\n                 Error(strprintf(_(\"This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds\"), FormatMoney(nFeeRequired).c_str()));\n             else\n                 Error(_(\"Transaction creation failed\"));\n@@ -2287,7 +2287,7 @@ void CSendingDialog::OnReply2(CDataStream& vRecv)\n             return;\n \n         // Commit\n-        if (!CommitTransaction(wtx, reservekey))\n+        if (!pwalletMain->CommitTransaction(wtx, reservekey))\n         {\n             Error(_(\"The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n             return;\n@@ -2381,11 +2381,11 @@ CAddressBookDialog::CAddressBookDialog(wxWindow* parent, const wxString& strInit\n     m_listCtrlReceiving->SetFocus();\n \n     // Fill listctrl with address book data\n-    CRITICAL_BLOCK(cs_mapKeys)\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapKeys)\n+    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n         string strDefaultReceiving = (string)pframeMain->m_textCtrlAddress->GetValue();\n-        BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapAddressBook)\n+        BOOST_FOREACH(const PAIRTYPE(string, string)& item, pwalletMain->mapAddressBook)\n         {\n             string strAddress = item.first;\n             string strName = item.second;\n@@ -2444,7 +2444,7 @@ void CAddressBookDialog::OnListEndLabelEdit(wxListEvent& event)\n     if (event.IsEditCancelled())\n         return;\n     string strAddress = (string)GetItemText(m_listCtrl, event.GetIndex(), 1);\n-    SetAddressBookName(strAddress, string(event.GetText()));\n+    pwalletMain->SetAddressBookName(strAddress, string(event.GetText()));\n     pframeMain->RefreshListCtrl();\n }\n \n@@ -2479,7 +2479,7 @@ void CAddressBookDialog::OnButtonDelete(wxCommandEvent& event)\n         if (m_listCtrl->GetItemState(nIndex, wxLIST_STATE_SELECTED))\n         {\n             string strAddress = (string)GetItemText(m_listCtrl, nIndex, 1);\n-            CWalletDB().EraseName(strAddress);\n+            CWalletDB(pwalletMain->strWalletFile).EraseName(strAddress);\n             m_listCtrl->DeleteItem(nIndex);\n         }\n     }\n@@ -2539,8 +2539,8 @@ void CAddressBookDialog::OnButtonEdit(wxCommandEvent& event)\n \n     // Write back\n     if (strAddress != strAddressOrg)\n-        CWalletDB().EraseName(strAddressOrg);\n-    SetAddressBookName(strAddress, strName);\n+        CWalletDB(pwalletMain->strWalletFile).EraseName(strAddressOrg);\n+    pwalletMain->SetAddressBookName(strAddress, strName);\n     m_listCtrl->SetItem(nIndex, 1, strAddress);\n     m_listCtrl->SetItemText(nIndex, strName);\n     pframeMain->RefreshListCtrl();\n@@ -2576,11 +2576,11 @@ void CAddressBookDialog::OnButtonNew(wxCommandEvent& event)\n         strName = dialog.GetValue();\n \n         // Generate new key\n-        strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+        strAddress = PubKeyToAddress(pwalletMain->GetKeyFromKeyPool());\n     }\n \n     // Add to list and select it\n-    SetAddressBookName(strAddress, strName);\n+    pwalletMain->SetAddressBookName(strAddress, strName);\n     int nIndex = InsertLine(m_listCtrl, strName, strAddress);\n     SetSelection(m_listCtrl, nIndex);\n     m_listCtrl->SetFocus();"
      },
      {
        "sha": "aef8d180e4f6450e5dbf3e6552f9bde821ef1d05",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 170,
        "deletions": 103,
        "changes": 273,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -15,36 +15,48 @@ using namespace std;\n // mapWallet\n //\n \n-void WalletUpdateSpent(const COutPoint& prevout)\n+bool CWallet::AddKey(const CKey& key)\n+{\n+    this->CKeyStore::AddKey(key);\n+    if (!fFileBacked)\n+        return true;\n+    return CWalletDB(strWalletFile).WriteKey(key.GetPubKey(), key.GetPrivKey());\n+}\n+\n+void CWallet::WalletUpdateSpent(const CTransaction &tx)\n {\n     // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n     // Update the wallet spent flag if it doesn't know due to wallet.dat being\n     // restored from backup or the user making copies of wallet.dat.\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n-        if (mi != mapWallet.end())\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         {\n-            CWalletTx& wtx = (*mi).second;\n-            if (!wtx.IsSpent(prevout.n) && wtx.vout[prevout.n].IsMine())\n+            map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n+            if (mi != mapWallet.end())\n             {\n-                printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n-                wtx.MarkSpent(prevout.n);\n-                wtx.WriteToDisk();\n-                vWalletUpdated.push_back(prevout.hash);\n+                CWalletTx& wtx = (*mi).second;\n+                if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n+                {\n+                    printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                    wtx.MarkSpent(txin.prevout.n);\n+                    wtx.WriteToDisk();\n+                    vWalletUpdated.push_back(txin.prevout.hash);\n+                }\n             }\n         }\n     }\n }\n \n-bool AddToWallet(const CWalletTx& wtxIn)\n+bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n {\n     uint256 hash = wtxIn.GetHash();\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n         // Inserts only if not already there, returns tx inserted or tx found\n         pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n         CWalletTx& wtx = (*ret.first).second;\n+        wtx.pwallet = this;\n         bool fInsertedNew = ret.second;\n         if (fInsertedNew)\n             wtx.nTimeReceived = GetAdjustedTime();\n@@ -87,7 +99,9 @@ bool AddToWallet(const CWalletTx& wtxIn)\n         {\n             if (txout.scriptPubKey == scriptDefaultKey)\n             {\n-                CWalletDB walletdb;\n+                if (!fFileBacked)\n+                    continue;\n+                CWalletDB walletdb(strWalletFile);\n                 vchDefaultKey = GetKeyFromKeyPool();\n                 walletdb.WriteDefaultKey(vchDefaultKey);\n                 walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n@@ -96,67 +110,74 @@ bool AddToWallet(const CWalletTx& wtxIn)\n \n         // Notify UI\n         vWalletUpdated.push_back(hash);\n+\n+        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n+        WalletUpdateSpent(wtx);\n     }\n \n     // Refresh UI\n     MainFrameRepaint();\n     return true;\n }\n \n-bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n+bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n {\n     uint256 hash = tx.GetHash();\n     bool fExisted = mapWallet.count(hash);\n     if (fExisted && !fUpdate) return false;\n-    if (fExisted || tx.IsMine() || tx.IsFromMe())\n+    if (fExisted || IsMine(tx) || IsFromMe(tx))\n     {\n-        CWalletTx wtx(tx);\n+        CWalletTx wtx(this,tx);\n         // Get merkle branch if transaction was found in a block\n         if (pblock)\n             wtx.SetMerkleBranch(pblock);\n         return AddToWallet(wtx);\n     }\n+    else\n+        WalletUpdateSpent(tx);\n     return false;\n }\n \n-bool EraseFromWallet(uint256 hash)\n+bool CWallet::EraseFromWallet(uint256 hash)\n {\n+    if (!fFileBacked)\n+        return false;\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n         if (mapWallet.erase(hash))\n-            CWalletDB().EraseTx(hash);\n+            CWalletDB(strWalletFile).EraseTx(hash);\n     }\n     return true;\n }\n \n \n-bool CTxIn::IsMine() const\n+bool CWallet::IsMine(const CTxIn &txin) const\n {\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n+        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n             const CWalletTx& prev = (*mi).second;\n-            if (prevout.n < prev.vout.size())\n-                if (prev.vout[prevout.n].IsMine())\n+            if (txin.prevout.n < prev.vout.size())\n+                if (IsMine(prev.vout[txin.prevout.n]))\n                     return true;\n         }\n     }\n     return false;\n }\n \n-int64 CTxIn::GetDebit() const\n+int64 CWallet::GetDebit(const CTxIn &txin) const\n {\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n-        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);\n+        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n             const CWalletTx& prev = (*mi).second;\n-            if (prevout.n < prev.vout.size())\n-                if (prev.vout[prevout.n].IsMine())\n-                    return prev.vout[prevout.n].nValue;\n+            if (txin.prevout.n < prev.vout.size())\n+                if (IsMine(prev.vout[txin.prevout.n]))\n+                    return prev.vout[txin.prevout.n].nValue;\n         }\n     }\n     return 0;\n@@ -184,31 +205,31 @@ int CWalletTx::GetRequestCount() const\n {\n     // Returns -1 if it wasn't being tracked\n     int nRequests = -1;\n-    CRITICAL_BLOCK(cs_mapRequestCount)\n+    CRITICAL_BLOCK(pwallet->cs_mapRequestCount)\n     {\n         if (IsCoinBase())\n         {\n             // Generated block\n             if (hashBlock != 0)\n             {\n-                map<uint256, int>::iterator mi = mapRequestCount.find(hashBlock);\n-                if (mi != mapRequestCount.end())\n+                map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n+                if (mi != pwallet->mapRequestCount.end())\n                     nRequests = (*mi).second;\n             }\n         }\n         else\n         {\n             // Did anyone request this transaction?\n-            map<uint256, int>::iterator mi = mapRequestCount.find(GetHash());\n-            if (mi != mapRequestCount.end())\n+            map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n+            if (mi != pwallet->mapRequestCount.end())\n             {\n                 nRequests = (*mi).second;\n \n                 // How about the block it's in?\n                 if (nRequests == 0 && hashBlock != 0)\n                 {\n-                    map<uint256, int>::iterator mi = mapRequestCount.find(hashBlock);\n-                    if (mi != mapRequestCount.end())\n+                    map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n+                    if (mi != pwallet->mapRequestCount.end())\n                         nRequests = (*mi).second;\n                     else\n                         nRequests = 1; // If it's in someone else's block it must have got out\n@@ -230,7 +251,7 @@ void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, l\n     if (IsCoinBase())\n     {\n         if (GetBlocksToMaturity() > 0)\n-            nGeneratedImmature = CTransaction::GetCredit();\n+            nGeneratedImmature = pwallet->GetCredit(*this);\n         else\n             nGeneratedMature = GetCredit();\n         return;\n@@ -263,13 +284,13 @@ void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, l\n         }\n \n         // Don't report 'change' txouts\n-        if (nDebit > 0 && txout.IsChange())\n+        if (nDebit > 0 && pwallet->IsChange(txout))\n             continue;\n \n         if (nDebit > 0)\n             listSent.push_back(make_pair(address, txout.nValue));\n \n-        if (txout.IsMine())\n+        if (pwallet->IsMine(txout))\n             listReceived.push_back(make_pair(address, txout.nValue));\n     }\n \n@@ -295,16 +316,15 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, i\n             nSent += s.second;\n         nFee = allFee;\n     }\n-    CRITICAL_BLOCK(cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwallet->cs_mapAddressBook)\n     {\n         BOOST_FOREACH(const PAIRTYPE(string,int64)& r, listReceived)\n         {\n-            if (mapAddressBook.count(r.first))\n+            if (pwallet->mapAddressBook.count(r.first))\n             {\n-                if (mapAddressBook[r.first] == strAccount)\n-                {\n+                map<string, string>::const_iterator mi = pwallet->mapAddressBook.find(r.first);\n+                if (mi != pwallet->mapAddressBook.end() && (*mi).second == strAccount)\n                     nReceived += r.second;\n-                }\n             }\n             else if (strAccount.empty())\n             {\n@@ -326,7 +346,7 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n             vWorkQueue.push_back(txin.prevout.hash);\n \n         // This critsect is OK because txdb is already open\n-        CRITICAL_BLOCK(cs_mapWallet)\n+        CRITICAL_BLOCK(pwallet->cs_mapWallet)\n         {\n             map<uint256, const CMerkleTx*> mapWalletPrev;\n             set<uint256> setAlreadyDone;\n@@ -338,10 +358,11 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n                 setAlreadyDone.insert(hash);\n \n                 CMerkleTx tx;\n-                if (mapWallet.count(hash))\n+                map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n+                if (mi != pwallet->mapWallet.end())\n                 {\n-                    tx = mapWallet[hash];\n-                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, mapWallet[hash].vtxPrev)\n+                    tx = (*mi).second;\n+                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                         mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                 }\n                 else if (mapWalletPrev.count(hash))\n@@ -373,10 +394,10 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n \n bool CWalletTx::WriteToDisk()\n {\n-    return CWalletDB().WriteTx(GetHash(), *this);\n+    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n }\n \n-int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n+int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n {\n     int ret = 0;\n \n@@ -398,7 +419,7 @@ int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n     return ret;\n }\n \n-void ReacceptWalletTransactions()\n+void CWallet::ReacceptWalletTransactions()\n {\n     CTxDB txdb(\"r\");\n     bool fRepeat = true;\n@@ -426,7 +447,7 @@ void ReacceptWalletTransactions()\n                 {\n                     if (wtx.IsSpent(i))\n                         continue;\n-                    if (!txindex.vSpent[i].IsNull() && wtx.vout[i].IsMine())\n+                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                     {\n                         wtx.MarkSpent(i);\n                         fUpdated = true;\n@@ -484,7 +505,7 @@ void CWalletTx::RelayWalletTransaction()\n    RelayWalletTransaction(txdb);\n }\n \n-void ResendWalletTransactions()\n+void CWallet::ResendWalletTransactions()\n {\n     // Do this infrequently and randomly to avoid giving away\n     // that these are our transactions.\n@@ -536,16 +557,16 @@ void ResendWalletTransactions()\n //\n \n \n-int64 GetBalance()\n+int64 CWallet::GetBalance() const\n {\n     int64 nStart = GetTimeMillis();\n \n     int64 nTotal = 0;\n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n-            CWalletTx* pcoin = &(*it).second;\n+            const CWalletTx* pcoin = &(*it).second;\n             if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n                 continue;\n             nTotal += pcoin->GetAvailableCredit();\n@@ -557,27 +578,27 @@ int64 GetBalance()\n }\n \n \n-bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet)\n+bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n     // List of values less than target\n-    pair<int64, pair<CWalletTx*,unsigned int> > coinLowestLarger;\n+    pair<int64, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n     coinLowestLarger.first = INT64_MAX;\n     coinLowestLarger.second.first = NULL;\n-    vector<pair<int64, pair<CWalletTx*,unsigned int> > > vValue;\n+    vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n     int64 nTotalLower = 0;\n \n     CRITICAL_BLOCK(cs_mapWallet)\n     {\n-       vector<CWalletTx*> vCoins;\n+       vector<const CWalletTx*> vCoins;\n        vCoins.reserve(mapWallet.size());\n-       for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+       for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n            vCoins.push_back(&(*it).second);\n        random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n \n-       BOOST_FOREACH(CWalletTx* pcoin, vCoins)\n+       BOOST_FOREACH(const CWalletTx* pcoin, vCoins)\n        {\n             if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n                 continue;\n@@ -591,15 +612,15 @@ bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<\n \n             for (int i = 0; i < pcoin->vout.size(); i++)\n             {\n-                if (pcoin->IsSpent(i) || !pcoin->vout[i].IsMine())\n+                if (pcoin->IsSpent(i) || !IsMine(pcoin->vout[i]))\n                     continue;\n \n                 int64 n = pcoin->vout[i].nValue;\n \n                 if (n <= 0)\n                     continue;\n \n-                pair<int64,pair<CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n+                pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n \n                 if (n == nTargetValue)\n                 {\n@@ -702,7 +723,7 @@ bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<\n     return true;\n }\n \n-bool SelectCoins(int64 nTargetValue, set<pair<CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet)\n+bool CWallet::SelectCoins(int64 nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n     return (SelectCoinsMinConf(nTargetValue, 1, 6, setCoinsRet, nValueRet) ||\n             SelectCoinsMinConf(nTargetValue, 1, 1, setCoinsRet, nValueRet) ||\n@@ -712,7 +733,7 @@ bool SelectCoins(int64 nTargetValue, set<pair<CWalletTx*,unsigned int> >& setCoi\n \n \n \n-bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n+bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n {\n     int64 nValue = 0;\n     BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n@@ -724,6 +745,8 @@ bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx&\n     if (vecSend.empty() || nValue < 0)\n         return false;\n \n+    wtxNew.pwallet = this;\n+\n     CRITICAL_BLOCK(cs_main)\n     {\n         // txdb must be opened before the mapWallet lock\n@@ -744,11 +767,11 @@ bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx&\n                     wtxNew.vout.push_back(CTxOut(s.second, s.first));\n \n                 // Choose coins to use\n-                set<pair<CWalletTx*,unsigned int> > setCoins;\n+                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                 int64 nValueIn = 0;\n                 if (!SelectCoins(nTotalValue, setCoins, nValueIn))\n                     return false;\n-                BOOST_FOREACH(PAIRTYPE(CWalletTx*, unsigned int) pcoin, setCoins)\n+                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                 {\n                     int64 nCredit = pcoin.first->vout[pcoin.second].nValue;\n                     dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n@@ -784,13 +807,13 @@ bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx&\n                     reservekey.ReturnKey();\n \n                 // Fill vin\n-                BOOST_FOREACH(const PAIRTYPE(CWalletTx*,unsigned int)& coin, setCoins)\n+                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                     wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n \n                 // Sign\n                 int nIn = 0;\n-                BOOST_FOREACH(const PAIRTYPE(CWalletTx*,unsigned int)& coin, setCoins)\n-                    if (!SignSignature(*coin.first, wtxNew, nIn++))\n+                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n+                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                         return false;\n \n                 // Limit size\n@@ -820,15 +843,15 @@ bool CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx&\n     return true;\n }\n \n-bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n+bool CWallet::CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet)\n {\n     vector< pair<CScript, int64> > vecSend;\n     vecSend.push_back(make_pair(scriptPubKey, nValue));\n     return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet);\n }\n \n // Call after CreateTransaction unless you want to abort\n-bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n+bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n {\n     CRITICAL_BLOCK(cs_main)\n     {\n@@ -838,7 +861,7 @@ bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n             // This is only to keep the database open to defeat the auto-flush for the\n             // duration of this scope.  This is the only place where this optimization\n             // maybe makes sense; please don't do it anywhere else.\n-            CWalletDB walletdb(\"r\");\n+            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n \n             // Take key pair from key pool so it won't be used again\n             reservekey.KeepKey();\n@@ -851,11 +874,15 @@ bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n             set<CWalletTx*> setCoins;\n             BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n             {\n-                CWalletTx &pcoin = mapWallet[txin.prevout.hash];\n-                pcoin.MarkSpent(txin.prevout.n);\n-                pcoin.WriteToDisk();\n-                vWalletUpdated.push_back(pcoin.GetHash());\n+                CWalletTx &coin = mapWallet[txin.prevout.hash];\n+                coin.pwallet = this;\n+                coin.MarkSpent(txin.prevout.n);\n+                coin.WriteToDisk();\n+                vWalletUpdated.push_back(coin.GetHash());\n             }\n+\n+            if (fFileBacked)\n+                delete pwalletdb;\n         }\n \n         // Track how many getdata requests our transaction gets\n@@ -879,9 +906,9 @@ bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n \n \n // requires cs_main lock\n-string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n+string CWallet::SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n {\n-    CReserveKey reservekey;\n+    CReserveKey reservekey(this);\n     int64 nFeeRequired;\n     if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n     {\n@@ -907,7 +934,7 @@ string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAs\n \n \n // requires cs_main lock\n-string SendMoneyToBitcoinAddress(string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n+string CWallet::SendMoneyToBitcoinAddress(string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n {\n     // Check amount\n     if (nValue <= 0)\n@@ -926,10 +953,12 @@ string SendMoneyToBitcoinAddress(string strAddress, int64 nValue, CWalletTx& wtx\n \n \n \n-bool LoadWallet(bool& fFirstRunRet)\n+bool CWallet::LoadWallet(bool& fFirstRunRet)\n {\n+    if (!fFileBacked)\n+        return false;\n     fFirstRunRet = false;\n-    if (!CWalletDB(\"cr+\").LoadWallet())\n+    if (!CWalletDB(strWalletFile,\"cr+\").LoadWallet(this))\n         return false;\n     fFirstRunRet = vchDefaultKey.empty();\n \n@@ -944,32 +973,69 @@ bool LoadWallet(bool& fFirstRunRet)\n         // Create new keyUser and set as default key\n         RandAddSeedPerfmon();\n \n-        CWalletDB walletdb;\n         vchDefaultKey = GetKeyFromKeyPool();\n-        walletdb.WriteDefaultKey(vchDefaultKey);\n-        walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n+        if (!SetAddressBookName(PubKeyToAddress(vchDefaultKey), \"\"))\n+            return false;\n+        CWalletDB(strWalletFile).WriteDefaultKey(keyUser.GetPubKey());\n     }\n \n-    CreateThread(ThreadFlushWalletDB, NULL);\n+    CreateThread(ThreadFlushWalletDB, &strWalletFile);\n     return true;\n }\n \n-void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n+void CWallet::PrintWallet(const CBlock& block)\n+{\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        if (mapWallet.count(block.vtx[0].GetHash()))\n+        {\n+            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n+            printf(\"    mine:  %d  %d  %d\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n+        }\n+    }\n+    printf(\"\\n\");\n+}\n+\n+bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n+{\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    {\n+        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n+        if (mi != mapWallet.end())\n+        {\n+            wtx = (*mi).second;\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n+\n+bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n+{\n+    if (!pwallet->fFileBacked)\n+        return false;\n+    strWalletFileOut = pwallet->strWalletFile;\n+    return true;\n+}\n+\n+void CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n {\n     nIndex = -1;\n     keypool.vchPubKey.clear();\n     CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_mapWallet)\n     CRITICAL_BLOCK(cs_setKeyPool)\n     {\n+        CWalletDB walletdb(strWalletFile);\n+\n         // Top up key pool\n         int64 nTargetSize = max(GetArg(\"-keypool\", 100), (int64)0);\n         while (setKeyPool.size() < nTargetSize+1)\n         {\n             int64 nEnd = 1;\n             if (!setKeyPool.empty())\n                 nEnd = *(--setKeyPool.end()) + 1;\n-            if (!Write(make_pair(string(\"pool\"), nEnd), CKeyPool(GenerateNewKey())))\n+            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                 throw runtime_error(\"ReserveKeyFromKeyPool() : writing generated key failed\");\n             setKeyPool.insert(nEnd);\n             printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n@@ -979,7 +1045,7 @@ void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n         assert(!setKeyPool.empty());\n         nIndex = *(setKeyPool.begin());\n         setKeyPool.erase(setKeyPool.begin());\n-        if (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n+        if (!walletdb.ReadPool(nIndex, keypool))\n             throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n         if (!mapKeys.count(keypool.vchPubKey))\n             throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n@@ -988,51 +1054,52 @@ void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n     }\n }\n \n-void CWalletDB::KeepKey(int64 nIndex)\n+void CWallet::KeepKey(int64 nIndex)\n {\n     // Remove from key pool\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    if (fFileBacked)\n     {\n-        Erase(make_pair(string(\"pool\"), nIndex));\n+        CWalletDB walletdb(strWalletFile);\n+        CRITICAL_BLOCK(cs_main)\n+        {\n+            walletdb.ErasePool(nIndex);\n+        }\n     }\n     printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n }\n \n-void CWalletDB::ReturnKey(int64 nIndex)\n+void CWallet::ReturnKey(int64 nIndex)\n {\n     // Return to key pool\n     CRITICAL_BLOCK(cs_setKeyPool)\n         setKeyPool.insert(nIndex);\n     printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n }\n \n-vector<unsigned char> GetKeyFromKeyPool()\n+vector<unsigned char> CWallet::GetKeyFromKeyPool()\n {\n-    CWalletDB walletdb;\n     int64 nIndex = 0;\n     CKeyPool keypool;\n-    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n-    walletdb.KeepKey(nIndex);\n+    ReserveKeyFromKeyPool(nIndex, keypool);\n+    KeepKey(nIndex);\n     return keypool.vchPubKey;\n }\n \n-int64 GetOldestKeyPoolTime()\n+int64 CWallet::GetOldestKeyPoolTime()\n {\n-    CWalletDB walletdb;\n     int64 nIndex = 0;\n     CKeyPool keypool;\n-    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n-    walletdb.ReturnKey(nIndex);\n+    ReserveKeyFromKeyPool(nIndex, keypool);\n+    ReturnKey(nIndex);\n     return keypool.nTime;\n }\n \n-std::vector<unsigned char> CReserveKey::GetReservedKey()\n+vector<unsigned char> CReserveKey::GetReservedKey()\n {\n     if (nIndex == -1)\n     {\n         CKeyPool keypool;\n-        CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n+        pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n         vchPubKey = keypool.vchPubKey;\n     }\n     assert(!vchPubKey.empty());\n@@ -1042,15 +1109,15 @@ std::vector<unsigned char> CReserveKey::GetReservedKey()\n void CReserveKey::KeepKey()\n {\n     if (nIndex != -1)\n-        CWalletDB().KeepKey(nIndex);\n+        pwallet->KeepKey(nIndex);\n     nIndex = -1;\n     vchPubKey.clear();\n }\n \n void CReserveKey::ReturnKey()\n {\n     if (nIndex != -1)\n-        CWalletDB::ReturnKey(nIndex);\n+        pwallet->ReturnKey(nIndex);\n     nIndex = -1;\n     vchPubKey.clear();\n }"
      },
      {
        "sha": "b14a2e8264296e29350c3b2eddb231541bbaec78",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 211,
        "deletions": 37,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=64c7ee7e6b9c059d99aaa493c74a6703c6b0fc80",
        "patch": "@@ -5,40 +5,205 @@\n #define BITCOIN_WALLET_H\n \n #include \"bignum.h\"\n+#include \"key.h\"\n #include \"script.h\"\n \n class CWalletTx;\n class CReserveKey;\n class CWalletDB;\n \n-extern std::map<uint256, CWalletTx> mapWallet;\n-extern std::vector<uint256> vWalletUpdated;\n-extern CCriticalSection cs_mapWallet;\n+class CWallet : public CKeyStore\n+{\n+private:\n+    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+    bool SelectCoins(int64 nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n-extern std::map<uint256, int> mapRequestCount;\n-extern CCriticalSection cs_mapRequestCount;\n \n-extern std::map<std::string, std::string> mapAddressBook;\n-extern CCriticalSection cs_mapAddressBook;\n+public:\n+    bool fFileBacked;\n+    std::string strWalletFile;\n \n-extern std::vector<unsigned char> vchDefaultKey;\n-extern CKey keyUser;\n+    std::set<int64> setKeyPool;\n+    CCriticalSection cs_setKeyPool;\n \n-bool AddToWallet(const CWalletTx& wtxIn);\n-bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false);\n-bool EraseFromWallet(uint256 hash);\n-void WalletUpdateSpent(const COutPoint& prevout);\n-int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n-void ReacceptWalletTransactions();\n-void ResendWalletTransactions();\n-int64 GetBalance();\n-bool CreateTransaction(const std::vector<std::pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n-bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n-bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n-bool BroadcastTransaction(CWalletTx& wtxNew);\n-std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n-std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+    CWallet()\n+    {\n+        fFileBacked = false;\n+    }\n+    CWallet(std::string strWalletFileIn)\n+    {\n+        strWalletFile = strWalletFileIn;\n+        fFileBacked = true;\n+    }\n \n+    mutable CCriticalSection cs_mapWallet;\n+    std::map<uint256, CWalletTx> mapWallet;\n+    std::vector<uint256> vWalletUpdated;\n+\n+    std::map<uint256, int> mapRequestCount;\n+    mutable CCriticalSection cs_mapRequestCount;\n+\n+    std::map<std::string, std::string> mapAddressBook;\n+    mutable CCriticalSection cs_mapAddressBook;\n+\n+    std::vector<unsigned char> vchDefaultKey;\n+    CKey keyUser;\n+\n+    bool AddKey(const CKey& key);\n+    bool AddToWallet(const CWalletTx& wtxIn);\n+    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false);\n+    bool EraseFromWallet(uint256 hash);\n+    void WalletUpdateSpent(const CTransaction& prevout);\n+    int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n+    void ReacceptWalletTransactions();\n+    void ResendWalletTransactions();\n+    int64 GetBalance() const;\n+    bool CreateTransaction(const std::vector<std::pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n+    bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet);\n+    bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n+    bool BroadcastTransaction(CWalletTx& wtxNew);\n+    std::string SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+    std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWalletTx& wtxNew, bool fAskFee=false);\n+\n+    void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);\n+    void KeepKey(int64 nIndex);\n+    void ReturnKey(int64 nIndex);\n+    std::vector<unsigned char> GetKeyFromKeyPool();\n+    int64 GetOldestKeyPoolTime();\n+\n+    bool IsMine(const CTxIn& txin) const;\n+    int64 GetDebit(const CTxIn& txin) const;\n+    bool IsMine(const CTxOut& txout) const\n+    {\n+        return ::IsMine(*this, txout.scriptPubKey);\n+    }\n+    int64 GetCredit(const CTxOut& txout) const\n+    {\n+        if (!MoneyRange(txout.nValue))\n+            throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n+        return (IsMine(txout) ? txout.nValue : 0);\n+    }\n+    bool IsChange(const CTxOut& txout) const\n+    {\n+        std::vector<unsigned char> vchPubKey;\n+        if (ExtractPubKey(txout.scriptPubKey, this, vchPubKey))\n+            CRITICAL_BLOCK(cs_mapAddressBook)\n+                if (!mapAddressBook.count(PubKeyToAddress(vchPubKey)))\n+                    return true;\n+        return false;\n+    }\n+    int64 GetChange(const CTxOut& txout) const\n+    {\n+        if (!MoneyRange(txout.nValue))\n+            throw std::runtime_error(\"CWallet::GetChange() : value out of range\");\n+        if (IsChange(txout) ? txout.nValue : 0);\n+    }\n+    bool IsMine(const CTransaction& tx) const\n+    {\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+            if (IsMine(txout))\n+                return true;\n+        return false;\n+    }\n+    bool IsFromMe(const CTransaction& tx) const\n+    {\n+        return (GetDebit(tx) > 0);\n+    }\n+    int64 GetDebit(const CTransaction& tx) const\n+    {\n+        int64 nDebit = 0;\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            nDebit += GetDebit(txin);\n+            if (!MoneyRange(nDebit))\n+                throw std::runtime_error(\"CWallet::GetDebit() : value out of range\");\n+        }\n+        return nDebit;\n+    }\n+    int64 GetCredit(const CTransaction& tx) const\n+    {\n+        int64 nCredit = 0;\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        {\n+            nCredit += GetCredit(txout);\n+            if (!MoneyRange(nCredit))\n+                throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n+        }\n+        return nCredit;\n+    }\n+    int64 GetChange(const CTransaction& tx) const\n+    {\n+        int64 nChange = 0;\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        {\n+            nChange += GetChange(txout);\n+            if (!MoneyRange(nChange))\n+                throw std::runtime_error(\"CWallet::GetChange() : value out of range\");\n+        }\n+        return nChange;\n+    }\n+    void SetBestChain(const CBlockLocator& loc)\n+    {\n+        CWalletDB walletdb(strWalletFile);\n+        walletdb.WriteBestBlock(loc);\n+    }\n+\n+    bool LoadWallet(bool& fFirstRunRet);\n+//    bool BackupWallet(const std::string& strDest);\n+\n+    bool SetAddressBookName(const std::string& strAddress, const std::string& strName)\n+    {\n+        if (!fFileBacked)\n+            return false;\n+        return CWalletDB(strWalletFile).WriteName(strAddress, strName);\n+    }\n+\n+    void UpdatedTransaction(const uint256 &hashTx)\n+    {\n+        CRITICAL_BLOCK(cs_mapWallet)\n+            vWalletUpdated.push_back(hashTx);\n+    }\n+\n+    void PrintWallet(const CBlock& block);\n+\n+    void Inventory(const uint256 &hash)\n+    {\n+        CRITICAL_BLOCK(cs_mapRequestCount)\n+        {\n+            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n+            if (mi != mapRequestCount.end())\n+                (*mi).second++;\n+        }\n+    }\n+\n+    bool GetTransaction(const uint256 &hashTx, CWalletTx& wtx);\n+\n+};\n+\n+\n+class CReserveKey\n+{\n+protected:\n+    CWallet* pwallet;\n+    int64 nIndex;\n+    std::vector<unsigned char> vchPubKey;\n+public:\n+    CReserveKey(CWallet* pwalletIn)\n+    {\n+        nIndex = -1;\n+        pwallet = pwalletIn;\n+    }\n+\n+    ~CReserveKey()\n+    {\n+        if (!fShutdown)\n+            ReturnKey();\n+    }\n+\n+    void ReturnKey();\n+    std::vector<unsigned char> GetReservedKey();\n+    void KeepKey();\n+};\n \n \n //\n@@ -49,6 +214,8 @@ std::string SendMoneyToBitcoinAddress(std::string strAddress, int64 nValue, CWal\n class CWalletTx : public CMerkleTx\n {\n public:\n+    const CWallet* pwallet;\n+\n     std::vector<CMerkleTx> vtxPrev;\n     std::map<std::string, std::string> mapValue;\n     std::vector<std::pair<std::string, std::string> > vOrderForm;\n@@ -73,24 +240,29 @@ class CWalletTx : public CMerkleTx\n     mutable int nLinesDisplayed;\n     mutable char fConfirmedDisplayed;\n \n-\n     CWalletTx()\n     {\n-        Init();\n+        Init(NULL);\n     }\n \n-    CWalletTx(const CMerkleTx& txIn) : CMerkleTx(txIn)\n+    CWalletTx(const CWallet* pwalletIn)\n     {\n-        Init();\n+        Init(pwalletIn);\n     }\n \n-    CWalletTx(const CTransaction& txIn) : CMerkleTx(txIn)\n+    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n     {\n-        Init();\n+        Init(pwalletIn);\n     }\n \n-    void Init()\n+    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n     {\n+        Init(pwalletIn);\n+    }\n+\n+    void Init(const CWallet* pwalletIn)\n+    {\n+        pwallet = pwalletIn;\n         vtxPrev.clear();\n         mapValue.clear();\n         vOrderForm.clear();\n@@ -116,7 +288,7 @@ class CWalletTx : public CMerkleTx\n     (\n         CWalletTx* pthis = const_cast<CWalletTx*>(this);\n         if (fRead)\n-            pthis->Init();\n+            pthis->Init(NULL);\n         char fSpent = false;\n \n         if (!fRead)\n@@ -213,7 +385,7 @@ class CWalletTx : public CMerkleTx\n             return 0;\n         if (fDebitCached)\n             return nDebitCached;\n-        nDebitCached = CTransaction::GetDebit();\n+        nDebitCached = pwallet->GetDebit(*this);\n         fDebitCached = true;\n         return nDebitCached;\n     }\n@@ -227,7 +399,7 @@ class CWalletTx : public CMerkleTx\n         // GetBalance can assume transactions in mapWallet won't change\n         if (fUseCache && fCreditCached)\n             return nCreditCached;\n-        nCreditCached = CTransaction::GetCredit();\n+        nCreditCached = pwallet->GetCredit(*this);\n         fCreditCached = true;\n         return nCreditCached;\n     }\n@@ -247,7 +419,7 @@ class CWalletTx : public CMerkleTx\n             if (!IsSpent(i))\n             {\n                 const CTxOut &txout = vout[i];\n-                nCredit += txout.GetCredit();\n+                nCredit += pwallet->GetCredit(txout);\n                 if (!MoneyRange(nCredit))\n                     throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n             }\n@@ -263,15 +435,15 @@ class CWalletTx : public CMerkleTx\n     {\n         if (fChangeCached)\n             return nChangeCached;\n-        nChangeCached = CTransaction::GetChange();\n+        nChangeCached = pwallet->GetChange(*this);\n         fChangeCached = true;\n         return nChangeCached;\n     }\n \n     void GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, std::list<std::pair<std::string /* address */, int64> >& listReceived,\n                     std::list<std::pair<std::string /* address */, int64> >& listSent, int64& nFee, std::string& strSentAccount) const;\n \n-    void GetAccountAmounts(const std::string& strAccount, int64& nGenerated, int64& nReceived,\n+    void GetAccountAmounts(const std::string& strAccount, int64& nGenerated, int64& nReceived, \n                            int64& nSent, int64& nFee) const;\n \n     bool IsFromMe() const\n@@ -303,7 +475,7 @@ class CWalletTx : public CMerkleTx\n                 return false;\n             if (ptx->GetDepthInMainChain() >= 1)\n                 continue;\n-            if (!ptx->IsFromMe())\n+            if (!pwallet->IsFromMe(*ptx))\n                 return false;\n \n             if (mapPrev.empty())\n@@ -438,4 +610,6 @@ class CAccountingEntry\n     )\n };\n \n+bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n+\n #endif"
      }
    ]
  }
]