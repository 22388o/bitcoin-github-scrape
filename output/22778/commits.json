[
  {
    "sha": "a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
    "node_id": "C_kwDOABII59oAKGE2NWE5MTlhZDE5NzU5MzJhN2FhYTJlOWI1YTI3ZTE1YmI3ZTQ0ZjA",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-27T20:44:10Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:16:07Z"
      },
      "message": "[net] Add CNode.m_relays_txs and CNode.m_bloom_filter_loaded\n\nWe'll move the transaction relay data into Peer in subsequent commits,\nbut the inbound eviction logic needs to know if the peer is relaying\ntxs and if the peer has loaded a bloom filter.\n\nThis is currently redundant information with m_tx_relay->fRelayTxes,\nbut when m_tx_relay is moved into net_processing, then we'll need these\nseparate fields in CNode.",
      "tree": {
        "sha": "3d2502fc9b9a1c83e01b605e4f4175b037878e43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d2502fc9b9a1c83e01b605e4f4175b037878e43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "224e90d9fdf895d3ee212edcf7dec3eb4d94ce91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/224e90d9fdf895d3ee212edcf7dec3eb4d94ce91",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/224e90d9fdf895d3ee212edcf7dec3eb4d94ce91"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 17,
      "deletions": 9
    },
    "files": [
      {
        "sha": "c05e8a0102a0f1908b0789e4a3ac6d2cda8a0edd",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
        "patch": "@@ -1044,18 +1044,11 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            bool peer_relay_txes = false;\n-            bool peer_filter_not_null = false;\n-            if (node->m_tx_relay != nullptr) {\n-                LOCK(node->m_tx_relay->cs_filter);\n-                peer_relay_txes = node->m_tx_relay->fRelayTxes;\n-                peer_filter_not_null = node->m_tx_relay->pfilter != nullptr;\n-            }\n             NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->m_min_ping_time,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n-                                               peer_relay_txes, peer_filter_not_null, node->nKeyedNetGroup,\n-                                               node->m_prefer_evict, node->addr.IsLocal(),\n+                                               node->m_relays_txs.load(), node->m_bloom_filter_loaded.load(),\n+                                               node->nKeyedNetGroup, node->m_prefer_evict, node->addr.IsLocal(),\n                                                node->ConnectedThroughNetwork()};\n             vEvictionCandidates.push_back(candidate);\n         }"
      },
      {
        "sha": "27b280caf8b61ddb01e1699b83cb581ec0e665ae",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
        "patch": "@@ -557,6 +557,16 @@ class CNode\n     // m_tx_relay == nullptr if we're not relaying transactions with this peer\n     std::unique_ptr<TxRelay> m_tx_relay;\n \n+    /** Whether we should relay transactions to this peer (their version\n+     *  message did not include fRelay=false and this is not a block-relay-only\n+     *  connection). This only changes from false to true. It will never change\n+     *  back to false. Used only in inbound eviction logic. */\n+    std::atomic_bool m_relays_txs{false};\n+\n+    /** Whether this peer has loaded a bloom filter. Used only in inbound\n+     *  eviction logic. */\n+    std::atomic_bool m_bloom_filter_loaded{false};\n+\n     /** UNIX epoch time of the last block received from this peer that we had\n      * not yet seen (e.g. not already received from another peer), that passed\n      * preliminary validity checks and was saved to disk, even if we don't"
      },
      {
        "sha": "69a5d6ae9ac4fa045804c2b4d525beb671741270",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
        "patch": "@@ -2604,6 +2604,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (pfrom.m_tx_relay != nullptr) {\n             LOCK(pfrom.m_tx_relay->cs_filter);\n             pfrom.m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n+            if (fRelay) pfrom.m_relays_txs = true;\n         }\n \n         if((nServices & NODE_WITNESS))\n@@ -3910,7 +3911,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n             LOCK(pfrom.m_tx_relay->cs_filter);\n             pfrom.m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n+            pfrom.m_bloom_filter_loaded = true;\n             pfrom.m_tx_relay->fRelayTxes = true;\n+            pfrom.m_relays_txs = true;\n         }\n         return;\n     }\n@@ -3954,7 +3957,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n         LOCK(pfrom.m_tx_relay->cs_filter);\n         pfrom.m_tx_relay->pfilter = nullptr;\n+        pfrom.m_bloom_filter_loaded = false;\n         pfrom.m_tx_relay->fRelayTxes = true;\n+        pfrom.m_relays_txs = true;\n         return;\n     }\n "
      }
    ]
  },
  {
    "sha": "ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
    "node_id": "C_kwDOABII59oAKGJhMGIyNTk0ZDRiMDYwNmZlNjRjOGM5ZWNiNzkwYTE1ZGJkOTA5NTI",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-27T22:34:43Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:16:07Z"
      },
      "message": "[net processing] Move m_wtxid_relay to Peer\n\nAlso, remove cs_main guard from m_wtxid_relay_peers and make it atomic.\nThis should be fine since we don't need m_wtxid_relay_peers to be\nsynchronized with m_wtxid_relay exactly at all times.\n\nAfter this change, RelayTransaction no longer requires cs_main.",
      "tree": {
        "sha": "ee70ab5046d86a73b6feb6e1c1bd77d263983e05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee70ab5046d86a73b6feb6e1c1bd77d263983e05"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a65a919ad1975932a7aaa2e9b5a27e15bb7e44f0"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 35,
      "deletions": 41
    },
    "files": [
      {
        "sha": "05c8d18c5a1caab9fc6bf900ed962597c26234f1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 41,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
        "patch": "@@ -224,6 +224,9 @@ struct Peer {\n     /** Whether a ping has been requested by the user */\n     std::atomic<bool> m_ping_queued{false};\n \n+    /** Whether this peer relays txs via wtxid */\n+    std::atomic<bool> m_wtxid_relay{false};\n+\n     /** A vector of addresses to send to the peer, limited to MAX_ADDR_TO_SEND. */\n     std::vector<CAddress> m_addrs_to_send;\n     /** Probabilistic filter to track recent addr messages relayed with this\n@@ -322,9 +325,6 @@ class PeerManagerImpl final : public PeerManager\n                         const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n \n private:\n-    void _RelayTransaction(const uint256& txid, const uint256& wtxid)\n-        EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n     void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -453,7 +453,7 @@ class PeerManagerImpl final : public PeerManager\n     std::map<uint256, std::pair<NodeId, bool>> mapBlockSource GUARDED_BY(cs_main);\n \n     /** Number of peers with wtxid relay. */\n-    int m_wtxid_relay_peers GUARDED_BY(cs_main) = 0;\n+    std::atomic<int> m_wtxid_relay_peers{0};\n \n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int m_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n@@ -759,9 +759,6 @@ struct CNodeState {\n     //! A rolling bloom filter of all announced tx CInvs to this peer.\n     CRollingBloomFilter m_recently_announced_invs = CRollingBloomFilter{INVENTORY_MAX_RECENT_RELAY, 0.000001};\n \n-    //! Whether this peer relays txs via wtxid\n-    bool m_wtxid_relay{false};\n-\n     CNodeState(bool is_inbound) : m_is_inbound(is_inbound) {}\n };\n \n@@ -1178,8 +1175,7 @@ void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler)\n         CTransactionRef tx = m_mempool.get(txid);\n \n         if (tx != nullptr) {\n-            LOCK(cs_main);\n-            _RelayTransaction(txid, tx->GetWitnessHash());\n+            RelayTransaction(txid, tx->GetWitnessHash());\n         } else {\n             m_mempool.RemoveUnbroadcastTx(txid, true);\n         }\n@@ -1206,6 +1202,8 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         PeerRef peer = RemovePeer(nodeid);\n         assert(peer != nullptr);\n         misbehavior = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);\n+        m_wtxid_relay_peers -= peer->m_wtxid_relay;\n+        assert(m_wtxid_relay_peers >= 0);\n     }\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -1223,8 +1221,6 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n     assert(m_peers_downloading_from >= 0);\n     m_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(m_outbound_peers_with_protect_from_disconnect >= 0);\n-    m_wtxid_relay_peers -= state->m_wtxid_relay;\n-    assert(m_wtxid_relay_peers >= 0);\n \n     mapNodeState.erase(nodeid);\n \n@@ -1673,21 +1669,22 @@ void PeerManagerImpl::SendPings()\n \n void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n {\n-    WITH_LOCK(cs_main, _RelayTransaction(txid, wtxid););\n-}\n+    std::map<const NodeId, const uint256&> relay_peers;\n+    {\n+        // Don't hold m_peer_mutex while calling ForEachNode() to avoid an\n+        // m_peer_mutex/cs_vNodes lock inversion. During shutdown, FinalizeNode()\n+        // is called while holding cs_vNodes.\n+        LOCK(m_peer_mutex);\n+        for (auto& it : m_peer_map) {\n+            relay_peers.emplace(it.first, it.second->m_wtxid_relay ? wtxid : txid);\n+        }\n+    }\n \n-void PeerManagerImpl::_RelayTransaction(const uint256& txid, const uint256& wtxid)\n-{\n-    m_connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n-        AssertLockHeld(::cs_main);\n+    m_connman.ForEachNode([&relay_peers](CNode* node) {\n+        auto it = relay_peers.find(node->GetId());\n+        if (it == relay_peers.end()) return; // Should never happen\n \n-        CNodeState* state = State(pnode->GetId());\n-        if (state == nullptr) return;\n-        if (state->m_wtxid_relay) {\n-            pnode->PushTxInventory(wtxid);\n-        } else {\n-            pnode->PushTxInventory(txid);\n-        }\n+        node->PushTxInventory(it->second);\n     });\n }\n \n@@ -2247,7 +2244,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-            _RelayTransaction(orphanHash, porphanTx->GetWitnessHash());\n+            RelayTransaction(orphanHash, porphanTx->GetWitnessHash());\n             m_orphanage.AddChildrenToWorkSet(*porphanTx, orphan_work_set);\n             m_orphanage.EraseTx(orphanHash);\n             for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n@@ -2785,9 +2782,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n         if (pfrom.GetCommonVersion() >= WTXID_RELAY_VERSION) {\n-            LOCK(cs_main);\n-            if (!State(pfrom.GetId())->m_wtxid_relay) {\n-                State(pfrom.GetId())->m_wtxid_relay = true;\n+            if (!peer->m_wtxid_relay) {\n+                peer->m_wtxid_relay = true;\n                 m_wtxid_relay_peers++;\n             } else {\n                 LogPrint(BCLog::NET, \"ignoring duplicate wtxidrelay from peer=%d\\n\", pfrom.GetId());\n@@ -2941,7 +2937,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // Ignore INVs that don't match wtxidrelay setting.\n             // Note that orphan parent fetching always uses MSG_TX GETDATAs regardless of the wtxidrelay setting.\n             // This is fine as no INV messages are involved in that process.\n-            if (State(pfrom.GetId())->m_wtxid_relay) {\n+            if (peer->m_wtxid_relay) {\n                 if (inv.IsMsgTx()) continue;\n             } else {\n                 if (inv.IsMsgWtx()) continue;\n@@ -3214,13 +3210,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const uint256& txid = ptx->GetHash();\n         const uint256& wtxid = ptx->GetWitnessHash();\n \n-        LOCK2(cs_main, g_cs_orphans);\n-\n-        CNodeState* nodestate = State(pfrom.GetId());\n-\n-        const uint256& hash = nodestate->m_wtxid_relay ? wtxid : txid;\n+        const uint256& hash = peer->m_wtxid_relay ? wtxid : txid;\n         pfrom.AddKnownTx(hash);\n-        if (nodestate->m_wtxid_relay && txid != wtxid) {\n+        if (peer->m_wtxid_relay && txid != wtxid) {\n             // Insert txid into filterInventoryKnown, even for\n             // wtxidrelay peers. This prevents re-adding of\n             // unconfirmed parents to the recently_announced\n@@ -3229,6 +3221,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             pfrom.AddKnownTx(txid);\n         }\n \n+        LOCK2(cs_main, g_cs_orphans);\n+\n         m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n         if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n \n@@ -3253,7 +3247,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n-                    _RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n+                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n                 }\n             }\n             return;\n@@ -3268,7 +3262,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // requests for it.\n             m_txrequest.ForgetTxHash(tx.GetHash());\n             m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n-            _RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n+            RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n             m_orphanage.AddChildrenToWorkSet(tx, peer->m_orphan_work_set);\n \n             pfrom.nLastTXTime = GetTime();\n@@ -4760,8 +4754,8 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     LOCK(pto->m_tx_relay->cs_filter);\n \n                     for (const auto& txinfo : vtxinfo) {\n-                        const uint256& hash = state.m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n-                        CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n+                        const uint256& hash = peer->m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n+                        CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n@@ -4792,7 +4786,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n-                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, state.m_wtxid_relay);\n+                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, peer->m_wtxid_relay);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n@@ -4804,7 +4798,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         std::set<uint256>::iterator it = vInvTx.back();\n                         vInvTx.pop_back();\n                         uint256 hash = *it;\n-                        CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n+                        CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n                         pto->m_tx_relay->setInventoryTxToSend.erase(it);\n                         // Check if not in the filter already"
      }
    ]
  },
  {
    "sha": "4bd66febf39346ea23551421340dbd70e7e137ca",
    "node_id": "C_kwDOABII59oAKDRiZDY2ZmViZjM5MzQ2ZWEyMzU1MTQyMTM0MGRiZDcwZTdlMTM3Y2E",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-07-10T14:35:14Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:17:58Z"
      },
      "message": "[net processing] Move tx relay data to Peer",
      "tree": {
        "sha": "fbcd47ce4de5fc0143ef762bc43753a4d3be50e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fbcd47ce4de5fc0143ef762bc43753a4d3be50e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4bd66febf39346ea23551421340dbd70e7e137ca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4bd66febf39346ea23551421340dbd70e7e137ca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4bd66febf39346ea23551421340dbd70e7e137ca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4bd66febf39346ea23551421340dbd70e7e137ca/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ba0b2594d4b0606fe64c8c9ecb790a15dbd90952"
      }
    ],
    "stats": {
      "total": 319,
      "additions": 142,
      "deletions": 177
    },
    "files": [
      {
        "sha": "51c4db7f7ef935edd7460460e52ccf7533b68822",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -560,12 +560,6 @@ void CNode::CopyStats(CNodeStats& stats)\n     X(addr);\n     X(addrBind);\n     stats.m_network = ConnectedThroughNetwork();\n-    if (m_tx_relay != nullptr) {\n-        LOCK(m_tx_relay->cs_filter);\n-        stats.fRelayTxes = m_tx_relay->fRelayTxes;\n-    } else {\n-        stats.fRelayTxes = false;\n-    }\n     X(nLastSend);\n     X(nLastRecv);\n     X(nLastTXTime);\n@@ -592,11 +586,6 @@ void CNode::CopyStats(CNodeStats& stats)\n         X(nRecvBytes);\n     }\n     X(m_permissionFlags);\n-    if (m_tx_relay != nullptr) {\n-        stats.minFeeFilter = m_tx_relay->minFeeFilter;\n-    } else {\n-        stats.minFeeFilter = 0;\n-    }\n \n     X(m_last_ping_time);\n     X(m_min_ping_time);\n@@ -2959,9 +2948,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n {\n     if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);\n     hSocket = hSocketIn;\n-    if (conn_type_in != ConnectionType::BLOCK_RELAY) {\n-        m_tx_relay = std::make_unique<TxRelay>();\n-    }\n \n     for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;"
      },
      {
        "sha": "80ca1eab0077c95061dd2865aea3838a2bc16609",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 48,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -240,7 +240,6 @@ class CNodeStats\n public:\n     NodeId nodeid;\n     ServiceFlags nServices;\n-    bool fRelayTxes;\n     int64_t nLastSend;\n     int64_t nLastRecv;\n     int64_t nLastTXTime;\n@@ -261,7 +260,6 @@ class CNodeStats\n     NetPermissionFlags m_permissionFlags;\n     std::chrono::microseconds m_last_ping_time;\n     std::chrono::microseconds m_min_ping_time;\n-    CAmount minFeeFilter;\n     // Our address, as reported by the peer\n     std::string addrLocal;\n     // Address of this peer\n@@ -528,35 +526,6 @@ class CNode\n     // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n     std::atomic<bool> m_bip152_highbandwidth_from{false};\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n-\n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n-\n-        /** Minimum fee rate with which to filter inv's to this node */\n-        std::atomic<CAmount> minFeeFilter{0};\n-        CAmount lastSentFeeFilter{0};\n-        std::chrono::microseconds m_next_send_feefilter{0};\n-    };\n-\n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n-\n     /** Whether we should relay transactions to this peer (their version\n      *  message did not include fRelay=false and this is not a block-relay-only\n      *  connection). This only changes from false to true. It will never change\n@@ -642,23 +611,6 @@ class CNode\n         nRefCount--;\n     }\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n-\n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n-\n     void CloseSocketDisconnect();\n \n     void CopyStats(CNodeStats& stats);"
      },
      {
        "sha": "883df607614fbee215af98c958cf8ebb948fc46b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 137,
        "deletions": 97,
        "changes": 234,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -227,6 +227,36 @@ struct Peer {\n     /** Whether this peer relays txs via wtxid */\n     std::atomic<bool> m_wtxid_relay{false};\n \n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n+\n+        /** Minimum fee rate with which to filter inv's to this node */\n+        std::atomic<CAmount> minFeeFilter{0};\n+        CAmount lastSentFeeFilter{0};\n+        std::chrono::microseconds m_next_send_feefilter{0};\n+    };\n+\n+    /** Transaction relay data. Will be a nullptr if we're not relaying\n+     *  transactions with this peer (e.g. if it's a block-relay-only peer) */\n+    std::unique_ptr<TxRelay> m_tx_relay;\n+\n     /** A vector of addresses to send to the peer, limited to MAX_ADDR_TO_SEND. */\n     std::vector<CAddress> m_addrs_to_send;\n     /** Probabilistic filter to track recent addr messages relayed with this\n@@ -285,8 +315,9 @@ struct Peer {\n     /** Work queue of items requested by this peer **/\n     std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n \n-    explicit Peer(NodeId id)\n+    explicit Peer(NodeId id, bool tx_relay)\n         : m_id(id)\n+        , m_tx_relay(tx_relay ? nullptr : std::make_unique<TxRelay>())\n     {}\n };\n \n@@ -385,7 +416,7 @@ class PeerManagerImpl final : public PeerManager\n         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     /** Send a version message to a peer */\n-    void PushNodeVersion(CNode& pnode, int64_t nTime);\n+    void PushNodeVersion(CNode& pnode, Peer& peer, int64_t nTime);\n \n     /** Send a ping message every PING_INTERVAL or if requested via RPC. May\n      *  mark the peer to be disconnected if a ping has timed out.\n@@ -406,7 +437,7 @@ class PeerManagerImpl final : public PeerManager\n     void RelayAddress(NodeId originator, const CAddress& addr, bool fReachable);\n \n     /** Send `feefilter` message. */\n-    void MaybeSendFeefilter(CNode& node, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void MaybeSendFeefilter(CNode& node, Peer& peer, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n@@ -803,6 +834,14 @@ static void PushAddress(Peer& peer, const CAddress& addr, FastRandomContext& ins\n     }\n }\n \n+static void AddKnownTx(Peer& peer, const uint256& hash)\n+{\n+    if (peer.m_tx_relay != nullptr) {\n+        LOCK(peer.m_tx_relay->cs_tx_inventory);\n+        peer.m_tx_relay->filterInventoryKnown.insert(hash);\n+    }\n+}\n+\n static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -1086,7 +1125,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n \n } // namespace\n \n-void PeerManagerImpl::PushNodeVersion(CNode& pnode, int64_t nTime)\n+void PeerManagerImpl::PushNodeVersion(CNode& pnode, Peer& peer, int64_t nTime)\n {\n     // Note that pnode->GetLocalServices() is a reflection of the local\n     // services we were offering when the CNode object was created for this\n@@ -1100,7 +1139,7 @@ void PeerManagerImpl::PushNodeVersion(CNode& pnode, int64_t nTime)\n     CService addr_you = addr.IsRoutable() && !IsProxy(addr) && addr.IsAddrV1Compatible() ? addr : CService();\n     uint64_t your_services{addr.nServices};\n \n-    const bool tx_relay = !m_ignore_incoming_txs && pnode.m_tx_relay != nullptr;\n+    const bool tx_relay = !m_ignore_incoming_txs && peer.m_tx_relay != nullptr;\n     m_connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, my_services, nTime,\n             your_services, addr_you, // Together the pre-version-31402 serialization of CAddress \"addrYou\" (without nTime)\n             my_services, CService(), // Together the pre-version-31402 serialization of CAddress \"addrMe\" (without nTime)\n@@ -1157,13 +1196,13 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(pnode->IsInboundConn()));\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n+    PeerRef peer = std::make_shared<Peer>(nodeid, pnode->IsBlockOnlyConn());\n     {\n-        PeerRef peer = std::make_shared<Peer>(nodeid);\n         LOCK(m_peer_mutex);\n-        m_peer_map.emplace_hint(m_peer_map.end(), nodeid, std::move(peer));\n+        m_peer_map.emplace_hint(m_peer_map.end(), nodeid, peer);\n     }\n     if (!pnode->IsInboundConn()) {\n-        PushNodeVersion(*pnode, GetTime());\n+        PushNodeVersion(*pnode, *peer, GetTime());\n     }\n }\n \n@@ -1293,6 +1332,14 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) c\n         ping_wait = GetTime<std::chrono::microseconds>() - peer->m_ping_start.load();\n     }\n \n+    if (peer->m_tx_relay != nullptr) {\n+        stats.fRelayTxes = WITH_LOCK(peer->m_tx_relay->cs_filter, return peer->m_tx_relay->fRelayTxes);\n+        stats.minFeeFilter = peer->m_tx_relay->minFeeFilter.load();\n+    } else {\n+        stats.fRelayTxes = false;\n+        stats.minFeeFilter = 0;\n+    }\n+\n     stats.m_ping_wait = ping_wait;\n     stats.m_addr_processed = peer->m_addr_processed.load();\n     stats.m_addr_rate_limited = peer->m_addr_rate_limited.load();\n@@ -1669,23 +1716,17 @@ void PeerManagerImpl::SendPings()\n \n void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n {\n-    std::map<const NodeId, const uint256&> relay_peers;\n-    {\n-        // Don't hold m_peer_mutex while calling ForEachNode() to avoid an\n-        // m_peer_mutex/cs_vNodes lock inversion. During shutdown, FinalizeNode()\n-        // is called while holding cs_vNodes.\n-        LOCK(m_peer_mutex);\n-        for (auto& it : m_peer_map) {\n-            relay_peers.emplace(it.first, it.second->m_wtxid_relay ? wtxid : txid);\n-        }\n-    }\n-\n-    m_connman.ForEachNode([&relay_peers](CNode* node) {\n-        auto it = relay_peers.find(node->GetId());\n-        if (it == relay_peers.end()) return; // Should never happen\n+    LOCK(m_peer_mutex);\n+    for(auto& it : m_peer_map) {\n+        Peer& peer = *it.second;\n+        if (!peer.m_tx_relay) continue;\n \n-        node->PushTxInventory(it->second);\n-    });\n+        const uint256& hash{peer.m_wtxid_relay ? wtxid : txid};\n+        LOCK(peer.m_tx_relay->cs_tx_inventory);\n+        if (!peer.m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            peer.m_tx_relay->setInventoryTxToSend.insert(hash);\n+        }\n+    };\n }\n \n void PeerManagerImpl::RelayAddress(NodeId originator,\n@@ -1829,11 +1870,11 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n         } else if (inv.IsMsgFilteredBlk()) {\n             bool sendMerkleBlock = false;\n             CMerkleBlock merkleBlock;\n-            if (pfrom.m_tx_relay != nullptr) {\n-                LOCK(pfrom.m_tx_relay->cs_filter);\n-                if (pfrom.m_tx_relay->pfilter) {\n+            if (peer.m_tx_relay != nullptr) {\n+                LOCK(peer.m_tx_relay->cs_filter);\n+                if (peer.m_tx_relay->pfilter) {\n                     sendMerkleBlock = true;\n-                    merkleBlock = CMerkleBlock(*pblock, *pfrom.m_tx_relay->pfilter);\n+                    merkleBlock = CMerkleBlock(*pblock, *peer.m_tx_relay->pfilter);\n                 }\n             }\n             if (sendMerkleBlock) {\n@@ -1922,8 +1963,8 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n \n     const std::chrono::seconds now = GetTime<std::chrono::seconds>();\n     // Get last mempool request time\n-    const std::chrono::seconds mempool_req = pfrom.m_tx_relay != nullptr ? pfrom.m_tx_relay->m_last_mempool_req.load()\n-                                                                          : std::chrono::seconds::min();\n+    const std::chrono::seconds mempool_req = peer.m_tx_relay != nullptr ? peer.m_tx_relay->m_last_mempool_req.load()\n+                                                                        : std::chrono::seconds::min();\n \n     // Process as many TX items from the front of the getdata queue as\n     // possible, since they're common and it's efficient to batch process\n@@ -1936,7 +1977,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n \n         const CInv &inv = *it++;\n \n-        if (pfrom.m_tx_relay == nullptr) {\n+        if (peer.m_tx_relay == nullptr) {\n             // Ignore GETDATA requests for transactions from blocks-only peers.\n             continue;\n         }\n@@ -1964,7 +2005,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n             }\n             for (const uint256& parent_txid : parent_ids_to_add) {\n                 // Relaying a transaction with a recent but unconfirmed parent.\n-                if (WITH_LOCK(pfrom.m_tx_relay->cs_tx_inventory, return !pfrom.m_tx_relay->filterInventoryKnown.contains(parent_txid))) {\n+                if (WITH_LOCK(peer.m_tx_relay->cs_tx_inventory, return !peer.m_tx_relay->filterInventoryKnown.contains(parent_txid))) {\n                     LOCK(cs_main);\n                     State(pfrom.GetId())->m_recently_announced_invs.insert(parent_txid);\n                 }\n@@ -2560,7 +2601,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // Inbound peers send us their version message when they connect.\n         // We send our version message in response.\n-        if (pfrom.IsInboundConn()) PushNodeVersion(pfrom, GetAdjustedTime());\n+        if (pfrom.IsInboundConn()) PushNodeVersion(pfrom, *peer, GetAdjustedTime());\n \n         // Change version\n         const int greatest_common_version = std::min(nVersion, PROTOCOL_VERSION);\n@@ -2598,9 +2639,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n         pfrom.m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n-        if (pfrom.m_tx_relay != nullptr) {\n-            LOCK(pfrom.m_tx_relay->cs_filter);\n-            pfrom.m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n+        if (peer->m_tx_relay != nullptr) {\n+            LOCK(peer->m_tx_relay->cs_filter);\n+            peer->m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n             if (fRelay) pfrom.m_relays_txs = true;\n         }\n \n@@ -2919,7 +2960,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // Reject tx INVs when the -blocksonly setting is enabled, or this is a\n         // block-relay-only peer\n-        bool reject_tx_invs{m_ignore_incoming_txs || (pfrom.m_tx_relay == nullptr)};\n+        bool reject_tx_invs{m_ignore_incoming_txs || (peer->m_tx_relay == nullptr)};\n \n         // Allow peers with relay permission to send data other than blocks in blocks only mode\n         if (pfrom.HasPermission(NetPermissionFlags::Relay)) {\n@@ -2966,7 +3007,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 const bool fAlreadyHave = AlreadyHaveTx(gtxid);\n                 LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n-                pfrom.AddKnownTx(inv.hash);\n+                AddKnownTx(*peer, inv.hash);\n                 if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n@@ -3196,8 +3237,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // Stop processing the transaction early if\n         // 1) We are in blocks only mode and peer has no relay permission\n         // 2) This peer is a block-relay-only peer\n-        if ((m_ignore_incoming_txs && !pfrom.HasPermission(NetPermissionFlags::Relay)) || (pfrom.m_tx_relay == nullptr))\n-        {\n+        if ((m_ignore_incoming_txs && !pfrom.HasPermission(NetPermissionFlags::Relay)) || (peer->m_tx_relay == nullptr)) {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n             return;\n@@ -3211,14 +3251,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const uint256& wtxid = ptx->GetWitnessHash();\n \n         const uint256& hash = peer->m_wtxid_relay ? wtxid : txid;\n-        pfrom.AddKnownTx(hash);\n+        AddKnownTx(*peer, hash);\n         if (peer->m_wtxid_relay && txid != wtxid) {\n             // Insert txid into filterInventoryKnown, even for\n             // wtxidrelay peers. This prevents re-adding of\n             // unconfirmed parents to the recently_announced\n             // filter, when a child tx is requested. See\n             // ProcessGetData().\n-            pfrom.AddKnownTx(txid);\n+            AddKnownTx(*peer, txid);\n         }\n \n         LOCK2(cs_main, g_cs_orphans);\n@@ -3309,7 +3349,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // Eventually we should replace this with an improved\n                     // protocol for getting all unconfirmed parents.\n                     const auto gtxid{GenTxid::Txid(parent_txid)};\n-                    pfrom.AddKnownTx(parent_txid);\n+                    AddKnownTx(*peer, parent_txid);\n                     if (!AlreadyHaveTx(gtxid)) AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n \n@@ -3805,9 +3845,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (pfrom.m_tx_relay != nullptr) {\n-            LOCK(pfrom.m_tx_relay->cs_tx_inventory);\n-            pfrom.m_tx_relay->fSendMempool = true;\n+        if (peer->m_tx_relay != nullptr) {\n+            LOCK(peer->m_tx_relay->cs_tx_inventory);\n+            peer->m_tx_relay->fSendMempool = true;\n         }\n         return;\n     }\n@@ -3901,12 +3941,12 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // There is no excuse for sending a too-large filter\n             Misbehaving(pfrom.GetId(), 100, \"too-large bloom filter\");\n         }\n-        else if (pfrom.m_tx_relay != nullptr)\n+        else if (peer->m_tx_relay != nullptr)\n         {\n-            LOCK(pfrom.m_tx_relay->cs_filter);\n-            pfrom.m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n+            LOCK(peer->m_tx_relay->cs_filter);\n+            peer->m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n             pfrom.m_bloom_filter_loaded = true;\n-            pfrom.m_tx_relay->fRelayTxes = true;\n+            peer->m_tx_relay->fRelayTxes = true;\n             pfrom.m_relays_txs = true;\n         }\n         return;\n@@ -3926,10 +3966,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         bool bad = false;\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n-        } else if (pfrom.m_tx_relay != nullptr) {\n-            LOCK(pfrom.m_tx_relay->cs_filter);\n-            if (pfrom.m_tx_relay->pfilter) {\n-                pfrom.m_tx_relay->pfilter->insert(vData);\n+        } else if (peer->m_tx_relay != nullptr) {\n+            LOCK(peer->m_tx_relay->cs_filter);\n+            if (peer->m_tx_relay->pfilter) {\n+                peer->m_tx_relay->pfilter->insert(vData);\n             } else {\n                 bad = true;\n             }\n@@ -3946,13 +3986,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             pfrom.fDisconnect = true;\n             return;\n         }\n-        if (pfrom.m_tx_relay == nullptr) {\n+        if (peer->m_tx_relay == nullptr) {\n             return;\n         }\n-        LOCK(pfrom.m_tx_relay->cs_filter);\n-        pfrom.m_tx_relay->pfilter = nullptr;\n+        LOCK(peer->m_tx_relay->cs_filter);\n+        peer->m_tx_relay->pfilter = nullptr;\n         pfrom.m_bloom_filter_loaded = false;\n-        pfrom.m_tx_relay->fRelayTxes = true;\n+        peer->m_tx_relay->fRelayTxes = true;\n         pfrom.m_relays_txs = true;\n         return;\n     }\n@@ -3961,8 +4001,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n-            if (pfrom.m_tx_relay != nullptr) {\n-                pfrom.m_tx_relay->minFeeFilter = newFeeFilter;\n+            if (peer->m_tx_relay != nullptr) {\n+                peer->m_tx_relay->minFeeFilter = newFeeFilter;\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom.GetId());\n         }\n@@ -4420,12 +4460,12 @@ void PeerManagerImpl::MaybeSendAddr(CNode& node, Peer& peer, std::chrono::micros\n     }\n }\n \n-void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, std::chrono::microseconds current_time)\n+void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, Peer& peer, std::chrono::microseconds current_time)\n {\n     AssertLockHeld(cs_main);\n \n     if (m_ignore_incoming_txs) return;\n-    if (!pto.m_tx_relay) return;\n+    if (!peer.m_tx_relay) return;\n     if (pto.GetCommonVersion() < FEEFILTER_VERSION) return;\n     // peers with the forcerelay permission should not filter txs to us\n     if (pto.HasPermission(NetPermissionFlags::ForceRelay)) return;\n@@ -4439,27 +4479,27 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, std::chrono::microseconds c\n         currentFilter = MAX_MONEY;\n     } else {\n         static const CAmount MAX_FILTER{g_filter_rounder.round(MAX_MONEY)};\n-        if (pto.m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n+        if (peer.m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n             // Send the current filter if we sent MAX_FILTER previously\n             // and made it out of IBD.\n-            pto.m_tx_relay->m_next_send_feefilter = 0us;\n+            peer.m_tx_relay->m_next_send_feefilter = 0us;\n         }\n     }\n-    if (current_time > pto.m_tx_relay->m_next_send_feefilter) {\n+    if (current_time > peer.m_tx_relay->m_next_send_feefilter) {\n         CAmount filterToSend = g_filter_rounder.round(currentFilter);\n         // We always have a fee filter of at least minRelayTxFee\n         filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-        if (filterToSend != pto.m_tx_relay->lastSentFeeFilter) {\n+        if (filterToSend != peer.m_tx_relay->lastSentFeeFilter) {\n             m_connman.PushMessage(&pto, CNetMsgMaker(pto.GetCommonVersion()).Make(NetMsgType::FEEFILTER, filterToSend));\n-            pto.m_tx_relay->lastSentFeeFilter = filterToSend;\n+            peer.m_tx_relay->lastSentFeeFilter = filterToSend;\n         }\n-        pto.m_tx_relay->m_next_send_feefilter = PoissonNextSend(current_time, AVG_FEEFILTER_BROADCAST_INTERVAL);\n+        peer.m_tx_relay->m_next_send_feefilter = PoissonNextSend(current_time, AVG_FEEFILTER_BROADCAST_INTERVAL);\n     }\n     // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n     // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n-    else if (current_time + MAX_FEEFILTER_CHANGE_DELAY < pto.m_tx_relay->m_next_send_feefilter &&\n-                (currentFilter < 3 * pto.m_tx_relay->lastSentFeeFilter / 4 || currentFilter > 4 * pto.m_tx_relay->lastSentFeeFilter / 3)) {\n-        pto.m_tx_relay->m_next_send_feefilter = current_time + GetRandomDuration<std::chrono::microseconds>(MAX_FEEFILTER_CHANGE_DELAY);\n+    else if (current_time + MAX_FEEFILTER_CHANGE_DELAY < peer.m_tx_relay->m_next_send_feefilter &&\n+                (currentFilter < 3 * peer.m_tx_relay->lastSentFeeFilter / 4 || currentFilter > 4 * peer.m_tx_relay->lastSentFeeFilter / 3)) {\n+        peer.m_tx_relay->m_next_send_feefilter = current_time + GetRandomDuration<std::chrono::microseconds>(MAX_FEEFILTER_CHANGE_DELAY);\n     }\n }\n \n@@ -4726,72 +4766,72 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             peer->m_blocks_for_inv_relay.clear();\n         }\n \n-        if (pto->m_tx_relay != nullptr) {\n-                LOCK(pto->m_tx_relay->cs_tx_inventory);\n+        if (peer->m_tx_relay != nullptr) {\n+                LOCK(peer->m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n-                if (pto->m_tx_relay->nNextInvSend < current_time) {\n+                if (peer->m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        peer->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     } else {\n-                        pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        peer->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     }\n                 }\n \n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n-                    LOCK(pto->m_tx_relay->cs_filter);\n-                    if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->setInventoryTxToSend.clear();\n+                    LOCK(peer->m_tx_relay->cs_filter);\n+                    if (!peer->m_tx_relay->fRelayTxes) peer->m_tx_relay->setInventoryTxToSend.clear();\n                 }\n \n                 // Respond to BIP35 mempool requests\n-                if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n+                if (fSendTrickle && peer->m_tx_relay->fSendMempool) {\n                     auto vtxinfo = m_mempool.infoAll();\n-                    pto->m_tx_relay->fSendMempool = false;\n-                    const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n+                    peer->m_tx_relay->fSendMempool = false;\n+                    const CFeeRate filterrate{peer->m_tx_relay->minFeeFilter.load()};\n \n-                    LOCK(pto->m_tx_relay->cs_filter);\n+                    LOCK(peer->m_tx_relay->cs_filter);\n \n                     for (const auto& txinfo : vtxinfo) {\n                         const uint256& hash = peer->m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n                         CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n+                        peer->m_tx_relay->setInventoryTxToSend.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (pto->m_tx_relay->pfilter) {\n-                            if (!pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (peer->m_tx_relay->pfilter) {\n+                            if (!peer->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         }\n-                        pto->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        peer->m_tx_relay->filterInventoryKnown.insert(hash);\n                         // Responses to MEMPOOL requests bypass the m_recently_announced_invs filter.\n                         vInv.push_back(inv);\n                         if (vInv.size() == MAX_INV_SZ) {\n                             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n                     }\n-                    pto->m_tx_relay->m_last_mempool_req = std::chrono::duration_cast<std::chrono::seconds>(current_time);\n+                    peer->m_tx_relay->m_last_mempool_req = std::chrono::duration_cast<std::chrono::seconds>(current_time);\n                 }\n \n                 // Determine transactions to relay\n                 if (fSendTrickle) {\n                     // Produce a vector with all candidates for sending\n                     std::vector<std::set<uint256>::iterator> vInvTx;\n-                    vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n-                    for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n+                    vInvTx.reserve(peer->m_tx_relay->setInventoryTxToSend.size());\n+                    for (std::set<uint256>::iterator it = peer->m_tx_relay->setInventoryTxToSend.begin(); it != peer->m_tx_relay->setInventoryTxToSend.end(); it++) {\n                         vInvTx.push_back(it);\n                     }\n-                    const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n+                    const CFeeRate filterrate{peer->m_tx_relay->minFeeFilter.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n                     CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, peer->m_wtxid_relay);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n                     unsigned int nRelayedTransactions = 0;\n-                    LOCK(pto->m_tx_relay->cs_filter);\n+                    LOCK(peer->m_tx_relay->cs_filter);\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n@@ -4800,9 +4840,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         uint256 hash = *it;\n                         CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(it);\n+                        peer->m_tx_relay->setInventoryTxToSend.erase(it);\n                         // Check if not in the filter already\n-                        if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n+                        if (peer->m_tx_relay->filterInventoryKnown.contains(hash)) {\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n@@ -4816,7 +4856,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (peer->m_tx_relay->pfilter && !peer->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n                         vInv.push_back(inv);\n@@ -4843,14 +4883,14 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n-                        pto->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        peer->m_tx_relay->filterInventoryKnown.insert(hash);\n                         if (hash != txid) {\n                             // Insert txid into filterInventoryKnown, even for\n                             // wtxidrelay peers. This prevents re-adding of\n                             // unconfirmed parents to the recently_announced\n                             // filter, when a child tx is requested. See\n                             // ProcessGetData().\n-                            pto->m_tx_relay->filterInventoryKnown.insert(txid);\n+                            peer->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n                 }\n@@ -4971,7 +5011,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         if (!vGetData.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n-        MaybeSendFeefilter(*pto, current_time);\n+        MaybeSendFeefilter(*pto, *peer, current_time);\n     } // release cs_main\n     return true;\n }"
      },
      {
        "sha": "83db3172f0382fdad046bb2b39202ff06b39f57a",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -29,6 +29,8 @@ struct CNodeStateStats {\n     int m_starting_height = -1;\n     std::chrono::microseconds m_ping_wait;\n     std::vector<int> vHeightInFlight;\n+    bool fRelayTxes;\n+    CAmount minFeeFilter;\n     uint64_t m_addr_processed = 0;\n     uint64_t m_addr_rate_limited = 0;\n     bool m_addr_relay_enabled{false};"
      },
      {
        "sha": "d501add7b33f5586b9158e6ed87cfb5d743333d9",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -1162,7 +1162,6 @@ void RPCConsole::updateDetailWidget()\n         peerAddrDetails += \"<br />\" + tr(\"via %1\").arg(QString::fromStdString(stats->nodeStats.addrLocal));\n     ui->peerHeading->setText(peerAddrDetails);\n     ui->peerServices->setText(GUIUtil::formatServicesStr(stats->nodeStats.nServices));\n-    ui->peerRelayTxes->setText(stats->nodeStats.fRelayTxes ? ts.yes : ts.no);\n     QString bip152_hb_settings;\n     if (stats->nodeStats.m_bip152_highbandwidth_to) bip152_hb_settings = ts.to;\n     if (stats->nodeStats.m_bip152_highbandwidth_from) bip152_hb_settings += (bip152_hb_settings.isEmpty() ? ts.from : QLatin1Char('/') + ts.from);\n@@ -1211,6 +1210,7 @@ void RPCConsole::updateDetailWidget()\n         }\n         ui->peerHeight->setText(QString::number(stats->nodeStateStats.m_starting_height));\n         ui->peerPingWait->setText(GUIUtil::formatPingTime(stats->nodeStateStats.m_ping_wait));\n+        ui->peerRelayTxes->setText(stats->nodeStateStats.fRelayTxes ? ts.yes : ts.no);\n     }\n \n     ui->peersTabRightPanel->show();"
      },
      {
        "sha": "471f6189f256224d7fed2f51d31ff444b9f47816",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -210,7 +210,6 @@ static RPCHelpMan getpeerinfo()\n         }\n         obj.pushKV(\"services\", strprintf(\"%016x\", stats.nServices));\n         obj.pushKV(\"servicesnames\", GetServicesNames(stats.nServices));\n-        obj.pushKV(\"relaytxes\", stats.fRelayTxes);\n         obj.pushKV(\"lastsend\", stats.nLastSend);\n         obj.pushKV(\"lastrecv\", stats.nLastRecv);\n         obj.pushKV(\"last_transaction\", stats.nLastTXTime);\n@@ -245,6 +244,8 @@ static RPCHelpMan getpeerinfo()\n                 heights.push_back(height);\n             }\n             obj.pushKV(\"inflight\", heights);\n+            obj.pushKV(\"relaytxes\", statestats.fRelayTxes);\n+            obj.pushKV(\"minfeefilter\", ValueFromAmount(statestats.minFeeFilter));\n             obj.pushKV(\"addr_relay_enabled\", statestats.m_addr_relay_enabled);\n             obj.pushKV(\"addr_processed\", statestats.m_addr_processed);\n             obj.pushKV(\"addr_rate_limited\", statestats.m_addr_rate_limited);\n@@ -254,7 +255,6 @@ static RPCHelpMan getpeerinfo()\n             permissions.push_back(permission);\n         }\n         obj.pushKV(\"permissions\", permissions);\n-        obj.pushKV(\"minfeefilter\", ValueFromAmount(stats.minFeeFilter));\n \n         UniValue sendPerMsgCmd(UniValue::VOBJ);\n         for (const auto& i : stats.mapSendBytesPerMsgCmd) {"
      },
      {
        "sha": "5cebc1ee0ec2eb91e3c0aaea819be127b6b21c3b",
        "filename": "src/test/fuzz/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/test/fuzz/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/test/fuzz/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/net.cpp?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -51,16 +51,6 @@ FUZZ_TARGET_INIT(net, initialize_net)\n                     node.Release();\n                 }\n             },\n-            [&] {\n-                const std::optional<CInv> inv_opt = ConsumeDeserializable<CInv>(fuzzed_data_provider);\n-                if (!inv_opt) {\n-                    return;\n-                }\n-                node.AddKnownTx(inv_opt->hash);\n-            },\n-            [&] {\n-                node.PushTxInventory(ConsumeUInt256(fuzzed_data_provider));\n-            },\n             [&] {\n                 const std::optional<CService> service_opt = ConsumeDeserializable<CService>(fuzzed_data_provider);\n                 if (!service_opt) {"
      },
      {
        "sha": "ffdb6cb6f5d57dc8aa29a49c1ec5abf8f315766d",
        "filename": "src/test/fuzz/util.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bd66febf39346ea23551421340dbd70e7e137ca/src/test/fuzz/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bd66febf39346ea23551421340dbd70e7e137ca/src/test/fuzz/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.cpp?ref=4bd66febf39346ea23551421340dbd70e7e137ca",
        "patch": "@@ -205,18 +205,13 @@ void FillNode(FuzzedDataProvider& fuzzed_data_provider, CNode& node, bool init_v\n     const ServiceFlags remote_services = ConsumeWeakEnum(fuzzed_data_provider, ALL_SERVICE_FLAGS);\n     const NetPermissionFlags permission_flags = ConsumeWeakEnum(fuzzed_data_provider, ALL_NET_PERMISSION_FLAGS);\n     const int32_t version = fuzzed_data_provider.ConsumeIntegralInRange<int32_t>(MIN_PEER_PROTO_VERSION, std::numeric_limits<int32_t>::max());\n-    const bool filter_txs = fuzzed_data_provider.ConsumeBool();\n \n     node.nServices = remote_services;\n     node.m_permissionFlags = permission_flags;\n     if (init_version) {\n         node.nVersion = version;\n         node.SetCommonVersion(std::min(version, PROTOCOL_VERSION));\n     }\n-    if (node.m_tx_relay != nullptr) {\n-        LOCK(node.m_tx_relay->cs_filter);\n-        node.m_tx_relay->fRelayTxes = filter_txs;\n-    }\n }\n \n CAmount ConsumeMoney(FuzzedDataProvider& fuzzed_data_provider, const std::optional<CAmount>& max) noexcept"
      }
    ]
  },
  {
    "sha": "b0dfefec249302cd9d9f121fe081a9a51294d0ab",
    "node_id": "C_kwDOABII59oAKGIwZGZlZmVjMjQ5MzAyY2Q5ZDlmMTIxZmUwODFhOWE1MTI5NGQwYWI",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-06-16T20:27:34Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:17:58Z"
      },
      "message": "scripted-diff: rename TxRelay members\n\n-BEGIN VERIFY SCRIPT-\nren() { sed -i \"s:\\<$1\\>:$2:g\" $(git grep -l \"\\<$1\\>\" ./src ./test); }\n\nren cs_filter             m_bloom_filter_mutex\nren fRelayTxes            m_relay_txs\nren pfilter               m_bloom_filter\nren cs_tx_inventory       m_tx_inventory_mutex\nren filterInventoryKnown  m_tx_inventory_known_filter\nren setInventoryTxToSend  m_tx_inventory_to_send\nren fSendMempool          m_send_mempool\nren nNextInvSend          m_next_inv_send_time\nren minFeeFilter          m_fee_filter_received\nren lastSentFeeFilter     m_fee_filter_sent\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "f188096c1f18fc2f84cc4035d28c4f4e0c0fa646",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f188096c1f18fc2f84cc4035d28c4f4e0c0fa646"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0dfefec249302cd9d9f121fe081a9a51294d0ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dfefec249302cd9d9f121fe081a9a51294d0ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0dfefec249302cd9d9f121fe081a9a51294d0ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dfefec249302cd9d9f121fe081a9a51294d0ab/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4bd66febf39346ea23551421340dbd70e7e137ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4bd66febf39346ea23551421340dbd70e7e137ca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4bd66febf39346ea23551421340dbd70e7e137ca"
      }
    ],
    "stats": {
      "total": 164,
      "additions": 82,
      "deletions": 82
    },
    "files": [
      {
        "sha": "e0bcbb34c1d28471229c6968b9b4cf4d413d3d82",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -834,15 +834,15 @@ static bool CompareNodeTXTime(const NodeEvictionCandidate &a, const NodeEviction\n {\n     // There is a fall-through here because it is common for a node to have more than a few peers that have not yet relayed txn.\n     if (a.nLastTXTime != b.nLastTXTime) return a.nLastTXTime < b.nLastTXTime;\n-    if (a.fRelayTxes != b.fRelayTxes) return b.fRelayTxes;\n+    if (a.m_relay_txs != b.m_relay_txs) return b.m_relay_txs;\n     if (a.fBloomFilter != b.fBloomFilter) return a.fBloomFilter;\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n // Pick out the potential block-relay only peers, and sort them by last block time.\n static bool CompareNodeBlockRelayOnlyTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n {\n-    if (a.fRelayTxes != b.fRelayTxes) return a.fRelayTxes;\n+    if (a.m_relay_txs != b.m_relay_txs) return a.m_relay_txs;\n     if (a.nLastBlockTime != b.nLastBlockTime) return a.nLastBlockTime < b.nLastBlockTime;\n     if (a.fRelevantServices != b.fRelevantServices) return b.fRelevantServices;\n     return a.nTimeConnected > b.nTimeConnected;\n@@ -967,7 +967,7 @@ void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& evicti\n     EraseLastKElements(vEvictionCandidates, CompareNodeTXTime, 4);\n     // Protect up to 8 non-tx-relay peers that have sent us novel blocks.\n     EraseLastKElements(vEvictionCandidates, CompareNodeBlockRelayOnlyTime, 8,\n-                       [](const NodeEvictionCandidate& n) { return !n.fRelayTxes && n.fRelevantServices; });\n+                       [](const NodeEvictionCandidate& n) { return !n.m_relay_txs && n.fRelevantServices; });\n \n     // Protect 4 nodes that most recently sent us novel blocks.\n     // An attacker cannot manipulate this metric without performing useful work."
      },
      {
        "sha": "b350e6e089c987219184500b45247e94ae5240c3",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -1157,7 +1157,7 @@ struct NodeEvictionCandidate\n     int64_t nLastBlockTime;\n     int64_t nLastTXTime;\n     bool fRelevantServices;\n-    bool fRelayTxes;\n+    bool m_relay_txs;\n     bool fBloomFilter;\n     uint64_t nKeyedNetGroup;\n     bool prefer_evict;"
      },
      {
        "sha": "1a2137dfd1141f8c98776525acd1bc9c208ebd22",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 67,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -228,28 +228,28 @@ struct Peer {\n     std::atomic<bool> m_wtxid_relay{false};\n \n     struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n+        mutable RecursiveMutex m_bloom_filter_mutex;\n+        // We use m_relay_txs for two purposes -\n         // a) it allows us to not relay tx invs before receiving the peer's version message\n         // b) the peer may tell us in its version message that we should not relay tx invs\n         //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+        bool m_relay_txs GUARDED_BY(m_bloom_filter_mutex){false};\n+        std::unique_ptr<CBloomFilter> m_bloom_filter PT_GUARDED_BY(m_bloom_filter_mutex) GUARDED_BY(m_bloom_filter_mutex){nullptr};\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        mutable RecursiveMutex m_tx_inventory_mutex;\n+        CRollingBloomFilter m_tx_inventory_known_filter GUARDED_BY(m_tx_inventory_mutex){50000, 0.000001};\n         // Set of transaction ids we still have to announce.\n         // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n+        std::set<uint256> m_tx_inventory_to_send;\n         // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        bool m_send_mempool GUARDED_BY(m_tx_inventory_mutex){false};\n         // Last time a \"MEMPOOL\" request was serviced.\n         std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+        std::chrono::microseconds m_next_inv_send_time{0};\n \n         /** Minimum fee rate with which to filter inv's to this node */\n-        std::atomic<CAmount> minFeeFilter{0};\n-        CAmount lastSentFeeFilter{0};\n+        std::atomic<CAmount> m_fee_filter_received{0};\n+        CAmount m_fee_filter_sent{0};\n         std::chrono::microseconds m_next_send_feefilter{0};\n     };\n \n@@ -837,8 +837,8 @@ static void PushAddress(Peer& peer, const CAddress& addr, FastRandomContext& ins\n static void AddKnownTx(Peer& peer, const uint256& hash)\n {\n     if (peer.m_tx_relay != nullptr) {\n-        LOCK(peer.m_tx_relay->cs_tx_inventory);\n-        peer.m_tx_relay->filterInventoryKnown.insert(hash);\n+        LOCK(peer.m_tx_relay->m_tx_inventory_mutex);\n+        peer.m_tx_relay->m_tx_inventory_known_filter.insert(hash);\n     }\n }\n \n@@ -1333,11 +1333,11 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) c\n     }\n \n     if (peer->m_tx_relay != nullptr) {\n-        stats.fRelayTxes = WITH_LOCK(peer->m_tx_relay->cs_filter, return peer->m_tx_relay->fRelayTxes);\n-        stats.minFeeFilter = peer->m_tx_relay->minFeeFilter.load();\n+        stats.m_relay_txs = WITH_LOCK(peer->m_tx_relay->m_bloom_filter_mutex, return peer->m_tx_relay->m_relay_txs);\n+        stats.m_fee_filter_received = peer->m_tx_relay->m_fee_filter_received.load();\n     } else {\n-        stats.fRelayTxes = false;\n-        stats.minFeeFilter = 0;\n+        stats.m_relay_txs = false;\n+        stats.m_fee_filter_received = 0;\n     }\n \n     stats.m_ping_wait = ping_wait;\n@@ -1722,9 +1722,9 @@ void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid\n         if (!peer.m_tx_relay) continue;\n \n         const uint256& hash{peer.m_wtxid_relay ? wtxid : txid};\n-        LOCK(peer.m_tx_relay->cs_tx_inventory);\n-        if (!peer.m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            peer.m_tx_relay->setInventoryTxToSend.insert(hash);\n+        LOCK(peer.m_tx_relay->m_tx_inventory_mutex);\n+        if (!peer.m_tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n+            peer.m_tx_relay->m_tx_inventory_to_send.insert(hash);\n         }\n     };\n }\n@@ -1871,10 +1871,10 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n             bool sendMerkleBlock = false;\n             CMerkleBlock merkleBlock;\n             if (peer.m_tx_relay != nullptr) {\n-                LOCK(peer.m_tx_relay->cs_filter);\n-                if (peer.m_tx_relay->pfilter) {\n+                LOCK(peer.m_tx_relay->m_bloom_filter_mutex);\n+                if (peer.m_tx_relay->m_bloom_filter) {\n                     sendMerkleBlock = true;\n-                    merkleBlock = CMerkleBlock(*pblock, *peer.m_tx_relay->pfilter);\n+                    merkleBlock = CMerkleBlock(*pblock, *peer.m_tx_relay->m_bloom_filter);\n                 }\n             }\n             if (sendMerkleBlock) {\n@@ -2005,7 +2005,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n             }\n             for (const uint256& parent_txid : parent_ids_to_add) {\n                 // Relaying a transaction with a recent but unconfirmed parent.\n-                if (WITH_LOCK(peer.m_tx_relay->cs_tx_inventory, return !peer.m_tx_relay->filterInventoryKnown.contains(parent_txid))) {\n+                if (WITH_LOCK(peer.m_tx_relay->m_tx_inventory_mutex, return !peer.m_tx_relay->m_tx_inventory_known_filter.contains(parent_txid))) {\n                     LOCK(cs_main);\n                     State(pfrom.GetId())->m_recently_announced_invs.insert(parent_txid);\n                 }\n@@ -2640,8 +2640,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         pfrom.m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n         if (peer->m_tx_relay != nullptr) {\n-            LOCK(peer->m_tx_relay->cs_filter);\n-            peer->m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n+            LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+            peer->m_tx_relay->m_relay_txs = fRelay; // set to true after we get the first filter* message\n             if (fRelay) pfrom.m_relays_txs = true;\n         }\n \n@@ -3253,7 +3253,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const uint256& hash = peer->m_wtxid_relay ? wtxid : txid;\n         AddKnownTx(*peer, hash);\n         if (peer->m_wtxid_relay && txid != wtxid) {\n-            // Insert txid into filterInventoryKnown, even for\n+            // Insert txid into m_tx_inventory_known_filter, even for\n             // wtxidrelay peers. This prevents re-adding of\n             // unconfirmed parents to the recently_announced\n             // filter, when a child tx is requested. See\n@@ -3846,8 +3846,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         if (peer->m_tx_relay != nullptr) {\n-            LOCK(peer->m_tx_relay->cs_tx_inventory);\n-            peer->m_tx_relay->fSendMempool = true;\n+            LOCK(peer->m_tx_relay->m_tx_inventory_mutex);\n+            peer->m_tx_relay->m_send_mempool = true;\n         }\n         return;\n     }\n@@ -3943,10 +3943,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n         else if (peer->m_tx_relay != nullptr)\n         {\n-            LOCK(peer->m_tx_relay->cs_filter);\n-            peer->m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n+            LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+            peer->m_tx_relay->m_bloom_filter.reset(new CBloomFilter(filter));\n             pfrom.m_bloom_filter_loaded = true;\n-            peer->m_tx_relay->fRelayTxes = true;\n+            peer->m_tx_relay->m_relay_txs = true;\n             pfrom.m_relays_txs = true;\n         }\n         return;\n@@ -3967,9 +3967,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n         } else if (peer->m_tx_relay != nullptr) {\n-            LOCK(peer->m_tx_relay->cs_filter);\n-            if (peer->m_tx_relay->pfilter) {\n-                peer->m_tx_relay->pfilter->insert(vData);\n+            LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+            if (peer->m_tx_relay->m_bloom_filter) {\n+                peer->m_tx_relay->m_bloom_filter->insert(vData);\n             } else {\n                 bad = true;\n             }\n@@ -3989,10 +3989,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (peer->m_tx_relay == nullptr) {\n             return;\n         }\n-        LOCK(peer->m_tx_relay->cs_filter);\n-        peer->m_tx_relay->pfilter = nullptr;\n+        LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+        peer->m_tx_relay->m_bloom_filter = nullptr;\n         pfrom.m_bloom_filter_loaded = false;\n-        peer->m_tx_relay->fRelayTxes = true;\n+        peer->m_tx_relay->m_relay_txs = true;\n         pfrom.m_relays_txs = true;\n         return;\n     }\n@@ -4002,7 +4002,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n             if (peer->m_tx_relay != nullptr) {\n-                peer->m_tx_relay->minFeeFilter = newFeeFilter;\n+                peer->m_tx_relay->m_fee_filter_received = newFeeFilter;\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom.GetId());\n         }\n@@ -4479,7 +4479,7 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, Peer& peer, std::chrono::mi\n         currentFilter = MAX_MONEY;\n     } else {\n         static const CAmount MAX_FILTER{g_filter_rounder.round(MAX_MONEY)};\n-        if (peer.m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n+        if (peer.m_tx_relay->m_fee_filter_sent == MAX_FILTER) {\n             // Send the current filter if we sent MAX_FILTER previously\n             // and made it out of IBD.\n             peer.m_tx_relay->m_next_send_feefilter = 0us;\n@@ -4489,16 +4489,16 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, Peer& peer, std::chrono::mi\n         CAmount filterToSend = g_filter_rounder.round(currentFilter);\n         // We always have a fee filter of at least minRelayTxFee\n         filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-        if (filterToSend != peer.m_tx_relay->lastSentFeeFilter) {\n+        if (filterToSend != peer.m_tx_relay->m_fee_filter_sent) {\n             m_connman.PushMessage(&pto, CNetMsgMaker(pto.GetCommonVersion()).Make(NetMsgType::FEEFILTER, filterToSend));\n-            peer.m_tx_relay->lastSentFeeFilter = filterToSend;\n+            peer.m_tx_relay->m_fee_filter_sent = filterToSend;\n         }\n         peer.m_tx_relay->m_next_send_feefilter = PoissonNextSend(current_time, AVG_FEEFILTER_BROADCAST_INTERVAL);\n     }\n     // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n     // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n     else if (current_time + MAX_FEEFILTER_CHANGE_DELAY < peer.m_tx_relay->m_next_send_feefilter &&\n-                (currentFilter < 3 * peer.m_tx_relay->lastSentFeeFilter / 4 || currentFilter > 4 * peer.m_tx_relay->lastSentFeeFilter / 3)) {\n+                (currentFilter < 3 * peer.m_tx_relay->m_fee_filter_sent / 4 || currentFilter > 4 * peer.m_tx_relay->m_fee_filter_sent / 3)) {\n         peer.m_tx_relay->m_next_send_feefilter = current_time + GetRandomDuration<std::chrono::microseconds>(MAX_FEEFILTER_CHANGE_DELAY);\n     }\n }\n@@ -4767,44 +4767,44 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         }\n \n         if (peer->m_tx_relay != nullptr) {\n-                LOCK(peer->m_tx_relay->cs_tx_inventory);\n+                LOCK(peer->m_tx_relay->m_tx_inventory_mutex);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n-                if (peer->m_tx_relay->nNextInvSend < current_time) {\n+                if (peer->m_tx_relay->m_next_inv_send_time < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        peer->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        peer->m_tx_relay->m_next_inv_send_time = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     } else {\n-                        peer->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        peer->m_tx_relay->m_next_inv_send_time = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     }\n                 }\n \n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n-                    LOCK(peer->m_tx_relay->cs_filter);\n-                    if (!peer->m_tx_relay->fRelayTxes) peer->m_tx_relay->setInventoryTxToSend.clear();\n+                    LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+                    if (!peer->m_tx_relay->m_relay_txs) peer->m_tx_relay->m_tx_inventory_to_send.clear();\n                 }\n \n                 // Respond to BIP35 mempool requests\n-                if (fSendTrickle && peer->m_tx_relay->fSendMempool) {\n+                if (fSendTrickle && peer->m_tx_relay->m_send_mempool) {\n                     auto vtxinfo = m_mempool.infoAll();\n-                    peer->m_tx_relay->fSendMempool = false;\n-                    const CFeeRate filterrate{peer->m_tx_relay->minFeeFilter.load()};\n+                    peer->m_tx_relay->m_send_mempool = false;\n+                    const CFeeRate filterrate{peer->m_tx_relay->m_fee_filter_received.load()};\n \n-                    LOCK(peer->m_tx_relay->cs_filter);\n+                    LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n \n                     for (const auto& txinfo : vtxinfo) {\n                         const uint256& hash = peer->m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n                         CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n-                        peer->m_tx_relay->setInventoryTxToSend.erase(hash);\n+                        peer->m_tx_relay->m_tx_inventory_to_send.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (peer->m_tx_relay->pfilter) {\n-                            if (!peer->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (peer->m_tx_relay->m_bloom_filter) {\n+                            if (!peer->m_tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         }\n-                        peer->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        peer->m_tx_relay->m_tx_inventory_known_filter.insert(hash);\n                         // Responses to MEMPOOL requests bypass the m_recently_announced_invs filter.\n                         vInv.push_back(inv);\n                         if (vInv.size() == MAX_INV_SZ) {\n@@ -4819,19 +4819,19 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 if (fSendTrickle) {\n                     // Produce a vector with all candidates for sending\n                     std::vector<std::set<uint256>::iterator> vInvTx;\n-                    vInvTx.reserve(peer->m_tx_relay->setInventoryTxToSend.size());\n-                    for (std::set<uint256>::iterator it = peer->m_tx_relay->setInventoryTxToSend.begin(); it != peer->m_tx_relay->setInventoryTxToSend.end(); it++) {\n+                    vInvTx.reserve(peer->m_tx_relay->m_tx_inventory_to_send.size());\n+                    for (std::set<uint256>::iterator it = peer->m_tx_relay->m_tx_inventory_to_send.begin(); it != peer->m_tx_relay->m_tx_inventory_to_send.end(); it++) {\n                         vInvTx.push_back(it);\n                     }\n-                    const CFeeRate filterrate{peer->m_tx_relay->minFeeFilter.load()};\n+                    const CFeeRate filterrate{peer->m_tx_relay->m_fee_filter_received.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n                     CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, peer->m_wtxid_relay);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n                     unsigned int nRelayedTransactions = 0;\n-                    LOCK(peer->m_tx_relay->cs_filter);\n+                    LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n@@ -4840,9 +4840,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         uint256 hash = *it;\n                         CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n-                        peer->m_tx_relay->setInventoryTxToSend.erase(it);\n+                        peer->m_tx_relay->m_tx_inventory_to_send.erase(it);\n                         // Check if not in the filter already\n-                        if (peer->m_tx_relay->filterInventoryKnown.contains(hash)) {\n+                        if (peer->m_tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n@@ -4856,7 +4856,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (peer->m_tx_relay->pfilter && !peer->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (peer->m_tx_relay->m_bloom_filter && !peer->m_tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n                         vInv.push_back(inv);\n@@ -4883,14 +4883,14 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n-                        peer->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        peer->m_tx_relay->m_tx_inventory_known_filter.insert(hash);\n                         if (hash != txid) {\n-                            // Insert txid into filterInventoryKnown, even for\n+                            // Insert txid into m_tx_inventory_known_filter, even for\n                             // wtxidrelay peers. This prevents re-adding of\n                             // unconfirmed parents to the recently_announced\n                             // filter, when a child tx is requested. See\n                             // ProcessGetData().\n-                            peer->m_tx_relay->filterInventoryKnown.insert(txid);\n+                            peer->m_tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n                 }"
      },
      {
        "sha": "2b54adee51fbd1c3b3e4e15948dd630b88064c42",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -29,8 +29,8 @@ struct CNodeStateStats {\n     int m_starting_height = -1;\n     std::chrono::microseconds m_ping_wait;\n     std::vector<int> vHeightInFlight;\n-    bool fRelayTxes;\n-    CAmount minFeeFilter;\n+    bool m_relay_txs;\n+    CAmount m_fee_filter_received;\n     uint64_t m_addr_processed = 0;\n     uint64_t m_addr_rate_limited = 0;\n     bool m_addr_relay_enabled{false};"
      },
      {
        "sha": "f6f7a2f4c6eb0498df5172e2f4efc323c112c3e8",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -1210,7 +1210,7 @@ void RPCConsole::updateDetailWidget()\n         }\n         ui->peerHeight->setText(QString::number(stats->nodeStateStats.m_starting_height));\n         ui->peerPingWait->setText(GUIUtil::formatPingTime(stats->nodeStateStats.m_ping_wait));\n-        ui->peerRelayTxes->setText(stats->nodeStateStats.fRelayTxes ? ts.yes : ts.no);\n+        ui->peerRelayTxes->setText(stats->nodeStateStats.m_relay_txs ? ts.yes : ts.no);\n     }\n \n     ui->peersTabRightPanel->show();"
      },
      {
        "sha": "a4dc4fba01024b8ce5241ca5f3e6a957baaed168",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -244,8 +244,8 @@ static RPCHelpMan getpeerinfo()\n                 heights.push_back(height);\n             }\n             obj.pushKV(\"inflight\", heights);\n-            obj.pushKV(\"relaytxes\", statestats.fRelayTxes);\n-            obj.pushKV(\"minfeefilter\", ValueFromAmount(statestats.minFeeFilter));\n+            obj.pushKV(\"relaytxes\", statestats.m_relay_txs);\n+            obj.pushKV(\"minfeefilter\", ValueFromAmount(statestats.m_fee_filter_received));\n             obj.pushKV(\"addr_relay_enabled\", statestats.m_addr_relay_enabled);\n             obj.pushKV(\"addr_processed\", statestats.m_addr_processed);\n             obj.pushKV(\"addr_rate_limited\", statestats.m_addr_rate_limited);"
      },
      {
        "sha": "161dfd64fa8b9f7b332cebb7c7de5777dcb2f28a",
        "filename": "src/test/fuzz/node_eviction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/test/fuzz/node_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/test/fuzz/node_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/node_eviction.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -26,7 +26,7 @@ FUZZ_TARGET(node_eviction)\n             /* nLastBlockTime */ fuzzed_data_provider.ConsumeIntegral<int64_t>(),\n             /* nLastTXTime */ fuzzed_data_provider.ConsumeIntegral<int64_t>(),\n             /* fRelevantServices */ fuzzed_data_provider.ConsumeBool(),\n-            /* fRelayTxes */ fuzzed_data_provider.ConsumeBool(),\n+            /* m_relay_txs */ fuzzed_data_provider.ConsumeBool(),\n             /* fBloomFilter */ fuzzed_data_provider.ConsumeBool(),\n             /* nKeyedNetGroup */ fuzzed_data_provider.ConsumeIntegral<uint64_t>(),\n             /* prefer_evict */ fuzzed_data_provider.ConsumeBool(),"
      },
      {
        "sha": "604683ccb2603ad3610373643d9c9112c105f2ac",
        "filename": "src/test/net_peer_eviction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/test/net_peer_eviction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/test/net_peer_eviction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_peer_eviction_tests.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -494,7 +494,7 @@ BOOST_AUTO_TEST_CASE(peer_eviction_test)\n                         number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n                             candidate.nLastBlockTime = number_of_nodes - candidate.id;\n                             if (candidate.id <= 7) {\n-                                candidate.fRelayTxes = false;\n+                                candidate.m_relay_txs = false;\n                                 candidate.fRelevantServices = true;\n                             }\n                         },\n@@ -513,7 +513,7 @@ BOOST_AUTO_TEST_CASE(peer_eviction_test)\n                         number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n                             candidate.nLastBlockTime = number_of_nodes - candidate.id;\n                             if (candidate.id <= 7) {\n-                                candidate.fRelayTxes = false;\n+                                candidate.m_relay_txs = false;\n                                 candidate.fRelevantServices = true;\n                             }\n                         },"
      },
      {
        "sha": "7d44f783fa10e4f0d502eafdd48ea2ec7f0c46be",
        "filename": "src/test/util/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/test/util/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/src/test/util/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.cpp?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -52,7 +52,7 @@ std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(int n_candida\n             /* nLastBlockTime */ static_cast<int64_t>(random_context.randrange(100)),\n             /* nLastTXTime */ static_cast<int64_t>(random_context.randrange(100)),\n             /* fRelevantServices */ random_context.randbool(),\n-            /* fRelayTxes */ random_context.randbool(),\n+            /* m_relay_txs */ random_context.randbool(),\n             /* fBloomFilter */ random_context.randbool(),\n             /* nKeyedNetGroup */ random_context.randrange(100),\n             /* prefer_evict */ random_context.randbool(),"
      },
      {
        "sha": "c5f5a2bb44a8572dcd11d2bd69de66bcbcf91270",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -94,7 +94,7 @@ def blocks_relay_conn_tests(self):\n \n         self.nodes[0].sendrawtransaction(tx_hex)\n \n-        # Bump time forward to ensure nNextInvSend timer pops\n+        # Bump time forward to ensure m_next_inv_send_time timer pops\n         self.nodes[0].setmocktime(int(time.time()) + 60)\n \n         conn.sync_send_with_ping()"
      },
      {
        "sha": "a3ee7dd17a04944c48fd2b1761f7c5d90a32bbf4",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dfefec249302cd9d9f121fe081a9a51294d0ab/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dfefec249302cd9d9f121fe081a9a51294d0ab/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "patch": "@@ -38,7 +38,7 @@ def run_test(self):\n         # Can take a few seconds due to transaction trickling\n         peer_first.wait_for_broadcast([txid])\n \n-        # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)\n+        # Add a second peer since txs aren't rebroadcast to the same peer (see m_tx_inventory_known_filter)\n         peer_second = node.add_p2p_connection(P2PTxInvStore())\n \n         self.log.info(\"Create a block\")"
      }
    ]
  },
  {
    "sha": "b443ceb7c2c3629b8981620900dffbe894fd43fa",
    "node_id": "C_kwDOABII59oAKGI0NDNjZWI3YzJjMzYyOWI4OTgxNjIwOTAwZGZmYmU4OTRmZDQzZmE",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-16T12:49:50Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:48:11Z"
      },
      "message": "[net processing] Comment all TxRelay members\n\nThis fully comments all the TxRelay members. The only significant change\nis to the comment for m_relay_txs. Previously the comment stated that\none of the purposes of the field was that \"We don't relay tx invs before\nreceiving the peer's version message\". However, even without the\nm_relay_txs flag, we would not send transactions to the peer before\nreceiving the `version` message, since SendMessages() returns\nimmediately if fSuccessfullyConnected is not set to true, which only\nhappens once a `version` and `verack` message have been received.",
      "tree": {
        "sha": "fc8bf79be8bbf766b085665389ee7bfd1c9d18e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc8bf79be8bbf766b085665389ee7bfd1c9d18e4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b443ceb7c2c3629b8981620900dffbe894fd43fa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b443ceb7c2c3629b8981620900dffbe894fd43fa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b443ceb7c2c3629b8981620900dffbe894fd43fa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b443ceb7c2c3629b8981620900dffbe894fd43fa/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dfefec249302cd9d9f121fe081a9a51294d0ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0dfefec249302cd9d9f121fe081a9a51294d0ab"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 26,
      "deletions": 9
    },
    "files": [
      {
        "sha": "c8ec4f68ced88d3a9f22c595c6691e41aa2a1d5b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 9,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b443ceb7c2c3629b8981620900dffbe894fd43fa/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b443ceb7c2c3629b8981620900dffbe894fd43fa/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b443ceb7c2c3629b8981620900dffbe894fd43fa",
        "patch": "@@ -228,28 +228,45 @@ struct Peer {\n     std::atomic<bool> m_wtxid_relay{false};\n \n     struct TxRelay {\n+        /** Protects m_bloom_filter and the m_relay_txs flag. */\n         mutable RecursiveMutex m_bloom_filter_mutex;\n-        // We use m_relay_txs for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n+        /** Whether the peer wishes to receive transaction announements.\n+         *\n+         * This is initially set based on the fRelay flag in the received\n+         * `version` message. If initially set to false, it can only be flipped\n+         * to true if we have offered the peer NODE_BLOOM services and it sends\n+         * us a `filterload` or `filterclear` message. See BIP37. */\n         bool m_relay_txs GUARDED_BY(m_bloom_filter_mutex){false};\n+        /** A bloom filter for which transactions to announce to the peer. See BIP37. */\n         std::unique_ptr<CBloomFilter> m_bloom_filter PT_GUARDED_BY(m_bloom_filter_mutex) GUARDED_BY(m_bloom_filter_mutex){nullptr};\n \n+        /** Protects m_tx_inventory_known and the m_send_mempool flag */\n         mutable RecursiveMutex m_tx_inventory_mutex;\n+        /** A filter of all the txids and wtxids that the peer has announced to\n+         *  us or we have announced to the peer. We use this to avoid announcing\n+         *  the same txid/wtxid to a peer that already has the transaction. */\n         CRollingBloomFilter m_tx_inventory_known_filter GUARDED_BY(m_tx_inventory_mutex){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n+        /** Set of transaction ids we still have to announce (txid for\n+         *  non-wtxid-relay peers, wtxid for wtxid-relay peers). We use the\n+         *  mempool to sort transactions in dependency order before relay, so\n+         *  this does not have to be sorted. */\n         std::set<uint256> m_tx_inventory_to_send;\n-        // Used for BIP35 mempool sending\n+        /** Whether the peer has requested us to send our complete mempool. Only\n+         *  permitted if the peer has NetPermissionFlags::Mempool. See BIP35. */\n         bool m_send_mempool GUARDED_BY(m_tx_inventory_mutex){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n+        /** The last time a BIP35 `mempool` request was serviced. */\n         std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        /** The next time after which we will send an `inv` message containing\n+         *  transaction announcements to this peer. */\n         std::chrono::microseconds m_next_inv_send_time{0};\n \n-        /** Minimum fee rate with which to filter inv's to this node */\n+        /** Minimum fee rate with which to filter transaction announcements to this node. See BIP133. */\n         std::atomic<CAmount> m_fee_filter_received{0};\n+        /** Fee rate below which we requested our peer not send us transaction\n+         *  announcements. It is *not* a p2p protocol violation for the peer to\n+         *  send us transactions with a lower fee rate than this. See BIP133. */\n         CAmount m_fee_filter_sent{0};\n+        /** The next time after which we will send a `feefilter` message to this peer. */\n         std::chrono::microseconds m_next_send_feefilter{0};\n     };\n "
      }
    ]
  },
  {
    "sha": "5b24d8a441e795405512c11e4a4089a5b37b2423",
    "node_id": "C_kwDOABII59oAKDViMjRkOGE0NDFlNzk1NDA1NTEyYzExZTRhNDA4OWE1YjM3YjI0MjM",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-27T08:28:02Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:48:11Z"
      },
      "message": "[net processing] Add m_tx_relay_mutex to protect m_tx_relay ptr",
      "tree": {
        "sha": "a9580fed48355a6989eff01567d26984474497fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a9580fed48355a6989eff01567d26984474497fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b24d8a441e795405512c11e4a4089a5b37b2423",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b24d8a441e795405512c11e4a4089a5b37b2423",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b24d8a441e795405512c11e4a4089a5b37b2423",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b24d8a441e795405512c11e4a4089a5b37b2423/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b443ceb7c2c3629b8981620900dffbe894fd43fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b443ceb7c2c3629b8981620900dffbe894fd43fa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b443ceb7c2c3629b8981620900dffbe894fd43fa"
      }
    ],
    "stats": {
      "total": 173,
      "additions": 93,
      "deletions": 80
    },
    "files": [
      {
        "sha": "2425c4eeaad067e8a8772cf5f7a062f60f7b4ac0",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 80,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b24d8a441e795405512c11e4a4089a5b37b2423/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b24d8a441e795405512c11e4a4089a5b37b2423/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5b24d8a441e795405512c11e4a4089a5b37b2423",
        "patch": "@@ -270,9 +270,18 @@ struct Peer {\n         std::chrono::microseconds m_next_send_feefilter{0};\n     };\n \n+    /** protects m_tx_relay */\n+    Mutex m_tx_relay_mutex;\n+\n     /** Transaction relay data. Will be a nullptr if we're not relaying\n-     *  transactions with this peer (e.g. if it's a block-relay-only peer) */\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+     *  transactions with this peer (e.g. if it's a block-relay-only peer).\n+     *  Users should access this with the GetTxRelay() getter. */\n+    std::unique_ptr<TxRelay> m_tx_relay GUARDED_BY(m_tx_relay_mutex);\n+\n+    TxRelay* GetTxRelay()\n+    {\n+        return WITH_LOCK(m_tx_relay_mutex, return m_tx_relay.get());\n+    };\n \n     /** A vector of addresses to send to the peer, limited to MAX_ADDR_TO_SEND. */\n     std::vector<CAddress> m_addrs_to_send;\n@@ -853,10 +862,11 @@ static void PushAddress(Peer& peer, const CAddress& addr, FastRandomContext& ins\n \n static void AddKnownTx(Peer& peer, const uint256& hash)\n {\n-    if (peer.m_tx_relay != nullptr) {\n-        LOCK(peer.m_tx_relay->m_tx_inventory_mutex);\n-        peer.m_tx_relay->m_tx_inventory_known_filter.insert(hash);\n-    }\n+    auto tx_relay = peer.GetTxRelay();\n+    if (!tx_relay) return;\n+\n+    LOCK(tx_relay->m_tx_inventory_mutex);\n+    tx_relay->m_tx_inventory_known_filter.insert(hash);\n }\n \n static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -1349,9 +1359,9 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) c\n         ping_wait = GetTime<std::chrono::microseconds>() - peer->m_ping_start.load();\n     }\n \n-    if (peer->m_tx_relay != nullptr) {\n-        stats.m_relay_txs = WITH_LOCK(peer->m_tx_relay->m_bloom_filter_mutex, return peer->m_tx_relay->m_relay_txs);\n-        stats.m_fee_filter_received = peer->m_tx_relay->m_fee_filter_received.load();\n+    if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n+        stats.m_relay_txs = WITH_LOCK(tx_relay->m_bloom_filter_mutex, return tx_relay->m_relay_txs);\n+        stats.m_fee_filter_received = tx_relay->m_fee_filter_received.load();\n     } else {\n         stats.m_relay_txs = false;\n         stats.m_fee_filter_received = 0;\n@@ -1736,12 +1746,13 @@ void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid\n     LOCK(m_peer_mutex);\n     for(auto& it : m_peer_map) {\n         Peer& peer = *it.second;\n-        if (!peer.m_tx_relay) continue;\n+        auto tx_relay = peer.GetTxRelay();\n+        if (!tx_relay) continue;\n \n         const uint256& hash{peer.m_wtxid_relay ? wtxid : txid};\n-        LOCK(peer.m_tx_relay->m_tx_inventory_mutex);\n-        if (!peer.m_tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n-            peer.m_tx_relay->m_tx_inventory_to_send.insert(hash);\n+        LOCK(tx_relay->m_tx_inventory_mutex);\n+        if (!tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n+            tx_relay->m_tx_inventory_to_send.insert(hash);\n         }\n     };\n }\n@@ -1887,11 +1898,11 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n         } else if (inv.IsMsgFilteredBlk()) {\n             bool sendMerkleBlock = false;\n             CMerkleBlock merkleBlock;\n-            if (peer.m_tx_relay != nullptr) {\n-                LOCK(peer.m_tx_relay->m_bloom_filter_mutex);\n-                if (peer.m_tx_relay->m_bloom_filter) {\n+            if (auto tx_relay = peer.GetTxRelay(); tx_relay != nullptr) {\n+                LOCK(tx_relay->m_bloom_filter_mutex);\n+                if (tx_relay->m_bloom_filter) {\n                     sendMerkleBlock = true;\n-                    merkleBlock = CMerkleBlock(*pblock, *peer.m_tx_relay->m_bloom_filter);\n+                    merkleBlock = CMerkleBlock(*pblock, *tx_relay->m_bloom_filter);\n                 }\n             }\n             if (sendMerkleBlock) {\n@@ -1974,14 +1985,16 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n {\n     AssertLockNotHeld(cs_main);\n \n+    auto tx_relay = peer.GetTxRelay();\n+\n     std::deque<CInv>::iterator it = peer.m_getdata_requests.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n \n     const std::chrono::seconds now = GetTime<std::chrono::seconds>();\n     // Get last mempool request time\n-    const std::chrono::seconds mempool_req = peer.m_tx_relay != nullptr ? peer.m_tx_relay->m_last_mempool_req.load()\n-                                                                        : std::chrono::seconds::min();\n+    const std::chrono::seconds mempool_req = tx_relay != nullptr ? tx_relay->m_last_mempool_req.load()\n+                                                                 : std::chrono::seconds::min();\n \n     // Process as many TX items from the front of the getdata queue as\n     // possible, since they're common and it's efficient to batch process\n@@ -1994,7 +2007,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n \n         const CInv &inv = *it++;\n \n-        if (peer.m_tx_relay == nullptr) {\n+        if (tx_relay == nullptr) {\n             // Ignore GETDATA requests for transactions from blocks-only peers.\n             continue;\n         }\n@@ -2022,7 +2035,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n             }\n             for (const uint256& parent_txid : parent_ids_to_add) {\n                 // Relaying a transaction with a recent but unconfirmed parent.\n-                if (WITH_LOCK(peer.m_tx_relay->m_tx_inventory_mutex, return !peer.m_tx_relay->m_tx_inventory_known_filter.contains(parent_txid))) {\n+                if (WITH_LOCK(tx_relay->m_tx_inventory_mutex, return !tx_relay->m_tx_inventory_known_filter.contains(parent_txid))) {\n                     LOCK(cs_main);\n                     State(pfrom.GetId())->m_recently_announced_invs.insert(parent_txid);\n                 }\n@@ -2656,7 +2669,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n         pfrom.m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n-        if (peer->m_tx_relay != nullptr) {\n+        {\n+            LOCK(peer->m_tx_relay_mutex);\n             LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n             peer->m_tx_relay->m_relay_txs = fRelay; // set to true after we get the first filter* message\n             if (fRelay) pfrom.m_relays_txs = true;\n@@ -2977,7 +2991,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // Reject tx INVs when the -blocksonly setting is enabled, or this is a\n         // block-relay-only peer\n-        bool reject_tx_invs{m_ignore_incoming_txs || (peer->m_tx_relay == nullptr)};\n+        bool reject_tx_invs{m_ignore_incoming_txs || (peer->GetTxRelay() == nullptr)};\n \n         // Allow peers with relay permission to send data other than blocks in blocks only mode\n         if (pfrom.HasPermission(NetPermissionFlags::Relay)) {\n@@ -3254,7 +3268,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // Stop processing the transaction early if\n         // 1) We are in blocks only mode and peer has no relay permission\n         // 2) This peer is a block-relay-only peer\n-        if ((m_ignore_incoming_txs && !pfrom.HasPermission(NetPermissionFlags::Relay)) || (peer->m_tx_relay == nullptr)) {\n+        if ((m_ignore_incoming_txs && !pfrom.HasPermission(NetPermissionFlags::Relay)) || (peer->GetTxRelay() == nullptr)) {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n             return;\n@@ -3862,9 +3876,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (peer->m_tx_relay != nullptr) {\n-            LOCK(peer->m_tx_relay->m_tx_inventory_mutex);\n-            peer->m_tx_relay->m_send_mempool = true;\n+        if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n+            LOCK(tx_relay->m_tx_inventory_mutex);\n+            tx_relay->m_send_mempool = true;\n         }\n         return;\n     }\n@@ -3957,13 +3971,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n             // There is no excuse for sending a too-large filter\n             Misbehaving(pfrom.GetId(), 100, \"too-large bloom filter\");\n-        }\n-        else if (peer->m_tx_relay != nullptr)\n-        {\n-            LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n-            peer->m_tx_relay->m_bloom_filter.reset(new CBloomFilter(filter));\n+        } else if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n+            LOCK(tx_relay->m_bloom_filter_mutex);\n+            tx_relay->m_bloom_filter.reset(new CBloomFilter(filter));\n             pfrom.m_bloom_filter_loaded = true;\n-            peer->m_tx_relay->m_relay_txs = true;\n+            tx_relay->m_relay_txs = true;\n             pfrom.m_relays_txs = true;\n         }\n         return;\n@@ -3983,10 +3995,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         bool bad = false;\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n-        } else if (peer->m_tx_relay != nullptr) {\n-            LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n-            if (peer->m_tx_relay->m_bloom_filter) {\n-                peer->m_tx_relay->m_bloom_filter->insert(vData);\n+        } else if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n+            LOCK(tx_relay->m_bloom_filter_mutex);\n+            if (tx_relay->m_bloom_filter) {\n+                tx_relay->m_bloom_filter->insert(vData);\n             } else {\n                 bad = true;\n             }\n@@ -4003,13 +4015,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             pfrom.fDisconnect = true;\n             return;\n         }\n-        if (peer->m_tx_relay == nullptr) {\n-            return;\n-        }\n-        LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n-        peer->m_tx_relay->m_bloom_filter = nullptr;\n+        auto tx_relay = peer->GetTxRelay();\n+        if (!tx_relay) return;\n+\n+        LOCK(tx_relay->m_bloom_filter_mutex);\n+        tx_relay->m_bloom_filter = nullptr;\n         pfrom.m_bloom_filter_loaded = false;\n-        peer->m_tx_relay->m_relay_txs = true;\n+        tx_relay->m_relay_txs = true;\n         pfrom.m_relays_txs = true;\n         return;\n     }\n@@ -4018,8 +4030,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n-            if (peer->m_tx_relay != nullptr) {\n-                peer->m_tx_relay->m_fee_filter_received = newFeeFilter;\n+            if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n+                tx_relay->m_fee_filter_received = newFeeFilter;\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom.GetId());\n         }\n@@ -4482,7 +4494,8 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, Peer& peer, std::chrono::mi\n     AssertLockHeld(cs_main);\n \n     if (m_ignore_incoming_txs) return;\n-    if (!peer.m_tx_relay) return;\n+    auto tx_relay = peer.GetTxRelay();\n+    if (!tx_relay) return;\n     if (pto.GetCommonVersion() < FEEFILTER_VERSION) return;\n     // peers with the forcerelay permission should not filter txs to us\n     if (pto.HasPermission(NetPermissionFlags::ForceRelay)) return;\n@@ -4496,27 +4509,27 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, Peer& peer, std::chrono::mi\n         currentFilter = MAX_MONEY;\n     } else {\n         static const CAmount MAX_FILTER{g_filter_rounder.round(MAX_MONEY)};\n-        if (peer.m_tx_relay->m_fee_filter_sent == MAX_FILTER) {\n+        if (tx_relay->m_fee_filter_sent == MAX_FILTER) {\n             // Send the current filter if we sent MAX_FILTER previously\n             // and made it out of IBD.\n-            peer.m_tx_relay->m_next_send_feefilter = 0us;\n+            tx_relay->m_next_send_feefilter = 0us;\n         }\n     }\n-    if (current_time > peer.m_tx_relay->m_next_send_feefilter) {\n+    if (current_time > tx_relay->m_next_send_feefilter) {\n         CAmount filterToSend = g_filter_rounder.round(currentFilter);\n         // We always have a fee filter of at least minRelayTxFee\n         filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-        if (filterToSend != peer.m_tx_relay->m_fee_filter_sent) {\n+        if (filterToSend != tx_relay->m_fee_filter_sent) {\n             m_connman.PushMessage(&pto, CNetMsgMaker(pto.GetCommonVersion()).Make(NetMsgType::FEEFILTER, filterToSend));\n-            peer.m_tx_relay->m_fee_filter_sent = filterToSend;\n+            tx_relay->m_fee_filter_sent = filterToSend;\n         }\n-        peer.m_tx_relay->m_next_send_feefilter = PoissonNextSend(current_time, AVG_FEEFILTER_BROADCAST_INTERVAL);\n+        tx_relay->m_next_send_feefilter = PoissonNextSend(current_time, AVG_FEEFILTER_BROADCAST_INTERVAL);\n     }\n     // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n     // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n-    else if (current_time + MAX_FEEFILTER_CHANGE_DELAY < peer.m_tx_relay->m_next_send_feefilter &&\n-                (currentFilter < 3 * peer.m_tx_relay->m_fee_filter_sent / 4 || currentFilter > 4 * peer.m_tx_relay->m_fee_filter_sent / 3)) {\n-        peer.m_tx_relay->m_next_send_feefilter = current_time + GetRandomDuration<std::chrono::microseconds>(MAX_FEEFILTER_CHANGE_DELAY);\n+    else if (current_time + MAX_FEEFILTER_CHANGE_DELAY < tx_relay->m_next_send_feefilter &&\n+                (currentFilter < 3 * tx_relay->m_fee_filter_sent / 4 || currentFilter > 4 * tx_relay->m_fee_filter_sent / 3)) {\n+        tx_relay->m_next_send_feefilter = current_time + GetRandomDuration<std::chrono::microseconds>(MAX_FEEFILTER_CHANGE_DELAY);\n     }\n }\n \n@@ -4783,72 +4796,72 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             peer->m_blocks_for_inv_relay.clear();\n         }\n \n-        if (peer->m_tx_relay != nullptr) {\n-                LOCK(peer->m_tx_relay->m_tx_inventory_mutex);\n+        if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n+                LOCK(tx_relay->m_tx_inventory_mutex);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n-                if (peer->m_tx_relay->m_next_inv_send_time < current_time) {\n+                if (tx_relay->m_next_inv_send_time < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        peer->m_tx_relay->m_next_inv_send_time = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        tx_relay->m_next_inv_send_time = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     } else {\n-                        peer->m_tx_relay->m_next_inv_send_time = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        tx_relay->m_next_inv_send_time = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     }\n                 }\n \n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n-                    LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n-                    if (!peer->m_tx_relay->m_relay_txs) peer->m_tx_relay->m_tx_inventory_to_send.clear();\n+                    LOCK(tx_relay->m_bloom_filter_mutex);\n+                    if (!tx_relay->m_relay_txs) tx_relay->m_tx_inventory_to_send.clear();\n                 }\n \n                 // Respond to BIP35 mempool requests\n-                if (fSendTrickle && peer->m_tx_relay->m_send_mempool) {\n+                if (fSendTrickle && tx_relay->m_send_mempool) {\n                     auto vtxinfo = m_mempool.infoAll();\n-                    peer->m_tx_relay->m_send_mempool = false;\n-                    const CFeeRate filterrate{peer->m_tx_relay->m_fee_filter_received.load()};\n+                    tx_relay->m_send_mempool = false;\n+                    const CFeeRate filterrate{tx_relay->m_fee_filter_received.load()};\n \n-                    LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+                    LOCK(tx_relay->m_bloom_filter_mutex);\n \n                     for (const auto& txinfo : vtxinfo) {\n                         const uint256& hash = peer->m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n                         CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n-                        peer->m_tx_relay->m_tx_inventory_to_send.erase(hash);\n+                        tx_relay->m_tx_inventory_to_send.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (peer->m_tx_relay->m_bloom_filter) {\n-                            if (!peer->m_tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (tx_relay->m_bloom_filter) {\n+                            if (!tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         }\n-                        peer->m_tx_relay->m_tx_inventory_known_filter.insert(hash);\n+                        tx_relay->m_tx_inventory_known_filter.insert(hash);\n                         // Responses to MEMPOOL requests bypass the m_recently_announced_invs filter.\n                         vInv.push_back(inv);\n                         if (vInv.size() == MAX_INV_SZ) {\n                             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n                     }\n-                    peer->m_tx_relay->m_last_mempool_req = std::chrono::duration_cast<std::chrono::seconds>(current_time);\n+                    tx_relay->m_last_mempool_req = std::chrono::duration_cast<std::chrono::seconds>(current_time);\n                 }\n \n                 // Determine transactions to relay\n                 if (fSendTrickle) {\n                     // Produce a vector with all candidates for sending\n                     std::vector<std::set<uint256>::iterator> vInvTx;\n-                    vInvTx.reserve(peer->m_tx_relay->m_tx_inventory_to_send.size());\n-                    for (std::set<uint256>::iterator it = peer->m_tx_relay->m_tx_inventory_to_send.begin(); it != peer->m_tx_relay->m_tx_inventory_to_send.end(); it++) {\n+                    vInvTx.reserve(tx_relay->m_tx_inventory_to_send.size());\n+                    for (std::set<uint256>::iterator it = tx_relay->m_tx_inventory_to_send.begin(); it != tx_relay->m_tx_inventory_to_send.end(); it++) {\n                         vInvTx.push_back(it);\n                     }\n-                    const CFeeRate filterrate{peer->m_tx_relay->m_fee_filter_received.load()};\n+                    const CFeeRate filterrate{tx_relay->m_fee_filter_received.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n                     CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, peer->m_wtxid_relay);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n                     unsigned int nRelayedTransactions = 0;\n-                    LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n+                    LOCK(tx_relay->m_bloom_filter_mutex);\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n@@ -4857,9 +4870,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         uint256 hash = *it;\n                         CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n-                        peer->m_tx_relay->m_tx_inventory_to_send.erase(it);\n+                        tx_relay->m_tx_inventory_to_send.erase(it);\n                         // Check if not in the filter already\n-                        if (peer->m_tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n+                        if (tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n@@ -4873,7 +4886,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (peer->m_tx_relay->m_bloom_filter && !peer->m_tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n                         vInv.push_back(inv);\n@@ -4900,14 +4913,14 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n-                        peer->m_tx_relay->m_tx_inventory_known_filter.insert(hash);\n+                        tx_relay->m_tx_inventory_known_filter.insert(hash);\n                         if (hash != txid) {\n                             // Insert txid into m_tx_inventory_known_filter, even for\n                             // wtxidrelay peers. This prevents re-adding of\n                             // unconfirmed parents to the recently_announced\n                             // filter, when a child tx is requested. See\n                             // ProcessGetData().\n-                            peer->m_tx_relay->m_tx_inventory_known_filter.insert(txid);\n+                            tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n                 }"
      }
    ]
  },
  {
    "sha": "c431a74e4bed4b80d943001c992becfeac304633",
    "node_id": "C_kwDOABII59oAKGM0MzFhNzRlNGJlZDRiODBkOTQzMDAxYzk5MmJlY2ZlYWMzMDQ2MzM",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-06T00:50:46Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-22T16:48:11Z"
      },
      "message": "[net processing] Don't initialize TxRelay for non-tx-relay peers.\n\nDelay initializing the TxRelay data structure for a peer until we receive\na version message from that peer. At that point we'll know whether it\nwill ever relay transactions. We only initialize the m_tx_relay\ndata structure if:\n\n- this isn' an outbound block-relay-only connection; AND\n- fRelay=true OR we're not offering NODE_BLOOM to this peer\n  (NODE_BLOOM means that the peer may turn on tx relay later)",
      "tree": {
        "sha": "1bb59616a7ca6f88011acd2fd60279ac11f84068",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1bb59616a7ca6f88011acd2fd60279ac11f84068"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c431a74e4bed4b80d943001c992becfeac304633",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c431a74e4bed4b80d943001c992becfeac304633",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c431a74e4bed4b80d943001c992becfeac304633",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c431a74e4bed4b80d943001c992becfeac304633/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b24d8a441e795405512c11e4a4089a5b37b2423",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b24d8a441e795405512c11e4a4089a5b37b2423",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b24d8a441e795405512c11e4a4089a5b37b2423"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 12,
      "deletions": 6
    },
    "files": [
      {
        "sha": "3023dc60fcf60a78fb499674ed2c2f03cac23608",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c431a74e4bed4b80d943001c992becfeac304633/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c431a74e4bed4b80d943001c992becfeac304633/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c431a74e4bed4b80d943001c992becfeac304633",
        "patch": "@@ -341,9 +341,8 @@ struct Peer {\n     /** Work queue of items requested by this peer **/\n     std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n \n-    explicit Peer(NodeId id, bool tx_relay)\n-        : m_id(id)\n-        , m_tx_relay(tx_relay ? nullptr : std::make_unique<TxRelay>())\n+    Peer(NodeId id)\n+        : m_id{id}\n     {}\n };\n \n@@ -1166,7 +1165,7 @@ void PeerManagerImpl::PushNodeVersion(CNode& pnode, Peer& peer, int64_t nTime)\n     CService addr_you = addr.IsRoutable() && !IsProxy(addr) && addr.IsAddrV1Compatible() ? addr : CService();\n     uint64_t your_services{addr.nServices};\n \n-    const bool tx_relay = !m_ignore_incoming_txs && peer.m_tx_relay != nullptr;\n+    const bool tx_relay = !m_ignore_incoming_txs && !pnode.IsBlockOnlyConn();\n     m_connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, my_services, nTime,\n             your_services, addr_you, // Together the pre-version-31402 serialization of CAddress \"addrYou\" (without nTime)\n             my_services, CService(), // Together the pre-version-31402 serialization of CAddress \"addrMe\" (without nTime)\n@@ -1223,7 +1222,7 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(pnode->IsInboundConn()));\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n-    PeerRef peer = std::make_shared<Peer>(nodeid, pnode->IsBlockOnlyConn());\n+    PeerRef peer = std::make_shared<Peer>(nodeid);\n     {\n         LOCK(m_peer_mutex);\n         m_peer_map.emplace_hint(m_peer_map.end(), nodeid, peer);\n@@ -2669,8 +2668,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n         pfrom.m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n-        {\n+        // We only initialize the m_tx_relay data structure if:\n+        // - this isn't an outbound block-relay-only connection; and\n+        // - fRelay=true or we're offering NODE_BLOOM to this peer\n+        //   (NODE_BLOOM means that the peer may turn on tx relay later)\n+        const bool enable_tx_relay = !pfrom.IsBlockOnlyConn() &&\n+                                      (fRelay || (pfrom.GetLocalServices() & NODE_BLOOM));\n+        if (enable_tx_relay) {\n             LOCK(peer->m_tx_relay_mutex);\n+            if (!peer->m_tx_relay) peer->m_tx_relay = std::make_unique<Peer::TxRelay>();\n             LOCK(peer->m_tx_relay->m_bloom_filter_mutex);\n             peer->m_tx_relay->m_relay_txs = fRelay; // set to true after we get the first filter* message\n             if (fRelay) pfrom.m_relays_txs = true;"
      }
    ]
  }
]