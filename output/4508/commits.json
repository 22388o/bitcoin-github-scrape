[
  {
    "sha": "b069750d3f27c96a83700a08a2bb819902268857",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDY5NzUwZDNmMjdjOTZhODM3MDBhMDhhMmJiODE5OTAyMjY4ODU3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-07-10T18:16:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2014-07-16T19:14:26Z"
      },
      "message": "Break up CAddrMan's IMPLEMENT_SERIALIZE",
      "tree": {
        "sha": "d427feef71fdc1b5a6b336eadaaab940e81f9400",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d427feef71fdc1b5a6b336eadaaab940e81f9400"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b069750d3f27c96a83700a08a2bb819902268857",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b069750d3f27c96a83700a08a2bb819902268857",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b069750d3f27c96a83700a08a2bb819902268857",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b069750d3f27c96a83700a08a2bb819902268857/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87e40799fdebb9f4c3c9d8cc7d071408a4ea768e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87e40799fdebb9f4c3c9d8cc7d071408a4ea768e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87e40799fdebb9f4c3c9d8cc7d071408a4ea768e"
      }
    ],
    "stats": {
      "total": 289,
      "additions": 160,
      "deletions": 129
    },
    "files": [
      {
        "sha": "052d364655fef9b70187d84e8b8e124b8939cbe1",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 131,
        "deletions": 129,
        "changes": 260,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b069750d3f27c96a83700a08a2bb819902268857/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b069750d3f27c96a83700a08a2bb819902268857/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=b069750d3f27c96a83700a08a2bb819902268857",
        "patch": "@@ -245,140 +245,142 @@ class CAddrMan\n     void Connected_(const CService &addr, int64_t nTime);\n \n public:\n+    // serialized format:\n+    // * version byte (currently 0)\n+    // * nKey\n+    // * nNew\n+    // * nTried\n+    // * number of \"new\" buckets\n+    // * all nNew addrinfos in vvNew\n+    // * all nTried addrinfos in vvTried\n+    // * for each bucket:\n+    //   * number of elements\n+    //   * for each element: index\n+    //\n+    // Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n+    // they are instead reconstructed from the other information.\n+    //\n+    // vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n+    // otherwise it is reconstructed as well.\n+    //\n+    // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n+    // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n+    //\n+    // We don't use IMPLEMENT_SERIALIZE since the serialization and deserialization code has\n+    // very little in common.\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersionDummy) const\n+    {\n+        LOCK(cs);\n+\n+        unsigned char nVersion = 0;\n+        s << nVersion;\n+        s << nKey;\n+        s << nNew;\n+        s << nTried;\n+\n+        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n+        s << nUBuckets;\n+        std::map<int, int> mapUnkIds;\n+        int nIds = 0;\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+            if (nIds == nNew) break; // this means nNew was wrong, oh ow\n+            mapUnkIds[(*it).first] = nIds;\n+            const CAddrInfo &info = (*it).second;\n+            if (info.nRefCount) {\n+                s << info;\n+                nIds++;\n+            }\n+        }\n+        nIds = 0;\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+            if (nIds == nTried) break; // this means nTried was wrong, oh ow\n+            const CAddrInfo &info = (*it).second;\n+            if (info.fInTried) {\n+                s << info;\n+                nIds++;\n+            }\n+        }\n+        for (std::vector<std::set<int> >::const_iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n+            const std::set<int> &vNew = (*it);\n+            int nSize = vNew.size();\n+            s << nSize;\n+            for (std::set<int>::const_iterator it2 = vNew.begin(); it2 != vNew.end(); it2++) {\n+                int nIndex = mapUnkIds[*it2];\n+                s << nIndex;\n+            }\n+        }\n+    }\n \n-    IMPLEMENT_SERIALIZE\n-    (({\n-        // serialized format:\n-        // * version byte (currently 0)\n-        // * nKey\n-        // * nNew\n-        // * nTried\n-        // * number of \"new\" buckets\n-        // * all nNew addrinfos in vvNew\n-        // * all nTried addrinfos in vvTried\n-        // * for each bucket:\n-        //   * number of elements\n-        //   * for each element: index\n-        //\n-        // Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n-        // they are instead reconstructed from the other information.\n-        //\n-        // vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n-        // otherwise it is reconstructed as well.\n-        //\n-        // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n-        // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n-        {\n-            LOCK(cs);\n-            unsigned char nVersion = 0;\n-            READWRITE(nVersion);\n-            READWRITE(nKey);\n-            READWRITE(nNew);\n-            READWRITE(nTried);\n-\n-            CAddrMan *am = const_cast<CAddrMan*>(this);\n-            if (fWrite)\n-            {\n-                int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n-                READWRITE(nUBuckets);\n-                std::map<int, int> mapUnkIds;\n-                int nIds = 0;\n-                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n-                {\n-                    if (nIds == nNew) break; // this means nNew was wrong, oh ow\n-                    mapUnkIds[(*it).first] = nIds;\n-                    CAddrInfo &info = (*it).second;\n-                    if (info.nRefCount)\n-                    {\n-                        READWRITE(info);\n-                        nIds++;\n-                    }\n-                }\n-                nIds = 0;\n-                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n-                {\n-                    if (nIds == nTried) break; // this means nTried was wrong, oh ow\n-                    CAddrInfo &info = (*it).second;\n-                    if (info.fInTried)\n-                    {\n-                        READWRITE(info);\n-                        nIds++;\n-                    }\n-                }\n-                for (std::vector<std::set<int> >::iterator it = am->vvNew.begin(); it != am->vvNew.end(); it++)\n-                {\n-                    const std::set<int> &vNew = (*it);\n-                    int nSize = vNew.size();\n-                    READWRITE(nSize);\n-                    for (std::set<int>::iterator it2 = vNew.begin(); it2 != vNew.end(); it2++)\n-                    {\n-                        int nIndex = mapUnkIds[*it2];\n-                        READWRITE(nIndex);\n-                    }\n-                }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersionDummy)\n+    {\n+        LOCK(cs);\n+\n+        unsigned char nVersion;\n+        s >> nVersion;\n+        s >> nKey;\n+        s >> nNew;\n+        s >> nTried;\n+\n+        int nUBuckets = 0;\n+        s >> nUBuckets;\n+        nIdCount = 0;\n+        mapInfo.clear();\n+        mapAddr.clear();\n+        vRandom.clear();\n+        vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n+        vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n+        for (int n = 0; n < nNew; n++) {\n+            CAddrInfo &info = mapInfo[n];\n+            s >> info;\n+            mapAddr[info] = n;\n+            info.nRandomPos = vRandom.size();\n+            vRandom.push_back(n);\n+            if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n+                vvNew[info.GetNewBucket(nKey)].insert(n);\n+                info.nRefCount++;\n+            }\n+        }\n+        nIdCount = nNew;\n+        int nLost = 0;\n+        for (int n = 0; n < nTried; n++) {\n+            CAddrInfo info;\n+            s >> info;\n+            std::vector<int> &vTried = vvTried[info.GetTriedBucket(nKey)];\n+            if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n+                info.nRandomPos = vRandom.size();\n+                info.fInTried = true;\n+                vRandom.push_back(nIdCount);\n+                mapInfo[nIdCount] = info;\n+                mapAddr[info] = nIdCount;\n+                vTried.push_back(nIdCount);\n+                nIdCount++;\n             } else {\n-                int nUBuckets = 0;\n-                READWRITE(nUBuckets);\n-                am->nIdCount = 0;\n-                am->mapInfo.clear();\n-                am->mapAddr.clear();\n-                am->vRandom.clear();\n-                am->vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n-                am->vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n-                for (int n = 0; n < am->nNew; n++)\n-                {\n-                    CAddrInfo &info = am->mapInfo[n];\n-                    READWRITE(info);\n-                    am->mapAddr[info] = n;\n-                    info.nRandomPos = vRandom.size();\n-                    am->vRandom.push_back(n);\n-                    if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT)\n-                    {\n-                        am->vvNew[info.GetNewBucket(am->nKey)].insert(n);\n-                        info.nRefCount++;\n-                    }\n-                }\n-                am->nIdCount = am->nNew;\n-                int nLost = 0;\n-                for (int n = 0; n < am->nTried; n++)\n-                {\n-                    CAddrInfo info;\n-                    READWRITE(info);\n-                    std::vector<int> &vTried = am->vvTried[info.GetTriedBucket(am->nKey)];\n-                    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n-                    {\n-                        info.nRandomPos = vRandom.size();\n-                        info.fInTried = true;\n-                        am->vRandom.push_back(am->nIdCount);\n-                        am->mapInfo[am->nIdCount] = info;\n-                        am->mapAddr[info] = am->nIdCount;\n-                        vTried.push_back(am->nIdCount);\n-                        am->nIdCount++;\n-                    } else {\n-                        nLost++;\n-                    }\n-                }\n-                am->nTried -= nLost;\n-                for (int b = 0; b < nUBuckets; b++)\n-                {\n-                    std::set<int> &vNew = am->vvNew[b];\n-                    int nSize = 0;\n-                    READWRITE(nSize);\n-                    for (int n = 0; n < nSize; n++)\n-                    {\n-                        int nIndex = 0;\n-                        READWRITE(nIndex);\n-                        CAddrInfo &info = am->mapInfo[nIndex];\n-                        if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n-                        {\n-                            info.nRefCount++;\n-                            vNew.insert(nIndex);\n-                        }\n-                    }\n+                nLost++;\n+            }\n+        }\n+        nTried -= nLost;\n+        for (int b = 0; b < nUBuckets; b++) {\n+            std::set<int> &vNew = vvNew[b];\n+            int nSize = 0;\n+            s >> nSize;\n+            for (int n = 0; n < nSize; n++) {\n+                int nIndex = 0;\n+                s >> nIndex;\n+                CAddrInfo &info = mapInfo[nIndex];\n+                if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n+                    info.nRefCount++;\n+                    vNew.insert(nIndex);\n                 }\n             }\n         }\n-    });)\n+    }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n+        return (CSizeComputer(nType, nVersion) << *this).size();\n+    }\n \n     CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n     {"
      },
      {
        "sha": "f876efd9b5a417ff5b28940a30e0d1a86c8f4a89",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b069750d3f27c96a83700a08a2bb819902268857/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b069750d3f27c96a83700a08a2bb819902268857/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=b069750d3f27c96a83700a08a2bb819902268857",
        "patch": "@@ -830,6 +830,35 @@ struct ser_streamplaceholder\n \n typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;\n \n+class CSizeComputer\n+{\n+protected:\n+    size_t nSize;\n+\n+public:\n+    int nType;\n+    int nVersion;\n+\n+    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}\n+\n+    CSizeComputer& write(const char *psz, int nSize)\n+    {\n+        this->nSize += nSize;\n+        return *this;\n+    }\n+\n+    template<typename T>\n+    CSizeComputer& operator<<(const T& obj)\n+    {\n+        ::Serialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    size_t size() const {\n+        return nSize;\n+    }\n+};\n+\n /** Double ended buffer combining vector and stream-like interfaces.\n  *\n  * >> and << read and write unformatted data using the above serialization templates."
      }
    ]
  }
]