[
  {
    "sha": "2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYWNhZDAzNjU3NWVjOTk4ZjhiYmU0ZjEwZjYyMDZiMWM4YWQzZDIz",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-08-31T19:10:49Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-09-29T18:25:11Z"
      },
      "message": "Remove OutputGroup non-default constructors",
      "tree": {
        "sha": "58420b89f1488449d6b7f0d82c7dc95fd977c06f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/58420b89f1488449d6b7f0d82c7dc95fd977c06f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de4b7f25acef14f98ed09b7cbaa065067313d24b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de4b7f25acef14f98ed09b7cbaa065067313d24b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de4b7f25acef14f98ed09b7cbaa065067313d24b"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 14,
      "deletions": 16
    },
    "files": [
      {
        "sha": "a5455bc7a16dd9f39f60a4b1dd79a504bfa14ebb",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
        "patch": "@@ -46,7 +46,8 @@ static void CoinSelection(benchmark::Bench& bench)\n     std::vector<OutputGroup> groups;\n     for (const auto& wtx : wtxs) {\n         COutput output(wtx.get(), 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n-        groups.emplace_back(output.GetInputCoin(), 6, false, 0, 0);\n+        groups.emplace_back();\n+        groups.back().Insert(output.GetInputCoin(), 6, false, 0, 0);\n     }\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n@@ -75,7 +76,8 @@ static void add_coin(const CAmount& nValue, int nInput, std::vector<OutputGroup>\n     tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n     std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n-    set.emplace_back(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0);\n+    set.emplace_back();\n+    set.back().Insert(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0);\n     wtxn.emplace_back(std::move(wtx));\n }\n // Copied from src/wallet/test/coinselector_tests.cpp"
      },
      {
        "sha": "1a0373eba18553b40b3eb225e0dd0fb90cea4b7e",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
        "patch": "@@ -81,17 +81,6 @@ struct OutputGroup\n     CAmount long_term_fee{0};\n \n     OutputGroup() {}\n-    OutputGroup(std::vector<CInputCoin>&& outputs, bool from_me, CAmount value, int depth, size_t ancestors, size_t descendants)\n-    : m_outputs(std::move(outputs))\n-    , m_from_me(from_me)\n-    , m_value(value)\n-    , m_depth(depth)\n-    , m_ancestors(ancestors)\n-    , m_descendants(descendants)\n-    {}\n-    OutputGroup(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants) : OutputGroup() {\n-        Insert(output, depth, from_me, ancestors, descendants);\n-    }\n     void Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants);\n     std::vector<CInputCoin>::iterator Discard(const CInputCoin& output);\n     bool EligibleForSpending(const CoinEligibilityFilter& eligibility_filter) const;"
      },
      {
        "sha": "72430620f1dd9939dc2d121a675a3fee9b6cc1f4",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
        "patch": "@@ -114,15 +114,21 @@ inline std::vector<OutputGroup>& GroupCoins(const std::vector<CInputCoin>& coins\n {\n     static std::vector<OutputGroup> static_groups;\n     static_groups.clear();\n-    for (auto& coin : coins) static_groups.emplace_back(coin, 0, true, 0, 0);\n+    for (auto& coin : coins) {\n+        static_groups.emplace_back();\n+        static_groups.back().Insert(coin, 0, true, 0, 0);\n+    }\n     return static_groups;\n }\n \n inline std::vector<OutputGroup>& GroupCoins(const std::vector<COutput>& coins)\n {\n     static std::vector<OutputGroup> static_groups;\n     static_groups.clear();\n-    for (auto& coin : coins) static_groups.emplace_back(coin.GetInputCoin(), coin.nDepth, coin.tx->m_amounts[CWalletTx::DEBIT].m_cached[ISMINE_SPENDABLE] && coin.tx->m_amounts[CWalletTx::DEBIT].m_value[ISMINE_SPENDABLE] == 1 /* HACK: we can't figure out the is_me flag so we use the conditions defined above; perhaps set safe to false for !fIsFromMe in add_coin() */, 0, 0);\n+    for (auto& coin : coins) {\n+        static_groups.emplace_back();\n+        static_groups.back().Insert(coin.GetInputCoin(), coin.nDepth, coin.tx->m_amounts[CWalletTx::DEBIT].m_cached[ISMINE_SPENDABLE] && coin.tx->m_amounts[CWalletTx::DEBIT].m_value[ISMINE_SPENDABLE] == 1 /* HACK: we can't figure out the is_me flag so we use the conditions defined above; perhaps set safe to false for !fIsFromMe in add_coin() */, 0, 0);\n+    }\n     return static_groups;\n }\n "
      },
      {
        "sha": "8d5e7546ec7a711c0e42a7fcdabc35689dc336e5",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acad036575ec998f8bbe4f10f6206b1c8ad3d23/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
        "patch": "@@ -4233,7 +4233,8 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n                     gmap[dst].Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n                 }\n             } else {\n-                groups.emplace_back(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n+                groups.emplace_back();\n+                groups.back().Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n             }\n         }\n     }"
      }
    ]
  },
  {
    "sha": "6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTQ4YThhY2RhNWU1OTRiYjliM2IyZDk4OTA1NmY5ZTAzZGRiZGJk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-08-31T19:30:51Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-09-29T18:25:21Z"
      },
      "message": "Move GroupOutputs into SelectCoinsMinConf",
      "tree": {
        "sha": "2ab4579b18956238a978f63802dc6c6839a44ef2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ab4579b18956238a978f63802dc6c6839a44ef2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2acad036575ec998f8bbe4f10f6206b1c8ad3d23",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2acad036575ec998f8bbe4f10f6206b1c8ad3d23"
      }
    ],
    "stats": {
      "total": 141,
      "additions": 75,
      "deletions": 66
    },
    "files": [
      {
        "sha": "6cb45ec7a5c989ef10833d854d5670368d4349cf",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
        "patch": "@@ -42,21 +42,19 @@ static void CoinSelection(benchmark::Bench& bench)\n     }\n     addCoin(3 * COIN, wallet, wtxs);\n \n-    // Create groups\n-    std::vector<OutputGroup> groups;\n+    // Create coins\n+    std::vector<COutput> coins;\n     for (const auto& wtx : wtxs) {\n-        COutput output(wtx.get(), 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n-        groups.emplace_back();\n-        groups.back().Insert(output.GetInputCoin(), 6, false, 0, 0);\n+        coins.emplace_back(wtx.get(), 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n     }\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n-    const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0);\n+    const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0, false);\n     bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "9af6ddd7cfc5780b5e3da65b06f1fc3119d4ad59",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 46,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
        "patch": "@@ -35,7 +35,7 @@ static CAmount balance = 0;\n CoinEligibilityFilter filter_standard(1, 6, 0);\n CoinEligibilityFilter filter_confirmed(1, 1, 0);\n CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n-CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0);\n+CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0, false);\n \n static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n {\n@@ -268,22 +268,22 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n \n     // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n-    CoinSelectionParams coin_selection_params_bnb(true, 0, 0, CFeeRate(3000), 0);\n+    CoinSelectionParams coin_selection_params_bnb(true, 0, 0, CFeeRate(3000), 0, false);\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n     bool bnb_used;\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n \n     // Test fees subtracted from output:\n     empty_wallet();\n     add_coin(1 * CENT);\n     vCoins.at(0).nInputBytes = 40;\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n     coin_selection_params_bnb.m_subtract_fee_outputs = true;\n-    BOOST_CHECK(testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n     BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n     // Make sure that can use BnB when there are preset inputs\n@@ -322,24 +322,24 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         add_coin(1*CENT, 4);        // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         add_coin(2*CENT);           // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n         add_coin(5*CENT);           // add a mature 5 cent coin,\n@@ -349,33 +349,33 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n         // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -389,30 +389,30 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -421,11 +421,11 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin( 2*COIN);\n         add_coin( 3*COIN);\n         add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -440,22 +440,22 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n         // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n \n         // but if we add a bigger coin, small change is avoided\n         add_coin(1111*MIN_CHANGE);\n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // if we add more small coins:\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n \n         // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -464,7 +464,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         for (int j = 0; j < 20; j++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n \n@@ -477,7 +477,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -487,7 +487,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 8 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n@@ -498,12 +498,12 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 100);\n \n         // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n       }\n@@ -517,7 +517,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n            // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.\n            for (int i = 0; i < RUN_TESTS; i++) {\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n              if (amt - 2000 < MIN_CHANGE) {\n                  // needs more than one input:\n@@ -543,17 +543,17 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n           for (int i = 0; i < RUN_TESTS; i++) {\n             // picking 50 from 100 coins doesn't depend on the shuffle,\n             // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, GroupCoins(vCoins), setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, GroupCoins(vCoins), setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n             BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n \n             int fails = 0;\n             for (int j = 0; j < RANDOM_REPEATS; j++)\n             {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, GroupCoins(vCoins), setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, GroupCoins(vCoins), setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -575,8 +575,8 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n             {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, GroupCoins(vCoins), setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, GroupCoins(vCoins), setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -603,7 +603,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n         add_coin(1000 * COIN);\n     add_coin(3 * COIN);\n \n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, GroupCoins(vCoins), setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n     BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n     BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -638,13 +638,13 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CAmount target = rand.randrange(balance - 1000) + 1000;\n \n         // Perform selection\n-        CoinSelectionParams coin_selection_params_knapsack(false, 34, 148, CFeeRate(0), 0);\n-        CoinSelectionParams coin_selection_params_bnb(true, 34, 148, CFeeRate(0), 0);\n+        CoinSelectionParams coin_selection_params_knapsack(false, 34, 148, CFeeRate(0), 0, false);\n+        CoinSelectionParams coin_selection_params_bnb(true, 34, 148, CFeeRate(0), 0, false);\n         CoinSet out_set;\n         CAmount out_value = 0;\n         bool bnb_used = false;\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params_bnb, bnb_used) ||\n-                    testWallet.SelectCoinsMinConf(target, filter_standard, GroupCoins(vCoins), out_set, out_value, coin_selection_params_knapsack, bnb_used));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_bnb, bnb_used) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_knapsack, bnb_used));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      },
      {
        "sha": "674849e26ae69e88d15e7a95b8ae32f26fe7ed73",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
        "patch": "@@ -2367,7 +2367,7 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n     return ptx->vout[n];\n }\n \n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n                                  std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n {\n     setCoinsRet.clear();\n@@ -2381,6 +2381,8 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         temp.m_confirm_target = 1008;\n         CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, &feeCalc);\n \n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors);\n+\n         // Calculate cost of change\n         CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n@@ -2403,6 +2405,8 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         bnb_used = true;\n         return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors);\n+\n         // Filter by the min conf specs and add to utxo_pool\n         for (const OutputGroup& group : groups) {\n             if (!group.EligibleForSpending(eligibility_filter)) continue;\n@@ -2492,16 +2496,14 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         // explicitly shuffling the outputs before processing\n         Shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n     }\n-    std::vector<OutputGroup> groups = GroupOutputs(vCoins, !coin_control.m_avoid_partial_spends, max_ancestors);\n-\n     bool res = value_to_select <= 0 ||\n-        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n+        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n@@ -2790,6 +2792,7 @@ bool CWallet::CreateTransactionInternal(\n             std::vector<COutput> vAvailableCoins;\n             AvailableCoins(vAvailableCoins, true, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n             CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n \n             // Create change script that will be used if we need change\n             // TODO: pass in scriptChange instead of reservedest so"
      },
      {
        "sha": "69bafd2e889a0180720fa154a0b29832e61a1ee4",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
        "patch": "@@ -610,8 +610,16 @@ struct CoinSelectionParams\n     size_t tx_noinputs_size = 0;\n     //! Indicate that we are subtracting the fee from outputs\n     bool m_subtract_fee_outputs = false;\n-\n-    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size) : use_bnb(use_bnb), change_output_size(change_output_size), change_spend_size(change_spend_size), effective_fee(effective_fee), tx_noinputs_size(tx_noinputs_size) {}\n+    bool m_avoid_partial_spends = false;\n+\n+    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size, bool avoid_partial) :\n+        use_bnb(use_bnb),\n+        change_output_size(change_output_size),\n+        change_spend_size(change_spend_size),\n+        effective_fee(effective_fee),\n+        tx_noinputs_size(tx_noinputs_size),\n+        m_avoid_partial_spends(avoid_partial)\n+    {}\n     CoinSelectionParams() {}\n };\n \n@@ -824,7 +832,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * completion the coin set and corresponding actual target value is\n      * assembled\n      */\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n         std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  },
  {
    "sha": "99b399aba5d27476b61b4865cc39553d03965d57",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OWIzOTlhYmE1ZDI3NDc2YjYxYjQ4NjVjYzM5NTUzZDAzOTY1ZDU3",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-08-31T19:56:30Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-09-29T18:25:56Z"
      },
      "message": "Move fee setting of OutputGroup to Insert\n\nOutputGroup will handle the fee and effective value computations\ninside of Insert. It now needs to take the effective feerate and long\nterm feerates as arguments to its constructor.",
      "tree": {
        "sha": "6a8c2425180d7dc6c136476197b691029f9e82ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a8c2425180d7dc6c136476197b691029f9e82ae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99b399aba5d27476b61b4865cc39553d03965d57",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99b399aba5d27476b61b4865cc39553d03965d57",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99b399aba5d27476b61b4865cc39553d03965d57",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99b399aba5d27476b61b4865cc39553d03965d57/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6148a8acda5e594bb9b3b2d989056f9e03ddbdbd"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 33,
      "deletions": 38
    },
    "files": [
      {
        "sha": "f4843dd0cecde5b87d13498fc560badb6330d763",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 20,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=99b399aba5d27476b61b4865cc39553d03965d57",
        "patch": "@@ -302,6 +302,16 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n \n void OutputGroup::Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants) {\n     m_outputs.push_back(output);\n+    CInputCoin& coin = m_outputs.back();\n+    coin.m_fee = coin.m_input_bytes < 0 ? 0 : m_effective_feerate.GetFee(coin.m_input_bytes);\n+    fee += coin.m_fee;\n+\n+    coin.m_long_term_fee = coin.m_input_bytes < 0 ? 0 : m_long_term_feerate.GetFee(coin.m_input_bytes);\n+    long_term_fee += coin.m_long_term_fee;\n+\n+    coin.effective_value = coin.txout.nValue - coin.m_fee;\n+    effective_value += coin.effective_value;\n+\n     m_from_me &= from_me;\n     m_value += output.txout.nValue;\n     m_depth = std::min(m_depth, depth);\n@@ -312,9 +322,6 @@ void OutputGroup::Insert(const CInputCoin& output, int depth, bool from_me, size\n     // descendants is the count as seen from the top ancestor, not the descendants as seen from the\n     // coin itself; thus, this value is counted as the max, not the sum\n     m_descendants = std::max(m_descendants, descendants);\n-    effective_value += output.effective_value;\n-    fee += output.m_fee;\n-    long_term_fee += output.m_long_term_fee;\n }\n \n std::vector<CInputCoin>::iterator OutputGroup::Discard(const CInputCoin& output) {\n@@ -335,23 +342,6 @@ bool OutputGroup::EligibleForSpending(const CoinEligibilityFilter& eligibility_f\n         && m_descendants <= eligibility_filter.max_descendants;\n }\n \n-void OutputGroup::SetFees(const CFeeRate effective_feerate, const CFeeRate long_term_feerate)\n-{\n-    fee = 0;\n-    long_term_fee = 0;\n-    effective_value = 0;\n-    for (CInputCoin& coin : m_outputs) {\n-        coin.m_fee = coin.m_input_bytes < 0 ? 0 : effective_feerate.GetFee(coin.m_input_bytes);\n-        fee += coin.m_fee;\n-\n-        coin.m_long_term_fee = coin.m_input_bytes < 0 ? 0 : long_term_feerate.GetFee(coin.m_input_bytes);\n-        long_term_fee += coin.m_long_term_fee;\n-\n-        coin.effective_value = coin.txout.nValue - coin.m_fee;\n-        effective_value += coin.effective_value;\n-    }\n-}\n-\n OutputGroup OutputGroup::GetPositiveOnlyGroup()\n {\n     OutputGroup group(*this);"
      },
      {
        "sha": "721f1a22ebf7dd7ef65f71bf119def885b66f3ef",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=99b399aba5d27476b61b4865cc39553d03965d57",
        "patch": "@@ -6,11 +6,10 @@\n #define BITCOIN_WALLET_COINSELECTION_H\n \n #include <amount.h>\n+#include <policy/feerate.h>\n #include <primitives/transaction.h>\n #include <random.h>\n \n-class CFeeRate;\n-\n //! target minimum change amount\n static constexpr CAmount MIN_CHANGE{COIN / 100};\n //! final minimum change amount after paying for fees\n@@ -78,15 +77,20 @@ struct OutputGroup\n     size_t m_descendants{0};\n     CAmount effective_value{0};\n     CAmount fee{0};\n+    CFeeRate m_effective_feerate{0};\n     CAmount long_term_fee{0};\n+    CFeeRate m_long_term_feerate{0};\n \n     OutputGroup() {}\n+    OutputGroup(const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate) :\n+        m_effective_feerate(effective_feerate),\n+        m_long_term_feerate(long_term_feerate)\n+    {}\n+\n     void Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants);\n     std::vector<CInputCoin>::iterator Discard(const CInputCoin& output);\n     bool EligibleForSpending(const CoinEligibilityFilter& eligibility_filter) const;\n \n-    //! Update the OutputGroup's fee, long_term_fee, and effective_value based on the given feerates\n-    void SetFees(const CFeeRate effective_feerate, const CFeeRate long_term_feerate);\n     OutputGroup GetPositiveOnlyGroup();\n };\n "
      },
      {
        "sha": "71db03c32b4d1dd4759564e707c8f932646f5243",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=99b399aba5d27476b61b4865cc39553d03965d57",
        "patch": "@@ -2381,7 +2381,14 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         temp.m_confirm_target = 1008;\n         CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, &feeCalc);\n \n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors);\n+        // Get the feerate for effective value.\n+        // When subtracting the fee from the outputs, we want the effective feerate to be 0\n+        CFeeRate effective_feerate{0};\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            effective_feerate = coin_selection_params.effective_fee;\n+        }\n+\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, effective_feerate, long_term_feerate);\n \n         // Calculate cost of change\n         CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n@@ -2390,13 +2397,6 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         for (OutputGroup& group : groups) {\n             if (!group.EligibleForSpending(eligibility_filter)) continue;\n \n-            if (coin_selection_params.m_subtract_fee_outputs) {\n-                // Set the effective feerate to 0 as we don't want to use the effective value since the fees will be deducted from the output\n-                group.SetFees(CFeeRate(0) /* effective_feerate */, long_term_feerate);\n-            } else {\n-                group.SetFees(coin_selection_params.effective_fee, long_term_feerate);\n-            }\n-\n             OutputGroup pos_group = group.GetPositiveOnlyGroup();\n             if (pos_group.effective_value > 0) utxo_pool.push_back(pos_group);\n         }\n@@ -2405,7 +2405,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         bnb_used = true;\n         return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, CFeeRate(0), CFeeRate(0));\n \n         // Filter by the min conf specs and add to utxo_pool\n         for (const OutputGroup& group : groups) {\n@@ -4206,7 +4206,7 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors) const {\n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate) const {\n     std::vector<OutputGroup> groups;\n     std::map<CTxDestination, OutputGroup> gmap;\n     std::set<CTxDestination> full_groups;\n@@ -4228,15 +4228,16 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n                     // high amount of fees.\n                     if (it->second.m_outputs.size() >= OUTPUT_GROUP_MAX_ENTRIES) {\n                         groups.push_back(it->second);\n-                        it->second = OutputGroup{};\n+                        it->second = OutputGroup{effective_feerate, long_term_feerate};\n                         full_groups.insert(dst);\n                     }\n                     it->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n                 } else {\n-                    gmap[dst].Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n+                    auto ins = gmap.emplace(dst, OutputGroup{effective_feerate, long_term_feerate});\n+                    ins.first->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n                 }\n             } else {\n-                groups.emplace_back();\n+                groups.emplace_back(effective_feerate, long_term_feerate);\n                 groups.back().Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n             }\n         }"
      },
      {
        "sha": "448b80c7bb806ee70c170954908248068969157a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b399aba5d27476b61b4865cc39553d03965d57/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=99b399aba5d27476b61b4865cc39553d03965d57",
        "patch": "@@ -841,7 +841,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors) const;\n+    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void LockCoin(const COutPoint& output) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  },
  {
    "sha": "d895e98b594b873f3d34c8ba63e9b55125d51b5a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODk1ZTk4YjU5NGI4NzNmM2QzNGM4YmE2M2U5YjU1MTI1ZDUxYjVh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-08-31T20:35:56Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-09-29T18:26:03Z"
      },
      "message": "Move EligibleForSpending into GroupOutputs\n\nInstead of filtering after the OutputGroups have been made, do it as\nthey are being made.",
      "tree": {
        "sha": "d92766ee4d8666e540d04fba0dfb320be969cbbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d92766ee4d8666e540d04fba0dfb320be969cbbc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d895e98b594b873f3d34c8ba63e9b55125d51b5a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d895e98b594b873f3d34c8ba63e9b55125d51b5a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d895e98b594b873f3d34c8ba63e9b55125d51b5a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d895e98b594b873f3d34c8ba63e9b55125d51b5a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99b399aba5d27476b61b4865cc39553d03965d57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99b399aba5d27476b61b4865cc39553d03965d57",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99b399aba5d27476b61b4865cc39553d03965d57"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 12,
      "deletions": 16
    },
    "files": [
      {
        "sha": "f2c035da144bb828ddc87cda4326e613a3504538",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 15,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d895e98b594b873f3d34c8ba63e9b55125d51b5a/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d895e98b594b873f3d34c8ba63e9b55125d51b5a/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d895e98b594b873f3d34c8ba63e9b55125d51b5a",
        "patch": "@@ -2373,8 +2373,8 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n-    std::vector<OutputGroup> utxo_pool;\n     if (coin_selection_params.use_bnb) {\n+        std::vector<OutputGroup> utxo_pool;\n         // Get long term estimate\n         FeeCalculation feeCalc;\n         CCoinControl temp;\n@@ -2388,15 +2388,13 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n             effective_feerate = coin_selection_params.effective_fee;\n         }\n \n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, effective_feerate, long_term_feerate);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, effective_feerate, long_term_feerate, eligibility_filter);\n \n         // Calculate cost of change\n         CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n         // Filter by the min conf specs and add to utxo_pool and calculate effective value\n         for (OutputGroup& group : groups) {\n-            if (!group.EligibleForSpending(eligibility_filter)) continue;\n-\n             OutputGroup pos_group = group.GetPositiveOnlyGroup();\n             if (pos_group.effective_value > 0) utxo_pool.push_back(pos_group);\n         }\n@@ -2405,15 +2403,10 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         bnb_used = true;\n         return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, CFeeRate(0), CFeeRate(0));\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, CFeeRate(0), CFeeRate(0), eligibility_filter);\n \n-        // Filter by the min conf specs and add to utxo_pool\n-        for (const OutputGroup& group : groups) {\n-            if (!group.EligibleForSpending(eligibility_filter)) continue;\n-            utxo_pool.push_back(group);\n-        }\n         bnb_used = false;\n-        return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n+        return KnapsackSolver(nTargetValue, groups, setCoinsRet, nValueRet);\n     }\n }\n \n@@ -4206,7 +4199,7 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate) const {\n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter) const {\n     std::vector<OutputGroup> groups;\n     std::map<CTxDestination, OutputGroup> gmap;\n     std::set<CTxDestination> full_groups;\n@@ -4237,8 +4230,10 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n                     ins.first->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n                 }\n             } else {\n-                groups.emplace_back(effective_feerate, long_term_feerate);\n-                groups.back().Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n+                // This is for if each output gets it's own OutputGroup\n+                OutputGroup coin(effective_feerate, long_term_feerate);\n+                coin.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n+                if (coin.EligibleForSpending(filter)) groups.push_back(coin);\n             }\n         }\n     }\n@@ -4249,7 +4244,8 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n                 // Make this unattractive as we want coin selection to avoid it if possible\n                 group.m_ancestors = max_ancestors - 1;\n             }\n-            groups.push_back(group);\n+            // If the OutputGroup is not eligible, don't add it\n+            if (group.EligibleForSpending(filter)) groups.push_back(group);\n         }\n     }\n     return groups;"
      },
      {
        "sha": "1c523d86b896f45f5357e00649e157d70e619537",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d895e98b594b873f3d34c8ba63e9b55125d51b5a/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d895e98b594b873f3d34c8ba63e9b55125d51b5a/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d895e98b594b873f3d34c8ba63e9b55125d51b5a",
        "patch": "@@ -841,7 +841,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate) const;\n+    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void LockCoin(const COutPoint& output) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  },
  {
    "sha": "416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MTZkNzRmYjE2ODdhZTFkNDdhNThjMTUzZDA5ZDlhZmUwYjZkYzYw",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-08-31T20:45:39Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-10-02T16:35:04Z"
      },
      "message": "Move OutputGroup positive only filtering into Insert",
      "tree": {
        "sha": "bd3fef5010a23b8fdcdd4f6f06d6a54aa0b71865",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd3fef5010a23b8fdcdd4f6f06d6a54aa0b71865"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d895e98b594b873f3d34c8ba63e9b55125d51b5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d895e98b594b873f3d34c8ba63e9b55125d51b5a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d895e98b594b873f3d34c8ba63e9b55125d51b5a"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 27,
      "deletions": 52
    },
    "files": [
      {
        "sha": "6af7e785de00994397ef80046d51cb0c03f3e6bb",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "patch": "@@ -75,7 +75,7 @@ static void add_coin(const CAmount& nValue, int nInput, std::vector<OutputGroup>\n     tx.vout[nInput].nValue = nValue;\n     std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n     set.emplace_back();\n-    set.back().Insert(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0);\n+    set.back().Insert(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0, false);\n     wtxn.emplace_back(std::move(wtx));\n }\n // Copied from src/wallet/test/coinselector_tests.cpp"
      },
      {
        "sha": "8032deb2fa2e851ea8bdf4c7478da7de75338895",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 29,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "patch": "@@ -300,16 +300,24 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n \n  ******************************************************************************/\n \n-void OutputGroup::Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants) {\n+void OutputGroup::Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants, bool positive_only) {\n+    // Compute the effective value first\n+    const CAmount coin_fee = output.m_input_bytes < 0 ? 0 : m_effective_feerate.GetFee(output.m_input_bytes);\n+    const CAmount ev = output.txout.nValue - coin_fee;\n+\n+    // Filter for positive only here before adding the coin\n+    if (positive_only && ev <= 0) return;\n+\n     m_outputs.push_back(output);\n     CInputCoin& coin = m_outputs.back();\n-    coin.m_fee = coin.m_input_bytes < 0 ? 0 : m_effective_feerate.GetFee(coin.m_input_bytes);\n+\n+    coin.m_fee = coin_fee;\n     fee += coin.m_fee;\n \n     coin.m_long_term_fee = coin.m_input_bytes < 0 ? 0 : m_long_term_feerate.GetFee(coin.m_input_bytes);\n     long_term_fee += coin.m_long_term_fee;\n \n-    coin.effective_value = coin.txout.nValue - coin.m_fee;\n+    coin.effective_value = ev;\n     effective_value += coin.effective_value;\n \n     m_from_me &= from_me;\n@@ -324,35 +332,9 @@ void OutputGroup::Insert(const CInputCoin& output, int depth, bool from_me, size\n     m_descendants = std::max(m_descendants, descendants);\n }\n \n-std::vector<CInputCoin>::iterator OutputGroup::Discard(const CInputCoin& output) {\n-    auto it = m_outputs.begin();\n-    while (it != m_outputs.end() && it->outpoint != output.outpoint) ++it;\n-    if (it == m_outputs.end()) return it;\n-    m_value -= output.txout.nValue;\n-    effective_value -= output.effective_value;\n-    fee -= output.m_fee;\n-    long_term_fee -= output.m_long_term_fee;\n-    return m_outputs.erase(it);\n-}\n-\n bool OutputGroup::EligibleForSpending(const CoinEligibilityFilter& eligibility_filter) const\n {\n     return m_depth >= (m_from_me ? eligibility_filter.conf_mine : eligibility_filter.conf_theirs)\n         && m_ancestors <= eligibility_filter.max_ancestors\n         && m_descendants <= eligibility_filter.max_descendants;\n }\n-\n-OutputGroup OutputGroup::GetPositiveOnlyGroup()\n-{\n-    OutputGroup group(*this);\n-    for (auto it = group.m_outputs.begin(); it != group.m_outputs.end(); ) {\n-        const CInputCoin& coin = *it;\n-        // Only include outputs that are positive effective value (i.e. not dust)\n-        if (coin.effective_value <= 0) {\n-            it = group.Discard(coin);\n-        } else {\n-            ++it;\n-        }\n-    }\n-    return group;\n-}"
      },
      {
        "sha": "6e3b8c3915fee90f2c5abb5b690f961808b8dd82",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "patch": "@@ -87,11 +87,8 @@ struct OutputGroup\n         m_long_term_feerate(long_term_feerate)\n     {}\n \n-    void Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants);\n-    std::vector<CInputCoin>::iterator Discard(const CInputCoin& output);\n+    void Insert(const CInputCoin& output, int depth, bool from_me, size_t ancestors, size_t descendants, bool positive_only);\n     bool EligibleForSpending(const CoinEligibilityFilter& eligibility_filter) const;\n-\n-    OutputGroup GetPositiveOnlyGroup();\n };\n \n bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);"
      },
      {
        "sha": "b5c9e62b5c960829537acf25a86b4e37bf60b58d",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "patch": "@@ -116,7 +116,7 @@ inline std::vector<OutputGroup>& GroupCoins(const std::vector<CInputCoin>& coins\n     static_groups.clear();\n     for (auto& coin : coins) {\n         static_groups.emplace_back();\n-        static_groups.back().Insert(coin, 0, true, 0, 0);\n+        static_groups.back().Insert(coin, 0, true, 0, 0, false);\n     }\n     return static_groups;\n }\n@@ -127,7 +127,7 @@ inline std::vector<OutputGroup>& GroupCoins(const std::vector<COutput>& coins)\n     static_groups.clear();\n     for (auto& coin : coins) {\n         static_groups.emplace_back();\n-        static_groups.back().Insert(coin.GetInputCoin(), coin.nDepth, coin.tx->m_amounts[CWalletTx::DEBIT].m_cached[ISMINE_SPENDABLE] && coin.tx->m_amounts[CWalletTx::DEBIT].m_value[ISMINE_SPENDABLE] == 1 /* HACK: we can't figure out the is_me flag so we use the conditions defined above; perhaps set safe to false for !fIsFromMe in add_coin() */, 0, 0);\n+        static_groups.back().Insert(coin.GetInputCoin(), coin.nDepth, coin.tx->m_amounts[CWalletTx::DEBIT].m_cached[ISMINE_SPENDABLE] && coin.tx->m_amounts[CWalletTx::DEBIT].m_value[ISMINE_SPENDABLE] == 1 /* HACK: we can't figure out the is_me flag so we use the conditions defined above; perhaps set safe to false for !fIsFromMe in add_coin() */, 0, 0, false);\n     }\n     return static_groups;\n }"
      },
      {
        "sha": "df0e39b301d045360a02e0987ef5f83527458312",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 15,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "patch": "@@ -2374,7 +2374,6 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     nValueRet = 0;\n \n     if (coin_selection_params.use_bnb) {\n-        std::vector<OutputGroup> utxo_pool;\n         // Get long term estimate\n         FeeCalculation feeCalc;\n         CCoinControl temp;\n@@ -2388,22 +2387,17 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n             effective_feerate = coin_selection_params.effective_fee;\n         }\n \n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, effective_feerate, long_term_feerate, eligibility_filter);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, effective_feerate, long_term_feerate, eligibility_filter, true /* positive_only */);\n \n         // Calculate cost of change\n         CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n-        // Filter by the min conf specs and add to utxo_pool and calculate effective value\n-        for (OutputGroup& group : groups) {\n-            OutputGroup pos_group = group.GetPositiveOnlyGroup();\n-            if (pos_group.effective_value > 0) utxo_pool.push_back(pos_group);\n-        }\n         // Calculate the fees for things that aren't inputs\n         CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n         bnb_used = true;\n-        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+        return SelectCoinsBnB(groups, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, CFeeRate(0), CFeeRate(0), eligibility_filter);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, CFeeRate(0), CFeeRate(0), eligibility_filter, false /* positive_only */);\n \n         bnb_used = false;\n         return KnapsackSolver(nTargetValue, groups, setCoinsRet, nValueRet);\n@@ -4199,7 +4193,7 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter) const {\n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const {\n     std::vector<OutputGroup> groups;\n     std::map<CTxDestination, OutputGroup> gmap;\n     std::set<CTxDestination> full_groups;\n@@ -4224,16 +4218,17 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n                         it->second = OutputGroup{effective_feerate, long_term_feerate};\n                         full_groups.insert(dst);\n                     }\n-                    it->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n+                    it->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n                 } else {\n                     auto ins = gmap.emplace(dst, OutputGroup{effective_feerate, long_term_feerate});\n-                    ins.first->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n+                    ins.first->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n                 }\n             } else {\n                 // This is for if each output gets it's own OutputGroup\n                 OutputGroup coin(effective_feerate, long_term_feerate);\n-                coin.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants);\n-                if (coin.EligibleForSpending(filter)) groups.push_back(coin);\n+                coin.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+                if (positive_only && coin.effective_value <= 0) continue;\n+                if (coin.m_outputs.size() > 0 && coin.EligibleForSpending(filter)) groups.push_back(coin);\n             }\n         }\n     }\n@@ -4245,7 +4240,8 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n                 group.m_ancestors = max_ancestors - 1;\n             }\n             // If the OutputGroup is not eligible, don't add it\n-            if (group.EligibleForSpending(filter)) groups.push_back(group);\n+            if (positive_only && group.effective_value <= 0) continue;\n+            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups.push_back(group);\n         }\n     }\n     return groups;"
      },
      {
        "sha": "da14b0108c4719eb802984ce65938ae5f879a8b0",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/416d74fb1687ae1d47a58c153d09d9afe0b6dc60/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "patch": "@@ -841,7 +841,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter) const;\n+    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void LockCoin(const COutPoint& output) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  },
  {
    "sha": "f6b305273910db0e46798d361413a7e878cb45f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNmIzMDUyNzM5MTBkYjBlNDY3OThkMzYxNDEzYTdlODc4Y2I0NWY3",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-10-01T17:43:17Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-10-02T16:35:22Z"
      },
      "message": "Explicitly filter out partial groups when we don't want them\n\nInstead of hacking OutputGroup::m_ancestors to discourage the inclusion\nof partial groups via the eligibility filter, add a parameter to the\neligibility filter that indicates whether we want to include the group.\nThen for those partial groups, don't return them in GroupOutputs if we\nindicate they aren't desired.",
      "tree": {
        "sha": "7846e45d9059d90b7c807fc839ef9c3e37f198da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7846e45d9059d90b7c807fc839ef9c3e37f198da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f6b305273910db0e46798d361413a7e878cb45f7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6b305273910db0e46798d361413a7e878cb45f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f6b305273910db0e46798d361413a7e878cb45f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6b305273910db0e46798d361413a7e878cb45f7/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/416d74fb1687ae1d47a58c153d09d9afe0b6dc60",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/416d74fb1687ae1d47a58c153d09d9afe0b6dc60"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 11,
      "deletions": 9
    },
    "files": [
      {
        "sha": "5d9a410dce9eec940df068a17cf8d935aa00c2f5",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6b305273910db0e46798d361413a7e878cb45f7/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6b305273910db0e46798d361413a7e878cb45f7/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=f6b305273910db0e46798d361413a7e878cb45f7",
        "patch": "@@ -62,9 +62,11 @@ struct CoinEligibilityFilter\n     const int conf_theirs;\n     const uint64_t max_ancestors;\n     const uint64_t max_descendants;\n+    const bool m_include_partial_groups{false}; //! Include partial destination groups when avoid_reuse and there are full groups\n \n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_ancestors) {}\n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants) {}\n+    CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants, bool include_partial) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants), m_include_partial_groups(include_partial) {}\n };\n \n struct OutputGroup"
      },
      {
        "sha": "c173ebf98839616d5a9409a3f294b1507d4e78b9",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6b305273910db0e46798d361413a7e878cb45f7/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6b305273910db0e46798d361413a7e878cb45f7/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=f6b305273910db0e46798d361413a7e878cb45f7",
        "patch": "@@ -2387,7 +2387,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n             effective_feerate = coin_selection_params.effective_fee;\n         }\n \n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, effective_feerate, long_term_feerate, eligibility_filter, true /* positive_only */);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, effective_feerate, long_term_feerate, eligibility_filter, true /* positive_only */);\n \n         // Calculate cost of change\n         CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n@@ -2397,7 +2397,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         bnb_used = true;\n         return SelectCoinsBnB(groups, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n     } else {\n-        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, eligibility_filter.max_ancestors, CFeeRate(0), CFeeRate(0), eligibility_filter, false /* positive_only */);\n+        std::vector<OutputGroup> groups = GroupOutputs(coins, !coin_selection_params.m_avoid_partial_spends, CFeeRate(0), CFeeRate(0), eligibility_filter, false /* positive_only */);\n \n         bnb_used = false;\n         return KnapsackSolver(nTargetValue, groups, setCoinsRet, nValueRet);\n@@ -2489,8 +2489,8 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n         (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n         (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n@@ -4193,7 +4193,7 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const {\n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const {\n     std::vector<OutputGroup> groups;\n     std::map<CTxDestination, OutputGroup> gmap;\n     std::set<CTxDestination> full_groups;\n@@ -4235,9 +4235,9 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n     if (!single_coin) {\n         for (auto& it : gmap) {\n             auto& group = it.second;\n-            if (full_groups.count(it.first) > 0) {\n-                // Make this unattractive as we want coin selection to avoid it if possible\n-                group.m_ancestors = max_ancestors - 1;\n+            if (full_groups.count(it.first) > 0 && !filter.m_include_partial_groups) {\n+                // Don't include partial groups if we don't want them\n+                continue;\n             }\n             // If the OutputGroup is not eligible, don't add it\n             if (positive_only && group.effective_value <= 0) continue;"
      },
      {
        "sha": "f6ce014358d8788d5d752ce7c6ccd990d7da636d",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6b305273910db0e46798d361413a7e878cb45f7/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6b305273910db0e46798d361413a7e878cb45f7/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=f6b305273910db0e46798d361413a7e878cb45f7",
        "patch": "@@ -841,7 +841,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const size_t max_ancestors, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n+    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void LockCoin(const COutPoint& output) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  },
  {
    "sha": "5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDQ1OTc2NjZkNTg5ZTM5MzU0ZTBkOGRkNWIyYWZiZTFhNWQ3ZDhl",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-12-09T00:19:35Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-12-10T01:18:05Z"
      },
      "message": "Rewrite OutputGroups to be clearer and to use scriptPubKeys\n\nRewrite OutputGroups so that the logic is easier to follow and\nunderstand.\n\nThere is a slight behavior change as OutputGroups will be grouped by\nscriptPubKey rather than CTxDestination as before. This should have no\neffect on users as all addresses are a CTxDestination. However by using\nscriptPubKeys, we can correctly group outputs which fall into the\nNoDestination case. But we also shouldn't have any NoDestination\noutputs.",
      "tree": {
        "sha": "20dbe7851e2879779a30f9c3409d1c3542759c06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20dbe7851e2879779a30f9c3409d1c3542759c06"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6b305273910db0e46798d361413a7e878cb45f7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6b305273910db0e46798d361413a7e878cb45f7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6b305273910db0e46798d361413a7e878cb45f7"
      }
    ],
    "stats": {
      "total": 116,
      "additions": 74,
      "deletions": 42
    },
    "files": [
      {
        "sha": "8ab9438f8c331e9a12a2b5431c221ff8ddb9596d",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 41,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e",
        "patch": "@@ -4193,58 +4193,90 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const {\n-    std::vector<OutputGroup> groups;\n-    std::map<CTxDestination, OutputGroup> gmap;\n-    std::set<CTxDestination> full_groups;\n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool separate_coins, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const\n+{\n+    std::vector<OutputGroup> groups_out;\n \n-    for (const auto& output : outputs) {\n-        if (output.fSpendable) {\n-            CTxDestination dst;\n-            CInputCoin input_coin = output.GetInputCoin();\n+    if (separate_coins) {\n+        // Single coin means no grouping. Each COutput gets its own OutputGroup.\n+        for (const COutput& output : outputs) {\n+            // Skip outputs we cannot spend\n+            if (!output.fSpendable) continue;\n \n             size_t ancestors, descendants;\n             chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n-            if (!single_coin && ExtractDestination(output.tx->tx->vout[output.i].scriptPubKey, dst)) {\n-                auto it = gmap.find(dst);\n-                if (it != gmap.end()) {\n-                    // Limit output groups to no more than OUTPUT_GROUP_MAX_ENTRIES\n-                    // number of entries, to protect against inadvertently creating\n-                    // a too-large transaction when using -avoidpartialspends to\n-                    // prevent breaking consensus or surprising users with a very\n-                    // high amount of fees.\n-                    if (it->second.m_outputs.size() >= OUTPUT_GROUP_MAX_ENTRIES) {\n-                        groups.push_back(it->second);\n-                        it->second = OutputGroup{effective_feerate, long_term_feerate};\n-                        full_groups.insert(dst);\n-                    }\n-                    it->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n-                } else {\n-                    auto ins = gmap.emplace(dst, OutputGroup{effective_feerate, long_term_feerate});\n-                    ins.first->second.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n-                }\n-            } else {\n-                // This is for if each output gets it's own OutputGroup\n-                OutputGroup coin(effective_feerate, long_term_feerate);\n-                coin.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n-                if (positive_only && coin.effective_value <= 0) continue;\n-                if (coin.m_outputs.size() > 0 && coin.EligibleForSpending(filter)) groups.push_back(coin);\n-            }\n+            CInputCoin input_coin = output.GetInputCoin();\n+\n+            // Make an OutputGroup containing just this output\n+            OutputGroup group{effective_feerate, long_term_feerate};\n+            group.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+\n+            // Check the OutputGroup's eligibility. Only add the eligible ones.\n+            if (positive_only && group.effective_value <= 0) continue;\n+            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n         }\n+        return groups_out;\n     }\n-    if (!single_coin) {\n-        for (auto& it : gmap) {\n-            auto& group = it.second;\n-            if (full_groups.count(it.first) > 0 && !filter.m_include_partial_groups) {\n-                // Don't include partial groups if we don't want them\n+\n+    // We want to combine COutputs that have the same scriptPubKey into single OutputGroups\n+    // except when there are more than OUTPUT_GROUP_MAX_ENTRIES COutputs grouped in an OutputGroup.\n+    // To do this, we maintain a map where the key is the scriptPubKey and the value is a vector of OutputGroups.\n+    // For each COutput, we check if the scriptPubKey is in the map, and if it is, the COutput's CInputCoin is added\n+    // to the last OutputGroup in the vector for the scriptPubKey. When the last OutputGroup has\n+    // OUTPUT_GROUP_MAX_ENTRIES CInputCoins, a new OutputGroup is added to the end of the vector.\n+    std::map<CScript, std::vector<OutputGroup>> spk_to_groups_map;\n+    for (const auto& output : outputs) {\n+        // Skip outputs we cannot spend\n+        if (!output.fSpendable) continue;\n+\n+        size_t ancestors, descendants;\n+        chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+        CInputCoin input_coin = output.GetInputCoin();\n+        CScript spk = input_coin.txout.scriptPubKey;\n+\n+        std::vector<OutputGroup>& groups = spk_to_groups_map[spk];\n+\n+        if (groups.size() == 0) {\n+            // No OutputGroups for this scriptPubKey yet, add one\n+            groups.emplace_back(effective_feerate, long_term_feerate);\n+        }\n+\n+        // Get the last OutputGroup in the vector so that we can add the CInputCoin to it\n+        // A pointer is used here so that group can be reassigned later if it is full.\n+        OutputGroup* group = &groups.back();\n+\n+        // Check if this OutputGroup is full. We limit to OUTPUT_GROUP_MAX_ENTRIES when using -avoidpartialspends\n+        // to avoid surprising users with very high fees.\n+        if (group->m_outputs.size() >= OUTPUT_GROUP_MAX_ENTRIES) {\n+            // The last output group is full, add a new group to the vector and use that group for the insertion\n+            groups.emplace_back(effective_feerate, long_term_feerate);\n+            group = &groups.back();\n+        }\n+\n+        // Add the input_coin to group\n+        group->Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+    }\n+\n+    // Now we go through the entire map and pull out the OutputGroups\n+    for (const auto& spk_and_groups_pair: spk_to_groups_map) {\n+        const std::vector<OutputGroup>& groups_per_spk= spk_and_groups_pair.second;\n+\n+        // Go through the vector backwards. This allows for the first item we deal with being the partial group.\n+        for (auto group_it = groups_per_spk.rbegin(); group_it != groups_per_spk.rend(); group_it++) {\n+            const OutputGroup& group = *group_it;\n+\n+            // Don't include partial groups if there are full groups too and we don't want partial groups\n+            if (group_it == groups_per_spk.rbegin() && groups_per_spk.size() > 1 && !filter.m_include_partial_groups) {\n                 continue;\n             }\n-            // If the OutputGroup is not eligible, don't add it\n+\n+            // Check the OutputGroup's eligibility. Only add the eligible ones.\n             if (positive_only && group.effective_value <= 0) continue;\n-            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups.push_back(group);\n+            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n         }\n     }\n-    return groups;\n+\n+    return groups_out;\n }\n \n bool CWallet::IsCrypted() const"
      },
      {
        "sha": "21cc888712f407778264c6684908680853b88a25",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=5d4597666d589e39354e0d8dd5b2afbe1a5d7d8e",
        "patch": "@@ -841,7 +841,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n+    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool separate_coins, const CFeeRate& effective_feerate, const CFeeRate& long_term_feerate, const CoinEligibilityFilter& filter, bool positive_only) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void LockCoin(const COutPoint& output) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  }
]