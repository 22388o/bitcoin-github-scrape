[
  {
    "sha": "54245985fb3c89d72e285c4db39d38ed2f5fb0de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDI0NTk4NWZiM2M4OWQ3MmUyODVjNGRiMzlkMzhlZDJmNWZiMGRl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-03-31T18:41:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-03-31T18:41:05Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 0b70241850..b19c000063\n\nb19c000063 Merge #607: Use size_t shifts when computing a size_t\n4d01bc2d9c Merge #606: travis: Remove unused sudo:false\ne6d01e9347 Use size_t shifts when computing a size_t\n7667532bd7 travis: Remove unused sudo:false\nee99f12f3d Merge #599: Switch x86_64 asm to use \"i\" instead of \"n\" for immediate values.\nd58bc93f2c Switch x86_64 asm to use \"i\" instead of \"n\" for immediate values.\n05362ee042 Merge #597: Add $(COMMON_LIB) to exhaustive tests to fix ARM asm build\n83483869ac Add $(COMMON_LIB) to exhaustive tests to fix ARM asm build\naa15154a48 Merge #568: Fix integer overflow in ecmult_multi_var when n is large\n2277af5ff0 Fix integer overflow in ecmult_multi_var when n is large\n85d0e1bcce Merge #591: Make bench_internal obey secp256k1_fe_sqrt's contract wrt aliasing.\n14196379ec Merge #580: Add trivial ecmult_multi algorithm which does not require a scratch space\na697d82da9 Add trivial ecmult_multi to the benchmark tool\nbade617417 Add trivial ecmult_multi algorithm. It is selected when no scratch space is given and just multiplies and adds the points.\n5545e13dea Merge #584: configure: Use CFLAGS_FOR_BUILD when checking native compiler\n20c5869df2 Merge #516: improvements to random seed in src/tests.c\nb76e45d5d6 Make bench_internal obey secp256k1_fe_sqrt's contract wrt aliasing.\n870a977644 Merge #562: Make use of TAG_PUBKEY constants in secp256k1_eckey_pubkey_parse\nbe40c4d0b5 Fixup for C90 mixed declarations.\nc71dd2c08f Merge #509: Fix algorithm selection in bench_ecmult\n6492bf88cc Merge #518: Summarize build options after running configure\n0e9ada1941 Merge #567: Correct order of libs returned on pkg-config --libs --static libsecp2\u2026\ne96901a4b9 Merge #587: Make randomization of a non-signing context a noop\n58df8d03ad Merge #511: Portability fix for the configure scripts generated\n2ebdad772a Merge #552: Make constants static:\n1c131affd3 Merge #551: secp256k1_fe_sqrt: Verify that the arguments don't alias.\nba698f883b Merge #539: Assorted minor corrections\n949e85b009 Merge #550: Optimize secp256k1_fe_normalize_weak calls.\na34bcaadf1 Actually pass CFLAGS_FOR_BUILD and LDFLAGS_FOR_BUILD to linker\n2d5f4cebdc configure: Use CFLAGS_FOR_BUILD when checking native compiler\nb408c6a8b2 Merge #579: Use __GNUC_PREREQ for detecting __builtin_expect\n6198375218 Make randomization of a non-signing context a noop\nc663397f46 Use __GNUC_PREREQ for detecting __builtin_expect\ne34ceb333b Merge #557: Eliminate scratch memory used when generating contexts\nb3bf5f99a3 ecmult_impl: expand comment to explain how effective affine interacts with everything\nefa783f8f0 Store z-ratios in the 'x' coord they'll recover\nffd3b346fe add `secp256k1_ge_set_all_gej_var` test which deals with many infinite points\n84740acd2a ecmult_impl: save one fe_inv_var\n47045270fa ecmult_impl: eliminate scratch memory used when generating context\n7f7a2ed3a8 ecmult_gen_impl: eliminate scratch memory used when generating context\n314a61d724 Merge #553: add static context object which has no capabilities\n89a20a8945 Correct order of libs returned on pkg-config --libs --static libsecp256k1 call.\n1086fda4c1 Merge #354: [ECDH API change] Support custom hash function\nd3cb1f95eb Make use of TAG_PUBKEY constants in secp256k1_eckey_pubkey_parse\n40fde611bd prevent attempts to modify `secp256k1_context_no_precomp`\ned7c08417a add static context object which has no capabilities\n496c5b43b8 Make constants static: static const secp256k1_ge secp256k1_ge_const_g; static const int CURVE_B;\nbf8b86cc07 secp256k1_fe_sqrt: Verify that the arguments don't alias.\n9bd89c836b Optimize secp256k1_fe_normalize_weak calls. Move secp256k1_fe_normalize_weak calls out of ECMULT_TABLE_GET_GE and ECMULT_TABLE_GET_GE_STORAGE and into secp256k1_ge_globalz_set_table_gej instead.\n52ab96fedb clean dependendies in field_*_impl.h\ndeff5edd42 Correct math typos in field_*.h\n4efb3f8dd1 Add check that restrict pointers don't alias with all parameters.\n1e6f1f5ad5 Merge #529: fix tests.c in the count == 0 case\nc8fbc3c397 [ECDH API change] Allow pass arbitrary data to hash function\nb00be65056 [ECDH API change] Support custom hash function\n95e99f196f fix tests.c in the count == 0 case\n452d8e4d2a Merge #523: scratch: add stack frame support\n6fe50439ae scratch: add stack frame support\n9bc2e26502 Merge #522: parameterize ecmult_const over input size\n7c1b91ba4b parameterize ecmult_const over input size\ndbc3ddd5e2 Merge #513: Increase sparsity of pippenger fixed window naf representation\n3965027c81 Summarize build options in configure script\n0f0517369c Fix algorithm selection in bench_ecmult\nfb9271dcf0 Merge #510: add a couple missing `const`s to ecmult_pippenger_wnaf\ncd5f6028e5 Merge #515: Fix typo\n09146ae854 Merge #512: secp256k1_ec_privkey_negate - fix documentation\nec0a7b3ae3 Don't touch leading zeros in wnaf_fixed.\n9e36d1bfe2 Fix bug in wnaf_fixed where the wnaf array is not completely zeroed when given a 0 scalar.\n96f68a0afc Don't invert scalar in wnaf_fixed when it is even because a caller might intentionally give a scalar with many leading zeros.\n8b3841c91d fix bug in fread() failure check\ncddef0c0be tests: add warning message when /dev/urandom fails\n9b7c47a21e Fix typo\n6dbb007869 Increase sparsity of pippenger fixed window naf representation\n1646ace4d5 secp256k1_ec_privkey_negate - fix documentation\n270f6c80db Portability fix for the configure scripts generated\n9b3ff0309d add a couple missing `const`s to ecmult_pippenger_wnaf\ncd329dbc3e Merge #460: [build] Update ax_jni_include_dir.m4 macro\n7f9c1a1565 Merge #498: tests: Avoid calling fclose(...) with an invalid argument\nf99aa8d4d3 Merge #499: tests: Make sure we get the requested number of bytes from /dev/urandom\nb549d3d5f7 Merge #472: [build] Set --enable-jni to no by default instead of auto.\nd333521516 Merge #494: Support OpenSSL versions >= 1.1 for ENABLE_OPENSSL_TESTS\n2ef8ea5d21 Merge #495: Add bench_ecmult to .gitignore\n82a96e4587 tests: Make sure we get the requested number of bytes from /dev/urandom\n5aae5b5bb2 Avoid calling fclose(...) with an invalid argument\ncb32940df3 Add bench_ecmult to .gitignore\n31abd3ab8d Support OpenSSL versions >= 1.1 for ENABLE_OPENSSL_TESTS\nc95f6f1360 Merge #487: fix tests typo, s/changed/unchanged\nfb46c83881 Merge #463: Reduce usage of hardcoded size constants\n02f5001dfc Merge #490: Disambiguate bench functions and types\n1f46d6089e Disambiguate bench functions and types\nf54c6c5083 Merge #480: Enable benchmark building by default\nc77fc08597 Merge #486: Add pippenger_wnaf for multi-multiplication\nd2f9c6b5dc Use more precise pippenger bucket windows\n4c950bbeaf Save some additions per window in _pippenger_wnaf\na58f543f5a Add flags for choosing algorithm in ecmult_multi benchmark\n36b22c9337 Use scratch space dependent batching in ecmult_multi\n355a38f113 Add pippenger_wnaf ecmult_multi\nbc65aa794e Add bench_ecmult\ndba5471b69 Add ecmult_multi tests\n8c1c831bdb Generalize Strauss to support multiple points\n548de42ecf add resizeable scratch space API\n0e96cdc6b6 fix typo, s/changed/unchanged\nc7680e570f Reduce usage of hardcoded size constants\n6ad5cdb42a Merge #479: Get rid of reserved _t in type names\n7a78f60598 Print whether we're building benchmarks\n4afec9f1ae Build benchmarks by default\nd1dc9dfc0a Get rid of reserved _t in type names\n57752d28b3 [build] Set --enable-jni to no by default instead of auto.\ne7daa9b3c2 [build] Tweak JNI macro to warn instead of error for JNI not found.\n5b22977922 [build] Update ax_jni_include_dir.m4 macro to deal with recent versions of macOS\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: b19c000063be11018b4d1a6b0a85871ab9d0bdcf",
      "tree": {
        "sha": "e862ca412860538b4969e6f77c8c005695e5ed28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e862ca412860538b4969e6f77c8c005695e5ed28"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54245985fb3c89d72e285c4db39d38ed2f5fb0de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54245985fb3c89d72e285c4db39d38ed2f5fb0de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54245985fb3c89d72e285c4db39d38ed2f5fb0de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54245985fb3c89d72e285c4db39d38ed2f5fb0de/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd86f998fcfd25d823d67a2920814e22445655f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd86f998fcfd25d823d67a2920814e22445655f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd86f998fcfd25d823d67a2920814e22445655f9"
      }
    ],
    "stats": {
      "total": 2831,
      "additions": 2415,
      "deletions": 416
    },
    "files": [
      {
        "sha": "55d325aeefa9c084a06e78808ddde841d702538c",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,5 +1,6 @@\n bench_inv\n bench_ecdh\n+bench_ecmult\n bench_sign\n bench_verify\n bench_schnorr_verify"
      },
      {
        "sha": "74f658f4d1c6d47c67618e4305cd0d0c21b92078",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,5 +1,5 @@\n language: c\n-sudo: false\n+os: linux\n addons:\n   apt:\n     packages: libgmp-dev\n@@ -11,7 +11,7 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n@@ -29,7 +29,7 @@ env:\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n-    - BUILD=check-java ECDH=yes EXPERIMENTAL=yes\n+    - BUILD=check-java JNI=yes ECDH=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -65,5 +65,4 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n-os: linux\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD"
      },
      {
        "sha": "9e5b7dcce0ab975ec61d55b6bc003c9587904bc0",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -42,6 +42,8 @@ noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n+noinst_HEADERS += src/scratch.h\n+noinst_HEADERS += src/scratch_impl.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n noinst_HEADERS += src/hash.h\n@@ -79,14 +81,17 @@ libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n-noinst_PROGRAMS += bench_verify bench_sign bench_internal\n+noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_ecmult_SOURCES = src/bench_ecmult.c\n+bench_ecmult_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_ecmult_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n TESTS =\n@@ -109,7 +114,7 @@ exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDE\n if !ENABLE_COVERAGE\n exhaustive_tests_CPPFLAGS += -DVERIFY\n endif\n-exhaustive_tests_LDADD = $(SECP_LIBS)\n+exhaustive_tests_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n@@ -146,19 +151,19 @@ endif\n \n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n-CFLAGS_FOR_BUILD += -Wall -Wextra -Wno-unused-function\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n gen_%.o: src/gen_%.c\n \t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n-\t$(CC_FOR_BUILD) $^ -o $@\n+\t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n \n $(libsecp256k1_la_OBJECTS): src/ecmult_static_context.h\n $(tests_OBJECTS): src/ecmult_static_context.h\n $(bench_internal_OBJECTS): src/ecmult_static_context.h\n+$(bench_ecmult_OBJECTS): src/ecmult_static_context.h\n \n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)"
      },
      {
        "sha": "cdc78d87d48b09d45830e47a70f59219c3fee2ce",
        "filename": "build-aux/m4/ax_jni_include_dir.m4",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_jni_include_dir.m4?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,5 +1,5 @@\n # ===========================================================================\n-#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+#    https://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n # ===========================================================================\n #\n # SYNOPSIS\n@@ -44,7 +44,7 @@\n #   and this notice are preserved. This file is offered as-is, without any\n #   warranty.\n \n-#serial 10\n+#serial 14\n \n AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n@@ -66,40 +66,45 @@ else\n fi\n \n case \"$host_os\" in\n-        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n-                        _JINC=\"$_JTOPDIR/Headers\";;\n-        *)              _JINC=\"$_JTOPDIR/include\";;\n+        darwin*)        # Apple Java headers are inside the Xcode bundle.\n+            macos_version=$(sw_vers -productVersion | sed -n -e 's/^@<:@0-9@:>@*.\\(@<:@0-9@:>@*\\).@<:@0-9@:>@*/\\1/p')\n+            if @<:@ \"$macos_version\" -gt \"7\" @:>@; then\n+                _JTOPDIR=\"$(xcrun --show-sdk-path)/System/Library/Frameworks/JavaVM.framework\"\n+                _JINC=\"$_JTOPDIR/Headers\"\n+            else\n+                _JTOPDIR=\"/System/Library/Frameworks/JavaVM.framework\"\n+                _JINC=\"$_JTOPDIR/Headers\"\n+            fi\n+            ;;\n+        *) _JINC=\"$_JTOPDIR/include\";;\n esac\n _AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n _AS_ECHO_LOG([_JINC=$_JINC])\n \n # On Mac OS X 10.6.4, jni.h is a symlink:\n # /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n # -> ../../CurrentJDK/Headers/jni.h.\n-\n AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n [\n-if test -f \"$_JINC/jni.h\"; then\n-  ac_cv_jni_header_path=\"$_JINC\"\n-  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n-else\n-  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n-  if test -f \"$_JTOPDIR/include/jni.h\"; then\n-    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+  if test -f \"$_JINC/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JINC\"\n     JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n   else\n-    ac_cv_jni_header_path=none\n+    _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+    if test -f \"$_JTOPDIR/include/jni.h\"; then\n+      ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+      JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+    else\n+      ac_cv_jni_header_path=none\n+    fi\n   fi\n-fi\n ])\n \n-\n-\n # get the likely subdirectories for system specific java includes\n case \"$host_os\" in\n bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n-darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n@@ -112,9 +117,9 @@ if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n   # add any subdirectories that are present\n   for JINCSUBDIR in $_JNI_INC_SUBDIRS\n   do\n-      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n-           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n-      fi\n+    if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+         JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+    fi\n   done\n fi\n ])"
      },
      {
        "sha": "3b3975cbdda81d9a96f7bece460c3d126ecc97b1",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -48,7 +48,6 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     EC_KEY_free(eckey);\n     ECDSA_SIG *sig_openssl;\n     sig_openssl = ECDSA_SIG_new();\n-    (void)sig_openssl->r;\n     ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])"
      },
      {
        "sha": "3b7a328c8af0acd9162152dccdb3ceb37f86358e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 60,
        "deletions": 29,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -85,9 +85,9 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is no)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n     [use_benchmark=$enableval],\n-    [use_benchmark=no])\n+    [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n     AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n@@ -135,9 +135,9 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=no])\n \n AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n     [use_jni=$enableval],\n-    [use_jni=auto])\n+    [use_jni=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n@@ -153,12 +153,6 @@ AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n \n AC_CHECK_TYPES([__int128])\n \n-AC_MSG_CHECKING([for __builtin_expect])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n-    [ AC_MSG_RESULT([yes]);AC_DEFINE(HAVE_BUILTIN_EXPECT,1,[Define this symbol if __builtin_expect is available]) ],\n-    [ AC_MSG_RESULT([no])\n-    ])\n-\n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n     CFLAGS=\"$CFLAGS -O0 --coverage\"\n@@ -168,27 +162,54 @@ else\n fi\n \n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  # Temporarily switch to an environment for the native compiler\n   save_cross_compiling=$cross_compiling\n   cross_compiling=no\n-  TEMP_CC=\"$CC\"\n+  SAVE_CC=\"$CC\"\n   CC=\"$CC_FOR_BUILD\"\n-  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  SAVE_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS_FOR_BUILD\"\n+  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n+  CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+  SAVE_LDFLAGS=\"$LDFLAGS\"\n+  LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n+\n+  warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n+  saved_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS $warn_CFLAGS_FOR_BUILD\"\n+  AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n+      [ AC_MSG_RESULT([yes]) ],\n+      [ AC_MSG_RESULT([no])\n+        CFLAGS=\"$saved_CFLAGS\"\n+      ])\n+\n+  AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n   AC_RUN_IFELSE(\n-    [AC_LANG_PROGRAM([], [return 0])],\n+    [AC_LANG_PROGRAM([], [])],\n     [working_native_cc=yes],\n     [working_native_cc=no],[dnl])\n-  CC=\"$TEMP_CC\"\n+\n+  CFLAGS_FOR_BUILD=\"$CFLAGS\"\n+\n+  # Restore the environment\n   cross_compiling=$save_cross_compiling\n+  CC=\"$SAVE_CC\"\n+  CFLAGS=\"$SAVE_CFLAGS\"\n+  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+  LDFLAGS=\"$SAVE_LDFLAGS\"\n \n   if test x\"$working_native_cc\" = x\"no\"; then\n+    AC_MSG_RESULT([no])\n     set_precomp=no\n+    m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n     if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n-      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+      AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n     else\n-      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+      AC_MSG_WARN([Disabling statically generated ecmult table because the native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n     fi\n   else\n-    AC_MSG_RESULT([ok])\n+    AC_MSG_RESULT([yes])\n     set_precomp=yes\n   fi\n else\n@@ -441,17 +462,6 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n-AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n-AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n-AC_MSG_NOTICE([Using field implementation: $set_field])\n-AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n-AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n-AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n-AC_MSG_NOTICE([Building for coverage analysis: $enable_coverage])\n-AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n-AC_MSG_NOTICE([Using jni: $use_jni])\n-\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -481,7 +491,7 @@ AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n-AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -491,3 +501,24 @@ unset PKG_CONFIG_PATH\n PKG_CONFIG_PATH=\"$PKGCONFIG_PATH_TEMP\"\n \n AC_OUTPUT\n+\n+echo\n+echo \"Build Options:\"\n+echo \"  with endomorphism   = $use_endomorphism\"\n+echo \"  with ecmult precomp = $set_precomp\"\n+echo \"  with jni            = $use_jni\"\n+echo \"  with benchmarks     = $use_benchmark\"\n+echo \"  with coverage       = $enable_coverage\"\n+echo \"  module ecdh         = $enable_module_ecdh\"\n+echo \"  module recovery     = $enable_module_recovery\"\n+echo\n+echo \"  asm                 = $set_asm\"\n+echo \"  bignum              = $set_bignum\"\n+echo \"  field               = $set_field\"\n+echo \"  scalar              = $set_scalar\"\n+echo\n+echo \"  CC                  = $CC\"\n+echo \"  CFLAGS              = $CFLAGS\"\n+echo \"  CPPFLAGS            = $CPPFLAGS\"\n+echo \"  LDFLAGS             = $LDFLAGS\"\n+echo"
      },
      {
        "sha": "43af09c330de4e8a21552e821ee946d6f198738d",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 47,
        "deletions": 2,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -42,6 +42,19 @@ extern \"C\" {\n  */\n typedef struct secp256k1_context_struct secp256k1_context;\n \n+/** Opaque data structure that holds rewriteable \"scratch space\"\n+ *\n+ *  The purpose of this structure is to replace dynamic memory allocations,\n+ *  because we target architectures where this may not be available. It is\n+ *  essentially a resizable (within specified parameters) block of bytes,\n+ *  which is initially created either by memory allocation or TODO as a pointer\n+ *  into some fixed rewritable space.\n+ *\n+ *  Unlike the context object, this cannot safely be shared between threads\n+ *  without additional synchronization logic.\n+ */\n+typedef struct secp256k1_scratch_space_struct secp256k1_scratch_space;\n+\n /** Opaque data structure that holds a parsed and valid public key.\n  *\n  *  The exact representation of data inside is implementation defined and not\n@@ -166,6 +179,13 @@ typedef int (*secp256k1_nonce_function)(\n #define SECP256K1_TAG_PUBKEY_HYBRID_EVEN 0x06\n #define SECP256K1_TAG_PUBKEY_HYBRID_ODD 0x07\n \n+/** A simple secp256k1 context object with no precomputed tables. These are useful for\n+ *  type serialization/parsing functions which require a context object to maintain\n+ *  API consistency, but currently do not require expensive precomputations or dynamic\n+ *  allocations.\n+ */\n+SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n+\n /** Create a secp256k1 context object.\n  *\n  *  Returns: a newly created context object.\n@@ -243,6 +263,26 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n     const void* data\n ) SECP256K1_ARG_NONNULL(1);\n \n+/** Create a secp256k1 scratch space object.\n+ *\n+ *  Returns: a newly created scratch space.\n+ *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  In:   max_size: maximum amount of memory to allocate\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n+    const secp256k1_context* ctx,\n+    size_t max_size\n+) SECP256K1_ARG_NONNULL(1);\n+\n+/** Destroy a secp256k1 scratch space.\n+ *\n+ *  The pointer may not be used afterwards.\n+ *  Args:   scratch: space to destroy\n+ */\n+SECP256K1_API void secp256k1_scratch_space_destroy(\n+    secp256k1_scratch_space* scratch\n+);\n+\n /** Parse a variable-length public key into the pubkey object.\n  *\n  *  Returns: 1 if the public key was fully valid.\n@@ -498,7 +538,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n  *\n  *  Returns: 1 always\n  *  Args:   ctx:        pointer to a context object\n- *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ *  In/Out: seckey:     pointer to the 32-byte private key to be negated (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n     const secp256k1_context* ctx,\n@@ -575,7 +615,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Updates the context randomization to protect against side-channel leakage.\n- *  Returns: 1: randomization successfully updated\n+ *  Returns: 1: randomization successfully updated or nothing to randomize\n  *           0: error\n  *  Args:    ctx:       pointer to a context object (cannot be NULL)\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n@@ -590,6 +630,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * that it does not affect function results, but shields against attacks which\n  * rely on any input-dependent behaviour.\n  *\n+ * This function has currently an effect only on contexts initialized for signing\n+ * because randomization is currently used only for signing. However, this is not\n+ * guaranteed and may change in the future. It is safe to call this function on\n+ * contexts not initialized for signing; then it will have no effect and return 1.\n+ *\n  * You should call this after secp256k1_context_create or\n  * secp256k1_context_clone, and may call this repeatedly afterwards.\n  */"
      },
      {
        "sha": "df5fde235c7b97d802d6abc071d2b54b2497c2b0",
        "filename": "include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 28,
        "deletions": 4,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_ecdh.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -7,21 +7,45 @@\n extern \"C\" {\n #endif\n \n+/** A pointer to a function that applies hash function to a point\n+ *\n+ *  Returns: 1 if a point was successfully hashed. 0 will cause ecdh to fail\n+ *  Out:    output:     pointer to an array to be filled by the function\n+ *  In:     x:          pointer to a 32-byte x coordinate\n+ *          y:          pointer to a 32-byte y coordinate\n+ *          data:       Arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ecdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x,\n+  const unsigned char *y,\n+  void *data\n+);\n+\n+/** An implementation of SHA256 hash function that applies to compressed public key. */\n+SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256;\n+\n+/** A default ecdh hash function (currently equal to secp256k1_ecdh_hash_function_sha256). */\n+SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default;\n+\n /** Compute an EC Diffie-Hellman secret in constant time\n  *  Returns: 1: exponentiation was successful\n  *           0: scalar was invalid (zero or overflow)\n  *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     result:     a 32-byte array which will be populated by an ECDH\n- *                       secret computed from the point and scalar\n+ *  Out:     output:     pointer to an array to be filled by the function\n  *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n  *                       initialized public key\n  *           privkey:    a 32-byte scalar with which to multiply the point\n+ *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n+ *           data:       Arbitrary data pointer that is passed through\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,\n-  unsigned char *result,\n+  unsigned char *output,\n   const secp256k1_pubkey *pubkey,\n-  const unsigned char *privkey\n+  const unsigned char *privkey,\n+  secp256k1_ecdh_hash_function hashfp,\n+  void *data\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n #ifdef __cplusplus"
      },
      {
        "sha": "694e98eef51ea7fe45317aa7f2ffbc9152f0ebe3",
        "filename": "libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/libsecp256k1.pc.in?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -8,6 +8,6 @@ Description: Optimized C library for EC operations on curve secp256k1\n URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n-Libs.private: @SECP_LIBS@\n Libs: -L${libdir} -lsecp256k1\n+Libs.private: @SECP_LIBS@\n "
      },
      {
        "sha": "5b59783f68a950f61a74372325635ddc1b194326",
        "filename": "src/bench.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_BENCH_H\n \n #include <stdio.h>\n+#include <string.h>\n #include <math.h>\n #include \"sys/time.h\"\n \n@@ -63,4 +64,19 @@ void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), v\n     printf(\"us\\n\");\n }\n \n+int have_flag(int argc, char** argv, char *flag) {\n+    char** argm = argv + argc;\n+    argv++;\n+    if (argv == argm) {\n+        return 1;\n+    }\n+    while (argv != NULL && argv != argm) {\n+        if (strcmp(*argv, flag) == 0) {\n+            return 1;\n+        }\n+        argv++;\n+    }\n+    return 0;\n+}\n+\n #endif /* SECP256K1_BENCH_H */"
      },
      {
        "sha": "c1dd5a6ac93c8cbf0c4017673102e09a8ee3c392",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -15,11 +15,11 @@ typedef struct {\n     secp256k1_context *ctx;\n     secp256k1_pubkey point;\n     unsigned char scalar[32];\n-} bench_ecdh_t;\n+} bench_ecdh_data;\n \n static void bench_ecdh_setup(void* arg) {\n     int i;\n-    bench_ecdh_t *data = (bench_ecdh_t*)arg;\n+    bench_ecdh_data *data = (bench_ecdh_data*)arg;\n     const unsigned char point[] = {\n         0x03,\n         0x54, 0x94, 0xc1, 0x5d, 0x32, 0x09, 0x97, 0x06,\n@@ -39,15 +39,15 @@ static void bench_ecdh_setup(void* arg) {\n static void bench_ecdh(void* arg) {\n     int i;\n     unsigned char res[32];\n-    bench_ecdh_t *data = (bench_ecdh_t*)arg;\n+    bench_ecdh_data *data = (bench_ecdh_data*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        CHECK(secp256k1_ecdh(data->ctx, res, &data->point, data->scalar) == 1);\n+        CHECK(secp256k1_ecdh(data->ctx, res, &data->point, data->scalar, NULL, NULL) == 1);\n     }\n }\n \n int main(void) {\n-    bench_ecdh_t data;\n+    bench_ecdh_data data;\n \n     run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, 20000);\n     return 0;"
      },
      {
        "sha": "6d0ed1f4364e4eaa049db91f87f4725144054391",
        "filename": "src/bench_ecmult.c",
        "status": "added",
        "additions": 207,
        "deletions": 0,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -0,0 +1,207 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+#include <stdio.h>\n+\n+#include \"include/secp256k1.h\"\n+\n+#include \"util.h\"\n+#include \"hash_impl.h\"\n+#include \"num_impl.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"scalar_impl.h\"\n+#include \"ecmult_impl.h\"\n+#include \"bench.h\"\n+#include \"secp256k1.c\"\n+\n+#define POINTS 32768\n+#define ITERS 10000\n+\n+typedef struct {\n+    /* Setup once in advance */\n+    secp256k1_context* ctx;\n+    secp256k1_scratch_space* scratch;\n+    secp256k1_scalar* scalars;\n+    secp256k1_ge* pubkeys;\n+    secp256k1_scalar* seckeys;\n+    secp256k1_gej* expected_output;\n+    secp256k1_ecmult_multi_func ecmult_multi;\n+\n+    /* Changes per test */\n+    size_t count;\n+    int includes_g;\n+\n+    /* Changes per test iteration */\n+    size_t offset1;\n+    size_t offset2;\n+\n+    /* Test output. */\n+    secp256k1_gej* output;\n+} bench_data;\n+\n+static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    if (data->includes_g) ++idx;\n+    if (idx == 0) {\n+        *sc = data->scalars[data->offset1];\n+        *ge = secp256k1_ge_const_g;\n+    } else {\n+        *sc = data->scalars[(data->offset1 + idx) % POINTS];\n+        *ge = data->pubkeys[(data->offset2 + idx - 1) % POINTS];\n+    }\n+    return 1;\n+}\n+\n+static void bench_ecmult(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+\n+    size_t count = data->count;\n+    int includes_g = data->includes_g;\n+    size_t iters = 1 + ITERS / count;\n+    size_t iter;\n+\n+    for (iter = 0; iter < iters; ++iter) {\n+        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->offset1 = (data->offset1 + count) % POINTS;\n+        data->offset2 = (data->offset2 + count - 1) % POINTS;\n+    }\n+}\n+\n+static void bench_ecmult_setup(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+}\n+\n+static void bench_ecmult_teardown(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    size_t iters = 1 + ITERS / data->count;\n+    size_t iter;\n+    /* Verify the results in teardown, to avoid doing comparisons while benchmarking. */\n+    for (iter = 0; iter < iters; ++iter) {\n+        secp256k1_gej tmp;\n+        secp256k1_gej_add_var(&tmp, &data->output[iter], &data->expected_output[iter], NULL);\n+        CHECK(secp256k1_gej_is_infinity(&tmp));\n+    }\n+}\n+\n+static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n+    secp256k1_sha256 sha256;\n+    unsigned char c[11] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n+    unsigned char buf[32];\n+    int overflow = 0;\n+    c[6] = num;\n+    c[7] = num >> 8;\n+    c[8] = num >> 16;\n+    c[9] = num >> 24;\n+    secp256k1_sha256_initialize(&sha256);\n+    secp256k1_sha256_write(&sha256, c, sizeof(c));\n+    secp256k1_sha256_finalize(&sha256, buf);\n+    secp256k1_scalar_set_b32(scalar, buf, &overflow);\n+    CHECK(!overflow);\n+}\n+\n+static void run_test(bench_data* data, size_t count, int includes_g) {\n+    char str[32];\n+    static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    size_t iters = 1 + ITERS / count;\n+    size_t iter;\n+\n+    data->count = count;\n+    data->includes_g = includes_g;\n+\n+    /* Compute (the negation of) the expected results directly. */\n+    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    for (iter = 0; iter < iters; ++iter) {\n+        secp256k1_scalar tmp;\n+        secp256k1_scalar total = data->scalars[(data->offset1++) % POINTS];\n+        size_t i = 0;\n+        for (i = 0; i + 1 < count; ++i) {\n+            secp256k1_scalar_mul(&tmp, &data->seckeys[(data->offset2++) % POINTS], &data->scalars[(data->offset1++) % POINTS]);\n+            secp256k1_scalar_add(&total, &total, &tmp);\n+        }\n+        secp256k1_scalar_negate(&total, &total);\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->expected_output[iter], NULL, &zero, &total);\n+    }\n+\n+    /* Run the benchmark. */\n+    sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n+    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * (1 + ITERS / count));\n+}\n+\n+int main(int argc, char **argv) {\n+    bench_data data;\n+    int i, p;\n+    secp256k1_gej* pubkeys_gej;\n+    size_t scratch_size;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n+    data.ecmult_multi = secp256k1_ecmult_multi_var;\n+\n+    if (argc > 1) {\n+        if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n+            printf(\"Using pippenger_wnaf:\\n\");\n+            data.ecmult_multi = secp256k1_ecmult_pippenger_batch_single;\n+        } else if(have_flag(argc, argv, \"strauss_wnaf\")) {\n+            printf(\"Using strauss_wnaf:\\n\");\n+            data.ecmult_multi = secp256k1_ecmult_strauss_batch_single;\n+        } else if(have_flag(argc, argv, \"simple\")) {\n+            printf(\"Using simple algorithm:\\n\");\n+            data.ecmult_multi = secp256k1_ecmult_multi_var;\n+            secp256k1_scratch_space_destroy(data.scratch);\n+            data.scratch = NULL;\n+        } else {\n+            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n+            fprintf(stderr, \"Use 'pippenger_wnaf', 'strauss_wnaf', 'simple' or no argument to benchmark a combined algorithm.\\n\");\n+            return 1;\n+        }\n+    }\n+\n+    /* Allocate stuff */\n+    data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n+    data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n+    data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n+    data.expected_output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n+    data.output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n+\n+    /* Generate a set of scalars, and private/public keypairs. */\n+    pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n+    secp256k1_gej_set_ge(&pubkeys_gej[0], &secp256k1_ge_const_g);\n+    secp256k1_scalar_set_int(&data.seckeys[0], 1);\n+    for (i = 0; i < POINTS; ++i) {\n+        generate_scalar(i, &data.scalars[i]);\n+        if (i) {\n+            secp256k1_gej_double_var(&pubkeys_gej[i], &pubkeys_gej[i - 1], NULL);\n+            secp256k1_scalar_add(&data.seckeys[i], &data.seckeys[i - 1], &data.seckeys[i - 1]);\n+        }\n+    }\n+    secp256k1_ge_set_all_gej_var(data.pubkeys, pubkeys_gej, POINTS);\n+    free(pubkeys_gej);\n+\n+    for (i = 1; i <= 8; ++i) {\n+        run_test(&data, i, 1);\n+    }\n+\n+    for (p = 0; p <= 11; ++p) {\n+        for (i = 9; i <= 16; ++i) {\n+            run_test(&data, i << p, 1);\n+        }\n+    }\n+    secp256k1_context_destroy(data.ctx);\n+    if (data.scratch != NULL) {\n+        secp256k1_scratch_space_destroy(data.scratch);\n+    }\n+    free(data.scalars);\n+    free(data.pubkeys);\n+    free(data.seckeys);\n+    free(data.output);\n+    free(data.expected_output);\n+\n+    return(0);\n+}"
      },
      {
        "sha": "9071724331e1e1d76de33da50ab727a6d514de4e",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 35,
        "deletions": 48,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -25,10 +25,10 @@ typedef struct {\n     secp256k1_gej gej_x, gej_y;\n     unsigned char data[64];\n     int wnaf[256];\n-} bench_inv_t;\n+} bench_inv;\n \n void bench_setup(void* arg) {\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     static const unsigned char init_x[32] = {\n         0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n@@ -58,7 +58,7 @@ void bench_setup(void* arg) {\n \n void bench_scalar_add(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n@@ -67,7 +67,7 @@ void bench_scalar_add(void* arg) {\n \n void bench_scalar_negate(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_scalar_negate(&data->scalar_x, &data->scalar_x);\n@@ -76,7 +76,7 @@ void bench_scalar_negate(void* arg) {\n \n void bench_scalar_sqr(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_scalar_sqr(&data->scalar_x, &data->scalar_x);\n@@ -85,7 +85,7 @@ void bench_scalar_sqr(void* arg) {\n \n void bench_scalar_mul(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_scalar_mul(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n@@ -95,7 +95,7 @@ void bench_scalar_mul(void* arg) {\n #ifdef USE_ENDOMORPHISM\n void bench_scalar_split(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_scalar l, r;\n@@ -107,7 +107,7 @@ void bench_scalar_split(void* arg) {\n \n void bench_scalar_inverse(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000; i++) {\n         secp256k1_scalar_inverse(&data->scalar_x, &data->scalar_x);\n@@ -117,7 +117,7 @@ void bench_scalar_inverse(void* arg) {\n \n void bench_scalar_inverse_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000; i++) {\n         secp256k1_scalar_inverse_var(&data->scalar_x, &data->scalar_x);\n@@ -127,7 +127,7 @@ void bench_scalar_inverse_var(void* arg) {\n \n void bench_field_normalize(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_fe_normalize(&data->fe_x);\n@@ -136,7 +136,7 @@ void bench_field_normalize(void* arg) {\n \n void bench_field_normalize_weak(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_fe_normalize_weak(&data->fe_x);\n@@ -145,7 +145,7 @@ void bench_field_normalize_weak(void* arg) {\n \n void bench_field_mul(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_fe_mul(&data->fe_x, &data->fe_x, &data->fe_y);\n@@ -154,7 +154,7 @@ void bench_field_mul(void* arg) {\n \n void bench_field_sqr(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_fe_sqr(&data->fe_x, &data->fe_x);\n@@ -163,7 +163,7 @@ void bench_field_sqr(void* arg) {\n \n void bench_field_inverse(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_fe_inv(&data->fe_x, &data->fe_x);\n@@ -173,7 +173,7 @@ void bench_field_inverse(void* arg) {\n \n void bench_field_inverse_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_fe_inv_var(&data->fe_x, &data->fe_x);\n@@ -183,17 +183,19 @@ void bench_field_inverse_var(void* arg) {\n \n void bench_field_sqrt(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_fe t;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n+        t = data->fe_x;\n+        secp256k1_fe_sqrt(&data->fe_x, &t);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n \n void bench_group_double_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_double_var(&data->gej_x, &data->gej_x, NULL);\n@@ -202,7 +204,7 @@ void bench_group_double_var(void* arg) {\n \n void bench_group_add_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_add_var(&data->gej_x, &data->gej_x, &data->gej_y, NULL);\n@@ -211,7 +213,7 @@ void bench_group_add_var(void* arg) {\n \n void bench_group_add_affine(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_add_ge(&data->gej_x, &data->gej_x, &data->ge_y);\n@@ -220,7 +222,7 @@ void bench_group_add_affine(void* arg) {\n \n void bench_group_add_affine_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_add_ge_var(&data->gej_x, &data->gej_x, &data->ge_y, NULL);\n@@ -229,7 +231,7 @@ void bench_group_add_affine_var(void* arg) {\n \n void bench_group_jacobi_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_gej_has_quad_y_var(&data->gej_x);\n@@ -238,7 +240,7 @@ void bench_group_jacobi_var(void* arg) {\n \n void bench_ecmult_wnaf(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n@@ -248,19 +250,19 @@ void bench_ecmult_wnaf(void* arg) {\n \n void bench_wnaf_const(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A);\n+        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }\n \n \n void bench_sha256(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n-    secp256k1_sha256_t sha;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_sha256 sha;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_sha256_initialize(&sha);\n@@ -271,8 +273,8 @@ void bench_sha256(void* arg) {\n \n void bench_hmac_sha256(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n-    secp256k1_hmac_sha256_t hmac;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_hmac_sha256 hmac;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_hmac_sha256_initialize(&hmac, data->data, 32);\n@@ -283,8 +285,8 @@ void bench_hmac_sha256(void* arg) {\n \n void bench_rfc6979_hmac_sha256(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n-    secp256k1_rfc6979_hmac_sha256_t rng;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_rfc6979_hmac_sha256 rng;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_rfc6979_hmac_sha256_initialize(&rng, data->data, 64);\n@@ -311,7 +313,7 @@ void bench_context_sign(void* arg) {\n #ifndef USE_NUM_NONE\n void bench_num_jacobi(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n     secp256k1_num nx, norder;\n \n     secp256k1_scalar_get_num(&nx, &data->scalar_x);\n@@ -324,23 +326,8 @@ void bench_num_jacobi(void* arg) {\n }\n #endif\n \n-int have_flag(int argc, char** argv, char *flag) {\n-    char** argm = argv + argc;\n-    argv++;\n-    if (argv == argm) {\n-        return 1;\n-    }\n-    while (argv != NULL && argv != argm) {\n-        if (strcmp(*argv, flag) == 0) {\n-            return 1;\n-        }\n-        argv++;\n-    }\n-    return 0;\n-}\n-\n int main(int argc, char **argv) {\n-    bench_inv_t data;\n+    bench_inv data;\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, 2000000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, 2000000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, 200000);"
      },
      {
        "sha": "b806eed94e1501becbdfc1d89a741e2ec6076276",
        "filename": "src/bench_recover.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -13,11 +13,11 @@ typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n     unsigned char sig[64];\n-} bench_recover_t;\n+} bench_recover_data;\n \n void bench_recover(void* arg) {\n     int i;\n-    bench_recover_t *data = (bench_recover_t*)arg;\n+    bench_recover_data *data = (bench_recover_data*)arg;\n     secp256k1_pubkey pubkey;\n     unsigned char pubkeyc[33];\n \n@@ -38,7 +38,7 @@ void bench_recover(void* arg) {\n \n void bench_recover_setup(void* arg) {\n     int i;\n-    bench_recover_t *data = (bench_recover_t*)arg;\n+    bench_recover_data *data = (bench_recover_data*)arg;\n \n     for (i = 0; i < 32; i++) {\n         data->msg[i] = 1 + i;\n@@ -49,7 +49,7 @@ void bench_recover_setup(void* arg) {\n }\n \n int main(void) {\n-    bench_recover_t data;\n+    bench_recover_data data;\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n "
      },
      {
        "sha": "544b43963c8d10d08aaddbd748abaaf181296223",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -12,11 +12,11 @@ typedef struct {\n     secp256k1_context* ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n-} bench_sign_t;\n+} bench_sign;\n \n static void bench_sign_setup(void* arg) {\n     int i;\n-    bench_sign_t *data = (bench_sign_t*)arg;\n+    bench_sign *data = (bench_sign*)arg;\n \n     for (i = 0; i < 32; i++) {\n         data->msg[i] = i + 1;\n@@ -26,9 +26,9 @@ static void bench_sign_setup(void* arg) {\n     }\n }\n \n-static void bench_sign(void* arg) {\n+static void bench_sign_run(void* arg) {\n     int i;\n-    bench_sign_t *data = (bench_sign_t*)arg;\n+    bench_sign *data = (bench_sign*)arg;\n \n     unsigned char sig[74];\n     for (i = 0; i < 20000; i++) {\n@@ -45,11 +45,11 @@ static void bench_sign(void* arg) {\n }\n \n int main(void) {\n-    bench_sign_t data;\n+    bench_sign data;\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n-    run_benchmark(\"ecdsa_sign\", bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, 20000);\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "7c5b789325f40d2886ff28ede70ab4ff436700b8",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -18,7 +18,7 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge *elem, const unsigned char\n     if (size == 33 && (pub[0] == SECP256K1_TAG_PUBKEY_EVEN || pub[0] == SECP256K1_TAG_PUBKEY_ODD)) {\n         secp256k1_fe x;\n         return secp256k1_fe_set_b32(&x, pub+1) && secp256k1_ge_set_xo_var(elem, &x, pub[0] == SECP256K1_TAG_PUBKEY_ODD);\n-    } else if (size == 65 && (pub[0] == 0x04 || pub[0] == 0x06 || pub[0] == 0x07)) {\n+    } else if (size == 65 && (pub[0] == SECP256K1_TAG_PUBKEY_UNCOMPRESSED || pub[0] == SECP256K1_TAG_PUBKEY_HYBRID_EVEN || pub[0] == SECP256K1_TAG_PUBKEY_HYBRID_ODD)) {\n         secp256k1_fe x, y;\n         if (!secp256k1_fe_set_b32(&x, pub+1) || !secp256k1_fe_set_b32(&y, pub+33)) {\n             return 0;"
      },
      {
        "sha": "3d75a960f424712b68dab7bd7f71c79b73b1351d",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra      *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -9,6 +9,8 @@\n \n #include \"num.h\"\n #include \"group.h\"\n+#include \"scalar.h\"\n+#include \"scratch.h\"\n \n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */\n@@ -28,4 +30,19 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n /** Double multiply: R = na*A + ng*G */\n static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n+typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n+\n+/**\n+ * Multi-multiply: R = inp_g_sc * G + sum_i ni * Ai.\n+ * Chooses the right algorithm for a given number of points and scratch space\n+ * size. Resets and overwrites the given scratch space. If the points do not\n+ * fit in the scratch space the algorithm is repeatedly run with batches of\n+ * points. If no scratch space is given then a simple algorithm is used that\n+ * simply multiplies the points with the corresponding scalars and adds them up.\n+ * Returns: 1 on success (including when inp_g_sc is NULL and n is 0)\n+ *          0 if there is not enough scratch space for a single point or\n+ *          callback returns 0\n+ */\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+\n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "d4804b8b68faa3ce5944e1695ec5eda3d5db3cab",
        "filename": "src/ecmult_const.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -10,6 +10,8 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q);\n+/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "8411752eb069f6da43a8e555939f106c81d2abbd",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 57,
        "deletions": 40,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -12,13 +12,6 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n-#ifdef USE_ENDOMORPHISM\n-    #define WNAF_BITS 128\n-#else\n-    #define WNAF_BITS 256\n-#endif\n-#define WNAF_SIZE(w) ((WNAF_BITS + (w) - 1) / (w))\n-\n /* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n #define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n     int m; \\\n@@ -55,7 +48,7 @@\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n+static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -74,9 +67,14 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n      * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n      * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication. */\n-\n-    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n+     * this, and having the caller compensate after doing the multiplication.\n+     *\n+     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n+     * particular, to ensure that the outputs from the endomorphism-split fit into\n+     * 128 bits). If we negate, the parity of our number flips, inverting which of\n+     * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n+     * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n+     * we need to special-case it in this logic. */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n     bit = flip ^ !secp256k1_scalar_is_even(&s);\n@@ -95,7 +93,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < WNAF_BITS) {\n+    while (word * w < size) {\n         int sign;\n         int even;\n \n@@ -115,37 +113,44 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE(w));\n+    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n     return skew;\n }\n \n-\n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar) {\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar, int size) {\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n     int skew_1;\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n #endif\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n     secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n+    int rsize = size;\n+#ifdef USE_ENDOMORPHISM\n+    if (size > 128) {\n+        rsize = 128;\n+        /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+    } else\n+#endif\n+    {\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n-    /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n-    skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n-#else\n-    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n+        skew_lam = 0;\n #endif\n+    }\n \n     /* Calculate odd multiples of a.\n      * All multiples are brought to the same Z 'denominator', which is stored\n@@ -159,26 +164,30 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         secp256k1_fe_normalize_weak(&pre_a[i].y);\n     }\n #ifdef USE_ENDOMORPHISM\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n-        secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+    if (size > 128) {\n+        for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+            secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+        }\n     }\n #endif\n \n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-    i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n+    i = wnaf_1[WNAF_SIZE_BITS(rsize, WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n #ifdef USE_ENDOMORPHISM\n-    i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n-    secp256k1_gej_add_ge(r, r, &tmpa);\n+    if (size > 128) {\n+        i = wnaf_lam[WNAF_SIZE_BITS(rsize, WINDOW_A - 1)];\n+        VERIFY_CHECK(i != 0);\n+        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n+        secp256k1_gej_add_ge(r, r, &tmpa);\n+    }\n #endif\n     /* remaining loop iterations */\n-    for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n+    for (i = WNAF_SIZE_BITS(rsize, WINDOW_A - 1) - 1; i >= 0; i--) {\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n@@ -190,10 +199,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n #ifdef USE_ENDOMORPHISM\n-        n = wnaf_lam[i];\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n-        VERIFY_CHECK(n != 0);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n+        if (size > 128) {\n+            n = wnaf_lam[i];\n+            ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n+            VERIFY_CHECK(n != 0);\n+            secp256k1_gej_add_ge(r, r, &tmpa);\n+        }\n #endif\n     }\n \n@@ -213,14 +224,18 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n #ifdef USE_ENDOMORPHISM\n-        secp256k1_ge_to_storage(&correction_lam_stor, a);\n+        if (size > 128) {\n+            secp256k1_ge_to_storage(&correction_lam_stor, a);\n+        }\n #endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n #ifdef USE_ENDOMORPHISM\n-        secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+        if (size > 128) {\n+            secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+        }\n #endif\n \n         /* Apply the correction */\n@@ -229,10 +244,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         secp256k1_gej_add_ge(r, r, &correction);\n \n #ifdef USE_ENDOMORPHISM\n-        secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n-        secp256k1_ge_neg(&correction, &correction);\n-        secp256k1_ge_mul_lambda(&correction, &correction);\n-        secp256k1_gej_add_ge(r, r, &correction);\n+        if (size > 128) {\n+            secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n+            secp256k1_ge_neg(&correction, &correction);\n+            secp256k1_ge_mul_lambda(&correction, &correction);\n+            secp256k1_gej_add_ge(r, r, &correction);\n+        }\n #endif\n     }\n }"
      },
      {
        "sha": "d64505dc00107879dadae95dce1f87fb6aec1482",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -77,7 +77,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(prec, precj, 1024, cb);\n+        secp256k1_ge_set_all_gej_var(prec, precj, 1024);\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {\n@@ -161,7 +161,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     secp256k1_gej gb;\n     secp256k1_fe s;\n     unsigned char nonce32[32];\n-    secp256k1_rfc6979_hmac_sha256_t rng;\n+    secp256k1_rfc6979_hmac_sha256 rng;\n     int retry;\n     unsigned char keydata[64] = {0};\n     if (seed32 == NULL) {"
      },
      {
        "sha": "1986914a4fd5d3707aeaa75b97500c677186a3b3",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 852,
        "deletions": 77,
        "changes": 929,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,13 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/*****************************************************************************\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick *\n+ * Distributed under the MIT software license, see the accompanying          *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.       *\n+ *****************************************************************************/\n \n #ifndef SECP256K1_ECMULT_IMPL_H\n #define SECP256K1_ECMULT_IMPL_H\n \n #include <string.h>\n+#include <stdint.h>\n \n #include \"group.h\"\n #include \"scalar.h\"\n@@ -41,9 +42,36 @@\n #endif\n #endif\n \n+#ifdef USE_ENDOMORPHISM\n+    #define WNAF_BITS 128\n+#else\n+    #define WNAF_BITS 256\n+#endif\n+#define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n+#define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n+\n /** The number of entries a table with precomputed multiples needs to have. */\n #define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n \n+/* The number of objects allocated on the scratch space for ecmult_multi algorithms */\n+#define PIPPENGER_SCRATCH_OBJECTS 6\n+#define STRAUSS_SCRATCH_OBJECTS 6\n+\n+#define PIPPENGER_MAX_BUCKET_WINDOW 12\n+\n+/* Minimum number of points for which pippenger_wnaf is faster than strauss wnaf */\n+#ifdef USE_ENDOMORPHISM\n+    #define ECMULT_PIPPENGER_THRESHOLD 88\n+#else\n+    #define ECMULT_PIPPENGER_THRESHOLD 160\n+#endif\n+\n+#ifdef USE_ENDOMORPHISM\n+    #define ECMULT_MAX_POINTS_PER_BATCH 5000000\n+#else\n+    #define ECMULT_MAX_POINTS_PER_BATCH 10000000\n+#endif\n+\n /** Fill a table 'prej' with precomputed odd multiples of a. Prej will contain\n  *  the values [1*a,3*a,...,(2*n-1)*a], so it space for n values. zr[0] will\n  *  contain prej[0].z / a.z. The other zr[i] values = prej[i].z / prej[i-1].z.\n@@ -109,24 +137,135 @@ static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *p\n     secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A), pre, globalz, prej, zr);\n }\n \n-static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge_storage *pre, const secp256k1_gej *a, const secp256k1_callback *cb) {\n-    secp256k1_gej *prej = (secp256k1_gej*)checked_malloc(cb, sizeof(secp256k1_gej) * n);\n-    secp256k1_ge *prea = (secp256k1_ge*)checked_malloc(cb, sizeof(secp256k1_ge) * n);\n-    secp256k1_fe *zr = (secp256k1_fe*)checked_malloc(cb, sizeof(secp256k1_fe) * n);\n+static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp256k1_ge_storage *pre, const secp256k1_gej *a) {\n+    secp256k1_gej d;\n+    secp256k1_ge d_ge, p_ge;\n+    secp256k1_gej pj;\n+    secp256k1_fe zi;\n+    secp256k1_fe zr;\n+    secp256k1_fe dx_over_dz_squared;\n     int i;\n \n-    /* Compute the odd multiples in Jacobian form. */\n-    secp256k1_ecmult_odd_multiples_table(n, prej, zr, a);\n-    /* Convert them in batch to affine coordinates. */\n-    secp256k1_ge_set_table_gej_var(prea, prej, zr, n);\n-    /* Convert them to compact storage form. */\n-    for (i = 0; i < n; i++) {\n-        secp256k1_ge_to_storage(&pre[i], &prea[i]);\n+    VERIFY_CHECK(!a->infinity);\n+\n+    secp256k1_gej_double_var(&d, a, NULL);\n+\n+    /* First, we perform all the additions in an isomorphic curve obtained by multiplying\n+     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use\n+     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store\n+     * the resulting y-coordinate and the z-ratio, since we only have enough memory to\n+     * store two field elements. These are sufficient to efficiently undo the isomorphism\n+     * and recompute all the `x`s.\n+     */\n+    d_ge.x = d.x;\n+    d_ge.y = d.y;\n+    d_ge.infinity = 0;\n+\n+    secp256k1_ge_set_gej_zinv(&p_ge, a, &d.z);\n+    pj.x = p_ge.x;\n+    pj.y = p_ge.y;\n+    pj.z = a->z;\n+    pj.infinity = 0;\n+\n+    for (i = 0; i < (n - 1); i++) {\n+        secp256k1_fe_normalize_var(&pj.y);\n+        secp256k1_fe_to_storage(&pre[i].y, &pj.y);\n+        secp256k1_gej_add_ge_var(&pj, &pj, &d_ge, &zr);\n+        secp256k1_fe_normalize_var(&zr);\n+        secp256k1_fe_to_storage(&pre[i].x, &zr);\n     }\n \n-    free(prea);\n-    free(prej);\n-    free(zr);\n+    /* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */\n+    secp256k1_fe_mul(&zi, &pj.z, &d.z);\n+    secp256k1_fe_inv_var(&zi, &zi);\n+\n+    /* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so\n+     * that we can combine it with the saved z-ratios to compute the other zs\n+     * without any more inversions. */\n+    secp256k1_ge_set_gej_zinv(&p_ge, &pj, &zi);\n+    secp256k1_ge_to_storage(&pre[n - 1], &p_ge);\n+\n+    /* Compute the actual x-coordinate of D, which will be needed below. */\n+    secp256k1_fe_mul(&d.z, &zi, &pj.z);  /* d.z = 1/d.z */\n+    secp256k1_fe_sqr(&dx_over_dz_squared, &d.z);\n+    secp256k1_fe_mul(&dx_over_dz_squared, &dx_over_dz_squared, &d.x);\n+\n+    /* Going into the second loop, we have set `pre[n-1]` to its final affine\n+     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We\n+     * have `zi = (p.z * d.z)^-1`, where\n+     *\n+     *     `p.z` is the z-coordinate of the point on the isomorphic curve\n+     *           which was ultimately assigned to `pre[n-1]`.\n+     *     `d.z` is the multiplier that must be applied to all z-coordinates\n+     *           to move from our isomorphic curve back to secp256k1; so the\n+     *           product `p.z * d.z` is the z-coordinate of the secp256k1\n+     *           point assigned to `pre[n-1]`.\n+     *\n+     * All subsequent inverse-z-coordinates can be obtained by multiplying this\n+     * factor by successive z-ratios, which is much more efficient than directly\n+     * computing each one.\n+     *\n+     * Importantly, these inverse-zs will be coordinates of points on secp256k1,\n+     * while our other stored values come from computations on the isomorphic\n+     * curve. So in the below loop, we will take care not to actually use `zi`\n+     * or any derived values until we're back on secp256k1.\n+     */\n+    i = n - 1;\n+    while (i > 0) {\n+        secp256k1_fe zi2, zi3;\n+        const secp256k1_fe *rzr;\n+        i--;\n+\n+        secp256k1_ge_from_storage(&p_ge, &pre[i]);\n+\n+        /* For each remaining point, we extract the z-ratio from the stored\n+         * x-coordinate, compute its z^-1 from that, and compute the full\n+         * point from that. */\n+        rzr = &p_ge.x;\n+        secp256k1_fe_mul(&zi, &zi, rzr);\n+        secp256k1_fe_sqr(&zi2, &zi);\n+        secp256k1_fe_mul(&zi3, &zi2, &zi);\n+        /* To compute the actual x-coordinate, we use the stored z ratio and\n+         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`\n+         * in the loop above, as well as the inverse of the square of its\n+         * z-coordinate. We store the latter in the `zi2` variable, which is\n+         * computed iteratively starting from the overall Z inverse then\n+         * multiplying by each z-ratio in turn.\n+         *\n+         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`\n+         * from the inside of the above `gej_add_ge_var` call. This satisfies\n+         *\n+         *    rzr = d_x * z^2 - x * d_z^2\n+         *\n+         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`\n+         * are Jacobian coordinates of our desired point -- except both are on\n+         * the isomorphic curve that we were using when we called `gej_add_ge_var`.\n+         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or\n+         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes\n+         *\n+         *    rzr = d_x * z^2 / d_z^2 - x\n+         *\n+         * (The left-hand-side, being a ratio of z-coordinates, is unaffected\n+         * by the isomorphism.)\n+         *\n+         * Rearranging to solve for `x`, we have\n+         *\n+         *     x = d_x * z^2 / d_z^2 - rzr\n+         *\n+         * But what we actually want is the affine coordinate `X = x/z^2`,\n+         * which will satisfy\n+         *\n+         *     X = d_x / d_z^2 - rzr / z^2\n+         *       = dx_over_dz_squared - rzr * zi2\n+         */\n+        secp256k1_fe_mul(&p_ge.x, rzr, &zi2);\n+        secp256k1_fe_negate(&p_ge.x, &p_ge.x, 1);\n+        secp256k1_fe_add(&p_ge.x, &dx_over_dz_squared);\n+        /* y is stored_y/z^3, as we expect */\n+        secp256k1_fe_mul(&p_ge.y, &p_ge.y, &zi3);\n+        /* Store */\n+        secp256k1_ge_to_storage(&pre[i], &p_ge);\n+    }\n }\n \n /** The following two macro retrieves a particular odd multiple from a table\n@@ -138,7 +277,8 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n     if ((n) > 0) { \\\n         *(r) = (pre)[((n)-1)/2]; \\\n     } else { \\\n-        secp256k1_ge_neg((r), &(pre)[(-(n)-1)/2]); \\\n+        *(r) = (pre)[(-(n)-1)/2]; \\\n+        secp256k1_fe_negate(&((r)->y), &((r)->y), 1); \\\n     } \\\n } while(0)\n \n@@ -150,7 +290,7 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n         secp256k1_ge_from_storage((r), &(pre)[((n)-1)/2]); \\\n     } else { \\\n         secp256k1_ge_from_storage((r), &(pre)[(-(n)-1)/2]); \\\n-        secp256k1_ge_neg((r), (r)); \\\n+        secp256k1_fe_negate(&((r)->y), &((r)->y), 1); \\\n     } \\\n } while(0)\n \n@@ -174,7 +314,7 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n \n     /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj, cb);\n+    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n \n #ifdef USE_ENDOMORPHISM\n     {\n@@ -188,7 +328,7 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         for (i = 0; i < 128; i++) {\n             secp256k1_gej_double_var(&g_128j, &g_128j, NULL);\n         }\n-        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j, cb);\n+        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n     }\n #endif\n }\n@@ -283,50 +423,78 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     return last_set_bit + 1;\n }\n \n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n-    secp256k1_fe Z;\n+struct secp256k1_strauss_point_state {\n #ifdef USE_ENDOMORPHISM\n-    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_scalar na_1, na_lam;\n-    /* Splitted G factors. */\n-    secp256k1_scalar ng_1, ng_128;\n     int wnaf_na_1[130];\n     int wnaf_na_lam[130];\n     int bits_na_1;\n     int bits_na_lam;\n-    int wnaf_ng_1[129];\n-    int bits_ng_1;\n-    int wnaf_ng_128[129];\n-    int bits_ng_128;\n #else\n     int wnaf_na[256];\n     int bits_na;\n+#endif\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_strauss_state {\n+    secp256k1_gej* prej;\n+    secp256k1_fe* zr;\n+    secp256k1_ge* pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge* pre_a_lam;\n+#endif\n+    struct secp256k1_strauss_point_state* ps;\n+};\n+\n+static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, int num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_ge tmpa;\n+    secp256k1_fe Z;\n+#ifdef USE_ENDOMORPHISM\n+    /* Splitted G factors. */\n+    secp256k1_scalar ng_1, ng_128;\n+    int wnaf_ng_1[129];\n+    int bits_ng_1 = 0;\n+    int wnaf_ng_128[129];\n+    int bits_ng_128 = 0;\n+#else\n     int wnaf_ng[256];\n-    int bits_ng;\n+    int bits_ng = 0;\n #endif\n     int i;\n-    int bits;\n+    int bits = 0;\n+    int np;\n+    int no = 0;\n \n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&na[np]) || secp256k1_gej_is_infinity(&a[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n #ifdef USE_ENDOMORPHISM\n-    /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&na_1, &na_lam, na);\n-\n-    /* build wnaf representation for na_1 and na_lam. */\n-    bits_na_1   = secp256k1_ecmult_wnaf(wnaf_na_1,   130, &na_1,   WINDOW_A);\n-    bits_na_lam = secp256k1_ecmult_wnaf(wnaf_na_lam, 130, &na_lam, WINDOW_A);\n-    VERIFY_CHECK(bits_na_1 <= 130);\n-    VERIFY_CHECK(bits_na_lam <= 130);\n-    bits = bits_na_1;\n-    if (bits_na_lam > bits) {\n-        bits = bits_na_lam;\n-    }\n+        /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */\n+        secp256k1_scalar_split_lambda(&state->ps[no].na_1, &state->ps[no].na_lam, &na[np]);\n+\n+        /* build wnaf representation for na_1 and na_lam. */\n+        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   130, &state->ps[no].na_1,   WINDOW_A);\n+        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 130, &state->ps[no].na_lam, WINDOW_A);\n+        VERIFY_CHECK(state->ps[no].bits_na_1 <= 130);\n+        VERIFY_CHECK(state->ps[no].bits_na_lam <= 130);\n+        if (state->ps[no].bits_na_1 > bits) {\n+            bits = state->ps[no].bits_na_1;\n+        }\n+        if (state->ps[no].bits_na_lam > bits) {\n+            bits = state->ps[no].bits_na_lam;\n+        }\n #else\n-    /* build wnaf representation for na. */\n-    bits_na     = secp256k1_ecmult_wnaf(wnaf_na,     256, na,      WINDOW_A);\n-    bits = bits_na;\n+        /* build wnaf representation for na. */\n+        state->ps[no].bits_na     = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na,     256, &na[np],      WINDOW_A);\n+        if (state->ps[no].bits_na > bits) {\n+            bits = state->ps[no].bits_na;\n+        }\n #endif\n+        ++no;\n+    }\n \n     /* Calculate odd multiples of a.\n      * All multiples are brought to the same Z 'denominator', which is stored\n@@ -338,29 +506,51 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n      * of 1/Z, so we can use secp256k1_gej_add_zinv_var, which uses the same\n      * isomorphism to efficiently add with a known Z inverse.\n      */\n-    secp256k1_ecmult_odd_multiples_table_globalz_windowa(pre_a, &Z, a);\n+    if (no > 0) {\n+        /* Compute the odd multiples in Jacobian form. */\n+        secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->prej, state->zr, &a[state->ps[0].input_pos]);\n+        for (np = 1; np < no; ++np) {\n+            secp256k1_gej tmp = a[state->ps[np].input_pos];\n+#ifdef VERIFY\n+            secp256k1_fe_normalize_var(&(state->prej[(np - 1) * ECMULT_TABLE_SIZE(WINDOW_A) + ECMULT_TABLE_SIZE(WINDOW_A) - 1].z));\n+#endif\n+            secp256k1_gej_rescale(&tmp, &(state->prej[(np - 1) * ECMULT_TABLE_SIZE(WINDOW_A) + ECMULT_TABLE_SIZE(WINDOW_A) - 1].z));\n+            secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->prej + np * ECMULT_TABLE_SIZE(WINDOW_A), state->zr + np * ECMULT_TABLE_SIZE(WINDOW_A), &tmp);\n+            secp256k1_fe_mul(state->zr + np * ECMULT_TABLE_SIZE(WINDOW_A), state->zr + np * ECMULT_TABLE_SIZE(WINDOW_A), &(a[state->ps[np].input_pos].z));\n+        }\n+        /* Bring them to the same Z denominator. */\n+        secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A) * no, state->pre_a, &Z, state->prej, state->zr);\n+    } else {\n+        secp256k1_fe_set_int(&Z, 1);\n+    }\n \n #ifdef USE_ENDOMORPHISM\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n-        secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+    for (np = 0; np < no; ++np) {\n+        for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+            secp256k1_ge_mul_lambda(&state->pre_a_lam[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i]);\n+        }\n     }\n \n-    /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */\n-    secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n+    if (ng) {\n+        /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */\n+        secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n \n-    /* Build wnaf representation for ng_1 and ng_128 */\n-    bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   129, &ng_1,   WINDOW_G);\n-    bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, 129, &ng_128, WINDOW_G);\n-    if (bits_ng_1 > bits) {\n-        bits = bits_ng_1;\n-    }\n-    if (bits_ng_128 > bits) {\n-        bits = bits_ng_128;\n+        /* Build wnaf representation for ng_1 and ng_128 */\n+        bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   129, &ng_1,   WINDOW_G);\n+        bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, 129, &ng_128, WINDOW_G);\n+        if (bits_ng_1 > bits) {\n+            bits = bits_ng_1;\n+        }\n+        if (bits_ng_128 > bits) {\n+            bits = bits_ng_128;\n+        }\n     }\n #else\n-    bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     256, ng,      WINDOW_G);\n-    if (bits_ng > bits) {\n-        bits = bits_ng;\n+    if (ng) {\n+        bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     256, ng,      WINDOW_G);\n+        if (bits_ng > bits) {\n+            bits = bits_ng;\n+        }\n     }\n #endif\n \n@@ -370,13 +560,15 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n         int n;\n         secp256k1_gej_double_var(r, r, NULL);\n #ifdef USE_ENDOMORPHISM\n-        if (i < bits_na_1 && (n = wnaf_na_1[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-            secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n-        }\n-        if (i < bits_na_lam && (n = wnaf_na_lam[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n-            secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+        for (np = 0; np < no; ++np) {\n+            if (i < state->ps[np].bits_na_1 && (n = state->ps[np].wnaf_na_1[i])) {\n+                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n+                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+            }\n+            if (i < state->ps[np].bits_na_lam && (n = state->ps[np].wnaf_na_lam[i])) {\n+                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a_lam + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n+                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+            }\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n             ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n@@ -387,9 +579,11 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n #else\n-        if (i < bits_na && (n = wnaf_na[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-            secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+        for (np = 0; np < no; ++np) {\n+            if (i < state->ps[np].bits_na && (n = state->ps[np].wnaf_na[i])) {\n+                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n+                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+            }\n         }\n         if (i < bits_ng && (n = wnaf_ng[i])) {\n             ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n@@ -403,4 +597,585 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n+            secp256k1_scratch_deallocate_frame(scratch);\n+            return 0;\n+        }\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    secp256k1_scratch_deallocate_frame(scratch);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] is either 0 or an odd integer between -(1 << w) and (1 << w)\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 or 1\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int skew = 0;\n+    int pos;\n+    int max_pos;\n+    int last_w;\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        for (pos = 0; pos < WNAF_SIZE(w); pos++) {\n+            wnaf[pos] = 0;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+        skew = 1;\n+    }\n+\n+    wnaf[0] = secp256k1_scalar_get_bits_var(work, 0, w) + skew;\n+    /* Compute last window size. Relevant when window size doesn't divide the\n+     * number of bits in the scalar */\n+    last_w = WNAF_BITS - (WNAF_SIZE(w) - 1) * w;\n+\n+    /* Store the position of the first nonzero word in max_pos to allow\n+     * skipping leading zeros when calculating the wnaf. */\n+    for (pos = WNAF_SIZE(w) - 1; pos > 0; pos--) {\n+        int val = secp256k1_scalar_get_bits_var(work, pos * w, pos == WNAF_SIZE(w)-1 ? last_w : w);\n+        if(val != 0) {\n+            break;\n+        }\n+        wnaf[pos] = 0;\n+    }\n+    max_pos = pos;\n+    pos = 1;\n+\n+    while (pos <= max_pos) {\n+        int val = secp256k1_scalar_get_bits_var(work, pos * w, pos == WNAF_SIZE(w)-1 ? last_w : w);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= (1 << w);\n+            wnaf[pos] = (val + 1);\n+        } else {\n+            wnaf[pos] = val;\n+        }\n+        /* Set a coefficient to zero if it is 1 or -1 and the proceeding digit\n+         * is strictly negative or strictly positive respectively. Only change\n+         * coefficients at previous positions because above code assumes that\n+         * wnaf[pos - 1] is odd.\n+         */\n+        if (pos >= 2 && ((wnaf[pos - 1] == 1 && wnaf[pos - 2] < 0) || (wnaf[pos - 1] == -1 && wnaf[pos - 2] > 0))) {\n+            if (wnaf[pos - 1] == 1) {\n+                wnaf[pos - 2] += 1 << w;\n+            } else {\n+                wnaf[pos - 2] -= 1 << w;\n+            }\n+            wnaf[pos - 1] = 0;\n+        }\n+        ++pos;\n+    }\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, const secp256k1_scalar *sc, const secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+\n+        for(j = 0; j < bucket_window; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        secp256k1_gej_set_infinity(&running_sum);\n+        /* Accumulate the sum: bucket[0] + 3*bucket[1] + 5*bucket[2] + 7*bucket[3] + ...\n+         *                   = bucket[0] +   bucket[1] +   bucket[2] +   bucket[3] + ...\n+         *                   +         2 *  (bucket[1] + 2*bucket[2] + 3*bucket[3] + ...)\n+         * using an intermediate running sum:\n+         * running_sum = bucket[0] +   bucket[1] +   bucket[2] + ...\n+         *\n+         * The doubling is done implicitly by deferring the final window doubling (of 'r').\n+         */\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j > 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(r, r, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[0], NULL);\n+        secp256k1_gej_double_var(r, r, NULL);\n+        secp256k1_gej_add_var(r, r, &running_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 1) {\n+        return 1;\n+    } else if (n <= 4) {\n+        return 2;\n+    } else if (n <= 20) {\n+        return 3;\n+    } else if (n <= 57) {\n+        return 4;\n+    } else if (n <= 136) {\n+        return 5;\n+    } else if (n <= 235) {\n+        return 6;\n+    } else if (n <= 1260) {\n+        return 7;\n+    } else if (n <= 4420) {\n+        return 9;\n+    } else if (n <= 7880) {\n+        return 10;\n+    } else if (n <= 16050) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 1) {\n+        return 1;\n+    } else if (n <= 11) {\n+        return 2;\n+    } else if (n <= 45) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 275) {\n+        return 5;\n+    } else if (n <= 625) {\n+        return 6;\n+    } else if (n <= 1850) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 9630) {\n+        return 9;\n+    } else if (n <= 17900) {\n+        return 10;\n+    } else if (n <= 32800) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+/**\n+ * Returns the maximum optimal number of points for a bucket_window.\n+ */\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+    switch(bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+        case 1: return 1;\n+        case 2: return 4;\n+        case 3: return 20;\n+        case 4: return 57;\n+        case 5: return 136;\n+        case 6: return 235;\n+        case 7: return 1260;\n+        case 8: return 1260;\n+        case 9: return 4420;\n+        case 10: return 7880;\n+        case 11: return 16050;\n+        case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n+#else\n+        case 1: return 1;\n+        case 2: return 11;\n+        case 3: return 45;\n+        case 4: return 100;\n+        case 5: return 275;\n+        case 6: return 625;\n+        case 7: return 1850;\n+        case 8: return 3400;\n+        case 9: return 9630;\n+        case 10: return 17900;\n+        case 11: return 32800;\n+        case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n+#endif\n+    }\n+    return 0;\n+}\n+\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            secp256k1_scratch_deallocate_frame(scratch);\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    secp256k1_scratch_deallocate_frame(scratch);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+/**\n+ * Returns the maximum number of points in addition to G that can be used with\n+ * a given scratch space. The function ensures that fewer points may also be\n+ * used.\n+ */\n+static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+    int bucket_window;\n+    size_t res = 0;\n+\n+    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n+        size_t n_points;\n+        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n+        size_t space_for_points;\n+        size_t space_overhead;\n+        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+\n+#ifdef USE_ENDOMORPHISM\n+        entry_size = 2*entry_size;\n+#endif\n+        space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n+        if (space_overhead > max_alloc) {\n+            break;\n+        }\n+        space_for_points = max_alloc - space_overhead;\n+\n+        n_points = space_for_points/entry_size;\n+        n_points = n_points > max_points ? max_points : n_points;\n+        if (n_points > res) {\n+            res = n_points;\n+        }\n+        if (n_points < max_points) {\n+            /* A larger bucket_window may support even more points. But if we\n+             * would choose that then the caller couldn't safely use any number\n+             * smaller than what this function returns */\n+            break;\n+        }\n+    }\n+    return res;\n+}\n+\n+/* Computes ecmult_multi by simply multiplying and adding each point. Does not\n+ * require a scratch space */\n+static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n+    size_t point_idx;\n+    secp256k1_scalar szero;\n+    secp256k1_gej tmpj;\n+\n+    secp256k1_scalar_set_int(&szero, 0);\n+    secp256k1_gej_set_infinity(r);\n+    secp256k1_gej_set_infinity(&tmpj);\n+    /* r = inp_g_sc*G */\n+    secp256k1_ecmult(ctx, r, &tmpj, &szero, inp_g_sc);\n+    for (point_idx = 0; point_idx < n_points; point_idx++) {\n+        secp256k1_ge point;\n+        secp256k1_gej pointj;\n+        secp256k1_scalar scalar;\n+        if (!cb(&scalar, &point, point_idx, cbdata)) {\n+            return 0;\n+        }\n+        /* r += scalar*point */\n+        secp256k1_gej_set_ge(&pointj, &point);\n+        secp256k1_ecmult(ctx, &tmpj, &pointj, &scalar, NULL);\n+        secp256k1_gej_add_var(r, r, &tmpj, NULL);\n+    }\n+    return 1;\n+}\n+\n+/* Compute the number of batches and the batch size given the maximum batch size and the\n+ * total number of points */\n+static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n_batch_points, size_t max_n_batch_points, size_t n) {\n+    if (max_n_batch_points == 0) {\n+        return 0;\n+    }\n+    if (max_n_batch_points > ECMULT_MAX_POINTS_PER_BATCH) {\n+        max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    }\n+    if (n == 0) {\n+        *n_batches = 0;\n+        *n_batch_points = 0;\n+        return 1;\n+    }\n+    /* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */\n+    *n_batches = 1 + (n - 1) / max_n_batch_points;\n+    *n_batch_points = 1 + (n - 1) / *n_batches;\n+    return 1;\n+}\n+\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    size_t i;\n+\n+    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    size_t n_batches;\n+    size_t n_batch_points;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n == 0) {\n+        return 1;\n+    } else if (n == 0) {\n+        secp256k1_scalar szero;\n+        secp256k1_scalar_set_int(&szero, 0);\n+        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        return 1;\n+    }\n+    if (scratch == NULL) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+    }\n+\n+    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n+     * use pippenger. Otherwise use strauss */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n+        return 0;\n+    }\n+    if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n+        f = secp256k1_ecmult_pippenger_batch;\n+    } else {\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n+            return 0;\n+        }\n+        f = secp256k1_ecmult_strauss_batch;\n+    }\n+    for(i = 0; i < n_batches; i++) {\n+        size_t nbp = n < n_batch_points ? n : n_batch_points;\n+        size_t offset = n_batch_points*i;\n+        secp256k1_gej tmp;\n+        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_var(r, r, &tmp, NULL);\n+        n -= nbp;\n+    }\n+    return 1;\n+}\n+\n #endif /* SECP256K1_ECMULT_IMPL_H */"
      },
      {
        "sha": "5ff03c8abcc05aed65e1b736d042b8aedfe98e56",
        "filename": "src/field_10x26.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_10x26.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_10x26.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -10,7 +10,9 @@\n #include <stdint.h>\n \n typedef struct {\n-    /* X = sum(i=0..9, elem[i]*2^26) mod n */\n+    /* X = sum(i=0..9, n[i]*2^(i*26)) mod p\n+     * where p = 2^256 - 0x1000003D1\n+     */\n     uint32_t n[10];\n #ifdef VERIFY\n     int magnitude;"
      },
      {
        "sha": "4ae4fdcec884c124a81e45fa1226a17ce3585842",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -8,7 +8,6 @@\n #define SECP256K1_FIELD_REPR_IMPL_H\n \n #include \"util.h\"\n-#include \"num.h\"\n #include \"field.h\"\n \n #ifdef VERIFY\n@@ -486,7 +485,8 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(b[9], 26);\n \n     /** [... a b c] is a shorthand for ... + a<<52 + b<<26 + c<<0 mod n.\n-     *  px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 0 <= x <= 9, px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 9 <= x <= 18, px is a shorthand for sum(a[i]*b[x-i], i=(x-9)..9)\n      *  Note that [x 0 0 0 0 0 0 0 0 0 0] = [x*R1 x*R0].\n      */\n \n@@ -1069,6 +1069,7 @@ static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp2\n     secp256k1_fe_verify(a);\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n+    VERIFY_CHECK(a != b);\n #endif\n     secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY"
      },
      {
        "sha": "fc5bfe357e705d75b1185aa88f9017be2f37cc8e",
        "filename": "src/field_5x52.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -10,7 +10,9 @@\n #include <stdint.h>\n \n typedef struct {\n-    /* X = sum(i=0..4, elem[i]*2^52) mod n */\n+    /* X = sum(i=0..4, n[i]*2^(i*52)) mod p\n+     * where p = 2^256 - 0x1000003D1\n+     */\n     uint64_t n[5];\n #ifdef VERIFY\n     int magnitude;"
      },
      {
        "sha": "f4263320d510065c74808638a20ca85c09cc6abf",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -12,7 +12,6 @@\n #endif\n \n #include \"util.h\"\n-#include \"num.h\"\n #include \"field.h\"\n \n #if defined(USE_ASM_X86_64)\n@@ -422,6 +421,7 @@ static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp2\n     secp256k1_fe_verify(a);\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n+    VERIFY_CHECK(a != b);\n #endif\n     secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY"
      },
      {
        "sha": "bcbfb92ac265b2e450af0fae487b8586c30cff42",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -32,9 +32,11 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(b[3], 56);\n     VERIFY_BITS(b[4], 52);\n     VERIFY_CHECK(r != b);\n+    VERIFY_CHECK(a != b);\n \n     /*  [... a b c] is a shorthand for ... + a<<104 + b<<52 + c<<0 mod n.\n-     *  px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 0 <= x <= 4, px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 4 <= x <= 8, px is a shorthand for sum(a[i]*b[x-i], i=(x-4)..4)\n      *  Note that [x 0 0 0 0 0] = [x*R].\n      */\n "
      },
      {
        "sha": "6070caccfeaad68d387207e2c4de758202ca77f0",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -12,6 +12,7 @@\n #endif\n \n #include \"util.h\"\n+#include \"num.h\"\n \n #if defined(USE_FIELD_10X26)\n #include \"field_10x26_impl.h\"\n@@ -48,6 +49,8 @@ static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;\n     int j;\n \n+    VERIFY_CHECK(r != a);\n+\n     /** The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n      *  { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n      *  1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]"
      },
      {
        "sha": "87d296ebf0e2c34c02cc987247a571c8646cd6a1",
        "filename": "src/gen_context.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_context.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -41,7 +41,7 @@ int main(int argc, char **argv) {\n     \n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n-    fprintf(fp, \"#include \\\"group.h\\\"\\n\");\n+    fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n     fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n "
      },
      {
        "sha": "8e122ab429c56365d89f39c6d55d786e2766e7fe",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -65,12 +65,7 @@ static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n-static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb);\n-\n-/** Set a batch of group elements equal to the inputs given in jacobian\n- *  coordinates (with known z-ratios). zr must contain the known z-ratios such\n- *  that mul(a[i].z, zr[i+1]) == a[i+1].z. zr[0] is ignored. */\n-static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len);\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len);\n \n /** Bring a batch inputs given in jacobian coordinates (with known z-ratios) to\n  *  the same global z \"denominator\". zr must contain the known z-ratios such\n@@ -79,6 +74,9 @@ static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej\n  *  stored in globalz. */\n static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp256k1_fe *globalz, const secp256k1_gej *a, const secp256k1_fe *zr);\n \n+/** Set a group element (affine) equal to the point at infinity. */\n+static void secp256k1_ge_set_infinity(secp256k1_ge *r);\n+\n /** Set a group element (jacobian) equal to the point at infinity. */\n static void secp256k1_gej_set_infinity(secp256k1_gej *r);\n "
      },
      {
        "sha": "9b93c39e92f5c7bed9d444087f55af9bd9a293a2",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 40,
        "deletions": 35,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -38,22 +38,22 @@\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 199\n-const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n     0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n     0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n     0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n );\n \n-const int CURVE_B = 4;\n+static const int CURVE_B = 4;\n #  elif EXHAUSTIVE_TEST_ORDER == 13\n-const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n     0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n     0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n     0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n );\n-const int CURVE_B = 2;\n+static const int CURVE_B = 2;\n #  else\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n@@ -68,7 +68,7 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n-const int CURVE_B = 7;\n+static const int CURVE_B = 7;\n #endif\n \n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n@@ -126,46 +126,43 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     r->y = a->y;\n }\n \n-static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb) {\n-    secp256k1_fe *az;\n-    secp256k1_fe *azi;\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len) {\n+    secp256k1_fe u;\n     size_t i;\n-    size_t count = 0;\n-    az = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * len);\n+    size_t last_i = SIZE_MAX;\n+\n     for (i = 0; i < len; i++) {\n         if (!a[i].infinity) {\n-            az[count++] = a[i].z;\n+            /* Use destination's x coordinates as scratch space */\n+            if (last_i == SIZE_MAX) {\n+                r[i].x = a[i].z;\n+            } else {\n+                secp256k1_fe_mul(&r[i].x, &r[last_i].x, &a[i].z);\n+            }\n+            last_i = i;\n         }\n     }\n+    if (last_i == SIZE_MAX) {\n+        return;\n+    }\n+    secp256k1_fe_inv_var(&u, &r[last_i].x);\n \n-    azi = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * count);\n-    secp256k1_fe_inv_all_var(azi, az, count);\n-    free(az);\n-\n-    count = 0;\n-    for (i = 0; i < len; i++) {\n-        r[i].infinity = a[i].infinity;\n+    i = last_i;\n+    while (i > 0) {\n+        i--;\n         if (!a[i].infinity) {\n-            secp256k1_ge_set_gej_zinv(&r[i], &a[i], &azi[count++]);\n+            secp256k1_fe_mul(&r[last_i].x, &r[i].x, &u);\n+            secp256k1_fe_mul(&u, &u, &a[last_i].z);\n+            last_i = i;\n         }\n     }\n-    free(azi);\n-}\n-\n-static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len) {\n-    size_t i = len - 1;\n-    secp256k1_fe zi;\n+    VERIFY_CHECK(!a[last_i].infinity);\n+    r[last_i].x = u;\n \n-    if (len > 0) {\n-        /* Compute the inverse of the last z coordinate, and use it to compute the last affine output. */\n-        secp256k1_fe_inv(&zi, &a[i].z);\n-        secp256k1_ge_set_gej_zinv(&r[i], &a[i], &zi);\n-\n-        /* Work out way backwards, using the z-ratios to scale the x/y values. */\n-        while (i > 0) {\n-            secp256k1_fe_mul(&zi, &zi, &zr[i]);\n-            i--;\n-            secp256k1_ge_set_gej_zinv(&r[i], &a[i], &zi);\n+    for (i = 0; i < len; i++) {\n+        r[i].infinity = a[i].infinity;\n+        if (!a[i].infinity) {\n+            secp256k1_ge_set_gej_zinv(&r[i], &a[i], &r[i].x);\n         }\n     }\n }\n@@ -178,6 +175,8 @@ static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp\n         /* The z of the final point gives us the \"global Z\" for the table. */\n         r[i].x = a[i].x;\n         r[i].y = a[i].y;\n+        /* Ensure all y values are in weak normal form for fast negation of points */\n+        secp256k1_fe_normalize_weak(&r[i].y);\n         *globalz = a[i].z;\n         r[i].infinity = 0;\n         zs = zr[i];\n@@ -200,6 +199,12 @@ static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     secp256k1_fe_clear(&r->z);\n }\n \n+static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n+    r->infinity = 1;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+}\n+\n static void secp256k1_gej_clear(secp256k1_gej *r) {\n     r->infinity = 0;\n     secp256k1_fe_clear(&r->x);"
      },
      {
        "sha": "de26e4b89f8cbb9712d859116606ef11c8e3095d",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -14,28 +14,28 @@ typedef struct {\n     uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n-} secp256k1_sha256_t;\n+} secp256k1_sha256;\n \n-static void secp256k1_sha256_initialize(secp256k1_sha256_t *hash);\n-static void secp256k1_sha256_write(secp256k1_sha256_t *hash, const unsigned char *data, size_t size);\n-static void secp256k1_sha256_finalize(secp256k1_sha256_t *hash, unsigned char *out32);\n+static void secp256k1_sha256_initialize(secp256k1_sha256 *hash);\n+static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t size);\n+static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out32);\n \n typedef struct {\n-    secp256k1_sha256_t inner, outer;\n-} secp256k1_hmac_sha256_t;\n+    secp256k1_sha256 inner, outer;\n+} secp256k1_hmac_sha256;\n \n-static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256_t *hash, const unsigned char *key, size_t size);\n-static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256_t *hash, const unsigned char *data, size_t size);\n-static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256_t *hash, unsigned char *out32);\n+static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256 *hash, const unsigned char *key, size_t size);\n+static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256 *hash, const unsigned char *data, size_t size);\n+static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256 *hash, unsigned char *out32);\n \n typedef struct {\n     unsigned char v[32];\n     unsigned char k[32];\n     int retry;\n-} secp256k1_rfc6979_hmac_sha256_t;\n+} secp256k1_rfc6979_hmac_sha256;\n \n-static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256_t *rng, const unsigned char *key, size_t keylen);\n-static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256_t *rng, unsigned char *out, size_t outlen);\n-static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256_t *rng);\n+static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256 *rng, const unsigned char *key, size_t keylen);\n+static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256 *rng, unsigned char *out, size_t outlen);\n+static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256 *rng);\n \n #endif /* SECP256K1_HASH_H */"
      },
      {
        "sha": "009f26beba9398dd55b1342bc0da75670caae85c",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 25,
        "deletions": 24,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -33,7 +33,7 @@\n #define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n #endif\n \n-static void secp256k1_sha256_initialize(secp256k1_sha256_t *hash) {\n+static void secp256k1_sha256_initialize(secp256k1_sha256 *hash) {\n     hash->s[0] = 0x6a09e667ul;\n     hash->s[1] = 0xbb67ae85ul;\n     hash->s[2] = 0x3c6ef372ul;\n@@ -128,14 +128,15 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n     s[7] += h;\n }\n \n-static void secp256k1_sha256_write(secp256k1_sha256_t *hash, const unsigned char *data, size_t len) {\n+static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n     while (bufsize + len >= 64) {\n         /* Fill the buffer, and process it. */\n-        memcpy(((unsigned char*)hash->buf) + bufsize, data, 64 - bufsize);\n-        data += 64 - bufsize;\n-        len -= 64 - bufsize;\n+        size_t chunk_len = 64 - bufsize;\n+        memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);\n+        data += chunk_len;\n+        len -= chunk_len;\n         secp256k1_sha256_transform(hash->s, hash->buf);\n         bufsize = 0;\n     }\n@@ -145,7 +146,7 @@ static void secp256k1_sha256_write(secp256k1_sha256_t *hash, const unsigned char\n     }\n }\n \n-static void secp256k1_sha256_finalize(secp256k1_sha256_t *hash, unsigned char *out32) {\n+static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out32) {\n     static const unsigned char pad[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n     uint32_t sizedesc[2];\n     uint32_t out[8];\n@@ -161,39 +162,39 @@ static void secp256k1_sha256_finalize(secp256k1_sha256_t *hash, unsigned char *o\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n-static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256_t *hash, const unsigned char *key, size_t keylen) {\n-    int n;\n+static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256 *hash, const unsigned char *key, size_t keylen) {\n+    size_t n;\n     unsigned char rkey[64];\n-    if (keylen <= 64) {\n+    if (keylen <= sizeof(rkey)) {\n         memcpy(rkey, key, keylen);\n-        memset(rkey + keylen, 0, 64 - keylen);\n+        memset(rkey + keylen, 0, sizeof(rkey) - keylen);\n     } else {\n-        secp256k1_sha256_t sha256;\n+        secp256k1_sha256 sha256;\n         secp256k1_sha256_initialize(&sha256);\n         secp256k1_sha256_write(&sha256, key, keylen);\n         secp256k1_sha256_finalize(&sha256, rkey);\n         memset(rkey + 32, 0, 32);\n     }\n \n     secp256k1_sha256_initialize(&hash->outer);\n-    for (n = 0; n < 64; n++) {\n+    for (n = 0; n < sizeof(rkey); n++) {\n         rkey[n] ^= 0x5c;\n     }\n-    secp256k1_sha256_write(&hash->outer, rkey, 64);\n+    secp256k1_sha256_write(&hash->outer, rkey, sizeof(rkey));\n \n     secp256k1_sha256_initialize(&hash->inner);\n-    for (n = 0; n < 64; n++) {\n+    for (n = 0; n < sizeof(rkey); n++) {\n         rkey[n] ^= 0x5c ^ 0x36;\n     }\n-    secp256k1_sha256_write(&hash->inner, rkey, 64);\n-    memset(rkey, 0, 64);\n+    secp256k1_sha256_write(&hash->inner, rkey, sizeof(rkey));\n+    memset(rkey, 0, sizeof(rkey));\n }\n \n-static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256_t *hash, const unsigned char *data, size_t size) {\n+static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256 *hash, const unsigned char *data, size_t size) {\n     secp256k1_sha256_write(&hash->inner, data, size);\n }\n \n-static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256_t *hash, unsigned char *out32) {\n+static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256 *hash, unsigned char *out32) {\n     unsigned char temp[32];\n     secp256k1_sha256_finalize(&hash->inner, temp);\n     secp256k1_sha256_write(&hash->outer, temp, 32);\n@@ -202,8 +203,8 @@ static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256_t *hash, unsign\n }\n \n \n-static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256_t *rng, const unsigned char *key, size_t keylen) {\n-    secp256k1_hmac_sha256_t hmac;\n+static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256 *rng, const unsigned char *key, size_t keylen) {\n+    secp256k1_hmac_sha256 hmac;\n     static const unsigned char zero[1] = {0x00};\n     static const unsigned char one[1] = {0x01};\n \n@@ -232,11 +233,11 @@ static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha2\n     rng->retry = 0;\n }\n \n-static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256_t *rng, unsigned char *out, size_t outlen) {\n+static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256 *rng, unsigned char *out, size_t outlen) {\n     /* RFC6979 3.2.h. */\n     static const unsigned char zero[1] = {0x00};\n     if (rng->retry) {\n-        secp256k1_hmac_sha256_t hmac;\n+        secp256k1_hmac_sha256 hmac;\n         secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n         secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n         secp256k1_hmac_sha256_write(&hmac, zero, 1);\n@@ -247,7 +248,7 @@ static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256\n     }\n \n     while (outlen > 0) {\n-        secp256k1_hmac_sha256_t hmac;\n+        secp256k1_hmac_sha256 hmac;\n         int now = outlen;\n         secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n         secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n@@ -263,7 +264,7 @@ static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 1;\n }\n \n-static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256_t *rng) {\n+static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256 *rng) {\n     memset(rng->k, 0, 32);\n     memset(rng->v, 0, 32);\n     rng->retry = 0;"
      },
      {
        "sha": "d766a1029ce389a73207431bdf7c0376b1fc6e35",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -52,7 +52,7 @@ public static void testSecKeyVerifyPos() throws AssertFailException{\n     }\n \n     /**\n-      * This tests secret key verify() for a invalid secretkey\n+      * This tests secret key verify() for an invalid secretkey\n       */\n     public static void testSecKeyVerifyNeg() throws AssertFailException{\n         boolean result = false;"
      },
      {
        "sha": "b50970b4f24c8cd3480368aab34a9d83df92fe1b",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -83,7 +83,7 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n \n   secp256k1_ecdsa_signature sig[72];\n \n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n@@ -353,7 +353,9 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n       ctx,\n       nonce_res,\n       &pubkey,\n-      secdata\n+      secdata,\n+      NULL,\n+      NULL\n     );\n   }\n "
      },
      {
        "sha": "44cb68e75025126b21385d953fcfabfcd68d5381",
        "filename": "src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 27,
        "deletions": 14,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/main_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -10,41 +10,54 @@\n #include \"include/secp256k1_ecdh.h\"\n #include \"ecmult_const_impl.h\"\n \n-int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *result, const secp256k1_pubkey *point, const unsigned char *scalar) {\n+static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n+    unsigned char version = (y[31] & 0x01) | 0x02;\n+    secp256k1_sha256 sha;\n+    (void)data;\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &version, 1);\n+    secp256k1_sha256_write(&sha, x, 32);\n+    secp256k1_sha256_finalize(&sha, output);\n+\n+    return 1;\n+}\n+\n+const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256 = ecdh_hash_function_sha256;\n+const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default = ecdh_hash_function_sha256;\n+\n+int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *output, const secp256k1_pubkey *point, const unsigned char *scalar, secp256k1_ecdh_hash_function hashfp, void *data) {\n     int ret = 0;\n     int overflow = 0;\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(result != NULL);\n+    ARG_CHECK(output != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n+    if (hashfp == NULL) {\n+        hashfp = secp256k1_ecdh_hash_function_default;\n+    }\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);\n     if (overflow || secp256k1_scalar_is_zero(&s)) {\n         ret = 0;\n     } else {\n         unsigned char x[32];\n-        unsigned char y[1];\n-        secp256k1_sha256_t sha;\n+        unsigned char y[32];\n \n-        secp256k1_ecmult_const(&res, &pt, &s);\n+        secp256k1_ecmult_const(&res, &pt, &s, 256);\n         secp256k1_ge_set_gej(&pt, &res);\n-        /* Compute a hash of the point in compressed form\n-         * Note we cannot use secp256k1_eckey_pubkey_serialize here since it does not\n-         * expect its output to be secret and has a timing sidechannel. */\n+\n+        /* Compute a hash of the point */\n         secp256k1_fe_normalize(&pt.x);\n         secp256k1_fe_normalize(&pt.y);\n         secp256k1_fe_get_b32(x, &pt.x);\n-        y[0] = 0x02 | secp256k1_fe_is_odd(&pt.y);\n+        secp256k1_fe_get_b32(y, &pt.y);\n \n-        secp256k1_sha256_initialize(&sha);\n-        secp256k1_sha256_write(&sha, y, sizeof(y));\n-        secp256k1_sha256_write(&sha, x, sizeof(x));\n-        secp256k1_sha256_finalize(&sha, result);\n-        ret = 1;\n+        ret = hashfp(output, x, y, data);\n     }\n \n     secp256k1_scalar_clear(&s);"
      },
      {
        "sha": "fe26e8fb6957d59eac2aecebfe736adffdfb1d61",
        "filename": "src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 16,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/tests_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -7,6 +7,23 @@\n #ifndef SECP256K1_MODULE_ECDH_TESTS_H\n #define SECP256K1_MODULE_ECDH_TESTS_H\n \n+int ecdh_hash_function_test_fail(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n+    (void)output;\n+    (void)x;\n+    (void)y;\n+    (void)data;\n+    return 0;\n+}\n+\n+int ecdh_hash_function_custom(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n+    (void)data;\n+    /* Save x and y as uncompressed public key */\n+    output[0] = 0x04;\n+    memcpy(output + 1, x, 32);\n+    memcpy(output + 33, y, 32);\n+    return 1;\n+}\n+\n void test_ecdh_api(void) {\n     /* Setup context that just counts errors */\n     secp256k1_context *tctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n@@ -21,15 +38,15 @@ void test_ecdh_api(void) {\n     CHECK(secp256k1_ec_pubkey_create(tctx, &point, s_one) == 1);\n \n     /* Check all NULLs are detected */\n-    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one, NULL, NULL) == 1);\n     CHECK(ecount == 0);\n-    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one) == 0);\n+    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one, NULL, NULL) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one) == 0);\n+    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one, NULL, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ecdh(tctx, res, &point, NULL) == 0);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, NULL, NULL, NULL) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one, NULL, NULL) == 1);\n     CHECK(ecount == 3);\n \n     /* Cleanup */\n@@ -44,29 +61,36 @@ void test_ecdh_generator_basepoint(void) {\n     s_one[31] = 1;\n     /* Check against pubkey creation when the basepoint is the generator */\n     for (i = 0; i < 100; ++i) {\n-        secp256k1_sha256_t sha;\n+        secp256k1_sha256 sha;\n         unsigned char s_b32[32];\n-        unsigned char output_ecdh[32];\n+        unsigned char output_ecdh[65];\n         unsigned char output_ser[32];\n-        unsigned char point_ser[33];\n+        unsigned char point_ser[65];\n         size_t point_ser_len = sizeof(point_ser);\n         secp256k1_scalar s;\n \n         random_scalar_order(&s);\n         secp256k1_scalar_get_b32(s_b32, &s);\n \n-        /* compute using ECDH function */\n         CHECK(secp256k1_ec_pubkey_create(ctx, &point[0], s_one) == 1);\n-        CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32) == 1);\n-        /* compute \"explicitly\" */\n         CHECK(secp256k1_ec_pubkey_create(ctx, &point[1], s_b32) == 1);\n+\n+        /* compute using ECDH function with custom hash function */\n+        CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32, ecdh_hash_function_custom, NULL) == 1);\n+        /* compute \"explicitly\" */\n+        CHECK(secp256k1_ec_pubkey_serialize(ctx, point_ser, &point_ser_len, &point[1], SECP256K1_EC_UNCOMPRESSED) == 1);\n+        /* compare */\n+        CHECK(memcmp(output_ecdh, point_ser, 65) == 0);\n+\n+        /* compute using ECDH function with default hash function */\n+        CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32, NULL, NULL) == 1);\n+        /* compute \"explicitly\" */\n         CHECK(secp256k1_ec_pubkey_serialize(ctx, point_ser, &point_ser_len, &point[1], SECP256K1_EC_COMPRESSED) == 1);\n-        CHECK(point_ser_len == sizeof(point_ser));\n         secp256k1_sha256_initialize(&sha);\n         secp256k1_sha256_write(&sha, point_ser, point_ser_len);\n         secp256k1_sha256_finalize(&sha, output_ser);\n         /* compare */\n-        CHECK(memcmp(output_ecdh, output_ser, sizeof(output_ser)) == 0);\n+        CHECK(memcmp(output_ecdh, output_ser, 32) == 0);\n     }\n }\n \n@@ -89,11 +113,14 @@ void test_bad_scalar(void) {\n     CHECK(secp256k1_ec_pubkey_create(ctx, &point, s_rand) == 1);\n \n     /* Try to multiply it by bad values */\n-    CHECK(secp256k1_ecdh(ctx, output, &point, s_zero) == 0);\n-    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow) == 0);\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_zero, NULL, NULL) == 0);\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow, NULL, NULL) == 0);\n     /* ...and a good one */\n     s_overflow[31] -= 1;\n-    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow) == 1);\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow, NULL, NULL) == 1);\n+\n+    /* Hash function failure results in ecdh failure */\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow, ecdh_hash_function_test_fail, NULL) == 0);\n }\n \n void run_ecdh_tests(void) {"
      },
      {
        "sha": "d378335d996f32449a1d782352f91d5c60cac3aa",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -376,7 +376,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     /* extract m6 */\n     \"movq %%r8, %q6\\n\"\n     : \"=g\"(m0), \"=g\"(m1), \"=g\"(m2), \"=g\"(m3), \"=g\"(m4), \"=g\"(m5), \"=g\"(m6)\n-    : \"S\"(l), \"n\"(SECP256K1_N_C_0), \"n\"(SECP256K1_N_C_1)\n+    : \"S\"(l), \"i\"(SECP256K1_N_C_0), \"i\"(SECP256K1_N_C_1)\n     : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"cc\");\n \n     /* Reduce 385 bits into 258. */\n@@ -455,7 +455,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     /* extract p4 */\n     \"movq %%r9, %q4\\n\"\n     : \"=&g\"(p0), \"=&g\"(p1), \"=&g\"(p2), \"=g\"(p3), \"=g\"(p4)\n-    : \"g\"(m0), \"g\"(m1), \"g\"(m2), \"g\"(m3), \"g\"(m4), \"g\"(m5), \"g\"(m6), \"n\"(SECP256K1_N_C_0), \"n\"(SECP256K1_N_C_1)\n+    : \"g\"(m0), \"g\"(m1), \"g\"(m2), \"g\"(m3), \"g\"(m4), \"g\"(m5), \"g\"(m6), \"i\"(SECP256K1_N_C_0), \"i\"(SECP256K1_N_C_1)\n     : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"cc\");\n \n     /* Reduce 258 bits into 256. */\n@@ -501,7 +501,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     /* Extract c */\n     \"movq %%r9, %q0\\n\"\n     : \"=g\"(c)\n-    : \"g\"(p0), \"g\"(p1), \"g\"(p2), \"g\"(p3), \"g\"(p4), \"D\"(r), \"n\"(SECP256K1_N_C_0), \"n\"(SECP256K1_N_C_1)\n+    : \"g\"(p0), \"g\"(p1), \"g\"(p2), \"g\"(p3), \"g\"(p4), \"D\"(r), \"i\"(SECP256K1_N_C_0), \"i\"(SECP256K1_N_C_1)\n     : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"cc\", \"memory\");\n #else\n     uint128_t c;"
      },
      {
        "sha": "fef377af0d94203efcbde83e854b1443b1cce8a4",
        "filename": "src/scratch.h",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -0,0 +1,39 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+\n+#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n+\n+/* The typedef is used internally; the struct name is used in the public API\n+ * (where it is exposed as a different typedef) */\n+typedef struct secp256k1_scratch_space_struct {\n+    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n+    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n+    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n+    size_t frame;\n+    size_t max_size;\n+    const secp256k1_callback* error_callback;\n+} secp256k1_scratch;\n+\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n+\n+static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+\n+/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n+static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+\n+/** Deallocates a stack frame */\n+static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+\n+/** Returns the maximum allocation the scratch space will allow */\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+\n+/** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n+static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+\n+#endif"
      },
      {
        "sha": "abed713b21d2a8cb6c5c218858309399742ca782",
        "filename": "src/scratch_impl.h",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -0,0 +1,86 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_IMPL_H_\n+#define _SECP256K1_SCRATCH_IMPL_H_\n+\n+#include \"scratch.h\"\n+\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes.\n+ * TODO: Determine this at configure time. */\n+#define ALIGNMENT 16\n+\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n+    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+    if (ret != NULL) {\n+        memset(ret, 0, sizeof(*ret));\n+        ret->max_size = max_size;\n+        ret->error_callback = error_callback;\n+    }\n+    return ret;\n+}\n+\n+static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+    if (scratch != NULL) {\n+        VERIFY_CHECK(scratch->frame == 0);\n+        free(scratch);\n+    }\n+}\n+\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n+    size_t i = 0;\n+    size_t allocated = 0;\n+    for (i = 0; i < scratch->frame; i++) {\n+        allocated += scratch->frame_size[i];\n+    }\n+    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+        return 0;\n+    }\n+    return scratch->max_size - allocated - objects * ALIGNMENT;\n+}\n+\n+static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n+    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n+\n+    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n+        n += objects * ALIGNMENT;\n+        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n+        if (scratch->data[scratch->frame] == NULL) {\n+            return 0;\n+        }\n+        scratch->frame_size[scratch->frame] = n;\n+        scratch->offset[scratch->frame] = 0;\n+        scratch->frame++;\n+        return 1;\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n+    VERIFY_CHECK(scratch->frame > 0);\n+    scratch->frame -= 1;\n+    free(scratch->data[scratch->frame]);\n+}\n+\n+static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+    void *ret;\n+    size_t frame = scratch->frame - 1;\n+    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n+    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+        return NULL;\n+    }\n+    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    memset(ret, 0, size);\n+    scratch->offset[frame] += size;\n+\n+    return ret;\n+}\n+\n+#endif"
      },
      {
        "sha": "15981f46e21af11072a67f94504da842bd7eebd5",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 38,
        "deletions": 13,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -17,6 +17,7 @@\n #include \"ecdsa_impl.h\"\n #include \"eckey_impl.h\"\n #include \"hash_impl.h\"\n+#include \"scratch_impl.h\"\n \n #define ARG_CHECK(cond) do { \\\n     if (EXPECT(!(cond), 0)) { \\\n@@ -55,6 +56,14 @@ struct secp256k1_context_struct {\n     secp256k1_callback error_callback;\n };\n \n+static const secp256k1_context secp256k1_context_no_precomp_ = {\n+    { 0 },\n+    { 0 },\n+    { default_illegal_callback_fn, 0 },\n+    { default_error_callback_fn, 0 }\n+};\n+const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n+\n secp256k1_context* secp256k1_context_create(unsigned int flags) {\n     secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n     ret->illegal_callback = default_illegal_callback;\n@@ -90,6 +99,7 @@ secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n }\n \n void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    CHECK(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n@@ -99,6 +109,7 @@ void secp256k1_context_destroy(secp256k1_context* ctx) {\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n+    CHECK(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n         fun = default_illegal_callback_fn;\n     }\n@@ -107,20 +118,30 @@ void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n+    CHECK(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n         fun = default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n }\n \n+secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context* ctx, size_t max_size) {\n+    VERIFY_CHECK(ctx != NULL);\n+    return secp256k1_scratch_create(&ctx->error_callback, max_size);\n+}\n+\n+void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n+    secp256k1_scratch_destroy(scratch);\n+}\n+\n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n     if (sizeof(secp256k1_ge_storage) == 64) {\n         /* When the secp256k1_ge_storage type is exactly 64 byte, use its\n          * representation inside secp256k1_pubkey, as conversion is very fast.\n          * Note that secp256k1_pubkey_save must use the same representation. */\n         secp256k1_ge_storage s;\n-        memcpy(&s, &pubkey->data[0], 64);\n+        memcpy(&s, &pubkey->data[0], sizeof(s));\n         secp256k1_ge_from_storage(ge, &s);\n     } else {\n         /* Otherwise, fall back to 32-byte big endian for X and Y. */\n@@ -137,7 +158,7 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n     if (sizeof(secp256k1_ge_storage) == 64) {\n         secp256k1_ge_storage s;\n         secp256k1_ge_to_storage(&s, ge);\n-        memcpy(&pubkey->data[0], &s, 64);\n+        memcpy(&pubkey->data[0], &s, sizeof(s));\n     } else {\n         VERIFY_CHECK(!secp256k1_ge_is_infinity(ge));\n         secp256k1_fe_normalize_var(&ge->x);\n@@ -307,10 +328,15 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n             secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &r, &s, &q, &m));\n }\n \n+static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len) {\n+    memcpy(buf + *offset, data, len);\n+    *offset += len;\n+}\n+\n static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n    unsigned char keydata[112];\n-   int keylen = 64;\n-   secp256k1_rfc6979_hmac_sha256_t rng;\n+   unsigned int offset = 0;\n+   secp256k1_rfc6979_hmac_sha256 rng;\n    unsigned int i;\n    /* We feed a byte array to the PRNG as input, consisting of:\n     * - the private key (32 bytes) and message (32 bytes), see RFC 6979 3.2d.\n@@ -320,17 +346,15 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n     *  different argument mixtures to emulate each other and result in the same\n     *  nonces.\n     */\n-   memcpy(keydata, key32, 32);\n-   memcpy(keydata + 32, msg32, 32);\n+   buffer_append(keydata, &offset, key32, 32);\n+   buffer_append(keydata, &offset, msg32, 32);\n    if (data != NULL) {\n-       memcpy(keydata + 64, data, 32);\n-       keylen = 96;\n+       buffer_append(keydata, &offset, data, 32);\n    }\n    if (algo16 != NULL) {\n-       memcpy(keydata + keylen, algo16, 16);\n-       keylen += 16;\n+       buffer_append(keydata, &offset, algo16, 16);\n    }\n-   secp256k1_rfc6979_hmac_sha256_initialize(&rng, keydata, keylen);\n+   secp256k1_rfc6979_hmac_sha256_initialize(&rng, keydata, offset);\n    memset(keydata, 0, sizeof(keydata));\n    for (i = 0; i <= counter; i++) {\n        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n@@ -546,8 +570,9 @@ int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey\n \n int secp256k1_context_randomize(secp256k1_context* ctx, const unsigned char *seed32) {\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    }\n     return 1;\n }\n "
      },
      {
        "sha": "30a91e5296137c5458cfc12e2ed92f5fde51704e",
        "filename": "src/testrand_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand_impl.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -13,7 +13,7 @@\n #include \"testrand.h\"\n #include \"hash.h\"\n \n-static secp256k1_rfc6979_hmac_sha256_t secp256k1_test_rng;\n+static secp256k1_rfc6979_hmac_sha256 secp256k1_test_rng;\n static uint32_t secp256k1_test_rng_precomputed[8];\n static int secp256k1_test_rng_precomputed_used = 8;\n static uint64_t secp256k1_test_rng_integer;"
      },
      {
        "sha": "f1c4db929a776a182ad52ac4ada84100af6e701b",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 641,
        "deletions": 27,
        "changes": 668,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -23,6 +23,9 @@\n #include \"openssl/ec.h\"\n #include \"openssl/ecdsa.h\"\n #include \"openssl/obj_mac.h\"\n+# if OPENSSL_VERSION_NUMBER < 0x10100000L\n+void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {*pr = sig->r; *ps = sig->s;}\n+# endif\n #endif\n \n #include \"contrib/lax_der_parsing.c\"\n@@ -215,8 +218,12 @@ void run_context_tests(void) {\n     CHECK(ecount == 3);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(vrfy, NULL) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(sign, ctmp) == 1);\n+    CHECK(ecount2 == 14);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n     CHECK(ecount2 == 14);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n@@ -248,6 +255,44 @@ void run_context_tests(void) {\n     secp256k1_context_destroy(NULL);\n }\n \n+void run_scratch_tests(void) {\n+    int32_t ecount = 0;\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_scratch_space *scratch;\n+\n+    /* Test public API */\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+\n+    scratch = secp256k1_scratch_space_create(none, 1000);\n+    CHECK(scratch != NULL);\n+    CHECK(ecount == 0);\n+\n+    /* Test internal API */\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n+\n+    /* Allocating 500 bytes with no frame fails */\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n+\n+    /* ...but pushing a new stack frame does affect the max allocation */\n+    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+\n+    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+\n+    /* ...and this effect is undone by popping the frame */\n+    secp256k1_scratch_deallocate_frame(scratch);\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+\n+    /* cleanup */\n+    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_context_destroy(none);\n+}\n+\n /***** HASH TESTS *****/\n \n void run_sha256_tests(void) {\n@@ -270,7 +315,7 @@ void run_sha256_tests(void) {\n     int i;\n     for (i = 0; i < 8; i++) {\n         unsigned char out[32];\n-        secp256k1_sha256_t hasher;\n+        secp256k1_sha256 hasher;\n         secp256k1_sha256_initialize(&hasher);\n         secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n         secp256k1_sha256_finalize(&hasher, out);\n@@ -313,7 +358,7 @@ void run_hmac_sha256_tests(void) {\n     };\n     int i;\n     for (i = 0; i < 6; i++) {\n-        secp256k1_hmac_sha256_t hasher;\n+        secp256k1_hmac_sha256 hasher;\n         unsigned char out[32];\n         secp256k1_hmac_sha256_initialize(&hasher, (const unsigned char*)(keys[i]), strlen(keys[i]));\n         secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n@@ -345,7 +390,7 @@ void run_rfc6979_hmac_sha256_tests(void) {\n         {0x75, 0x97, 0x88, 0x7c, 0xbd, 0x76, 0x32, 0x1f, 0x32, 0xe3, 0x04, 0x40, 0x67, 0x9a, 0x22, 0xcf, 0x7f, 0x8d, 0x9d, 0x2e, 0xac, 0x39, 0x0e, 0x58, 0x1f, 0xea, 0x09, 0x1c, 0xe2, 0x02, 0xba, 0x94}\n     };\n \n-    secp256k1_rfc6979_hmac_sha256_t rng;\n+    secp256k1_rfc6979_hmac_sha256 rng;\n     unsigned char out[32];\n     int i;\n \n@@ -2054,28 +2099,40 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with and without known z ratios. */\n     {\n         secp256k1_fe *zr = (secp256k1_fe *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_fe));\n-        secp256k1_ge *ge_set_table = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         secp256k1_ge *ge_set_all = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             /* Compute gej[i + 1].z / gez[i].z (with gej[n].z taken to be 1). */\n             if (i < 4 * runs) {\n                 secp256k1_fe_mul(&zr[i + 1], &zinv[i], &gej[i + 1].z);\n             }\n         }\n-        secp256k1_ge_set_table_gej_var(ge_set_table, gej, zr, 4 * runs + 1);\n-        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1, &ctx->error_callback);\n+        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1);\n         for (i = 0; i < 4 * runs + 1; i++) {\n             secp256k1_fe s;\n             random_fe_non_zero(&s);\n             secp256k1_gej_rescale(&gej[i], &s);\n-            ge_equals_gej(&ge_set_table[i], &gej[i]);\n             ge_equals_gej(&ge_set_all[i], &gej[i]);\n         }\n-        free(ge_set_table);\n         free(ge_set_all);\n         free(zr);\n     }\n \n+    /* Test batch gej -> ge conversion with many infinities. */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        random_group_element_test(&ge[i]);\n+        /* randomly set half the points to infinitiy */\n+        if(secp256k1_fe_is_odd(&ge[i].x)) {\n+            secp256k1_ge_set_infinity(&ge[i]);\n+        }\n+        secp256k1_gej_set_ge(&gej[i], &ge[i]);\n+    }\n+    /* batch invert */\n+    secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n+    /* check result */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        ge_equals_gej(&ge[i], &gej[i]);\n+    }\n+\n     free(ge);\n     free(gej);\n     free(zinv);\n@@ -2405,7 +2462,7 @@ void ecmult_const_random_mult(void) {\n         0xb84e4e1b, 0xfb77e21f, 0x96baae2a, 0x63dec956\n     );\n     secp256k1_gej b;\n-    secp256k1_ecmult_const(&b, &a, &xn);\n+    secp256k1_ecmult_const(&b, &a, &xn, 256);\n \n     CHECK(secp256k1_ge_is_valid_var(&a));\n     ge_equals_gej(&expected_b, &b);\n@@ -2421,12 +2478,12 @@ void ecmult_const_commutativity(void) {\n     random_scalar_order_test(&a);\n     random_scalar_order_test(&b);\n \n-    secp256k1_ecmult_const(&res1, &secp256k1_ge_const_g, &a);\n-    secp256k1_ecmult_const(&res2, &secp256k1_ge_const_g, &b);\n+    secp256k1_ecmult_const(&res1, &secp256k1_ge_const_g, &a, 256);\n+    secp256k1_ecmult_const(&res2, &secp256k1_ge_const_g, &b, 256);\n     secp256k1_ge_set_gej(&mid1, &res1);\n     secp256k1_ge_set_gej(&mid2, &res2);\n-    secp256k1_ecmult_const(&res1, &mid1, &b);\n-    secp256k1_ecmult_const(&res2, &mid2, &a);\n+    secp256k1_ecmult_const(&res1, &mid1, &b, 256);\n+    secp256k1_ecmult_const(&res2, &mid2, &a, 256);\n     secp256k1_ge_set_gej(&mid1, &res1);\n     secp256k1_ge_set_gej(&mid2, &res2);\n     ge_equals_ge(&mid1, &mid2);\n@@ -2442,13 +2499,13 @@ void ecmult_const_mult_zero_one(void) {\n     secp256k1_scalar_negate(&negone, &one);\n \n     random_group_element_test(&point);\n-    secp256k1_ecmult_const(&res1, &point, &zero);\n+    secp256k1_ecmult_const(&res1, &point, &zero, 3);\n     secp256k1_ge_set_gej(&res2, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res2));\n-    secp256k1_ecmult_const(&res1, &point, &one);\n+    secp256k1_ecmult_const(&res1, &point, &one, 2);\n     secp256k1_ge_set_gej(&res2, &res1);\n     ge_equals_ge(&res2, &point);\n-    secp256k1_ecmult_const(&res1, &point, &negone);\n+    secp256k1_ecmult_const(&res1, &point, &negone, 256);\n     secp256k1_gej_neg(&res1, &res1);\n     secp256k1_ge_set_gej(&res2, &res1);\n     ge_equals_ge(&res2, &point);\n@@ -2474,7 +2531,7 @@ void ecmult_const_chain_multiply(void) {\n     for (i = 0; i < 100; ++i) {\n         secp256k1_ge tmp;\n         secp256k1_ge_set_gej(&tmp, &point);\n-        secp256k1_ecmult_const(&point, &tmp, &scalar);\n+        secp256k1_ecmult_const(&point, &tmp, &scalar, 256);\n     }\n     secp256k1_ge_set_gej(&res, &point);\n     ge_equals_gej(&res, &expected_point);\n@@ -2487,6 +2544,446 @@ void run_ecmult_const_tests(void) {\n     ecmult_const_chain_multiply();\n }\n \n+typedef struct {\n+    secp256k1_scalar *sc;\n+    secp256k1_ge *pt;\n+} ecmult_multi_data;\n+\n+static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    ecmult_multi_data *data = (ecmult_multi_data*) cbdata;\n+    *sc = data->sc[idx];\n+    *pt = data->pt[idx];\n+    return 1;\n+}\n+\n+static int ecmult_multi_false_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    (void)sc;\n+    (void)pt;\n+    (void)idx;\n+    (void)cbdata;\n+    return 0;\n+}\n+\n+void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func ecmult_multi) {\n+    int ncount;\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    secp256k1_gej r2;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* No points to multiply */\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+\n+    /* Check 1- and 2-point multiplies against ecmult */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+        random_scalar_order(&sc[0]);\n+        random_scalar_order(&sc[1]);\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+        pt[0] = ptg;\n+        pt[1] = secp256k1_ge_const_g;\n+\n+        /* only G scalar */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* 1-point */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* Try to multiply 1 point, but scratch space is empty */\n+        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_scratch_destroy(scratch_empty);\n+\n+        /* Try to multiply 1 point, but callback returns false */\n+        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+\n+        /* 2-point */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* 2-point with G scalar */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check infinite outputs of various forms */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        secp256k1_ge ptg;\n+        size_t i, j;\n+        size_t sizes[] = { 2, 10, 32 };\n+\n+        for (j = 0; j < 3; j++) {\n+            for (i = 0; i < 32; i++) {\n+                random_scalar_order(&sc[i]);\n+                secp256k1_ge_set_infinity(&pt[i]);\n+            }\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        for (j = 0; j < 3; j++) {\n+            for (i = 0; i < 32; i++) {\n+                random_group_element_test(&ptg);\n+                pt[i] = ptg;\n+                secp256k1_scalar_set_int(&sc[i], 0);\n+            }\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        for (j = 0; j < 3; j++) {\n+            random_group_element_test(&ptg);\n+            for (i = 0; i < 16; i++) {\n+                random_scalar_order(&sc[2*i]);\n+                secp256k1_scalar_negate(&sc[2*i + 1], &sc[2*i]);\n+                pt[2 * i] = ptg;\n+                pt[2 * i + 1] = ptg;\n+            }\n+\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+\n+            random_scalar_order(&sc[0]);\n+            for (i = 0; i < 16; i++) {\n+                random_group_element_test(&ptg);\n+\n+                sc[2*i] = sc[0];\n+                sc[2*i+1] = sc[0];\n+                pt[2 * i] = ptg;\n+                secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n+            }\n+\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_scalar_set_int(&sc[0], 0);\n+        pt[0] = ptg;\n+        for (i = 1; i < 32; i++) {\n+            pt[i] = ptg;\n+\n+            random_scalar_order(&sc[i]);\n+            secp256k1_scalar_add(&sc[0], &sc[0], &sc[i]);\n+            secp256k1_scalar_negate(&sc[i], &sc[i]);\n+        }\n+\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check random points, constant scalar */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        size_t i;\n+        secp256k1_gej_set_infinity(&r);\n+\n+        random_scalar_order(&sc[0]);\n+        for (i = 0; i < 20; i++) {\n+            secp256k1_ge ptg;\n+            sc[i] = sc[0];\n+            random_group_element_test(&ptg);\n+            pt[i] = ptg;\n+            secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n+        }\n+\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check random scalars, constant point */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        size_t i;\n+        secp256k1_ge ptg;\n+        secp256k1_gej p0j;\n+        secp256k1_scalar rs;\n+        secp256k1_scalar_set_int(&rs, 0);\n+\n+        random_group_element_test(&ptg);\n+        for (i = 0; i < 20; i++) {\n+            random_scalar_order(&sc[i]);\n+            pt[i] = ptg;\n+            secp256k1_scalar_add(&rs, &rs, &sc[i]);\n+        }\n+\n+        secp256k1_gej_set_ge(&p0j, &pt[0]);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Sanity check that zero scalars don't cause problems */\n+    for (ncount = 0; ncount < 20; ncount++) {\n+        random_scalar_order(&sc[ncount]);\n+        random_group_element_test(&pt[ncount]);\n+    }\n+\n+    secp256k1_scalar_clear(&sc[0]);\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    secp256k1_scalar_clear(&sc[1]);\n+    secp256k1_scalar_clear(&sc[2]);\n+    secp256k1_scalar_clear(&sc[3]);\n+    secp256k1_scalar_clear(&sc[4]);\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+\n+    /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n+    {\n+        const size_t TOP = 8;\n+        size_t s0i, s1i;\n+        size_t t0i, t1i;\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+\n+        for(t0i = 0; t0i < TOP; t0i++) {\n+            for(t1i = 0; t1i < TOP; t1i++) {\n+                secp256k1_gej t0p, t1p;\n+                secp256k1_scalar t0, t1;\n+\n+                secp256k1_scalar_set_int(&t0, (t0i + 1) / 2);\n+                secp256k1_scalar_cond_negate(&t0, t0i & 1);\n+                secp256k1_scalar_set_int(&t1, (t1i + 1) / 2);\n+                secp256k1_scalar_cond_negate(&t1, t1i & 1);\n+\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &t0p, &ptgj, &t0, &szero);\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &t1p, &ptgj, &t1, &szero);\n+\n+                for(s0i = 0; s0i < TOP; s0i++) {\n+                    for(s1i = 0; s1i < TOP; s1i++) {\n+                        secp256k1_scalar tmp1, tmp2;\n+                        secp256k1_gej expected, actual;\n+\n+                        secp256k1_ge_set_gej(&pt[0], &t0p);\n+                        secp256k1_ge_set_gej(&pt[1], &t1p);\n+\n+                        secp256k1_scalar_set_int(&sc[0], (s0i + 1) / 2);\n+                        secp256k1_scalar_cond_negate(&sc[0], s0i & 1);\n+                        secp256k1_scalar_set_int(&sc[1], (s1i + 1) / 2);\n+                        secp256k1_scalar_cond_negate(&sc[1], s1i & 1);\n+\n+                        secp256k1_scalar_mul(&tmp1, &t0, &sc[0]);\n+                        secp256k1_scalar_mul(&tmp2, &t1, &sc[1]);\n+                        secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n+\n+                        secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n+                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        secp256k1_gej_neg(&expected, &expected);\n+                        secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n+                        CHECK(secp256k1_gej_is_infinity(&actual));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_secp256k1_pippenger_bucket_window_inv(void) {\n+    int i;\n+\n+    CHECK(secp256k1_pippenger_bucket_window_inv(0) == 0);\n+    for(i = 1; i <= PIPPENGER_MAX_BUCKET_WINDOW; i++) {\n+#ifdef USE_ENDOMORPHISM\n+        /* Bucket_window of 8 is not used with endo */\n+        if (i == 8) {\n+            continue;\n+        }\n+#endif\n+        CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)) == i);\n+        if (i != PIPPENGER_MAX_BUCKET_WINDOW) {\n+            CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)+1) > i);\n+        }\n+    }\n+}\n+\n+/**\n+ * Probabilistically test the function returning the maximum number of possible points\n+ * for a given scratch space.\n+ */\n+void test_ecmult_multi_pippenger_max_points(void) {\n+    size_t scratch_size = secp256k1_rand_int(256);\n+    size_t max_size = secp256k1_pippenger_scratch_size(secp256k1_pippenger_bucket_window_inv(PIPPENGER_MAX_BUCKET_WINDOW-1)+512, 12);\n+    secp256k1_scratch *scratch;\n+    size_t n_points_supported;\n+    int bucket_window = 0;\n+\n+    for(; scratch_size < max_size; scratch_size+=256) {\n+        scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n+        CHECK(scratch != NULL);\n+        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        if (n_points_supported == 0) {\n+            secp256k1_scratch_destroy(scratch);\n+            continue;\n+        }\n+        bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n+        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n+        secp256k1_scratch_deallocate_frame(scratch);\n+        secp256k1_scratch_destroy(scratch);\n+    }\n+    CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n+}\n+\n+void test_ecmult_multi_batch_size_helper(void) {\n+    size_t n_batches, n_batch_points, max_n_batch_points, n;\n+\n+    max_n_batch_points = 0;\n+    n = 1;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 0);\n+\n+    max_n_batch_points = 1;\n+    n = 0;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 0);\n+    CHECK(n_batch_points == 0);\n+\n+    max_n_batch_points = 2;\n+    n = 5;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 3);\n+    CHECK(n_batch_points == 2);\n+\n+    max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    n = ECMULT_MAX_POINTS_PER_BATCH;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 1);\n+    CHECK(n_batch_points == ECMULT_MAX_POINTS_PER_BATCH);\n+\n+    max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH + 1;\n+    n = ECMULT_MAX_POINTS_PER_BATCH + 1;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 2);\n+    CHECK(n_batch_points == ECMULT_MAX_POINTS_PER_BATCH/2 + 1);\n+\n+    max_n_batch_points = 1;\n+    n = SIZE_MAX;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == SIZE_MAX);\n+    CHECK(n_batch_points == 1);\n+\n+    max_n_batch_points = 2;\n+    n = SIZE_MAX;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == SIZE_MAX/2 + 1);\n+    CHECK(n_batch_points == 2);\n+}\n+\n+/**\n+ * Run secp256k1_ecmult_multi_var with num points and a scratch space restricted to\n+ * 1 <= i <= num points.\n+ */\n+void test_ecmult_multi_batching(void) {\n+    static const int n_points = 2*ECMULT_PIPPENGER_THRESHOLD;\n+    secp256k1_scalar scG;\n+    secp256k1_scalar szero;\n+    secp256k1_scalar *sc = (secp256k1_scalar *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_scalar) * n_points);\n+    secp256k1_ge *pt = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * n_points);\n+    secp256k1_gej r;\n+    secp256k1_gej r2;\n+    ecmult_multi_data data;\n+    int i;\n+    secp256k1_scratch *scratch;\n+\n+    secp256k1_gej_set_infinity(&r2);\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Get random scalars and group elements and compute result */\n+    random_scalar_order(&scG);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r2, &szero, &scG);\n+    for(i = 0; i < n_points; i++) {\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+        pt[i] = ptg;\n+        random_scalar_order(&sc[i]);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &ptgj, &ptgj, &sc[i], NULL);\n+        secp256k1_gej_add_var(&r2, &r2, &ptgj, NULL);\n+    }\n+    data.sc = sc;\n+    data.pt = pt;\n+\n+    /* Test with empty scratch space */\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(scratch);\n+\n+    /* Test with space for 1 point in pippenger. That's not enough because\n+     * ecmult_multi selects strauss which requires more memory. */\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n+    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(scratch);\n+\n+    secp256k1_gej_neg(&r2, &r2);\n+    for(i = 1; i <= n_points; i++) {\n+        if (i > ECMULT_PIPPENGER_THRESHOLD) {\n+            int bucket_window = secp256k1_pippenger_bucket_window(i);\n+            size_t scratch_size = secp256k1_pippenger_scratch_size(i, bucket_window);\n+            scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n+        } else {\n+            size_t scratch_size = secp256k1_strauss_scratch_size(i);\n+            scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n+        }\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+        secp256k1_scratch_destroy(scratch);\n+    }\n+    free(sc);\n+    free(pt);\n+}\n+\n+void run_ecmult_multi_tests(void) {\n+    secp256k1_scratch *scratch;\n+\n+    test_secp256k1_pippenger_bucket_window_inv();\n+    test_ecmult_multi_pippenger_max_points();\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, 819200);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n+    test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(scratch);\n+\n+    /* Run test_ecmult_multi with space for exactly one point */\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n+    secp256k1_scratch_destroy(scratch);\n+\n+    test_ecmult_multi_batch_size_helper();\n+    test_ecmult_multi_batching();\n+}\n+\n void test_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, two, t;\n     int wnaf[256];\n@@ -2541,6 +3038,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     int wnaf[256] = {0};\n     int i;\n     int skew;\n+    int bits = 256;\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2550,10 +3048,11 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n+    bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n+    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n \n-    for (i = WNAF_SIZE(w); i >= 0; --i) {\n+    for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n         int v = wnaf[i];\n         CHECK(v != 0); /* check nonzero */\n@@ -2575,6 +3074,110 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n+void test_fixed_wnaf(const secp256k1_scalar *number, int w) {\n+    secp256k1_scalar x, shift;\n+    int wnaf[256] = {0};\n+    int i;\n+    int skew;\n+    secp256k1_scalar num = *number;\n+\n+    secp256k1_scalar_set_int(&x, 0);\n+    secp256k1_scalar_set_int(&shift, 1 << w);\n+    /* With USE_ENDOMORPHISM on we only consider 128-bit numbers */\n+#ifdef USE_ENDOMORPHISM\n+    for (i = 0; i < 16; ++i) {\n+        secp256k1_scalar_shr_int(&num, 8);\n+    }\n+#endif\n+    skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+\n+    for (i = WNAF_SIZE(w)-1; i >= 0; --i) {\n+        secp256k1_scalar t;\n+        int v = wnaf[i];\n+        CHECK(v == 0 || v & 1);  /* check parity */\n+        CHECK(v > -(1 << w)); /* check range above */\n+        CHECK(v < (1 << w));  /* check range below */\n+\n+        secp256k1_scalar_mul(&x, &x, &shift);\n+        if (v >= 0) {\n+            secp256k1_scalar_set_int(&t, v);\n+        } else {\n+            secp256k1_scalar_set_int(&t, -v);\n+            secp256k1_scalar_negate(&t, &t);\n+        }\n+        secp256k1_scalar_add(&x, &x, &t);\n+    }\n+    /* If skew is 1 then add 1 to num */\n+    secp256k1_scalar_cadd_bit(&num, 0, skew == 1);\n+    CHECK(secp256k1_scalar_eq(&x, &num));\n+}\n+\n+/* Checks that the first 8 elements of wnaf are equal to wnaf_expected and the\n+ * rest is 0.*/\n+void test_fixed_wnaf_small_helper(int *wnaf, int *wnaf_expected, int w) {\n+    int i;\n+    for (i = WNAF_SIZE(w)-1; i >= 8; --i) {\n+        CHECK(wnaf[i] == 0);\n+    }\n+    for (i = 7; i >= 0; --i) {\n+        CHECK(wnaf[i] == wnaf_expected[i]);\n+    }\n+}\n+\n+void test_fixed_wnaf_small(void) {\n+    int w = 4;\n+    int wnaf[256] = {0};\n+    int i;\n+    int skew;\n+    secp256k1_scalar num;\n+\n+    secp256k1_scalar_set_int(&num, 0);\n+    skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+    for (i = WNAF_SIZE(w)-1; i >= 0; --i) {\n+        int v = wnaf[i];\n+        CHECK(v == 0);\n+    }\n+    CHECK(skew == 0);\n+\n+    secp256k1_scalar_set_int(&num, 1);\n+    skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+    for (i = WNAF_SIZE(w)-1; i >= 1; --i) {\n+        int v = wnaf[i];\n+        CHECK(v == 0);\n+    }\n+    CHECK(wnaf[0] == 1);\n+    CHECK(skew == 0);\n+\n+    {\n+        int wnaf_expected[8] = { 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf };\n+        secp256k1_scalar_set_int(&num, 0xffffffff);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 0);\n+    }\n+    {\n+        int wnaf_expected[8] = { -1, -1, -1, -1, -1, -1, -1, 0xf };\n+        secp256k1_scalar_set_int(&num, 0xeeeeeeee);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 1);\n+    }\n+    {\n+        int wnaf_expected[8] = { 1, 0, 1, 0, 1, 0, 1, 0 };\n+        secp256k1_scalar_set_int(&num, 0x01010101);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 0);\n+    }\n+    {\n+        int wnaf_expected[8] = { -0xf, 0, 0xf, -0xf, 0, 0xf, 1, 0 };\n+        secp256k1_scalar_set_int(&num, 0x01ef1ef1);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 0);\n+    }\n+}\n+\n void run_wnaf(void) {\n     int i;\n     secp256k1_scalar n = {{0}};\n@@ -2585,12 +3188,15 @@ void run_wnaf(void) {\n     test_constant_wnaf(&n, 4);\n     n.d[0] = 2;\n     test_constant_wnaf(&n, 4);\n+    /* Test 0 */\n+    test_fixed_wnaf_small();\n     /* Random tests */\n     for (i = 0; i < count; i++) {\n         random_scalar_order(&n);\n         test_wnaf(&n, 4+(i%10));\n         test_constant_wnaf_negate(&n);\n         test_constant_wnaf(&n, 4 + (i % 10));\n+        test_fixed_wnaf(&n, 4 + (i % 10));\n     }\n     secp256k1_scalar_set_int(&n, 0);\n     CHECK(secp256k1_scalar_cond_negate(&n, 1) == -1);\n@@ -3055,6 +3661,7 @@ void run_ec_pubkey_parse_test(void) {\n     ecount = 0;\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, 65) == 1);\n+    CHECK(secp256k1_ec_pubkey_parse(secp256k1_context_no_precomp, &pubkey, pubkeyc, 65) == 1);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n     CHECK(ecount == 0);\n     VG_UNDEF(&ge, sizeof(ge));\n@@ -3177,7 +3784,7 @@ void run_eckey_edge_case_test(void) {\n     VG_CHECK(&pubkey, sizeof(pubkey));\n     CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     pubkey_negone = pubkey;\n-    /* Tweak of zero leaves the value changed. */\n+    /* Tweak of zero leaves the value unchanged. */\n     memset(ctmp2, 0, 32);\n     CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, ctmp2) == 1);\n     CHECK(memcmp(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n@@ -3668,6 +4275,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n \n #ifdef ENABLE_OPENSSL_TESTS\n     ECDSA_SIG *sig_openssl;\n+    const BIGNUM *r = NULL, *s = NULL;\n     const unsigned char *sigptr;\n     unsigned char roundtrip_openssl[2048];\n     int len_openssl = 2048;\n@@ -3719,15 +4327,16 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     sigptr = sig;\n     parsed_openssl = (d2i_ECDSA_SIG(&sig_openssl, &sigptr, siglen) != NULL);\n     if (parsed_openssl) {\n-        valid_openssl = !BN_is_negative(sig_openssl->r) && !BN_is_negative(sig_openssl->s) && BN_num_bits(sig_openssl->r) > 0 && BN_num_bits(sig_openssl->r) <= 256 && BN_num_bits(sig_openssl->s) > 0 && BN_num_bits(sig_openssl->s) <= 256;\n+        ECDSA_SIG_get0(sig_openssl, &r, &s);\n+        valid_openssl = !BN_is_negative(r) && !BN_is_negative(s) && BN_num_bits(r) > 0 && BN_num_bits(r) <= 256 && BN_num_bits(s) > 0 && BN_num_bits(s) <= 256;\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n-            BN_bn2bin(sig_openssl->r, tmp + 32 - BN_num_bytes(sig_openssl->r));\n+            BN_bn2bin(r, tmp + 32 - BN_num_bytes(r));\n             valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n         }\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n-            BN_bn2bin(sig_openssl->s, tmp + 32 - BN_num_bytes(sig_openssl->s));\n+            BN_bn2bin(s, tmp + 32 - BN_num_bytes(s));\n             valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n         }\n     }\n@@ -4431,8 +5040,9 @@ int main(int argc, char **argv) {\n         }\n     } else {\n         FILE *frand = fopen(\"/dev/urandom\", \"r\");\n-        if ((frand == NULL) || !fread(&seed16, sizeof(seed16), 1, frand)) {\n+        if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n             uint64_t t = time(NULL) * (uint64_t)1337;\n+            fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");\n             seed16[0] ^= t;\n             seed16[1] ^= t >> 8;\n             seed16[2] ^= t >> 16;\n@@ -4442,7 +5052,9 @@ int main(int argc, char **argv) {\n             seed16[6] ^= t >> 48;\n             seed16[7] ^= t >> 56;\n         }\n-        fclose(frand);\n+        if (frand) {\n+            fclose(frand);\n+        }\n     }\n     secp256k1_rand_seed(seed16);\n \n@@ -4451,6 +5063,7 @@ int main(int argc, char **argv) {\n \n     /* initialize */\n     run_context_tests();\n+    run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {\n         secp256k1_rand256(run32);\n@@ -4492,6 +5105,7 @@ int main(int argc, char **argv) {\n     run_ecmult_constants();\n     run_ecmult_gen_blind();\n     run_ecmult_const_tests();\n+    run_ecmult_multi_tests();\n     run_ec_combine();\n \n     /* endomorphism tests */"
      },
      {
        "sha": "ab9779b02fc544b52ea82ce58778405574dd26b6",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 42,
        "deletions": 1,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -174,14 +174,54 @@ void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *gr\n                 ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n \n                 if (i > 0) {\n-                    secp256k1_ecmult_const(&tmp, &group[i], &ng);\n+                    secp256k1_ecmult_const(&tmp, &group[i], &ng, 256);\n                     ge_equals_gej(&group[(i * j) % order], &tmp);\n                 }\n             }\n         }\n     }\n }\n \n+typedef struct {\n+    secp256k1_scalar sc[2];\n+    secp256k1_ge pt[2];\n+} ecmult_multi_data;\n+\n+static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    ecmult_multi_data *data = (ecmult_multi_data*) cbdata;\n+    *sc = data->sc[idx];\n+    *pt = data->pt[idx];\n+    return 1;\n+}\n+\n+void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k, x, y;\n+    secp256k1_scratch *scratch = secp256k1_scratch_create(&ctx->error_callback, 4096);\n+    for (i = 0; i < order; i++) {\n+        for (j = 0; j < order; j++) {\n+            for (k = 0; k < order; k++) {\n+                for (x = 0; x < order; x++) {\n+                    for (y = 0; y < order; y++) {\n+                        secp256k1_gej tmp;\n+                        secp256k1_scalar g_sc;\n+                        ecmult_multi_data data;\n+\n+                        secp256k1_scalar_set_int(&data.sc[0], i);\n+                        secp256k1_scalar_set_int(&data.sc[1], j);\n+                        secp256k1_scalar_set_int(&g_sc, k);\n+                        data.pt[0] = group[x];\n+                        data.pt[1] = group[y];\n+\n+                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    secp256k1_scratch_destroy(scratch);\n+}\n+\n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n     secp256k1_fe x;\n     unsigned char x_bin[32];\n@@ -456,6 +496,7 @@ int main(void) {\n #endif\n     test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_ecmult_multi(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n "
      },
      {
        "sha": "e1f5b764527d9a70febb0f2a6f94c5dfc6f3d7a2",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -36,7 +36,7 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n } while(0)\n #endif\n \n-#ifdef HAVE_BUILTIN_EXPECT\n+#if SECP256K1_GNUC_PREREQ(3, 0)\n #define EXPECT(x,c) __builtin_expect((x),(c))\n #else\n #define EXPECT(x,c) (x)\n@@ -76,6 +76,14 @@ static SECP256K1_INLINE void *checked_malloc(const secp256k1_callback* cb, size_\n     return ret;\n }\n \n+static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void *ptr, size_t size) {\n+    void *ret = realloc(ptr, size);\n+    if (ret == NULL) {\n+        secp256k1_callback_call(cb, \"Out of memory\");\n+    }\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT"
      }
    ]
  },
  {
    "sha": "99df276dae91de034f67d4bfc215b8101f5dac7b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OWRmMjc2ZGFlOTFkZTAzNGY2N2Q0YmZjMjE1YjgxMDFmNWRhYzdi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-03-31T18:41:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-03-31T18:41:05Z"
      },
      "message": "Update the secp256k1 subtree to the latest upstream version",
      "tree": {
        "sha": "d80cc52dac2304e3ad60eea5a6aabe4b67e02b1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d80cc52dac2304e3ad60eea5a6aabe4b67e02b1b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99df276dae91de034f67d4bfc215b8101f5dac7b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99df276dae91de034f67d4bfc215b8101f5dac7b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99df276dae91de034f67d4bfc215b8101f5dac7b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99df276dae91de034f67d4bfc215b8101f5dac7b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "79c345a0114c9a83fd40e01150519373c017b130",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79c345a0114c9a83fd40e01150519373c017b130",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/79c345a0114c9a83fd40e01150519373c017b130"
      },
      {
        "sha": "54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54245985fb3c89d72e285c4db39d38ed2f5fb0de"
      }
    ],
    "stats": {
      "total": 2831,
      "additions": 2415,
      "deletions": 416
    },
    "files": [
      {
        "sha": "55d325aeefa9c084a06e78808ddde841d702538c",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -1,5 +1,6 @@\n bench_inv\n bench_ecdh\n+bench_ecmult\n bench_sign\n bench_verify\n bench_schnorr_verify"
      },
      {
        "sha": "74f658f4d1c6d47c67618e4305cd0d0c21b92078",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -1,5 +1,5 @@\n language: c\n-sudo: false\n+os: linux\n addons:\n   apt:\n     packages: libgmp-dev\n@@ -11,7 +11,7 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n@@ -29,7 +29,7 @@ env:\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n-    - BUILD=check-java ECDH=yes EXPERIMENTAL=yes\n+    - BUILD=check-java JNI=yes ECDH=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -65,5 +65,4 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n-os: linux\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD"
      },
      {
        "sha": "9e5b7dcce0ab975ec61d55b6bc003c9587904bc0",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -42,6 +42,8 @@ noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n+noinst_HEADERS += src/scratch.h\n+noinst_HEADERS += src/scratch_impl.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n noinst_HEADERS += src/hash.h\n@@ -79,14 +81,17 @@ libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n-noinst_PROGRAMS += bench_verify bench_sign bench_internal\n+noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_ecmult_SOURCES = src/bench_ecmult.c\n+bench_ecmult_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_ecmult_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n TESTS =\n@@ -109,7 +114,7 @@ exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDE\n if !ENABLE_COVERAGE\n exhaustive_tests_CPPFLAGS += -DVERIFY\n endif\n-exhaustive_tests_LDADD = $(SECP_LIBS)\n+exhaustive_tests_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n@@ -146,19 +151,19 @@ endif\n \n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n-CFLAGS_FOR_BUILD += -Wall -Wextra -Wno-unused-function\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n gen_%.o: src/gen_%.c\n \t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n-\t$(CC_FOR_BUILD) $^ -o $@\n+\t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n \n $(libsecp256k1_la_OBJECTS): src/ecmult_static_context.h\n $(tests_OBJECTS): src/ecmult_static_context.h\n $(bench_internal_OBJECTS): src/ecmult_static_context.h\n+$(bench_ecmult_OBJECTS): src/ecmult_static_context.h\n \n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)"
      },
      {
        "sha": "cdc78d87d48b09d45830e47a70f59219c3fee2ce",
        "filename": "src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -1,5 +1,5 @@\n # ===========================================================================\n-#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+#    https://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n # ===========================================================================\n #\n # SYNOPSIS\n@@ -44,7 +44,7 @@\n #   and this notice are preserved. This file is offered as-is, without any\n #   warranty.\n \n-#serial 10\n+#serial 14\n \n AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n@@ -66,40 +66,45 @@ else\n fi\n \n case \"$host_os\" in\n-        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n-                        _JINC=\"$_JTOPDIR/Headers\";;\n-        *)              _JINC=\"$_JTOPDIR/include\";;\n+        darwin*)        # Apple Java headers are inside the Xcode bundle.\n+            macos_version=$(sw_vers -productVersion | sed -n -e 's/^@<:@0-9@:>@*.\\(@<:@0-9@:>@*\\).@<:@0-9@:>@*/\\1/p')\n+            if @<:@ \"$macos_version\" -gt \"7\" @:>@; then\n+                _JTOPDIR=\"$(xcrun --show-sdk-path)/System/Library/Frameworks/JavaVM.framework\"\n+                _JINC=\"$_JTOPDIR/Headers\"\n+            else\n+                _JTOPDIR=\"/System/Library/Frameworks/JavaVM.framework\"\n+                _JINC=\"$_JTOPDIR/Headers\"\n+            fi\n+            ;;\n+        *) _JINC=\"$_JTOPDIR/include\";;\n esac\n _AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n _AS_ECHO_LOG([_JINC=$_JINC])\n \n # On Mac OS X 10.6.4, jni.h is a symlink:\n # /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n # -> ../../CurrentJDK/Headers/jni.h.\n-\n AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n [\n-if test -f \"$_JINC/jni.h\"; then\n-  ac_cv_jni_header_path=\"$_JINC\"\n-  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n-else\n-  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n-  if test -f \"$_JTOPDIR/include/jni.h\"; then\n-    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+  if test -f \"$_JINC/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JINC\"\n     JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n   else\n-    ac_cv_jni_header_path=none\n+    _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+    if test -f \"$_JTOPDIR/include/jni.h\"; then\n+      ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+      JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+    else\n+      ac_cv_jni_header_path=none\n+    fi\n   fi\n-fi\n ])\n \n-\n-\n # get the likely subdirectories for system specific java includes\n case \"$host_os\" in\n bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n-darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n@@ -112,9 +117,9 @@ if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n   # add any subdirectories that are present\n   for JINCSUBDIR in $_JNI_INC_SUBDIRS\n   do\n-      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n-           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n-      fi\n+    if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+         JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+    fi\n   done\n fi\n ])"
      },
      {
        "sha": "3b3975cbdda81d9a96f7bece460c3d126ecc97b1",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -48,7 +48,6 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     EC_KEY_free(eckey);\n     ECDSA_SIG *sig_openssl;\n     sig_openssl = ECDSA_SIG_new();\n-    (void)sig_openssl->r;\n     ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])"
      },
      {
        "sha": "3b7a328c8af0acd9162152dccdb3ceb37f86358e",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 60,
        "deletions": 29,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -85,9 +85,9 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is no)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n     [use_benchmark=$enableval],\n-    [use_benchmark=no])\n+    [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n     AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n@@ -135,9 +135,9 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=no])\n \n AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n     [use_jni=$enableval],\n-    [use_jni=auto])\n+    [use_jni=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n@@ -153,12 +153,6 @@ AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n \n AC_CHECK_TYPES([__int128])\n \n-AC_MSG_CHECKING([for __builtin_expect])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n-    [ AC_MSG_RESULT([yes]);AC_DEFINE(HAVE_BUILTIN_EXPECT,1,[Define this symbol if __builtin_expect is available]) ],\n-    [ AC_MSG_RESULT([no])\n-    ])\n-\n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n     CFLAGS=\"$CFLAGS -O0 --coverage\"\n@@ -168,27 +162,54 @@ else\n fi\n \n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  # Temporarily switch to an environment for the native compiler\n   save_cross_compiling=$cross_compiling\n   cross_compiling=no\n-  TEMP_CC=\"$CC\"\n+  SAVE_CC=\"$CC\"\n   CC=\"$CC_FOR_BUILD\"\n-  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  SAVE_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS_FOR_BUILD\"\n+  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n+  CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+  SAVE_LDFLAGS=\"$LDFLAGS\"\n+  LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n+\n+  warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n+  saved_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS $warn_CFLAGS_FOR_BUILD\"\n+  AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n+      [ AC_MSG_RESULT([yes]) ],\n+      [ AC_MSG_RESULT([no])\n+        CFLAGS=\"$saved_CFLAGS\"\n+      ])\n+\n+  AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n   AC_RUN_IFELSE(\n-    [AC_LANG_PROGRAM([], [return 0])],\n+    [AC_LANG_PROGRAM([], [])],\n     [working_native_cc=yes],\n     [working_native_cc=no],[dnl])\n-  CC=\"$TEMP_CC\"\n+\n+  CFLAGS_FOR_BUILD=\"$CFLAGS\"\n+\n+  # Restore the environment\n   cross_compiling=$save_cross_compiling\n+  CC=\"$SAVE_CC\"\n+  CFLAGS=\"$SAVE_CFLAGS\"\n+  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+  LDFLAGS=\"$SAVE_LDFLAGS\"\n \n   if test x\"$working_native_cc\" = x\"no\"; then\n+    AC_MSG_RESULT([no])\n     set_precomp=no\n+    m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n     if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n-      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+      AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n     else\n-      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+      AC_MSG_WARN([Disabling statically generated ecmult table because the native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n     fi\n   else\n-    AC_MSG_RESULT([ok])\n+    AC_MSG_RESULT([yes])\n     set_precomp=yes\n   fi\n else\n@@ -441,17 +462,6 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n-AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n-AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n-AC_MSG_NOTICE([Using field implementation: $set_field])\n-AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n-AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n-AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n-AC_MSG_NOTICE([Building for coverage analysis: $enable_coverage])\n-AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n-AC_MSG_NOTICE([Using jni: $use_jni])\n-\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -481,7 +491,7 @@ AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n-AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -491,3 +501,24 @@ unset PKG_CONFIG_PATH\n PKG_CONFIG_PATH=\"$PKGCONFIG_PATH_TEMP\"\n \n AC_OUTPUT\n+\n+echo\n+echo \"Build Options:\"\n+echo \"  with endomorphism   = $use_endomorphism\"\n+echo \"  with ecmult precomp = $set_precomp\"\n+echo \"  with jni            = $use_jni\"\n+echo \"  with benchmarks     = $use_benchmark\"\n+echo \"  with coverage       = $enable_coverage\"\n+echo \"  module ecdh         = $enable_module_ecdh\"\n+echo \"  module recovery     = $enable_module_recovery\"\n+echo\n+echo \"  asm                 = $set_asm\"\n+echo \"  bignum              = $set_bignum\"\n+echo \"  field               = $set_field\"\n+echo \"  scalar              = $set_scalar\"\n+echo\n+echo \"  CC                  = $CC\"\n+echo \"  CFLAGS              = $CFLAGS\"\n+echo \"  CPPFLAGS            = $CPPFLAGS\"\n+echo \"  LDFLAGS             = $LDFLAGS\"\n+echo"
      },
      {
        "sha": "43af09c330de4e8a21552e821ee946d6f198738d",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 47,
        "deletions": 2,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -42,6 +42,19 @@ extern \"C\" {\n  */\n typedef struct secp256k1_context_struct secp256k1_context;\n \n+/** Opaque data structure that holds rewriteable \"scratch space\"\n+ *\n+ *  The purpose of this structure is to replace dynamic memory allocations,\n+ *  because we target architectures where this may not be available. It is\n+ *  essentially a resizable (within specified parameters) block of bytes,\n+ *  which is initially created either by memory allocation or TODO as a pointer\n+ *  into some fixed rewritable space.\n+ *\n+ *  Unlike the context object, this cannot safely be shared between threads\n+ *  without additional synchronization logic.\n+ */\n+typedef struct secp256k1_scratch_space_struct secp256k1_scratch_space;\n+\n /** Opaque data structure that holds a parsed and valid public key.\n  *\n  *  The exact representation of data inside is implementation defined and not\n@@ -166,6 +179,13 @@ typedef int (*secp256k1_nonce_function)(\n #define SECP256K1_TAG_PUBKEY_HYBRID_EVEN 0x06\n #define SECP256K1_TAG_PUBKEY_HYBRID_ODD 0x07\n \n+/** A simple secp256k1 context object with no precomputed tables. These are useful for\n+ *  type serialization/parsing functions which require a context object to maintain\n+ *  API consistency, but currently do not require expensive precomputations or dynamic\n+ *  allocations.\n+ */\n+SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n+\n /** Create a secp256k1 context object.\n  *\n  *  Returns: a newly created context object.\n@@ -243,6 +263,26 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n     const void* data\n ) SECP256K1_ARG_NONNULL(1);\n \n+/** Create a secp256k1 scratch space object.\n+ *\n+ *  Returns: a newly created scratch space.\n+ *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  In:   max_size: maximum amount of memory to allocate\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n+    const secp256k1_context* ctx,\n+    size_t max_size\n+) SECP256K1_ARG_NONNULL(1);\n+\n+/** Destroy a secp256k1 scratch space.\n+ *\n+ *  The pointer may not be used afterwards.\n+ *  Args:   scratch: space to destroy\n+ */\n+SECP256K1_API void secp256k1_scratch_space_destroy(\n+    secp256k1_scratch_space* scratch\n+);\n+\n /** Parse a variable-length public key into the pubkey object.\n  *\n  *  Returns: 1 if the public key was fully valid.\n@@ -498,7 +538,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n  *\n  *  Returns: 1 always\n  *  Args:   ctx:        pointer to a context object\n- *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ *  In/Out: seckey:     pointer to the 32-byte private key to be negated (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n     const secp256k1_context* ctx,\n@@ -575,7 +615,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Updates the context randomization to protect against side-channel leakage.\n- *  Returns: 1: randomization successfully updated\n+ *  Returns: 1: randomization successfully updated or nothing to randomize\n  *           0: error\n  *  Args:    ctx:       pointer to a context object (cannot be NULL)\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n@@ -590,6 +630,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * that it does not affect function results, but shields against attacks which\n  * rely on any input-dependent behaviour.\n  *\n+ * This function has currently an effect only on contexts initialized for signing\n+ * because randomization is currently used only for signing. However, this is not\n+ * guaranteed and may change in the future. It is safe to call this function on\n+ * contexts not initialized for signing; then it will have no effect and return 1.\n+ *\n  * You should call this after secp256k1_context_create or\n  * secp256k1_context_clone, and may call this repeatedly afterwards.\n  */"
      },
      {
        "sha": "df5fde235c7b97d802d6abc071d2b54b2497c2b0",
        "filename": "src/secp256k1/include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 28,
        "deletions": 4,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_ecdh.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -7,21 +7,45 @@\n extern \"C\" {\n #endif\n \n+/** A pointer to a function that applies hash function to a point\n+ *\n+ *  Returns: 1 if a point was successfully hashed. 0 will cause ecdh to fail\n+ *  Out:    output:     pointer to an array to be filled by the function\n+ *  In:     x:          pointer to a 32-byte x coordinate\n+ *          y:          pointer to a 32-byte y coordinate\n+ *          data:       Arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ecdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x,\n+  const unsigned char *y,\n+  void *data\n+);\n+\n+/** An implementation of SHA256 hash function that applies to compressed public key. */\n+SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256;\n+\n+/** A default ecdh hash function (currently equal to secp256k1_ecdh_hash_function_sha256). */\n+SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default;\n+\n /** Compute an EC Diffie-Hellman secret in constant time\n  *  Returns: 1: exponentiation was successful\n  *           0: scalar was invalid (zero or overflow)\n  *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     result:     a 32-byte array which will be populated by an ECDH\n- *                       secret computed from the point and scalar\n+ *  Out:     output:     pointer to an array to be filled by the function\n  *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n  *                       initialized public key\n  *           privkey:    a 32-byte scalar with which to multiply the point\n+ *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n+ *           data:       Arbitrary data pointer that is passed through\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,\n-  unsigned char *result,\n+  unsigned char *output,\n   const secp256k1_pubkey *pubkey,\n-  const unsigned char *privkey\n+  const unsigned char *privkey,\n+  secp256k1_ecdh_hash_function hashfp,\n+  void *data\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n #ifdef __cplusplus"
      },
      {
        "sha": "694e98eef51ea7fe45317aa7f2ffbc9152f0ebe3",
        "filename": "src/secp256k1/libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/libsecp256k1.pc.in?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -8,6 +8,6 @@ Description: Optimized C library for EC operations on curve secp256k1\n URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n-Libs.private: @SECP_LIBS@\n Libs: -L${libdir} -lsecp256k1\n+Libs.private: @SECP_LIBS@\n "
      },
      {
        "sha": "5b59783f68a950f61a74372325635ddc1b194326",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_BENCH_H\n \n #include <stdio.h>\n+#include <string.h>\n #include <math.h>\n #include \"sys/time.h\"\n \n@@ -63,4 +64,19 @@ void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), v\n     printf(\"us\\n\");\n }\n \n+int have_flag(int argc, char** argv, char *flag) {\n+    char** argm = argv + argc;\n+    argv++;\n+    if (argv == argm) {\n+        return 1;\n+    }\n+    while (argv != NULL && argv != argm) {\n+        if (strcmp(*argv, flag) == 0) {\n+            return 1;\n+        }\n+        argv++;\n+    }\n+    return 0;\n+}\n+\n #endif /* SECP256K1_BENCH_H */"
      },
      {
        "sha": "c1dd5a6ac93c8cbf0c4017673102e09a8ee3c392",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -15,11 +15,11 @@ typedef struct {\n     secp256k1_context *ctx;\n     secp256k1_pubkey point;\n     unsigned char scalar[32];\n-} bench_ecdh_t;\n+} bench_ecdh_data;\n \n static void bench_ecdh_setup(void* arg) {\n     int i;\n-    bench_ecdh_t *data = (bench_ecdh_t*)arg;\n+    bench_ecdh_data *data = (bench_ecdh_data*)arg;\n     const unsigned char point[] = {\n         0x03,\n         0x54, 0x94, 0xc1, 0x5d, 0x32, 0x09, 0x97, 0x06,\n@@ -39,15 +39,15 @@ static void bench_ecdh_setup(void* arg) {\n static void bench_ecdh(void* arg) {\n     int i;\n     unsigned char res[32];\n-    bench_ecdh_t *data = (bench_ecdh_t*)arg;\n+    bench_ecdh_data *data = (bench_ecdh_data*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        CHECK(secp256k1_ecdh(data->ctx, res, &data->point, data->scalar) == 1);\n+        CHECK(secp256k1_ecdh(data->ctx, res, &data->point, data->scalar, NULL, NULL) == 1);\n     }\n }\n \n int main(void) {\n-    bench_ecdh_t data;\n+    bench_ecdh_data data;\n \n     run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, 20000);\n     return 0;"
      },
      {
        "sha": "6d0ed1f4364e4eaa049db91f87f4725144054391",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "added",
        "additions": 207,
        "deletions": 0,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -0,0 +1,207 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+#include <stdio.h>\n+\n+#include \"include/secp256k1.h\"\n+\n+#include \"util.h\"\n+#include \"hash_impl.h\"\n+#include \"num_impl.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"scalar_impl.h\"\n+#include \"ecmult_impl.h\"\n+#include \"bench.h\"\n+#include \"secp256k1.c\"\n+\n+#define POINTS 32768\n+#define ITERS 10000\n+\n+typedef struct {\n+    /* Setup once in advance */\n+    secp256k1_context* ctx;\n+    secp256k1_scratch_space* scratch;\n+    secp256k1_scalar* scalars;\n+    secp256k1_ge* pubkeys;\n+    secp256k1_scalar* seckeys;\n+    secp256k1_gej* expected_output;\n+    secp256k1_ecmult_multi_func ecmult_multi;\n+\n+    /* Changes per test */\n+    size_t count;\n+    int includes_g;\n+\n+    /* Changes per test iteration */\n+    size_t offset1;\n+    size_t offset2;\n+\n+    /* Test output. */\n+    secp256k1_gej* output;\n+} bench_data;\n+\n+static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    if (data->includes_g) ++idx;\n+    if (idx == 0) {\n+        *sc = data->scalars[data->offset1];\n+        *ge = secp256k1_ge_const_g;\n+    } else {\n+        *sc = data->scalars[(data->offset1 + idx) % POINTS];\n+        *ge = data->pubkeys[(data->offset2 + idx - 1) % POINTS];\n+    }\n+    return 1;\n+}\n+\n+static void bench_ecmult(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+\n+    size_t count = data->count;\n+    int includes_g = data->includes_g;\n+    size_t iters = 1 + ITERS / count;\n+    size_t iter;\n+\n+    for (iter = 0; iter < iters; ++iter) {\n+        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->offset1 = (data->offset1 + count) % POINTS;\n+        data->offset2 = (data->offset2 + count - 1) % POINTS;\n+    }\n+}\n+\n+static void bench_ecmult_setup(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+}\n+\n+static void bench_ecmult_teardown(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    size_t iters = 1 + ITERS / data->count;\n+    size_t iter;\n+    /* Verify the results in teardown, to avoid doing comparisons while benchmarking. */\n+    for (iter = 0; iter < iters; ++iter) {\n+        secp256k1_gej tmp;\n+        secp256k1_gej_add_var(&tmp, &data->output[iter], &data->expected_output[iter], NULL);\n+        CHECK(secp256k1_gej_is_infinity(&tmp));\n+    }\n+}\n+\n+static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n+    secp256k1_sha256 sha256;\n+    unsigned char c[11] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n+    unsigned char buf[32];\n+    int overflow = 0;\n+    c[6] = num;\n+    c[7] = num >> 8;\n+    c[8] = num >> 16;\n+    c[9] = num >> 24;\n+    secp256k1_sha256_initialize(&sha256);\n+    secp256k1_sha256_write(&sha256, c, sizeof(c));\n+    secp256k1_sha256_finalize(&sha256, buf);\n+    secp256k1_scalar_set_b32(scalar, buf, &overflow);\n+    CHECK(!overflow);\n+}\n+\n+static void run_test(bench_data* data, size_t count, int includes_g) {\n+    char str[32];\n+    static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    size_t iters = 1 + ITERS / count;\n+    size_t iter;\n+\n+    data->count = count;\n+    data->includes_g = includes_g;\n+\n+    /* Compute (the negation of) the expected results directly. */\n+    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    for (iter = 0; iter < iters; ++iter) {\n+        secp256k1_scalar tmp;\n+        secp256k1_scalar total = data->scalars[(data->offset1++) % POINTS];\n+        size_t i = 0;\n+        for (i = 0; i + 1 < count; ++i) {\n+            secp256k1_scalar_mul(&tmp, &data->seckeys[(data->offset2++) % POINTS], &data->scalars[(data->offset1++) % POINTS]);\n+            secp256k1_scalar_add(&total, &total, &tmp);\n+        }\n+        secp256k1_scalar_negate(&total, &total);\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->expected_output[iter], NULL, &zero, &total);\n+    }\n+\n+    /* Run the benchmark. */\n+    sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n+    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * (1 + ITERS / count));\n+}\n+\n+int main(int argc, char **argv) {\n+    bench_data data;\n+    int i, p;\n+    secp256k1_gej* pubkeys_gej;\n+    size_t scratch_size;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n+    data.ecmult_multi = secp256k1_ecmult_multi_var;\n+\n+    if (argc > 1) {\n+        if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n+            printf(\"Using pippenger_wnaf:\\n\");\n+            data.ecmult_multi = secp256k1_ecmult_pippenger_batch_single;\n+        } else if(have_flag(argc, argv, \"strauss_wnaf\")) {\n+            printf(\"Using strauss_wnaf:\\n\");\n+            data.ecmult_multi = secp256k1_ecmult_strauss_batch_single;\n+        } else if(have_flag(argc, argv, \"simple\")) {\n+            printf(\"Using simple algorithm:\\n\");\n+            data.ecmult_multi = secp256k1_ecmult_multi_var;\n+            secp256k1_scratch_space_destroy(data.scratch);\n+            data.scratch = NULL;\n+        } else {\n+            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n+            fprintf(stderr, \"Use 'pippenger_wnaf', 'strauss_wnaf', 'simple' or no argument to benchmark a combined algorithm.\\n\");\n+            return 1;\n+        }\n+    }\n+\n+    /* Allocate stuff */\n+    data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n+    data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n+    data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n+    data.expected_output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n+    data.output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n+\n+    /* Generate a set of scalars, and private/public keypairs. */\n+    pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n+    secp256k1_gej_set_ge(&pubkeys_gej[0], &secp256k1_ge_const_g);\n+    secp256k1_scalar_set_int(&data.seckeys[0], 1);\n+    for (i = 0; i < POINTS; ++i) {\n+        generate_scalar(i, &data.scalars[i]);\n+        if (i) {\n+            secp256k1_gej_double_var(&pubkeys_gej[i], &pubkeys_gej[i - 1], NULL);\n+            secp256k1_scalar_add(&data.seckeys[i], &data.seckeys[i - 1], &data.seckeys[i - 1]);\n+        }\n+    }\n+    secp256k1_ge_set_all_gej_var(data.pubkeys, pubkeys_gej, POINTS);\n+    free(pubkeys_gej);\n+\n+    for (i = 1; i <= 8; ++i) {\n+        run_test(&data, i, 1);\n+    }\n+\n+    for (p = 0; p <= 11; ++p) {\n+        for (i = 9; i <= 16; ++i) {\n+            run_test(&data, i << p, 1);\n+        }\n+    }\n+    secp256k1_context_destroy(data.ctx);\n+    if (data.scratch != NULL) {\n+        secp256k1_scratch_space_destroy(data.scratch);\n+    }\n+    free(data.scalars);\n+    free(data.pubkeys);\n+    free(data.seckeys);\n+    free(data.output);\n+    free(data.expected_output);\n+\n+    return(0);\n+}"
      },
      {
        "sha": "9071724331e1e1d76de33da50ab727a6d514de4e",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 35,
        "deletions": 48,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -25,10 +25,10 @@ typedef struct {\n     secp256k1_gej gej_x, gej_y;\n     unsigned char data[64];\n     int wnaf[256];\n-} bench_inv_t;\n+} bench_inv;\n \n void bench_setup(void* arg) {\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     static const unsigned char init_x[32] = {\n         0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n@@ -58,7 +58,7 @@ void bench_setup(void* arg) {\n \n void bench_scalar_add(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n@@ -67,7 +67,7 @@ void bench_scalar_add(void* arg) {\n \n void bench_scalar_negate(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_scalar_negate(&data->scalar_x, &data->scalar_x);\n@@ -76,7 +76,7 @@ void bench_scalar_negate(void* arg) {\n \n void bench_scalar_sqr(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_scalar_sqr(&data->scalar_x, &data->scalar_x);\n@@ -85,7 +85,7 @@ void bench_scalar_sqr(void* arg) {\n \n void bench_scalar_mul(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_scalar_mul(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n@@ -95,7 +95,7 @@ void bench_scalar_mul(void* arg) {\n #ifdef USE_ENDOMORPHISM\n void bench_scalar_split(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_scalar l, r;\n@@ -107,7 +107,7 @@ void bench_scalar_split(void* arg) {\n \n void bench_scalar_inverse(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000; i++) {\n         secp256k1_scalar_inverse(&data->scalar_x, &data->scalar_x);\n@@ -117,7 +117,7 @@ void bench_scalar_inverse(void* arg) {\n \n void bench_scalar_inverse_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000; i++) {\n         secp256k1_scalar_inverse_var(&data->scalar_x, &data->scalar_x);\n@@ -127,7 +127,7 @@ void bench_scalar_inverse_var(void* arg) {\n \n void bench_field_normalize(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_fe_normalize(&data->fe_x);\n@@ -136,7 +136,7 @@ void bench_field_normalize(void* arg) {\n \n void bench_field_normalize_weak(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 2000000; i++) {\n         secp256k1_fe_normalize_weak(&data->fe_x);\n@@ -145,7 +145,7 @@ void bench_field_normalize_weak(void* arg) {\n \n void bench_field_mul(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_fe_mul(&data->fe_x, &data->fe_x, &data->fe_y);\n@@ -154,7 +154,7 @@ void bench_field_mul(void* arg) {\n \n void bench_field_sqr(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_fe_sqr(&data->fe_x, &data->fe_x);\n@@ -163,7 +163,7 @@ void bench_field_sqr(void* arg) {\n \n void bench_field_inverse(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_fe_inv(&data->fe_x, &data->fe_x);\n@@ -173,7 +173,7 @@ void bench_field_inverse(void* arg) {\n \n void bench_field_inverse_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_fe_inv_var(&data->fe_x, &data->fe_x);\n@@ -183,17 +183,19 @@ void bench_field_inverse_var(void* arg) {\n \n void bench_field_sqrt(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_fe t;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n+        t = data->fe_x;\n+        secp256k1_fe_sqrt(&data->fe_x, &t);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n \n void bench_group_double_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_double_var(&data->gej_x, &data->gej_x, NULL);\n@@ -202,7 +204,7 @@ void bench_group_double_var(void* arg) {\n \n void bench_group_add_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_add_var(&data->gej_x, &data->gej_x, &data->gej_y, NULL);\n@@ -211,7 +213,7 @@ void bench_group_add_var(void* arg) {\n \n void bench_group_add_affine(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_add_ge(&data->gej_x, &data->gej_x, &data->ge_y);\n@@ -220,7 +222,7 @@ void bench_group_add_affine(void* arg) {\n \n void bench_group_add_affine_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 200000; i++) {\n         secp256k1_gej_add_ge_var(&data->gej_x, &data->gej_x, &data->ge_y, NULL);\n@@ -229,7 +231,7 @@ void bench_group_add_affine_var(void* arg) {\n \n void bench_group_jacobi_var(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_gej_has_quad_y_var(&data->gej_x);\n@@ -238,7 +240,7 @@ void bench_group_jacobi_var(void* arg) {\n \n void bench_ecmult_wnaf(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n@@ -248,19 +250,19 @@ void bench_ecmult_wnaf(void* arg) {\n \n void bench_wnaf_const(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A);\n+        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }\n \n \n void bench_sha256(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n-    secp256k1_sha256_t sha;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_sha256 sha;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_sha256_initialize(&sha);\n@@ -271,8 +273,8 @@ void bench_sha256(void* arg) {\n \n void bench_hmac_sha256(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n-    secp256k1_hmac_sha256_t hmac;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_hmac_sha256 hmac;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_hmac_sha256_initialize(&hmac, data->data, 32);\n@@ -283,8 +285,8 @@ void bench_hmac_sha256(void* arg) {\n \n void bench_rfc6979_hmac_sha256(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n-    secp256k1_rfc6979_hmac_sha256_t rng;\n+    bench_inv *data = (bench_inv*)arg;\n+    secp256k1_rfc6979_hmac_sha256 rng;\n \n     for (i = 0; i < 20000; i++) {\n         secp256k1_rfc6979_hmac_sha256_initialize(&rng, data->data, 64);\n@@ -311,7 +313,7 @@ void bench_context_sign(void* arg) {\n #ifndef USE_NUM_NONE\n void bench_num_jacobi(void* arg) {\n     int i;\n-    bench_inv_t *data = (bench_inv_t*)arg;\n+    bench_inv *data = (bench_inv*)arg;\n     secp256k1_num nx, norder;\n \n     secp256k1_scalar_get_num(&nx, &data->scalar_x);\n@@ -324,23 +326,8 @@ void bench_num_jacobi(void* arg) {\n }\n #endif\n \n-int have_flag(int argc, char** argv, char *flag) {\n-    char** argm = argv + argc;\n-    argv++;\n-    if (argv == argm) {\n-        return 1;\n-    }\n-    while (argv != NULL && argv != argm) {\n-        if (strcmp(*argv, flag) == 0) {\n-            return 1;\n-        }\n-        argv++;\n-    }\n-    return 0;\n-}\n-\n int main(int argc, char **argv) {\n-    bench_inv_t data;\n+    bench_inv data;\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, 2000000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, 2000000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, 200000);"
      },
      {
        "sha": "b806eed94e1501becbdfc1d89a741e2ec6076276",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -13,11 +13,11 @@ typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n     unsigned char sig[64];\n-} bench_recover_t;\n+} bench_recover_data;\n \n void bench_recover(void* arg) {\n     int i;\n-    bench_recover_t *data = (bench_recover_t*)arg;\n+    bench_recover_data *data = (bench_recover_data*)arg;\n     secp256k1_pubkey pubkey;\n     unsigned char pubkeyc[33];\n \n@@ -38,7 +38,7 @@ void bench_recover(void* arg) {\n \n void bench_recover_setup(void* arg) {\n     int i;\n-    bench_recover_t *data = (bench_recover_t*)arg;\n+    bench_recover_data *data = (bench_recover_data*)arg;\n \n     for (i = 0; i < 32; i++) {\n         data->msg[i] = 1 + i;\n@@ -49,7 +49,7 @@ void bench_recover_setup(void* arg) {\n }\n \n int main(void) {\n-    bench_recover_t data;\n+    bench_recover_data data;\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n "
      },
      {
        "sha": "544b43963c8d10d08aaddbd748abaaf181296223",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -12,11 +12,11 @@ typedef struct {\n     secp256k1_context* ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n-} bench_sign_t;\n+} bench_sign;\n \n static void bench_sign_setup(void* arg) {\n     int i;\n-    bench_sign_t *data = (bench_sign_t*)arg;\n+    bench_sign *data = (bench_sign*)arg;\n \n     for (i = 0; i < 32; i++) {\n         data->msg[i] = i + 1;\n@@ -26,9 +26,9 @@ static void bench_sign_setup(void* arg) {\n     }\n }\n \n-static void bench_sign(void* arg) {\n+static void bench_sign_run(void* arg) {\n     int i;\n-    bench_sign_t *data = (bench_sign_t*)arg;\n+    bench_sign *data = (bench_sign*)arg;\n \n     unsigned char sig[74];\n     for (i = 0; i < 20000; i++) {\n@@ -45,11 +45,11 @@ static void bench_sign(void* arg) {\n }\n \n int main(void) {\n-    bench_sign_t data;\n+    bench_sign data;\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n-    run_benchmark(\"ecdsa_sign\", bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, 20000);\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "7c5b789325f40d2886ff28ede70ab4ff436700b8",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -18,7 +18,7 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge *elem, const unsigned char\n     if (size == 33 && (pub[0] == SECP256K1_TAG_PUBKEY_EVEN || pub[0] == SECP256K1_TAG_PUBKEY_ODD)) {\n         secp256k1_fe x;\n         return secp256k1_fe_set_b32(&x, pub+1) && secp256k1_ge_set_xo_var(elem, &x, pub[0] == SECP256K1_TAG_PUBKEY_ODD);\n-    } else if (size == 65 && (pub[0] == 0x04 || pub[0] == 0x06 || pub[0] == 0x07)) {\n+    } else if (size == 65 && (pub[0] == SECP256K1_TAG_PUBKEY_UNCOMPRESSED || pub[0] == SECP256K1_TAG_PUBKEY_HYBRID_EVEN || pub[0] == SECP256K1_TAG_PUBKEY_HYBRID_ODD)) {\n         secp256k1_fe x, y;\n         if (!secp256k1_fe_set_b32(&x, pub+1) || !secp256k1_fe_set_b32(&y, pub+33)) {\n             return 0;"
      },
      {
        "sha": "3d75a960f424712b68dab7bd7f71c79b73b1351d",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra      *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -9,6 +9,8 @@\n \n #include \"num.h\"\n #include \"group.h\"\n+#include \"scalar.h\"\n+#include \"scratch.h\"\n \n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */\n@@ -28,4 +30,19 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n /** Double multiply: R = na*A + ng*G */\n static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n+typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n+\n+/**\n+ * Multi-multiply: R = inp_g_sc * G + sum_i ni * Ai.\n+ * Chooses the right algorithm for a given number of points and scratch space\n+ * size. Resets and overwrites the given scratch space. If the points do not\n+ * fit in the scratch space the algorithm is repeatedly run with batches of\n+ * points. If no scratch space is given then a simple algorithm is used that\n+ * simply multiplies the points with the corresponding scalars and adds them up.\n+ * Returns: 1 on success (including when inp_g_sc is NULL and n is 0)\n+ *          0 if there is not enough scratch space for a single point or\n+ *          callback returns 0\n+ */\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+\n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "d4804b8b68faa3ce5944e1695ec5eda3d5db3cab",
        "filename": "src/secp256k1/src/ecmult_const.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -10,6 +10,8 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q);\n+/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "8411752eb069f6da43a8e555939f106c81d2abbd",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 57,
        "deletions": 40,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -12,13 +12,6 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n-#ifdef USE_ENDOMORPHISM\n-    #define WNAF_BITS 128\n-#else\n-    #define WNAF_BITS 256\n-#endif\n-#define WNAF_SIZE(w) ((WNAF_BITS + (w) - 1) / (w))\n-\n /* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n #define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n     int m; \\\n@@ -55,7 +48,7 @@\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n+static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -74,9 +67,14 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n      * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n      * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication. */\n-\n-    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n+     * this, and having the caller compensate after doing the multiplication.\n+     *\n+     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n+     * particular, to ensure that the outputs from the endomorphism-split fit into\n+     * 128 bits). If we negate, the parity of our number flips, inverting which of\n+     * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n+     * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n+     * we need to special-case it in this logic. */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n     bit = flip ^ !secp256k1_scalar_is_even(&s);\n@@ -95,7 +93,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < WNAF_BITS) {\n+    while (word * w < size) {\n         int sign;\n         int even;\n \n@@ -115,37 +113,44 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE(w));\n+    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n     return skew;\n }\n \n-\n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar) {\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar, int size) {\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n     int skew_1;\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n #endif\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n     secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n+    int rsize = size;\n+#ifdef USE_ENDOMORPHISM\n+    if (size > 128) {\n+        rsize = 128;\n+        /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+    } else\n+#endif\n+    {\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n-    /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n-    skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n-#else\n-    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n+        skew_lam = 0;\n #endif\n+    }\n \n     /* Calculate odd multiples of a.\n      * All multiples are brought to the same Z 'denominator', which is stored\n@@ -159,26 +164,30 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         secp256k1_fe_normalize_weak(&pre_a[i].y);\n     }\n #ifdef USE_ENDOMORPHISM\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n-        secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+    if (size > 128) {\n+        for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+            secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+        }\n     }\n #endif\n \n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-    i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n+    i = wnaf_1[WNAF_SIZE_BITS(rsize, WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n #ifdef USE_ENDOMORPHISM\n-    i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n-    secp256k1_gej_add_ge(r, r, &tmpa);\n+    if (size > 128) {\n+        i = wnaf_lam[WNAF_SIZE_BITS(rsize, WINDOW_A - 1)];\n+        VERIFY_CHECK(i != 0);\n+        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n+        secp256k1_gej_add_ge(r, r, &tmpa);\n+    }\n #endif\n     /* remaining loop iterations */\n-    for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n+    for (i = WNAF_SIZE_BITS(rsize, WINDOW_A - 1) - 1; i >= 0; i--) {\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n@@ -190,10 +199,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n #ifdef USE_ENDOMORPHISM\n-        n = wnaf_lam[i];\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n-        VERIFY_CHECK(n != 0);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n+        if (size > 128) {\n+            n = wnaf_lam[i];\n+            ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n+            VERIFY_CHECK(n != 0);\n+            secp256k1_gej_add_ge(r, r, &tmpa);\n+        }\n #endif\n     }\n \n@@ -213,14 +224,18 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n #ifdef USE_ENDOMORPHISM\n-        secp256k1_ge_to_storage(&correction_lam_stor, a);\n+        if (size > 128) {\n+            secp256k1_ge_to_storage(&correction_lam_stor, a);\n+        }\n #endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n #ifdef USE_ENDOMORPHISM\n-        secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+        if (size > 128) {\n+            secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+        }\n #endif\n \n         /* Apply the correction */\n@@ -229,10 +244,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         secp256k1_gej_add_ge(r, r, &correction);\n \n #ifdef USE_ENDOMORPHISM\n-        secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n-        secp256k1_ge_neg(&correction, &correction);\n-        secp256k1_ge_mul_lambda(&correction, &correction);\n-        secp256k1_gej_add_ge(r, r, &correction);\n+        if (size > 128) {\n+            secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n+            secp256k1_ge_neg(&correction, &correction);\n+            secp256k1_ge_mul_lambda(&correction, &correction);\n+            secp256k1_gej_add_ge(r, r, &correction);\n+        }\n #endif\n     }\n }"
      },
      {
        "sha": "d64505dc00107879dadae95dce1f87fb6aec1482",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -77,7 +77,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(prec, precj, 1024, cb);\n+        secp256k1_ge_set_all_gej_var(prec, precj, 1024);\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {\n@@ -161,7 +161,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     secp256k1_gej gb;\n     secp256k1_fe s;\n     unsigned char nonce32[32];\n-    secp256k1_rfc6979_hmac_sha256_t rng;\n+    secp256k1_rfc6979_hmac_sha256 rng;\n     int retry;\n     unsigned char keydata[64] = {0};\n     if (seed32 == NULL) {"
      },
      {
        "sha": "1986914a4fd5d3707aeaa75b97500c677186a3b3",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 852,
        "deletions": 77,
        "changes": 929,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -1,13 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/*****************************************************************************\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick *\n+ * Distributed under the MIT software license, see the accompanying          *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.       *\n+ *****************************************************************************/\n \n #ifndef SECP256K1_ECMULT_IMPL_H\n #define SECP256K1_ECMULT_IMPL_H\n \n #include <string.h>\n+#include <stdint.h>\n \n #include \"group.h\"\n #include \"scalar.h\"\n@@ -41,9 +42,36 @@\n #endif\n #endif\n \n+#ifdef USE_ENDOMORPHISM\n+    #define WNAF_BITS 128\n+#else\n+    #define WNAF_BITS 256\n+#endif\n+#define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n+#define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n+\n /** The number of entries a table with precomputed multiples needs to have. */\n #define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n \n+/* The number of objects allocated on the scratch space for ecmult_multi algorithms */\n+#define PIPPENGER_SCRATCH_OBJECTS 6\n+#define STRAUSS_SCRATCH_OBJECTS 6\n+\n+#define PIPPENGER_MAX_BUCKET_WINDOW 12\n+\n+/* Minimum number of points for which pippenger_wnaf is faster than strauss wnaf */\n+#ifdef USE_ENDOMORPHISM\n+    #define ECMULT_PIPPENGER_THRESHOLD 88\n+#else\n+    #define ECMULT_PIPPENGER_THRESHOLD 160\n+#endif\n+\n+#ifdef USE_ENDOMORPHISM\n+    #define ECMULT_MAX_POINTS_PER_BATCH 5000000\n+#else\n+    #define ECMULT_MAX_POINTS_PER_BATCH 10000000\n+#endif\n+\n /** Fill a table 'prej' with precomputed odd multiples of a. Prej will contain\n  *  the values [1*a,3*a,...,(2*n-1)*a], so it space for n values. zr[0] will\n  *  contain prej[0].z / a.z. The other zr[i] values = prej[i].z / prej[i-1].z.\n@@ -109,24 +137,135 @@ static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *p\n     secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A), pre, globalz, prej, zr);\n }\n \n-static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge_storage *pre, const secp256k1_gej *a, const secp256k1_callback *cb) {\n-    secp256k1_gej *prej = (secp256k1_gej*)checked_malloc(cb, sizeof(secp256k1_gej) * n);\n-    secp256k1_ge *prea = (secp256k1_ge*)checked_malloc(cb, sizeof(secp256k1_ge) * n);\n-    secp256k1_fe *zr = (secp256k1_fe*)checked_malloc(cb, sizeof(secp256k1_fe) * n);\n+static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp256k1_ge_storage *pre, const secp256k1_gej *a) {\n+    secp256k1_gej d;\n+    secp256k1_ge d_ge, p_ge;\n+    secp256k1_gej pj;\n+    secp256k1_fe zi;\n+    secp256k1_fe zr;\n+    secp256k1_fe dx_over_dz_squared;\n     int i;\n \n-    /* Compute the odd multiples in Jacobian form. */\n-    secp256k1_ecmult_odd_multiples_table(n, prej, zr, a);\n-    /* Convert them in batch to affine coordinates. */\n-    secp256k1_ge_set_table_gej_var(prea, prej, zr, n);\n-    /* Convert them to compact storage form. */\n-    for (i = 0; i < n; i++) {\n-        secp256k1_ge_to_storage(&pre[i], &prea[i]);\n+    VERIFY_CHECK(!a->infinity);\n+\n+    secp256k1_gej_double_var(&d, a, NULL);\n+\n+    /* First, we perform all the additions in an isomorphic curve obtained by multiplying\n+     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use\n+     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store\n+     * the resulting y-coordinate and the z-ratio, since we only have enough memory to\n+     * store two field elements. These are sufficient to efficiently undo the isomorphism\n+     * and recompute all the `x`s.\n+     */\n+    d_ge.x = d.x;\n+    d_ge.y = d.y;\n+    d_ge.infinity = 0;\n+\n+    secp256k1_ge_set_gej_zinv(&p_ge, a, &d.z);\n+    pj.x = p_ge.x;\n+    pj.y = p_ge.y;\n+    pj.z = a->z;\n+    pj.infinity = 0;\n+\n+    for (i = 0; i < (n - 1); i++) {\n+        secp256k1_fe_normalize_var(&pj.y);\n+        secp256k1_fe_to_storage(&pre[i].y, &pj.y);\n+        secp256k1_gej_add_ge_var(&pj, &pj, &d_ge, &zr);\n+        secp256k1_fe_normalize_var(&zr);\n+        secp256k1_fe_to_storage(&pre[i].x, &zr);\n     }\n \n-    free(prea);\n-    free(prej);\n-    free(zr);\n+    /* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */\n+    secp256k1_fe_mul(&zi, &pj.z, &d.z);\n+    secp256k1_fe_inv_var(&zi, &zi);\n+\n+    /* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so\n+     * that we can combine it with the saved z-ratios to compute the other zs\n+     * without any more inversions. */\n+    secp256k1_ge_set_gej_zinv(&p_ge, &pj, &zi);\n+    secp256k1_ge_to_storage(&pre[n - 1], &p_ge);\n+\n+    /* Compute the actual x-coordinate of D, which will be needed below. */\n+    secp256k1_fe_mul(&d.z, &zi, &pj.z);  /* d.z = 1/d.z */\n+    secp256k1_fe_sqr(&dx_over_dz_squared, &d.z);\n+    secp256k1_fe_mul(&dx_over_dz_squared, &dx_over_dz_squared, &d.x);\n+\n+    /* Going into the second loop, we have set `pre[n-1]` to its final affine\n+     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We\n+     * have `zi = (p.z * d.z)^-1`, where\n+     *\n+     *     `p.z` is the z-coordinate of the point on the isomorphic curve\n+     *           which was ultimately assigned to `pre[n-1]`.\n+     *     `d.z` is the multiplier that must be applied to all z-coordinates\n+     *           to move from our isomorphic curve back to secp256k1; so the\n+     *           product `p.z * d.z` is the z-coordinate of the secp256k1\n+     *           point assigned to `pre[n-1]`.\n+     *\n+     * All subsequent inverse-z-coordinates can be obtained by multiplying this\n+     * factor by successive z-ratios, which is much more efficient than directly\n+     * computing each one.\n+     *\n+     * Importantly, these inverse-zs will be coordinates of points on secp256k1,\n+     * while our other stored values come from computations on the isomorphic\n+     * curve. So in the below loop, we will take care not to actually use `zi`\n+     * or any derived values until we're back on secp256k1.\n+     */\n+    i = n - 1;\n+    while (i > 0) {\n+        secp256k1_fe zi2, zi3;\n+        const secp256k1_fe *rzr;\n+        i--;\n+\n+        secp256k1_ge_from_storage(&p_ge, &pre[i]);\n+\n+        /* For each remaining point, we extract the z-ratio from the stored\n+         * x-coordinate, compute its z^-1 from that, and compute the full\n+         * point from that. */\n+        rzr = &p_ge.x;\n+        secp256k1_fe_mul(&zi, &zi, rzr);\n+        secp256k1_fe_sqr(&zi2, &zi);\n+        secp256k1_fe_mul(&zi3, &zi2, &zi);\n+        /* To compute the actual x-coordinate, we use the stored z ratio and\n+         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`\n+         * in the loop above, as well as the inverse of the square of its\n+         * z-coordinate. We store the latter in the `zi2` variable, which is\n+         * computed iteratively starting from the overall Z inverse then\n+         * multiplying by each z-ratio in turn.\n+         *\n+         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`\n+         * from the inside of the above `gej_add_ge_var` call. This satisfies\n+         *\n+         *    rzr = d_x * z^2 - x * d_z^2\n+         *\n+         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`\n+         * are Jacobian coordinates of our desired point -- except both are on\n+         * the isomorphic curve that we were using when we called `gej_add_ge_var`.\n+         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or\n+         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes\n+         *\n+         *    rzr = d_x * z^2 / d_z^2 - x\n+         *\n+         * (The left-hand-side, being a ratio of z-coordinates, is unaffected\n+         * by the isomorphism.)\n+         *\n+         * Rearranging to solve for `x`, we have\n+         *\n+         *     x = d_x * z^2 / d_z^2 - rzr\n+         *\n+         * But what we actually want is the affine coordinate `X = x/z^2`,\n+         * which will satisfy\n+         *\n+         *     X = d_x / d_z^2 - rzr / z^2\n+         *       = dx_over_dz_squared - rzr * zi2\n+         */\n+        secp256k1_fe_mul(&p_ge.x, rzr, &zi2);\n+        secp256k1_fe_negate(&p_ge.x, &p_ge.x, 1);\n+        secp256k1_fe_add(&p_ge.x, &dx_over_dz_squared);\n+        /* y is stored_y/z^3, as we expect */\n+        secp256k1_fe_mul(&p_ge.y, &p_ge.y, &zi3);\n+        /* Store */\n+        secp256k1_ge_to_storage(&pre[i], &p_ge);\n+    }\n }\n \n /** The following two macro retrieves a particular odd multiple from a table\n@@ -138,7 +277,8 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n     if ((n) > 0) { \\\n         *(r) = (pre)[((n)-1)/2]; \\\n     } else { \\\n-        secp256k1_ge_neg((r), &(pre)[(-(n)-1)/2]); \\\n+        *(r) = (pre)[(-(n)-1)/2]; \\\n+        secp256k1_fe_negate(&((r)->y), &((r)->y), 1); \\\n     } \\\n } while(0)\n \n@@ -150,7 +290,7 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n         secp256k1_ge_from_storage((r), &(pre)[((n)-1)/2]); \\\n     } else { \\\n         secp256k1_ge_from_storage((r), &(pre)[(-(n)-1)/2]); \\\n-        secp256k1_ge_neg((r), (r)); \\\n+        secp256k1_fe_negate(&((r)->y), &((r)->y), 1); \\\n     } \\\n } while(0)\n \n@@ -174,7 +314,7 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n \n     /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj, cb);\n+    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n \n #ifdef USE_ENDOMORPHISM\n     {\n@@ -188,7 +328,7 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         for (i = 0; i < 128; i++) {\n             secp256k1_gej_double_var(&g_128j, &g_128j, NULL);\n         }\n-        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j, cb);\n+        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n     }\n #endif\n }\n@@ -283,50 +423,78 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     return last_set_bit + 1;\n }\n \n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n-    secp256k1_fe Z;\n+struct secp256k1_strauss_point_state {\n #ifdef USE_ENDOMORPHISM\n-    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_scalar na_1, na_lam;\n-    /* Splitted G factors. */\n-    secp256k1_scalar ng_1, ng_128;\n     int wnaf_na_1[130];\n     int wnaf_na_lam[130];\n     int bits_na_1;\n     int bits_na_lam;\n-    int wnaf_ng_1[129];\n-    int bits_ng_1;\n-    int wnaf_ng_128[129];\n-    int bits_ng_128;\n #else\n     int wnaf_na[256];\n     int bits_na;\n+#endif\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_strauss_state {\n+    secp256k1_gej* prej;\n+    secp256k1_fe* zr;\n+    secp256k1_ge* pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge* pre_a_lam;\n+#endif\n+    struct secp256k1_strauss_point_state* ps;\n+};\n+\n+static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, int num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_ge tmpa;\n+    secp256k1_fe Z;\n+#ifdef USE_ENDOMORPHISM\n+    /* Splitted G factors. */\n+    secp256k1_scalar ng_1, ng_128;\n+    int wnaf_ng_1[129];\n+    int bits_ng_1 = 0;\n+    int wnaf_ng_128[129];\n+    int bits_ng_128 = 0;\n+#else\n     int wnaf_ng[256];\n-    int bits_ng;\n+    int bits_ng = 0;\n #endif\n     int i;\n-    int bits;\n+    int bits = 0;\n+    int np;\n+    int no = 0;\n \n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&na[np]) || secp256k1_gej_is_infinity(&a[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n #ifdef USE_ENDOMORPHISM\n-    /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&na_1, &na_lam, na);\n-\n-    /* build wnaf representation for na_1 and na_lam. */\n-    bits_na_1   = secp256k1_ecmult_wnaf(wnaf_na_1,   130, &na_1,   WINDOW_A);\n-    bits_na_lam = secp256k1_ecmult_wnaf(wnaf_na_lam, 130, &na_lam, WINDOW_A);\n-    VERIFY_CHECK(bits_na_1 <= 130);\n-    VERIFY_CHECK(bits_na_lam <= 130);\n-    bits = bits_na_1;\n-    if (bits_na_lam > bits) {\n-        bits = bits_na_lam;\n-    }\n+        /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */\n+        secp256k1_scalar_split_lambda(&state->ps[no].na_1, &state->ps[no].na_lam, &na[np]);\n+\n+        /* build wnaf representation for na_1 and na_lam. */\n+        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   130, &state->ps[no].na_1,   WINDOW_A);\n+        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 130, &state->ps[no].na_lam, WINDOW_A);\n+        VERIFY_CHECK(state->ps[no].bits_na_1 <= 130);\n+        VERIFY_CHECK(state->ps[no].bits_na_lam <= 130);\n+        if (state->ps[no].bits_na_1 > bits) {\n+            bits = state->ps[no].bits_na_1;\n+        }\n+        if (state->ps[no].bits_na_lam > bits) {\n+            bits = state->ps[no].bits_na_lam;\n+        }\n #else\n-    /* build wnaf representation for na. */\n-    bits_na     = secp256k1_ecmult_wnaf(wnaf_na,     256, na,      WINDOW_A);\n-    bits = bits_na;\n+        /* build wnaf representation for na. */\n+        state->ps[no].bits_na     = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na,     256, &na[np],      WINDOW_A);\n+        if (state->ps[no].bits_na > bits) {\n+            bits = state->ps[no].bits_na;\n+        }\n #endif\n+        ++no;\n+    }\n \n     /* Calculate odd multiples of a.\n      * All multiples are brought to the same Z 'denominator', which is stored\n@@ -338,29 +506,51 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n      * of 1/Z, so we can use secp256k1_gej_add_zinv_var, which uses the same\n      * isomorphism to efficiently add with a known Z inverse.\n      */\n-    secp256k1_ecmult_odd_multiples_table_globalz_windowa(pre_a, &Z, a);\n+    if (no > 0) {\n+        /* Compute the odd multiples in Jacobian form. */\n+        secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->prej, state->zr, &a[state->ps[0].input_pos]);\n+        for (np = 1; np < no; ++np) {\n+            secp256k1_gej tmp = a[state->ps[np].input_pos];\n+#ifdef VERIFY\n+            secp256k1_fe_normalize_var(&(state->prej[(np - 1) * ECMULT_TABLE_SIZE(WINDOW_A) + ECMULT_TABLE_SIZE(WINDOW_A) - 1].z));\n+#endif\n+            secp256k1_gej_rescale(&tmp, &(state->prej[(np - 1) * ECMULT_TABLE_SIZE(WINDOW_A) + ECMULT_TABLE_SIZE(WINDOW_A) - 1].z));\n+            secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->prej + np * ECMULT_TABLE_SIZE(WINDOW_A), state->zr + np * ECMULT_TABLE_SIZE(WINDOW_A), &tmp);\n+            secp256k1_fe_mul(state->zr + np * ECMULT_TABLE_SIZE(WINDOW_A), state->zr + np * ECMULT_TABLE_SIZE(WINDOW_A), &(a[state->ps[np].input_pos].z));\n+        }\n+        /* Bring them to the same Z denominator. */\n+        secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A) * no, state->pre_a, &Z, state->prej, state->zr);\n+    } else {\n+        secp256k1_fe_set_int(&Z, 1);\n+    }\n \n #ifdef USE_ENDOMORPHISM\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n-        secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+    for (np = 0; np < no; ++np) {\n+        for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+            secp256k1_ge_mul_lambda(&state->pre_a_lam[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i]);\n+        }\n     }\n \n-    /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */\n-    secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n+    if (ng) {\n+        /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */\n+        secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n \n-    /* Build wnaf representation for ng_1 and ng_128 */\n-    bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   129, &ng_1,   WINDOW_G);\n-    bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, 129, &ng_128, WINDOW_G);\n-    if (bits_ng_1 > bits) {\n-        bits = bits_ng_1;\n-    }\n-    if (bits_ng_128 > bits) {\n-        bits = bits_ng_128;\n+        /* Build wnaf representation for ng_1 and ng_128 */\n+        bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   129, &ng_1,   WINDOW_G);\n+        bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, 129, &ng_128, WINDOW_G);\n+        if (bits_ng_1 > bits) {\n+            bits = bits_ng_1;\n+        }\n+        if (bits_ng_128 > bits) {\n+            bits = bits_ng_128;\n+        }\n     }\n #else\n-    bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     256, ng,      WINDOW_G);\n-    if (bits_ng > bits) {\n-        bits = bits_ng;\n+    if (ng) {\n+        bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     256, ng,      WINDOW_G);\n+        if (bits_ng > bits) {\n+            bits = bits_ng;\n+        }\n     }\n #endif\n \n@@ -370,13 +560,15 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n         int n;\n         secp256k1_gej_double_var(r, r, NULL);\n #ifdef USE_ENDOMORPHISM\n-        if (i < bits_na_1 && (n = wnaf_na_1[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-            secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n-        }\n-        if (i < bits_na_lam && (n = wnaf_na_lam[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n-            secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+        for (np = 0; np < no; ++np) {\n+            if (i < state->ps[np].bits_na_1 && (n = state->ps[np].wnaf_na_1[i])) {\n+                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n+                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+            }\n+            if (i < state->ps[np].bits_na_lam && (n = state->ps[np].wnaf_na_lam[i])) {\n+                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a_lam + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n+                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+            }\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n             ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n@@ -387,9 +579,11 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n #else\n-        if (i < bits_na && (n = wnaf_na[i])) {\n-            ECMULT_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-            secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+        for (np = 0; np < no; ++np) {\n+            if (i < state->ps[np].bits_na && (n = state->ps[np].wnaf_na[i])) {\n+                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n+                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n+            }\n         }\n         if (i < bits_ng && (n = wnaf_ng[i])) {\n             ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n@@ -403,4 +597,585 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n+            secp256k1_scratch_deallocate_frame(scratch);\n+            return 0;\n+        }\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    secp256k1_scratch_deallocate_frame(scratch);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] is either 0 or an odd integer between -(1 << w) and (1 << w)\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 or 1\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int skew = 0;\n+    int pos;\n+    int max_pos;\n+    int last_w;\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        for (pos = 0; pos < WNAF_SIZE(w); pos++) {\n+            wnaf[pos] = 0;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+        skew = 1;\n+    }\n+\n+    wnaf[0] = secp256k1_scalar_get_bits_var(work, 0, w) + skew;\n+    /* Compute last window size. Relevant when window size doesn't divide the\n+     * number of bits in the scalar */\n+    last_w = WNAF_BITS - (WNAF_SIZE(w) - 1) * w;\n+\n+    /* Store the position of the first nonzero word in max_pos to allow\n+     * skipping leading zeros when calculating the wnaf. */\n+    for (pos = WNAF_SIZE(w) - 1; pos > 0; pos--) {\n+        int val = secp256k1_scalar_get_bits_var(work, pos * w, pos == WNAF_SIZE(w)-1 ? last_w : w);\n+        if(val != 0) {\n+            break;\n+        }\n+        wnaf[pos] = 0;\n+    }\n+    max_pos = pos;\n+    pos = 1;\n+\n+    while (pos <= max_pos) {\n+        int val = secp256k1_scalar_get_bits_var(work, pos * w, pos == WNAF_SIZE(w)-1 ? last_w : w);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= (1 << w);\n+            wnaf[pos] = (val + 1);\n+        } else {\n+            wnaf[pos] = val;\n+        }\n+        /* Set a coefficient to zero if it is 1 or -1 and the proceeding digit\n+         * is strictly negative or strictly positive respectively. Only change\n+         * coefficients at previous positions because above code assumes that\n+         * wnaf[pos - 1] is odd.\n+         */\n+        if (pos >= 2 && ((wnaf[pos - 1] == 1 && wnaf[pos - 2] < 0) || (wnaf[pos - 1] == -1 && wnaf[pos - 2] > 0))) {\n+            if (wnaf[pos - 1] == 1) {\n+                wnaf[pos - 2] += 1 << w;\n+            } else {\n+                wnaf[pos - 2] -= 1 << w;\n+            }\n+            wnaf[pos - 1] = 0;\n+        }\n+        ++pos;\n+    }\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, const secp256k1_scalar *sc, const secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+\n+        for(j = 0; j < bucket_window; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        secp256k1_gej_set_infinity(&running_sum);\n+        /* Accumulate the sum: bucket[0] + 3*bucket[1] + 5*bucket[2] + 7*bucket[3] + ...\n+         *                   = bucket[0] +   bucket[1] +   bucket[2] +   bucket[3] + ...\n+         *                   +         2 *  (bucket[1] + 2*bucket[2] + 3*bucket[3] + ...)\n+         * using an intermediate running sum:\n+         * running_sum = bucket[0] +   bucket[1] +   bucket[2] + ...\n+         *\n+         * The doubling is done implicitly by deferring the final window doubling (of 'r').\n+         */\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j > 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(r, r, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[0], NULL);\n+        secp256k1_gej_double_var(r, r, NULL);\n+        secp256k1_gej_add_var(r, r, &running_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 1) {\n+        return 1;\n+    } else if (n <= 4) {\n+        return 2;\n+    } else if (n <= 20) {\n+        return 3;\n+    } else if (n <= 57) {\n+        return 4;\n+    } else if (n <= 136) {\n+        return 5;\n+    } else if (n <= 235) {\n+        return 6;\n+    } else if (n <= 1260) {\n+        return 7;\n+    } else if (n <= 4420) {\n+        return 9;\n+    } else if (n <= 7880) {\n+        return 10;\n+    } else if (n <= 16050) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 1) {\n+        return 1;\n+    } else if (n <= 11) {\n+        return 2;\n+    } else if (n <= 45) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 275) {\n+        return 5;\n+    } else if (n <= 625) {\n+        return 6;\n+    } else if (n <= 1850) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 9630) {\n+        return 9;\n+    } else if (n <= 17900) {\n+        return 10;\n+    } else if (n <= 32800) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+/**\n+ * Returns the maximum optimal number of points for a bucket_window.\n+ */\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+    switch(bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+        case 1: return 1;\n+        case 2: return 4;\n+        case 3: return 20;\n+        case 4: return 57;\n+        case 5: return 136;\n+        case 6: return 235;\n+        case 7: return 1260;\n+        case 8: return 1260;\n+        case 9: return 4420;\n+        case 10: return 7880;\n+        case 11: return 16050;\n+        case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n+#else\n+        case 1: return 1;\n+        case 2: return 11;\n+        case 3: return 45;\n+        case 4: return 100;\n+        case 5: return 275;\n+        case 6: return 625;\n+        case 7: return 1850;\n+        case 8: return 3400;\n+        case 9: return 9630;\n+        case 10: return 17900;\n+        case 11: return 32800;\n+        case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n+#endif\n+    }\n+    return 0;\n+}\n+\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            secp256k1_scratch_deallocate_frame(scratch);\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    secp256k1_scratch_deallocate_frame(scratch);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+/**\n+ * Returns the maximum number of points in addition to G that can be used with\n+ * a given scratch space. The function ensures that fewer points may also be\n+ * used.\n+ */\n+static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+    int bucket_window;\n+    size_t res = 0;\n+\n+    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n+        size_t n_points;\n+        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n+        size_t space_for_points;\n+        size_t space_overhead;\n+        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+\n+#ifdef USE_ENDOMORPHISM\n+        entry_size = 2*entry_size;\n+#endif\n+        space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n+        if (space_overhead > max_alloc) {\n+            break;\n+        }\n+        space_for_points = max_alloc - space_overhead;\n+\n+        n_points = space_for_points/entry_size;\n+        n_points = n_points > max_points ? max_points : n_points;\n+        if (n_points > res) {\n+            res = n_points;\n+        }\n+        if (n_points < max_points) {\n+            /* A larger bucket_window may support even more points. But if we\n+             * would choose that then the caller couldn't safely use any number\n+             * smaller than what this function returns */\n+            break;\n+        }\n+    }\n+    return res;\n+}\n+\n+/* Computes ecmult_multi by simply multiplying and adding each point. Does not\n+ * require a scratch space */\n+static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n+    size_t point_idx;\n+    secp256k1_scalar szero;\n+    secp256k1_gej tmpj;\n+\n+    secp256k1_scalar_set_int(&szero, 0);\n+    secp256k1_gej_set_infinity(r);\n+    secp256k1_gej_set_infinity(&tmpj);\n+    /* r = inp_g_sc*G */\n+    secp256k1_ecmult(ctx, r, &tmpj, &szero, inp_g_sc);\n+    for (point_idx = 0; point_idx < n_points; point_idx++) {\n+        secp256k1_ge point;\n+        secp256k1_gej pointj;\n+        secp256k1_scalar scalar;\n+        if (!cb(&scalar, &point, point_idx, cbdata)) {\n+            return 0;\n+        }\n+        /* r += scalar*point */\n+        secp256k1_gej_set_ge(&pointj, &point);\n+        secp256k1_ecmult(ctx, &tmpj, &pointj, &scalar, NULL);\n+        secp256k1_gej_add_var(r, r, &tmpj, NULL);\n+    }\n+    return 1;\n+}\n+\n+/* Compute the number of batches and the batch size given the maximum batch size and the\n+ * total number of points */\n+static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n_batch_points, size_t max_n_batch_points, size_t n) {\n+    if (max_n_batch_points == 0) {\n+        return 0;\n+    }\n+    if (max_n_batch_points > ECMULT_MAX_POINTS_PER_BATCH) {\n+        max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    }\n+    if (n == 0) {\n+        *n_batches = 0;\n+        *n_batch_points = 0;\n+        return 1;\n+    }\n+    /* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */\n+    *n_batches = 1 + (n - 1) / max_n_batch_points;\n+    *n_batch_points = 1 + (n - 1) / *n_batches;\n+    return 1;\n+}\n+\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    size_t i;\n+\n+    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    size_t n_batches;\n+    size_t n_batch_points;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n == 0) {\n+        return 1;\n+    } else if (n == 0) {\n+        secp256k1_scalar szero;\n+        secp256k1_scalar_set_int(&szero, 0);\n+        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        return 1;\n+    }\n+    if (scratch == NULL) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+    }\n+\n+    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n+     * use pippenger. Otherwise use strauss */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n+        return 0;\n+    }\n+    if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n+        f = secp256k1_ecmult_pippenger_batch;\n+    } else {\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n+            return 0;\n+        }\n+        f = secp256k1_ecmult_strauss_batch;\n+    }\n+    for(i = 0; i < n_batches; i++) {\n+        size_t nbp = n < n_batch_points ? n : n_batch_points;\n+        size_t offset = n_batch_points*i;\n+        secp256k1_gej tmp;\n+        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_var(r, r, &tmp, NULL);\n+        n -= nbp;\n+    }\n+    return 1;\n+}\n+\n #endif /* SECP256K1_ECMULT_IMPL_H */"
      },
      {
        "sha": "5ff03c8abcc05aed65e1b736d042b8aedfe98e56",
        "filename": "src/secp256k1/src/field_10x26.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_10x26.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_10x26.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -10,7 +10,9 @@\n #include <stdint.h>\n \n typedef struct {\n-    /* X = sum(i=0..9, elem[i]*2^26) mod n */\n+    /* X = sum(i=0..9, n[i]*2^(i*26)) mod p\n+     * where p = 2^256 - 0x1000003D1\n+     */\n     uint32_t n[10];\n #ifdef VERIFY\n     int magnitude;"
      },
      {
        "sha": "4ae4fdcec884c124a81e45fa1226a17ce3585842",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -8,7 +8,6 @@\n #define SECP256K1_FIELD_REPR_IMPL_H\n \n #include \"util.h\"\n-#include \"num.h\"\n #include \"field.h\"\n \n #ifdef VERIFY\n@@ -486,7 +485,8 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(b[9], 26);\n \n     /** [... a b c] is a shorthand for ... + a<<52 + b<<26 + c<<0 mod n.\n-     *  px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 0 <= x <= 9, px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 9 <= x <= 18, px is a shorthand for sum(a[i]*b[x-i], i=(x-9)..9)\n      *  Note that [x 0 0 0 0 0 0 0 0 0 0] = [x*R1 x*R0].\n      */\n \n@@ -1069,6 +1069,7 @@ static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp2\n     secp256k1_fe_verify(a);\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n+    VERIFY_CHECK(a != b);\n #endif\n     secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY"
      },
      {
        "sha": "fc5bfe357e705d75b1185aa88f9017be2f37cc8e",
        "filename": "src/secp256k1/src/field_5x52.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -10,7 +10,9 @@\n #include <stdint.h>\n \n typedef struct {\n-    /* X = sum(i=0..4, elem[i]*2^52) mod n */\n+    /* X = sum(i=0..4, n[i]*2^(i*52)) mod p\n+     * where p = 2^256 - 0x1000003D1\n+     */\n     uint64_t n[5];\n #ifdef VERIFY\n     int magnitude;"
      },
      {
        "sha": "f4263320d510065c74808638a20ca85c09cc6abf",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -12,7 +12,6 @@\n #endif\n \n #include \"util.h\"\n-#include \"num.h\"\n #include \"field.h\"\n \n #if defined(USE_ASM_X86_64)\n@@ -422,6 +421,7 @@ static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp2\n     secp256k1_fe_verify(a);\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n+    VERIFY_CHECK(a != b);\n #endif\n     secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY"
      },
      {
        "sha": "bcbfb92ac265b2e450af0fae487b8586c30cff42",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -32,9 +32,11 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(b[3], 56);\n     VERIFY_BITS(b[4], 52);\n     VERIFY_CHECK(r != b);\n+    VERIFY_CHECK(a != b);\n \n     /*  [... a b c] is a shorthand for ... + a<<104 + b<<52 + c<<0 mod n.\n-     *  px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 0 <= x <= 4, px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n+     *  for 4 <= x <= 8, px is a shorthand for sum(a[i]*b[x-i], i=(x-4)..4)\n      *  Note that [x 0 0 0 0 0] = [x*R].\n      */\n "
      },
      {
        "sha": "6070caccfeaad68d387207e2c4de758202ca77f0",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -12,6 +12,7 @@\n #endif\n \n #include \"util.h\"\n+#include \"num.h\"\n \n #if defined(USE_FIELD_10X26)\n #include \"field_10x26_impl.h\"\n@@ -48,6 +49,8 @@ static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;\n     int j;\n \n+    VERIFY_CHECK(r != a);\n+\n     /** The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n      *  { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n      *  1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]"
      },
      {
        "sha": "87d296ebf0e2c34c02cc987247a571c8646cd6a1",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -41,7 +41,7 @@ int main(int argc, char **argv) {\n     \n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n-    fprintf(fp, \"#include \\\"group.h\\\"\\n\");\n+    fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n     fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n "
      },
      {
        "sha": "8e122ab429c56365d89f39c6d55d786e2766e7fe",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -65,12 +65,7 @@ static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n-static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb);\n-\n-/** Set a batch of group elements equal to the inputs given in jacobian\n- *  coordinates (with known z-ratios). zr must contain the known z-ratios such\n- *  that mul(a[i].z, zr[i+1]) == a[i+1].z. zr[0] is ignored. */\n-static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len);\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len);\n \n /** Bring a batch inputs given in jacobian coordinates (with known z-ratios) to\n  *  the same global z \"denominator\". zr must contain the known z-ratios such\n@@ -79,6 +74,9 @@ static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej\n  *  stored in globalz. */\n static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp256k1_fe *globalz, const secp256k1_gej *a, const secp256k1_fe *zr);\n \n+/** Set a group element (affine) equal to the point at infinity. */\n+static void secp256k1_ge_set_infinity(secp256k1_ge *r);\n+\n /** Set a group element (jacobian) equal to the point at infinity. */\n static void secp256k1_gej_set_infinity(secp256k1_gej *r);\n "
      },
      {
        "sha": "9b93c39e92f5c7bed9d444087f55af9bd9a293a2",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 40,
        "deletions": 35,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -38,22 +38,22 @@\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 199\n-const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n     0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n     0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n     0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n );\n \n-const int CURVE_B = 4;\n+static const int CURVE_B = 4;\n #  elif EXHAUSTIVE_TEST_ORDER == 13\n-const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n     0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n     0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n     0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n );\n-const int CURVE_B = 2;\n+static const int CURVE_B = 2;\n #  else\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n@@ -68,7 +68,7 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n-const int CURVE_B = 7;\n+static const int CURVE_B = 7;\n #endif\n \n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n@@ -126,46 +126,43 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     r->y = a->y;\n }\n \n-static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb) {\n-    secp256k1_fe *az;\n-    secp256k1_fe *azi;\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len) {\n+    secp256k1_fe u;\n     size_t i;\n-    size_t count = 0;\n-    az = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * len);\n+    size_t last_i = SIZE_MAX;\n+\n     for (i = 0; i < len; i++) {\n         if (!a[i].infinity) {\n-            az[count++] = a[i].z;\n+            /* Use destination's x coordinates as scratch space */\n+            if (last_i == SIZE_MAX) {\n+                r[i].x = a[i].z;\n+            } else {\n+                secp256k1_fe_mul(&r[i].x, &r[last_i].x, &a[i].z);\n+            }\n+            last_i = i;\n         }\n     }\n+    if (last_i == SIZE_MAX) {\n+        return;\n+    }\n+    secp256k1_fe_inv_var(&u, &r[last_i].x);\n \n-    azi = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * count);\n-    secp256k1_fe_inv_all_var(azi, az, count);\n-    free(az);\n-\n-    count = 0;\n-    for (i = 0; i < len; i++) {\n-        r[i].infinity = a[i].infinity;\n+    i = last_i;\n+    while (i > 0) {\n+        i--;\n         if (!a[i].infinity) {\n-            secp256k1_ge_set_gej_zinv(&r[i], &a[i], &azi[count++]);\n+            secp256k1_fe_mul(&r[last_i].x, &r[i].x, &u);\n+            secp256k1_fe_mul(&u, &u, &a[last_i].z);\n+            last_i = i;\n         }\n     }\n-    free(azi);\n-}\n-\n-static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len) {\n-    size_t i = len - 1;\n-    secp256k1_fe zi;\n+    VERIFY_CHECK(!a[last_i].infinity);\n+    r[last_i].x = u;\n \n-    if (len > 0) {\n-        /* Compute the inverse of the last z coordinate, and use it to compute the last affine output. */\n-        secp256k1_fe_inv(&zi, &a[i].z);\n-        secp256k1_ge_set_gej_zinv(&r[i], &a[i], &zi);\n-\n-        /* Work out way backwards, using the z-ratios to scale the x/y values. */\n-        while (i > 0) {\n-            secp256k1_fe_mul(&zi, &zi, &zr[i]);\n-            i--;\n-            secp256k1_ge_set_gej_zinv(&r[i], &a[i], &zi);\n+    for (i = 0; i < len; i++) {\n+        r[i].infinity = a[i].infinity;\n+        if (!a[i].infinity) {\n+            secp256k1_ge_set_gej_zinv(&r[i], &a[i], &r[i].x);\n         }\n     }\n }\n@@ -178,6 +175,8 @@ static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp\n         /* The z of the final point gives us the \"global Z\" for the table. */\n         r[i].x = a[i].x;\n         r[i].y = a[i].y;\n+        /* Ensure all y values are in weak normal form for fast negation of points */\n+        secp256k1_fe_normalize_weak(&r[i].y);\n         *globalz = a[i].z;\n         r[i].infinity = 0;\n         zs = zr[i];\n@@ -200,6 +199,12 @@ static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     secp256k1_fe_clear(&r->z);\n }\n \n+static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n+    r->infinity = 1;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+}\n+\n static void secp256k1_gej_clear(secp256k1_gej *r) {\n     r->infinity = 0;\n     secp256k1_fe_clear(&r->x);"
      },
      {
        "sha": "de26e4b89f8cbb9712d859116606ef11c8e3095d",
        "filename": "src/secp256k1/src/hash.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -14,28 +14,28 @@ typedef struct {\n     uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n-} secp256k1_sha256_t;\n+} secp256k1_sha256;\n \n-static void secp256k1_sha256_initialize(secp256k1_sha256_t *hash);\n-static void secp256k1_sha256_write(secp256k1_sha256_t *hash, const unsigned char *data, size_t size);\n-static void secp256k1_sha256_finalize(secp256k1_sha256_t *hash, unsigned char *out32);\n+static void secp256k1_sha256_initialize(secp256k1_sha256 *hash);\n+static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t size);\n+static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out32);\n \n typedef struct {\n-    secp256k1_sha256_t inner, outer;\n-} secp256k1_hmac_sha256_t;\n+    secp256k1_sha256 inner, outer;\n+} secp256k1_hmac_sha256;\n \n-static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256_t *hash, const unsigned char *key, size_t size);\n-static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256_t *hash, const unsigned char *data, size_t size);\n-static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256_t *hash, unsigned char *out32);\n+static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256 *hash, const unsigned char *key, size_t size);\n+static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256 *hash, const unsigned char *data, size_t size);\n+static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256 *hash, unsigned char *out32);\n \n typedef struct {\n     unsigned char v[32];\n     unsigned char k[32];\n     int retry;\n-} secp256k1_rfc6979_hmac_sha256_t;\n+} secp256k1_rfc6979_hmac_sha256;\n \n-static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256_t *rng, const unsigned char *key, size_t keylen);\n-static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256_t *rng, unsigned char *out, size_t outlen);\n-static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256_t *rng);\n+static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256 *rng, const unsigned char *key, size_t keylen);\n+static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256 *rng, unsigned char *out, size_t outlen);\n+static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256 *rng);\n \n #endif /* SECP256K1_HASH_H */"
      },
      {
        "sha": "009f26beba9398dd55b1342bc0da75670caae85c",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 25,
        "deletions": 24,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -33,7 +33,7 @@\n #define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n #endif\n \n-static void secp256k1_sha256_initialize(secp256k1_sha256_t *hash) {\n+static void secp256k1_sha256_initialize(secp256k1_sha256 *hash) {\n     hash->s[0] = 0x6a09e667ul;\n     hash->s[1] = 0xbb67ae85ul;\n     hash->s[2] = 0x3c6ef372ul;\n@@ -128,14 +128,15 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n     s[7] += h;\n }\n \n-static void secp256k1_sha256_write(secp256k1_sha256_t *hash, const unsigned char *data, size_t len) {\n+static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n     while (bufsize + len >= 64) {\n         /* Fill the buffer, and process it. */\n-        memcpy(((unsigned char*)hash->buf) + bufsize, data, 64 - bufsize);\n-        data += 64 - bufsize;\n-        len -= 64 - bufsize;\n+        size_t chunk_len = 64 - bufsize;\n+        memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);\n+        data += chunk_len;\n+        len -= chunk_len;\n         secp256k1_sha256_transform(hash->s, hash->buf);\n         bufsize = 0;\n     }\n@@ -145,7 +146,7 @@ static void secp256k1_sha256_write(secp256k1_sha256_t *hash, const unsigned char\n     }\n }\n \n-static void secp256k1_sha256_finalize(secp256k1_sha256_t *hash, unsigned char *out32) {\n+static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out32) {\n     static const unsigned char pad[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n     uint32_t sizedesc[2];\n     uint32_t out[8];\n@@ -161,39 +162,39 @@ static void secp256k1_sha256_finalize(secp256k1_sha256_t *hash, unsigned char *o\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n-static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256_t *hash, const unsigned char *key, size_t keylen) {\n-    int n;\n+static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256 *hash, const unsigned char *key, size_t keylen) {\n+    size_t n;\n     unsigned char rkey[64];\n-    if (keylen <= 64) {\n+    if (keylen <= sizeof(rkey)) {\n         memcpy(rkey, key, keylen);\n-        memset(rkey + keylen, 0, 64 - keylen);\n+        memset(rkey + keylen, 0, sizeof(rkey) - keylen);\n     } else {\n-        secp256k1_sha256_t sha256;\n+        secp256k1_sha256 sha256;\n         secp256k1_sha256_initialize(&sha256);\n         secp256k1_sha256_write(&sha256, key, keylen);\n         secp256k1_sha256_finalize(&sha256, rkey);\n         memset(rkey + 32, 0, 32);\n     }\n \n     secp256k1_sha256_initialize(&hash->outer);\n-    for (n = 0; n < 64; n++) {\n+    for (n = 0; n < sizeof(rkey); n++) {\n         rkey[n] ^= 0x5c;\n     }\n-    secp256k1_sha256_write(&hash->outer, rkey, 64);\n+    secp256k1_sha256_write(&hash->outer, rkey, sizeof(rkey));\n \n     secp256k1_sha256_initialize(&hash->inner);\n-    for (n = 0; n < 64; n++) {\n+    for (n = 0; n < sizeof(rkey); n++) {\n         rkey[n] ^= 0x5c ^ 0x36;\n     }\n-    secp256k1_sha256_write(&hash->inner, rkey, 64);\n-    memset(rkey, 0, 64);\n+    secp256k1_sha256_write(&hash->inner, rkey, sizeof(rkey));\n+    memset(rkey, 0, sizeof(rkey));\n }\n \n-static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256_t *hash, const unsigned char *data, size_t size) {\n+static void secp256k1_hmac_sha256_write(secp256k1_hmac_sha256 *hash, const unsigned char *data, size_t size) {\n     secp256k1_sha256_write(&hash->inner, data, size);\n }\n \n-static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256_t *hash, unsigned char *out32) {\n+static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256 *hash, unsigned char *out32) {\n     unsigned char temp[32];\n     secp256k1_sha256_finalize(&hash->inner, temp);\n     secp256k1_sha256_write(&hash->outer, temp, 32);\n@@ -202,8 +203,8 @@ static void secp256k1_hmac_sha256_finalize(secp256k1_hmac_sha256_t *hash, unsign\n }\n \n \n-static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256_t *rng, const unsigned char *key, size_t keylen) {\n-    secp256k1_hmac_sha256_t hmac;\n+static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha256 *rng, const unsigned char *key, size_t keylen) {\n+    secp256k1_hmac_sha256 hmac;\n     static const unsigned char zero[1] = {0x00};\n     static const unsigned char one[1] = {0x01};\n \n@@ -232,11 +233,11 @@ static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha2\n     rng->retry = 0;\n }\n \n-static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256_t *rng, unsigned char *out, size_t outlen) {\n+static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256 *rng, unsigned char *out, size_t outlen) {\n     /* RFC6979 3.2.h. */\n     static const unsigned char zero[1] = {0x00};\n     if (rng->retry) {\n-        secp256k1_hmac_sha256_t hmac;\n+        secp256k1_hmac_sha256 hmac;\n         secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n         secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n         secp256k1_hmac_sha256_write(&hmac, zero, 1);\n@@ -247,7 +248,7 @@ static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256\n     }\n \n     while (outlen > 0) {\n-        secp256k1_hmac_sha256_t hmac;\n+        secp256k1_hmac_sha256 hmac;\n         int now = outlen;\n         secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n         secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n@@ -263,7 +264,7 @@ static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 1;\n }\n \n-static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256_t *rng) {\n+static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256 *rng) {\n     memset(rng->k, 0, 32);\n     memset(rng->v, 0, 32);\n     rng->retry = 0;"
      },
      {
        "sha": "d766a1029ce389a73207431bdf7c0376b1fc6e35",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -52,7 +52,7 @@ public static void testSecKeyVerifyPos() throws AssertFailException{\n     }\n \n     /**\n-      * This tests secret key verify() for a invalid secretkey\n+      * This tests secret key verify() for an invalid secretkey\n       */\n     public static void testSecKeyVerifyNeg() throws AssertFailException{\n         boolean result = false;"
      },
      {
        "sha": "b50970b4f24c8cd3480368aab34a9d83df92fe1b",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -83,7 +83,7 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n \n   secp256k1_ecdsa_signature sig[72];\n \n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n@@ -353,7 +353,9 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n       ctx,\n       nonce_res,\n       &pubkey,\n-      secdata\n+      secdata,\n+      NULL,\n+      NULL\n     );\n   }\n "
      },
      {
        "sha": "44cb68e75025126b21385d953fcfabfcd68d5381",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 27,
        "deletions": 14,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -10,41 +10,54 @@\n #include \"include/secp256k1_ecdh.h\"\n #include \"ecmult_const_impl.h\"\n \n-int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *result, const secp256k1_pubkey *point, const unsigned char *scalar) {\n+static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n+    unsigned char version = (y[31] & 0x01) | 0x02;\n+    secp256k1_sha256 sha;\n+    (void)data;\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &version, 1);\n+    secp256k1_sha256_write(&sha, x, 32);\n+    secp256k1_sha256_finalize(&sha, output);\n+\n+    return 1;\n+}\n+\n+const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256 = ecdh_hash_function_sha256;\n+const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default = ecdh_hash_function_sha256;\n+\n+int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *output, const secp256k1_pubkey *point, const unsigned char *scalar, secp256k1_ecdh_hash_function hashfp, void *data) {\n     int ret = 0;\n     int overflow = 0;\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(result != NULL);\n+    ARG_CHECK(output != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n+    if (hashfp == NULL) {\n+        hashfp = secp256k1_ecdh_hash_function_default;\n+    }\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);\n     if (overflow || secp256k1_scalar_is_zero(&s)) {\n         ret = 0;\n     } else {\n         unsigned char x[32];\n-        unsigned char y[1];\n-        secp256k1_sha256_t sha;\n+        unsigned char y[32];\n \n-        secp256k1_ecmult_const(&res, &pt, &s);\n+        secp256k1_ecmult_const(&res, &pt, &s, 256);\n         secp256k1_ge_set_gej(&pt, &res);\n-        /* Compute a hash of the point in compressed form\n-         * Note we cannot use secp256k1_eckey_pubkey_serialize here since it does not\n-         * expect its output to be secret and has a timing sidechannel. */\n+\n+        /* Compute a hash of the point */\n         secp256k1_fe_normalize(&pt.x);\n         secp256k1_fe_normalize(&pt.y);\n         secp256k1_fe_get_b32(x, &pt.x);\n-        y[0] = 0x02 | secp256k1_fe_is_odd(&pt.y);\n+        secp256k1_fe_get_b32(y, &pt.y);\n \n-        secp256k1_sha256_initialize(&sha);\n-        secp256k1_sha256_write(&sha, y, sizeof(y));\n-        secp256k1_sha256_write(&sha, x, sizeof(x));\n-        secp256k1_sha256_finalize(&sha, result);\n-        ret = 1;\n+        ret = hashfp(output, x, y, data);\n     }\n \n     secp256k1_scalar_clear(&s);"
      },
      {
        "sha": "fe26e8fb6957d59eac2aecebfe736adffdfb1d61",
        "filename": "src/secp256k1/src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 16,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/tests_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -7,6 +7,23 @@\n #ifndef SECP256K1_MODULE_ECDH_TESTS_H\n #define SECP256K1_MODULE_ECDH_TESTS_H\n \n+int ecdh_hash_function_test_fail(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n+    (void)output;\n+    (void)x;\n+    (void)y;\n+    (void)data;\n+    return 0;\n+}\n+\n+int ecdh_hash_function_custom(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n+    (void)data;\n+    /* Save x and y as uncompressed public key */\n+    output[0] = 0x04;\n+    memcpy(output + 1, x, 32);\n+    memcpy(output + 33, y, 32);\n+    return 1;\n+}\n+\n void test_ecdh_api(void) {\n     /* Setup context that just counts errors */\n     secp256k1_context *tctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n@@ -21,15 +38,15 @@ void test_ecdh_api(void) {\n     CHECK(secp256k1_ec_pubkey_create(tctx, &point, s_one) == 1);\n \n     /* Check all NULLs are detected */\n-    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one, NULL, NULL) == 1);\n     CHECK(ecount == 0);\n-    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one) == 0);\n+    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one, NULL, NULL) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one) == 0);\n+    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one, NULL, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ecdh(tctx, res, &point, NULL) == 0);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, NULL, NULL, NULL) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one, NULL, NULL) == 1);\n     CHECK(ecount == 3);\n \n     /* Cleanup */\n@@ -44,29 +61,36 @@ void test_ecdh_generator_basepoint(void) {\n     s_one[31] = 1;\n     /* Check against pubkey creation when the basepoint is the generator */\n     for (i = 0; i < 100; ++i) {\n-        secp256k1_sha256_t sha;\n+        secp256k1_sha256 sha;\n         unsigned char s_b32[32];\n-        unsigned char output_ecdh[32];\n+        unsigned char output_ecdh[65];\n         unsigned char output_ser[32];\n-        unsigned char point_ser[33];\n+        unsigned char point_ser[65];\n         size_t point_ser_len = sizeof(point_ser);\n         secp256k1_scalar s;\n \n         random_scalar_order(&s);\n         secp256k1_scalar_get_b32(s_b32, &s);\n \n-        /* compute using ECDH function */\n         CHECK(secp256k1_ec_pubkey_create(ctx, &point[0], s_one) == 1);\n-        CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32) == 1);\n-        /* compute \"explicitly\" */\n         CHECK(secp256k1_ec_pubkey_create(ctx, &point[1], s_b32) == 1);\n+\n+        /* compute using ECDH function with custom hash function */\n+        CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32, ecdh_hash_function_custom, NULL) == 1);\n+        /* compute \"explicitly\" */\n+        CHECK(secp256k1_ec_pubkey_serialize(ctx, point_ser, &point_ser_len, &point[1], SECP256K1_EC_UNCOMPRESSED) == 1);\n+        /* compare */\n+        CHECK(memcmp(output_ecdh, point_ser, 65) == 0);\n+\n+        /* compute using ECDH function with default hash function */\n+        CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32, NULL, NULL) == 1);\n+        /* compute \"explicitly\" */\n         CHECK(secp256k1_ec_pubkey_serialize(ctx, point_ser, &point_ser_len, &point[1], SECP256K1_EC_COMPRESSED) == 1);\n-        CHECK(point_ser_len == sizeof(point_ser));\n         secp256k1_sha256_initialize(&sha);\n         secp256k1_sha256_write(&sha, point_ser, point_ser_len);\n         secp256k1_sha256_finalize(&sha, output_ser);\n         /* compare */\n-        CHECK(memcmp(output_ecdh, output_ser, sizeof(output_ser)) == 0);\n+        CHECK(memcmp(output_ecdh, output_ser, 32) == 0);\n     }\n }\n \n@@ -89,11 +113,14 @@ void test_bad_scalar(void) {\n     CHECK(secp256k1_ec_pubkey_create(ctx, &point, s_rand) == 1);\n \n     /* Try to multiply it by bad values */\n-    CHECK(secp256k1_ecdh(ctx, output, &point, s_zero) == 0);\n-    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow) == 0);\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_zero, NULL, NULL) == 0);\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow, NULL, NULL) == 0);\n     /* ...and a good one */\n     s_overflow[31] -= 1;\n-    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow) == 1);\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow, NULL, NULL) == 1);\n+\n+    /* Hash function failure results in ecdh failure */\n+    CHECK(secp256k1_ecdh(ctx, output, &point, s_overflow, ecdh_hash_function_test_fail, NULL) == 0);\n }\n \n void run_ecdh_tests(void) {"
      },
      {
        "sha": "d378335d996f32449a1d782352f91d5c60cac3aa",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -376,7 +376,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     /* extract m6 */\n     \"movq %%r8, %q6\\n\"\n     : \"=g\"(m0), \"=g\"(m1), \"=g\"(m2), \"=g\"(m3), \"=g\"(m4), \"=g\"(m5), \"=g\"(m6)\n-    : \"S\"(l), \"n\"(SECP256K1_N_C_0), \"n\"(SECP256K1_N_C_1)\n+    : \"S\"(l), \"i\"(SECP256K1_N_C_0), \"i\"(SECP256K1_N_C_1)\n     : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"cc\");\n \n     /* Reduce 385 bits into 258. */\n@@ -455,7 +455,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     /* extract p4 */\n     \"movq %%r9, %q4\\n\"\n     : \"=&g\"(p0), \"=&g\"(p1), \"=&g\"(p2), \"=g\"(p3), \"=g\"(p4)\n-    : \"g\"(m0), \"g\"(m1), \"g\"(m2), \"g\"(m3), \"g\"(m4), \"g\"(m5), \"g\"(m6), \"n\"(SECP256K1_N_C_0), \"n\"(SECP256K1_N_C_1)\n+    : \"g\"(m0), \"g\"(m1), \"g\"(m2), \"g\"(m3), \"g\"(m4), \"g\"(m5), \"g\"(m6), \"i\"(SECP256K1_N_C_0), \"i\"(SECP256K1_N_C_1)\n     : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"cc\");\n \n     /* Reduce 258 bits into 256. */\n@@ -501,7 +501,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     /* Extract c */\n     \"movq %%r9, %q0\\n\"\n     : \"=g\"(c)\n-    : \"g\"(p0), \"g\"(p1), \"g\"(p2), \"g\"(p3), \"g\"(p4), \"D\"(r), \"n\"(SECP256K1_N_C_0), \"n\"(SECP256K1_N_C_1)\n+    : \"g\"(p0), \"g\"(p1), \"g\"(p2), \"g\"(p3), \"g\"(p4), \"D\"(r), \"i\"(SECP256K1_N_C_0), \"i\"(SECP256K1_N_C_1)\n     : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"cc\", \"memory\");\n #else\n     uint128_t c;"
      },
      {
        "sha": "fef377af0d94203efcbde83e854b1443b1cce8a4",
        "filename": "src/secp256k1/src/scratch.h",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -0,0 +1,39 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+\n+#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n+\n+/* The typedef is used internally; the struct name is used in the public API\n+ * (where it is exposed as a different typedef) */\n+typedef struct secp256k1_scratch_space_struct {\n+    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n+    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n+    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n+    size_t frame;\n+    size_t max_size;\n+    const secp256k1_callback* error_callback;\n+} secp256k1_scratch;\n+\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n+\n+static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+\n+/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n+static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+\n+/** Deallocates a stack frame */\n+static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+\n+/** Returns the maximum allocation the scratch space will allow */\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+\n+/** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n+static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+\n+#endif"
      },
      {
        "sha": "abed713b21d2a8cb6c5c218858309399742ca782",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -0,0 +1,86 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_IMPL_H_\n+#define _SECP256K1_SCRATCH_IMPL_H_\n+\n+#include \"scratch.h\"\n+\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes.\n+ * TODO: Determine this at configure time. */\n+#define ALIGNMENT 16\n+\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n+    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+    if (ret != NULL) {\n+        memset(ret, 0, sizeof(*ret));\n+        ret->max_size = max_size;\n+        ret->error_callback = error_callback;\n+    }\n+    return ret;\n+}\n+\n+static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+    if (scratch != NULL) {\n+        VERIFY_CHECK(scratch->frame == 0);\n+        free(scratch);\n+    }\n+}\n+\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n+    size_t i = 0;\n+    size_t allocated = 0;\n+    for (i = 0; i < scratch->frame; i++) {\n+        allocated += scratch->frame_size[i];\n+    }\n+    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+        return 0;\n+    }\n+    return scratch->max_size - allocated - objects * ALIGNMENT;\n+}\n+\n+static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n+    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n+\n+    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n+        n += objects * ALIGNMENT;\n+        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n+        if (scratch->data[scratch->frame] == NULL) {\n+            return 0;\n+        }\n+        scratch->frame_size[scratch->frame] = n;\n+        scratch->offset[scratch->frame] = 0;\n+        scratch->frame++;\n+        return 1;\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n+    VERIFY_CHECK(scratch->frame > 0);\n+    scratch->frame -= 1;\n+    free(scratch->data[scratch->frame]);\n+}\n+\n+static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+    void *ret;\n+    size_t frame = scratch->frame - 1;\n+    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n+    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+        return NULL;\n+    }\n+    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    memset(ret, 0, size);\n+    scratch->offset[frame] += size;\n+\n+    return ret;\n+}\n+\n+#endif"
      },
      {
        "sha": "15981f46e21af11072a67f94504da842bd7eebd5",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 38,
        "deletions": 13,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -17,6 +17,7 @@\n #include \"ecdsa_impl.h\"\n #include \"eckey_impl.h\"\n #include \"hash_impl.h\"\n+#include \"scratch_impl.h\"\n \n #define ARG_CHECK(cond) do { \\\n     if (EXPECT(!(cond), 0)) { \\\n@@ -55,6 +56,14 @@ struct secp256k1_context_struct {\n     secp256k1_callback error_callback;\n };\n \n+static const secp256k1_context secp256k1_context_no_precomp_ = {\n+    { 0 },\n+    { 0 },\n+    { default_illegal_callback_fn, 0 },\n+    { default_error_callback_fn, 0 }\n+};\n+const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n+\n secp256k1_context* secp256k1_context_create(unsigned int flags) {\n     secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n     ret->illegal_callback = default_illegal_callback;\n@@ -90,6 +99,7 @@ secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n }\n \n void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    CHECK(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n@@ -99,6 +109,7 @@ void secp256k1_context_destroy(secp256k1_context* ctx) {\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n+    CHECK(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n         fun = default_illegal_callback_fn;\n     }\n@@ -107,20 +118,30 @@ void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n+    CHECK(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n         fun = default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n }\n \n+secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context* ctx, size_t max_size) {\n+    VERIFY_CHECK(ctx != NULL);\n+    return secp256k1_scratch_create(&ctx->error_callback, max_size);\n+}\n+\n+void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n+    secp256k1_scratch_destroy(scratch);\n+}\n+\n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n     if (sizeof(secp256k1_ge_storage) == 64) {\n         /* When the secp256k1_ge_storage type is exactly 64 byte, use its\n          * representation inside secp256k1_pubkey, as conversion is very fast.\n          * Note that secp256k1_pubkey_save must use the same representation. */\n         secp256k1_ge_storage s;\n-        memcpy(&s, &pubkey->data[0], 64);\n+        memcpy(&s, &pubkey->data[0], sizeof(s));\n         secp256k1_ge_from_storage(ge, &s);\n     } else {\n         /* Otherwise, fall back to 32-byte big endian for X and Y. */\n@@ -137,7 +158,7 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n     if (sizeof(secp256k1_ge_storage) == 64) {\n         secp256k1_ge_storage s;\n         secp256k1_ge_to_storage(&s, ge);\n-        memcpy(&pubkey->data[0], &s, 64);\n+        memcpy(&pubkey->data[0], &s, sizeof(s));\n     } else {\n         VERIFY_CHECK(!secp256k1_ge_is_infinity(ge));\n         secp256k1_fe_normalize_var(&ge->x);\n@@ -307,10 +328,15 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n             secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &r, &s, &q, &m));\n }\n \n+static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len) {\n+    memcpy(buf + *offset, data, len);\n+    *offset += len;\n+}\n+\n static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n    unsigned char keydata[112];\n-   int keylen = 64;\n-   secp256k1_rfc6979_hmac_sha256_t rng;\n+   unsigned int offset = 0;\n+   secp256k1_rfc6979_hmac_sha256 rng;\n    unsigned int i;\n    /* We feed a byte array to the PRNG as input, consisting of:\n     * - the private key (32 bytes) and message (32 bytes), see RFC 6979 3.2d.\n@@ -320,17 +346,15 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n     *  different argument mixtures to emulate each other and result in the same\n     *  nonces.\n     */\n-   memcpy(keydata, key32, 32);\n-   memcpy(keydata + 32, msg32, 32);\n+   buffer_append(keydata, &offset, key32, 32);\n+   buffer_append(keydata, &offset, msg32, 32);\n    if (data != NULL) {\n-       memcpy(keydata + 64, data, 32);\n-       keylen = 96;\n+       buffer_append(keydata, &offset, data, 32);\n    }\n    if (algo16 != NULL) {\n-       memcpy(keydata + keylen, algo16, 16);\n-       keylen += 16;\n+       buffer_append(keydata, &offset, algo16, 16);\n    }\n-   secp256k1_rfc6979_hmac_sha256_initialize(&rng, keydata, keylen);\n+   secp256k1_rfc6979_hmac_sha256_initialize(&rng, keydata, offset);\n    memset(keydata, 0, sizeof(keydata));\n    for (i = 0; i <= counter; i++) {\n        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n@@ -546,8 +570,9 @@ int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey\n \n int secp256k1_context_randomize(secp256k1_context* ctx, const unsigned char *seed32) {\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    }\n     return 1;\n }\n "
      },
      {
        "sha": "30a91e5296137c5458cfc12e2ed92f5fde51704e",
        "filename": "src/secp256k1/src/testrand_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand_impl.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -13,7 +13,7 @@\n #include \"testrand.h\"\n #include \"hash.h\"\n \n-static secp256k1_rfc6979_hmac_sha256_t secp256k1_test_rng;\n+static secp256k1_rfc6979_hmac_sha256 secp256k1_test_rng;\n static uint32_t secp256k1_test_rng_precomputed[8];\n static int secp256k1_test_rng_precomputed_used = 8;\n static uint64_t secp256k1_test_rng_integer;"
      },
      {
        "sha": "f1c4db929a776a182ad52ac4ada84100af6e701b",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 641,
        "deletions": 27,
        "changes": 668,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -23,6 +23,9 @@\n #include \"openssl/ec.h\"\n #include \"openssl/ecdsa.h\"\n #include \"openssl/obj_mac.h\"\n+# if OPENSSL_VERSION_NUMBER < 0x10100000L\n+void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {*pr = sig->r; *ps = sig->s;}\n+# endif\n #endif\n \n #include \"contrib/lax_der_parsing.c\"\n@@ -215,8 +218,12 @@ void run_context_tests(void) {\n     CHECK(ecount == 3);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(vrfy, NULL) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(sign, ctmp) == 1);\n+    CHECK(ecount2 == 14);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n     CHECK(ecount2 == 14);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n@@ -248,6 +255,44 @@ void run_context_tests(void) {\n     secp256k1_context_destroy(NULL);\n }\n \n+void run_scratch_tests(void) {\n+    int32_t ecount = 0;\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_scratch_space *scratch;\n+\n+    /* Test public API */\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+\n+    scratch = secp256k1_scratch_space_create(none, 1000);\n+    CHECK(scratch != NULL);\n+    CHECK(ecount == 0);\n+\n+    /* Test internal API */\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n+\n+    /* Allocating 500 bytes with no frame fails */\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n+\n+    /* ...but pushing a new stack frame does affect the max allocation */\n+    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+\n+    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+\n+    /* ...and this effect is undone by popping the frame */\n+    secp256k1_scratch_deallocate_frame(scratch);\n+    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+\n+    /* cleanup */\n+    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_context_destroy(none);\n+}\n+\n /***** HASH TESTS *****/\n \n void run_sha256_tests(void) {\n@@ -270,7 +315,7 @@ void run_sha256_tests(void) {\n     int i;\n     for (i = 0; i < 8; i++) {\n         unsigned char out[32];\n-        secp256k1_sha256_t hasher;\n+        secp256k1_sha256 hasher;\n         secp256k1_sha256_initialize(&hasher);\n         secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n         secp256k1_sha256_finalize(&hasher, out);\n@@ -313,7 +358,7 @@ void run_hmac_sha256_tests(void) {\n     };\n     int i;\n     for (i = 0; i < 6; i++) {\n-        secp256k1_hmac_sha256_t hasher;\n+        secp256k1_hmac_sha256 hasher;\n         unsigned char out[32];\n         secp256k1_hmac_sha256_initialize(&hasher, (const unsigned char*)(keys[i]), strlen(keys[i]));\n         secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n@@ -345,7 +390,7 @@ void run_rfc6979_hmac_sha256_tests(void) {\n         {0x75, 0x97, 0x88, 0x7c, 0xbd, 0x76, 0x32, 0x1f, 0x32, 0xe3, 0x04, 0x40, 0x67, 0x9a, 0x22, 0xcf, 0x7f, 0x8d, 0x9d, 0x2e, 0xac, 0x39, 0x0e, 0x58, 0x1f, 0xea, 0x09, 0x1c, 0xe2, 0x02, 0xba, 0x94}\n     };\n \n-    secp256k1_rfc6979_hmac_sha256_t rng;\n+    secp256k1_rfc6979_hmac_sha256 rng;\n     unsigned char out[32];\n     int i;\n \n@@ -2054,28 +2099,40 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with and without known z ratios. */\n     {\n         secp256k1_fe *zr = (secp256k1_fe *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_fe));\n-        secp256k1_ge *ge_set_table = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         secp256k1_ge *ge_set_all = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             /* Compute gej[i + 1].z / gez[i].z (with gej[n].z taken to be 1). */\n             if (i < 4 * runs) {\n                 secp256k1_fe_mul(&zr[i + 1], &zinv[i], &gej[i + 1].z);\n             }\n         }\n-        secp256k1_ge_set_table_gej_var(ge_set_table, gej, zr, 4 * runs + 1);\n-        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1, &ctx->error_callback);\n+        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1);\n         for (i = 0; i < 4 * runs + 1; i++) {\n             secp256k1_fe s;\n             random_fe_non_zero(&s);\n             secp256k1_gej_rescale(&gej[i], &s);\n-            ge_equals_gej(&ge_set_table[i], &gej[i]);\n             ge_equals_gej(&ge_set_all[i], &gej[i]);\n         }\n-        free(ge_set_table);\n         free(ge_set_all);\n         free(zr);\n     }\n \n+    /* Test batch gej -> ge conversion with many infinities. */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        random_group_element_test(&ge[i]);\n+        /* randomly set half the points to infinitiy */\n+        if(secp256k1_fe_is_odd(&ge[i].x)) {\n+            secp256k1_ge_set_infinity(&ge[i]);\n+        }\n+        secp256k1_gej_set_ge(&gej[i], &ge[i]);\n+    }\n+    /* batch invert */\n+    secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n+    /* check result */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        ge_equals_gej(&ge[i], &gej[i]);\n+    }\n+\n     free(ge);\n     free(gej);\n     free(zinv);\n@@ -2405,7 +2462,7 @@ void ecmult_const_random_mult(void) {\n         0xb84e4e1b, 0xfb77e21f, 0x96baae2a, 0x63dec956\n     );\n     secp256k1_gej b;\n-    secp256k1_ecmult_const(&b, &a, &xn);\n+    secp256k1_ecmult_const(&b, &a, &xn, 256);\n \n     CHECK(secp256k1_ge_is_valid_var(&a));\n     ge_equals_gej(&expected_b, &b);\n@@ -2421,12 +2478,12 @@ void ecmult_const_commutativity(void) {\n     random_scalar_order_test(&a);\n     random_scalar_order_test(&b);\n \n-    secp256k1_ecmult_const(&res1, &secp256k1_ge_const_g, &a);\n-    secp256k1_ecmult_const(&res2, &secp256k1_ge_const_g, &b);\n+    secp256k1_ecmult_const(&res1, &secp256k1_ge_const_g, &a, 256);\n+    secp256k1_ecmult_const(&res2, &secp256k1_ge_const_g, &b, 256);\n     secp256k1_ge_set_gej(&mid1, &res1);\n     secp256k1_ge_set_gej(&mid2, &res2);\n-    secp256k1_ecmult_const(&res1, &mid1, &b);\n-    secp256k1_ecmult_const(&res2, &mid2, &a);\n+    secp256k1_ecmult_const(&res1, &mid1, &b, 256);\n+    secp256k1_ecmult_const(&res2, &mid2, &a, 256);\n     secp256k1_ge_set_gej(&mid1, &res1);\n     secp256k1_ge_set_gej(&mid2, &res2);\n     ge_equals_ge(&mid1, &mid2);\n@@ -2442,13 +2499,13 @@ void ecmult_const_mult_zero_one(void) {\n     secp256k1_scalar_negate(&negone, &one);\n \n     random_group_element_test(&point);\n-    secp256k1_ecmult_const(&res1, &point, &zero);\n+    secp256k1_ecmult_const(&res1, &point, &zero, 3);\n     secp256k1_ge_set_gej(&res2, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res2));\n-    secp256k1_ecmult_const(&res1, &point, &one);\n+    secp256k1_ecmult_const(&res1, &point, &one, 2);\n     secp256k1_ge_set_gej(&res2, &res1);\n     ge_equals_ge(&res2, &point);\n-    secp256k1_ecmult_const(&res1, &point, &negone);\n+    secp256k1_ecmult_const(&res1, &point, &negone, 256);\n     secp256k1_gej_neg(&res1, &res1);\n     secp256k1_ge_set_gej(&res2, &res1);\n     ge_equals_ge(&res2, &point);\n@@ -2474,7 +2531,7 @@ void ecmult_const_chain_multiply(void) {\n     for (i = 0; i < 100; ++i) {\n         secp256k1_ge tmp;\n         secp256k1_ge_set_gej(&tmp, &point);\n-        secp256k1_ecmult_const(&point, &tmp, &scalar);\n+        secp256k1_ecmult_const(&point, &tmp, &scalar, 256);\n     }\n     secp256k1_ge_set_gej(&res, &point);\n     ge_equals_gej(&res, &expected_point);\n@@ -2487,6 +2544,446 @@ void run_ecmult_const_tests(void) {\n     ecmult_const_chain_multiply();\n }\n \n+typedef struct {\n+    secp256k1_scalar *sc;\n+    secp256k1_ge *pt;\n+} ecmult_multi_data;\n+\n+static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    ecmult_multi_data *data = (ecmult_multi_data*) cbdata;\n+    *sc = data->sc[idx];\n+    *pt = data->pt[idx];\n+    return 1;\n+}\n+\n+static int ecmult_multi_false_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    (void)sc;\n+    (void)pt;\n+    (void)idx;\n+    (void)cbdata;\n+    return 0;\n+}\n+\n+void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func ecmult_multi) {\n+    int ncount;\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    secp256k1_gej r2;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* No points to multiply */\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+\n+    /* Check 1- and 2-point multiplies against ecmult */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+        random_scalar_order(&sc[0]);\n+        random_scalar_order(&sc[1]);\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+        pt[0] = ptg;\n+        pt[1] = secp256k1_ge_const_g;\n+\n+        /* only G scalar */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* 1-point */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* Try to multiply 1 point, but scratch space is empty */\n+        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_scratch_destroy(scratch_empty);\n+\n+        /* Try to multiply 1 point, but callback returns false */\n+        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+\n+        /* 2-point */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* 2-point with G scalar */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check infinite outputs of various forms */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        secp256k1_ge ptg;\n+        size_t i, j;\n+        size_t sizes[] = { 2, 10, 32 };\n+\n+        for (j = 0; j < 3; j++) {\n+            for (i = 0; i < 32; i++) {\n+                random_scalar_order(&sc[i]);\n+                secp256k1_ge_set_infinity(&pt[i]);\n+            }\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        for (j = 0; j < 3; j++) {\n+            for (i = 0; i < 32; i++) {\n+                random_group_element_test(&ptg);\n+                pt[i] = ptg;\n+                secp256k1_scalar_set_int(&sc[i], 0);\n+            }\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        for (j = 0; j < 3; j++) {\n+            random_group_element_test(&ptg);\n+            for (i = 0; i < 16; i++) {\n+                random_scalar_order(&sc[2*i]);\n+                secp256k1_scalar_negate(&sc[2*i + 1], &sc[2*i]);\n+                pt[2 * i] = ptg;\n+                pt[2 * i + 1] = ptg;\n+            }\n+\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+\n+            random_scalar_order(&sc[0]);\n+            for (i = 0; i < 16; i++) {\n+                random_group_element_test(&ptg);\n+\n+                sc[2*i] = sc[0];\n+                sc[2*i+1] = sc[0];\n+                pt[2 * i] = ptg;\n+                secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n+            }\n+\n+            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_scalar_set_int(&sc[0], 0);\n+        pt[0] = ptg;\n+        for (i = 1; i < 32; i++) {\n+            pt[i] = ptg;\n+\n+            random_scalar_order(&sc[i]);\n+            secp256k1_scalar_add(&sc[0], &sc[0], &sc[i]);\n+            secp256k1_scalar_negate(&sc[i], &sc[i]);\n+        }\n+\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check random points, constant scalar */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        size_t i;\n+        secp256k1_gej_set_infinity(&r);\n+\n+        random_scalar_order(&sc[0]);\n+        for (i = 0; i < 20; i++) {\n+            secp256k1_ge ptg;\n+            sc[i] = sc[0];\n+            random_group_element_test(&ptg);\n+            pt[i] = ptg;\n+            secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n+        }\n+\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check random scalars, constant point */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        size_t i;\n+        secp256k1_ge ptg;\n+        secp256k1_gej p0j;\n+        secp256k1_scalar rs;\n+        secp256k1_scalar_set_int(&rs, 0);\n+\n+        random_group_element_test(&ptg);\n+        for (i = 0; i < 20; i++) {\n+            random_scalar_order(&sc[i]);\n+            pt[i] = ptg;\n+            secp256k1_scalar_add(&rs, &rs, &sc[i]);\n+        }\n+\n+        secp256k1_gej_set_ge(&p0j, &pt[0]);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n+        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Sanity check that zero scalars don't cause problems */\n+    for (ncount = 0; ncount < 20; ncount++) {\n+        random_scalar_order(&sc[ncount]);\n+        random_group_element_test(&pt[ncount]);\n+    }\n+\n+    secp256k1_scalar_clear(&sc[0]);\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    secp256k1_scalar_clear(&sc[1]);\n+    secp256k1_scalar_clear(&sc[2]);\n+    secp256k1_scalar_clear(&sc[3]);\n+    secp256k1_scalar_clear(&sc[4]);\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+\n+    /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n+    {\n+        const size_t TOP = 8;\n+        size_t s0i, s1i;\n+        size_t t0i, t1i;\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+\n+        for(t0i = 0; t0i < TOP; t0i++) {\n+            for(t1i = 0; t1i < TOP; t1i++) {\n+                secp256k1_gej t0p, t1p;\n+                secp256k1_scalar t0, t1;\n+\n+                secp256k1_scalar_set_int(&t0, (t0i + 1) / 2);\n+                secp256k1_scalar_cond_negate(&t0, t0i & 1);\n+                secp256k1_scalar_set_int(&t1, (t1i + 1) / 2);\n+                secp256k1_scalar_cond_negate(&t1, t1i & 1);\n+\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &t0p, &ptgj, &t0, &szero);\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &t1p, &ptgj, &t1, &szero);\n+\n+                for(s0i = 0; s0i < TOP; s0i++) {\n+                    for(s1i = 0; s1i < TOP; s1i++) {\n+                        secp256k1_scalar tmp1, tmp2;\n+                        secp256k1_gej expected, actual;\n+\n+                        secp256k1_ge_set_gej(&pt[0], &t0p);\n+                        secp256k1_ge_set_gej(&pt[1], &t1p);\n+\n+                        secp256k1_scalar_set_int(&sc[0], (s0i + 1) / 2);\n+                        secp256k1_scalar_cond_negate(&sc[0], s0i & 1);\n+                        secp256k1_scalar_set_int(&sc[1], (s1i + 1) / 2);\n+                        secp256k1_scalar_cond_negate(&sc[1], s1i & 1);\n+\n+                        secp256k1_scalar_mul(&tmp1, &t0, &sc[0]);\n+                        secp256k1_scalar_mul(&tmp2, &t1, &sc[1]);\n+                        secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n+\n+                        secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n+                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        secp256k1_gej_neg(&expected, &expected);\n+                        secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n+                        CHECK(secp256k1_gej_is_infinity(&actual));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_secp256k1_pippenger_bucket_window_inv(void) {\n+    int i;\n+\n+    CHECK(secp256k1_pippenger_bucket_window_inv(0) == 0);\n+    for(i = 1; i <= PIPPENGER_MAX_BUCKET_WINDOW; i++) {\n+#ifdef USE_ENDOMORPHISM\n+        /* Bucket_window of 8 is not used with endo */\n+        if (i == 8) {\n+            continue;\n+        }\n+#endif\n+        CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)) == i);\n+        if (i != PIPPENGER_MAX_BUCKET_WINDOW) {\n+            CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)+1) > i);\n+        }\n+    }\n+}\n+\n+/**\n+ * Probabilistically test the function returning the maximum number of possible points\n+ * for a given scratch space.\n+ */\n+void test_ecmult_multi_pippenger_max_points(void) {\n+    size_t scratch_size = secp256k1_rand_int(256);\n+    size_t max_size = secp256k1_pippenger_scratch_size(secp256k1_pippenger_bucket_window_inv(PIPPENGER_MAX_BUCKET_WINDOW-1)+512, 12);\n+    secp256k1_scratch *scratch;\n+    size_t n_points_supported;\n+    int bucket_window = 0;\n+\n+    for(; scratch_size < max_size; scratch_size+=256) {\n+        scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n+        CHECK(scratch != NULL);\n+        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        if (n_points_supported == 0) {\n+            secp256k1_scratch_destroy(scratch);\n+            continue;\n+        }\n+        bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n+        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n+        secp256k1_scratch_deallocate_frame(scratch);\n+        secp256k1_scratch_destroy(scratch);\n+    }\n+    CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n+}\n+\n+void test_ecmult_multi_batch_size_helper(void) {\n+    size_t n_batches, n_batch_points, max_n_batch_points, n;\n+\n+    max_n_batch_points = 0;\n+    n = 1;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 0);\n+\n+    max_n_batch_points = 1;\n+    n = 0;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 0);\n+    CHECK(n_batch_points == 0);\n+\n+    max_n_batch_points = 2;\n+    n = 5;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 3);\n+    CHECK(n_batch_points == 2);\n+\n+    max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    n = ECMULT_MAX_POINTS_PER_BATCH;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 1);\n+    CHECK(n_batch_points == ECMULT_MAX_POINTS_PER_BATCH);\n+\n+    max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH + 1;\n+    n = ECMULT_MAX_POINTS_PER_BATCH + 1;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == 2);\n+    CHECK(n_batch_points == ECMULT_MAX_POINTS_PER_BATCH/2 + 1);\n+\n+    max_n_batch_points = 1;\n+    n = SIZE_MAX;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == SIZE_MAX);\n+    CHECK(n_batch_points == 1);\n+\n+    max_n_batch_points = 2;\n+    n = SIZE_MAX;\n+    CHECK(secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, max_n_batch_points, n) == 1);\n+    CHECK(n_batches == SIZE_MAX/2 + 1);\n+    CHECK(n_batch_points == 2);\n+}\n+\n+/**\n+ * Run secp256k1_ecmult_multi_var with num points and a scratch space restricted to\n+ * 1 <= i <= num points.\n+ */\n+void test_ecmult_multi_batching(void) {\n+    static const int n_points = 2*ECMULT_PIPPENGER_THRESHOLD;\n+    secp256k1_scalar scG;\n+    secp256k1_scalar szero;\n+    secp256k1_scalar *sc = (secp256k1_scalar *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_scalar) * n_points);\n+    secp256k1_ge *pt = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * n_points);\n+    secp256k1_gej r;\n+    secp256k1_gej r2;\n+    ecmult_multi_data data;\n+    int i;\n+    secp256k1_scratch *scratch;\n+\n+    secp256k1_gej_set_infinity(&r2);\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Get random scalars and group elements and compute result */\n+    random_scalar_order(&scG);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r2, &szero, &scG);\n+    for(i = 0; i < n_points; i++) {\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+        pt[i] = ptg;\n+        random_scalar_order(&sc[i]);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &ptgj, &ptgj, &sc[i], NULL);\n+        secp256k1_gej_add_var(&r2, &r2, &ptgj, NULL);\n+    }\n+    data.sc = sc;\n+    data.pt = pt;\n+\n+    /* Test with empty scratch space */\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(scratch);\n+\n+    /* Test with space for 1 point in pippenger. That's not enough because\n+     * ecmult_multi selects strauss which requires more memory. */\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n+    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(scratch);\n+\n+    secp256k1_gej_neg(&r2, &r2);\n+    for(i = 1; i <= n_points; i++) {\n+        if (i > ECMULT_PIPPENGER_THRESHOLD) {\n+            int bucket_window = secp256k1_pippenger_bucket_window(i);\n+            size_t scratch_size = secp256k1_pippenger_scratch_size(i, bucket_window);\n+            scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n+        } else {\n+            size_t scratch_size = secp256k1_strauss_scratch_size(i);\n+            scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n+        }\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+        secp256k1_scratch_destroy(scratch);\n+    }\n+    free(sc);\n+    free(pt);\n+}\n+\n+void run_ecmult_multi_tests(void) {\n+    secp256k1_scratch *scratch;\n+\n+    test_secp256k1_pippenger_bucket_window_inv();\n+    test_ecmult_multi_pippenger_max_points();\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, 819200);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n+    test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(scratch);\n+\n+    /* Run test_ecmult_multi with space for exactly one point */\n+    scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n+    test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n+    secp256k1_scratch_destroy(scratch);\n+\n+    test_ecmult_multi_batch_size_helper();\n+    test_ecmult_multi_batching();\n+}\n+\n void test_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, two, t;\n     int wnaf[256];\n@@ -2541,6 +3038,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     int wnaf[256] = {0};\n     int i;\n     int skew;\n+    int bits = 256;\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2550,10 +3048,11 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n+    bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n+    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n \n-    for (i = WNAF_SIZE(w); i >= 0; --i) {\n+    for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n         int v = wnaf[i];\n         CHECK(v != 0); /* check nonzero */\n@@ -2575,6 +3074,110 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n+void test_fixed_wnaf(const secp256k1_scalar *number, int w) {\n+    secp256k1_scalar x, shift;\n+    int wnaf[256] = {0};\n+    int i;\n+    int skew;\n+    secp256k1_scalar num = *number;\n+\n+    secp256k1_scalar_set_int(&x, 0);\n+    secp256k1_scalar_set_int(&shift, 1 << w);\n+    /* With USE_ENDOMORPHISM on we only consider 128-bit numbers */\n+#ifdef USE_ENDOMORPHISM\n+    for (i = 0; i < 16; ++i) {\n+        secp256k1_scalar_shr_int(&num, 8);\n+    }\n+#endif\n+    skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+\n+    for (i = WNAF_SIZE(w)-1; i >= 0; --i) {\n+        secp256k1_scalar t;\n+        int v = wnaf[i];\n+        CHECK(v == 0 || v & 1);  /* check parity */\n+        CHECK(v > -(1 << w)); /* check range above */\n+        CHECK(v < (1 << w));  /* check range below */\n+\n+        secp256k1_scalar_mul(&x, &x, &shift);\n+        if (v >= 0) {\n+            secp256k1_scalar_set_int(&t, v);\n+        } else {\n+            secp256k1_scalar_set_int(&t, -v);\n+            secp256k1_scalar_negate(&t, &t);\n+        }\n+        secp256k1_scalar_add(&x, &x, &t);\n+    }\n+    /* If skew is 1 then add 1 to num */\n+    secp256k1_scalar_cadd_bit(&num, 0, skew == 1);\n+    CHECK(secp256k1_scalar_eq(&x, &num));\n+}\n+\n+/* Checks that the first 8 elements of wnaf are equal to wnaf_expected and the\n+ * rest is 0.*/\n+void test_fixed_wnaf_small_helper(int *wnaf, int *wnaf_expected, int w) {\n+    int i;\n+    for (i = WNAF_SIZE(w)-1; i >= 8; --i) {\n+        CHECK(wnaf[i] == 0);\n+    }\n+    for (i = 7; i >= 0; --i) {\n+        CHECK(wnaf[i] == wnaf_expected[i]);\n+    }\n+}\n+\n+void test_fixed_wnaf_small(void) {\n+    int w = 4;\n+    int wnaf[256] = {0};\n+    int i;\n+    int skew;\n+    secp256k1_scalar num;\n+\n+    secp256k1_scalar_set_int(&num, 0);\n+    skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+    for (i = WNAF_SIZE(w)-1; i >= 0; --i) {\n+        int v = wnaf[i];\n+        CHECK(v == 0);\n+    }\n+    CHECK(skew == 0);\n+\n+    secp256k1_scalar_set_int(&num, 1);\n+    skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+    for (i = WNAF_SIZE(w)-1; i >= 1; --i) {\n+        int v = wnaf[i];\n+        CHECK(v == 0);\n+    }\n+    CHECK(wnaf[0] == 1);\n+    CHECK(skew == 0);\n+\n+    {\n+        int wnaf_expected[8] = { 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf };\n+        secp256k1_scalar_set_int(&num, 0xffffffff);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 0);\n+    }\n+    {\n+        int wnaf_expected[8] = { -1, -1, -1, -1, -1, -1, -1, 0xf };\n+        secp256k1_scalar_set_int(&num, 0xeeeeeeee);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 1);\n+    }\n+    {\n+        int wnaf_expected[8] = { 1, 0, 1, 0, 1, 0, 1, 0 };\n+        secp256k1_scalar_set_int(&num, 0x01010101);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 0);\n+    }\n+    {\n+        int wnaf_expected[8] = { -0xf, 0, 0xf, -0xf, 0, 0xf, 1, 0 };\n+        secp256k1_scalar_set_int(&num, 0x01ef1ef1);\n+        skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n+        test_fixed_wnaf_small_helper(wnaf, wnaf_expected, w);\n+        CHECK(skew == 0);\n+    }\n+}\n+\n void run_wnaf(void) {\n     int i;\n     secp256k1_scalar n = {{0}};\n@@ -2585,12 +3188,15 @@ void run_wnaf(void) {\n     test_constant_wnaf(&n, 4);\n     n.d[0] = 2;\n     test_constant_wnaf(&n, 4);\n+    /* Test 0 */\n+    test_fixed_wnaf_small();\n     /* Random tests */\n     for (i = 0; i < count; i++) {\n         random_scalar_order(&n);\n         test_wnaf(&n, 4+(i%10));\n         test_constant_wnaf_negate(&n);\n         test_constant_wnaf(&n, 4 + (i % 10));\n+        test_fixed_wnaf(&n, 4 + (i % 10));\n     }\n     secp256k1_scalar_set_int(&n, 0);\n     CHECK(secp256k1_scalar_cond_negate(&n, 1) == -1);\n@@ -3055,6 +3661,7 @@ void run_ec_pubkey_parse_test(void) {\n     ecount = 0;\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, 65) == 1);\n+    CHECK(secp256k1_ec_pubkey_parse(secp256k1_context_no_precomp, &pubkey, pubkeyc, 65) == 1);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n     CHECK(ecount == 0);\n     VG_UNDEF(&ge, sizeof(ge));\n@@ -3177,7 +3784,7 @@ void run_eckey_edge_case_test(void) {\n     VG_CHECK(&pubkey, sizeof(pubkey));\n     CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     pubkey_negone = pubkey;\n-    /* Tweak of zero leaves the value changed. */\n+    /* Tweak of zero leaves the value unchanged. */\n     memset(ctmp2, 0, 32);\n     CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, ctmp2) == 1);\n     CHECK(memcmp(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n@@ -3668,6 +4275,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n \n #ifdef ENABLE_OPENSSL_TESTS\n     ECDSA_SIG *sig_openssl;\n+    const BIGNUM *r = NULL, *s = NULL;\n     const unsigned char *sigptr;\n     unsigned char roundtrip_openssl[2048];\n     int len_openssl = 2048;\n@@ -3719,15 +4327,16 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     sigptr = sig;\n     parsed_openssl = (d2i_ECDSA_SIG(&sig_openssl, &sigptr, siglen) != NULL);\n     if (parsed_openssl) {\n-        valid_openssl = !BN_is_negative(sig_openssl->r) && !BN_is_negative(sig_openssl->s) && BN_num_bits(sig_openssl->r) > 0 && BN_num_bits(sig_openssl->r) <= 256 && BN_num_bits(sig_openssl->s) > 0 && BN_num_bits(sig_openssl->s) <= 256;\n+        ECDSA_SIG_get0(sig_openssl, &r, &s);\n+        valid_openssl = !BN_is_negative(r) && !BN_is_negative(s) && BN_num_bits(r) > 0 && BN_num_bits(r) <= 256 && BN_num_bits(s) > 0 && BN_num_bits(s) <= 256;\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n-            BN_bn2bin(sig_openssl->r, tmp + 32 - BN_num_bytes(sig_openssl->r));\n+            BN_bn2bin(r, tmp + 32 - BN_num_bytes(r));\n             valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n         }\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n-            BN_bn2bin(sig_openssl->s, tmp + 32 - BN_num_bytes(sig_openssl->s));\n+            BN_bn2bin(s, tmp + 32 - BN_num_bytes(s));\n             valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n         }\n     }\n@@ -4431,8 +5040,9 @@ int main(int argc, char **argv) {\n         }\n     } else {\n         FILE *frand = fopen(\"/dev/urandom\", \"r\");\n-        if ((frand == NULL) || !fread(&seed16, sizeof(seed16), 1, frand)) {\n+        if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n             uint64_t t = time(NULL) * (uint64_t)1337;\n+            fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");\n             seed16[0] ^= t;\n             seed16[1] ^= t >> 8;\n             seed16[2] ^= t >> 16;\n@@ -4442,7 +5052,9 @@ int main(int argc, char **argv) {\n             seed16[6] ^= t >> 48;\n             seed16[7] ^= t >> 56;\n         }\n-        fclose(frand);\n+        if (frand) {\n+            fclose(frand);\n+        }\n     }\n     secp256k1_rand_seed(seed16);\n \n@@ -4451,6 +5063,7 @@ int main(int argc, char **argv) {\n \n     /* initialize */\n     run_context_tests();\n+    run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {\n         secp256k1_rand256(run32);\n@@ -4492,6 +5105,7 @@ int main(int argc, char **argv) {\n     run_ecmult_constants();\n     run_ecmult_gen_blind();\n     run_ecmult_const_tests();\n+    run_ecmult_multi_tests();\n     run_ec_combine();\n \n     /* endomorphism tests */"
      },
      {
        "sha": "ab9779b02fc544b52ea82ce58778405574dd26b6",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 42,
        "deletions": 1,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -174,14 +174,54 @@ void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *gr\n                 ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n \n                 if (i > 0) {\n-                    secp256k1_ecmult_const(&tmp, &group[i], &ng);\n+                    secp256k1_ecmult_const(&tmp, &group[i], &ng, 256);\n                     ge_equals_gej(&group[(i * j) % order], &tmp);\n                 }\n             }\n         }\n     }\n }\n \n+typedef struct {\n+    secp256k1_scalar sc[2];\n+    secp256k1_ge pt[2];\n+} ecmult_multi_data;\n+\n+static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    ecmult_multi_data *data = (ecmult_multi_data*) cbdata;\n+    *sc = data->sc[idx];\n+    *pt = data->pt[idx];\n+    return 1;\n+}\n+\n+void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k, x, y;\n+    secp256k1_scratch *scratch = secp256k1_scratch_create(&ctx->error_callback, 4096);\n+    for (i = 0; i < order; i++) {\n+        for (j = 0; j < order; j++) {\n+            for (k = 0; k < order; k++) {\n+                for (x = 0; x < order; x++) {\n+                    for (y = 0; y < order; y++) {\n+                        secp256k1_gej tmp;\n+                        secp256k1_scalar g_sc;\n+                        ecmult_multi_data data;\n+\n+                        secp256k1_scalar_set_int(&data.sc[0], i);\n+                        secp256k1_scalar_set_int(&data.sc[1], j);\n+                        secp256k1_scalar_set_int(&g_sc, k);\n+                        data.pt[0] = group[x];\n+                        data.pt[1] = group[y];\n+\n+                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    secp256k1_scratch_destroy(scratch);\n+}\n+\n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n     secp256k1_fe x;\n     unsigned char x_bin[32];\n@@ -456,6 +496,7 @@ int main(void) {\n #endif\n     test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_ecmult_multi(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n "
      },
      {
        "sha": "e1f5b764527d9a70febb0f2a6f94c5dfc6f3d7a2",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99df276dae91de034f67d4bfc215b8101f5dac7b/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=99df276dae91de034f67d4bfc215b8101f5dac7b",
        "patch": "@@ -36,7 +36,7 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n } while(0)\n #endif\n \n-#ifdef HAVE_BUILTIN_EXPECT\n+#if SECP256K1_GNUC_PREREQ(3, 0)\n #define EXPECT(x,c) __builtin_expect((x),(c))\n #else\n #define EXPECT(x,c) (x)\n@@ -76,6 +76,14 @@ static SECP256K1_INLINE void *checked_malloc(const secp256k1_callback* cb, size_\n     return ret;\n }\n \n+static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void *ptr, size_t size) {\n+    void *ret = realloc(ptr, size);\n+    if (ret == NULL) {\n+        secp256k1_callback_call(cb, \"Out of memory\");\n+    }\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT"
      }
    ]
  }
]