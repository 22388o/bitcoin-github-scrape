[
  {
    "sha": "1622543cf42feb810d8ea9e7b3238d21f1427c17",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNjIyNTQzY2Y0MmZlYjgxMGQ4ZWE5ZTdiMzIzOGQyMWYxNDI3YzE3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-17T16:31:23Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-26T18:53:34Z"
      },
      "message": "[addrman] Move CAddrMan::Serialize to cpp file\n\nReviewer hint: use `git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space`\n\nCo-authored-by: Amiti Uttarwar <amiti@uttarwar.org>",
      "tree": {
        "sha": "2215edd5aa9fbe0501740c44c94d64c0466ebc01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2215edd5aa9fbe0501740c44c94d64c0466ebc01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1622543cf42feb810d8ea9e7b3238d21f1427c17",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1622543cf42feb810d8ea9e7b3238d21f1427c17",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1622543cf42feb810d8ea9e7b3238d21f1427c17",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1622543cf42feb810d8ea9e7b3238d21f1427c17/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4fc15d15667d9d9c4fb5515ce73c05b4596298ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fc15d15667d9d9c4fb5515ce73c05b4596298ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4fc15d15667d9d9c4fb5515ce73c05b4596298ec"
      }
    ],
    "stats": {
      "total": 210,
      "additions": 109,
      "deletions": 101
    },
    "files": [
      {
        "sha": "58feb39b1bd8c49cf9262962ae5612854ef77678",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1622543cf42feb810d8ea9e7b3238d21f1427c17/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1622543cf42feb810d8ea9e7b3238d21f1427c17/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=1622543cf42feb810d8ea9e7b3238d21f1427c17",
        "patch": "@@ -94,6 +94,114 @@ CAddrMan::CAddrMan(bool deterministic, int32_t consistency_check_ratio)\n     }\n }\n \n+template <typename Stream>\n+void CAddrMan::Serialize(Stream& s_) const\n+{\n+    LOCK(cs);\n+\n+    /**\n+     * Serialized format.\n+     * * format version byte (@see `Format`)\n+     * * lowest compatible format version byte. This is used to help old software decide\n+     *   whether to parse the file. For example:\n+     *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is\n+     *     introduced in version N+1 that is compatible with format=3 and it is known that\n+     *     version N will be able to parse it, then version N+1 will write\n+     *     (format=4, lowest_compatible=3) in the first two bytes of the file, and so\n+     *     version N will still try to parse it.\n+     *   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write\n+     *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse\n+     *     format=5 will not try to read the file.\n+     * * nKey\n+     * * nNew\n+     * * nTried\n+     * * number of \"new\" buckets XOR 2**30\n+     * * all new addresses (total count: nNew)\n+     * * all tried addresses (total count: nTried)\n+     * * for each new bucket:\n+     *   * number of elements\n+     *   * for each element: index in the serialized \"all new addresses\"\n+     * * asmap checksum\n+     *\n+     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n+     * as incompatible. This is necessary because it did not check the version number on\n+     * deserialization.\n+     *\n+     * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;\n+     * they are instead reconstructed from the other information.\n+     *\n+     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n+     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n+     *\n+     * We don't use SERIALIZE_METHODS since the serialization and deserialization code has\n+     * very little in common.\n+     */\n+\n+    // Always serialize in the latest version (FILE_FORMAT).\n+\n+    OverrideStream<Stream> s(&s_, s_.GetType(), s_.GetVersion() | ADDRV2_FORMAT);\n+\n+    s << static_cast<uint8_t>(FILE_FORMAT);\n+\n+    // Increment `lowest_compatible` iff a newly introduced format is incompatible with\n+    // the previous one.\n+    static constexpr uint8_t lowest_compatible = Format::V3_BIP155;\n+    s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);\n+\n+    s << nKey;\n+    s << nNew;\n+    s << nTried;\n+\n+    int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n+    s << nUBuckets;\n+    std::unordered_map<int, int> mapUnkIds;\n+    int nIds = 0;\n+    for (const auto& entry : mapInfo) {\n+        mapUnkIds[entry.first] = nIds;\n+        const CAddrInfo &info = entry.second;\n+        if (info.nRefCount) {\n+            assert(nIds != nNew); // this means nNew was wrong, oh ow\n+            s << info;\n+            nIds++;\n+        }\n+    }\n+    nIds = 0;\n+    for (const auto& entry : mapInfo) {\n+        const CAddrInfo &info = entry.second;\n+        if (info.fInTried) {\n+            assert(nIds != nTried); // this means nTried was wrong, oh ow\n+            s << info;\n+            nIds++;\n+        }\n+    }\n+    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+        int nSize = 0;\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[bucket][i] != -1)\n+                nSize++;\n+        }\n+        s << nSize;\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[bucket][i] != -1) {\n+                int nIndex = mapUnkIds[vvNew[bucket][i]];\n+                s << nIndex;\n+            }\n+        }\n+    }\n+    // Store asmap checksum after bucket entries so that it\n+    // can be ignored by older clients for backward compatibility.\n+    uint256 asmap_checksum;\n+    if (m_asmap.size() != 0) {\n+        asmap_checksum = SerializeHash(m_asmap);\n+    }\n+    s << asmap_checksum;\n+}\n+\n+// explicit instantiation\n+template void CAddrMan::Serialize(CHashWriter& s) const;\n+template void CAddrMan::Serialize(CAutoFile& s) const;\n+template void CAddrMan::Serialize(CDataStream& s) const;\n+\n CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);"
      },
      {
        "sha": "07e68191fc12b98b5879d106abf15af7f5b0530f",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 101,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1622543cf42feb810d8ea9e7b3238d21f1427c17/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1622543cf42feb810d8ea9e7b3238d21f1427c17/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=1622543cf42feb810d8ea9e7b3238d21f1427c17",
        "patch": "@@ -200,108 +200,8 @@ class CAddrMan\n     // Read asmap from provided binary file\n     static std::vector<bool> DecodeAsmap(fs::path path);\n \n-    /**\n-     * Serialized format.\n-     * * format version byte (@see `Format`)\n-     * * lowest compatible format version byte. This is used to help old software decide\n-     *   whether to parse the file. For example:\n-     *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is\n-     *     introduced in version N+1 that is compatible with format=3 and it is known that\n-     *     version N will be able to parse it, then version N+1 will write\n-     *     (format=4, lowest_compatible=3) in the first two bytes of the file, and so\n-     *     version N will still try to parse it.\n-     *   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write\n-     *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse\n-     *     format=5 will not try to read the file.\n-     * * nKey\n-     * * nNew\n-     * * nTried\n-     * * number of \"new\" buckets XOR 2**30\n-     * * all new addresses (total count: nNew)\n-     * * all tried addresses (total count: nTried)\n-     * * for each new bucket:\n-     *   * number of elements\n-     *   * for each element: index in the serialized \"all new addresses\"\n-     * * asmap checksum\n-     *\n-     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n-     * as incompatible. This is necessary because it did not check the version number on\n-     * deserialization.\n-     *\n-     * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;\n-     * they are instead reconstructed from the other information.\n-     *\n-     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n-     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n-     *\n-     * We don't use SERIALIZE_METHODS since the serialization and deserialization code has\n-     * very little in common.\n-     */\n     template <typename Stream>\n-    void Serialize(Stream& s_) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-\n-        // Always serialize in the latest version (FILE_FORMAT).\n-\n-        OverrideStream<Stream> s(&s_, s_.GetType(), s_.GetVersion() | ADDRV2_FORMAT);\n-\n-        s << static_cast<uint8_t>(FILE_FORMAT);\n-\n-        // Increment `lowest_compatible` iff a newly introduced format is incompatible with\n-        // the previous one.\n-        static constexpr uint8_t lowest_compatible = Format::V3_BIP155;\n-        s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);\n-\n-        s << nKey;\n-        s << nNew;\n-        s << nTried;\n-\n-        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n-        s << nUBuckets;\n-        std::unordered_map<int, int> mapUnkIds;\n-        int nIds = 0;\n-        for (const auto& entry : mapInfo) {\n-            mapUnkIds[entry.first] = nIds;\n-            const CAddrInfo &info = entry.second;\n-            if (info.nRefCount) {\n-                assert(nIds != nNew); // this means nNew was wrong, oh ow\n-                s << info;\n-                nIds++;\n-            }\n-        }\n-        nIds = 0;\n-        for (const auto& entry : mapInfo) {\n-            const CAddrInfo &info = entry.second;\n-            if (info.fInTried) {\n-                assert(nIds != nTried); // this means nTried was wrong, oh ow\n-                s << info;\n-                nIds++;\n-            }\n-        }\n-        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n-            int nSize = 0;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-                if (vvNew[bucket][i] != -1)\n-                    nSize++;\n-            }\n-            s << nSize;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-                if (vvNew[bucket][i] != -1) {\n-                    int nIndex = mapUnkIds[vvNew[bucket][i]];\n-                    s << nIndex;\n-                }\n-            }\n-        }\n-        // Store asmap checksum after bucket entries so that it\n-        // can be ignored by older clients for backward compatibility.\n-        uint256 asmap_checksum;\n-        if (m_asmap.size() != 0) {\n-            asmap_checksum = SerializeHash(m_asmap);\n-        }\n-        s << asmap_checksum;\n-    }\n+    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     template <typename Stream>\n     void Unserialize(Stream& s_)"
      }
    ]
  },
  {
    "sha": "a65053f1d44c72c43754a5d5aeb684fc1fca0300",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNjUwNTNmMWQ0NGM3MmM0Mzc1NGE1ZDVhZWI2ODRmYzFmY2EwMzAw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-17T16:31:23Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-26T18:53:44Z"
      },
      "message": "[addrman] Move CAddrMan::Unserialize to cpp file\n\nReviewer hint: use `git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space`\n\nCo-authored-by: Amiti Uttarwar <amiti@uttarwar.org>",
      "tree": {
        "sha": "234700bbf51e70ad7b068c762735065900935637",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/234700bbf51e70ad7b068c762735065900935637"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a65053f1d44c72c43754a5d5aeb684fc1fca0300",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a65053f1d44c72c43754a5d5aeb684fc1fca0300",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a65053f1d44c72c43754a5d5aeb684fc1fca0300",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a65053f1d44c72c43754a5d5aeb684fc1fca0300/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1622543cf42feb810d8ea9e7b3238d21f1427c17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1622543cf42feb810d8ea9e7b3238d21f1427c17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1622543cf42feb810d8ea9e7b3238d21f1427c17"
      }
    ],
    "stats": {
      "total": 338,
      "additions": 172,
      "deletions": 166
    },
    "files": [
      {
        "sha": "ed5fd0628894f3e6f5030032ac16431daa0908b7",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a65053f1d44c72c43754a5d5aeb684fc1fca0300/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a65053f1d44c72c43754a5d5aeb684fc1fca0300/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=a65053f1d44c72c43754a5d5aeb684fc1fca0300",
        "patch": "@@ -197,10 +197,181 @@ void CAddrMan::Serialize(Stream& s_) const\n     s << asmap_checksum;\n }\n \n+template <typename Stream>\n+void CAddrMan::Unserialize(Stream& s_)\n+{\n+    LOCK(cs);\n+\n+    assert(vRandom.empty());\n+\n+    Format format;\n+    s_ >> Using<CustomUintFormatter<1>>(format);\n+\n+    int stream_version = s_.GetVersion();\n+    if (format >= Format::V3_BIP155) {\n+        // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+        // unserialize methods know that an address in addrv2 format is coming.\n+        stream_version |= ADDRV2_FORMAT;\n+    }\n+\n+    OverrideStream<Stream> s(&s_, s_.GetType(), stream_version);\n+\n+    uint8_t compat;\n+    s >> compat;\n+    const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;\n+    if (lowest_compatible > FILE_FORMAT) {\n+        throw std::ios_base::failure(strprintf(\n+                    \"Unsupported format of addrman database: %u. It is compatible with formats >=%u, \"\n+                    \"but the maximum supported by this version of %s is %u.\",\n+                    format, lowest_compatible, PACKAGE_NAME, static_cast<uint8_t>(FILE_FORMAT)));\n+    }\n+\n+    s >> nKey;\n+    s >> nNew;\n+    s >> nTried;\n+    int nUBuckets = 0;\n+    s >> nUBuckets;\n+    if (format >= Format::V1_DETERMINISTIC) {\n+        nUBuckets ^= (1 << 30);\n+    }\n+\n+    if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n+        throw std::ios_base::failure(\n+                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %u]\",\n+                    nNew,\n+                    ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n+    }\n+\n+    if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n+        throw std::ios_base::failure(\n+                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %u]\",\n+                    nTried,\n+                    ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n+    }\n+\n+    // Deserialize entries from the new table.\n+    for (int n = 0; n < nNew; n++) {\n+        CAddrInfo &info = mapInfo[n];\n+        s >> info;\n+        mapAddr[info] = n;\n+        info.nRandomPos = vRandom.size();\n+        vRandom.push_back(n);\n+    }\n+    nIdCount = nNew;\n+\n+    // Deserialize entries from the tried table.\n+    int nLost = 0;\n+    for (int n = 0; n < nTried; n++) {\n+        CAddrInfo info;\n+        s >> info;\n+        int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n+        int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n+        if (info.IsValid()\n+                && vvTried[nKBucket][nKBucketPos] == -1) {\n+            info.nRandomPos = vRandom.size();\n+            info.fInTried = true;\n+            vRandom.push_back(nIdCount);\n+            mapInfo[nIdCount] = info;\n+            mapAddr[info] = nIdCount;\n+            vvTried[nKBucket][nKBucketPos] = nIdCount;\n+            nIdCount++;\n+        } else {\n+            nLost++;\n+        }\n+    }\n+    nTried -= nLost;\n+\n+    // Store positions in the new table buckets to apply later (if possible).\n+    // An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,\n+    // so we store all bucket-entry_index pairs to iterate through later.\n+    std::vector<std::pair<int, int>> bucket_entries;\n+\n+    for (int bucket = 0; bucket < nUBuckets; ++bucket) {\n+        int num_entries{0};\n+        s >> num_entries;\n+        for (int n = 0; n < num_entries; ++n) {\n+            int entry_index{0};\n+            s >> entry_index;\n+            if (entry_index >= 0 && entry_index < nNew) {\n+                bucket_entries.emplace_back(bucket, entry_index);\n+            }\n+        }\n+    }\n+\n+    // If the bucket count and asmap checksum haven't changed, then attempt\n+    // to restore the entries to the buckets/positions they were in before\n+    // serialization.\n+    uint256 supplied_asmap_checksum;\n+    if (m_asmap.size() != 0) {\n+        supplied_asmap_checksum = SerializeHash(m_asmap);\n+    }\n+    uint256 serialized_asmap_checksum;\n+    if (format >= Format::V2_ASMAP) {\n+        s >> serialized_asmap_checksum;\n+    }\n+    const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n+        serialized_asmap_checksum == supplied_asmap_checksum};\n+\n+    if (!restore_bucketing) {\n+        LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n+    }\n+\n+    for (auto bucket_entry : bucket_entries) {\n+        int bucket{bucket_entry.first};\n+        const int entry_index{bucket_entry.second};\n+        CAddrInfo& info = mapInfo[entry_index];\n+\n+        // Don't store the entry in the new bucket if it's not a valid address for our addrman\n+        if (!info.IsValid()) continue;\n+\n+        // The entry shouldn't appear in more than\n+        // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n+        // this bucket_entry.\n+        if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n+\n+        int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n+        if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n+            // Bucketing has not changed, using existing bucket positions for the new table\n+            vvNew[bucket][bucket_position] = entry_index;\n+            ++info.nRefCount;\n+        } else {\n+            // In case the new table data cannot be used (bucket count wrong or new asmap),\n+            // try to give them a reference based on their primary source address.\n+            bucket = info.GetNewBucket(nKey, m_asmap);\n+            bucket_position = info.GetBucketPosition(nKey, true, bucket);\n+            if (vvNew[bucket][bucket_position] == -1) {\n+                vvNew[bucket][bucket_position] = entry_index;\n+                ++info.nRefCount;\n+            }\n+        }\n+    }\n+\n+    // Prune new entries with refcount 0 (as a result of collisions or invalid address).\n+    int nLostUnk = 0;\n+    for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {\n+        if (it->second.fInTried == false && it->second.nRefCount == 0) {\n+            const auto itCopy = it++;\n+            Delete(itCopy->first);\n+            ++nLostUnk;\n+        } else {\n+            ++it;\n+        }\n+    }\n+    if (nLost + nLostUnk > 0) {\n+        LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions or invalid addresses\\n\", nLostUnk, nLost);\n+    }\n+\n+    Check();\n+}\n+\n // explicit instantiation\n template void CAddrMan::Serialize(CHashWriter& s) const;\n template void CAddrMan::Serialize(CAutoFile& s) const;\n template void CAddrMan::Serialize(CDataStream& s) const;\n+template void CAddrMan::Unserialize(CAutoFile& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void CAddrMan::Unserialize(CDataStream& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n \n CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {"
      },
      {
        "sha": "d4cee52268e45083275f3baced62161dcdcd5ac9",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 166,
        "changes": 167,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a65053f1d44c72c43754a5d5aeb684fc1fca0300/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a65053f1d44c72c43754a5d5aeb684fc1fca0300/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=a65053f1d44c72c43754a5d5aeb684fc1fca0300",
        "patch": "@@ -204,172 +204,7 @@ class CAddrMan\n     void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     template <typename Stream>\n-    void Unserialize(Stream& s_)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-\n-        assert(vRandom.empty());\n-\n-        Format format;\n-        s_ >> Using<CustomUintFormatter<1>>(format);\n-\n-        int stream_version = s_.GetVersion();\n-        if (format >= Format::V3_BIP155) {\n-            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n-            // unserialize methods know that an address in addrv2 format is coming.\n-            stream_version |= ADDRV2_FORMAT;\n-        }\n-\n-        OverrideStream<Stream> s(&s_, s_.GetType(), stream_version);\n-\n-        uint8_t compat;\n-        s >> compat;\n-        const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;\n-        if (lowest_compatible > FILE_FORMAT) {\n-            throw std::ios_base::failure(strprintf(\n-                \"Unsupported format of addrman database: %u. It is compatible with formats >=%u, \"\n-                \"but the maximum supported by this version of %s is %u.\",\n-                format, lowest_compatible, PACKAGE_NAME, static_cast<uint8_t>(FILE_FORMAT)));\n-        }\n-\n-        s >> nKey;\n-        s >> nNew;\n-        s >> nTried;\n-        int nUBuckets = 0;\n-        s >> nUBuckets;\n-        if (format >= Format::V1_DETERMINISTIC) {\n-            nUBuckets ^= (1 << 30);\n-        }\n-\n-        if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n-            throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %u]\",\n-                          nNew,\n-                          ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n-        }\n-\n-        if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n-            throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %u]\",\n-                          nTried,\n-                          ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n-        }\n-\n-        // Deserialize entries from the new table.\n-        for (int n = 0; n < nNew; n++) {\n-            CAddrInfo &info = mapInfo[n];\n-            s >> info;\n-            mapAddr[info] = n;\n-            info.nRandomPos = vRandom.size();\n-            vRandom.push_back(n);\n-        }\n-        nIdCount = nNew;\n-\n-        // Deserialize entries from the tried table.\n-        int nLost = 0;\n-        for (int n = 0; n < nTried; n++) {\n-            CAddrInfo info;\n-            s >> info;\n-            int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n-            int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n-            if (info.IsValid()\n-                && vvTried[nKBucket][nKBucketPos] == -1) {\n-                info.nRandomPos = vRandom.size();\n-                info.fInTried = true;\n-                vRandom.push_back(nIdCount);\n-                mapInfo[nIdCount] = info;\n-                mapAddr[info] = nIdCount;\n-                vvTried[nKBucket][nKBucketPos] = nIdCount;\n-                nIdCount++;\n-            } else {\n-                nLost++;\n-            }\n-        }\n-        nTried -= nLost;\n-\n-        // Store positions in the new table buckets to apply later (if possible).\n-        // An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,\n-        // so we store all bucket-entry_index pairs to iterate through later.\n-        std::vector<std::pair<int, int>> bucket_entries;\n-\n-        for (int bucket = 0; bucket < nUBuckets; ++bucket) {\n-            int num_entries{0};\n-            s >> num_entries;\n-            for (int n = 0; n < num_entries; ++n) {\n-                int entry_index{0};\n-                s >> entry_index;\n-                if (entry_index >= 0 && entry_index < nNew) {\n-                    bucket_entries.emplace_back(bucket, entry_index);\n-                }\n-            }\n-        }\n-\n-        // If the bucket count and asmap checksum haven't changed, then attempt\n-        // to restore the entries to the buckets/positions they were in before\n-        // serialization.\n-        uint256 supplied_asmap_checksum;\n-        if (m_asmap.size() != 0) {\n-            supplied_asmap_checksum = SerializeHash(m_asmap);\n-        }\n-        uint256 serialized_asmap_checksum;\n-        if (format >= Format::V2_ASMAP) {\n-            s >> serialized_asmap_checksum;\n-        }\n-        const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n-                                     serialized_asmap_checksum == supplied_asmap_checksum};\n-\n-        if (!restore_bucketing) {\n-            LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n-        }\n-\n-        for (auto bucket_entry : bucket_entries) {\n-            int bucket{bucket_entry.first};\n-            const int entry_index{bucket_entry.second};\n-            CAddrInfo& info = mapInfo[entry_index];\n-\n-            // Don't store the entry in the new bucket if it's not a valid address for our addrman\n-            if (!info.IsValid()) continue;\n-\n-            // The entry shouldn't appear in more than\n-            // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n-            // this bucket_entry.\n-            if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n-\n-            int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n-            if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n-                // Bucketing has not changed, using existing bucket positions for the new table\n-                vvNew[bucket][bucket_position] = entry_index;\n-                ++info.nRefCount;\n-            } else {\n-                // In case the new table data cannot be used (bucket count wrong or new asmap),\n-                // try to give them a reference based on their primary source address.\n-                bucket = info.GetNewBucket(nKey, m_asmap);\n-                bucket_position = info.GetBucketPosition(nKey, true, bucket);\n-                if (vvNew[bucket][bucket_position] == -1) {\n-                    vvNew[bucket][bucket_position] = entry_index;\n-                    ++info.nRefCount;\n-                }\n-            }\n-        }\n-\n-        // Prune new entries with refcount 0 (as a result of collisions or invalid address).\n-        int nLostUnk = 0;\n-        for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {\n-            if (it->second.fInTried == false && it->second.nRefCount == 0) {\n-                const auto itCopy = it++;\n-                Delete(itCopy->first);\n-                ++nLostUnk;\n-            } else {\n-                ++it;\n-            }\n-        }\n-        if (nLost + nLostUnk > 0) {\n-            LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions or invalid addresses\\n\", nLostUnk, nLost);\n-        }\n-\n-        Check();\n-    }\n+    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     explicit CAddrMan(bool deterministic, int32_t consistency_check_ratio);\n "
      }
    ]
  },
  {
    "sha": "7dc443a62d3c98d8d0849d83060e940356fe32a3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZGM0NDNhNjJkM2M5OGQ4ZDA4NDlkODMwNjBlOTQwMzU2ZmUzMmEz",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-17T16:31:23Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-26T18:56:13Z"
      },
      "message": "[addrman] Change addrman #define constants to be constexprs\n\nCo-authored-by: John Newbery <john@johnnewbery.com>",
      "tree": {
        "sha": "822fe0c0751a53c8db98f9bd049d6a0417a68342",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/822fe0c0751a53c8db98f9bd049d6a0417a68342"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dc443a62d3c98d8d0849d83060e940356fe32a3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dc443a62d3c98d8d0849d83060e940356fe32a3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7dc443a62d3c98d8d0849d83060e940356fe32a3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dc443a62d3c98d8d0849d83060e940356fe32a3/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a65053f1d44c72c43754a5d5aeb684fc1fca0300",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a65053f1d44c72c43754a5d5aeb684fc1fca0300",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a65053f1d44c72c43754a5d5aeb684fc1fca0300"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 18,
      "deletions": 18
    },
    "files": [
      {
        "sha": "93f7cf6980b4c0942edd2ad4565837db531a7927",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc443a62d3c98d8d0849d83060e940356fe32a3/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc443a62d3c98d8d0849d83060e940356fe32a3/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=7dc443a62d3c98d8d0849d83060e940356fe32a3",
        "patch": "@@ -237,14 +237,14 @@ void CAddrMan::Unserialize(Stream& s_)\n \n     if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %u]\",\n+                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %d]\",\n                     nNew,\n                     ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %u]\",\n+                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %d]\",\n                     nTried,\n                     ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }"
      },
      {
        "sha": "ed7e4c4c5ba45676f09bf68cf3e5b9cd4e715b46",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dc443a62d3c98d8d0849d83060e940356fe32a3/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dc443a62d3c98d8d0849d83060e940356fe32a3/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=7dc443a62d3c98d8d0849d83060e940356fe32a3",
        "patch": "@@ -132,48 +132,48 @@ class CAddrInfo : public CAddress\n  */\n \n //! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT_LOG2 8\n+static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n \n //! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT_LOG2 10\n+static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n \n //! maximum allowed number of entries in buckets for new and tried addresses\n-#define ADDRMAN_BUCKET_SIZE_LOG2 6\n+static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n-#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n+static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n \n //! over how many buckets entries with new addresses originating from a single group are spread\n-#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 64\n+static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n \n //! in how many buckets for entries with new addresses a single address may occur\n-#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 8\n+static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n \n //! how old addresses can maximally be\n-#define ADDRMAN_HORIZON_DAYS 30\n+static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n \n //! after how many failed attempts we give up on a new node\n-#define ADDRMAN_RETRIES 3\n+static constexpr int32_t ADDRMAN_RETRIES{3};\n \n //! how many successive failures are allowed ...\n-#define ADDRMAN_MAX_FAILURES 10\n+static constexpr int32_t ADDRMAN_MAX_FAILURES{10};\n \n //! ... in at least this many days\n-#define ADDRMAN_MIN_FAIL_DAYS 7\n+static constexpr int64_t ADDRMAN_MIN_FAIL_DAYS{7};\n \n //! how recent a successful connection should be before we allow an address to be evicted from tried\n-#define ADDRMAN_REPLACEMENT_HOURS 4\n+static constexpr int64_t ADDRMAN_REPLACEMENT_HOURS{4};\n \n //! Convenience\n-#define ADDRMAN_TRIED_BUCKET_COUNT (1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2)\n-#define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n-#define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n \n //! the maximum number of tried addr collisions to store\n-#define ADDRMAN_SET_TRIED_COLLISION_SIZE 10\n+static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n \n //! the maximum time we'll spend trying to resolve a tried table collision, in seconds\n-static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n+static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n /**\n  * Stochastical (IP) address manager"
      }
    ]
  },
  {
    "sha": "af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjk2MzhhMGZiYjc5YmVjNzQzZjRkMjI3NWI4OWU5NTczY2ZkYzBh",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-17T20:55:11Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-26T18:56:13Z"
      },
      "message": "[move-only] Extract constants from addrman .h to .cpp\n\nReviewer hint: use `git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space`\n\nCo-authored-by: John Newbery <john@johnnewbery.com>",
      "tree": {
        "sha": "c93be21a68ce47eda0b541fea4ddd04876d7084c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c93be21a68ce47eda0b541fea4ddd04876d7084c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af9638a0fbb79bec743f4d2275b89e9573cfdc0a/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7dc443a62d3c98d8d0849d83060e940356fe32a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dc443a62d3c98d8d0849d83060e940356fe32a3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7dc443a62d3c98d8d0849d83060e940356fe32a3"
      }
    ],
    "stats": {
      "total": 67,
      "additions": 33,
      "deletions": 34
    },
    "files": [
      {
        "sha": "ec1c6c975fc01fc58a4b244bc6910dd43eadf39d",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af9638a0fbb79bec743f4d2275b89e9573cfdc0a/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af9638a0fbb79bec743f4d2275b89e9573cfdc0a/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
        "patch": "@@ -15,6 +15,37 @@\n #include <unordered_map>\n #include <unordered_set>\n \n+//! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n+static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n+\n+//! over how many buckets entries with new addresses originating from a single group are spread\n+static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n+\n+//! in how many buckets for entries with new addresses a single address may occur\n+static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n+\n+//! how old addresses can maximally be\n+static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n+\n+//! after how many failed attempts we give up on a new node\n+static constexpr int32_t ADDRMAN_RETRIES{3};\n+\n+//! how many successive failures are allowed ...\n+static constexpr int32_t ADDRMAN_MAX_FAILURES{10};\n+\n+//! ... in at least this many days\n+static constexpr int64_t ADDRMAN_MIN_FAIL_DAYS{7};\n+\n+//! how recent a successful connection should be before we allow an address to be evicted from tried\n+static constexpr int64_t ADDRMAN_REPLACEMENT_HOURS{4};\n+\n+//! the maximum number of tried addr collisions to store\n+static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n+\n+//! the maximum time we'll spend trying to resolve a tried table collision, in seconds\n+static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n+\n+\n int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();"
      },
      {
        "sha": "b6d115e74151105c31c22a7bbe168d27b3a798fb",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 34,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af9638a0fbb79bec743f4d2275b89e9573cfdc0a/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af9638a0fbb79bec743f4d2275b89e9573cfdc0a/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
        "patch": "@@ -133,48 +133,16 @@ class CAddrInfo : public CAddress\n \n //! total number of buckets for tried addresses\n static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n \n //! total number of buckets for new addresses\n static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n \n //! maximum allowed number of entries in buckets for new and tried addresses\n static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n-\n-//! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n-static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n-\n-//! over how many buckets entries with new addresses originating from a single group are spread\n-static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n-\n-//! in how many buckets for entries with new addresses a single address may occur\n-static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n-\n-//! how old addresses can maximally be\n-static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n-\n-//! after how many failed attempts we give up on a new node\n-static constexpr int32_t ADDRMAN_RETRIES{3};\n-\n-//! how many successive failures are allowed ...\n-static constexpr int32_t ADDRMAN_MAX_FAILURES{10};\n-\n-//! ... in at least this many days\n-static constexpr int64_t ADDRMAN_MIN_FAIL_DAYS{7};\n-\n-//! how recent a successful connection should be before we allow an address to be evicted from tried\n-static constexpr int64_t ADDRMAN_REPLACEMENT_HOURS{4};\n-\n-//! Convenience\n-static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n-static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n \n-//! the maximum number of tried addr collisions to store\n-static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n-\n-//! the maximum time we'll spend trying to resolve a tried table collision, in seconds\n-static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n-\n /**\n  * Stochastical (IP) address manager\n  */"
      }
    ]
  },
  {
    "sha": "85b15ddc8ff499fe21d8ab35ece3994f8878b3de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NWIxNWRkYzhmZjQ5OWZlMjFkOGFiMzVlY2UzOTk0Zjg4NzhiM2Rl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-18T08:45:54Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-26T18:56:13Z"
      },
      "message": "[refactor] [addrman] Update constant comments\n\nCo-authored-by: Amiti Uttarwar <amiti@uttarwar.org>",
      "tree": {
        "sha": "f2d5df057f4aac2c8aa8580335f6876e09fd6130",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f2d5df057f4aac2c8aa8580335f6876e09fd6130"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85b15ddc8ff499fe21d8ab35ece3994f8878b3de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85b15ddc8ff499fe21d8ab35ece3994f8878b3de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/85b15ddc8ff499fe21d8ab35ece3994f8878b3de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85b15ddc8ff499fe21d8ab35ece3994f8878b3de/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af9638a0fbb79bec743f4d2275b89e9573cfdc0a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af9638a0fbb79bec743f4d2275b89e9573cfdc0a"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 13,
      "deletions": 23
    },
    "files": [
      {
        "sha": "48e79c64ed7b9cc765c15856d5de7207e77aa247",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 20,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b15ddc8ff499fe21d8ab35ece3994f8878b3de/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b15ddc8ff499fe21d8ab35ece3994f8878b3de/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=85b15ddc8ff499fe21d8ab35ece3994f8878b3de",
        "patch": "@@ -15,37 +15,27 @@\n #include <unordered_map>\n #include <unordered_set>\n \n-//! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n+/** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n-\n-//! over how many buckets entries with new addresses originating from a single group are spread\n+/** Over how many buckets entries with new addresses originating from a single group are spread */\n static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n-\n-//! in how many buckets for entries with new addresses a single address may occur\n+/** Maximum number of times an address can be added to the new table */\n static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n-\n-//! how old addresses can maximally be\n+/** How old addresses can maximally be */\n static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n-\n-//! after how many failed attempts we give up on a new node\n+/** After how many failed attempts we give up on a new node */\n static constexpr int32_t ADDRMAN_RETRIES{3};\n-\n-//! how many successive failures are allowed ...\n+/** How many successive failures are allowed ... */\n static constexpr int32_t ADDRMAN_MAX_FAILURES{10};\n-\n-//! ... in at least this many days\n+/** ... in at least this many days */\n static constexpr int64_t ADDRMAN_MIN_FAIL_DAYS{7};\n-\n-//! how recent a successful connection should be before we allow an address to be evicted from tried\n+/** How recent a successful connection should be before we allow an address to be evicted from tried */\n static constexpr int64_t ADDRMAN_REPLACEMENT_HOURS{4};\n-\n-//! the maximum number of tried addr collisions to store\n+/** The maximum number of tried addr collisions to store */\n static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n-\n-//! the maximum time we'll spend trying to resolve a tried table collision, in seconds\n+/** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-\n int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();"
      },
      {
        "sha": "2548b891bac1b065b412a3d8198c55529fd4605a",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85b15ddc8ff499fe21d8ab35ece3994f8878b3de/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85b15ddc8ff499fe21d8ab35ece3994f8878b3de/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=85b15ddc8ff499fe21d8ab35ece3994f8878b3de",
        "patch": "@@ -131,15 +131,15 @@ class CAddrInfo : public CAddress\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n \n-//! total number of buckets for tried addresses\n+/** Total number of buckets for tried addresses */\n static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n \n-//! total number of buckets for new addresses\n+/** Total number of buckets for new addresses */\n static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n \n-//! maximum allowed number of entries in buckets for new and tried addresses\n+/** Maximum allowed number of entries in buckets for new and tried addresses */\n static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n "
      }
    ]
  }
]