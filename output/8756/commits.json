[
  {
    "sha": "200a37062adc235e0668f40c7e94e0b74658d7dc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDBhMzcwNjJhZGMyMzVlMDY2OGY0MGM3ZTk0ZTBiNzQ2NThkN2Rj",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-27T17:36:25Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-27T17:37:40Z"
      },
      "message": "Add sighash limitation policy\n\nThis implements a static estimation of sighash size for a transaction. A transaction with more than 90bytes of sighash per weight is non-standard. This is equivalent to 36MB for an 100kB non-segwit transaction, or 360MB for a block in the worst case. All transactions below 100kB with legitimate use of CHECK(MULTI)SIG should remain standard with this limit.",
      "tree": {
        "sha": "13ce94166103df3c0fa75d0ea6d7f5e1a2a0caeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13ce94166103df3c0fa75d0ea6d7f5e1a2a0caeb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/200a37062adc235e0668f40c7e94e0b74658d7dc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/200a37062adc235e0668f40c7e94e0b74658d7dc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/200a37062adc235e0668f40c7e94e0b74658d7dc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/200a37062adc235e0668f40c7e94e0b74658d7dc/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fea5e05a638080d54a1962c058f13798c16af150",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fea5e05a638080d54a1962c058f13798c16af150",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fea5e05a638080d54a1962c058f13798c16af150"
      }
    ],
    "stats": {
      "total": 138,
      "additions": 133,
      "deletions": 5
    },
    "files": [
      {
        "sha": "834ab0206b15c759a4eab8a14f292ebb9095647f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -1062,8 +1062,23 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n+int GetTransactionBaseSigHashOpCount(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+{\n+    int nSigHashOps = 0;\n+\n+    if (tx.IsCoinBase())\n+        return nSigHashOps;\n \n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        nSigHashOps += tx.vin[i].scriptSig.GetSigHashOpCount();\n+        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        nSigHashOps += prevout.scriptPubKey.GetSigHashOpCount();\n+        if (prevout.scriptPubKey.IsPayToScriptHash() && (flags & SCRIPT_VERIFY_P2SH))\n+            nSigHashOps += prevout.scriptPubKey.GetSigHashOpCount(tx.vin[i].scriptSig);\n+    }\n \n+    return nSigHashOps;\n+}\n \n \n bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n@@ -1285,6 +1300,13 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (!tx.wit.IsNull() && fRequireStandard && !IsWitnessStandard(tx, view))\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n \n+        // Check for excessive SignatureHash operation\n+        if (fRequireStandard) {\n+            int64_t hashsize = GetTransactionHashableSize(tx) * GetTransactionBaseSigHashOpCount(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+            if (hashsize > MAX_STANDARD_HASH_PER_WEIGHT * GetTransactionWeight(tx))\n+                return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-too-much-sighashing\");\n+        }\n+\n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n         CAmount nValueOut = tx.GetValueOut();"
      },
      {
        "sha": "8d3869efb83f1a4018f304d64fa2589d051c8335",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -325,6 +325,12 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& ma\n  */\n int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n \n+/**\n+ * Compute total signature hashing operation of a transaction.\n+ * Parameters same as GetTransactionSigOpCost\n+ */\n+int GetTransactionBaseSigHashOpCount(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+\n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n  * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it"
      },
      {
        "sha": "8ed0a6ee92b1902c39c703351e9fb0b095259a79",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -36,6 +36,12 @@ static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n /** The maximum size of a standard witnessScript */\n static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n+/**\n+ *  Maximum standard signature hashing per transaction weight (byte hashed per weight)\n+ *  This is equivalent to 36MB for an 100kB non-segwit transaction.\n+ *  All transactions below 100kB with legitimate use of CHECK(MULTI)SIG should remain standard with this limit.\n+ */\n+static const unsigned int MAX_STANDARD_HASH_PER_WEIGHT = 90;\n /**\n  * Standard script verification flags that standard transactions will comply\n  * with. However scripts violating these flags may still be present in valid"
      },
      {
        "sha": "dbb32fb125c51db8cbad9be4ac88cb03edd93902",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -158,3 +158,21 @@ int64_t GetTransactionWeight(const CTransaction& tx)\n {\n     return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n }\n+\n+int64_t GetTransactionHashableSize(const CTransaction& tx)\n+{\n+    int64_t size = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        int64_t scriptSigSize = tx.vin[i].scriptSig.size();\n+        size -= scriptSigSize;\n+        // If the scriptSig size is larger than 252, 2 bytes compactSize encoding is deducted.\n+        if (scriptSigSize > 252)\n+            size -= 2;\n+        /*\n+         * Theoretically, 4 bytes should be deducted if the scriptSig is larger than 65535 bytes,\n+         * and 8 bytes should be deducted if it is larger than 4294967295 bytes.\n+         * However, scriptSig larger than 10000 bytes is invalid so it is not needed.\n+         */\n+    }\n+    return size;\n+}"
      },
      {
        "sha": "96688f54b8dd416836d70bacded266c018429304",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -471,4 +471,7 @@ struct CMutableTransaction\n /** Compute the weight of a transaction, as defined by BIP 141 */\n int64_t GetTransactionWeight(const CTransaction &tx);\n \n+/** Compute the signature hashable size = transaction size - scriptSig size */\n+int64_t GetTransactionHashableSize(const CTransaction& tx);\n+\n #endif // BITCOIN_PRIMITIVES_TRANSACTION_H"
      },
      {
        "sha": "f68521221f798afff689bbd270758f49d39e91d7",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 1,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -201,6 +201,72 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     return subscript.GetSigOpCount(true);\n }\n \n+unsigned int CScript::GetSigHashOpCount() const\n+{\n+    unsigned int n = 0;\n+    const_iterator pc = begin();\n+    std::vector<opcodetype> pushOpcodes;\n+    while (pc < end())\n+    {\n+        opcodetype opcode;\n+        if (!GetOp(pc, opcode))\n+            break; // The script is invalid\n+        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n+            n++;\n+        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY) {\n+            // The number of keys must be k = 1 to 16 denoted by OP_k\n+            if (!pushOpcodes.empty() && pushOpcodes.back() >= OP_1 && pushOpcodes.back() <= OP_16) {\n+                unsigned int nKeys = DecodeOP_N(pushOpcodes.back());\n+                // We assume sigHashOp is k, unless the the number of signature is canonical\n+                n += nKeys;\n+                // If all the k + 2 opcodes before the CHECKMULTISIG are push only, and the number of signature\n+                // is denoted as OP_s with s = 1 to 16, and s < k, we count it as s sigHashOp\n+                if (pushOpcodes.size() >= nKeys + 2) {\n+                    opcodetype nSigsCode = pushOpcodes.at(pushOpcodes.size() - nKeys - 2);\n+                    if (nSigsCode >= OP_1 && nSigsCode <= OP_16) {\n+                        unsigned int nSigs = DecodeOP_N(nSigsCode);\n+                        if (nSigs < nKeys)\n+                            n = n - nKeys + nSigs;\n+                    }\n+                }\n+            }\n+            // If key count is not canonical, we assume it has 20 sigHashOp\n+            else\n+                n += MAX_PUBKEYS_PER_MULTISIG;\n+        }\n+\n+        if (opcode <= OP_16)\n+            pushOpcodes.push_back(opcode);\n+        else\n+            pushOpcodes.clear();\n+    }\n+    return n;\n+}\n+\n+unsigned int CScript::GetSigHashOpCount(const CScript& scriptSig) const\n+{\n+    if (!IsPayToScriptHash())\n+        return GetSigHashOpCount();\n+\n+    // This is a pay-to-script-hash scriptPubKey;\n+    // get the last item that the scriptSig\n+    // pushes onto the stack:\n+    const_iterator pc = scriptSig.begin();\n+    vector<unsigned char> data;\n+    while (pc < scriptSig.end())\n+    {\n+        opcodetype opcode;\n+        if (!scriptSig.GetOp(pc, opcode, data))\n+            return 0;\n+        if (opcode > OP_16)\n+            return 0;\n+    }\n+\n+    /// ... and return its hash opcount:\n+    CScript subscript(data.begin(), data.end());\n+    return subscript.GetSigHashOpCount();\n+}\n+\n bool CScript::IsPayToScriptHash() const\n {\n     // Extra-fast test for pay-to-script-hash CScripts:"
      },
      {
        "sha": "29f934eabb5b1de790a7f3e0c847281df6c51e07",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/200a37062adc235e0668f40c7e94e0b74658d7dc/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/200a37062adc235e0668f40c7e94e0b74658d7dc/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=200a37062adc235e0668f40c7e94e0b74658d7dc",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -620,6 +620,13 @@ class CScript : public CScriptBase\n      */\n     unsigned int GetSigOpCount(const CScript& scriptSig) const;\n \n+    /**\n+     * Count the maximum number of sighashing-equivalent operations in a non-witness script.\n+     * It assumes that SignatureHash is performed once only for each signature within a CHECKMULTISIG.\n+     */\n+    unsigned int GetSigHashOpCount() const;\n+    unsigned int GetSigHashOpCount(const CScript& scriptSig) const;\n+\n     bool IsPayToScriptHash() const;\n     bool IsPayToWitnessScriptHash() const;\n     bool IsWitnessProgram(int& version, std::vector<unsigned char>& program) const;"
      }
    ]
  },
  {
    "sha": "c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMWVlYTJjY2NlOWI3MTY4MjZhZjZlZDllNGNhOWJhYjIyZGFiMjll",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-09-19T04:40:02Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-27T17:37:41Z"
      },
      "message": "Implement sighash cache for signature within CHECKMULTISIG\n\nThis makes sure that SignatureHash is performed once only for each signature within a CHECKMULTISIG. Alternative to #8654.",
      "tree": {
        "sha": "7cd9443de5c5f8808f094ed19479955f5107b1fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7cd9443de5c5f8808f094ed19479955f5107b1fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "200a37062adc235e0668f40c7e94e0b74658d7dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/200a37062adc235e0668f40c7e94e0b74658d7dc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/200a37062adc235e0668f40c7e94e0b74658d7dc"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 22,
      "deletions": 8
    },
    "files": [
      {
        "sha": "45f45158bcc6883099afe85b84fb8c99a900d8f6",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
        "patch": "@@ -899,7 +899,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         //serror is set\n                         return false;\n                     }\n-                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+                    uint256 sighashCopy;\n+                    bool cacheSet = false;\n+                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion, sighashCopy, cacheSet);\n \n                     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n                         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n@@ -961,6 +963,8 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     }\n \n                     bool fSuccess = true;\n+                    bool cacheSet = false;\n+                    uint256 sighashCopy;\n                     while (fSuccess && nSigsCount > 0)\n                     {\n                         valtype& vchSig    = stacktop(-isig);\n@@ -975,11 +979,12 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         }\n \n                         // Check signature\n-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion, sighashCopy, cacheSet);\n \n                         if (fOk) {\n                             isig++;\n                             nSigsCount--;\n+                            cacheSet = false;\n                         }\n                         ikey++;\n                         nKeysCount--;\n@@ -1250,7 +1255,7 @@ bool TransactionSignatureChecker::VerifySignature(const std::vector<unsigned cha\n     return pubkey.Verify(sighash, vchSig);\n }\n \n-bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion, uint256& sighashCopy, bool& cacheSet) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n@@ -1263,7 +1268,14 @@ bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn\n     int nHashType = vchSig.back();\n     vchSig.pop_back();\n \n-    uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n+    uint256 sighash;\n+    if (cacheSet)\n+        sighash = sighashCopy;\n+    else {\n+        sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n+        sighashCopy = sighash;\n+        cacheSet = true;\n+    }\n \n     if (!VerifySignature(vchSig, pubkey, sighash))\n         return false;"
      },
      {
        "sha": "954c513656839e1aabc1d8cc3ab0f194b22394f1",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
        "patch": "@@ -128,7 +128,7 @@ uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsig\n class BaseSignatureChecker\n {\n public:\n-    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion, uint256& sighashCopy, bool& cacheSet) const\n     {\n         return false;\n     }\n@@ -160,7 +160,7 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n public:\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(NULL) {}\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const;\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion, uint256& sighashCopy, bool& cacheSet) const;\n     bool CheckLockTime(const CScriptNum& nLockTime) const;\n     bool CheckSequence(const CScriptNum& nSequence) const;\n };"
      },
      {
        "sha": "63fff07796caf4f330a3d31e959d1a29c6936c9f",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
        "patch": "@@ -257,13 +257,15 @@ static vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSi\n     map<valtype, valtype> sigs;\n     BOOST_FOREACH(const valtype& sig, allsigs)\n     {\n+        uint256 sighashCopy;\n+        bool cacheSet = false;\n         for (unsigned int i = 0; i < nPubKeys; i++)\n         {\n             const valtype& pubkey = vSolutions[i+1];\n             if (sigs.count(pubkey))\n                 continue; // Already got a sig for this pubkey\n \n-            if (checker.CheckSig(sig, pubkey, scriptPubKey, sigversion))\n+            if (checker.CheckSig(sig, pubkey, scriptPubKey, sigversion, sighashCopy, cacheSet))\n             {\n                 sigs[pubkey] = sig;\n                 break;\n@@ -401,7 +403,7 @@ class DummySignatureChecker : public BaseSignatureChecker\n public:\n     DummySignatureChecker() {}\n \n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion, uint256& sighashCopy, bool& cacheSet) const\n     {\n         return true;\n     }"
      }
    ]
  },
  {
    "sha": "e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMjBiNmM2YjMzNTRiZjFjZTJmZTY3NDlkOWI2ZDM4ZDg2YTJmNDQy",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-09-30T09:09:02Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-28T08:48:17Z"
      },
      "message": "Test sighash limit policy",
      "tree": {
        "sha": "90aa6585ca6e4612406cc5fef8c822c0ba03c3ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/90aa6585ca6e4612406cc5fef8c822c0ba03c3ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c1eea2ccce9b716826af6ed9e4ca9bab22dab29e"
      }
    ],
    "stats": {
      "total": 334,
      "additions": 331,
      "deletions": 3
    },
    "files": [
      {
        "sha": "0ee88349343b0e178985968ba7cf854b2d735854",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
        "patch": "@@ -146,6 +146,7 @@\n     'p2p-compactblocks.py',\n     'nulldummy.py',\n     'importmulti.py',\n+    'sighashlimit.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')"
      },
      {
        "sha": "5545b5b23b6bdb3ff7c3eb6e5bf4d231af89c492",
        "filename": "qa/rpc-tests/sighashlimit.py",
        "status": "added",
        "additions": 157,
        "deletions": 0,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/qa/rpc-tests/sighashlimit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/qa/rpc-tests/sighashlimit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sighashlimit.py?ref=e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
        "patch": "@@ -0,0 +1,157 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.mininode import CTransaction, CTxOut, CTxIn, COutPoint, CTxInWitness\n+from test_framework.util import *\n+from test_framework.script import CScript, OP_0, OP_HASH160, OP_EQUAL, OP_CHECKSIG, OP_NOT, OP_2DUP, OP_DROP, OP_2DROP, hash160, sha256\n+\n+# This is to test the sighash limit policy\n+\n+class SigHashLimitTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self):\n+        # Create 2 nodes. One enforces standardness rules and one does not.\n+        self.nodes = [start_node(0, self.options.tmpdir, [\"-acceptnonstdtxn=0\"])]\n+        self.nodes.append(start_node(1, self.options.tmpdir))\n+        connect_nodes(self.nodes[0], 1)\n+\n+    def test_preparation(self):\n+        print (\"Testing sighash limit policy\")\n+        # Generate a block and get the coinbase txid.\n+        self.coinbase_blocks = self.nodes[1].generate(1)\n+        coinbase_txid = int(\"0x\" + self.nodes[1].getblock(self.coinbase_blocks[0])['tx'][0], 0)\n+        self.nodes[1].generate(100)\n+\n+        '''\n+        # By design, it is impossible to create a normal transaction below 400,000 weight,\n+        # while having excessive SigHash size.\n+        #\n+        # Here it creates small script with 4 SigHashOp in P2SH.\n+        # Also create a witness program, which should be ignored in SigHashOp counting.\n+        '''\n+        dummykey = hex_str_to_bytes(\"0300112233445566778899aabbccddeeff00112233445566778899aabbccddeeff\")\n+        self.script = CScript([OP_0, dummykey, OP_2DUP, OP_2DUP, OP_2DUP, OP_CHECKSIG, OP_DROP, OP_CHECKSIG, OP_DROP, OP_CHECKSIG, OP_DROP, OP_CHECKSIG, OP_NOT])\n+        self.p2sh = CScript([OP_HASH160, hash160(self.script), OP_EQUAL])\n+        self.p2wsh = CScript([OP_0, sha256(self.script)])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(coinbase_txid)))\n+        for i in range(1000):\n+            tx.vout.append(CTxOut(4500000, self.p2sh))\n+        for i in range(100):\n+            tx.vout.append(CTxOut(4500000, self.p2wsh))\n+\n+        tx.rehash()\n+        signresults = self.nodes[1].signrawtransaction(bytes_to_hex_str(tx.serialize_with_witness()))['hex']\n+        self.txid = int(\"0x\" + self.nodes[1].sendrawtransaction(signresults, True), 0)\n+        self.nodes[1].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        self.p2shcount = 0      # P2SH outputs start from 0\n+        self.p2wshcount = 1000   # P2WSH outputs start from 500\n+\n+    def non_segwit_test(self):\n+        '''\n+        tx1:\n+            Size = 4 + 1 + 88 * 95 + 3 + 2390 * 32 + 4 = 84852\n+            Weight = 84852 * 4 = 339408\n+            Hashable size = 84852 - 47 * 95 = 80387\n+            SigHashOp = 4 * 95 = 380\n+            SigHashSize = 380 * 80387 = 30547060\n+            SigHashSize per Weight = 30547060 / 339408 = 90.001\n+\n+        tx2:\n+            Size = 4 + 1 + 88 * 95 + 3 + 2389 * 32 + 4 = 84820\n+            Weight = 84820 * 4 = 339280\n+            Hashable size = 84820 - 47 * 95 = 80355\n+            SigHashOp = 4 * 95 = 380\n+            SigHashSize = 380 * 80355 = 30534900\n+            SigHashSize per Weight = 30534900 / 339280 = 89.9991\n+        '''\n+        tx1 = CTransaction()\n+        tx2 = CTransaction()\n+        for i in range(95):\n+            tx1.vin.append(CTxIn(COutPoint(self.txid,self.p2shcount),CScript([self.script])))\n+            tx2.vin.append(CTxIn(COutPoint(self.txid,self.p2shcount + 1),CScript([self.script])))\n+            self.p2shcount += 2\n+        for i in range(2389):\n+            tx1.vout.append(CTxOut(1000, self.p2sh))\n+            tx2.vout.append(CTxOut(1000, self.p2sh))\n+        tx1.vout.append(CTxOut(1000, self.p2sh))    # Add one more output to tx1\n+        tx1.rehash()\n+        tx2.rehash()\n+        self.submit_pair(tx1, tx2)\n+\n+    def segwit_test(self):\n+        '''\n+        tx1:\n+            Witness-stripped size = 4 + 1 + 88 * 95 + 41 * 20 + 3 + 2513 * 32 + 4 = 89608\n+            Witness size = 2 + 1 * 95 + 48 * 20 = 1057\n+            Weight = 89608 * 4 + 1057 = 359489\n+            Hashable size = 89608 - 47 * 95 = 85143\n+            SigHashOp = 4 * 95 = 380\n+            SigHashSize = 380 * 85143 = 32354340\n+            SigHashSize per Weight = 32342180 / 359489 = 90.0009\n+\n+        tx2:\n+            Witness-stripped size = 4 + 1 + 88 * 95 + 41 * 20 + 3 + 2512 * 32 + 4 = 89576\n+            Witness size = 2 + 1 * 95 + 48 * 20 = 1057\n+            Weight = 89576 * 4 + 1057 = 359361\n+            Hashable size = 89576 - 47 * 95 = 85111\n+            SigHashOp = 4 * 95 = 380\n+            SigHashSize = 380 * 85111 = 32342180\n+            SigHashSize per Weight = 32342180 / 359361 = 89.9991\n+        '''\n+        tx1 = CTransaction()\n+        tx2 = CTransaction()\n+        for i in range(20):\n+            tx1.vin.append(CTxIn(COutPoint(self.txid,self.p2wshcount)))\n+            tx1.wit.vtxinwit.append(CTxInWitness())\n+            tx1.wit.vtxinwit[i].scriptWitness.stack = [self.script]\n+            tx2.vin.append(CTxIn(COutPoint(self.txid,self.p2wshcount + 1)))\n+            tx2.wit.vtxinwit.append(CTxInWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [self.script]\n+            self.p2wshcount += 2\n+        for i in range(95):\n+            tx1.vin.append(CTxIn(COutPoint(self.txid,self.p2shcount),CScript([self.script])))\n+            tx2.vin.append(CTxIn(COutPoint(self.txid,self.p2shcount + 1),CScript([self.script])))\n+            self.p2shcount += 2\n+        for i in range(2512):\n+            tx1.vout.append(CTxOut(1000, self.p2sh))\n+            tx2.vout.append(CTxOut(1000, self.p2sh))\n+        tx1.vout.append(CTxOut(1000, self.p2sh))    # Add one more output to tx1\n+        tx1.rehash()\n+        tx2.rehash()\n+        self.submit_pair(tx1, tx2)\n+\n+    def submit_pair(self, tx1, tx2):\n+        # Non-standard node should accept both tx1 and tx2. Standard node should accept only tx2\n+        try:\n+            self.nodes[0].sendrawtransaction(bytes_to_hex_str(tx1.serialize_with_witness()), True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], \"64: bad-txns-nonstandard-too-much-sighashing\")\n+        else:\n+            assert(False)\n+        self.nodes[1].sendrawtransaction(bytes_to_hex_str(tx1.serialize_with_witness()), True)\n+        self.nodes[0].sendrawtransaction(bytes_to_hex_str(tx2.serialize_with_witness()), True)\n+        self.nodes[1].sendrawtransaction(bytes_to_hex_str(tx2.serialize_with_witness()), True)\n+        self.nodes[1].generate(1)\n+        sync_blocks(self.nodes)\n+\n+    def run_test(self):\n+        self.test_preparation()\n+        self.non_segwit_test()          # Test non-segwit P2SH before segwit activation\n+        self.nodes[0].generate(400)     # Activate segwit\n+        sync_blocks(self.nodes)\n+        self.non_segwit_test()          # Test non-segwit P2SH after segwit activation\n+        self.segwit_test()              # Test non-segwit P2SH mixed with P2WSH\n+\n+if __name__ == '__main__':\n+    SigHashLimitTest().main()\n\\ No newline at end of file"
      },
      {
        "sha": "a0ee8b69fab686e1a88807ffc0197234750c8708",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 98,
        "deletions": 2,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -1333,7 +1333,6 @@ ScriptFromHex(const char* hex)\n     return CScript(data.begin(), data.end());\n }\n \n-\n BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n {\n     // Exercise the FindAndDelete functionality\n@@ -1443,4 +1442,101 @@ BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n     BOOST_CHECK(s == expect);\n }\n \n+BOOST_AUTO_TEST_CASE(script_SigHashOp)\n+{\n+    CScript s;\n+    CKey key;\n+    key.MakeNewKey(true);\n+    std::vector<unsigned char> pubkey = ToByteVector(key.GetPubKey());\n+\n+    // Empty script\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 0);\n+\n+    // Maximum count is 3\n+    for (int i = 1; i < 10; i++) {\n+        s << OP_CHECKSIG;\n+        BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), i);\n+    }\n+    s = CScript();\n+    for (int i = 1; i < 10; i++) {\n+        s << OP_CHECKMULTISIG;\n+        BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 20*i);\n+    }\n+    s = CScript();\n+    for (int i = 1; i < 10; i++) {\n+        s << OP_1 << pubkey << pubkey << OP_2 << OP_CHECKMULTISIG;\n+        BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), i);\n+    }\n+    s = CScript();\n+    for (int i = 1; i < 10; i++) {\n+        s << OP_2 << pubkey << pubkey << OP_2 << OP_CHECKMULTISIG;\n+        BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2*i);\n+    }\n+\n+    // Mixing CHECKSIG and CHECKMULTISIG\n+    s = CScript() << OP_CHECKSIGVERIFY << OP_1 << pubkey << pubkey << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+    s = CScript() << OP_1 << pubkey << pubkey << OP_2 << OP_CHECKMULTISIGVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+\n+    // OP_RESERVED is considered as a push code. It doesn't matter since the script must fail before CHECKMULTISIG is run.\n+    s = CScript() << OP_1 << OP_RESERVED << OP_0 << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 1);\n+\n+    // Using OP_RESERVED as number of signature is non-canonical\n+    s = CScript() << OP_RESERVED << OP_RESERVED << OP_0 << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+\n+    // Using non-push code before number of signature or after OP_CHECKMULTISIG is ok\n+    s = CScript() << OP_NOP << OP_1 << pubkey << pubkey << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 1);\n+    s = CScript() << OP_1 << pubkey << pubkey << OP_2 << OP_CHECKMULTISIG << OP_NOP;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 1);\n+    // But not ok if it's used in between\n+    s = CScript() << OP_1 << OP_NOP << pubkey << pubkey << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+    s = CScript() << OP_1 << pubkey << OP_NOP << pubkey << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+    s = CScript() << OP_1 << pubkey << pubkey << OP_NOP << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+    s = CScript() << OP_1 << pubkey << pubkey << OP_2 << OP_NOP << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 20);\n+\n+    // Test 17 * 18 combinations of nKey and nSig in OP_CHECKMULTISIG\n+    static const opcodetype pushOps[] = {OP_0, OP_1, OP_2, OP_3, OP_4, OP_5, OP_6, OP_7, OP_8, OP_9, OP_10, OP_11, OP_12, OP_13, OP_14, OP_15, OP_16};\n+    for (int nKey = 0; nKey <= 16; nKey++) {\n+        for (int nSig = -1; nSig <= 16; nSig++) {\n+            s = CScript();\n+            if (nSig >= 0)\n+               s << pushOps[nSig];\n+            for (int i = 0; i < nKey; i++)\n+                s << pubkey;\n+            s << pushOps[nKey] << OP_CHECKMULTISIG;\n+            if (nKey == 0)\n+                BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), MAX_PUBKEYS_PER_MULTISIG); // This is non-canonical\n+            else if (nSig > 0 && nSig < nKey)\n+                BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), nSig);\n+            else\n+                BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), nKey);\n+        }\n+    }\n+\n+    // Non-canonical push for nKey or nSig\n+    s = ScriptFromHex(\"5151510102ae\");\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 20);\n+    s = ScriptFromHex(\"0101515152ae\");\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+\n+    // Non-canonical push for pubkey is ok\n+    // OP_2 0x0101 OP_PUSHDATA1(01) OP_PUSHDATA2(01) OP_PUSHDATA4(01) OP_1 OP_RESERVED OP_6 OP_CHECKMULTISIG\n+    s = ScriptFromHex(\"5201014c01014d0100014e0100000001515056ae\");\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+\n+    // Truncated scripts are invalid and the last known SigHashOp is returned\n+    s = ScriptFromHex(\"ac05acadaeaf\");\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 1);\n+    s = ScriptFromHex(\"5200000053ae05acadaeaf\");\n+    BOOST_CHECK_EQUAL(s.GetSigHashOpCount(), 2);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7f370d80faa38475cf6b114915747a455db69313",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 1,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Copyright (c) 2012-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -143,6 +143,32 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         assert(GetTransactionSigOpCost(CTransaction(creationTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n         // Sanity check: script verification fails because of an invalid signature.\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        // SigHashOp in spending scriptPubKey is counted as the number of signature\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 1);\n+        // SigOp in output scriptPubKey is not counted as SigHashOp\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(creationTx), coins, flags) == 0);\n+    }\n+\n+    // Multisig in scriptSig (legacy counting)\n+    {\n+        CScript scriptPubKey = CScript();\n+        // Do not use a valid signature to avoid using wallet operations.\n+        CScript scriptSig = CScript() << OP_0 << OP_0 << 1 << ToByteVector(pubkey) << ToByteVector(pubkey) << 2 << OP_CHECKMULTISIGVERIFY;\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CTxInWitness());\n+        // creationTx contains two signature operations in its scriptSig, but legacy counting\n+        // is not accurate.\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n+        // Sanity check: script verification fails because of an invalid signature.\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        // SigHashOp in scriptSig is counted as the number of signature\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 1);\n+\n+        // SigOp in coinbase scriptSig is counted\n+        spendingTx.vin[0].prevout.SetNull();\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n+        // SigHashOp in coinbase scriptSig is not counted\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 0);\n     }\n \n     // Multisig nested in P2SH\n@@ -154,6 +180,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CTxInWitness());\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2 * WITNESS_SCALE_FACTOR);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        // SigHashOp in redeemScript is counted as the number of signature\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 1);\n     }\n \n     // P2WPKH witness program\n@@ -173,6 +201,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         // No signature operations if we don't verify the witness.\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+        // SigOp in witness is not counted as SigHashOp\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 0);\n \n         // The sig op cost for witness version != 0 is zero.\n         assert(scriptPubKey[0] == 0x00);\n@@ -202,6 +232,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+        // SigOp in witness is not counted as SigHashOp\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 0);\n     }\n \n     // P2WSH witness program\n@@ -220,6 +252,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        // SigOp in witness is not counted as SigHashOp\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 0);\n     }\n \n     // P2WSH nested in P2SH\n@@ -238,6 +272,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        // SigOp in witness is not counted as SigHashOp\n+        assert(GetTransactionBaseSigHashOpCount(CTransaction(spendingTx), coins, flags) == 0);\n     }\n }\n "
      },
      {
        "sha": "3b53d07801d784e32ff650f2dceaa661a67a8e64",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=e20b6c6b3354bf1ce2fe6749d9b6d38d86a2f442",
        "patch": "@@ -19,6 +19,7 @@\n #include \"script/script_error.h\"\n #include \"script/standard.h\"\n #include \"utilstrencodings.h\"\n+#include \"test_random.h\"\n \n #include <map>\n #include <string>\n@@ -771,4 +772,41 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     BOOST_CHECK(!IsStandardTx(t, reason));\n }\n \n+BOOST_AUTO_TEST_CASE(test_transaction_hashable_size)\n+{\n+    /*\n+     * Generate 500 random transactions, with 1-100 inputs and 1-100 outputs.\n+     * Some have witness, some do not.\n+     * Random size for scriptSig and scriptPubKey from 0 to 499\n+     * sz1 is the witness-stripped and scriptSig-stripped size, should be equal to the result of GetTransactionHashableSize\n+     */\n+    for (int i = 0; i < 500; i++) {\n+        int nIn = 1 + insecure_rand() % 100;\n+        int nOut = 1 + insecure_rand() % 100;\n+        bool wit = insecure_rand() % 2;\n+        CMutableTransaction mtx;\n+        mtx.vin.resize(nIn);\n+        mtx.vout.resize(nOut);\n+        for (int j = 0; j < nOut; j++) {\n+            int sizeScript = insecure_rand() % 500;\n+            for (int k = 0; k < sizeScript; k++)\n+                mtx.vout[j].scriptPubKey << OP_0;\n+        }\n+        if (wit) {\n+            mtx.wit.vtxinwit.resize(nIn);\n+            for (int j = 0; j < nIn; j++) {\n+                int sizeWitness = insecure_rand() % 500;\n+                mtx.wit.vtxinwit[j].scriptWitness.stack.resize(sizeWitness);\n+            }\n+        }\n+        int64_t sz1 = ::GetSerializeSize(mtx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n+        for (int j = 0; j < nIn; j++) {\n+            int sizeScript = insecure_rand() % 500;\n+            for (int k = 0; k < sizeScript; k++)\n+                mtx.vin[j].scriptSig << OP_0;\n+        }\n+        BOOST_CHECK_EQUAL(sz1, GetTransactionHashableSize(mtx));\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]