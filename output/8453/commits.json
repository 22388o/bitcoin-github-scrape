[
  {
    "sha": "b2135359b3ad37cf2ac09b008079ddb237eff2c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjEzNTM1OWIzYWQzN2NmMmFjMDliMDA4MDc5ZGRiMjM3ZWZmMmM5",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-08-16T09:34:11Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-08-16T09:34:11Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 6c527ec..7a49cac\n\n7a49cac Merge #410: Add string.h include to ecmult_impl\n0bbd5d4 Add string.h include to ecmult_impl\nc5b32e1 Merge #405: Make secp256k1_fe_sqrt constant time\n926836a Make secp256k1_fe_sqrt constant time\ne2a8e92 Merge #404: Replace 3M + 4S doubling formula with 2M + 5S one\n8ec49d8 Add note about 2M + 5S doubling formula\n5a91bd7 Merge #400: A couple minor cleanups\nac01378 build: add -DSECP256K1_BUILD to benchmark_internal build flags\na6c6f99 Remove a bunch of unused stdlib #includes\n65285a6 Merge #403: configure: add flag to disable OpenSSL tests\na9b2a5d configure: add flag to disable OpenSSL tests\nb340123 Merge #402: Add support for testing quadratic residues\ne6e9805 Add function for testing quadratic residue field/group elements.\nefd953a Add Jacobi symbol test via GMP\nfa36a0d Merge #401: ecmult_const: unify endomorphism and non-endomorphism skew cases\nc6191fd ecmult_const: unify endomorphism and non-endomorphism skew cases\n0b3e618 Merge #378: .gitignore build-aux cleanup\n6042217 Merge #384: JNI: align shared files copyright/comments to bitcoinj's\n24ad20f Merge #399: build: verify that the native compiler works for static precomp\nb3be852 Merge #398: Test whether ECDH and Schnorr are enabled for JNI\naa0b1fd build: verify that the native compiler works for static precomp\neee808d Test whether ECDH and Schnorr are enabled for JNI\n7b0fb18 Merge #366: ARM assembly implementation of field_10x26 inner (rebase of #173)\n001f176 ARM assembly implementation of field_10x26 inner\n0172be9 Merge #397: Small fixes for sha256\n3f8b78e Fix undefs in hash_impl.h\n2ab4695 Fix state size in sha256 struct\n6875b01 Merge #386: Add some missing `VERIFY_CHECK(ctx != NULL)`\n2c52b5d Merge #389: Cast pointers through uintptr_t under JNI\n43097a4 Merge #390: Update bitcoin-core GitHub links\n31c9c12 Merge #391: JNI: Only call ecdsa_verify if its inputs parsed correctly\n1cb2302 Merge #392: Add testcase which hits additional branch in secp256k1_scalar_sqr\nd2ee340 Merge #388: bench_ecdh: fix call to secp256k1_context_create\n093a497 Add testcase which hits additional branch in secp256k1_scalar_sqr\na40c701 JNI: Only call ecdsa_verify if its inputs parsed correctly\nfaa2a11 Update bitcoin-core GitHub links\n47b9e78 Cast pointers through uintptr_t under JNI\nf36f9c6 bench_ecdh: fix call to secp256k1_context_create\nbcc4881 Add some missing `VERIFY_CHECK(ctx != NULL)` for functions that use `ARG_CHECK`\n6ceea2c align shared files copyright/comments to bitcoinj's\n70141a8 Update .gitignore\n7b549b1 Merge #373: build: fix x86_64 asm detection for some compilers\nbc7c93c Merge #374: Add note about y=0 being possible on one of the sextic twists\ne457018 Merge #364: JNI rebased\n86e2d07 JNI library: cleanup, removed unimplemented code\n3093576a JNI library\nbd2895f Merge pull request #371\ne72e93a Add note about y=0 being possible on one of the sextic twists\n3f8fdfb build: fix x86_64 asm detection for some compilers\ne5a9047 [Trivial] Remove double semicolons\nc18b869 Merge pull request #360\n3026daa Merge pull request #302\n03d4611 Add sage verification script for the group laws\na965937 Merge pull request #361\n83221ec Add experimental features to configure\n5d4c5a3 Prevent damage_array in the signature test from going out of bounds.\n419bf7f Merge pull request #356\n03d84a4 Benchmark against OpenSSL verification\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 7a49cacd3937311fcb1cb36b6ba3336fca811991",
      "tree": {
        "sha": "cfd05e78e0a117016efa89cd75e4ac5a938219cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cfd05e78e0a117016efa89cd75e4ac5a938219cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b2135359b3ad37cf2ac09b008079ddb237eff2c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2135359b3ad37cf2ac09b008079ddb237eff2c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b2135359b3ad37cf2ac09b008079ddb237eff2c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2135359b3ad37cf2ac09b008079ddb237eff2c9/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ad54630935d1f340666de7bc9ffef9b8a1df296"
      }
    ],
    "stats": {
      "total": 4100,
      "additions": 3905,
      "deletions": 195
    },
    "files": [
      {
        "sha": "efb277d3470657ab7ebef58ffe7687feb57de3c8",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -25,17 +25,24 @@ config.status\n libtool\n .deps/\n .dirstamp\n-build-aux/\n *.lo\n *.o\n *~\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h\n-m4/libtool.m4\n-m4/ltoptions.m4\n-m4/ltsugar.m4\n-m4/ltversion.m4\n-m4/lt~obsolete.m4\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n src/stamp-h1\n libsecp256k1.pc"
      },
      {
        "sha": "2c5c63adadcb193b73d3302d78136c3ab6826674",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -6,26 +6,31 @@ addons:\n compiler:\n   - clang\n   - gcc\n+cache:\n+  directories:\n+  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no  EXPERIMENTAL=no\n+    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n     - SCALAR=64bit\n     - FIELD=64bit     RECOVERY=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes\n+    - FIELD=32bit     SCHNORR=yes EXPERIMENTAL=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n+    - BUILD=check-java ECDH=yes SCHNORR=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -55,9 +60,11 @@ matrix:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+before_install: mkdir -p `dirname $GUAVA_JAR`\n+install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "3d130bdcbd71784fa6f7bbd039bb732131d28f7c",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 62,
        "deletions": 10,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,6 +1,12 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n+if USE_JNI\n+JNI_LIB = libsecp256k1_jni.la\n+noinst_LTLIBRARIES = $(JNI_LIB)\n+else\n+JNI_LIB =\n+endif\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n@@ -32,6 +38,7 @@ noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n@@ -45,35 +52,80 @@ noinst_HEADERS += contrib/lax_der_parsing.c\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.h\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.c\n \n+if USE_EXTERNAL_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+else\n+COMMON_LIB =\n+endif\n+\n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n+if USE_EXTERNAL_ASM\n+if USE_ASM_ARM\n+libsecp256k1_common_la_SOURCES = src/asm/field_10x26_arm.s\n+endif\n+endif\n+\n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(SECP_LIBS)\n+libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n \n+libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n+libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal\n bench_verify_SOURCES = src/bench_verify.c\n-bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n-bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n-bench_internal_LDADD = $(SECP_LIBS)\n-bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n+bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS = tests\n endif\n \n+JAVAROOT=src/java\n+JAVAORG=org/bitcoin\n+JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n+CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n+JAVA_FILES= \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n+  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n+\n+if USE_JNI\n+\n+$(JAVA_GUAVA):\n+\t@echo Guava is missing. Fetch it via: \\\n+\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n+\t@false\n+\n+.stamp-java: $(JAVA_FILES)\n+\t@echo   Compiling $^\n+\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n+\t@touch $@\n+\n+if USE_TESTS\n+\n+check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n+\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n+\n+endif\n+endif\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n CFLAGS_FOR_BUILD += -Wall -Wextra -Wno-unused-function\n@@ -93,10 +145,10 @@ $(bench_internal_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "8cd344ea81232413cf9004bc50dec4ec2fe112a6",
        "filename": "README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n Optimized C library for EC operations on curve secp256k1.\n "
      },
      {
        "sha": "1fc36276144a2fb7740c436bd53f09f42b12daff",
        "filename": "build-aux/m4/ax_jni_include_dir.m4",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_jni_include_dir.m4?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,140 @@\n+# ===========================================================================\n+#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_JNI_INCLUDE_DIR\n+#\n+# DESCRIPTION\n+#\n+#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n+#   programs using the JNI interface.\n+#\n+#   JNI include directories are usually in the Java distribution. This is\n+#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n+#   that order. When this macro completes, a list of directories is left in\n+#   the variable JNI_INCLUDE_DIRS.\n+#\n+#   Example usage follows:\n+#\n+#     AX_JNI_INCLUDE_DIR\n+#\n+#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n+#     do\n+#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n+#     done\n+#\n+#   If you want to force a specific compiler:\n+#\n+#   - at the configure.in level, set JAVAC=yourcompiler before calling\n+#   AX_JNI_INCLUDE_DIR\n+#\n+#   - at the configure level, setenv JAVAC\n+#\n+#   Note: This macro can work with the autoconf M4 macros for Java programs.\n+#   This particular macro is not part of the original set of macros.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 10\n+\n+AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n+AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n+\n+JNI_INCLUDE_DIRS=\"\"\n+\n+if test \"x$JAVA_HOME\" != x; then\n+\t_JTOPDIR=\"$JAVA_HOME\"\n+else\n+\tif test \"x$JAVAC\" = x; then\n+\t\tJAVAC=javac\n+\tfi\n+\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n+\tif test \"x$_ACJNI_JAVAC\" = xno; then\n+\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n+\tfi\n+\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n+\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n+fi\n+\n+case \"$host_os\" in\n+        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+                        _JINC=\"$_JTOPDIR/Headers\";;\n+        *)              _JINC=\"$_JTOPDIR/include\";;\n+esac\n+_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n+_AS_ECHO_LOG([_JINC=$_JINC])\n+\n+# On Mac OS X 10.6.4, jni.h is a symlink:\n+# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n+# -> ../../CurrentJDK/Headers/jni.h.\n+\n+AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n+[\n+if test -f \"$_JINC/jni.h\"; then\n+  ac_cv_jni_header_path=\"$_JINC\"\n+  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+else\n+  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+  if test -f \"$_JTOPDIR/include/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+  else\n+    ac_cv_jni_header_path=none\n+  fi\n+fi\n+])\n+\n+\n+\n+# get the likely subdirectories for system specific java includes\n+case \"$host_os\" in\n+bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n+freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n+osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n+solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n+mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n+cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n+*)              _JNI_INC_SUBDIRS=\"genunix\";;\n+esac\n+\n+if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n+  # add any subdirectories that are present\n+  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n+  do\n+      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+      fi\n+  done\n+fi\n+])\n+\n+# _ACJNI_FOLLOW_SYMLINKS <path>\n+# Follows symbolic links on <path>,\n+# finally setting variable _ACJNI_FOLLOWED\n+# ----------------------------------------\n+AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n+# find the include directory relative to the javac executable\n+_cur=\"$1\"\n+while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n+        AC_MSG_CHECKING([symlink for $_cur])\n+        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n+        case \"$_slink\" in\n+        /*) _cur=\"$_slink\";;\n+        # 'X' avoids triggering unwanted echo options.\n+        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n+        esac\n+        AC_MSG_RESULT([$_cur])\n+done\n+_ACJNI_FOLLOWED=\"$_cur\"\n+])# _ACJNI"
      },
      {
        "sha": "b25d8adb92c7fd207a7f142d2328940d222d57b7",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -3,13 +3,13 @@ AC_DEFUN([SECP_INT128_CHECK],[\n has_int128=$ac_cv_type___int128\n ])\n \n-dnl \n+dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n   #include <stdint.h>]],[[\n   uint64_t a = 11, tmp;\n-  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  __asm__ __volatile__(\"movq \\@S|@0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n   ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n AC_MSG_RESULT([$has_64bit_asm])\n ])"
      },
      {
        "sha": "0743c36690c7aec009d52d4ac84ea8639fe5dfe6",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 130,
        "deletions": 16,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -29,6 +29,7 @@ AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n   AC_MSG_ERROR([c89 compiler support required])\n fi\n+AM_PROG_AS\n \n case $host_os in\n   *darwin*)\n@@ -93,23 +94,33 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n+AC_ARG_ENABLE(openssl_tests,\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    [enable_openssl_tests=$enableval],\n+    [enable_openssl_tests=auto])\n+\n+AC_ARG_ENABLE(experimental,\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    [use_experimental=$enableval],\n+    [use_experimental=no])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n-    \n+\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n     [use_ecmult_static_precomputation=$enableval],\n-    [use_ecmult_static_precomputation=yes])\n+    [use_ecmult_static_precomputation=auto])\n \n AC_ARG_ENABLE(module_ecdh,\n-    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (default is no)]),\n+    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (experimental)]),\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (default is no)]),\n+    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (experimental)]),\n     [enable_module_schnorr=$enableval],\n     [enable_module_schnorr=no])\n \n@@ -118,6 +129,11 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(jni,\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    [use_jni=$enableval],\n+    [use_jni=auto])\n+\n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n \n@@ -127,8 +143,8 @@ AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n [Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|no|auto]\n-[Specify assembly optimizations to use. Default is auto])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n+[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n \n AC_CHECK_TYPES([__int128])\n \n@@ -138,6 +154,34 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  save_cross_compiling=$cross_compiling\n+  cross_compiling=no\n+  TEMP_CC=\"$CC\"\n+  CC=\"$CC_FOR_BUILD\"\n+  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  AC_RUN_IFELSE(\n+    [AC_LANG_PROGRAM([], [return 0])],\n+    [working_native_cc=yes],\n+    [working_native_cc=no],[dnl])\n+  CC=\"$TEMP_CC\"\n+  cross_compiling=$save_cross_compiling\n+\n+  if test x\"$working_native_cc\" = x\"no\"; then\n+    set_precomp=no\n+    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    else\n+      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    fi\n+  else\n+    AC_MSG_RESULT([ok])\n+    set_precomp=yes\n+  fi\n+else\n+  set_precomp=no\n+fi\n+\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -155,6 +199,8 @@ else\n       AC_MSG_ERROR([x86_64 assembly optimization requested but not available])\n     fi\n     ;;\n+  arm)\n+    ;;\n   no)\n     ;;\n   *)\n@@ -247,10 +293,15 @@ else\n fi\n \n # select assembly optimization\n+use_external_asm=no\n+\n case $set_asm in\n x86_64)\n   AC_DEFINE(USE_ASM_X86_64, 1, [Define this symbol to enable x86_64 assembly optimizations])\n   ;;\n+arm)\n+  use_external_asm=yes\n+  ;;\n no)\n   ;;\n *)\n@@ -305,16 +356,51 @@ esac\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n-    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n-    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-    case $host in\n-    *mingw*)\n-      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-      ;;\n-    esac\n+    if test x\"$enable_openssl_tests\" != x\"no\"; then\n+      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+      case $host in\n+      *mingw*)\n+        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+        ;;\n+      esac\n+    fi\n+  else\n+    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n+    fi\n+  fi\n+else\n+  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n+  fi\n+fi\n \n+if test x\"$use_jni\" != x\"no\"; then\n+  AX_JNI_INCLUDE_DIR\n+  have_jni_dependencies=yes\n+  if test x\"$enable_module_schnorr\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test x\"$enable_module_ecdh\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$have_jni_dependencies\" = \"xno\"; then\n+    if test x\"$use_jni\" = x\"yes\"; then\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and Schnorr and try again.])\n+    fi\n+    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n+    use_jni=no\n+  else\n+    use_jni=yes\n+    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n+      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n+    done\n   fi\n fi\n \n@@ -345,18 +431,43 @@ fi\n \n AC_C_BIGENDIAN()\n \n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-\n AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n+AC_MSG_NOTICE([Using jni: $use_jni])\n+\n+if test x\"$enable_experimental\" = x\"yes\"; then\n+  AC_MSG_NOTICE([******])\n+  AC_MSG_NOTICE([WARNING: experimental build])\n+  AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n+  AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n+  AC_MSG_NOTICE([******])\n+else\n+  if test x\"$enable_module_schnorr\" = x\"yes\"; then\n+    AC_MSG_ERROR([Schnorr signature module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$enable_module_ecdh\" = x\"yes\"; then\n+    AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$set_asm\" = x\"arm\"; then\n+    AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n+  fi\n+fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n@@ -367,6 +478,9 @@ AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_pr\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n dnl make sure nothing new is exported so that we don't break the cache\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\""
      },
      {
        "sha": "a0d006f1131f47d9bb80de6d425e38912e1258f0",
        "filename": "libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/libsecp256k1.pc.in?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -5,7 +5,7 @@ includedir=@includedir@\n \n Name: libsecp256k1\n Description: Optimized C library for EC operations on curve secp256k1\n-URL: https://github.com/bitcoin/secp256k1\n+URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n Libs.private: @SECP_LIBS@"
      },
      {
        "sha": "ab580c5b23bbf786f41757b8a3800958db37c7a7",
        "filename": "sage/group_prover.sage",
        "status": "added",
        "additions": 322,
        "deletions": 0,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/group_prover.sage?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,322 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(numerator, assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  \"\"\"A set of constraints, consisting of zero and nonzero expressions.\n+\n+  Constraints can either be used to express knowledge or a requirement.\n+\n+  Both the fields zero and nonzero are maps from expressions to description\n+  strings. The expressions that are the keys in zero are required to be zero,\n+  and the expressions that are the keys in nonzero are required to be nonzero.\n+\n+  Note that (a != 0) and (b != 0) is the same as (a*b != 0), so all keys in\n+  nonzero could be multiplied into a single key. This is often much less\n+  efficient to work with though, so we keep them separate inside the\n+  constraints. This allows higher-level code to do fast checks on the individual\n+  nonzero elements, or combine them if needed for stronger checks.\n+\n+  We can't multiply the different zero elements, as it would suffice for one of\n+  the factors to be zero, instead of all of them. Instead, the zero elements are\n+  typically combined into an ideal first.\n+  \"\"\"\n+\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(numerator, con.zero))\n+  if 1 in zero:\n+    return True\n+  # First a cheap check whether any of the individual nonzero terms conflict on\n+  # their own.\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, knowing\n+  # that either x or y is zero is equivalent to having x*y in the zero set.\n+  # Having x or y individually in the nonzero set is not a conflict, but both\n+  # simultaneously is, so that is the right thing to check for.\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = set()\n+  for nz in map(numerator, assume.nonzero):\n+    for (f,n) in nz.factor():\n+      nonzero.add(f)\n+    rnz = zero.reduce(nz)\n+    for (f,n) in rnz.factor():\n+      nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if numerator(expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: numerator(a)*numerator(b), exprs, 1)\n+  for (f, n) in allexprs.factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(numerator(allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in numerator(expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(numerator(expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = prod(x for x in assume.nonzero)\n+  expl = []\n+  for expr in exprs:\n+    if not expr.iszero(zero):\n+      expl.append(exprs[expr])\n+  if not expl:\n+    return (True, None)\n+  return (False, expl)\n+\n+\n+def describe_extra(R, assume, assumeExtra):\n+  \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n+  zerox = assume.zero.copy()\n+  zerox.update(assumeExtra.zero)\n+  zero = R.ideal(map(numerator, assume.zero))\n+  zeroextra = R.ideal(map(numerator, zerox))\n+  nonzero = get_nonzero_set(R, assume)\n+  ret = set()\n+  # Iterate over the extra zero expressions\n+  for base in assumeExtra.zero:\n+    if base not in zero:\n+      add = []\n+      for (f, n) in numerator(base).factor():\n+        if f not in nonzero:\n+          add += [\"%s\" % f]\n+      if add:\n+        ret.add((\" * \".join(add)) + \" = 0 [%s]\" % assumeExtra.zero[base])\n+  # Iterate over the extra nonzero expressions\n+  for nz in assumeExtra.nonzero:\n+    nzr = zeroextra.reduce(numerator(nz))\n+    if nzr not in zeroextra:\n+      for (f,n) in nzr.factor():\n+        if zeroextra.reduce(f) not in nonzero:\n+          ret.add(\"%s != 0\" % zeroextra.reduce(f))\n+  return \", \".join(x for x in ret)\n+\n+\n+def check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require):\n+  \"\"\"Check a set of zero and nonzero requirements, given a set of zero and nonzero assumptions\"\"\"\n+  assume = assumeLaw + assumeAssert + assumeBranch\n+\n+  if conflicts(R, assume):\n+    # This formula does not apply\n+    return None\n+\n+  describe = describe_extra(R, assumeLaw + assumeBranch, assumeAssert)\n+\n+  ok, msg = prove_zero(R, require.zero, assume)\n+  if not ok:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(msg), describe)\n+\n+  res, expl = prove_nonzero(R, require.nonzero, assume)\n+  if not res:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(expl), describe)\n+\n+  if describe != \"\":\n+    return \"OK (assuming %s)\" % describe\n+  else:\n+    return \"OK\"\n+\n+\n+def concrete_verify(c):\n+  for k in c.zero:\n+    if k != 0:\n+      return (False, c.zero[k])\n+  for k in c.nonzero:\n+    if k == 0:\n+      return (False, c.nonzero[k])\n+  return (True, None)"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "sage/secp256k1.sage",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/sage/secp256k1.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/sage/secp256k1.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/secp256k1.sage?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h2 * h\n+  h = h * b.Z\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge_var, which assume bz==1\"\"\"\n+  if branch == 0:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z12 = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if (branch == 2):\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if (branch == 3):\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_zinv_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_zinv_var\"\"\"\n+  bzinv = b.Z^(-1)\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={b.Infinity : 'b_infinite'}), a)\n+  if branch == 1:\n+    bzinv2 = bzinv^2\n+    bzinv3 = bzinv2 * bzinv\n+    rx = b.X * bzinv2\n+    ry = b.Y * bzinv3\n+    rz = 1\n+    return (constraints(), constraints(zero={b.Infinity : 'b_finite'}, nonzero={a.Infinity : 'a_infinite'}), jacobianpoint(rx, ry, rz))\n+  azz = a.Z * bzinv\n+  z12 = azz^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * azz\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z\n+  rz = rz * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge\"\"\"\n+  zeroes = {}\n+  nonzeroes = {}\n+  a_infinity = False\n+  if (branch & 4) != 0:\n+    nonzeroes.update({a.Infinity : 'a_infinite'})\n+    a_infinity = True\n+  else:\n+    zeroes.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  rr = t^2\n+  m_alt = -u2\n+  tt = u1 * m_alt\n+  rr = rr + tt\n+  degenerate = (branch & 3) == 3\n+  if (branch & 1) != 0:\n+    zeroes.update({m : 'm_zero'})\n+  else:\n+    nonzeroes.update({m : 'm_nonzero'})\n+  if (branch & 2) != 0:\n+    zeroes.update({rr : 'rr_zero'})\n+  else:\n+    nonzeroes.update({rr : 'rr_nonzero'})\n+  rr_alt = s1\n+  rr_alt = rr_alt * 2\n+  m_alt = m_alt + u1\n+  if not degenerate:\n+    rr_alt = rr\n+    m_alt = m\n+  n = m_alt^2\n+  q = n * t\n+  n = n^2\n+  if degenerate:\n+    n = m\n+  t = rr_alt^2\n+  rz = a.Z * m_alt\n+  infinity = False\n+  if (branch & 8) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    zeroes.update({rz : 'r.z=0'})\n+  else:\n+    nonzeroes.update({rz : 'r.z!=0'})\n+  rz = rz * 2\n+  q = -q\n+  t = t + q\n+  rx = t\n+  t = t * 2\n+  t = t + q\n+  t = t * rr_alt\n+  t = t + n\n+  ry = -t\n+  rx = rx * 4\n+  ry = ry * 4\n+  if a_infinity:\n+    rx = b.X\n+    ry = b.Y\n+    rz = 1\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_old(branch, a, b):\n+  \"\"\"libsecp256k1's old secp256k1_gej_add_ge, which fails when ay+by=0 but ax!=bx\"\"\"\n+  a_infinity = (branch & 1) != 0\n+  zero = {}\n+  nonzero = {}\n+  if a_infinity:\n+    nonzero.update({a.Infinity : 'a_infinite'})\n+  else:\n+    zero.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  z = a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  n = m^2\n+  q = n * t\n+  n = n^2\n+  rr = t^2\n+  t = u1 * u2\n+  t = -t\n+  rr = rr + t\n+  t = rr^2\n+  rz = m * z\n+  infinity = False\n+  if (branch & 2) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    else:\n+      return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(nonzero={z : 'conflict_a'}, zero={z : 'conflict_b'}), point_at_infinity())\n+    zero.update({rz : 'r.z=0'})\n+  else:\n+    nonzero.update({rz : 'r.z!=0'})\n+  rz = rz * (0 if a_infinity else 2)\n+  rx = t\n+  q = -q\n+  rx = rx + q\n+  q = q * 3\n+  t = t * 2\n+  t = t + q\n+  t = t * rr\n+  t = t + n\n+  ry = -t\n+  rx = rx * (0 if a_infinity else 4)\n+  ry = ry * (0 if a_infinity else 4)\n+  t = b.X\n+  t = t * (1 if a_infinity else 0)\n+  rx = rx + t\n+  t = b.Y\n+  t = t * (1 if a_infinity else 0)\n+  ry = ry + t\n+  t = (1 if a_infinity else 0)\n+  rz = rz + t\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), jacobianpoint(rx, ry, rz))\n+\n+if __name__ == \"__main__\":\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old)\n+\n+  if len(sys.argv) >= 2 and sys.argv[1] == \"--exhaustive\":\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old, 43)"
      },
      {
        "sha": "03ef2ec901ea9cafa47b4ccdce7bbba61279930f",
        "filename": "sage/weierstrass_prover.sage",
        "status": "added",
        "additions": 264,
        "deletions": 0,
        "changes": 264,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/weierstrass_prover.sage?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,264 @@\n+# Prover implementation for Weierstrass curves of the form\n+# y^2 = x^3 + A * x + B, specifically with a = 0 and b = 7, with group laws\n+# operating on affine and Jacobian coordinates, including the point at infinity\n+# represented by a 4th variable in coordinates.\n+\n+load(\"group_prover.sage\")\n+\n+\n+class affinepoint:\n+  def __init__(self, x, y, infinity=0):\n+    self.x = x\n+    self.y = y\n+    self.infinity = infinity\n+  def __str__(self):\n+    return \"affinepoint(x=%s,y=%s,inf=%s)\" % (self.x, self.y, self.infinity)\n+\n+\n+class jacobianpoint:\n+  def __init__(self, x, y, z, infinity=0):\n+    self.X = x\n+    self.Y = y\n+    self.Z = z\n+    self.Infinity = infinity\n+  def __str__(self):\n+    return \"jacobianpoint(X=%s,Y=%s,Z=%s,inf=%s)\" % (self.X, self.Y, self.Z, self.Infinity)\n+\n+\n+def point_at_infinity():\n+  return jacobianpoint(1, 1, 1, 1)\n+\n+\n+def negate(p):\n+  if p.__class__ == affinepoint:\n+    return affinepoint(p.x, -p.y)\n+  if p.__class__ == jacobianpoint:\n+    return jacobianpoint(p.X, -p.Y, p.Z)\n+  assert(False)\n+\n+\n+def on_weierstrass_curve(A, B, p):\n+  \"\"\"Return a set of zero-expressions for an affine point to be on the curve\"\"\"\n+  return constraints(zero={p.x^3 + A*p.x + B - p.y^2: 'on_curve'})\n+\n+\n+def tangential_to_weierstrass_curve(A, B, p12, p3):\n+  \"\"\"Return a set of zero-expressions for ((x12,y12),(x3,y3)) to be a line that is tangential to the curve at (x12,y12)\"\"\"\n+  return constraints(zero={\n+    (p12.y - p3.y) * (p12.y * 2) - (p12.x^2 * 3 + A) * (p12.x - p3.x): 'tangential_to_curve'\n+  })\n+\n+\n+def colinear(p1, p2, p3):\n+  \"\"\"Return a set of zero-expressions for ((x1,y1),(x2,y2),(x3,y3)) to be collinear\"\"\"\n+  return constraints(zero={\n+    (p1.y - p2.y) * (p1.x - p3.x) - (p1.y - p3.y) * (p1.x - p2.x): 'colinear_1',\n+    (p2.y - p3.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p2.x - p3.x): 'colinear_2',\n+    (p3.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p3.x - p1.x): 'colinear_3'\n+  })\n+\n+\n+def good_affine_point(p):\n+  return constraints(nonzero={p.x : 'nonzero_x', p.y : 'nonzero_y'})\n+\n+\n+def good_jacobian_point(p):\n+  return constraints(nonzero={p.X : 'nonzero_X', p.Y : 'nonzero_Y', p.Z^6 : 'nonzero_Z'})\n+\n+\n+def good_point(p):\n+  return constraints(nonzero={p.Z^6 : 'nonzero_X'})\n+\n+\n+def finite(p, *affine_fns):\n+  con = good_point(p) + constraints(zero={p.Infinity : 'finite_point'})\n+  if p.Z != 0:\n+    return con + reduce(lambda a, b: a + b, (f(affinepoint(p.X / p.Z^2, p.Y / p.Z^3)) for f in affine_fns), con)\n+  else:\n+    return con\n+\n+def infinite(p):\n+  return constraints(nonzero={p.Infinity : 'infinite_point'})\n+\n+\n+def law_jacobian_weierstrass_add(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian add, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(nonzero={pa.x - pb.x : 'different_x'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             colinear(pa, pb, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_double(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian doubling, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y - pb.y : 'equal_y'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             tangential_to_weierstrass_curve(A, B, pa, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_opposites(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y + pb.y : 'opposite_y'}))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_a(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pb) +\n+               infinite(pA) +\n+               finite(pB))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pb.x : 'c.x=b.x', pc.y - pb.y : 'c.y=b.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_b(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               infinite(pB) +\n+               finite(pA))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pa.x : 'c.x=a.x', pc.y - pa.y : 'c.y=a.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_ab(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               infinite(pA) +\n+               infinite(pB))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+laws_jacobian_weierstrass = {\n+  'add': law_jacobian_weierstrass_add,\n+  'double': law_jacobian_weierstrass_double,\n+  'add_opposite': law_jacobian_weierstrass_add_opposites,\n+  'add_infinite_a': law_jacobian_weierstrass_add_infinite_a,\n+  'add_infinite_b': law_jacobian_weierstrass_add_infinite_b,\n+  'add_infinite_ab': law_jacobian_weierstrass_add_infinite_ab\n+}\n+\n+\n+def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n+  F = Integers(p)\n+  print \"Formula %s on Z%i:\" % (name, p)\n+  points = []\n+  for x in xrange(0, p):\n+    for y in xrange(0, p):\n+      point = affinepoint(F(x), F(y))\n+      r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n+      if r:\n+        points.append(point)\n+\n+  for za in xrange(1, p):\n+    for zb in xrange(1, p):\n+      for pa in points:\n+        for pb in points:\n+          for ia in xrange(2):\n+            for ib in xrange(2):\n+              pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n+              pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n+              for branch in xrange(0, branches):\n+                assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n+                pC.X = F(pC.X)\n+                pC.Y = F(pC.Y)\n+                pC.Z = F(pC.Z)\n+                pC.Infinity = F(pC.Infinity)\n+                r, e = concrete_verify(assumeAssert + assumeBranch)\n+                if r:\n+                  match = False\n+                  for key in laws_jacobian_weierstrass:\n+                    assumeLaw, require = laws_jacobian_weierstrass[key](A, B, pa, pb, pA, pB, pC)\n+                    r, e = concrete_verify(assumeLaw)\n+                    if r:\n+                      if match:\n+                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                      else:\n+                        match = True\n+                      r, e = concrete_verify(require)\n+                      if not r:\n+                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n+  print\n+\n+\n+def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n+  assumeLaw, require = f(A, B, pa, pb, pA, pB, pC)\n+  return check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require)\n+\n+def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve symbolically\"\"\"\n+  R.<ax,bx,ay,by,Az,Bz,Ai,Bi> = PolynomialRing(QQ,8,order='invlex')\n+  lift = lambda x: fastfrac(R,x)\n+  ax = lift(ax)\n+  ay = lift(ay)\n+  Az = lift(Az)\n+  bx = lift(bx)\n+  by = lift(by)\n+  Bz = lift(Bz)\n+  Ai = lift(Ai)\n+  Bi = lift(Bi)\n+\n+  pa = affinepoint(ax, ay, Ai)\n+  pb = affinepoint(bx, by, Bi)\n+  pA = jacobianpoint(ax * Az^2, ay * Az^3, Az, Ai)\n+  pB = jacobianpoint(bx * Bz^2, by * Bz^3, Bz, Bi)\n+\n+  res = {}\n+\n+  for key in laws_jacobian_weierstrass:\n+    res[key] = []\n+\n+  print (\"Formula \" + name + \":\")\n+  count = 0\n+  for branch in xrange(branches):\n+    assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n+    pC.X = lift(pC.X)\n+    pC.Y = lift(pC.Y)\n+    pC.Z = lift(pC.Z)\n+    pC.Infinity = lift(pC.Infinity)\n+\n+    for key in laws_jacobian_weierstrass:\n+      res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n+\n+  for key in res:\n+    print \"  %s:\" % key\n+    val = res[key]\n+    for x in val:\n+      if x[0] is not None:\n+        print \"    branch %i: %s\" % (x[1], x[0])\n+\n+  print"
      },
      {
        "sha": "5df561f2fc939e332dae7137345a18fdef9906eb",
        "filename": "src/asm/field_10x26_arm.s",
        "status": "added",
        "additions": 919,
        "deletions": 0,
        "changes": 919,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/asm/field_10x26_arm.s?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,919 @@\n+@ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n+/**********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                        *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+/*\n+ARM implementation of field_10x26 inner loops.\n+\n+Note:\n+\n+- To avoid unnecessary loads and make use of available registers, two\n+  'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n+  which will be added to c and d respectively in the the even passes\n+\n+*/\n+\n+\t.syntax unified\n+\t.arch armv7-a\n+\t@ eabi attributes - see readelf -A\n+\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n+\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n+\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n+\t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n+\t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n+\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Agressive Speed\n+\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n+\t.text\n+\n+\t@ Field constants\n+\t.set field_R0, 0x3d10\n+\t.set field_R1, 0x400\n+\t.set field_not_M, 0xfc000000\t@ ~M = ~0x3ffffff\n+\n+\t.align\t2\n+\t.global secp256k1_fe_mul_inner\n+\t.type\tsecp256k1_fe_mul_inner, %function\n+\t@ Arguments:\n+\t@  r0  r      Restrict: can overlap with a, not with b\n+\t@  r1  a\n+\t@  r2  b\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_mul_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r2       b (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\n+\t/* A - interleaved with B */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tldr\tr8, [r2, #9*4]\t\t\t@ b[9]\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]\n+\tumull\tr5, r6, r7, r8\t\t\t@ d = a[0] * b[9]\n+\tldr\tr14, [r2, #8*4]\t\t\t@ b[8]\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[1] * b[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[1] * b[8]\n+\tldr\tr8, [r2, #7*4] \t\t\t@ b[7]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[2] * b[8]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[2] * b[7]\n+\tldr\tr14, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[3] * b[7]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[3] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[4] * b[6]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[5]\n+\tldr\tr14, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[5] * b[5]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[5] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[6] * b[4]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[3]\n+\tldr\tr14, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[7] * b[3]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[7] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[8] * b[2]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[1]\n+\tldr\tr14, [r2, #0*4]   \t\t@ b[0]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[9] * b[1]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[9] * b[0]\n+\t@ r7,r14 used in B\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 4*9]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tumull\tr3, r4, r7, r14   \t\t@ c = a[0] * b[0]\n+\tadds\tr5, r5, r9       \t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C - interleaved with D */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[2]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[1]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[0]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[2] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[3] * b[9]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[3] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[4] * b[8]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[4] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[5] * b[7]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[5] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[6]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[7] * b[5]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[4]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[3]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[2]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E - interleaved with F */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[0] * b[3]\n+\tldr\tr7, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[1] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[1] * b[2]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[2] * b[1]\n+\tldr\tr7, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[3] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[3] * b[0]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[0]\n+\tldr\tr8, [r2, #9*4]   \t\t@ b[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[9]\n+\tldr\tr7, [r1, #5*4]   \t\t@ a[5]\n+\tumull\tr9, r10, r7, r8   \t\t@ d' = a[5] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[5] * b[8]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[8]\n+\tldr\tr8, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[7]\n+\tldr\tr7, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[7] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[7] * b[6]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[5]\n+\tldr\tr7, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[9] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[9] * b[4]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G - interleaved with H */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[6]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[5]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[4]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[3]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[2]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[1]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[0]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[7] * b[9]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[8]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[7]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I - interleaved with J */\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumull   r11, r12, r7, r8   \t\t@ c' = a[0] * b[8]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[7]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[6]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[5]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[4]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[3]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[2]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[6] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[7] * b[1]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[7] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[8] * b[0]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14  \t\t@ d' = a[9] * b[9]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_mul_inner, .-secp256k1_fe_mul_inner\n+\n+\t.align\t2\n+\t.global secp256k1_fe_sqr_inner\n+\t.type\tsecp256k1_fe_sqr_inner, %function\n+\t@ Arguments:\n+\t@  r0  r\t Can overlap with a\n+\t@  r1  a\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_sqr_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r2,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\t/* A interleaved with B */\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumull\tr3, r4, r7, r7\t\t\t@ c = a[0] * a[0]\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr7, r7, asl #1\n+\tumull\tr5, r6, r7, r14\t\t\t@ d = a[0]*2 * a[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[1]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[1]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[2]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[7]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[3]*2 * a[7]\n+\tldr\tr14, [r1, #5*4]\t\t\t@ a[5]\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[6]\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[5]\n+\tumlal\tr9, r10, r14, r14\t\t@ d' += a[5] * a[5]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 9*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C interleaved with D */\n+\tldr\tr0, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr14, [r1, #1*4]\t\t\t@ a[1]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr8, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[0]*2 * a[1]\n+\tmov\tr7, r8, asl #1                  @ a[2]*2\n+\tumull\tr11, r12, r14, r14\t\t@ c' = a[1] * a[1]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[0]*2 * a[2]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[9]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[3]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[7]\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[5]*2 * a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[5]*2 * a[6]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[6] * a[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E interleaved with F */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr14, [r1, #2*4]\t\t\t@ a[2]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tldr\tr2, [r1, #4*4]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[3]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[4]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[4]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[3]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[2]\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[2] * a[2]\n+\tldr\tr14, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[4]*2 * a[9]\n+\tldr\tr7, [r1, #6*4]\t\t\t@ a[6]*2\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[5]*2 * a[9]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[5]*2 * a[8]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[6]*2 * a[8]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[6]*2 * a[7]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[7] * a[7]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G interleaved with H */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tldr\tr2, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[5]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[6]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[5]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[4]\n+\tmov\tr0, r2, asl #1\t\t\t@ a[6]*2\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[4]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[3]\n+\tldr\tr7, [r1, #7*4]\t\t\t@ a[7]*2\n+\tumlal\tr11, r12, r8, r8\t\t@ c' += a[3] * a[3]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[6]*2 * a[9]\n+\tumull\tr9, r10, r7, r14\t\t@ d' = a[7]*2 * a[9]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[7]*2 * a[8]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[8] * a[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I interleaved with J */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tldr\tr2, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[7]\n+\tldr\tr14, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[8]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[7]\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[6]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[6]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[5]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[8]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[3]*2 * a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[3]*2 * a[4]\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[4] * a[4]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[8]*2 * a[9]\n+\t@ r8 will be used in J\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tumlal\tr5, r6, r8, r8\t\t\t@ d += a[9] * a[9]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_sqr_inner, .-secp256k1_fe_sqr_inner\n+"
      },
      {
        "sha": "cde5e2dbb4e4ea1bd4fedced7ba1fecea7de8aa1",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -28,7 +28,8 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    data->ctx = secp256k1_context_create(0);\n+    /* create a context with no capabilities */\n+    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }"
      },
      {
        "sha": "0809f77bda108dacd5a9a2c6208827c985f00f54",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -181,12 +181,12 @@ void bench_field_inverse_var(void* arg) {\n     }\n }\n \n-void bench_field_sqrt_var(void* arg) {\n+void bench_field_sqrt(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt_var(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n@@ -227,6 +227,15 @@ void bench_group_add_affine_var(void* arg) {\n     }\n }\n \n+void bench_group_jacobi_var(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    }\n+}\n+\n void bench_ecmult_wnaf(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n@@ -299,6 +308,21 @@ void bench_context_sign(void* arg) {\n     }\n }\n \n+#ifndef USE_NUM_NONE\n+void bench_num_jacobi(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+    secp256k1_num nx, norder;\n+\n+    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_order_get_num(&norder);\n+    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+\n+    for (i = 0; i < 200000; i++) {\n+        secp256k1_num_jacobi(&nx, &norder);\n+    }\n+}\n+#endif\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n@@ -333,12 +357,13 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt_var\", bench_field_sqrt_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n@@ -350,5 +375,8 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n \n+#ifndef USE_NUM_NONE\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+#endif\n     return 0;\n }"
      },
      {
        "sha": "418defa0aa22a06dff07d3f1567e205235706976",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -11,6 +11,12 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+#include <openssl/bn.h>\n+#include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+#endif\n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -19,6 +25,9 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n+#ifdef ENABLE_OPENSSL_TESTS\n+    EC_GROUP* ec_group;\n+#endif\n } benchmark_verify_t;\n \n static void benchmark_verify(void* arg) {\n@@ -40,6 +49,36 @@ static void benchmark_verify(void* arg) {\n     }\n }\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+static void benchmark_verify_openssl(void* arg) {\n+    int i;\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        {\n+            EC_KEY *pkey = EC_KEY_new();\n+            const unsigned char *pubkey = &data->pubkey[0];\n+            int result;\n+\n+            CHECK(pkey != NULL);\n+            result = EC_KEY_set_group(pkey, data->ec_group);\n+            CHECK(result);\n+            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n+            CHECK(result);\n+            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n+            CHECK(result);\n+            EC_KEY_free(pkey);\n+        }\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -62,6 +101,11 @@ int main(void) {\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+#ifdef ENABLE_OPENSSL_TESTS\n+    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    EC_GROUP_free(data.ec_group);\n+#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "7a6a25318c4cf4a83ea60771755c59f7676dfc71",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 23,
        "deletions": 44,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -58,22 +58,24 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n+\n     /* 1 2 3 */\n     int u_last;\n     int u;\n \n-#ifdef USE_ENDOMORPHISM\n     int flip;\n     int bit;\n     secp256k1_scalar neg_s;\n     int not_neg_one;\n-    /* If we are using the endomorphism, we cannot handle even numbers by negating\n-     * them, since we are working with 128-bit numbers whose negations would be 256\n-     * bits, eliminating the performance advantage. Instead we use a technique from\n+    /* Note that we cannot handle even numbers by negating them to be odd, as is\n+     * done in other implementations, since if our scalars were specified to have\n+     * width < 256 for performance reasons, their negations would have width 256\n+     * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n-     * or 2 (for odd) to the number we are encoding, then compensating after the\n-     * multiplication. */\n-    /* Negative 128-bit numbers will be negated, since otherwise they are 256-bit */\n+     * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n+     * this, and having the caller compensate after doing the multiplication. */\n+\n+    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n     bit = flip ^ (s.d[0] & 1);\n@@ -89,11 +91,6 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     global_sign = secp256k1_scalar_cond_negate(&s, flip);\n     global_sign *= not_neg_one * 2 - 1;\n     skew = 1 << bit;\n-#else\n-    /* Otherwise, we just negate to force oddness */\n-    int is_even = secp256k1_scalar_is_even(&s);\n-    global_sign = secp256k1_scalar_cond_negate(&s, is_even);\n-#endif\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n@@ -127,15 +124,13 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n+    int skew_1;\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_1;\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#else\n-    int wnaf[1 + WNAF_SIZE(WINDOW_A - 1)];\n #endif\n \n     int i;\n@@ -145,18 +140,10 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n #ifdef USE_ENDOMORPHISM\n     /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n     secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    /* no need for zero correction when using endomorphism since even\n-     * numbers have one added to them anyway */\n     skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n     skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n #else\n-    int is_zero = secp256k1_scalar_is_zero(scalar);\n-    /* the wNAF ladder cannot handle zero, so bump this to one .. we will\n-     * correct the result after the fact */\n-    sc.d[0] += is_zero;\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(&sc));\n-\n-    secp256k1_wnaf_const(wnaf, sc, WINDOW_A - 1);\n+    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n #endif\n \n     /* Calculate odd multiples of a.\n@@ -179,21 +166,15 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-#ifdef USE_ENDOMORPHISM\n     i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n     i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n     secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-    i = wnaf[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n #endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n@@ -202,59 +183,57 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n             secp256k1_gej_double_nonzero(r, r, NULL);\n         }\n-#ifdef USE_ENDOMORPHISM\n+\n         n = wnaf_1[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n         n = wnaf_lam[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-        n = wnaf[i];\n-        VERIFY_CHECK(n != 0);\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n #endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n+#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_to_storage(&correction_lam_stor, a);\n+#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_ge_mul_lambda(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n-    }\n-#else\n-    /* correct for zero */\n-    r->infinity |= is_zero;\n #endif\n+    }\n }\n \n #endif"
      },
      {
        "sha": "81ae08e100b6b52ee6428eab17d15588acccdd51",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -11,6 +11,8 @@\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n+#include <string.h>\n+\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n "
      },
      {
        "sha": "c5ba074244e6ab37bc53ac7d189a339e7cd42025",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -57,6 +57,9 @@ static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n static int secp256k1_fe_is_odd(const secp256k1_fe *a);\n \n /** Compare two field elements. Requires magnitude-1 inputs. */\n+static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b);\n+\n+/** Same as secp256k1_fe_equal, but may be variable time. */\n static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b);\n \n /** Compare two field elements. Requires both inputs to be normalized */\n@@ -92,7 +95,10 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  The input's magnitude can be at most 8. The output magnitude is 1 (but not\n  *  guaranteed to be normalized). The result in r will always be a square\n  *  itself. */\n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a);\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n+\n+/** Checks whether a field element is a quadratic residue. */\n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */"
      },
      {
        "sha": "7b8c07960847ebe8a4dfde401bc6596795b83b15",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n #define _SECP256K1_FIELD_REPR_IMPL_H_\n \n-#include <stdio.h>\n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\"\n@@ -429,6 +427,14 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe *r, const secp256k1_f\n #endif\n }\n \n+#if defined(USE_EXTERNAL_ASM)\n+\n+/* External assembler implementation */\n+void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b);\n+void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a);\n+\n+#else\n+\n #ifdef VERIFY\n #define VERIFY_BITS(x, n) VERIFY_CHECK(((x) >> (n)) == 0)\n #else\n@@ -1037,7 +1043,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(r[2], 27);\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n-\n+#endif\n \n static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {\n #ifdef VERIFY"
      },
      {
        "sha": "7a99eb21eccc6bcea99d6d015bf0a7307d26db21",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -11,7 +11,6 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\""
      },
      {
        "sha": "0bf22bdd3ec887251346dac826291fd1432c13ce",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -137,7 +137,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -259,7 +259,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "52cd902eb3873993a00bb2e2b2fa11857900dd65",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 34,
        "deletions": 2,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -21,14 +21,21 @@\n #error \"Please select field implementation\"\n #endif\n \n+SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {\n+    secp256k1_fe na;\n+    secp256k1_fe_negate(&na, a, 1);\n+    secp256k1_fe_add(&na, b);\n+    return secp256k1_fe_normalizes_to_zero(&na);\n+}\n+\n SECP256K1_INLINE static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe na;\n     secp256k1_fe_negate(&na, a, 1);\n     secp256k1_fe_add(&na, b);\n     return secp256k1_fe_normalizes_to_zero_var(&na);\n }\n \n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     /** Given that p is congruent to 3 mod 4, we can compute the square root of\n      *  a mod p as the (p+1)/4'th power of a.\n      *\n@@ -123,7 +130,7 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n     /* Check that a square root was actually calculated */\n \n     secp256k1_fe_sqr(&t1, r);\n-    return secp256k1_fe_equal_var(&t1, a);\n+    return secp256k1_fe_equal(&t1, a);\n }\n \n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n@@ -280,4 +287,29 @@ static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k\n     r[0] = u;\n }\n \n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n+#ifndef USE_NUM_NONE\n+    unsigned char b[32];\n+    secp256k1_num n;\n+    secp256k1_num m;\n+    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n+    static const unsigned char prime[32] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+\n+    secp256k1_fe c = *a;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_set_bin(&m, prime, 32);\n+    return secp256k1_num_jacobi(&n, &m) >= 0;\n+#else\n+    secp256k1_fe r;\n+    return secp256k1_fe_sqrt(&r, a);\n+#endif\n+}\n+\n #endif"
      },
      {
        "sha": "d5157167447a77e94cbf04d9efa94c63cd7d0dca",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const se\n  *  and a Y coordinate that is a quadratic residue modulo p. The return value\n  *  is true iff a coordinate with the given X coordinate exists.\n  */\n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x);\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n@@ -94,6 +94,9 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n+/** Check whether a group element's y coordinate is a quadratic residue. */\n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n+\n /** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n  * a may not be zero. Constant time. */\n static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "3e9c4c410d4132dc1a2ab62075997b10645bd5f5",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 6,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_GROUP_IMPL_H_\n #define _SECP256K1_GROUP_IMPL_H_\n \n-#include <string.h>\n-\n #include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n@@ -165,19 +163,19 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe x2, x3, c;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt_var(&r->y, &c);\n+    return secp256k1_fe_sqrt(&r->y, &c);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad_var(r, x)) {\n+    if (!secp256k1_ge_set_xquad(r, x)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -251,11 +249,23 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n }\n \n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate */\n+    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n+     *\n+     * Note that there is an implementation described at\n+     *     https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n+     * which trades a multiply for a square, but in practice this is actually slower,\n+     * mainly because it requires more normalizations.\n+     */\n     secp256k1_fe t1,t2,t3,t4;\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *  \n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     r->infinity = a->infinity;\n     if (r->infinity) {\n@@ -623,4 +633,18 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n }\n #endif\n \n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n+    secp256k1_fe yz;\n+\n+    if (a->infinity) {\n+        return 0;\n+    }\n+\n+    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n+     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n+       is */\n+    secp256k1_fe_mul(&yz, &a->y, &a->z);\n+    return secp256k1_fe_is_quad_var(&yz);\n+}\n+\n #endif"
      },
      {
        "sha": "fca98cab9f8315bd4fa5c165d9f8e2f16dc2a493",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -11,7 +11,7 @@\n #include <stdint.h>\n \n typedef struct {\n-    uint32_t s[32];\n+    uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n } secp256k1_sha256_t;"
      },
      {
        "sha": "b47e65f830a906fc0eb9ff7939d62966823202b1",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -269,15 +269,13 @@ static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 0;\n }\n \n-\n+#undef BE32\n #undef Round\n-#undef sigma0\n #undef sigma1\n-#undef Sigma0\n+#undef sigma0\n #undef Sigma1\n-#undef Ch\n+#undef Sigma0\n #undef Maj\n-#undef ReadBE32\n-#undef WriteBE32\n+#undef Ch\n \n #endif"
      },
      {
        "sha": "be67048fbed69e04b799cba74232aee471782747",
        "filename": "src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 445,
        "deletions": 27,
        "changes": 472,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1.java?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,60 +1,478 @@\n+/*\n+ * Copyright 2013 Google Inc.\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package org.bitcoin;\n \n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n \n+import java.math.BigInteger;\n import com.google.common.base.Preconditions;\n-\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n- * This class holds native methods to handle ECDSA verification.\n- * You can find an example library that can be used for this at\n- * https://github.com/sipa/secp256k1\n+ * <p>This class holds native methods to handle ECDSA verification.</p>\n+ *\n+ * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n+ *\n+ * <p>To build secp256k1 for use with bitcoinj, run\n+ * `./configure --enable-jni --enable-experimental --enable-module-schnorr --enable-module-ecdh`\n+ * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n+ * or point the JVM to the folder containing it with -Djava.library.path\n+ * </p>\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+    //TODO add a 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n     }\n \n     /**\n-     * @param byteBuff signature format is byte[32] data,\n-     *        native-endian int signatureLength, native-endian int pubkeyLength,\n-     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n-     * @returns 1 for valid signature, anything else for invalid\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n      */\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] resArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(resArr.length, 32, \"Got bad result length.\");\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return resArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 randomize - updates the context randomization\n+     *\n+     * @param seed 32-byte random seed\n+     */\n+    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n+        Preconditions.checkArgument(seed.length == 32 || seed == null);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seed.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seed);\n+\n+        w.lock();\n+        try {\n+          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static byte[] schnorrSign(byte[] data, byte[] sec) throws AssertFailException {\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_schnorr_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(sigArr.length, 64, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    private static native long secp256k1_ctx_clone(long context);\n+\n+    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native void secp256k1_destroy_context(long context);\n+\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n+\n+    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n+\n+    private static native byte[][] secp256k1_schnorr_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n+\n }"
      },
      {
        "sha": "f18ce95810d138fbf40e7a0b03d9c43e3d29593f",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "added",
        "additions": 247,
        "deletions": 0,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,247 @@\n+package org.bitcoin;\n+\n+import com.google.common.io.BaseEncoding;\n+import java.util.Arrays;\n+import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n+\n+/**\n+ * This class holds test cases defined for testing this library.\n+ */\n+public class NativeSecp256k1Test {\n+\n+    //TODO improve comments/add more tests\n+    /**\n+      * This tests verify() for a valid signature\n+      */\n+    public static void testVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        assertEquals( result, true , \"testVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests verify() for a non-valid signature\n+      */\n+    public static void testVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a valid secretkey\n+      */\n+    public static void testSecKeyVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, true , \"testSecKeyVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a invalid secretkey\n+      */\n+    public static void testSecKeyVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a valid secretkey\n+      */\n+    public static void testPubKeyCreatePos() throws AssertFailException{\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a invalid secretkey\n+      */\n+    public static void testPubKeyCreateNeg() throws AssertFailException{\n+       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n+    }\n+\n+    /**\n+      * This tests sign() for a valid secretkey\n+      */\n+    public static void testSignPos() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n+    }\n+\n+    /**\n+      * This tests sign() for a invalid secretkey\n+      */\n+    public static void testSignNeg() throws AssertFailException{\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"\" , \"testSignNeg\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add\n+      */\n+    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul\n+      */\n+    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add uncompressed\n+      */\n+    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul uncompressed\n+      */\n+    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n+    }\n+\n+    /**\n+      * This tests seed randomization\n+      */\n+    public static void testRandomize() throws AssertFailException {\n+        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n+        boolean result = NativeSecp256k1.randomize(seed);\n+        assertEquals( result, true, \"testRandomize\");\n+    }\n+\n+    /**\n+      * This tests signSchnorr() for a valid secretkey\n+      */\n+    public static void testSchnorrSign() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.schnorrSign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"C5E929AA058B982048760422D3B563749B7D0E50C5EBD8CD2FFC23214BD6A2F1B072C13880997EBA847CF20F2F90FCE07C1CA33A890A4127095A351127F8D95F\" , \"testSchnorrSign\");\n+    }\n+\n+    /**\n+      * This tests signSchnorr() for a valid secretkey\n+      */\n+    public static void testCreateECDHSecret() throws AssertFailException{\n+\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n+    }\n+\n+    public static void main(String[] args) throws AssertFailException{\n+\n+\n+        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n+\n+        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n+\n+        //Test verify() success/fail\n+        testVerifyPos();\n+        testVerifyNeg();\n+\n+        //Test secKeyVerify() success/fail\n+        testSecKeyVerifyPos();\n+        testSecKeyVerifyNeg();\n+\n+        //Test computePubkey() success/fail\n+        testPubKeyCreatePos();\n+        testPubKeyCreateNeg();\n+\n+        //Test sign() success/fail\n+        testSignPos();\n+        testSignNeg();\n+\n+        //Test Schnorr (partial support) //TODO\n+        testSchnorrSign();\n+        //testSchnorrVerify\n+        //testSchnorrRecovery\n+\n+        //Test privKeyTweakAdd() 1\n+        testPrivKeyTweakAdd_1();\n+\n+        //Test privKeyTweakMul() 2\n+        testPrivKeyTweakMul_1();\n+\n+        //Test privKeyTweakAdd() 3\n+        testPrivKeyTweakAdd_2();\n+\n+        //Test privKeyTweakMul() 4\n+        testPrivKeyTweakMul_2();\n+\n+        //Test randomize()\n+        testRandomize();\n+\n+        //Test ECDH\n+        testCreateECDHSecret();\n+\n+        NativeSecp256k1.cleanup();\n+\n+        System.out.println(\" All tests passed.\" );\n+\n+    }\n+}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+public class NativeSecp256k1Util{\n+\n+    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+    }\n+\n+    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n+      if( !val.equals(val2) )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static class AssertFailException extends Exception {\n+      public AssertFailException(String message) {\n+        super( message );\n+      }\n+    }\n+}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/java/org/bitcoin/Secp256k1Context.java",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/Secp256k1Context.java?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+/**\n+ * This class holds the context reference used in native methods \n+ * to handle ECDSA operations.\n+ */\n+public class Secp256k1Context {\n+  private static final boolean enabled; //true if the library is loaded\n+  private static final long context; //ref to pointer to context obj\n+\n+  static { //static initializer\n+      boolean isEnabled = true;\n+      long contextRef = -1;\n+      try {\n+          System.loadLibrary(\"secp256k1\");\n+          contextRef = secp256k1_init_context();\n+      } catch (UnsatisfiedLinkError e) {\n+          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n+          isEnabled = false;\n+      }\n+      enabled = isEnabled;\n+      context = contextRef;\n+  }\n+\n+  public static boolean isEnabled() {\n+     return enabled;\n+  }\n+\n+  public static long getContext() {\n+     if(!enabled) return -1; //sanity check\n+     return context;\n+  }\n+\n+  private static native long secp256k1_init_context();\n+}"
      },
      {
        "sha": "dba9524dd4cc291058e70f7b6574e846d64035f3",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 400,
        "deletions": 12,
        "changes": 412,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,23 +1,411 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n #include \"org_bitcoin_NativeSecp256k1.h\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_ecdh.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#include \"include/secp256k1_schnorr.h\"\n \n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n+\n+  (void)classObject;(void)env;\n+\n+  return ctx_clone_l;\n+\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_context_randomize(ctx, seed);\n+\n+}\n+\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  secp256k1_context_destroy(ctx);\n+\n+  (void)classObject;(void)env;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n+  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n+\n+  secp256k1_ecdsa_signature sig;\n+  secp256k1_pubkey pubkey;\n+\n+  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+    if( ret ) {\n+      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n+    }\n+  }\n+\n+  (void)classObject;\n+\n+  return ret;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  secp256k1_ecdsa_signature sig[72];\n+\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+\n+  unsigned char outputSer[72];\n+  size_t outputLen = 72;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_ec_seckey_verify(ctx, secKey);\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  secp256k1_pubkey pubkey;\n+\n+  jobjectArray retArray;\n+  jbyteArray pubkeyArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n+\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n {\n-\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\tint sigLen = *((int*)(data + 32));\n-\tint pubLen = *((int*)(data + 32 + 4));\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if ( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n \n-\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }\n \n-static void __javasecp256k1_attach(void) __attribute__((constructor));\n-static void __javasecp256k1_detach(void) __attribute__((destructor));\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n+  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n+{\n+  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n \n-static void __javasecp256k1_attach(void) {\n-\tsecp256k1_start(SECP256K1_START_VERIFY);\n+  return 0;\n }\n \n-static void __javasecp256k1_detach(void) {\n-\tsecp256k1_stop();\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  unsigned char sig[64];\n+\n+  int ret = secp256k1_schnorr_sign(ctx, sig, data, secKey, NULL, NULL);\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, 64);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, 64, (jbyte*)sig);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray outArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  secp256k1_pubkey pubkey;\n+  unsigned char nonce_res[32];\n+  size_t outputLen = 32;\n+\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+  if (ret) {\n+    ret = secp256k1_ecdh(\n+      ctx,\n+      nonce_res,\n+      &pubkey,\n+      secdata\n+    );\n+  }\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  outArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }"
      },
      {
        "sha": "4125a1f5233beae400c4846ad975a7b6b47721d6",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 109,
        "deletions": 3,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -1,19 +1,125 @@\n /* DO NOT EDIT THIS FILE - it is machine generated */\n #include <jni.h>\n+#include \"include/secp256k1.h\"\n /* Header for class org_bitcoin_NativeSecp256k1 */\n \n #ifndef _Included_org_bitcoin_NativeSecp256k1\n #define _Included_org_bitcoin_NativeSecp256k1\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ctx_clone\n+ * Signature: (J)J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv *, jclass, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_context_randomize\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_destroy_context\n+ * Signature: (J)V\n+ */\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv *, jclass, jlong);\n+\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;)I\n+ * Signature: (Ljava/nio/ByteBuffer;JII)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_sign\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_seckey_verify\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_create\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n  */\n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject);\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_parse\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_schnorr_sign\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdh\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n+\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/java/org_bitcoin_Secp256k1Context.c",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_Secp256k1Context.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,15 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include \"org_bitcoin_Secp256k1Context.h\"\n+#include \"include/secp256k1.h\"\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv* env, jclass classObject)\n+{\n+  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+  (void)classObject;(void)env;\n+\n+  return (uintptr_t)ctx;\n+}\n+"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/java/org_bitcoin_Secp256k1Context.h",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_Secp256k1Context.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -0,0 +1,22 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+#include \"include/secp256k1.h\"\n+/* Header for class org_bitcoin_Secp256k1Context */\n+\n+#ifndef _Included_org_bitcoin_Secp256k1Context\n+#define _Included_org_bitcoin_Secp256k1Context\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_Secp256k1Context\n+ * Method:    secp256k1_init_context\n+ * Signature: ()J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv *, jclass);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "e3088b469790bdc14b8982931d5729a7eabde69b",
        "filename": "src/modules/ecdh/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/ecdh/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/ecdh/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/Makefile.am.include?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/ecdh/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_ecdh\n bench_ecdh_SOURCES = src/bench_ecdh.c\n-bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "bf23c26e71c5dd88df965141295bb33144007147",
        "filename": "src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/Makefile.am.include?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/recovery/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c\n-bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "f1af8e83255fd0c1e0bd7d051dcaed609bae1447",
        "filename": "src/modules/schnorr/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/Makefile.am.include?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -6,5 +6,5 @@ noinst_HEADERS += src/modules/schnorr/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_schnorr_verify\n bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "7bb9c5be8cf5a6d020ef4bfcac1af13902e5d533",
        "filename": "src/num.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -32,6 +32,9 @@ static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsi\n /** Compute a modular inverse. The input must be less than the modulus. */\n static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n \n+/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n+\n /** Compare the absolute value of two numbers. */\n static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n \n@@ -57,6 +60,9 @@ static void secp256k1_num_shift(secp256k1_num *r, int bits);\n /** Check whether a number is zero. */\n static int secp256k1_num_is_zero(const secp256k1_num *a);\n \n+/** Check whether a number is one. */\n+static int secp256k1_num_is_one(const secp256k1_num *a);\n+\n /** Check whether a number is strictly negative. */\n static int secp256k1_num_is_neg(const secp256k1_num *a);\n "
      },
      {
        "sha": "3a46495eeac7d979a87871ca20ce30c2010a54ce",
        "filename": "src/num_gmp_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -144,6 +144,32 @@ static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a,\n     memset(v, 0, sizeof(v));\n }\n \n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n+    int ret;\n+    mpz_t ga, gb;\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n+\n+    mpz_inits(ga, gb, NULL);\n+\n+    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n+    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n+    if (a->neg) {\n+        mpz_neg(ga, ga);\n+    }\n+\n+    ret = mpz_jacobi(ga, gb);\n+\n+    mpz_clears(ga, gb, NULL);\n+\n+    return ret;\n+}\n+\n+static int secp256k1_num_is_one(const secp256k1_num *a) {\n+    return (a->limbs == 1 && a->data[0] == 1);\n+}\n+\n static int secp256k1_num_is_zero(const secp256k1_num *a) {\n     return (a->limbs == 1 && a->data[0] == 0);\n }"
      },
      {
        "sha": "c5baf4df413e0895135f3c4f974998d97613e836",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_SCALAR_IMPL_H_\n #define _SECP256K1_SCALAR_IMPL_H_\n \n-#include <string.h>\n-\n #include \"group.h\"\n #include \"scalar.h\"\n "
      },
      {
        "sha": "7973d60c36a81e6bd5cc765a9e038d12b1790195",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -4,8 +4,6 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n-#define SECP256K1_BUILD (1)\n-\n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n@@ -152,7 +150,6 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pubkey, const unsigned char *input, size_t inputlen) {\n     secp256k1_ge Q;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n@@ -170,7 +167,6 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     size_t len;\n     int ret = 0;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n@@ -216,7 +212,7 @@ static void secp256k1_ecdsa_signature_save(secp256k1_ecdsa_signature* sig, const\n int secp256k1_ecdsa_signature_parse_der(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input != NULL);\n \n@@ -234,7 +230,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n \n@@ -253,7 +249,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(sig != NULL);\n@@ -265,7 +261,7 @@ int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsign\n int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n \n@@ -398,7 +394,6 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n@@ -437,7 +432,6 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -485,7 +479,6 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);"
      },
      {
        "sha": "b32cb90813718cd1feae8bea86c4c0990c96a70a",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 166,
        "deletions": 24,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2135359b3ad37cf2ac09b008079ddb237eff2c9/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "patch": "@@ -473,6 +473,8 @@ void test_num_negate(void) {\n }\n \n void test_num_add_sub(void) {\n+    int i;\n+    secp256k1_scalar s;\n     secp256k1_num n1;\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n@@ -498,13 +500,119 @@ void test_num_add_sub(void) {\n     CHECK(!secp256k1_num_eq(&n2p1, &n1));\n     secp256k1_num_sub(&n2p1, &n2p1, &n2); /* n2p1 = R2 + R1 - R2 = R1 */\n     CHECK(secp256k1_num_eq(&n2p1, &n1));\n+\n+    /* check is_one */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&n1, &s);\n+    CHECK(secp256k1_num_is_one(&n1));\n+    /* check that 2^n + 1 is never 1 */\n+    secp256k1_scalar_get_num(&n2, &s);\n+    for (i = 0; i < 250; ++i) {\n+        secp256k1_num_add(&n1, &n1, &n1);    /* n1 *= 2 */\n+        secp256k1_num_add(&n1p2, &n1, &n2);  /* n1p2 = n1 + 1 */\n+        CHECK(!secp256k1_num_is_one(&n1p2));\n+    }\n+}\n+\n+void test_num_mod(void) {\n+    int i;\n+    secp256k1_scalar s;\n+    secp256k1_num order, n;\n+\n+    /* check that 0 mod anything is 0 */\n+    random_scalar_order_test(&s); \n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_set_int(&s, 0);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that anything mod 1 is 0 */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that increasing the number past 2^256 does not break this */\n+    random_scalar_order_test(&s); \n+    secp256k1_scalar_get_num(&n, &s);\n+    /* multiply by 2^8, which'll test this case with high probability */\n+    for (i = 0; i < 8; ++i) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+}\n+\n+void test_num_jacobi(void) {\n+    secp256k1_scalar sqr;\n+    secp256k1_scalar small;\n+    secp256k1_scalar five;  /* five is not a quadratic residue */\n+    secp256k1_num order, n;\n+    int i;\n+    /* squares mod 5 are 1, 4 */\n+    const int jacobi5[10] = { 0, 1, -1, -1, 1, 0, 1, -1, -1, 1 };\n+\n+    /* check some small values with 5 as the order */\n+    secp256k1_scalar_set_int(&five, 5);\n+    secp256k1_scalar_get_num(&order, &five);\n+    for (i = 0; i < 10; ++i) {\n+        secp256k1_scalar_set_int(&small, i);\n+        secp256k1_scalar_get_num(&n, &small);\n+        CHECK(secp256k1_num_jacobi(&n, &order) == jacobi5[i]);\n+    }\n+\n+    /** test large values with 5 as group order */\n+    secp256k1_scalar_get_num(&order, &five);\n+    /* we first need a scalar which is not a multiple of 5 */\n+    do {\n+        secp256k1_num fiven;\n+        random_scalar_order_test(&sqr); \n+        secp256k1_scalar_get_num(&fiven, &five);\n+        secp256k1_scalar_get_num(&n, &sqr);\n+        secp256k1_num_mod(&n, &fiven);\n+    } while (secp256k1_num_is_zero(&n));\n+    /* next force it to be a residue. 2 is a nonresidue mod 5 so we can\n+     * just multiply by two, i.e. add the number to itself */\n+    if (secp256k1_num_jacobi(&n, &order) == -1) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+\n+    /* test residue */\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_num_add(&n, &n, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+\n+    /** test with secp group order as order */\n+    secp256k1_scalar_order_get_num(&order);\n+    random_scalar_order_test(&sqr); \n+    secp256k1_scalar_sqr(&sqr, &sqr);\n+    /* test residue */\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_scalar_mul(&sqr, &sqr, &five);\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+    /* test multiple of the order*/\n+    CHECK(secp256k1_num_jacobi(&order, &order) == 0);\n+\n+    /* check one less than the order */\n+    secp256k1_scalar_set_int(&small, 1);\n+    secp256k1_scalar_get_num(&n, &small);\n+    secp256k1_num_sub(&n, &order, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);  /* sage confirms this is 1 */\n }\n \n void run_num_smalltests(void) {\n     int i;\n     for (i = 0; i < 100*count; i++) {\n         test_num_negate();\n         test_num_add_sub();\n+        test_num_mod();\n+        test_num_jacobi();\n     }\n }\n #endif\n@@ -689,6 +797,10 @@ void scalar_test(void) {\n             secp256k1_scalar_inverse(&inv, &inv);\n             /* Inverting one must result in one. */\n             CHECK(secp256k1_scalar_is_one(&inv));\n+#ifndef USE_NUM_NONE\n+            secp256k1_scalar_get_num(&invnum, &inv);\n+            CHECK(secp256k1_num_is_one(&invnum));\n+#endif\n         }\n     }\n \n@@ -855,7 +967,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar zzv;\n #endif\n         int overflow;\n-        unsigned char chal[32][2][32] = {\n+        unsigned char chal[33][2][32] = {\n             {{0xff, 0xff, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\n               0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,\n@@ -1111,9 +1223,17 @@ void run_scalar_tests(void) {\n              {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00,\n               0xf8, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,\n-              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}}\n+              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}},\n+            {{0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03},\n+             {0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03}}\n         };\n-        unsigned char res[32][2][32] = {\n+        unsigned char res[33][2][32] = {\n             {{0x0c, 0x3b, 0x0a, 0xca, 0x8d, 0x1a, 0x2f, 0xb9,\n               0x8a, 0x7b, 0x53, 0x5a, 0x1f, 0xc5, 0x22, 0xa1,\n               0x07, 0x2a, 0x48, 0xea, 0x02, 0xeb, 0xb3, 0xd6,\n@@ -1369,10 +1489,18 @@ void run_scalar_tests(void) {\n              {0xe4, 0xf1, 0x23, 0x84, 0xe1, 0xb5, 0x9d, 0xf2,\n               0xb8, 0x73, 0x8b, 0x45, 0x2b, 0x35, 0x46, 0x38,\n               0x10, 0x2b, 0x50, 0xf8, 0x8b, 0x35, 0xcd, 0x34,\n-              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}}\n+              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}},\n+            {{0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5},\n+             {0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5}}\n         };\n         secp256k1_scalar_set_int(&one, 1);\n-        for (i = 0; i < 32; i++) {\n+        for (i = 0; i < 33; i++) {\n             secp256k1_scalar_set_b32(&x, chal[i][0], &overflow);\n             CHECK(!overflow);\n             secp256k1_scalar_set_b32(&y, chal[i][1], &overflow);\n@@ -1446,7 +1574,7 @@ void random_fe_non_zero(secp256k1_fe *nz) {\n void random_fe_non_square(secp256k1_fe *ns) {\n     secp256k1_fe r;\n     random_fe_non_zero(ns);\n-    if (secp256k1_fe_sqrt_var(&r, ns)) {\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -1641,7 +1769,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe *a, const secp256k1_fe *k) {\n     secp256k1_fe r1, r2;\n-    int v = secp256k1_fe_sqrt_var(&r1, a);\n+    int v = secp256k1_fe_sqrt(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -1951,8 +2079,8 @@ void test_add_neg_y_diff_x(void) {\n      * of the sum to be wrong (since infinity has no xy coordinates).\n      * HOWEVER, if the x-coordinates are different, infinity is the\n      * wrong answer, and such degeneracies are exposed. This is the\n-     * root of https://github.com/bitcoin/secp256k1/issues/257 which\n-     * this test is a regression test for.\n+     * root of https://github.com/bitcoin-core/secp256k1/issues/257\n+     * which this test is a regression test for.\n      *\n      * These points were generated in sage as\n      * # secp256k1 params\n@@ -2051,15 +2179,16 @@ void run_ec_combine(void) {\n void test_group_decompress(const secp256k1_fe* x) {\n     /* The input itself, normalized. */\n     secp256k1_fe fex = *x;\n-    secp256k1_fe tmp;\n+    secp256k1_fe fez;\n     /* Results of set_xquad_var, set_xo_var(..., 0), set_xo_var(..., 1). */\n     secp256k1_ge ge_quad, ge_even, ge_odd;\n+    secp256k1_gej gej_quad;\n     /* Return values of the above calls. */\n     int res_quad, res_even, res_odd;\n \n     secp256k1_fe_normalize_var(&fex);\n \n-    res_quad = secp256k1_ge_set_xquad_var(&ge_quad, &fex);\n+    res_quad = secp256k1_ge_set_xquad(&ge_quad, &fex);\n     res_even = secp256k1_ge_set_xo_var(&ge_even, &fex, 0);\n     res_odd = secp256k1_ge_set_xo_var(&ge_odd, &fex, 1);\n \n@@ -2085,13 +2214,29 @@ void test_group_decompress(const secp256k1_fe* x) {\n         CHECK(secp256k1_fe_equal_var(&ge_odd.x, x));\n \n         /* Check that the Y coordinate result in ge_quad is a square. */\n-        CHECK(secp256k1_fe_sqrt_var(&tmp, &ge_quad.y));\n-        secp256k1_fe_sqr(&tmp, &tmp);\n-        CHECK(secp256k1_fe_equal_var(&tmp, &ge_quad.y));\n+        CHECK(secp256k1_fe_is_quad_var(&ge_quad.y));\n \n         /* Check odd/even Y in ge_odd, ge_even. */\n         CHECK(secp256k1_fe_is_odd(&ge_odd.y));\n         CHECK(!secp256k1_fe_is_odd(&ge_even.y));\n+\n+        /* Check secp256k1_gej_has_quad_y_var. */\n+        secp256k1_gej_set_ge(&gej_quad, &ge_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n     }\n }\n \n@@ -2383,9 +2528,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, shift;\n     int wnaf[256] = {0};\n     int i;\n-#ifdef USE_ENDOMORPHISM\n     int skew;\n-#endif\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2395,10 +2538,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n-#else\n-    secp256k1_wnaf_const(wnaf, num, w);\n #endif\n+    skew = secp256k1_wnaf_const(wnaf, num, w);\n \n     for (i = WNAF_SIZE(w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -2417,10 +2558,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         }\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n-#ifdef USE_ENDOMORPHISM\n-    /* Skew num because when encoding 128-bit numbers as odd we use an offset */\n+    /* Skew num because when encoding numbers as odd we use an offset */\n     secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n-#endif\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3484,12 +3623,14 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n+#ifdef ENABLE_OPENSSL_TESTS\n     static const unsigned char max_scalar[32] = {\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n         0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n         0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n     };\n+#endif\n \n     int ret = 0;\n \n@@ -3607,13 +3748,13 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n     int action = secp256k1_rand_bits(3);\n-    if (action < 1) {\n+    if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n         pos = secp256k1_rand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n-    } else if (action < 2) {\n+    } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n         pos = secp256k1_rand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n@@ -3785,6 +3926,7 @@ void run_ecdsa_der_parse(void) {\n         int certainly_der = 0;\n         int certainly_not_der = 0;\n         random_ber_signature(buffer, &buflen, &certainly_der, &certainly_not_der);\n+        CHECK(buflen <= 2048);\n         for (j = 0; j < 16; j++) {\n             int ret = 0;\n             if (j > 0) {"
      }
    ]
  },
  {
    "sha": "0237096df5299e9f0947e902153d93932f2ea13b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjM3MDk2ZGY1Mjk5ZTlmMDk0N2U5MDIxNTNkOTM5MzJmMmVhMTNi",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-08-16T09:34:12Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-08-16T09:34:43Z"
      },
      "message": "Merge commit 'b2135359b3ad37cf2ac09b008079ddb237eff2c9'",
      "tree": {
        "sha": "0f42855d4cb68d8d4e7b69a85515eb46cf8b6b5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f42855d4cb68d8d4e7b69a85515eb46cf8b6b5b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0237096df5299e9f0947e902153d93932f2ea13b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0237096df5299e9f0947e902153d93932f2ea13b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0237096df5299e9f0947e902153d93932f2ea13b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0237096df5299e9f0947e902153d93932f2ea13b/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2c2d471e18f0601c2767cf516425b2ecfcfd2126",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c2d471e18f0601c2767cf516425b2ecfcfd2126",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2c2d471e18f0601c2767cf516425b2ecfcfd2126"
      },
      {
        "sha": "b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2135359b3ad37cf2ac09b008079ddb237eff2c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b2135359b3ad37cf2ac09b008079ddb237eff2c9"
      }
    ],
    "stats": {
      "total": 4100,
      "additions": 3905,
      "deletions": 195
    },
    "files": [
      {
        "sha": "efb277d3470657ab7ebef58ffe7687feb57de3c8",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -25,17 +25,24 @@ config.status\n libtool\n .deps/\n .dirstamp\n-build-aux/\n *.lo\n *.o\n *~\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h\n-m4/libtool.m4\n-m4/ltoptions.m4\n-m4/ltsugar.m4\n-m4/ltversion.m4\n-m4/lt~obsolete.m4\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n src/stamp-h1\n libsecp256k1.pc"
      },
      {
        "sha": "2c5c63adadcb193b73d3302d78136c3ab6826674",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -6,26 +6,31 @@ addons:\n compiler:\n   - clang\n   - gcc\n+cache:\n+  directories:\n+  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no  EXPERIMENTAL=no\n+    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n     - SCALAR=64bit\n     - FIELD=64bit     RECOVERY=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes\n+    - FIELD=32bit     SCHNORR=yes EXPERIMENTAL=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n+    - BUILD=check-java ECDH=yes SCHNORR=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -55,9 +60,11 @@ matrix:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+before_install: mkdir -p `dirname $GUAVA_JAR`\n+install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "3d130bdcbd71784fa6f7bbd039bb732131d28f7c",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 62,
        "deletions": 10,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -1,6 +1,12 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n+if USE_JNI\n+JNI_LIB = libsecp256k1_jni.la\n+noinst_LTLIBRARIES = $(JNI_LIB)\n+else\n+JNI_LIB =\n+endif\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n@@ -32,6 +38,7 @@ noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n@@ -45,35 +52,80 @@ noinst_HEADERS += contrib/lax_der_parsing.c\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.h\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.c\n \n+if USE_EXTERNAL_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+else\n+COMMON_LIB =\n+endif\n+\n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n+if USE_EXTERNAL_ASM\n+if USE_ASM_ARM\n+libsecp256k1_common_la_SOURCES = src/asm/field_10x26_arm.s\n+endif\n+endif\n+\n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(SECP_LIBS)\n+libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n \n+libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n+libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal\n bench_verify_SOURCES = src/bench_verify.c\n-bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n-bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n-bench_internal_LDADD = $(SECP_LIBS)\n-bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n+bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS = tests\n endif\n \n+JAVAROOT=src/java\n+JAVAORG=org/bitcoin\n+JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n+CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n+JAVA_FILES= \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n+  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n+\n+if USE_JNI\n+\n+$(JAVA_GUAVA):\n+\t@echo Guava is missing. Fetch it via: \\\n+\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n+\t@false\n+\n+.stamp-java: $(JAVA_FILES)\n+\t@echo   Compiling $^\n+\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n+\t@touch $@\n+\n+if USE_TESTS\n+\n+check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n+\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n+\n+endif\n+endif\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n CFLAGS_FOR_BUILD += -Wall -Wextra -Wno-unused-function\n@@ -93,10 +145,10 @@ $(bench_internal_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "8cd344ea81232413cf9004bc50dec4ec2fe112a6",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n Optimized C library for EC operations on curve secp256k1.\n "
      },
      {
        "sha": "1fc36276144a2fb7740c436bd53f09f42b12daff",
        "filename": "src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,140 @@\n+# ===========================================================================\n+#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_JNI_INCLUDE_DIR\n+#\n+# DESCRIPTION\n+#\n+#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n+#   programs using the JNI interface.\n+#\n+#   JNI include directories are usually in the Java distribution. This is\n+#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n+#   that order. When this macro completes, a list of directories is left in\n+#   the variable JNI_INCLUDE_DIRS.\n+#\n+#   Example usage follows:\n+#\n+#     AX_JNI_INCLUDE_DIR\n+#\n+#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n+#     do\n+#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n+#     done\n+#\n+#   If you want to force a specific compiler:\n+#\n+#   - at the configure.in level, set JAVAC=yourcompiler before calling\n+#   AX_JNI_INCLUDE_DIR\n+#\n+#   - at the configure level, setenv JAVAC\n+#\n+#   Note: This macro can work with the autoconf M4 macros for Java programs.\n+#   This particular macro is not part of the original set of macros.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 10\n+\n+AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n+AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n+\n+JNI_INCLUDE_DIRS=\"\"\n+\n+if test \"x$JAVA_HOME\" != x; then\n+\t_JTOPDIR=\"$JAVA_HOME\"\n+else\n+\tif test \"x$JAVAC\" = x; then\n+\t\tJAVAC=javac\n+\tfi\n+\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n+\tif test \"x$_ACJNI_JAVAC\" = xno; then\n+\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n+\tfi\n+\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n+\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n+fi\n+\n+case \"$host_os\" in\n+        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+                        _JINC=\"$_JTOPDIR/Headers\";;\n+        *)              _JINC=\"$_JTOPDIR/include\";;\n+esac\n+_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n+_AS_ECHO_LOG([_JINC=$_JINC])\n+\n+# On Mac OS X 10.6.4, jni.h is a symlink:\n+# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n+# -> ../../CurrentJDK/Headers/jni.h.\n+\n+AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n+[\n+if test -f \"$_JINC/jni.h\"; then\n+  ac_cv_jni_header_path=\"$_JINC\"\n+  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+else\n+  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+  if test -f \"$_JTOPDIR/include/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+  else\n+    ac_cv_jni_header_path=none\n+  fi\n+fi\n+])\n+\n+\n+\n+# get the likely subdirectories for system specific java includes\n+case \"$host_os\" in\n+bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n+freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n+osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n+solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n+mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n+cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n+*)              _JNI_INC_SUBDIRS=\"genunix\";;\n+esac\n+\n+if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n+  # add any subdirectories that are present\n+  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n+  do\n+      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+      fi\n+  done\n+fi\n+])\n+\n+# _ACJNI_FOLLOW_SYMLINKS <path>\n+# Follows symbolic links on <path>,\n+# finally setting variable _ACJNI_FOLLOWED\n+# ----------------------------------------\n+AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n+# find the include directory relative to the javac executable\n+_cur=\"$1\"\n+while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n+        AC_MSG_CHECKING([symlink for $_cur])\n+        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n+        case \"$_slink\" in\n+        /*) _cur=\"$_slink\";;\n+        # 'X' avoids triggering unwanted echo options.\n+        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n+        esac\n+        AC_MSG_RESULT([$_cur])\n+done\n+_ACJNI_FOLLOWED=\"$_cur\"\n+])# _ACJNI"
      },
      {
        "sha": "b25d8adb92c7fd207a7f142d2328940d222d57b7",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -3,13 +3,13 @@ AC_DEFUN([SECP_INT128_CHECK],[\n has_int128=$ac_cv_type___int128\n ])\n \n-dnl \n+dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n   #include <stdint.h>]],[[\n   uint64_t a = 11, tmp;\n-  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  __asm__ __volatile__(\"movq \\@S|@0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n   ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n AC_MSG_RESULT([$has_64bit_asm])\n ])"
      },
      {
        "sha": "0743c36690c7aec009d52d4ac84ea8639fe5dfe6",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 130,
        "deletions": 16,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -29,6 +29,7 @@ AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n   AC_MSG_ERROR([c89 compiler support required])\n fi\n+AM_PROG_AS\n \n case $host_os in\n   *darwin*)\n@@ -93,23 +94,33 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n+AC_ARG_ENABLE(openssl_tests,\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    [enable_openssl_tests=$enableval],\n+    [enable_openssl_tests=auto])\n+\n+AC_ARG_ENABLE(experimental,\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    [use_experimental=$enableval],\n+    [use_experimental=no])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n-    \n+\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n     [use_ecmult_static_precomputation=$enableval],\n-    [use_ecmult_static_precomputation=yes])\n+    [use_ecmult_static_precomputation=auto])\n \n AC_ARG_ENABLE(module_ecdh,\n-    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (default is no)]),\n+    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (experimental)]),\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (default is no)]),\n+    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (experimental)]),\n     [enable_module_schnorr=$enableval],\n     [enable_module_schnorr=no])\n \n@@ -118,6 +129,11 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(jni,\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    [use_jni=$enableval],\n+    [use_jni=auto])\n+\n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n \n@@ -127,8 +143,8 @@ AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n [Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|no|auto]\n-[Specify assembly optimizations to use. Default is auto])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n+[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n \n AC_CHECK_TYPES([__int128])\n \n@@ -138,6 +154,34 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  save_cross_compiling=$cross_compiling\n+  cross_compiling=no\n+  TEMP_CC=\"$CC\"\n+  CC=\"$CC_FOR_BUILD\"\n+  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  AC_RUN_IFELSE(\n+    [AC_LANG_PROGRAM([], [return 0])],\n+    [working_native_cc=yes],\n+    [working_native_cc=no],[dnl])\n+  CC=\"$TEMP_CC\"\n+  cross_compiling=$save_cross_compiling\n+\n+  if test x\"$working_native_cc\" = x\"no\"; then\n+    set_precomp=no\n+    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    else\n+      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    fi\n+  else\n+    AC_MSG_RESULT([ok])\n+    set_precomp=yes\n+  fi\n+else\n+  set_precomp=no\n+fi\n+\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -155,6 +199,8 @@ else\n       AC_MSG_ERROR([x86_64 assembly optimization requested but not available])\n     fi\n     ;;\n+  arm)\n+    ;;\n   no)\n     ;;\n   *)\n@@ -247,10 +293,15 @@ else\n fi\n \n # select assembly optimization\n+use_external_asm=no\n+\n case $set_asm in\n x86_64)\n   AC_DEFINE(USE_ASM_X86_64, 1, [Define this symbol to enable x86_64 assembly optimizations])\n   ;;\n+arm)\n+  use_external_asm=yes\n+  ;;\n no)\n   ;;\n *)\n@@ -305,16 +356,51 @@ esac\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n-    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n-    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-    case $host in\n-    *mingw*)\n-      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-      ;;\n-    esac\n+    if test x\"$enable_openssl_tests\" != x\"no\"; then\n+      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+      case $host in\n+      *mingw*)\n+        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+        ;;\n+      esac\n+    fi\n+  else\n+    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n+    fi\n+  fi\n+else\n+  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n+  fi\n+fi\n \n+if test x\"$use_jni\" != x\"no\"; then\n+  AX_JNI_INCLUDE_DIR\n+  have_jni_dependencies=yes\n+  if test x\"$enable_module_schnorr\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test x\"$enable_module_ecdh\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$have_jni_dependencies\" = \"xno\"; then\n+    if test x\"$use_jni\" = x\"yes\"; then\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and Schnorr and try again.])\n+    fi\n+    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n+    use_jni=no\n+  else\n+    use_jni=yes\n+    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n+      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n+    done\n   fi\n fi\n \n@@ -345,18 +431,43 @@ fi\n \n AC_C_BIGENDIAN()\n \n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-\n AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n+AC_MSG_NOTICE([Using jni: $use_jni])\n+\n+if test x\"$enable_experimental\" = x\"yes\"; then\n+  AC_MSG_NOTICE([******])\n+  AC_MSG_NOTICE([WARNING: experimental build])\n+  AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n+  AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n+  AC_MSG_NOTICE([******])\n+else\n+  if test x\"$enable_module_schnorr\" = x\"yes\"; then\n+    AC_MSG_ERROR([Schnorr signature module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$enable_module_ecdh\" = x\"yes\"; then\n+    AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$set_asm\" = x\"arm\"; then\n+    AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n+  fi\n+fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n@@ -367,6 +478,9 @@ AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_pr\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n dnl make sure nothing new is exported so that we don't break the cache\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\""
      },
      {
        "sha": "a0d006f1131f47d9bb80de6d425e38912e1258f0",
        "filename": "src/secp256k1/libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/libsecp256k1.pc.in?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -5,7 +5,7 @@ includedir=@includedir@\n \n Name: libsecp256k1\n Description: Optimized C library for EC operations on curve secp256k1\n-URL: https://github.com/bitcoin/secp256k1\n+URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n Libs.private: @SECP_LIBS@"
      },
      {
        "sha": "ab580c5b23bbf786f41757b8a3800958db37c7a7",
        "filename": "src/secp256k1/sage/group_prover.sage",
        "status": "added",
        "additions": 322,
        "deletions": 0,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/group_prover.sage?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,322 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(numerator, assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  \"\"\"A set of constraints, consisting of zero and nonzero expressions.\n+\n+  Constraints can either be used to express knowledge or a requirement.\n+\n+  Both the fields zero and nonzero are maps from expressions to description\n+  strings. The expressions that are the keys in zero are required to be zero,\n+  and the expressions that are the keys in nonzero are required to be nonzero.\n+\n+  Note that (a != 0) and (b != 0) is the same as (a*b != 0), so all keys in\n+  nonzero could be multiplied into a single key. This is often much less\n+  efficient to work with though, so we keep them separate inside the\n+  constraints. This allows higher-level code to do fast checks on the individual\n+  nonzero elements, or combine them if needed for stronger checks.\n+\n+  We can't multiply the different zero elements, as it would suffice for one of\n+  the factors to be zero, instead of all of them. Instead, the zero elements are\n+  typically combined into an ideal first.\n+  \"\"\"\n+\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(numerator, con.zero))\n+  if 1 in zero:\n+    return True\n+  # First a cheap check whether any of the individual nonzero terms conflict on\n+  # their own.\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, knowing\n+  # that either x or y is zero is equivalent to having x*y in the zero set.\n+  # Having x or y individually in the nonzero set is not a conflict, but both\n+  # simultaneously is, so that is the right thing to check for.\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = set()\n+  for nz in map(numerator, assume.nonzero):\n+    for (f,n) in nz.factor():\n+      nonzero.add(f)\n+    rnz = zero.reduce(nz)\n+    for (f,n) in rnz.factor():\n+      nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if numerator(expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: numerator(a)*numerator(b), exprs, 1)\n+  for (f, n) in allexprs.factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(numerator(allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in numerator(expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(numerator(expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = prod(x for x in assume.nonzero)\n+  expl = []\n+  for expr in exprs:\n+    if not expr.iszero(zero):\n+      expl.append(exprs[expr])\n+  if not expl:\n+    return (True, None)\n+  return (False, expl)\n+\n+\n+def describe_extra(R, assume, assumeExtra):\n+  \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n+  zerox = assume.zero.copy()\n+  zerox.update(assumeExtra.zero)\n+  zero = R.ideal(map(numerator, assume.zero))\n+  zeroextra = R.ideal(map(numerator, zerox))\n+  nonzero = get_nonzero_set(R, assume)\n+  ret = set()\n+  # Iterate over the extra zero expressions\n+  for base in assumeExtra.zero:\n+    if base not in zero:\n+      add = []\n+      for (f, n) in numerator(base).factor():\n+        if f not in nonzero:\n+          add += [\"%s\" % f]\n+      if add:\n+        ret.add((\" * \".join(add)) + \" = 0 [%s]\" % assumeExtra.zero[base])\n+  # Iterate over the extra nonzero expressions\n+  for nz in assumeExtra.nonzero:\n+    nzr = zeroextra.reduce(numerator(nz))\n+    if nzr not in zeroextra:\n+      for (f,n) in nzr.factor():\n+        if zeroextra.reduce(f) not in nonzero:\n+          ret.add(\"%s != 0\" % zeroextra.reduce(f))\n+  return \", \".join(x for x in ret)\n+\n+\n+def check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require):\n+  \"\"\"Check a set of zero and nonzero requirements, given a set of zero and nonzero assumptions\"\"\"\n+  assume = assumeLaw + assumeAssert + assumeBranch\n+\n+  if conflicts(R, assume):\n+    # This formula does not apply\n+    return None\n+\n+  describe = describe_extra(R, assumeLaw + assumeBranch, assumeAssert)\n+\n+  ok, msg = prove_zero(R, require.zero, assume)\n+  if not ok:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(msg), describe)\n+\n+  res, expl = prove_nonzero(R, require.nonzero, assume)\n+  if not res:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(expl), describe)\n+\n+  if describe != \"\":\n+    return \"OK (assuming %s)\" % describe\n+  else:\n+    return \"OK\"\n+\n+\n+def concrete_verify(c):\n+  for k in c.zero:\n+    if k != 0:\n+      return (False, c.zero[k])\n+  for k in c.nonzero:\n+    if k == 0:\n+      return (False, c.nonzero[k])\n+  return (True, None)"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "src/secp256k1/sage/secp256k1.sage",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/sage/secp256k1.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/sage/secp256k1.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/secp256k1.sage?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h2 * h\n+  h = h * b.Z\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge_var, which assume bz==1\"\"\"\n+  if branch == 0:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z12 = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if (branch == 2):\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if (branch == 3):\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_zinv_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_zinv_var\"\"\"\n+  bzinv = b.Z^(-1)\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={b.Infinity : 'b_infinite'}), a)\n+  if branch == 1:\n+    bzinv2 = bzinv^2\n+    bzinv3 = bzinv2 * bzinv\n+    rx = b.X * bzinv2\n+    ry = b.Y * bzinv3\n+    rz = 1\n+    return (constraints(), constraints(zero={b.Infinity : 'b_finite'}, nonzero={a.Infinity : 'a_infinite'}), jacobianpoint(rx, ry, rz))\n+  azz = a.Z * bzinv\n+  z12 = azz^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * azz\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z\n+  rz = rz * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge\"\"\"\n+  zeroes = {}\n+  nonzeroes = {}\n+  a_infinity = False\n+  if (branch & 4) != 0:\n+    nonzeroes.update({a.Infinity : 'a_infinite'})\n+    a_infinity = True\n+  else:\n+    zeroes.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  rr = t^2\n+  m_alt = -u2\n+  tt = u1 * m_alt\n+  rr = rr + tt\n+  degenerate = (branch & 3) == 3\n+  if (branch & 1) != 0:\n+    zeroes.update({m : 'm_zero'})\n+  else:\n+    nonzeroes.update({m : 'm_nonzero'})\n+  if (branch & 2) != 0:\n+    zeroes.update({rr : 'rr_zero'})\n+  else:\n+    nonzeroes.update({rr : 'rr_nonzero'})\n+  rr_alt = s1\n+  rr_alt = rr_alt * 2\n+  m_alt = m_alt + u1\n+  if not degenerate:\n+    rr_alt = rr\n+    m_alt = m\n+  n = m_alt^2\n+  q = n * t\n+  n = n^2\n+  if degenerate:\n+    n = m\n+  t = rr_alt^2\n+  rz = a.Z * m_alt\n+  infinity = False\n+  if (branch & 8) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    zeroes.update({rz : 'r.z=0'})\n+  else:\n+    nonzeroes.update({rz : 'r.z!=0'})\n+  rz = rz * 2\n+  q = -q\n+  t = t + q\n+  rx = t\n+  t = t * 2\n+  t = t + q\n+  t = t * rr_alt\n+  t = t + n\n+  ry = -t\n+  rx = rx * 4\n+  ry = ry * 4\n+  if a_infinity:\n+    rx = b.X\n+    ry = b.Y\n+    rz = 1\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_old(branch, a, b):\n+  \"\"\"libsecp256k1's old secp256k1_gej_add_ge, which fails when ay+by=0 but ax!=bx\"\"\"\n+  a_infinity = (branch & 1) != 0\n+  zero = {}\n+  nonzero = {}\n+  if a_infinity:\n+    nonzero.update({a.Infinity : 'a_infinite'})\n+  else:\n+    zero.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  z = a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  n = m^2\n+  q = n * t\n+  n = n^2\n+  rr = t^2\n+  t = u1 * u2\n+  t = -t\n+  rr = rr + t\n+  t = rr^2\n+  rz = m * z\n+  infinity = False\n+  if (branch & 2) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    else:\n+      return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(nonzero={z : 'conflict_a'}, zero={z : 'conflict_b'}), point_at_infinity())\n+    zero.update({rz : 'r.z=0'})\n+  else:\n+    nonzero.update({rz : 'r.z!=0'})\n+  rz = rz * (0 if a_infinity else 2)\n+  rx = t\n+  q = -q\n+  rx = rx + q\n+  q = q * 3\n+  t = t * 2\n+  t = t + q\n+  t = t * rr\n+  t = t + n\n+  ry = -t\n+  rx = rx * (0 if a_infinity else 4)\n+  ry = ry * (0 if a_infinity else 4)\n+  t = b.X\n+  t = t * (1 if a_infinity else 0)\n+  rx = rx + t\n+  t = b.Y\n+  t = t * (1 if a_infinity else 0)\n+  ry = ry + t\n+  t = (1 if a_infinity else 0)\n+  rz = rz + t\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), jacobianpoint(rx, ry, rz))\n+\n+if __name__ == \"__main__\":\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old)\n+\n+  if len(sys.argv) >= 2 and sys.argv[1] == \"--exhaustive\":\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old, 43)"
      },
      {
        "sha": "03ef2ec901ea9cafa47b4ccdce7bbba61279930f",
        "filename": "src/secp256k1/sage/weierstrass_prover.sage",
        "status": "added",
        "additions": 264,
        "deletions": 0,
        "changes": 264,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/weierstrass_prover.sage?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,264 @@\n+# Prover implementation for Weierstrass curves of the form\n+# y^2 = x^3 + A * x + B, specifically with a = 0 and b = 7, with group laws\n+# operating on affine and Jacobian coordinates, including the point at infinity\n+# represented by a 4th variable in coordinates.\n+\n+load(\"group_prover.sage\")\n+\n+\n+class affinepoint:\n+  def __init__(self, x, y, infinity=0):\n+    self.x = x\n+    self.y = y\n+    self.infinity = infinity\n+  def __str__(self):\n+    return \"affinepoint(x=%s,y=%s,inf=%s)\" % (self.x, self.y, self.infinity)\n+\n+\n+class jacobianpoint:\n+  def __init__(self, x, y, z, infinity=0):\n+    self.X = x\n+    self.Y = y\n+    self.Z = z\n+    self.Infinity = infinity\n+  def __str__(self):\n+    return \"jacobianpoint(X=%s,Y=%s,Z=%s,inf=%s)\" % (self.X, self.Y, self.Z, self.Infinity)\n+\n+\n+def point_at_infinity():\n+  return jacobianpoint(1, 1, 1, 1)\n+\n+\n+def negate(p):\n+  if p.__class__ == affinepoint:\n+    return affinepoint(p.x, -p.y)\n+  if p.__class__ == jacobianpoint:\n+    return jacobianpoint(p.X, -p.Y, p.Z)\n+  assert(False)\n+\n+\n+def on_weierstrass_curve(A, B, p):\n+  \"\"\"Return a set of zero-expressions for an affine point to be on the curve\"\"\"\n+  return constraints(zero={p.x^3 + A*p.x + B - p.y^2: 'on_curve'})\n+\n+\n+def tangential_to_weierstrass_curve(A, B, p12, p3):\n+  \"\"\"Return a set of zero-expressions for ((x12,y12),(x3,y3)) to be a line that is tangential to the curve at (x12,y12)\"\"\"\n+  return constraints(zero={\n+    (p12.y - p3.y) * (p12.y * 2) - (p12.x^2 * 3 + A) * (p12.x - p3.x): 'tangential_to_curve'\n+  })\n+\n+\n+def colinear(p1, p2, p3):\n+  \"\"\"Return a set of zero-expressions for ((x1,y1),(x2,y2),(x3,y3)) to be collinear\"\"\"\n+  return constraints(zero={\n+    (p1.y - p2.y) * (p1.x - p3.x) - (p1.y - p3.y) * (p1.x - p2.x): 'colinear_1',\n+    (p2.y - p3.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p2.x - p3.x): 'colinear_2',\n+    (p3.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p3.x - p1.x): 'colinear_3'\n+  })\n+\n+\n+def good_affine_point(p):\n+  return constraints(nonzero={p.x : 'nonzero_x', p.y : 'nonzero_y'})\n+\n+\n+def good_jacobian_point(p):\n+  return constraints(nonzero={p.X : 'nonzero_X', p.Y : 'nonzero_Y', p.Z^6 : 'nonzero_Z'})\n+\n+\n+def good_point(p):\n+  return constraints(nonzero={p.Z^6 : 'nonzero_X'})\n+\n+\n+def finite(p, *affine_fns):\n+  con = good_point(p) + constraints(zero={p.Infinity : 'finite_point'})\n+  if p.Z != 0:\n+    return con + reduce(lambda a, b: a + b, (f(affinepoint(p.X / p.Z^2, p.Y / p.Z^3)) for f in affine_fns), con)\n+  else:\n+    return con\n+\n+def infinite(p):\n+  return constraints(nonzero={p.Infinity : 'infinite_point'})\n+\n+\n+def law_jacobian_weierstrass_add(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian add, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(nonzero={pa.x - pb.x : 'different_x'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             colinear(pa, pb, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_double(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian doubling, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y - pb.y : 'equal_y'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             tangential_to_weierstrass_curve(A, B, pa, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_opposites(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y + pb.y : 'opposite_y'}))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_a(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pb) +\n+               infinite(pA) +\n+               finite(pB))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pb.x : 'c.x=b.x', pc.y - pb.y : 'c.y=b.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_b(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               infinite(pB) +\n+               finite(pA))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pa.x : 'c.x=a.x', pc.y - pa.y : 'c.y=a.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_ab(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               infinite(pA) +\n+               infinite(pB))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+laws_jacobian_weierstrass = {\n+  'add': law_jacobian_weierstrass_add,\n+  'double': law_jacobian_weierstrass_double,\n+  'add_opposite': law_jacobian_weierstrass_add_opposites,\n+  'add_infinite_a': law_jacobian_weierstrass_add_infinite_a,\n+  'add_infinite_b': law_jacobian_weierstrass_add_infinite_b,\n+  'add_infinite_ab': law_jacobian_weierstrass_add_infinite_ab\n+}\n+\n+\n+def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n+  F = Integers(p)\n+  print \"Formula %s on Z%i:\" % (name, p)\n+  points = []\n+  for x in xrange(0, p):\n+    for y in xrange(0, p):\n+      point = affinepoint(F(x), F(y))\n+      r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n+      if r:\n+        points.append(point)\n+\n+  for za in xrange(1, p):\n+    for zb in xrange(1, p):\n+      for pa in points:\n+        for pb in points:\n+          for ia in xrange(2):\n+            for ib in xrange(2):\n+              pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n+              pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n+              for branch in xrange(0, branches):\n+                assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n+                pC.X = F(pC.X)\n+                pC.Y = F(pC.Y)\n+                pC.Z = F(pC.Z)\n+                pC.Infinity = F(pC.Infinity)\n+                r, e = concrete_verify(assumeAssert + assumeBranch)\n+                if r:\n+                  match = False\n+                  for key in laws_jacobian_weierstrass:\n+                    assumeLaw, require = laws_jacobian_weierstrass[key](A, B, pa, pb, pA, pB, pC)\n+                    r, e = concrete_verify(assumeLaw)\n+                    if r:\n+                      if match:\n+                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                      else:\n+                        match = True\n+                      r, e = concrete_verify(require)\n+                      if not r:\n+                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n+  print\n+\n+\n+def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n+  assumeLaw, require = f(A, B, pa, pb, pA, pB, pC)\n+  return check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require)\n+\n+def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve symbolically\"\"\"\n+  R.<ax,bx,ay,by,Az,Bz,Ai,Bi> = PolynomialRing(QQ,8,order='invlex')\n+  lift = lambda x: fastfrac(R,x)\n+  ax = lift(ax)\n+  ay = lift(ay)\n+  Az = lift(Az)\n+  bx = lift(bx)\n+  by = lift(by)\n+  Bz = lift(Bz)\n+  Ai = lift(Ai)\n+  Bi = lift(Bi)\n+\n+  pa = affinepoint(ax, ay, Ai)\n+  pb = affinepoint(bx, by, Bi)\n+  pA = jacobianpoint(ax * Az^2, ay * Az^3, Az, Ai)\n+  pB = jacobianpoint(bx * Bz^2, by * Bz^3, Bz, Bi)\n+\n+  res = {}\n+\n+  for key in laws_jacobian_weierstrass:\n+    res[key] = []\n+\n+  print (\"Formula \" + name + \":\")\n+  count = 0\n+  for branch in xrange(branches):\n+    assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n+    pC.X = lift(pC.X)\n+    pC.Y = lift(pC.Y)\n+    pC.Z = lift(pC.Z)\n+    pC.Infinity = lift(pC.Infinity)\n+\n+    for key in laws_jacobian_weierstrass:\n+      res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n+\n+  for key in res:\n+    print \"  %s:\" % key\n+    val = res[key]\n+    for x in val:\n+      if x[0] is not None:\n+        print \"    branch %i: %s\" % (x[1], x[0])\n+\n+  print"
      },
      {
        "sha": "5df561f2fc939e332dae7137345a18fdef9906eb",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "added",
        "additions": 919,
        "deletions": 0,
        "changes": 919,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,919 @@\n+@ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n+/**********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                        *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+/*\n+ARM implementation of field_10x26 inner loops.\n+\n+Note:\n+\n+- To avoid unnecessary loads and make use of available registers, two\n+  'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n+  which will be added to c and d respectively in the the even passes\n+\n+*/\n+\n+\t.syntax unified\n+\t.arch armv7-a\n+\t@ eabi attributes - see readelf -A\n+\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n+\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n+\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n+\t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n+\t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n+\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Agressive Speed\n+\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n+\t.text\n+\n+\t@ Field constants\n+\t.set field_R0, 0x3d10\n+\t.set field_R1, 0x400\n+\t.set field_not_M, 0xfc000000\t@ ~M = ~0x3ffffff\n+\n+\t.align\t2\n+\t.global secp256k1_fe_mul_inner\n+\t.type\tsecp256k1_fe_mul_inner, %function\n+\t@ Arguments:\n+\t@  r0  r      Restrict: can overlap with a, not with b\n+\t@  r1  a\n+\t@  r2  b\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_mul_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r2       b (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\n+\t/* A - interleaved with B */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tldr\tr8, [r2, #9*4]\t\t\t@ b[9]\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]\n+\tumull\tr5, r6, r7, r8\t\t\t@ d = a[0] * b[9]\n+\tldr\tr14, [r2, #8*4]\t\t\t@ b[8]\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[1] * b[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[1] * b[8]\n+\tldr\tr8, [r2, #7*4] \t\t\t@ b[7]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[2] * b[8]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[2] * b[7]\n+\tldr\tr14, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[3] * b[7]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[3] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[4] * b[6]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[5]\n+\tldr\tr14, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[5] * b[5]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[5] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[6] * b[4]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[3]\n+\tldr\tr14, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[7] * b[3]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[7] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[8] * b[2]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[1]\n+\tldr\tr14, [r2, #0*4]   \t\t@ b[0]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[9] * b[1]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[9] * b[0]\n+\t@ r7,r14 used in B\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 4*9]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tumull\tr3, r4, r7, r14   \t\t@ c = a[0] * b[0]\n+\tadds\tr5, r5, r9       \t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C - interleaved with D */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[2]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[1]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[0]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[2] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[3] * b[9]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[3] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[4] * b[8]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[4] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[5] * b[7]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[5] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[6]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[7] * b[5]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[4]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[3]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[2]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E - interleaved with F */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[0] * b[3]\n+\tldr\tr7, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[1] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[1] * b[2]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[2] * b[1]\n+\tldr\tr7, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[3] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[3] * b[0]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[0]\n+\tldr\tr8, [r2, #9*4]   \t\t@ b[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[9]\n+\tldr\tr7, [r1, #5*4]   \t\t@ a[5]\n+\tumull\tr9, r10, r7, r8   \t\t@ d' = a[5] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[5] * b[8]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[8]\n+\tldr\tr8, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[7]\n+\tldr\tr7, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[7] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[7] * b[6]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[5]\n+\tldr\tr7, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[9] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[9] * b[4]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G - interleaved with H */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[6]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[5]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[4]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[3]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[2]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[1]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[0]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[7] * b[9]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[8]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[7]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I - interleaved with J */\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumull   r11, r12, r7, r8   \t\t@ c' = a[0] * b[8]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[7]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[6]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[5]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[4]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[3]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[2]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[6] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[7] * b[1]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[7] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[8] * b[0]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14  \t\t@ d' = a[9] * b[9]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_mul_inner, .-secp256k1_fe_mul_inner\n+\n+\t.align\t2\n+\t.global secp256k1_fe_sqr_inner\n+\t.type\tsecp256k1_fe_sqr_inner, %function\n+\t@ Arguments:\n+\t@  r0  r\t Can overlap with a\n+\t@  r1  a\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_sqr_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r2,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\t/* A interleaved with B */\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumull\tr3, r4, r7, r7\t\t\t@ c = a[0] * a[0]\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr7, r7, asl #1\n+\tumull\tr5, r6, r7, r14\t\t\t@ d = a[0]*2 * a[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[1]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[1]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[2]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[7]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[3]*2 * a[7]\n+\tldr\tr14, [r1, #5*4]\t\t\t@ a[5]\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[6]\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[5]\n+\tumlal\tr9, r10, r14, r14\t\t@ d' += a[5] * a[5]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 9*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C interleaved with D */\n+\tldr\tr0, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr14, [r1, #1*4]\t\t\t@ a[1]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr8, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[0]*2 * a[1]\n+\tmov\tr7, r8, asl #1                  @ a[2]*2\n+\tumull\tr11, r12, r14, r14\t\t@ c' = a[1] * a[1]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[0]*2 * a[2]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[9]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[3]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[7]\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[5]*2 * a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[5]*2 * a[6]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[6] * a[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E interleaved with F */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr14, [r1, #2*4]\t\t\t@ a[2]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tldr\tr2, [r1, #4*4]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[3]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[4]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[4]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[3]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[2]\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[2] * a[2]\n+\tldr\tr14, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[4]*2 * a[9]\n+\tldr\tr7, [r1, #6*4]\t\t\t@ a[6]*2\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[5]*2 * a[9]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[5]*2 * a[8]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[6]*2 * a[8]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[6]*2 * a[7]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[7] * a[7]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G interleaved with H */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tldr\tr2, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[5]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[6]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[5]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[4]\n+\tmov\tr0, r2, asl #1\t\t\t@ a[6]*2\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[4]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[3]\n+\tldr\tr7, [r1, #7*4]\t\t\t@ a[7]*2\n+\tumlal\tr11, r12, r8, r8\t\t@ c' += a[3] * a[3]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[6]*2 * a[9]\n+\tumull\tr9, r10, r7, r14\t\t@ d' = a[7]*2 * a[9]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[7]*2 * a[8]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[8] * a[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I interleaved with J */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tldr\tr2, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[7]\n+\tldr\tr14, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[8]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[7]\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[6]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[6]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[5]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[8]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[3]*2 * a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[3]*2 * a[4]\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[4] * a[4]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[8]*2 * a[9]\n+\t@ r8 will be used in J\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tumlal\tr5, r6, r8, r8\t\t\t@ d += a[9] * a[9]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_sqr_inner, .-secp256k1_fe_sqr_inner\n+"
      },
      {
        "sha": "cde5e2dbb4e4ea1bd4fedced7ba1fecea7de8aa1",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -28,7 +28,8 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    data->ctx = secp256k1_context_create(0);\n+    /* create a context with no capabilities */\n+    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }"
      },
      {
        "sha": "0809f77bda108dacd5a9a2c6208827c985f00f54",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -181,12 +181,12 @@ void bench_field_inverse_var(void* arg) {\n     }\n }\n \n-void bench_field_sqrt_var(void* arg) {\n+void bench_field_sqrt(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt_var(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n@@ -227,6 +227,15 @@ void bench_group_add_affine_var(void* arg) {\n     }\n }\n \n+void bench_group_jacobi_var(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    }\n+}\n+\n void bench_ecmult_wnaf(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n@@ -299,6 +308,21 @@ void bench_context_sign(void* arg) {\n     }\n }\n \n+#ifndef USE_NUM_NONE\n+void bench_num_jacobi(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+    secp256k1_num nx, norder;\n+\n+    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_order_get_num(&norder);\n+    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+\n+    for (i = 0; i < 200000; i++) {\n+        secp256k1_num_jacobi(&nx, &norder);\n+    }\n+}\n+#endif\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n@@ -333,12 +357,13 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt_var\", bench_field_sqrt_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n@@ -350,5 +375,8 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n \n+#ifndef USE_NUM_NONE\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+#endif\n     return 0;\n }"
      },
      {
        "sha": "418defa0aa22a06dff07d3f1567e205235706976",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -11,6 +11,12 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+#include <openssl/bn.h>\n+#include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+#endif\n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -19,6 +25,9 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n+#ifdef ENABLE_OPENSSL_TESTS\n+    EC_GROUP* ec_group;\n+#endif\n } benchmark_verify_t;\n \n static void benchmark_verify(void* arg) {\n@@ -40,6 +49,36 @@ static void benchmark_verify(void* arg) {\n     }\n }\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+static void benchmark_verify_openssl(void* arg) {\n+    int i;\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        {\n+            EC_KEY *pkey = EC_KEY_new();\n+            const unsigned char *pubkey = &data->pubkey[0];\n+            int result;\n+\n+            CHECK(pkey != NULL);\n+            result = EC_KEY_set_group(pkey, data->ec_group);\n+            CHECK(result);\n+            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n+            CHECK(result);\n+            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n+            CHECK(result);\n+            EC_KEY_free(pkey);\n+        }\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -62,6 +101,11 @@ int main(void) {\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+#ifdef ENABLE_OPENSSL_TESTS\n+    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    EC_GROUP_free(data.ec_group);\n+#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "7a6a25318c4cf4a83ea60771755c59f7676dfc71",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 23,
        "deletions": 44,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -58,22 +58,24 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n+\n     /* 1 2 3 */\n     int u_last;\n     int u;\n \n-#ifdef USE_ENDOMORPHISM\n     int flip;\n     int bit;\n     secp256k1_scalar neg_s;\n     int not_neg_one;\n-    /* If we are using the endomorphism, we cannot handle even numbers by negating\n-     * them, since we are working with 128-bit numbers whose negations would be 256\n-     * bits, eliminating the performance advantage. Instead we use a technique from\n+    /* Note that we cannot handle even numbers by negating them to be odd, as is\n+     * done in other implementations, since if our scalars were specified to have\n+     * width < 256 for performance reasons, their negations would have width 256\n+     * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n-     * or 2 (for odd) to the number we are encoding, then compensating after the\n-     * multiplication. */\n-    /* Negative 128-bit numbers will be negated, since otherwise they are 256-bit */\n+     * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n+     * this, and having the caller compensate after doing the multiplication. */\n+\n+    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n     bit = flip ^ (s.d[0] & 1);\n@@ -89,11 +91,6 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     global_sign = secp256k1_scalar_cond_negate(&s, flip);\n     global_sign *= not_neg_one * 2 - 1;\n     skew = 1 << bit;\n-#else\n-    /* Otherwise, we just negate to force oddness */\n-    int is_even = secp256k1_scalar_is_even(&s);\n-    global_sign = secp256k1_scalar_cond_negate(&s, is_even);\n-#endif\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n@@ -127,15 +124,13 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n+    int skew_1;\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_1;\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#else\n-    int wnaf[1 + WNAF_SIZE(WINDOW_A - 1)];\n #endif\n \n     int i;\n@@ -145,18 +140,10 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n #ifdef USE_ENDOMORPHISM\n     /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n     secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    /* no need for zero correction when using endomorphism since even\n-     * numbers have one added to them anyway */\n     skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n     skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n #else\n-    int is_zero = secp256k1_scalar_is_zero(scalar);\n-    /* the wNAF ladder cannot handle zero, so bump this to one .. we will\n-     * correct the result after the fact */\n-    sc.d[0] += is_zero;\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(&sc));\n-\n-    secp256k1_wnaf_const(wnaf, sc, WINDOW_A - 1);\n+    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n #endif\n \n     /* Calculate odd multiples of a.\n@@ -179,21 +166,15 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-#ifdef USE_ENDOMORPHISM\n     i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n     i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n     secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-    i = wnaf[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n #endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n@@ -202,59 +183,57 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n             secp256k1_gej_double_nonzero(r, r, NULL);\n         }\n-#ifdef USE_ENDOMORPHISM\n+\n         n = wnaf_1[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n         n = wnaf_lam[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-        n = wnaf[i];\n-        VERIFY_CHECK(n != 0);\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n #endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n+#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_to_storage(&correction_lam_stor, a);\n+#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_ge_mul_lambda(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n-    }\n-#else\n-    /* correct for zero */\n-    r->infinity |= is_zero;\n #endif\n+    }\n }\n \n #endif"
      },
      {
        "sha": "81ae08e100b6b52ee6428eab17d15588acccdd51",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -11,6 +11,8 @@\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n+#include <string.h>\n+\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n "
      },
      {
        "sha": "c5ba074244e6ab37bc53ac7d189a339e7cd42025",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -57,6 +57,9 @@ static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n static int secp256k1_fe_is_odd(const secp256k1_fe *a);\n \n /** Compare two field elements. Requires magnitude-1 inputs. */\n+static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b);\n+\n+/** Same as secp256k1_fe_equal, but may be variable time. */\n static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b);\n \n /** Compare two field elements. Requires both inputs to be normalized */\n@@ -92,7 +95,10 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  The input's magnitude can be at most 8. The output magnitude is 1 (but not\n  *  guaranteed to be normalized). The result in r will always be a square\n  *  itself. */\n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a);\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n+\n+/** Checks whether a field element is a quadratic residue. */\n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */"
      },
      {
        "sha": "7b8c07960847ebe8a4dfde401bc6596795b83b15",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n #define _SECP256K1_FIELD_REPR_IMPL_H_\n \n-#include <stdio.h>\n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\"\n@@ -429,6 +427,14 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe *r, const secp256k1_f\n #endif\n }\n \n+#if defined(USE_EXTERNAL_ASM)\n+\n+/* External assembler implementation */\n+void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b);\n+void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a);\n+\n+#else\n+\n #ifdef VERIFY\n #define VERIFY_BITS(x, n) VERIFY_CHECK(((x) >> (n)) == 0)\n #else\n@@ -1037,7 +1043,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(r[2], 27);\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n-\n+#endif\n \n static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {\n #ifdef VERIFY"
      },
      {
        "sha": "7a99eb21eccc6bcea99d6d015bf0a7307d26db21",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -11,7 +11,6 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\""
      },
      {
        "sha": "0bf22bdd3ec887251346dac826291fd1432c13ce",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -137,7 +137,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -259,7 +259,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "52cd902eb3873993a00bb2e2b2fa11857900dd65",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 34,
        "deletions": 2,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -21,14 +21,21 @@\n #error \"Please select field implementation\"\n #endif\n \n+SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {\n+    secp256k1_fe na;\n+    secp256k1_fe_negate(&na, a, 1);\n+    secp256k1_fe_add(&na, b);\n+    return secp256k1_fe_normalizes_to_zero(&na);\n+}\n+\n SECP256K1_INLINE static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe na;\n     secp256k1_fe_negate(&na, a, 1);\n     secp256k1_fe_add(&na, b);\n     return secp256k1_fe_normalizes_to_zero_var(&na);\n }\n \n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     /** Given that p is congruent to 3 mod 4, we can compute the square root of\n      *  a mod p as the (p+1)/4'th power of a.\n      *\n@@ -123,7 +130,7 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n     /* Check that a square root was actually calculated */\n \n     secp256k1_fe_sqr(&t1, r);\n-    return secp256k1_fe_equal_var(&t1, a);\n+    return secp256k1_fe_equal(&t1, a);\n }\n \n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n@@ -280,4 +287,29 @@ static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k\n     r[0] = u;\n }\n \n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n+#ifndef USE_NUM_NONE\n+    unsigned char b[32];\n+    secp256k1_num n;\n+    secp256k1_num m;\n+    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n+    static const unsigned char prime[32] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+\n+    secp256k1_fe c = *a;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_set_bin(&m, prime, 32);\n+    return secp256k1_num_jacobi(&n, &m) >= 0;\n+#else\n+    secp256k1_fe r;\n+    return secp256k1_fe_sqrt(&r, a);\n+#endif\n+}\n+\n #endif"
      },
      {
        "sha": "d5157167447a77e94cbf04d9efa94c63cd7d0dca",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const se\n  *  and a Y coordinate that is a quadratic residue modulo p. The return value\n  *  is true iff a coordinate with the given X coordinate exists.\n  */\n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x);\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n@@ -94,6 +94,9 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n+/** Check whether a group element's y coordinate is a quadratic residue. */\n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n+\n /** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n  * a may not be zero. Constant time. */\n static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "3e9c4c410d4132dc1a2ab62075997b10645bd5f5",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 6,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_GROUP_IMPL_H_\n #define _SECP256K1_GROUP_IMPL_H_\n \n-#include <string.h>\n-\n #include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n@@ -165,19 +163,19 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe x2, x3, c;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt_var(&r->y, &c);\n+    return secp256k1_fe_sqrt(&r->y, &c);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad_var(r, x)) {\n+    if (!secp256k1_ge_set_xquad(r, x)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -251,11 +249,23 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n }\n \n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate */\n+    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n+     *\n+     * Note that there is an implementation described at\n+     *     https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n+     * which trades a multiply for a square, but in practice this is actually slower,\n+     * mainly because it requires more normalizations.\n+     */\n     secp256k1_fe t1,t2,t3,t4;\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *  \n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     r->infinity = a->infinity;\n     if (r->infinity) {\n@@ -623,4 +633,18 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n }\n #endif\n \n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n+    secp256k1_fe yz;\n+\n+    if (a->infinity) {\n+        return 0;\n+    }\n+\n+    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n+     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n+       is */\n+    secp256k1_fe_mul(&yz, &a->y, &a->z);\n+    return secp256k1_fe_is_quad_var(&yz);\n+}\n+\n #endif"
      },
      {
        "sha": "fca98cab9f8315bd4fa5c165d9f8e2f16dc2a493",
        "filename": "src/secp256k1/src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -11,7 +11,7 @@\n #include <stdint.h>\n \n typedef struct {\n-    uint32_t s[32];\n+    uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n } secp256k1_sha256_t;"
      },
      {
        "sha": "b47e65f830a906fc0eb9ff7939d62966823202b1",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -269,15 +269,13 @@ static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 0;\n }\n \n-\n+#undef BE32\n #undef Round\n-#undef sigma0\n #undef sigma1\n-#undef Sigma0\n+#undef sigma0\n #undef Sigma1\n-#undef Ch\n+#undef Sigma0\n #undef Maj\n-#undef ReadBE32\n-#undef WriteBE32\n+#undef Ch\n \n #endif"
      },
      {
        "sha": "be67048fbed69e04b799cba74232aee471782747",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 445,
        "deletions": 27,
        "changes": 472,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -1,60 +1,478 @@\n+/*\n+ * Copyright 2013 Google Inc.\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package org.bitcoin;\n \n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n \n+import java.math.BigInteger;\n import com.google.common.base.Preconditions;\n-\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n- * This class holds native methods to handle ECDSA verification.\n- * You can find an example library that can be used for this at\n- * https://github.com/sipa/secp256k1\n+ * <p>This class holds native methods to handle ECDSA verification.</p>\n+ *\n+ * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n+ *\n+ * <p>To build secp256k1 for use with bitcoinj, run\n+ * `./configure --enable-jni --enable-experimental --enable-module-schnorr --enable-module-ecdh`\n+ * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n+ * or point the JVM to the folder containing it with -Djava.library.path\n+ * </p>\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+    //TODO add a 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n     }\n \n     /**\n-     * @param byteBuff signature format is byte[32] data,\n-     *        native-endian int signatureLength, native-endian int pubkeyLength,\n-     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n-     * @returns 1 for valid signature, anything else for invalid\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n      */\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] resArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(resArr.length, 32, \"Got bad result length.\");\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return resArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 randomize - updates the context randomization\n+     *\n+     * @param seed 32-byte random seed\n+     */\n+    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n+        Preconditions.checkArgument(seed.length == 32 || seed == null);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seed.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seed);\n+\n+        w.lock();\n+        try {\n+          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static byte[] schnorrSign(byte[] data, byte[] sec) throws AssertFailException {\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_schnorr_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(sigArr.length, 64, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    private static native long secp256k1_ctx_clone(long context);\n+\n+    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native void secp256k1_destroy_context(long context);\n+\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n+\n+    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n+\n+    private static native byte[][] secp256k1_schnorr_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n+\n }"
      },
      {
        "sha": "f18ce95810d138fbf40e7a0b03d9c43e3d29593f",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "added",
        "additions": 247,
        "deletions": 0,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,247 @@\n+package org.bitcoin;\n+\n+import com.google.common.io.BaseEncoding;\n+import java.util.Arrays;\n+import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n+\n+/**\n+ * This class holds test cases defined for testing this library.\n+ */\n+public class NativeSecp256k1Test {\n+\n+    //TODO improve comments/add more tests\n+    /**\n+      * This tests verify() for a valid signature\n+      */\n+    public static void testVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        assertEquals( result, true , \"testVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests verify() for a non-valid signature\n+      */\n+    public static void testVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a valid secretkey\n+      */\n+    public static void testSecKeyVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, true , \"testSecKeyVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a invalid secretkey\n+      */\n+    public static void testSecKeyVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a valid secretkey\n+      */\n+    public static void testPubKeyCreatePos() throws AssertFailException{\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a invalid secretkey\n+      */\n+    public static void testPubKeyCreateNeg() throws AssertFailException{\n+       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n+    }\n+\n+    /**\n+      * This tests sign() for a valid secretkey\n+      */\n+    public static void testSignPos() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n+    }\n+\n+    /**\n+      * This tests sign() for a invalid secretkey\n+      */\n+    public static void testSignNeg() throws AssertFailException{\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"\" , \"testSignNeg\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add\n+      */\n+    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul\n+      */\n+    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add uncompressed\n+      */\n+    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul uncompressed\n+      */\n+    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n+    }\n+\n+    /**\n+      * This tests seed randomization\n+      */\n+    public static void testRandomize() throws AssertFailException {\n+        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n+        boolean result = NativeSecp256k1.randomize(seed);\n+        assertEquals( result, true, \"testRandomize\");\n+    }\n+\n+    /**\n+      * This tests signSchnorr() for a valid secretkey\n+      */\n+    public static void testSchnorrSign() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.schnorrSign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"C5E929AA058B982048760422D3B563749B7D0E50C5EBD8CD2FFC23214BD6A2F1B072C13880997EBA847CF20F2F90FCE07C1CA33A890A4127095A351127F8D95F\" , \"testSchnorrSign\");\n+    }\n+\n+    /**\n+      * This tests signSchnorr() for a valid secretkey\n+      */\n+    public static void testCreateECDHSecret() throws AssertFailException{\n+\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n+    }\n+\n+    public static void main(String[] args) throws AssertFailException{\n+\n+\n+        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n+\n+        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n+\n+        //Test verify() success/fail\n+        testVerifyPos();\n+        testVerifyNeg();\n+\n+        //Test secKeyVerify() success/fail\n+        testSecKeyVerifyPos();\n+        testSecKeyVerifyNeg();\n+\n+        //Test computePubkey() success/fail\n+        testPubKeyCreatePos();\n+        testPubKeyCreateNeg();\n+\n+        //Test sign() success/fail\n+        testSignPos();\n+        testSignNeg();\n+\n+        //Test Schnorr (partial support) //TODO\n+        testSchnorrSign();\n+        //testSchnorrVerify\n+        //testSchnorrRecovery\n+\n+        //Test privKeyTweakAdd() 1\n+        testPrivKeyTweakAdd_1();\n+\n+        //Test privKeyTweakMul() 2\n+        testPrivKeyTweakMul_1();\n+\n+        //Test privKeyTweakAdd() 3\n+        testPrivKeyTweakAdd_2();\n+\n+        //Test privKeyTweakMul() 4\n+        testPrivKeyTweakMul_2();\n+\n+        //Test randomize()\n+        testRandomize();\n+\n+        //Test ECDH\n+        testCreateECDHSecret();\n+\n+        NativeSecp256k1.cleanup();\n+\n+        System.out.println(\" All tests passed.\" );\n+\n+    }\n+}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+public class NativeSecp256k1Util{\n+\n+    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+    }\n+\n+    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n+      if( !val.equals(val2) )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static class AssertFailException extends Exception {\n+      public AssertFailException(String message) {\n+        super( message );\n+      }\n+    }\n+}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+/**\n+ * This class holds the context reference used in native methods \n+ * to handle ECDSA operations.\n+ */\n+public class Secp256k1Context {\n+  private static final boolean enabled; //true if the library is loaded\n+  private static final long context; //ref to pointer to context obj\n+\n+  static { //static initializer\n+      boolean isEnabled = true;\n+      long contextRef = -1;\n+      try {\n+          System.loadLibrary(\"secp256k1\");\n+          contextRef = secp256k1_init_context();\n+      } catch (UnsatisfiedLinkError e) {\n+          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n+          isEnabled = false;\n+      }\n+      enabled = isEnabled;\n+      context = contextRef;\n+  }\n+\n+  public static boolean isEnabled() {\n+     return enabled;\n+  }\n+\n+  public static long getContext() {\n+     if(!enabled) return -1; //sanity check\n+     return context;\n+  }\n+\n+  private static native long secp256k1_init_context();\n+}"
      },
      {
        "sha": "dba9524dd4cc291058e70f7b6574e846d64035f3",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 400,
        "deletions": 12,
        "changes": 412,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -1,23 +1,411 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n #include \"org_bitcoin_NativeSecp256k1.h\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_ecdh.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#include \"include/secp256k1_schnorr.h\"\n \n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n+\n+  (void)classObject;(void)env;\n+\n+  return ctx_clone_l;\n+\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_context_randomize(ctx, seed);\n+\n+}\n+\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  secp256k1_context_destroy(ctx);\n+\n+  (void)classObject;(void)env;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n+  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n+\n+  secp256k1_ecdsa_signature sig;\n+  secp256k1_pubkey pubkey;\n+\n+  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+    if( ret ) {\n+      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n+    }\n+  }\n+\n+  (void)classObject;\n+\n+  return ret;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  secp256k1_ecdsa_signature sig[72];\n+\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+\n+  unsigned char outputSer[72];\n+  size_t outputLen = 72;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_ec_seckey_verify(ctx, secKey);\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  secp256k1_pubkey pubkey;\n+\n+  jobjectArray retArray;\n+  jbyteArray pubkeyArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n+\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n {\n-\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\tint sigLen = *((int*)(data + 32));\n-\tint pubLen = *((int*)(data + 32 + 4));\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if ( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n \n-\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }\n \n-static void __javasecp256k1_attach(void) __attribute__((constructor));\n-static void __javasecp256k1_detach(void) __attribute__((destructor));\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n+  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n+{\n+  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n \n-static void __javasecp256k1_attach(void) {\n-\tsecp256k1_start(SECP256K1_START_VERIFY);\n+  return 0;\n }\n \n-static void __javasecp256k1_detach(void) {\n-\tsecp256k1_stop();\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  unsigned char sig[64];\n+\n+  int ret = secp256k1_schnorr_sign(ctx, sig, data, secKey, NULL, NULL);\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, 64);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, 64, (jbyte*)sig);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray outArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  secp256k1_pubkey pubkey;\n+  unsigned char nonce_res[32];\n+  size_t outputLen = 32;\n+\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+  if (ret) {\n+    ret = secp256k1_ecdh(\n+      ctx,\n+      nonce_res,\n+      &pubkey,\n+      secdata\n+    );\n+  }\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  outArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }"
      },
      {
        "sha": "4125a1f5233beae400c4846ad975a7b6b47721d6",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 109,
        "deletions": 3,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -1,19 +1,125 @@\n /* DO NOT EDIT THIS FILE - it is machine generated */\n #include <jni.h>\n+#include \"include/secp256k1.h\"\n /* Header for class org_bitcoin_NativeSecp256k1 */\n \n #ifndef _Included_org_bitcoin_NativeSecp256k1\n #define _Included_org_bitcoin_NativeSecp256k1\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ctx_clone\n+ * Signature: (J)J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv *, jclass, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_context_randomize\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_destroy_context\n+ * Signature: (J)V\n+ */\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv *, jclass, jlong);\n+\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;)I\n+ * Signature: (Ljava/nio/ByteBuffer;JII)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_sign\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_seckey_verify\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_create\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n  */\n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject);\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_parse\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_schnorr_sign\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdh\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n+\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,15 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include \"org_bitcoin_Secp256k1Context.h\"\n+#include \"include/secp256k1.h\"\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv* env, jclass classObject)\n+{\n+  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+  (void)classObject;(void)env;\n+\n+  return (uintptr_t)ctx;\n+}\n+"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -0,0 +1,22 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+#include \"include/secp256k1.h\"\n+/* Header for class org_bitcoin_Secp256k1Context */\n+\n+#ifndef _Included_org_bitcoin_Secp256k1Context\n+#define _Included_org_bitcoin_Secp256k1Context\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_Secp256k1Context\n+ * Method:    secp256k1_init_context\n+ * Signature: ()J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv *, jclass);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "e3088b469790bdc14b8982931d5729a7eabde69b",
        "filename": "src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/Makefile.am.include?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/ecdh/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_ecdh\n bench_ecdh_SOURCES = src/bench_ecdh.c\n-bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "bf23c26e71c5dd88df965141295bb33144007147",
        "filename": "src/secp256k1/src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/Makefile.am.include?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/recovery/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c\n-bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "f1af8e83255fd0c1e0bd7d051dcaed609bae1447",
        "filename": "src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/Makefile.am.include?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -6,5 +6,5 @@ noinst_HEADERS += src/modules/schnorr/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_schnorr_verify\n bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "7bb9c5be8cf5a6d020ef4bfcac1af13902e5d533",
        "filename": "src/secp256k1/src/num.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -32,6 +32,9 @@ static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsi\n /** Compute a modular inverse. The input must be less than the modulus. */\n static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n \n+/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n+\n /** Compare the absolute value of two numbers. */\n static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n \n@@ -57,6 +60,9 @@ static void secp256k1_num_shift(secp256k1_num *r, int bits);\n /** Check whether a number is zero. */\n static int secp256k1_num_is_zero(const secp256k1_num *a);\n \n+/** Check whether a number is one. */\n+static int secp256k1_num_is_one(const secp256k1_num *a);\n+\n /** Check whether a number is strictly negative. */\n static int secp256k1_num_is_neg(const secp256k1_num *a);\n "
      },
      {
        "sha": "3a46495eeac7d979a87871ca20ce30c2010a54ce",
        "filename": "src/secp256k1/src/num_gmp_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -144,6 +144,32 @@ static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a,\n     memset(v, 0, sizeof(v));\n }\n \n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n+    int ret;\n+    mpz_t ga, gb;\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n+\n+    mpz_inits(ga, gb, NULL);\n+\n+    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n+    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n+    if (a->neg) {\n+        mpz_neg(ga, ga);\n+    }\n+\n+    ret = mpz_jacobi(ga, gb);\n+\n+    mpz_clears(ga, gb, NULL);\n+\n+    return ret;\n+}\n+\n+static int secp256k1_num_is_one(const secp256k1_num *a) {\n+    return (a->limbs == 1 && a->data[0] == 1);\n+}\n+\n static int secp256k1_num_is_zero(const secp256k1_num *a) {\n     return (a->limbs == 1 && a->data[0] == 0);\n }"
      },
      {
        "sha": "c5baf4df413e0895135f3c4f974998d97613e836",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_SCALAR_IMPL_H_\n #define _SECP256K1_SCALAR_IMPL_H_\n \n-#include <string.h>\n-\n #include \"group.h\"\n #include \"scalar.h\"\n "
      },
      {
        "sha": "7973d60c36a81e6bd5cc765a9e038d12b1790195",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -4,8 +4,6 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n-#define SECP256K1_BUILD (1)\n-\n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n@@ -152,7 +150,6 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pubkey, const unsigned char *input, size_t inputlen) {\n     secp256k1_ge Q;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n@@ -170,7 +167,6 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     size_t len;\n     int ret = 0;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n@@ -216,7 +212,7 @@ static void secp256k1_ecdsa_signature_save(secp256k1_ecdsa_signature* sig, const\n int secp256k1_ecdsa_signature_parse_der(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input != NULL);\n \n@@ -234,7 +230,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n \n@@ -253,7 +249,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(sig != NULL);\n@@ -265,7 +261,7 @@ int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsign\n int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n \n@@ -398,7 +394,6 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n@@ -437,7 +432,6 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -485,7 +479,6 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);"
      },
      {
        "sha": "b32cb90813718cd1feae8bea86c4c0990c96a70a",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 166,
        "deletions": 24,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0237096df5299e9f0947e902153d93932f2ea13b/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=0237096df5299e9f0947e902153d93932f2ea13b",
        "patch": "@@ -473,6 +473,8 @@ void test_num_negate(void) {\n }\n \n void test_num_add_sub(void) {\n+    int i;\n+    secp256k1_scalar s;\n     secp256k1_num n1;\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n@@ -498,13 +500,119 @@ void test_num_add_sub(void) {\n     CHECK(!secp256k1_num_eq(&n2p1, &n1));\n     secp256k1_num_sub(&n2p1, &n2p1, &n2); /* n2p1 = R2 + R1 - R2 = R1 */\n     CHECK(secp256k1_num_eq(&n2p1, &n1));\n+\n+    /* check is_one */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&n1, &s);\n+    CHECK(secp256k1_num_is_one(&n1));\n+    /* check that 2^n + 1 is never 1 */\n+    secp256k1_scalar_get_num(&n2, &s);\n+    for (i = 0; i < 250; ++i) {\n+        secp256k1_num_add(&n1, &n1, &n1);    /* n1 *= 2 */\n+        secp256k1_num_add(&n1p2, &n1, &n2);  /* n1p2 = n1 + 1 */\n+        CHECK(!secp256k1_num_is_one(&n1p2));\n+    }\n+}\n+\n+void test_num_mod(void) {\n+    int i;\n+    secp256k1_scalar s;\n+    secp256k1_num order, n;\n+\n+    /* check that 0 mod anything is 0 */\n+    random_scalar_order_test(&s); \n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_set_int(&s, 0);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that anything mod 1 is 0 */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that increasing the number past 2^256 does not break this */\n+    random_scalar_order_test(&s); \n+    secp256k1_scalar_get_num(&n, &s);\n+    /* multiply by 2^8, which'll test this case with high probability */\n+    for (i = 0; i < 8; ++i) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+}\n+\n+void test_num_jacobi(void) {\n+    secp256k1_scalar sqr;\n+    secp256k1_scalar small;\n+    secp256k1_scalar five;  /* five is not a quadratic residue */\n+    secp256k1_num order, n;\n+    int i;\n+    /* squares mod 5 are 1, 4 */\n+    const int jacobi5[10] = { 0, 1, -1, -1, 1, 0, 1, -1, -1, 1 };\n+\n+    /* check some small values with 5 as the order */\n+    secp256k1_scalar_set_int(&five, 5);\n+    secp256k1_scalar_get_num(&order, &five);\n+    for (i = 0; i < 10; ++i) {\n+        secp256k1_scalar_set_int(&small, i);\n+        secp256k1_scalar_get_num(&n, &small);\n+        CHECK(secp256k1_num_jacobi(&n, &order) == jacobi5[i]);\n+    }\n+\n+    /** test large values with 5 as group order */\n+    secp256k1_scalar_get_num(&order, &five);\n+    /* we first need a scalar which is not a multiple of 5 */\n+    do {\n+        secp256k1_num fiven;\n+        random_scalar_order_test(&sqr); \n+        secp256k1_scalar_get_num(&fiven, &five);\n+        secp256k1_scalar_get_num(&n, &sqr);\n+        secp256k1_num_mod(&n, &fiven);\n+    } while (secp256k1_num_is_zero(&n));\n+    /* next force it to be a residue. 2 is a nonresidue mod 5 so we can\n+     * just multiply by two, i.e. add the number to itself */\n+    if (secp256k1_num_jacobi(&n, &order) == -1) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+\n+    /* test residue */\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_num_add(&n, &n, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+\n+    /** test with secp group order as order */\n+    secp256k1_scalar_order_get_num(&order);\n+    random_scalar_order_test(&sqr); \n+    secp256k1_scalar_sqr(&sqr, &sqr);\n+    /* test residue */\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_scalar_mul(&sqr, &sqr, &five);\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+    /* test multiple of the order*/\n+    CHECK(secp256k1_num_jacobi(&order, &order) == 0);\n+\n+    /* check one less than the order */\n+    secp256k1_scalar_set_int(&small, 1);\n+    secp256k1_scalar_get_num(&n, &small);\n+    secp256k1_num_sub(&n, &order, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);  /* sage confirms this is 1 */\n }\n \n void run_num_smalltests(void) {\n     int i;\n     for (i = 0; i < 100*count; i++) {\n         test_num_negate();\n         test_num_add_sub();\n+        test_num_mod();\n+        test_num_jacobi();\n     }\n }\n #endif\n@@ -689,6 +797,10 @@ void scalar_test(void) {\n             secp256k1_scalar_inverse(&inv, &inv);\n             /* Inverting one must result in one. */\n             CHECK(secp256k1_scalar_is_one(&inv));\n+#ifndef USE_NUM_NONE\n+            secp256k1_scalar_get_num(&invnum, &inv);\n+            CHECK(secp256k1_num_is_one(&invnum));\n+#endif\n         }\n     }\n \n@@ -855,7 +967,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar zzv;\n #endif\n         int overflow;\n-        unsigned char chal[32][2][32] = {\n+        unsigned char chal[33][2][32] = {\n             {{0xff, 0xff, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\n               0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,\n@@ -1111,9 +1223,17 @@ void run_scalar_tests(void) {\n              {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00,\n               0xf8, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,\n-              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}}\n+              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}},\n+            {{0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03},\n+             {0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03}}\n         };\n-        unsigned char res[32][2][32] = {\n+        unsigned char res[33][2][32] = {\n             {{0x0c, 0x3b, 0x0a, 0xca, 0x8d, 0x1a, 0x2f, 0xb9,\n               0x8a, 0x7b, 0x53, 0x5a, 0x1f, 0xc5, 0x22, 0xa1,\n               0x07, 0x2a, 0x48, 0xea, 0x02, 0xeb, 0xb3, 0xd6,\n@@ -1369,10 +1489,18 @@ void run_scalar_tests(void) {\n              {0xe4, 0xf1, 0x23, 0x84, 0xe1, 0xb5, 0x9d, 0xf2,\n               0xb8, 0x73, 0x8b, 0x45, 0x2b, 0x35, 0x46, 0x38,\n               0x10, 0x2b, 0x50, 0xf8, 0x8b, 0x35, 0xcd, 0x34,\n-              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}}\n+              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}},\n+            {{0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5},\n+             {0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5}}\n         };\n         secp256k1_scalar_set_int(&one, 1);\n-        for (i = 0; i < 32; i++) {\n+        for (i = 0; i < 33; i++) {\n             secp256k1_scalar_set_b32(&x, chal[i][0], &overflow);\n             CHECK(!overflow);\n             secp256k1_scalar_set_b32(&y, chal[i][1], &overflow);\n@@ -1446,7 +1574,7 @@ void random_fe_non_zero(secp256k1_fe *nz) {\n void random_fe_non_square(secp256k1_fe *ns) {\n     secp256k1_fe r;\n     random_fe_non_zero(ns);\n-    if (secp256k1_fe_sqrt_var(&r, ns)) {\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -1641,7 +1769,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe *a, const secp256k1_fe *k) {\n     secp256k1_fe r1, r2;\n-    int v = secp256k1_fe_sqrt_var(&r1, a);\n+    int v = secp256k1_fe_sqrt(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -1951,8 +2079,8 @@ void test_add_neg_y_diff_x(void) {\n      * of the sum to be wrong (since infinity has no xy coordinates).\n      * HOWEVER, if the x-coordinates are different, infinity is the\n      * wrong answer, and such degeneracies are exposed. This is the\n-     * root of https://github.com/bitcoin/secp256k1/issues/257 which\n-     * this test is a regression test for.\n+     * root of https://github.com/bitcoin-core/secp256k1/issues/257\n+     * which this test is a regression test for.\n      *\n      * These points were generated in sage as\n      * # secp256k1 params\n@@ -2051,15 +2179,16 @@ void run_ec_combine(void) {\n void test_group_decompress(const secp256k1_fe* x) {\n     /* The input itself, normalized. */\n     secp256k1_fe fex = *x;\n-    secp256k1_fe tmp;\n+    secp256k1_fe fez;\n     /* Results of set_xquad_var, set_xo_var(..., 0), set_xo_var(..., 1). */\n     secp256k1_ge ge_quad, ge_even, ge_odd;\n+    secp256k1_gej gej_quad;\n     /* Return values of the above calls. */\n     int res_quad, res_even, res_odd;\n \n     secp256k1_fe_normalize_var(&fex);\n \n-    res_quad = secp256k1_ge_set_xquad_var(&ge_quad, &fex);\n+    res_quad = secp256k1_ge_set_xquad(&ge_quad, &fex);\n     res_even = secp256k1_ge_set_xo_var(&ge_even, &fex, 0);\n     res_odd = secp256k1_ge_set_xo_var(&ge_odd, &fex, 1);\n \n@@ -2085,13 +2214,29 @@ void test_group_decompress(const secp256k1_fe* x) {\n         CHECK(secp256k1_fe_equal_var(&ge_odd.x, x));\n \n         /* Check that the Y coordinate result in ge_quad is a square. */\n-        CHECK(secp256k1_fe_sqrt_var(&tmp, &ge_quad.y));\n-        secp256k1_fe_sqr(&tmp, &tmp);\n-        CHECK(secp256k1_fe_equal_var(&tmp, &ge_quad.y));\n+        CHECK(secp256k1_fe_is_quad_var(&ge_quad.y));\n \n         /* Check odd/even Y in ge_odd, ge_even. */\n         CHECK(secp256k1_fe_is_odd(&ge_odd.y));\n         CHECK(!secp256k1_fe_is_odd(&ge_even.y));\n+\n+        /* Check secp256k1_gej_has_quad_y_var. */\n+        secp256k1_gej_set_ge(&gej_quad, &ge_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n     }\n }\n \n@@ -2383,9 +2528,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, shift;\n     int wnaf[256] = {0};\n     int i;\n-#ifdef USE_ENDOMORPHISM\n     int skew;\n-#endif\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2395,10 +2538,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n-#else\n-    secp256k1_wnaf_const(wnaf, num, w);\n #endif\n+    skew = secp256k1_wnaf_const(wnaf, num, w);\n \n     for (i = WNAF_SIZE(w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -2417,10 +2558,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         }\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n-#ifdef USE_ENDOMORPHISM\n-    /* Skew num because when encoding 128-bit numbers as odd we use an offset */\n+    /* Skew num because when encoding numbers as odd we use an offset */\n     secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n-#endif\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3484,12 +3623,14 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n+#ifdef ENABLE_OPENSSL_TESTS\n     static const unsigned char max_scalar[32] = {\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n         0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n         0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n     };\n+#endif\n \n     int ret = 0;\n \n@@ -3607,13 +3748,13 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n     int action = secp256k1_rand_bits(3);\n-    if (action < 1) {\n+    if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n         pos = secp256k1_rand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n-    } else if (action < 2) {\n+    } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n         pos = secp256k1_rand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n@@ -3785,6 +3926,7 @@ void run_ecdsa_der_parse(void) {\n         int certainly_der = 0;\n         int certainly_not_der = 0;\n         random_ber_signature(buffer, &buflen, &certainly_der, &certainly_not_der);\n+        CHECK(buflen <= 2048);\n         for (j = 0; j < 16; j++) {\n             int ret = 0;\n             if (j > 0) {"
      }
    ]
  }
]