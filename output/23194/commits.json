[
  {
    "sha": "89968333782b92c6a470d308ca7bd4c570cfec8b",
    "node_id": "C_kwDOABII59oAKDg5OTY4MzMzNzgyYjkyYzZhNDcwZDMwOGNhN2JkNGM1NzBjZmVjOGI",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T16:37:52Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T16:37:52Z"
      },
      "message": "fixes #23073\n\nAdded function to msvc-autogen.py that automatically parses changes from \nconfigure.ac into bitcoin_config.h.\nThe function supports following values:\n- CLIENT_VERSION_BUILD\n- CLIENT_VERSION_IS_RELEASE\n- CLIENT_VERSION_MAJOR\n- CLIENT_VERSION_MINOR\n- COPYRIGHT_YEAR\n- PACKAGE_STRING\n- PACKAGE_VERSION",
      "tree": {
        "sha": "8506b3d5dada127460a13660ed2c888ff03a674c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8506b3d5dada127460a13660ed2c888ff03a674c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89968333782b92c6a470d308ca7bd4c570cfec8b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89968333782b92c6a470d308ca7bd4c570cfec8b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/89968333782b92c6a470d308ca7bd4c570cfec8b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89968333782b92c6a470d308ca7bd4c570cfec8b/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c79d9fb2f6e5f47dcb0ac45d66a542dad0c8e7e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c79d9fb2f6e5f47dcb0ac45d66a542dad0c8e7e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c79d9fb2f6e5f47dcb0ac45d66a542dad0c8e7e4"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 32,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9007a056dd3f27f6823ab90354ef8b931fc373c5",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89968333782b92c6a470d308ca7bd4c570cfec8b/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89968333782b92c6a470d308ca7bd4c570cfec8b/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=89968333782b92c6a470d308ca7bd4c570cfec8b",
        "patch": "@@ -6,6 +6,7 @@\n import os\n import re\n import argparse\n+import fileinput\n from shutil import copyfile\n \n SOURCE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'src'))\n@@ -57,6 +58,37 @@ def set_common_properties(toolset):\n     with open(os.path.join(SOURCE_DIR, '../build_msvc/common.init.vcxproj'), 'w', encoding='utf-8',newline='\\n') as wfile:\n         wfile.write(s)\n \n+def parse_config_into_btc_conifg():\n+    def find_between( s, first, last ):\n+        try:\n+            start = s.index( first ) + len( first )\n+            end = s.index( last, start )\n+            return s[start:end]\n+        except ValueError:\n+            return \"\"\n+\n+    config_info = []\n+    with open(os.path.join(SOURCE_DIR,'../configure.ac') as f:\n+        for line in f:\n+            if line.startswith(\"define\"):\n+                config_info.append(find_between(line, \"(_\", \")\"))\n+\n+    config_info = [c for c in config_info if not c.startswith(\"COPYRIGHT_HOLDERS\")]\n+\n+    config_dict = dict(item.split(\", \") for item in config_info)\n+    config_dict[\"PACKAGE_VERSION\"] = f\"\\\"{config_dict['CLIENT_VERSION_MAJOR']}.{config_dict['CLIENT_VERSION_MINOR']}.{config_dict['CLIENT_VERSION_BUILD']}\\\"\"\n+    version = config_dict[\"PACKAGE_VERSION\"].strip('\"')\n+    config_dict[\"PACKAGE_STRING\"] = f\"\\\"Bitcoin Core {version}\\\"\"\n+\n+    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h'), inplace=True):\n+        header = \"\"\n+        if line.startswith(\"#define\"):\n+            header = line.split(\" \")[1]\n+        if header in config_dict:\n+            print(f\"#define {header} {config_dict[header]}\\n\", end='')\n+        else:\n+            print(line, end='')\n+\n def main():\n     parser = argparse.ArgumentParser(description='Bitcoin-core msbuild configuration initialiser.')\n     parser.add_argument('-toolset', nargs='?',help='Optionally sets the msbuild platform toolset, e.g. v142 for Visual Studio 2019.'"
      }
    ]
  },
  {
    "sha": "d2ec759ec1c315411b77b69768c0d8045c593e9f",
    "node_id": "C_kwDOABII59oAKGQyZWM3NTllYzFjMzE1NDExYjc3YjY5NzY4YzBkODA0NWM1OTNlOWY",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T17:01:44Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T17:01:44Z"
      },
      "message": "Was missing a bracket",
      "tree": {
        "sha": "01963c8e5faf3c6186b578c8201746f40ba8dc72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/01963c8e5faf3c6186b578c8201746f40ba8dc72"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2ec759ec1c315411b77b69768c0d8045c593e9f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2ec759ec1c315411b77b69768c0d8045c593e9f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2ec759ec1c315411b77b69768c0d8045c593e9f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2ec759ec1c315411b77b69768c0d8045c593e9f/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89968333782b92c6a470d308ca7bd4c570cfec8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89968333782b92c6a470d308ca7bd4c570cfec8b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89968333782b92c6a470d308ca7bd4c570cfec8b"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "68acb34c5aa0c37ca274e7b96e0639d5c8f07975",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2ec759ec1c315411b77b69768c0d8045c593e9f/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2ec759ec1c315411b77b69768c0d8045c593e9f/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=d2ec759ec1c315411b77b69768c0d8045c593e9f",
        "patch": "@@ -68,7 +68,7 @@ def find_between( s, first, last ):\n             return \"\"\n \n     config_info = []\n-    with open(os.path.join(SOURCE_DIR,'../configure.ac') as f:\n+    with open(os.path.join(SOURCE_DIR,'../configure.ac')) as f:\n         for line in f:\n             if line.startswith(\"define\"):\n                 config_info.append(find_between(line, \"(_\", \")\"))"
      }
    ]
  },
  {
    "sha": "b333e27c1f4d62a3b2d64373514d767c00a5eb71",
    "node_id": "C_kwDOABII59oAKGIzMzNlMjdjMWY0ZDYyYTNiMmQ2NDM3MzUxNGQ3NjdjMDBhNWViNzE",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T17:32:34Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T17:32:34Z"
      },
      "message": "Added UTF-8 encoding to open()",
      "tree": {
        "sha": "9bdea00c337508dbd85246d4ca61e503a6246ee3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9bdea00c337508dbd85246d4ca61e503a6246ee3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b333e27c1f4d62a3b2d64373514d767c00a5eb71",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b333e27c1f4d62a3b2d64373514d767c00a5eb71",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b333e27c1f4d62a3b2d64373514d767c00a5eb71",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b333e27c1f4d62a3b2d64373514d767c00a5eb71/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2ec759ec1c315411b77b69768c0d8045c593e9f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2ec759ec1c315411b77b69768c0d8045c593e9f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2ec759ec1c315411b77b69768c0d8045c593e9f"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 3,
      "deletions": 2
    },
    "files": [
      {
        "sha": "f7ceb28a046beebd112eabe0d89f462b2dbb6336",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b333e27c1f4d62a3b2d64373514d767c00a5eb71/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b333e27c1f4d62a3b2d64373514d767c00a5eb71/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=b333e27c1f4d62a3b2d64373514d767c00a5eb71",
        "patch": "@@ -68,7 +68,7 @@ def find_between( s, first, last ):\n             return \"\"\n \n     config_info = []\n-    with open(os.path.join(SOURCE_DIR,'../configure.ac')) as f:\n+    with open(os.path.join(SOURCE_DIR,'../configure.ac'), encoding=\"utf8\") as f:\n         for line in f:\n             if line.startswith(\"define\"):\n                 config_info.append(find_between(line, \"(_\", \")\"))\n@@ -80,7 +80,7 @@ def find_between( s, first, last ):\n     version = config_dict[\"PACKAGE_VERSION\"].strip('\"')\n     config_dict[\"PACKAGE_STRING\"] = f\"\\\"Bitcoin Core {version}\\\"\"\n \n-    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h'), inplace=True):\n+    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h', ), inplace=True, encoding=\"utf8\"):\n         header = \"\"\n         if line.startswith(\"#define\"):\n             header = line.split(\" \")[1]\n@@ -89,6 +89,7 @@ def find_between( s, first, last ):\n         else:\n             print(line, end='')\n \n+\n def main():\n     parser = argparse.ArgumentParser(description='Bitcoin-core msbuild configuration initialiser.')\n     parser.add_argument('-toolset', nargs='?',help='Optionally sets the msbuild platform toolset, e.g. v142 for Visual Studio 2019.'"
      }
    ]
  },
  {
    "sha": "40f550589622eb24a0a2d278541e08805c8f3949",
    "node_id": "C_kwDOABII59oAKDQwZjU1MDU4OTYyMmViMjRhMGEyZDI3ODU0MWUwODgwNWM4ZjM5NDk",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:20:17Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:20:17Z"
      },
      "message": "typo",
      "tree": {
        "sha": "d300ecd9d3c61c428104fbbcc45b627f98f0d610",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d300ecd9d3c61c428104fbbcc45b627f98f0d610"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/40f550589622eb24a0a2d278541e08805c8f3949",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40f550589622eb24a0a2d278541e08805c8f3949",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/40f550589622eb24a0a2d278541e08805c8f3949",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40f550589622eb24a0a2d278541e08805c8f3949/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b333e27c1f4d62a3b2d64373514d767c00a5eb71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b333e27c1f4d62a3b2d64373514d767c00a5eb71",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b333e27c1f4d62a3b2d64373514d767c00a5eb71"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "8177822535e38aa2eae5c9e28dc209cbbf8d519f",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40f550589622eb24a0a2d278541e08805c8f3949/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40f550589622eb24a0a2d278541e08805c8f3949/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=40f550589622eb24a0a2d278541e08805c8f3949",
        "patch": "@@ -58,7 +58,7 @@ def set_common_properties(toolset):\n     with open(os.path.join(SOURCE_DIR, '../build_msvc/common.init.vcxproj'), 'w', encoding='utf-8',newline='\\n') as wfile:\n         wfile.write(s)\n \n-def parse_config_into_btc_conifg():\n+def parse_config_into_btc_config():\n     def find_between( s, first, last ):\n         try:\n             start = s.index( first ) + len( first )"
      }
    ]
  },
  {
    "sha": "75263a9e9ab19be73de9739c4251216a4d082f1e",
    "node_id": "C_kwDOABII59oAKDc1MjYzYTllOWFiMTliZTczZGU5NzM5YzQyNTEyMTZhNGQwODJmMWU",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:21:06Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:21:06Z"
      },
      "message": "Actually call the function",
      "tree": {
        "sha": "2babe78d53d5a6fba8c79319486791b85ac638fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2babe78d53d5a6fba8c79319486791b85ac638fa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75263a9e9ab19be73de9739c4251216a4d082f1e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75263a9e9ab19be73de9739c4251216a4d082f1e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75263a9e9ab19be73de9739c4251216a4d082f1e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75263a9e9ab19be73de9739c4251216a4d082f1e/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "40f550589622eb24a0a2d278541e08805c8f3949",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40f550589622eb24a0a2d278541e08805c8f3949",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/40f550589622eb24a0a2d278541e08805c8f3949"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "93931148c938ba585ee4c65456b9557626e66de0",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75263a9e9ab19be73de9739c4251216a4d082f1e/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75263a9e9ab19be73de9739c4251216a4d082f1e/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=75263a9e9ab19be73de9739c4251216a4d082f1e",
        "patch": "@@ -112,6 +112,8 @@ def main():\n             with open(vcxproj_filename, 'w', encoding='utf-8') as vcxproj_file:\n                 vcxproj_file.write(vcxproj_in_file.read().replace(\n                     '@SOURCE_FILES@\\n', content))\n+                    \n+    parse_config_into_btc_config()\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h'), os.path.join(SOURCE_DIR, 'config/bitcoin-config.h'))\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/libsecp256k1_config.h'), os.path.join(SOURCE_DIR, 'secp256k1/src/libsecp256k1-config.h'))\n "
      }
    ]
  },
  {
    "sha": "2b2cfef54503d4881b8257cd680e146a8480b731",
    "node_id": "C_kwDOABII59oAKDJiMmNmZWY1NDUwM2Q0ODgxYjgyNTdjZDY4MGUxNDZhODQ4MGI3MzE",
    "commit": {
      "author": {
        "name": "Deniz Hasler",
        "email": "51458033+CallMeMisterOwl@users.noreply.github.com",
        "date": "2021-10-05T20:22:51Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-10-05T20:22:51Z"
      },
      "message": "Merge branch 'bitcoin:master' into auto_gen_MSVC_issue",
      "tree": {
        "sha": "7b6e3d8ae92ae40bb822b2eca2d6c4bd8e117b43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7b6e3d8ae92ae40bb822b2eca2d6c4bd8e117b43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b2cfef54503d4881b8257cd680e146a8480b731",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhXLQcCRBK7hj4Ov3rIwAA7EcIAKUU3tju6xekjRa1u2UXpNKJ\nhW4GxhLhQkNc3MOIHGnRE699E5mtW41FpMZF3AFdsIPFNC8PB70TaCH/kLN+zIOG\nM+RapMsocjsJHBlkCbpd0MolJUMBxOAjgl/kzp+14ph4I0HNK9uDrOBNVh28Io6b\n4Rhw2orVoAW3euO95Xt/RL898nPhONEBGhI08dXtU23eqgEW5jW4F1ZqyBRkrBzC\nQIKwZ4eeHkrt/qUE+D5CDv4S7DPqJ1RymvVaa/vfzWd7O8S+AvKwz6/rztHx97jb\nv0w8BXxj5jwYsiJeNPZBXWHNxgRa7cyeXc012rU4TrYYow6i/sNVvK1+p7NjqgU=\n=VyCR\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 7b6e3d8ae92ae40bb822b2eca2d6c4bd8e117b43\nparent b333e27c1f4d62a3b2d64373514d767c00a5eb71\nparent 113b863f0773999497f952daa6539a03a66a9de3\nauthor Deniz Hasler <51458033+CallMeMisterOwl@users.noreply.github.com> 1633465371 +0200\ncommitter GitHub <noreply@github.com> 1633465371 +0200\n\nMerge branch 'bitcoin:master' into auto_gen_MSVC_issue\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b2cfef54503d4881b8257cd680e146a8480b731",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b2cfef54503d4881b8257cd680e146a8480b731",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b2cfef54503d4881b8257cd680e146a8480b731/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b333e27c1f4d62a3b2d64373514d767c00a5eb71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b333e27c1f4d62a3b2d64373514d767c00a5eb71",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b333e27c1f4d62a3b2d64373514d767c00a5eb71"
      },
      {
        "sha": "113b863f0773999497f952daa6539a03a66a9de3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/113b863f0773999497f952daa6539a03a66a9de3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/113b863f0773999497f952daa6539a03a66a9de3"
      }
    ],
    "stats": {
      "total": 1681,
      "additions": 966,
      "deletions": 715
    },
    "files": [
      {
        "sha": "3d0aa5d132f095e2046f3ed0a1e380c5833d2dd7",
        "filename": "contrib/signet/getcoins.py",
        "status": "modified",
        "additions": 91,
        "deletions": 3,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/contrib/signet/getcoins.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/contrib/signet/getcoins.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/getcoins.py?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -4,18 +4,77 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n import argparse\n+import io\n+import requests\n import subprocess\n import sys\n-import requests\n \n DEFAULT_GLOBAL_FAUCET = 'https://signetfaucet.com/claim'\n+DEFAULT_GLOBAL_CAPTCHA = 'https://signetfaucet.com/captcha'\n GLOBAL_FIRST_BLOCK_HASH = '00000086d6b2636cb2a392d45edc4ec544a10024d30141c9adf4bfd9de533b53'\n \n+# braille unicode block\n+BASE = 0x2800\n+BIT_PER_PIXEL = [\n+    [0x01, 0x08],\n+    [0x02, 0x10],\n+    [0x04, 0x20],\n+    [0x40, 0x80],\n+]\n+BW = 2\n+BH = 4\n+\n+# imagemagick or compatible fork (used for converting SVG)\n+CONVERT = 'convert'\n+\n+class PPMImage:\n+    '''\n+    Load a PPM image (Pillow-ish API).\n+    '''\n+    def __init__(self, f):\n+        if f.readline() != b'P6\\n':\n+            raise ValueError('Invalid ppm format: header')\n+        line = f.readline()\n+        (width, height) = (int(x) for x in line.rstrip().split(b' '))\n+        if f.readline() != b'255\\n':\n+            raise ValueError('Invalid ppm format: color depth')\n+        data = f.read(width * height * 3)\n+        stride = width * 3\n+        self.size = (width, height)\n+        self._grid = [[tuple(data[stride * y + 3 * x:stride * y + 3 * (x + 1)]) for x in range(width)] for y in range(height)]\n+\n+    def getpixel(self, pos):\n+        return self._grid[pos[1]][pos[0]]\n+\n+def print_image(img, threshold=128):\n+    '''Print black-and-white image to terminal in braille unicode characters.'''\n+    x_blocks = (img.size[0] + BW - 1) // BW\n+    y_blocks = (img.size[1] + BH - 1) // BH\n+\n+    for yb in range(y_blocks):\n+        line = []\n+        for xb in range(x_blocks):\n+            ch = BASE\n+            for y in range(BH):\n+                for x in range(BW):\n+                    try:\n+                        val = img.getpixel((xb * BW + x, yb * BH + y))\n+                    except IndexError:\n+                        pass\n+                    else:\n+                        if val[0] < threshold:\n+                            ch |= BIT_PER_PIXEL[y][x]\n+            line.append(chr(ch))\n+        print(''.join(line))\n+\n parser = argparse.ArgumentParser(description='Script to get coins from a faucet.', epilog='You may need to start with double-dash (--) when providing bitcoin-cli arguments.')\n parser.add_argument('-c', '--cmd', dest='cmd', default='bitcoin-cli', help='bitcoin-cli command to use')\n parser.add_argument('-f', '--faucet', dest='faucet', default=DEFAULT_GLOBAL_FAUCET, help='URL of the faucet')\n+parser.add_argument('-g', '--captcha', dest='captcha', default=DEFAULT_GLOBAL_CAPTCHA, help='URL of the faucet captcha, or empty if no captcha is needed')\n parser.add_argument('-a', '--addr', dest='addr', default='', help='Bitcoin address to which the faucet should send')\n parser.add_argument('-p', '--password', dest='password', default='', help='Faucet password, if any')\n+parser.add_argument('-n', '--amount', dest='amount', default='0.001', help='Amount to request (0.001-0.1, default is 0.001)')\n+parser.add_argument('-i', '--imagemagick', dest='imagemagick', default=CONVERT, help='Path to imagemagick convert utility')\n parser.add_argument('bitcoin_cli_args', nargs='*', help='Arguments to pass on to bitcoin-cli (default: -signet)')\n \n args = parser.parse_args()\n@@ -43,14 +102,43 @@ def bitcoin_cli(rpc_command_and_params):\n     if curr_signet_hash != GLOBAL_FIRST_BLOCK_HASH:\n         print('The global faucet cannot be used with a custom Signet network. Please use the global signet or setup your custom faucet to use this functionality.\\n')\n         exit(1)\n+else:\n+    # For custom faucets, don't request captcha by default.\n+    if args.captcha == DEFAULT_GLOBAL_CAPTCHA:\n+        args.captcha = ''\n \n if args.addr == '':\n     # get address for receiving coins\n     args.addr = bitcoin_cli(['getnewaddress', 'faucet', 'bech32'])\n \n-data = {'address': args.addr, 'password': args.password}\n+data = {'address': args.addr, 'password': args.password, 'amount': args.amount}\n+\n+# Store cookies\n+# for debugging: print(session.cookies.get_dict())\n+session = requests.Session()\n+\n+if args.captcha != '': # Retrieve a captcha\n+    try:\n+        res = session.get(args.captcha)\n+    except:\n+        print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n+        exit(1)\n+\n+    # Convert SVG image to PPM, and load it\n+    try:\n+        rv = subprocess.run([args.imagemagick, '-', '-depth', '8', 'ppm:-'], input=res.content, check=True, capture_output=True)\n+    except FileNotFoundError:\n+        print('The binary', args.imagemagick, 'could not be found. Please make sure ImageMagick (or a compatible fork) is installed and that the correct path is specified.')\n+        exit(1)\n+    img = PPMImage(io.BytesIO(rv.stdout))\n+\n+    # Terminal interaction\n+    print_image(img)\n+    print('Enter captcha: ', end='')\n+    data['captcha'] = input()\n+\n try:\n-    res = requests.post(args.faucet, data=data)\n+    res = session.post(args.faucet, data=data)\n except:\n     print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n     exit(1)"
      },
      {
        "sha": "12fdc9ad7588514e2920812359b5b084860bc91e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -117,6 +117,7 @@ endif\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addrman.h \\\n+  addrman_impl.h \\\n   attributes.h \\\n   banman.h \\\n   base58.h \\"
      },
      {
        "sha": "50fd09101ee568cd305b05ed1f3b7682dd828056",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -170,21 +170,21 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr)\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)\n {\n     const auto pathAddr = args.GetDataDirNet() / \"peers.dat\";\n     return SerializeFileDB(\"peers\", pathAddr, addr, CLIENT_VERSION);\n }\n \n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers)\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers)\n {\n     DeserializeDB(ssPeers, addr, false);\n }\n \n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman)\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n {\n     auto check_addrman = std::clamp<int32_t>(args.GetIntArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+    addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n \n     int64_t nStart = GetTimeMillis();\n     const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n@@ -193,7 +193,7 @@ std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const A\n         LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n     } catch (const DbNotFoundError&) {\n         // Addrman can be in an inconsistent state after failure, reset it\n-        addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n         LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", path_addr);\n         DumpPeerAddresses(args, *addrman);\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "19be4b5bb4ee284c92745c7115c9ec1042c02f83",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -14,14 +14,14 @@\n #include <vector>\n \n class ArgsManager;\n-class CAddrMan;\n+class AddrMan;\n class CAddress;\n class CDataStream;\n struct bilingual_str;\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr);\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr);\n /** Only used by tests. */\n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers);\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers);\n \n /** Access to the banlist database (banlist.json) */\n class CBanDB\n@@ -48,7 +48,7 @@ class CBanDB\n };\n \n /** Returns an error string on failure */\n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman);\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman);\n \n /**\n  * Dump the anchor IP address database (anchors.dat)"
      },
      {
        "sha": "c364a7710b458a0440b04a2fcb20a74eaec16b12",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 354,
        "deletions": 181,
        "changes": 535,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -4,25 +4,27 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <addrman.h>\n+#include <addrman_impl.h>\n \n-#include <clientversion.h>\n #include <hash.h>\n-#include <logging.h>\n #include <netaddress.h>\n+#include <protocol.h>\n+#include <random.h>\n #include <serialize.h>\n #include <streams.h>\n+#include <timedata.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n #include <util/check.h>\n \n #include <cmath>\n #include <optional>\n-#include <unordered_map>\n-#include <unordered_set>\n \n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n /** Over how many buckets entries with new addresses originating from a single group are spread */\n static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n-/** Maximum number of times an address can be added to the new table */\n+/** Maximum number of times an address can occur in the new table */\n static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n /** How old addresses can maximally be */\n static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n@@ -39,7 +41,7 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool>& asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n@@ -49,7 +51,7 @@ int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asma\n     return tried_bucket;\n }\n \n-int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool>& asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n@@ -60,13 +62,13 @@ int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std:\n     return new_bucket;\n }\n \n-int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int nBucket) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n }\n \n-bool CAddrInfo::IsTerrible(int64_t nNow) const\n+bool AddrInfo::IsTerrible(int64_t nNow) const\n {\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n         return false;\n@@ -86,7 +88,7 @@ bool CAddrInfo::IsTerrible(int64_t nNow) const\n     return false;\n }\n \n-double CAddrInfo::GetChance(int64_t nNow) const\n+double AddrInfo::GetChance(int64_t nNow) const\n {\n     double fChance = 1.0;\n     int64_t nSinceLastTry = std::max<int64_t>(nNow - nLastTry, 0);\n@@ -101,7 +103,7 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrManImpl::AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio)\n     : insecure_rand{deterministic}\n     , nKey{deterministic ? uint256{1} : insecure_rand.rand256()}\n     , m_consistency_check_ratio{consistency_check_ratio}\n@@ -119,8 +121,13 @@ CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consiste\n     }\n }\n \n+AddrManImpl::~AddrManImpl()\n+{\n+    nKey.SetNull();\n+}\n+\n template <typename Stream>\n-void CAddrMan::Serialize(Stream& s_) const\n+void AddrManImpl::Serialize(Stream& s_) const\n {\n     LOCK(cs);\n \n@@ -183,7 +190,7 @@ void CAddrMan::Serialize(Stream& s_) const\n     int nIds = 0;\n     for (const auto& entry : mapInfo) {\n         mapUnkIds[entry.first] = nIds;\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.nRefCount) {\n             assert(nIds != nNew); // this means nNew was wrong, oh ow\n             s << info;\n@@ -192,7 +199,7 @@ void CAddrMan::Serialize(Stream& s_) const\n     }\n     nIds = 0;\n     for (const auto& entry : mapInfo) {\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.fInTried) {\n             assert(nIds != nTried); // this means nTried was wrong, oh ow\n             s << info;\n@@ -223,7 +230,7 @@ void CAddrMan::Serialize(Stream& s_) const\n }\n \n template <typename Stream>\n-void CAddrMan::Unserialize(Stream& s_)\n+void AddrManImpl::Unserialize(Stream& s_)\n {\n     LOCK(cs);\n \n@@ -262,21 +269,21 @@ void CAddrMan::Unserialize(Stream& s_)\n \n     if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]\",\n                     nNew,\n                     ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]\",\n                     nTried,\n                     ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     // Deserialize entries from the new table.\n     for (int n = 0; n < nNew; n++) {\n-        CAddrInfo &info = mapInfo[n];\n+        AddrInfo& info = mapInfo[n];\n         s >> info;\n         mapAddr[info] = n;\n         info.nRandomPos = vRandom.size();\n@@ -287,7 +294,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     // Deserialize entries from the tried table.\n     int nLost = 0;\n     for (int n = 0; n < nTried; n++) {\n-        CAddrInfo info;\n+        AddrInfo info;\n         s >> info;\n         int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n         int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n@@ -344,7 +351,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     for (auto bucket_entry : bucket_entries) {\n         int bucket{bucket_entry.first};\n         const int entry_index{bucket_entry.second};\n-        CAddrInfo& info = mapInfo[entry_index];\n+        AddrInfo& info = mapInfo[entry_index];\n \n         // Don't store the entry in the new bucket if it's not a valid address for our addrman\n         if (!info.IsValid()) continue;\n@@ -394,16 +401,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     }\n }\n \n-// explicit instantiation\n-template void CAddrMan::Serialize(CHashWriter& s) const;\n-template void CAddrMan::Serialize(CAutoFile& s) const;\n-template void CAddrMan::Serialize(CDataStream& s) const;\n-template void CAddrMan::Unserialize(CAutoFile& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n-template void CAddrMan::Unserialize(CDataStream& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n-\n-CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n+AddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -418,12 +416,12 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n     return nullptr;\n }\n \n-CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n+AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     AssertLockHeld(cs);\n \n     int nId = nIdCount++;\n-    mapInfo[nId] = CAddrInfo(addr, addrSource);\n+    mapInfo[nId] = AddrInfo(addr, addrSource);\n     mapAddr[addr] = nId;\n     mapInfo[nId].nRandomPos = vRandom.size();\n     vRandom.push_back(nId);\n@@ -432,7 +430,7 @@ CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, in\n     return &mapInfo[nId];\n }\n \n-void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n+void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n {\n     AssertLockHeld(cs);\n \n@@ -456,12 +454,12 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n     vRandom[nRndPos2] = nId1;\n }\n \n-void CAddrMan::Delete(int nId)\n+void AddrManImpl::Delete(int nId)\n {\n     AssertLockHeld(cs);\n \n     assert(mapInfo.count(nId) != 0);\n-    CAddrInfo& info = mapInfo[nId];\n+    AddrInfo& info = mapInfo[nId];\n     assert(!info.fInTried);\n     assert(info.nRefCount == 0);\n \n@@ -472,14 +470,14 @@ void CAddrMan::Delete(int nId)\n     nNew--;\n }\n \n-void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n+void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n {\n     AssertLockHeld(cs);\n \n     // if there is an entry in the specified bucket, delete it.\n     if (vvNew[nUBucket][nUBucketPos] != -1) {\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n-        CAddrInfo& infoDelete = mapInfo[nIdDelete];\n+        AddrInfo& infoDelete = mapInfo[nIdDelete];\n         assert(infoDelete.nRefCount > 0);\n         infoDelete.nRefCount--;\n         vvNew[nUBucket][nUBucketPos] = -1;\n@@ -489,7 +487,7 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n     }\n }\n \n-void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n+void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -517,7 +515,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n         // find an item to evict\n         int nIdEvict = vvTried[nKBucket][nKBucketPos];\n         assert(mapInfo.count(nIdEvict) == 1);\n-        CAddrInfo& infoOld = mapInfo[nIdEvict];\n+        AddrInfo& infoOld = mapInfo[nIdEvict];\n \n         // Remove the to-be-evicted item from the tried set.\n         infoOld.fInTried = false;\n@@ -542,21 +540,21 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n+void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n     int nId;\n \n     nLastGood = nTime;\n \n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -598,7 +596,7 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n     }\n }\n \n-bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     AssertLockHeld(cs);\n \n@@ -607,7 +605,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n \n     bool fNew = false;\n     int nId;\n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // Do not set a penalty for a source's self-announcement\n     if (addr == source) {\n@@ -654,7 +652,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n         if (!fInsert) {\n-            CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n+            AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n             if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n                 // Overwrite the existing new table entry.\n                 fInsert = true;\n@@ -673,17 +671,17 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     return fNew;\n }\n \n-void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -697,15 +695,13 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n     }\n }\n \n-CAddrInfo CAddrMan::Select_(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n-    if (vRandom.empty())\n-        return CAddrInfo();\n+    if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0)\n-        return CAddrInfo();\n+    if (newOnly && nNew == 0) return {};\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n@@ -722,9 +718,10 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n             int nId = vvTried[nKBucket][nKBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n+            const AddrInfo& info{it_found->second};\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n+            }\n             fChanceFactor *= 1.2;\n         }\n     } else {\n@@ -740,118 +737,16 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n             int nId = vvNew[nUBucket][nUBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n-            fChanceFactor *= 1.2;\n-        }\n-    }\n-}\n-\n-void CAddrMan::Check() const\n-{\n-    AssertLockHeld(cs);\n-\n-    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n-    if (m_consistency_check_ratio == 0) return;\n-    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n-\n-    const int err{ForceCheckAddrman()};\n-    if (err) {\n-        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n-        assert(false);\n-    }\n-}\n-\n-int CAddrMan::ForceCheckAddrman() const\n-{\n-    AssertLockHeld(cs);\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n-\n-    std::unordered_set<int> setTried;\n-    std::unordered_map<int, int> mapNew;\n-\n-    if (vRandom.size() != (size_t)(nTried + nNew))\n-        return -7;\n-\n-    for (const auto& entry : mapInfo) {\n-        int n = entry.first;\n-        const CAddrInfo& info = entry.second;\n-        if (info.fInTried) {\n-            if (!info.nLastSuccess)\n-                return -1;\n-            if (info.nRefCount)\n-                return -2;\n-            setTried.insert(n);\n-        } else {\n-            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n-                return -3;\n-            if (!info.nRefCount)\n-                return -4;\n-            mapNew[n] = info.nRefCount;\n-        }\n-        const auto it{mapAddr.find(info)};\n-        if (it == mapAddr.end() || it->second != n) {\n-            return -5;\n-        }\n-        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n-            return -14;\n-        if (info.nLastTry < 0)\n-            return -6;\n-        if (info.nLastSuccess < 0)\n-            return -8;\n-    }\n-\n-    if (setTried.size() != (size_t)nTried)\n-        return -9;\n-    if (mapNew.size() != (size_t)nNew)\n-        return -10;\n-\n-    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvTried[n][i] != -1) {\n-                if (!setTried.count(vvTried[n][i]))\n-                    return -11;\n-                const auto it{mapInfo.find(vvTried[n][i])};\n-                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n-                    return -17;\n-                }\n-                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n-                    return -18;\n-                }\n-                setTried.erase(vvTried[n][i]);\n-            }\n-        }\n-    }\n-\n-    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvNew[n][i] != -1) {\n-                if (!mapNew.count(vvNew[n][i]))\n-                    return -12;\n-                const auto it{mapInfo.find(vvNew[n][i])};\n-                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n-                    return -19;\n-                }\n-                if (--mapNew[vvNew[n][i]] == 0)\n-                    mapNew.erase(vvNew[n][i]);\n+            const AddrInfo& info{it_found->second};\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n             }\n+            fChanceFactor *= 1.2;\n         }\n     }\n-\n-    if (setTried.size())\n-        return -13;\n-    if (mapNew.size())\n-        return -15;\n-    if (nKey.IsNull())\n-        return -16;\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n-    return 0;\n }\n \n-void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -865,38 +760,41 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size\n \n     // gather a list of random nodes, skipping those of low quality\n     const int64_t now{GetAdjustedTime()};\n+    std::vector<CAddress> addresses;\n     for (unsigned int n = 0; n < vRandom.size(); n++) {\n-        if (vAddr.size() >= nNodes)\n+        if (addresses.size() >= nNodes)\n             break;\n \n         int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);\n         const auto it{mapInfo.find(vRandom[n])};\n         assert(it != mapInfo.end());\n \n-        const CAddrInfo& ai{it->second};\n+        const AddrInfo& ai{it->second};\n \n         // Filter by network (optional)\n         if (network != std::nullopt && ai.GetNetClass() != network) continue;\n \n         // Filter for quality\n         if (ai.IsTerrible(now)) continue;\n \n-        vAddr.push_back(ai);\n+        addresses.push_back(ai);\n     }\n+\n+    return addresses;\n }\n \n-void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n+void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -908,17 +806,17 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n         info.nTime = nTime;\n }\n \n-void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -928,7 +826,7 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n     info.nServices = nServices;\n }\n \n-void CAddrMan::ResolveCollisions_()\n+void AddrManImpl::ResolveCollisions_()\n {\n     AssertLockHeld(cs);\n \n@@ -941,7 +839,7 @@ void CAddrMan::ResolveCollisions_()\n         if (mapInfo.count(id_new) != 1) {\n             erase_collision = true;\n         } else {\n-            CAddrInfo& info_new = mapInfo[id_new];\n+            AddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n             int tried_bucket = info_new.GetTriedBucket(nKey, m_asmap);\n@@ -952,7 +850,7 @@ void CAddrMan::ResolveCollisions_()\n \n                 // Get the to-be-evicted address that is being tested\n                 int id_old = vvTried[tried_bucket][tried_bucket_pos];\n-                CAddrInfo& info_old = mapInfo[id_old];\n+                AddrInfo& info_old = mapInfo[id_old];\n \n                 // Has successfully connected in last X hours\n                 if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n@@ -989,11 +887,11 @@ void CAddrMan::ResolveCollisions_()\n     }\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision_()\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n {\n     AssertLockHeld(cs);\n \n-    if (m_tried_collisions.size() == 0) return CAddrInfo();\n+    if (m_tried_collisions.size() == 0) return {};\n \n     std::set<int>::iterator it = m_tried_collisions.begin();\n \n@@ -1004,16 +902,291 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     // If id_new not found in mapInfo remove it from m_tried_collisions\n     if (mapInfo.count(id_new) != 1) {\n         m_tried_collisions.erase(it);\n-        return CAddrInfo();\n+        return {};\n     }\n \n-    const CAddrInfo& newInfo = mapInfo[id_new];\n+    const AddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n     int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n-    int id_old = vvTried[tried_bucket][tried_bucket_pos];\n+    const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n+    return {info_old, info_old.nLastTry};\n+}\n+\n+void AddrManImpl::Check() const\n+{\n+    AssertLockHeld(cs);\n+\n+    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n+    if (m_consistency_check_ratio == 0) return;\n+    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n+\n+    const int err{ForceCheckAddrman()};\n+    if (err) {\n+        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+        assert(false);\n+    }\n+}\n+\n+int AddrManImpl::ForceCheckAddrman() const\n+{\n+    AssertLockHeld(cs);\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n+\n+    std::unordered_set<int> setTried;\n+    std::unordered_map<int, int> mapNew;\n+\n+    if (vRandom.size() != (size_t)(nTried + nNew))\n+        return -7;\n+\n+    for (const auto& entry : mapInfo) {\n+        int n = entry.first;\n+        const AddrInfo& info = entry.second;\n+        if (info.fInTried) {\n+            if (!info.nLastSuccess)\n+                return -1;\n+            if (info.nRefCount)\n+                return -2;\n+            setTried.insert(n);\n+        } else {\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                return -3;\n+            if (!info.nRefCount)\n+                return -4;\n+            mapNew[n] = info.nRefCount;\n+        }\n+        const auto it{mapAddr.find(info)};\n+        if (it == mapAddr.end() || it->second != n) {\n+            return -5;\n+        }\n+        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n+            return -14;\n+        if (info.nLastTry < 0)\n+            return -6;\n+        if (info.nLastSuccess < 0)\n+            return -8;\n+    }\n+\n+    if (setTried.size() != (size_t)nTried)\n+        return -9;\n+    if (mapNew.size() != (size_t)nNew)\n+        return -10;\n+\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvTried[n][i] != -1) {\n+                if (!setTried.count(vvTried[n][i]))\n+                    return -11;\n+                const auto it{mapInfo.find(vvTried[n][i])};\n+                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n+                    return -17;\n+                }\n+                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n+                    return -18;\n+                }\n+                setTried.erase(vvTried[n][i]);\n+            }\n+        }\n+    }\n+\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[n][i] != -1) {\n+                if (!mapNew.count(vvNew[n][i]))\n+                    return -12;\n+                const auto it{mapInfo.find(vvNew[n][i])};\n+                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n+                    return -19;\n+                }\n+                if (--mapNew[vvNew[n][i]] == 0)\n+                    mapNew.erase(vvNew[n][i]);\n+            }\n+        }\n+    }\n+\n+    if (setTried.size())\n+        return -13;\n+    if (mapNew.size())\n+        return -15;\n+    if (nKey.IsNull())\n+        return -16;\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n+    return 0;\n+}\n+\n+size_t AddrManImpl::size() const\n+{\n+    LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n+    return vRandom.size();\n+}\n+\n+bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    LOCK(cs);\n+    int nAdd = 0;\n+    Check();\n+    for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+        nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n+    Check();\n+    if (nAdd) {\n+        LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+    }\n+    return nAdd > 0;\n+}\n+\n+void AddrManImpl::Good(const CService& addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Good_(addr, /* test_before_evict */ true, nTime);\n+    Check();\n+}\n \n-    return mapInfo[id_old];\n+void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Attempt_(addr, fCountFailure, nTime);\n+    Check();\n+}\n+\n+void AddrManImpl::ResolveCollisions()\n+{\n+    LOCK(cs);\n+    Check();\n+    ResolveCollisions_();\n+    Check();\n+}\n+\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision()\n+{\n+    LOCK(cs);\n+    Check();\n+    const auto ret = SelectTriedCollision_();\n+    Check();\n+    return ret;\n+}\n+\n+std::pair<CAddress, int64_t> AddrManImpl::Select(bool newOnly) const\n+{\n+    LOCK(cs);\n+    Check();\n+    const auto addrRet = Select_(newOnly);\n+    Check();\n+    return addrRet;\n+}\n+\n+std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    LOCK(cs);\n+    Check();\n+    const auto addresses = GetAddr_(max_addresses, max_pct, network);\n+    Check();\n+    return addresses;\n+}\n+\n+void AddrManImpl::Connected(const CService& addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Connected_(addr, nTime);\n+    Check();\n+}\n+\n+void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)\n+{\n+    LOCK(cs);\n+    Check();\n+    SetServices_(addr, nServices);\n+    Check();\n+}\n+\n+const std::vector<bool>& AddrManImpl::GetAsmap() const\n+{\n+    return m_asmap;\n+}\n+\n+AddrMan::AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+    : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n+\n+AddrMan::~AddrMan() = default;\n+\n+template <typename Stream>\n+void AddrMan::Serialize(Stream& s_) const\n+{\n+    m_impl->Serialize<Stream>(s_);\n+}\n+\n+template <typename Stream>\n+void AddrMan::Unserialize(Stream& s_)\n+{\n+    m_impl->Unserialize<Stream>(s_);\n+}\n+\n+// explicit instantiation\n+template void AddrMan::Serialize(CHashWriter& s) const;\n+template void AddrMan::Serialize(CAutoFile& s) const;\n+template void AddrMan::Serialize(CDataStream& s) const;\n+template void AddrMan::Unserialize(CAutoFile& s);\n+template void AddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void AddrMan::Unserialize(CDataStream& s);\n+template void AddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n+size_t AddrMan::size() const\n+{\n+    return m_impl->size();\n+}\n+\n+bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    return m_impl->Add(vAddr, source, nTimePenalty);\n+}\n+\n+void AddrMan::Good(const CService& addr, int64_t nTime)\n+{\n+    m_impl->Good(addr, nTime);\n+}\n+\n+void AddrMan::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n+{\n+    m_impl->Attempt(addr, fCountFailure, nTime);\n+}\n+\n+void AddrMan::ResolveCollisions()\n+{\n+    m_impl->ResolveCollisions();\n+}\n+\n+std::pair<CAddress, int64_t> AddrMan::SelectTriedCollision()\n+{\n+    return m_impl->SelectTriedCollision();\n+}\n+\n+std::pair<CAddress, int64_t> AddrMan::Select(bool newOnly) const\n+{\n+    return m_impl->Select(newOnly);\n+}\n+\n+std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    return m_impl->GetAddr(max_addresses, max_pct, network);\n+}\n+\n+void AddrMan::Connected(const CService& addr, int64_t nTime)\n+{\n+    m_impl->Connected(addr, nTime);\n+}\n+\n+void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)\n+{\n+    m_impl->SetServices(addr, nServices);\n+}\n+\n+const std::vector<bool>& AddrMan::GetAsmap() const\n+{\n+    return m_impl->GetAsmap();\n }"
      },
      {
        "sha": "174ab4f811b0590732f437ed637ecdc8fb020e7d",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 39,
        "deletions": 335,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -6,94 +6,22 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include <fs.h>\n-#include <logging.h>\n #include <netaddress.h>\n #include <protocol.h>\n-#include <sync.h>\n+#include <streams.h>\n #include <timedata.h>\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n-#include <set>\n-#include <unordered_map>\n+#include <utility>\n #include <vector>\n \n+class AddrManImpl;\n+\n /** Default for -checkaddrman */\n static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n \n-/**\n- * Extended statistics about a CAddress\n- */\n-class CAddrInfo : public CAddress\n-{\n-public:\n-    //! last try whatsoever by us (memory only)\n-    int64_t nLastTry{0};\n-\n-    //! last counted attempt (memory only)\n-    int64_t nLastCountAttempt{0};\n-\n-private:\n-    //! where knowledge about this address first came from\n-    CNetAddr source;\n-\n-    //! last successful connection by us\n-    int64_t nLastSuccess{0};\n-\n-    //! connection attempts since last successful attempt\n-    int nAttempts{0};\n-\n-    //! reference count in new sets (memory only)\n-    int nRefCount{0};\n-\n-    //! in tried set? (memory only)\n-    bool fInTried{false};\n-\n-    //! position in vRandom\n-    mutable int nRandomPos{-1};\n-\n-    friend class CAddrMan;\n-    friend class CAddrManDeterministic;\n-\n-public:\n-\n-    SERIALIZE_METHODS(CAddrInfo, obj)\n-    {\n-        READWRITEAS(CAddress, obj);\n-        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n-    }\n-\n-    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n-    {\n-    }\n-\n-    CAddrInfo() : CAddress(), source()\n-    {\n-    }\n-\n-    //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n-    {\n-        return GetNewBucket(nKey, source, asmap);\n-    }\n-\n-    //! Calculate in which position of a bucket to store this entry.\n-    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n-\n-    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n-    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n-\n-    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n-    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n-};\n-\n /** Stochastic address manager\n  *\n  * Design goals:\n@@ -123,290 +51,64 @@ class CAddrInfo : public CAddress\n  *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n+class AddrMan\n+{\n+    const std::unique_ptr<AddrManImpl> m_impl;\n \n-/** Total number of buckets for tried addresses */\n-static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n-static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n-\n-/** Total number of buckets for new addresses */\n-static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n-static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+public:\n+    explicit AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n-/** Maximum allowed number of entries in buckets for new and tried addresses */\n-static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n-static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n+    ~AddrMan();\n \n-/**\n- * Stochastical (IP) address manager\n- */\n-class CAddrMan\n-{\n-public:\n     template <typename Stream>\n-    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Serialize(Stream& s_) const;\n \n     template <typename Stream>\n-    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n-\n-    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n-\n-    ~CAddrMan()\n-    {\n-        nKey.SetNull();\n-    }\n+    void Unserialize(Stream& s_);\n \n     //! Return the number of (unique) addresses in all tables.\n-    size_t size() const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n-        return vRandom.size();\n-    }\n+    size_t size() const;\n \n     //! Add addresses to addrman's new table.\n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        int nAdd = 0;\n-        Check();\n-        for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n-            nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n-        Check();\n-        if (nAdd) {\n-            LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n-        }\n-        return nAdd > 0;\n-    }\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n-    //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Good_(addr, /* test_before_evict */ true, nTime);\n-        Check();\n-    }\n+    //! Mark an entry as accessible, possibly moving it from \"new\" to \"tried\".\n+    void Good(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Attempt_(addr, fCountFailure, nTime);\n-        Check();\n-    }\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        ResolveCollisions_();\n-        Check();\n-    }\n-\n-    //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo ret = SelectTriedCollision_();\n-        Check();\n-        return ret;\n-    }\n+    void ResolveCollisions();\n \n     /**\n-     * Choose an address to connect to.\n+     * Randomly select an address in the tried table that another address is\n+     * attempting to evict.\n+     *\n+     * @return CAddress The record for the selected tried peer.\n+     *         int64_t  The last time we attempted to connect to that peer.\n      */\n-    CAddrInfo Select(bool newOnly = false) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo addrRet = Select_(newOnly);\n-        Check();\n-        return addrRet;\n-    }\n+    std::pair<CAddress, int64_t> SelectTriedCollision();\n \n     /**\n-     * Return all or many randomly selected addresses, optionally by network.\n+     * Choose an address to connect to.\n      *\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @return    CAddress The record for the selected peer.\n+     *            int64_t  The last time we attempted to connect to that peer.\n      */\n-    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        std::vector<CAddress> vAddr;\n-        GetAddr_(vAddr, max_addresses, max_pct, network);\n-        Check();\n-        return vAddr;\n-    }\n-\n-    //! Outer function for Connected_()\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Connected_(addr, nTime);\n-        Check();\n-    }\n-\n-    void SetServices(const CService &addr, ServiceFlags nServices)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        SetServices_(addr, nServices);\n-        Check();\n-    }\n-\n-    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n-\n-private:\n-    //! A mutex to protect the inner data structures.\n-    mutable Mutex cs;\n-\n-    //! Source of random numbers for randomization in inner loops\n-    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n-\n-    //! secret key to randomize bucket select with\n-    uint256 nKey;\n-\n-    //! Serialization versions.\n-    enum Format : uint8_t {\n-        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n-        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n-        V2_ASMAP = 2,         //!< for files including asmap version\n-        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n-    };\n-\n-    //! The maximum format this software knows it can unserialize. Also, we always serialize\n-    //! in this format.\n-    //! The format (first byte in the serialized stream) can be higher than this and\n-    //! still this software may be able to unserialize the file - if the second byte\n-    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n-    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n-\n-    //! The initial value of a field that is incremented every time an incompatible format\n-    //! change is made (such that old software versions would not be able to parse and\n-    //! understand the new file format). This is 32 because we overtook the \"key size\"\n-    //! field which was 32 historically.\n-    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n-    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n-\n-    //! last used nId\n-    int nIdCount GUARDED_BY(cs){0};\n-\n-    //! table with information about all nIds\n-    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n-\n-    //! find an nId based on its network address\n-    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n-\n-    //! randomly-ordered vector of all nIds\n-    //! This is mutable because it is unobservable outside the class, so any\n-    //! changes to it (even in const methods) are also unobservable.\n-    mutable std::vector<int> vRandom GUARDED_BY(cs);\n-\n-    // number of \"tried\" entries\n-    int nTried GUARDED_BY(cs){0};\n-\n-    //! list of \"tried\" buckets\n-    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! number of (unique) \"new\" entries\n-    int nNew GUARDED_BY(cs){0};\n-\n-    //! list of \"new\" buckets\n-    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n-    int64_t nLastGood GUARDED_BY(cs){1};\n-\n-    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n-    std::set<int> m_tried_collisions;\n-\n-    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n-    const int32_t m_consistency_check_ratio;\n-\n-    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n-    // Should be always empty if no file was provided.\n-    // This mapping is then used for bucketing nodes in Addrman.\n-    //\n-    // If asmap is provided, nodes will be bucketed by\n-    // AS they belong to, in order to make impossible for a node\n-    // to connect to several nodes hosted in a single AS.\n-    // This is done in response to Erebus attack, but also to generally\n-    // diversify the connections every node creates,\n-    // especially useful when a large fraction of nodes\n-    // operate under a couple of cloud providers.\n-    //\n-    // If a new asmap was provided, the existing records\n-    // would be re-bucketed accordingly.\n-    const std::vector<bool> m_asmap;\n-\n-    //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Swap two elements in vRandom.\n-    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Delete an entry. It must not be in tried, and have refcount 0.\n-    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n-    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Add an entry to the \"new\" table.\n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry as attempted to connect.\n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n-    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Perform consistency check, regardless of m_consistency_check_ratio.\n-    //! @returns an error code or zero.\n-    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::pair<CAddress, int64_t> Select(bool newOnly = false) const;\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n      *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n      * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n+     *\n+     * @return                   A vector of randomly selected addresses from vRandom.\n      */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const;\n \n     /** We have successfully connected to this peer. Calling this function\n      *  updates the CAddress's nTime, which is used in our IsTerrible()\n@@ -419,13 +121,15 @@ class CAddrMan\n      * @param[in]   addr     The address of the peer we were connected to\n      * @param[in]   nTime    The time that we were last connected to this peer\n      */\n-    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void Connected(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Update an entry's service bits.\n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void SetServices(const CService& addr, ServiceFlags nServices);\n+\n+    const std::vector<bool>& GetAsmap() const;\n \n-    friend class CAddrManTest;\n-    friend class CAddrManDeterministic;\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "1dc7f25f9c476dc62774c69fd485b88c060ef0ae",
        "filename": "src/addrman_impl.h",
        "status": "added",
        "additions": 271,
        "deletions": 0,
        "changes": 271,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRMAN_IMPL_H\n+#define BITCOIN_ADDRMAN_IMPL_H\n+\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <protocol.h>\n+#include <serialize.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <utility>\n+#include <vector>\n+\n+/** Total number of buckets for tried addresses */\n+static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n+/** Total number of buckets for new addresses */\n+static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+/** Maximum allowed number of entries in buckets for new and tried addresses */\n+static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n+static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n+\n+/**\n+ * Extended statistics about a CAddress\n+ */\n+class AddrInfo : public CAddress\n+{\n+public:\n+    //! last try whatsoever by us (memory only)\n+    int64_t nLastTry{0};\n+\n+    //! last counted attempt (memory only)\n+    int64_t nLastCountAttempt{0};\n+\n+    //! where knowledge about this address first came from\n+    CNetAddr source;\n+\n+    //! last successful connection by us\n+    int64_t nLastSuccess{0};\n+\n+    //! connection attempts since last successful attempt\n+    int nAttempts{0};\n+\n+    //! reference count in new sets (memory only)\n+    int nRefCount{0};\n+\n+    //! in tried set? (memory only)\n+    bool fInTried{false};\n+\n+    //! position in vRandom\n+    mutable int nRandomPos{-1};\n+\n+    SERIALIZE_METHODS(AddrInfo, obj)\n+    {\n+        READWRITEAS(CAddress, obj);\n+        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n+    }\n+\n+    AddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n+    {\n+    }\n+\n+    AddrInfo() : CAddress(), source()\n+    {\n+    }\n+\n+    //! Calculate in which \"tried\" bucket this entry belongs\n+    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n+    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n+    {\n+        return GetNewBucket(nKey, source, asmap);\n+    }\n+\n+    //! Calculate in which position of a bucket to store this entry.\n+    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n+\n+    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n+    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n+\n+    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n+    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n+};\n+\n+class AddrManImpl\n+{\n+public:\n+    AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio);\n+\n+    ~AddrManImpl();\n+\n+    template <typename Stream>\n+    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    template <typename Stream>\n+    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Good(const CService& addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::pair<CAddress, int64_t> SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::pair<CAddress, int64_t> Select(bool newOnly) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Connected(const CService& addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void SetServices(const CService& addr, ServiceFlags nServices)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    const std::vector<bool>& GetAsmap() const;\n+\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n+\n+private:\n+    //! A mutex to protect the inner data structures.\n+    mutable Mutex cs;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs){0};\n+\n+    //! table with information about all nIds\n+    std::unordered_map<int, AddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    //! This is mutable because it is unobservable outside the class, so any\n+    //! changes to it (even in const methods) are also unobservable.\n+    mutable std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs){0};\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs){0};\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n+    int64_t nLastGood GUARDED_BY(cs){1};\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n+    const int32_t m_consistency_check_ratio;\n+\n+    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n+    // Should be always empty if no file was provided.\n+    // This mapping is then used for bucketing nodes in Addrman.\n+    //\n+    // If asmap is provided, nodes will be bucketed by\n+    // AS they belong to, in order to make impossible for a node\n+    // to connect to several nodes hosted in a single AS.\n+    // This is done in response to Erebus attack, but also to generally\n+    // diversify the connections every node creates,\n+    // especially useful when a large fraction of nodes\n+    // operate under a couple of cloud providers.\n+    //\n+    // If a new asmap was provided, the existing records\n+    // would be re-bucketed accordingly.\n+    const std::vector<bool> m_asmap;\n+\n+    //! Find an entry.\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(AddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void Good_(const CService& addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    bool Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void Attempt_(const CService& addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void SetServices_(const CService& addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    std::pair<CAddress, int64_t> SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n+    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Perform consistency check, regardless of m_consistency_check_ratio.\n+    //! @returns an error code or zero.\n+    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+};\n+\n+#endif // BITCOIN_ADDRMAN_IMPL_H"
      },
      {
        "sha": "d6834a239bd911c4dfcc08fa09e4c7084cc987bd",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -53,14 +53,14 @@ static void CreateAddresses()\n     }\n }\n \n-static void AddAddressesToAddrMan(CAddrMan& addrman)\n+static void AddAddressesToAddrMan(AddrMan& addrman)\n {\n     for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n         addrman.Add(g_addresses[source_i], g_sources[source_i]);\n     }\n }\n \n-static void FillAddrMan(CAddrMan& addrman)\n+static void FillAddrMan(AddrMan& addrman)\n {\n     CreateAddresses();\n \n@@ -74,26 +74,26 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        CAddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n+        AddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n     bench.run([&] {\n         const auto& address = addrman.Select();\n-        assert(address.GetPort() > 0);\n+        assert(address.first.GetPort() > 0);\n     });\n }\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -105,7 +105,7 @@ static void AddrManGetAddr(benchmark::Bench& bench)\n \n static void AddrManAddThenGood(benchmark::Bench& bench)\n {\n-    auto markSomeAsGood = [](CAddrMan& addrman) {\n+    auto markSomeAsGood = [](AddrMan& addrman) {\n         for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n             for (size_t addr_i = 0; addr_i < NUM_ADDRESSES_PER_SOURCE; ++addr_i) {\n                 addrman.Good(g_addresses[source_i][addr_i]);\n@@ -117,12 +117,12 @@ static void AddrManAddThenGood(benchmark::Bench& bench)\n \n     bench.run([&] {\n         // To make the benchmark independent of the number of evaluations, we always prepare a new addrman.\n-        // This is necessary because CAddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n+        // This is necessary because AddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n         // to the same method and we want to do the same amount of work in every loop iteration.\n         //\n         // This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in\n-        // CAddrMan::Good() will still be noticeable.\n-        CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+        // AddrMan::Good() will still be noticeable.\n+        AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n         AddAddressesToAddrMan(addrman);\n \n         markSomeAsGood(addrman);"
      },
      {
        "sha": "7271ff22b2af52f25f158ab77a66af2d62c370d9",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -2010,17 +2010,18 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             if (nTries > 100)\n                 break;\n \n-            CAddrInfo addr;\n+            CAddress addr;\n+            int64_t addr_last_try{0};\n \n             if (fFeeler) {\n                 // First, try to get a tried table collision address. This returns\n                 // an empty (invalid) address if there are no collisions to try.\n-                addr = addrman.SelectTriedCollision();\n+                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();\n \n                 if (!addr.IsValid()) {\n                     // No tried table collisions. Select a new table address\n                     // for our feeler.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 } else if (AlreadyConnectedToAddress(addr)) {\n                     // If test-before-evict logic would have us connect to a\n                     // peer that we're already connected to, just mark that\n@@ -2029,11 +2030,11 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     // a currently-connected peer.\n                     addrman.Good(addr);\n                     // Select a new table address for our feeler instead.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 }\n             } else {\n                 // Not a feeler\n-                addr = addrman.Select();\n+                std::tie(addr, addr_last_try) = addrman.Select();\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n@@ -2050,7 +2051,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 continue;\n \n             // only consider very recently tried nodes after 30 failed attempts\n-            if (nANow - addr.nLastTry < 600 && nTries < 30)\n+            if (nANow - addr_last_try < 600 && nTries < 30)\n                 continue;\n \n             // for non-feelers, require all the services we'll want,\n@@ -2443,7 +2444,7 @@ void CConnman::SetNetworkActive(bool active)\n     }\n }\n \n-CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, CAddrMan& addrman_in, bool network_active)\n+CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in, bool network_active)\n     : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)\n {\n     SetTryNewOutboundPeer(false);"
      },
      {
        "sha": "e2071414b434f3eb9db5aa8a1df02fd100362246",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -797,7 +797,7 @@ class CConnman\n         m_onion_binds = connOptions.onion_binds;\n     }\n \n-    CConnman(uint64_t seed0, uint64_t seed1, CAddrMan& addrman, bool network_active = true);\n+    CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, bool network_active = true);\n     ~CConnman();\n     bool Start(CScheduler& scheduler, const Options& options);\n \n@@ -1049,7 +1049,7 @@ class CConnman\n     std::vector<ListenSocket> vhListenSocket;\n     std::atomic<bool> fNetworkActive{true};\n     bool fAddressesInitialized{false};\n-    CAddrMan& addrman;\n+    AddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);"
      },
      {
        "sha": "66b99aa2bb156ea4872f2398b456c89f90a4ad0b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -292,7 +292,7 @@ using PeerRef = std::shared_ptr<Peer>;\n class PeerManagerImpl final : public PeerManager\n {\n public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                     BanMan* banman, ChainstateManager& chainman,\n                     CTxMemPool& pool, bool ignore_incoming_txs);\n \n@@ -410,7 +410,7 @@ class PeerManagerImpl final : public PeerManager\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n-    CAddrMan& m_addrman;\n+    AddrMan& m_addrman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n@@ -1426,14 +1426,14 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n            (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n-std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                                BanMan* banman, ChainstateManager& chainman,\n                                                CTxMemPool& pool, bool ignore_incoming_txs)\n {\n     return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, chainman, pool, ignore_incoming_txs);\n }\n \n-PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                  BanMan* banman, ChainstateManager& chainman,\n                                  CTxMemPool& pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n@@ -2664,7 +2664,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // table is also potentially detrimental because new-table entries\n             // are subject to eviction in the event of addrman collisions.  We\n             // mitigate the information-leak by never calling\n-            // CAddrMan::Connected() on block-relay-only peers; see\n+            // AddrMan::Connected() on block-relay-only peers; see\n             // FinalizeNode().\n             //\n             // This moves an address from New to Tried table in Addrman,"
      },
      {
        "sha": "27bc40687a0597a0ff6b454af2524ea1a0a73079",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -9,7 +9,7 @@\n #include <net.h>\n #include <validationinterface.h>\n \n-class CAddrMan;\n+class AddrMan;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n@@ -37,7 +37,7 @@ struct CNodeStateStats {\n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:\n-    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                              BanMan* banman, ChainstateManager& chainman,\n                                              CTxMemPool& pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }"
      },
      {
        "sha": "f9fff5a6d5e6a68f1db6bf8663fbc199d2668305",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -165,7 +165,7 @@ void CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)\n }\n \n /**\n- * Create an \"internal\" address that represents a name or FQDN. CAddrMan uses\n+ * Create an \"internal\" address that represents a name or FQDN. AddrMan uses\n  * these fake addresses to keep track of which DNS seeds were used.\n  * @returns Whether or not the operation was successful.\n  * @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX, CNetAddr::IsInternal(), CNetAddr::IsRFC4193()"
      },
      {
        "sha": "66c8c48f08a07dcffcd45cc57b401695b7f97905",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -62,7 +62,7 @@ enum Network {\n     NET_CJDNS,\n \n     /// A set of addresses that represent the hash of a string or FQDN. We use\n-    /// them in CAddrMan to keep track of which DNS seeds were used.\n+    /// them in AddrMan to keep track of which DNS seeds were used.\n     NET_INTERNAL,\n \n     /// Dummy value to indicate the number of NET_* constants."
      },
      {
        "sha": "26873345b46724752dff4f35c47522486c046805",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -12,7 +12,7 @@\n \n class ArgsManager;\n class BanMan;\n-class CAddrMan;\n+class AddrMan;\n class CBlockPolicyEstimator;\n class CConnman;\n class CScheduler;\n@@ -39,7 +39,7 @@ class WalletClient;\n struct NodeContext {\n     //! Init interface for initializing current process and connecting to other processes.\n     interfaces::Init* init{nullptr};\n-    std::unique_ptr<CAddrMan> addrman;\n+    std::unique_ptr<AddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;"
      },
      {
        "sha": "bd6f47021956963ea1e88f3279c2fd1d29c9d833",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 105,
        "changes": 211,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <clientversion.h>\n #include <hash.h>\n@@ -21,26 +22,26 @@\n \n using namespace std::literals;\n \n-class CAddrManSerializationMock : public CAddrMan\n+class AddrManSerializationMock : public AddrMan\n {\n public:\n     virtual void Serialize(CDataStream& s) const = 0;\n \n-    CAddrManSerializationMock()\n-        : CAddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n+    AddrManSerializationMock()\n+        : AddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n     {}\n };\n \n-class CAddrManUncorrupted : public CAddrManSerializationMock\n+class AddrManUncorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n     {\n-        CAddrMan::Serialize(s);\n+        AddrMan::Serialize(s);\n     }\n };\n \n-class CAddrManCorrupted : public CAddrManSerializationMock\n+class AddrManCorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n@@ -61,12 +62,12 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n         CAddress addr = CAddress(serv, NODE_NONE);\n         CNetAddr resolved;\n         BOOST_CHECK(LookupHost(\"252.2.2.2\", resolved, false));\n-        CAddrInfo info = CAddrInfo(addr, resolved);\n+        AddrInfo info = AddrInfo(addr, resolved);\n         s << info;\n     }\n };\n \n-static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n+static CDataStream AddrmanToStream(const AddrManSerializationMock& _addrman)\n {\n     CDataStream ssPeersIn(SER_DISK, CLIENT_VERSION);\n     ssPeersIn << Params().MessageStart();\n@@ -76,44 +77,44 @@ static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n     return CDataStream(vchData, SER_DISK, CLIENT_VERSION);\n }\n \n-class CAddrManTest : public CAddrMan\n+class AddrManTest : public AddrMan\n {\n private:\n     bool deterministic;\n public:\n-    explicit CAddrManTest(bool makeDeterministic = true,\n-                          std::vector<bool> asmap = std::vector<bool>())\n-        : CAddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n+    explicit AddrManTest(bool makeDeterministic = true,\n+                         std::vector<bool> asmap = std::vector<bool>())\n+        : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;\n     }\n \n-    CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Find(addr, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Find(addr, pnId);\n     }\n \n-    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Create(addr, addrSource, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Create(addr, addrSource, pnId);\n     }\n \n     void Delete(int nId)\n     {\n-        LOCK(cs);\n-        CAddrMan::Delete(nId);\n+        LOCK(m_impl->cs);\n+        m_impl->Delete(nId);\n     }\n \n     // Used to test deserialization\n     std::pair<int, int> GetBucketAndEntry(const CAddress& addr)\n     {\n-        LOCK(cs);\n-        int nId = mapAddr[addr];\n+        LOCK(m_impl->cs);\n+        int nId = m_impl->mapAddr[addr];\n         for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n             for (int entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n-                if (nId == vvNew[bucket][entry]) {\n+                if (nId == m_impl->vvNew[bucket][entry]) {\n                     return std::pair<int, int>(bucket, entry);\n                 }\n             }\n@@ -165,20 +166,20 @@ BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n {\n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test: Does Addrman respond correctly when empty.\n     BOOST_CHECK_EQUAL(addrman->size(), 0U);\n-    CAddrInfo addr_null = addrman->Select();\n+    auto addr_null = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n     // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman->size(), 1U);\n-    CAddrInfo addr_ret1 = addrman->Select();\n+    auto addr_ret1 = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Does IP address deduplication work correctly.\n@@ -199,7 +200,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     BOOST_CHECK(addrman->size() >= 1);\n \n     // Test: reset addrman and test AddrMan::Add multiple addresses works as expected\n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     std::vector<CAddress> vAddr;\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n@@ -209,7 +210,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -223,22 +224,22 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     BOOST_CHECK(!addrman.Add({CAddress(addr1_port, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select();\n+    auto addr_ret2 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     bool newOnly = true;\n-    CAddrInfo addr_ret3 = addrman.Select(newOnly);\n+    auto addr_ret3 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n \n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -248,16 +249,16 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     bool newOnly = true;\n-    CAddrInfo addr_ret1 = addrman.Select(newOnly);\n+    auto addr_ret1 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select(newOnly);\n+    auto addr_ret2 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n-    CAddrInfo addr_ret3 = addrman.Select();\n+    auto addr_ret3 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n@@ -290,14 +291,14 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Test: Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n-        ports.insert(addrman.Select().GetPort());\n+        ports.insert(addrman.Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -326,7 +327,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -356,7 +357,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -372,44 +373,44 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     BOOST_CHECK(addrman.Add({addr3}, source1));\n \n     // Test: ensure Find returns an IP matching what we searched on.\n-    CAddrInfo* info1 = addrman.Find(addr1);\n+    AddrInfo* info1 = addrman.Find(addr1);\n     BOOST_REQUIRE(info1);\n     BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n-    CAddrInfo* info2 = addrman.Find(addr2);\n+    AddrInfo* info2 = addrman.Find(addr2);\n     BOOST_REQUIRE(info2);\n     BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n     // Test: Find returns another IP matching what we searched on.\n-    CAddrInfo* info3 = addrman.Find(addr3);\n+    AddrInfo* info3 = addrman.Find(addr3);\n     BOOST_REQUIRE(info3);\n     BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n-    CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n+    AddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n     // Test: The result should be the same as the input addr.\n     BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n \n BOOST_AUTO_TEST_CASE(addrman_delete)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -423,13 +424,13 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     addrman.Delete(nId);\n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == nullptr);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n@@ -489,15 +490,15 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -512,14 +513,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetTriedBucket(nKey1, asmap);\n@@ -531,7 +532,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -544,14 +545,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -567,13 +568,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -585,7 +586,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -598,7 +599,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -622,15 +623,15 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n // 101.8.0.0/16 AS8\n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -645,14 +646,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"101.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -664,7 +665,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -677,14 +678,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -700,13 +701,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -718,7 +719,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -731,7 +732,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -743,7 +744,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -759,9 +760,9 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n {\n     std::vector<bool> asmap1 = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n \n-    auto addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_asmap1_dup = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_noasmap = std::make_unique<CAddrManTest>();\n+    auto addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_asmap1_dup = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_noasmap = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     CAddress addr = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n@@ -791,8 +792,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1.second != bucketAndEntry_noasmap.second);\n \n     // deserializing non-asmaped peers.dat to asmaped addrman\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     addrman_noasmap->Add({addr}, default_source);\n     stream << *addrman_noasmap;\n     stream >> *addrman_asmap1;\n@@ -803,8 +804,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1_deser.second == bucketAndEntry_asmap1_dup.second);\n \n     // used to map to different buckets, now maps to the same bucket.\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.2.1.1\"), NODE_NONE);\n     addrman_noasmap->Add({addr, addr2}, default_source);\n@@ -824,7 +825,7 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n {\n     // Confirm that invalid addresses are ignored in unserialization.\n \n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     const CAddress new1{ResolveService(\"5.5.5.5\"), NODE_NONE};\n@@ -856,19 +857,19 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n     BOOST_REQUIRE(pos + sizeof(tried2_raw_replacement) <= stream.size());\n     memcpy(stream.data() + pos, tried2_raw_replacement, sizeof(tried2_raw_replacement));\n \n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     stream >> *addrman;\n     BOOST_CHECK_EQUAL(addrman->size(), 2);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add twenty two addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -879,7 +880,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n         // No collisions yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Ensure Good handles duplicates well.\n@@ -888,14 +889,14 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == 22);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n }\n \n BOOST_AUTO_TEST_CASE(addrman_noevict)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Add 35 addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -906,7 +907,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -915,11 +916,11 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr36);\n \n     BOOST_CHECK(addrman.size() == 36);\n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.19:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.19:0\");\n \n     // 36 should be discarded and 19 not evicted.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Lets create two collisions.\n     for (unsigned int i = 37; i < 59; i++) {\n@@ -928,7 +929,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Cause a collision.\n@@ -937,26 +938,26 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr59);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.10:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.10:0\");\n \n     // Cause a second collision.\n     BOOST_CHECK(!addrman.Add({CAddress(addr36, NODE_NONE)}, source));\n     addrman.Good(addr36);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() != \"[::]:0\");\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add 35 addresses\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -967,7 +968,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -976,36 +977,36 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     addrman.Good(addr);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 36);\n-    CAddrInfo info = addrman.SelectTriedCollision();\n+    auto info = addrman.SelectTriedCollision().first;\n     BOOST_CHECK_EQUAL(info.ToString(), \"250.1.1.19:0\");\n \n     // Ensure test of address fails, so that it is evicted.\n     addrman.SimConnFail(info);\n \n     // Should swap 36 for 19.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If 36 was swapped for 19, then this should cause no collisions.\n     BOOST_CHECK(!addrman.Add({CAddress(addr, NODE_NONE)}, source));\n     addrman.Good(addr);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If we insert 19 it should collide with 36\n     CService addr19 = ResolveService(\"250.1.1.19\");\n     BOOST_CHECK(!addrman.Add({CAddress(addr19, NODE_NONE)}, source));\n     addrman.Good(addr19);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.36:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.36:0\");\n \n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(load_addrman)\n {\n-    CAddrManUncorrupted addrmanUncorrupted;\n+    AddrManUncorrupted addrmanUncorrupted;\n \n     CService addr1, addr2, addr3;\n     BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n@@ -1024,7 +1025,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -1041,7 +1042,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n@@ -1050,12 +1051,12 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n \n BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n {\n-    CAddrManCorrupted addrmanCorrupted;\n+    AddrManCorrupted addrmanCorrupted;\n \n     // Test that the de-serialization of corrupted addrman throws an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1071,7 +1072,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }"
      },
      {
        "sha": "cfeab9dcdc2f0e460188c47865ce9a15ca6717d0",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 38,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <merkleblock.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n@@ -27,29 +28,29 @@ FUZZ_TARGET_INIT(data_stream_addr_man, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    CAddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     try {\n         ReadFromStream(addr_man, data_stream);\n     } catch (const std::exception&) {\n     }\n }\n \n-class CAddrManDeterministic : public CAddrMan\n+class AddrManDeterministic : public AddrMan\n {\n public:\n     FuzzedDataProvider& m_fuzzed_data_provider;\n \n-    explicit CAddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n-        : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n+    explicit AddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n+        : AddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n-        WITH_LOCK(cs, insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n+        WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n     }\n \n     /**\n      * Generate a random address. Always returns a valid address.\n      */\n-    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(cs)\n+    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs)\n     {\n         CNetAddr addr;\n         if (m_fuzzed_data_provider.remaining_bytes() > 1 && m_fuzzed_data_provider.ConsumeBool()) {\n@@ -61,15 +62,15 @@ class CAddrManDeterministic : public CAddrMan\n                                                                    {4, ADDR_TORV3_SIZE},\n                                                                    {5, ADDR_I2P_SIZE},\n                                                                    {6, ADDR_CJDNS_SIZE}};\n-            uint8_t net = insecure_rand.randrange(5) + 1; // [1..5]\n+            uint8_t net = m_impl->insecure_rand.randrange(5) + 1; // [1..5]\n             if (net == 3) {\n                 net = 6;\n             }\n \n             CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n \n             s << net;\n-            s << insecure_rand.randbytes(net_len_map.at(net));\n+            s << m_impl->insecure_rand.randbytes(net_len_map.at(net));\n \n             s >> addr;\n         }\n@@ -89,7 +90,7 @@ class CAddrManDeterministic : public CAddrMan\n      */\n     void Fill()\n     {\n-        LOCK(cs);\n+        LOCK(m_impl->cs);\n \n         // Add some of the addresses directly to the \"tried\" table.\n \n@@ -102,20 +103,20 @@ class CAddrManDeterministic : public CAddrMan\n         // the latter is exhausted it just returns 0.\n         for (size_t i = 0; i < num_sources; ++i) {\n             const auto source = RandAddr();\n-            const size_t num_addresses = insecure_rand.randrange(500) + 1; // [1..500]\n+            const size_t num_addresses = m_impl->insecure_rand.randrange(500) + 1; // [1..500]\n \n             for (size_t j = 0; j < num_addresses; ++j) {\n                 const auto addr = CAddress{CService{RandAddr(), 8333}, NODE_NETWORK};\n-                const auto time_penalty = insecure_rand.randrange(100000001);\n-                Add_(addr, source, time_penalty);\n+                const auto time_penalty = m_impl->insecure_rand.randrange(100000001);\n+                m_impl->Add_(addr, source, time_penalty);\n \n-                if (n > 0 && mapInfo.size() % n == 0) {\n-                    Good_(addr, false, GetTime());\n+                if (n > 0 && m_impl->mapInfo.size() % n == 0) {\n+                    m_impl->Good_(addr, false, GetTime());\n                 }\n \n                 // Add 10% of the addresses from more than one source.\n-                if (insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n-                    Add_(addr, prev_source, time_penalty);\n+                if (m_impl->insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n+                    m_impl->Add_({addr}, prev_source, time_penalty);\n                 }\n             }\n             prev_source = source;\n@@ -129,69 +130,69 @@ class CAddrManDeterministic : public CAddrMan\n      * - vvNew entries refer to the same addresses\n      * - vvTried entries refer to the same addresses\n      */\n-    bool operator==(const CAddrManDeterministic& other)\n+    bool operator==(const AddrManDeterministic& other)\n     {\n-        LOCK2(cs, other.cs);\n+        LOCK2(m_impl->cs, other.m_impl->cs);\n \n-        if (mapInfo.size() != other.mapInfo.size() || nNew != other.nNew ||\n-            nTried != other.nTried) {\n+        if (m_impl->mapInfo.size() != other.m_impl->mapInfo.size() || m_impl->nNew != other.m_impl->nNew ||\n+            m_impl->nTried != other.m_impl->nTried) {\n             return false;\n         }\n \n         // Check that all values in `mapInfo` are equal to all values in `other.mapInfo`.\n         // Keys may be different.\n \n-        using CAddrInfoHasher = std::function<size_t(const CAddrInfo&)>;\n-        using CAddrInfoEq = std::function<bool(const CAddrInfo&, const CAddrInfo&)>;\n+        using AddrInfoHasher = std::function<size_t(const AddrInfo&)>;\n+        using AddrInfoEq = std::function<bool(const AddrInfo&, const AddrInfo&)>;\n \n         CNetAddrHash netaddr_hasher;\n \n-        CAddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const CAddrInfo& a) {\n+        AddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const AddrInfo& a) {\n             return netaddr_hasher(static_cast<CNetAddr>(a)) ^ netaddr_hasher(a.source) ^\n                    a.nLastSuccess ^ a.nAttempts ^ a.nRefCount ^ a.fInTried;\n         };\n \n-        CAddrInfoEq addrinfo_eq = [](const CAddrInfo& lhs, const CAddrInfo& rhs) {\n+        AddrInfoEq addrinfo_eq = [](const AddrInfo& lhs, const AddrInfo& rhs) {\n             return static_cast<CNetAddr>(lhs) == static_cast<CNetAddr>(rhs) &&\n                    lhs.source == rhs.source && lhs.nLastSuccess == rhs.nLastSuccess &&\n                    lhs.nAttempts == rhs.nAttempts && lhs.nRefCount == rhs.nRefCount &&\n                    lhs.fInTried == rhs.fInTried;\n         };\n \n-        using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n+        using Addresses = std::unordered_set<AddrInfo, AddrInfoHasher, AddrInfoEq>;\n \n-        const size_t num_addresses{mapInfo.size()};\n+        const size_t num_addresses{m_impl->mapInfo.size()};\n \n         Addresses addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : mapInfo) {\n+        for (const auto& [id, addr] : m_impl->mapInfo) {\n             addresses.insert(addr);\n         }\n \n         Addresses other_addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : other.mapInfo) {\n+        for (const auto& [id, addr] : other.m_impl->mapInfo) {\n             other_addresses.insert(addr);\n         }\n \n         if (addresses != other_addresses) {\n             return false;\n         }\n \n-        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(cs, other.cs) {\n+        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs, other.m_impl->cs) {\n             if (id == -1 && other_id == -1) {\n                 return true;\n             }\n             if ((id == -1 && other_id != -1) || (id != -1 && other_id == -1)) {\n                 return false;\n             }\n-            return mapInfo.at(id) == other.mapInfo.at(other_id);\n+            return m_impl->mapInfo.at(id) == other.m_impl->mapInfo.at(other_id);\n         };\n \n         // Check that `vvNew` contains the same addresses as `other.vvNew`. Notice - `vvNew[i][j]`\n         // contains just an id and the address is to be found in `mapInfo.at(id)`. The ids\n         // themselves may differ between `vvNew` and `other.vvNew`.\n         for (size_t i = 0; i < ADDRMAN_NEW_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvNew[i][j], other.vvNew[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvNew[i][j], other.m_impl->vvNew[i][j])) {\n                     return false;\n                 }\n             }\n@@ -200,7 +201,7 @@ class CAddrManDeterministic : public CAddrMan\n         // Same for `vvTried`.\n         for (size_t i = 0; i < ADDRMAN_TRIED_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvTried[i][j], other.vvTried[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvTried[i][j], other.m_impl->vvTried[i][j])) {\n                     return false;\n                 }\n             }\n@@ -222,7 +223,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    auto addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+    auto addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n         CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n@@ -231,10 +232,10 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         try {\n             ds >> *addr_man_ptr;\n         } catch (const std::ios_base::failure&) {\n-            addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+            addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n         }\n     }\n-    CAddrManDeterministic& addr_man = *addr_man_ptr;\n+    AddrManDeterministic& addr_man = *addr_man_ptr;\n     while (fuzzed_data_provider.ConsumeBool()) {\n         CallOneOf(\n             fuzzed_data_provider,\n@@ -283,7 +284,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n                 }\n             });\n     }\n-    const CAddrMan& const_addr_man{addr_man};\n+    const AddrMan& const_addr_man{addr_man};\n     (void)const_addr_man.GetAddr(\n         /* max_addresses */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n         /* max_pct */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n@@ -301,8 +302,8 @@ FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n \n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    CAddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n-    CAddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n \n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n "
      },
      {
        "sha": "d381345a0d4d3d4376c70d904f496d497e3d007c",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -25,7 +25,7 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);"
      },
      {
        "sha": "a9325fa738b223f8734f77e396ef4d48027546a6",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <blockencodings.h>\n #include <blockfilter.h>\n #include <chain.h>\n@@ -104,7 +105,7 @@ FUZZ_TARGET_DESERIALIZE(block_filter_deserialize, {\n     DeserializeFromFuzzingInput(buffer, block_filter);\n })\n FUZZ_TARGET_DESERIALIZE(addr_info_deserialize, {\n-    CAddrInfo addr_info;\n+    AddrInfo addr_info;\n     DeserializeFromFuzzingInput(buffer, addr_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_file_info_deserialize, {\n@@ -188,7 +189,7 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    CAddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {"
      },
      {
        "sha": "ebefa9974e773e41c476b02d68d6ba828272e9a4",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -192,7 +192,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<CAddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.addrman = std::make_unique<AddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,"
      },
      {
        "sha": "6d62864a4a8c71b78dfb9d476d75b9c73ece7331",
        "filename": "src/util/syscall_sandbox.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 8,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/src/util/syscall_sandbox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/src/util/syscall_sandbox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/syscall_sandbox.cpp?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -40,6 +40,24 @@ bool g_syscall_sandbox_log_violation_before_terminating{false};\n #error Syscall sandbox is an experimental feature currently available only under Linux x86-64.\n #endif // defined(__x86_64__)\n \n+#ifndef SECCOMP_RET_KILL_PROCESS\n+#define SECCOMP_RET_KILL_PROCESS 0x80000000U\n+#endif\n+\n+// Define system call numbers for x86_64 that are referenced in the system call profile\n+// but not provided by the kernel headers used in the GUIX build.\n+#ifndef __NR_statx\n+#define __NR_statx 332\n+#endif\n+\n+#ifndef __NR_getrandom\n+#define __NR_getrandom 318\n+#endif\n+\n+#ifndef __NR_membarrier\n+#define __NR_membarrier 324\n+#endif\n+\n // This list of syscalls in LINUX_SYSCALLS is only used to map syscall numbers to syscall names in\n // order to be able to print user friendly error messages which include the syscall name in addition\n // to the syscall number.\n@@ -158,9 +176,7 @@ const std::map<uint32_t, std::string> LINUX_SYSCALLS{\n     {__NR_getpmsg, \"getpmsg\"},\n     {__NR_getppid, \"getppid\"},\n     {__NR_getpriority, \"getpriority\"},\n-#if defined(__NR_getrandom)\n     {__NR_getrandom, \"getrandom\"},\n-#endif // defined(__NR_getrandom)\n     {__NR_getresgid, \"getresgid\"},\n     {__NR_getresuid, \"getresuid\"},\n     {__NR_getrlimit, \"getrlimit\"},\n@@ -208,9 +224,7 @@ const std::map<uint32_t, std::string> LINUX_SYSCALLS{\n     {__NR_lstat, \"lstat\"},\n     {__NR_madvise, \"madvise\"},\n     {__NR_mbind, \"mbind\"},\n-#if defined(__NR_membarrier)\n     {__NR_membarrier, \"membarrier\"},\n-#endif // defined(__NR_membarrier)\n     {__NR_memfd_create, \"memfd_create\"},\n     {__NR_migrate_pages, \"migrate_pages\"},\n     {__NR_mincore, \"mincore\"},\n@@ -511,9 +525,7 @@ class SeccompPolicyBuilder\n     {\n         allowed_syscalls.insert(__NR_brk);     // change data segment size\n         allowed_syscalls.insert(__NR_madvise); // give advice about use of memory\n-#if defined(__NR_membarrier)\n         allowed_syscalls.insert(__NR_membarrier); // issue memory barriers on a set of threads\n-#endif // defined(__NR_membarrier)\n         allowed_syscalls.insert(__NR_mlock);    // lock memory\n         allowed_syscalls.insert(__NR_mmap);     // map files or devices into memory\n         allowed_syscalls.insert(__NR_mprotect); // set protection on a region of memory\n@@ -593,9 +605,7 @@ class SeccompPolicyBuilder\n \n     void AllowGetRandom()\n     {\n-#if defined(__NR_getrandom)\n         allowed_syscalls.insert(__NR_getrandom); // obtain a series of random bytes\n-#endif // defined(__NR_getrandom)\n     }\n \n     void AllowGetSimpleId()"
      },
      {
        "sha": "93d50c13692176f72ecdc17d1ef1dc3dffc2a354",
        "filename": "test/functional/feature_addrman.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b2cfef54503d4881b8257cd680e146a8480b731/test/functional/feature_addrman.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b2cfef54503d4881b8257cd680e146a8480b731/test/functional/feature_addrman.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_addrman.py?ref=2b2cfef54503d4881b8257cd680e146a8480b731",
        "patch": "@@ -109,15 +109,15 @@ def run_test(self):\n         self.stop_node(0)\n         write_addrman(peers_dat, len_tried=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n \n         self.log.info(\"Check that corrupt addrman cannot be read (len_new)\")\n         self.stop_node(0)\n         write_addrman(peers_dat, len_new=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n "
      }
    ]
  },
  {
    "sha": "a8e6545b94e1c9dfd71aecf241948a34890a33d2",
    "node_id": "C_kwDOABII59oAKGE4ZTY1NDViOTRlMWM5ZGZkNzFhZWNmMjQxOTQ4YTM0ODkwYTMzZDI",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:23:13Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:23:13Z"
      },
      "message": "Merge branch 'auto_gen_MSVC_issue' of https://github.com/CallMeMisterOwl/bitcoin into auto_gen_MSVC_issue",
      "tree": {
        "sha": "6265810020e8d02dc860a66ef4dffb113c1f9844",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6265810020e8d02dc860a66ef4dffb113c1f9844"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a8e6545b94e1c9dfd71aecf241948a34890a33d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8e6545b94e1c9dfd71aecf241948a34890a33d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a8e6545b94e1c9dfd71aecf241948a34890a33d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8e6545b94e1c9dfd71aecf241948a34890a33d2/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75263a9e9ab19be73de9739c4251216a4d082f1e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75263a9e9ab19be73de9739c4251216a4d082f1e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75263a9e9ab19be73de9739c4251216a4d082f1e"
      },
      {
        "sha": "2b2cfef54503d4881b8257cd680e146a8480b731",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b2cfef54503d4881b8257cd680e146a8480b731",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b2cfef54503d4881b8257cd680e146a8480b731"
      }
    ],
    "stats": {
      "total": 1681,
      "additions": 966,
      "deletions": 715
    },
    "files": [
      {
        "sha": "3d0aa5d132f095e2046f3ed0a1e380c5833d2dd7",
        "filename": "contrib/signet/getcoins.py",
        "status": "modified",
        "additions": 91,
        "deletions": 3,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/contrib/signet/getcoins.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/contrib/signet/getcoins.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/getcoins.py?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -4,18 +4,77 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n import argparse\n+import io\n+import requests\n import subprocess\n import sys\n-import requests\n \n DEFAULT_GLOBAL_FAUCET = 'https://signetfaucet.com/claim'\n+DEFAULT_GLOBAL_CAPTCHA = 'https://signetfaucet.com/captcha'\n GLOBAL_FIRST_BLOCK_HASH = '00000086d6b2636cb2a392d45edc4ec544a10024d30141c9adf4bfd9de533b53'\n \n+# braille unicode block\n+BASE = 0x2800\n+BIT_PER_PIXEL = [\n+    [0x01, 0x08],\n+    [0x02, 0x10],\n+    [0x04, 0x20],\n+    [0x40, 0x80],\n+]\n+BW = 2\n+BH = 4\n+\n+# imagemagick or compatible fork (used for converting SVG)\n+CONVERT = 'convert'\n+\n+class PPMImage:\n+    '''\n+    Load a PPM image (Pillow-ish API).\n+    '''\n+    def __init__(self, f):\n+        if f.readline() != b'P6\\n':\n+            raise ValueError('Invalid ppm format: header')\n+        line = f.readline()\n+        (width, height) = (int(x) for x in line.rstrip().split(b' '))\n+        if f.readline() != b'255\\n':\n+            raise ValueError('Invalid ppm format: color depth')\n+        data = f.read(width * height * 3)\n+        stride = width * 3\n+        self.size = (width, height)\n+        self._grid = [[tuple(data[stride * y + 3 * x:stride * y + 3 * (x + 1)]) for x in range(width)] for y in range(height)]\n+\n+    def getpixel(self, pos):\n+        return self._grid[pos[1]][pos[0]]\n+\n+def print_image(img, threshold=128):\n+    '''Print black-and-white image to terminal in braille unicode characters.'''\n+    x_blocks = (img.size[0] + BW - 1) // BW\n+    y_blocks = (img.size[1] + BH - 1) // BH\n+\n+    for yb in range(y_blocks):\n+        line = []\n+        for xb in range(x_blocks):\n+            ch = BASE\n+            for y in range(BH):\n+                for x in range(BW):\n+                    try:\n+                        val = img.getpixel((xb * BW + x, yb * BH + y))\n+                    except IndexError:\n+                        pass\n+                    else:\n+                        if val[0] < threshold:\n+                            ch |= BIT_PER_PIXEL[y][x]\n+            line.append(chr(ch))\n+        print(''.join(line))\n+\n parser = argparse.ArgumentParser(description='Script to get coins from a faucet.', epilog='You may need to start with double-dash (--) when providing bitcoin-cli arguments.')\n parser.add_argument('-c', '--cmd', dest='cmd', default='bitcoin-cli', help='bitcoin-cli command to use')\n parser.add_argument('-f', '--faucet', dest='faucet', default=DEFAULT_GLOBAL_FAUCET, help='URL of the faucet')\n+parser.add_argument('-g', '--captcha', dest='captcha', default=DEFAULT_GLOBAL_CAPTCHA, help='URL of the faucet captcha, or empty if no captcha is needed')\n parser.add_argument('-a', '--addr', dest='addr', default='', help='Bitcoin address to which the faucet should send')\n parser.add_argument('-p', '--password', dest='password', default='', help='Faucet password, if any')\n+parser.add_argument('-n', '--amount', dest='amount', default='0.001', help='Amount to request (0.001-0.1, default is 0.001)')\n+parser.add_argument('-i', '--imagemagick', dest='imagemagick', default=CONVERT, help='Path to imagemagick convert utility')\n parser.add_argument('bitcoin_cli_args', nargs='*', help='Arguments to pass on to bitcoin-cli (default: -signet)')\n \n args = parser.parse_args()\n@@ -43,14 +102,43 @@ def bitcoin_cli(rpc_command_and_params):\n     if curr_signet_hash != GLOBAL_FIRST_BLOCK_HASH:\n         print('The global faucet cannot be used with a custom Signet network. Please use the global signet or setup your custom faucet to use this functionality.\\n')\n         exit(1)\n+else:\n+    # For custom faucets, don't request captcha by default.\n+    if args.captcha == DEFAULT_GLOBAL_CAPTCHA:\n+        args.captcha = ''\n \n if args.addr == '':\n     # get address for receiving coins\n     args.addr = bitcoin_cli(['getnewaddress', 'faucet', 'bech32'])\n \n-data = {'address': args.addr, 'password': args.password}\n+data = {'address': args.addr, 'password': args.password, 'amount': args.amount}\n+\n+# Store cookies\n+# for debugging: print(session.cookies.get_dict())\n+session = requests.Session()\n+\n+if args.captcha != '': # Retrieve a captcha\n+    try:\n+        res = session.get(args.captcha)\n+    except:\n+        print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n+        exit(1)\n+\n+    # Convert SVG image to PPM, and load it\n+    try:\n+        rv = subprocess.run([args.imagemagick, '-', '-depth', '8', 'ppm:-'], input=res.content, check=True, capture_output=True)\n+    except FileNotFoundError:\n+        print('The binary', args.imagemagick, 'could not be found. Please make sure ImageMagick (or a compatible fork) is installed and that the correct path is specified.')\n+        exit(1)\n+    img = PPMImage(io.BytesIO(rv.stdout))\n+\n+    # Terminal interaction\n+    print_image(img)\n+    print('Enter captcha: ', end='')\n+    data['captcha'] = input()\n+\n try:\n-    res = requests.post(args.faucet, data=data)\n+    res = session.post(args.faucet, data=data)\n except:\n     print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n     exit(1)"
      },
      {
        "sha": "12fdc9ad7588514e2920812359b5b084860bc91e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -117,6 +117,7 @@ endif\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addrman.h \\\n+  addrman_impl.h \\\n   attributes.h \\\n   banman.h \\\n   base58.h \\"
      },
      {
        "sha": "50fd09101ee568cd305b05ed1f3b7682dd828056",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -170,21 +170,21 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr)\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)\n {\n     const auto pathAddr = args.GetDataDirNet() / \"peers.dat\";\n     return SerializeFileDB(\"peers\", pathAddr, addr, CLIENT_VERSION);\n }\n \n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers)\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers)\n {\n     DeserializeDB(ssPeers, addr, false);\n }\n \n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman)\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n {\n     auto check_addrman = std::clamp<int32_t>(args.GetIntArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+    addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n \n     int64_t nStart = GetTimeMillis();\n     const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n@@ -193,7 +193,7 @@ std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const A\n         LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n     } catch (const DbNotFoundError&) {\n         // Addrman can be in an inconsistent state after failure, reset it\n-        addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n         LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", path_addr);\n         DumpPeerAddresses(args, *addrman);\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "19be4b5bb4ee284c92745c7115c9ec1042c02f83",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -14,14 +14,14 @@\n #include <vector>\n \n class ArgsManager;\n-class CAddrMan;\n+class AddrMan;\n class CAddress;\n class CDataStream;\n struct bilingual_str;\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr);\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr);\n /** Only used by tests. */\n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers);\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers);\n \n /** Access to the banlist database (banlist.json) */\n class CBanDB\n@@ -48,7 +48,7 @@ class CBanDB\n };\n \n /** Returns an error string on failure */\n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman);\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman);\n \n /**\n  * Dump the anchor IP address database (anchors.dat)"
      },
      {
        "sha": "c364a7710b458a0440b04a2fcb20a74eaec16b12",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 354,
        "deletions": 181,
        "changes": 535,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -4,25 +4,27 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <addrman.h>\n+#include <addrman_impl.h>\n \n-#include <clientversion.h>\n #include <hash.h>\n-#include <logging.h>\n #include <netaddress.h>\n+#include <protocol.h>\n+#include <random.h>\n #include <serialize.h>\n #include <streams.h>\n+#include <timedata.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n #include <util/check.h>\n \n #include <cmath>\n #include <optional>\n-#include <unordered_map>\n-#include <unordered_set>\n \n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n /** Over how many buckets entries with new addresses originating from a single group are spread */\n static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n-/** Maximum number of times an address can be added to the new table */\n+/** Maximum number of times an address can occur in the new table */\n static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n /** How old addresses can maximally be */\n static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n@@ -39,7 +41,7 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool>& asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n@@ -49,7 +51,7 @@ int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asma\n     return tried_bucket;\n }\n \n-int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool>& asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n@@ -60,13 +62,13 @@ int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std:\n     return new_bucket;\n }\n \n-int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int nBucket) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n }\n \n-bool CAddrInfo::IsTerrible(int64_t nNow) const\n+bool AddrInfo::IsTerrible(int64_t nNow) const\n {\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n         return false;\n@@ -86,7 +88,7 @@ bool CAddrInfo::IsTerrible(int64_t nNow) const\n     return false;\n }\n \n-double CAddrInfo::GetChance(int64_t nNow) const\n+double AddrInfo::GetChance(int64_t nNow) const\n {\n     double fChance = 1.0;\n     int64_t nSinceLastTry = std::max<int64_t>(nNow - nLastTry, 0);\n@@ -101,7 +103,7 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrManImpl::AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio)\n     : insecure_rand{deterministic}\n     , nKey{deterministic ? uint256{1} : insecure_rand.rand256()}\n     , m_consistency_check_ratio{consistency_check_ratio}\n@@ -119,8 +121,13 @@ CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consiste\n     }\n }\n \n+AddrManImpl::~AddrManImpl()\n+{\n+    nKey.SetNull();\n+}\n+\n template <typename Stream>\n-void CAddrMan::Serialize(Stream& s_) const\n+void AddrManImpl::Serialize(Stream& s_) const\n {\n     LOCK(cs);\n \n@@ -183,7 +190,7 @@ void CAddrMan::Serialize(Stream& s_) const\n     int nIds = 0;\n     for (const auto& entry : mapInfo) {\n         mapUnkIds[entry.first] = nIds;\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.nRefCount) {\n             assert(nIds != nNew); // this means nNew was wrong, oh ow\n             s << info;\n@@ -192,7 +199,7 @@ void CAddrMan::Serialize(Stream& s_) const\n     }\n     nIds = 0;\n     for (const auto& entry : mapInfo) {\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.fInTried) {\n             assert(nIds != nTried); // this means nTried was wrong, oh ow\n             s << info;\n@@ -223,7 +230,7 @@ void CAddrMan::Serialize(Stream& s_) const\n }\n \n template <typename Stream>\n-void CAddrMan::Unserialize(Stream& s_)\n+void AddrManImpl::Unserialize(Stream& s_)\n {\n     LOCK(cs);\n \n@@ -262,21 +269,21 @@ void CAddrMan::Unserialize(Stream& s_)\n \n     if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]\",\n                     nNew,\n                     ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]\",\n                     nTried,\n                     ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     // Deserialize entries from the new table.\n     for (int n = 0; n < nNew; n++) {\n-        CAddrInfo &info = mapInfo[n];\n+        AddrInfo& info = mapInfo[n];\n         s >> info;\n         mapAddr[info] = n;\n         info.nRandomPos = vRandom.size();\n@@ -287,7 +294,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     // Deserialize entries from the tried table.\n     int nLost = 0;\n     for (int n = 0; n < nTried; n++) {\n-        CAddrInfo info;\n+        AddrInfo info;\n         s >> info;\n         int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n         int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n@@ -344,7 +351,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     for (auto bucket_entry : bucket_entries) {\n         int bucket{bucket_entry.first};\n         const int entry_index{bucket_entry.second};\n-        CAddrInfo& info = mapInfo[entry_index];\n+        AddrInfo& info = mapInfo[entry_index];\n \n         // Don't store the entry in the new bucket if it's not a valid address for our addrman\n         if (!info.IsValid()) continue;\n@@ -394,16 +401,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     }\n }\n \n-// explicit instantiation\n-template void CAddrMan::Serialize(CHashWriter& s) const;\n-template void CAddrMan::Serialize(CAutoFile& s) const;\n-template void CAddrMan::Serialize(CDataStream& s) const;\n-template void CAddrMan::Unserialize(CAutoFile& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n-template void CAddrMan::Unserialize(CDataStream& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n-\n-CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n+AddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -418,12 +416,12 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n     return nullptr;\n }\n \n-CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n+AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     AssertLockHeld(cs);\n \n     int nId = nIdCount++;\n-    mapInfo[nId] = CAddrInfo(addr, addrSource);\n+    mapInfo[nId] = AddrInfo(addr, addrSource);\n     mapAddr[addr] = nId;\n     mapInfo[nId].nRandomPos = vRandom.size();\n     vRandom.push_back(nId);\n@@ -432,7 +430,7 @@ CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, in\n     return &mapInfo[nId];\n }\n \n-void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n+void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n {\n     AssertLockHeld(cs);\n \n@@ -456,12 +454,12 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n     vRandom[nRndPos2] = nId1;\n }\n \n-void CAddrMan::Delete(int nId)\n+void AddrManImpl::Delete(int nId)\n {\n     AssertLockHeld(cs);\n \n     assert(mapInfo.count(nId) != 0);\n-    CAddrInfo& info = mapInfo[nId];\n+    AddrInfo& info = mapInfo[nId];\n     assert(!info.fInTried);\n     assert(info.nRefCount == 0);\n \n@@ -472,14 +470,14 @@ void CAddrMan::Delete(int nId)\n     nNew--;\n }\n \n-void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n+void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n {\n     AssertLockHeld(cs);\n \n     // if there is an entry in the specified bucket, delete it.\n     if (vvNew[nUBucket][nUBucketPos] != -1) {\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n-        CAddrInfo& infoDelete = mapInfo[nIdDelete];\n+        AddrInfo& infoDelete = mapInfo[nIdDelete];\n         assert(infoDelete.nRefCount > 0);\n         infoDelete.nRefCount--;\n         vvNew[nUBucket][nUBucketPos] = -1;\n@@ -489,7 +487,7 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n     }\n }\n \n-void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n+void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -517,7 +515,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n         // find an item to evict\n         int nIdEvict = vvTried[nKBucket][nKBucketPos];\n         assert(mapInfo.count(nIdEvict) == 1);\n-        CAddrInfo& infoOld = mapInfo[nIdEvict];\n+        AddrInfo& infoOld = mapInfo[nIdEvict];\n \n         // Remove the to-be-evicted item from the tried set.\n         infoOld.fInTried = false;\n@@ -542,21 +540,21 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n+void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n     int nId;\n \n     nLastGood = nTime;\n \n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -598,7 +596,7 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n     }\n }\n \n-bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     AssertLockHeld(cs);\n \n@@ -607,7 +605,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n \n     bool fNew = false;\n     int nId;\n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // Do not set a penalty for a source's self-announcement\n     if (addr == source) {\n@@ -654,7 +652,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n         if (!fInsert) {\n-            CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n+            AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n             if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n                 // Overwrite the existing new table entry.\n                 fInsert = true;\n@@ -673,17 +671,17 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     return fNew;\n }\n \n-void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -697,15 +695,13 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n     }\n }\n \n-CAddrInfo CAddrMan::Select_(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n-    if (vRandom.empty())\n-        return CAddrInfo();\n+    if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0)\n-        return CAddrInfo();\n+    if (newOnly && nNew == 0) return {};\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n@@ -722,9 +718,10 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n             int nId = vvTried[nKBucket][nKBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n+            const AddrInfo& info{it_found->second};\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n+            }\n             fChanceFactor *= 1.2;\n         }\n     } else {\n@@ -740,118 +737,16 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n             int nId = vvNew[nUBucket][nUBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n-            fChanceFactor *= 1.2;\n-        }\n-    }\n-}\n-\n-void CAddrMan::Check() const\n-{\n-    AssertLockHeld(cs);\n-\n-    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n-    if (m_consistency_check_ratio == 0) return;\n-    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n-\n-    const int err{ForceCheckAddrman()};\n-    if (err) {\n-        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n-        assert(false);\n-    }\n-}\n-\n-int CAddrMan::ForceCheckAddrman() const\n-{\n-    AssertLockHeld(cs);\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n-\n-    std::unordered_set<int> setTried;\n-    std::unordered_map<int, int> mapNew;\n-\n-    if (vRandom.size() != (size_t)(nTried + nNew))\n-        return -7;\n-\n-    for (const auto& entry : mapInfo) {\n-        int n = entry.first;\n-        const CAddrInfo& info = entry.second;\n-        if (info.fInTried) {\n-            if (!info.nLastSuccess)\n-                return -1;\n-            if (info.nRefCount)\n-                return -2;\n-            setTried.insert(n);\n-        } else {\n-            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n-                return -3;\n-            if (!info.nRefCount)\n-                return -4;\n-            mapNew[n] = info.nRefCount;\n-        }\n-        const auto it{mapAddr.find(info)};\n-        if (it == mapAddr.end() || it->second != n) {\n-            return -5;\n-        }\n-        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n-            return -14;\n-        if (info.nLastTry < 0)\n-            return -6;\n-        if (info.nLastSuccess < 0)\n-            return -8;\n-    }\n-\n-    if (setTried.size() != (size_t)nTried)\n-        return -9;\n-    if (mapNew.size() != (size_t)nNew)\n-        return -10;\n-\n-    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvTried[n][i] != -1) {\n-                if (!setTried.count(vvTried[n][i]))\n-                    return -11;\n-                const auto it{mapInfo.find(vvTried[n][i])};\n-                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n-                    return -17;\n-                }\n-                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n-                    return -18;\n-                }\n-                setTried.erase(vvTried[n][i]);\n-            }\n-        }\n-    }\n-\n-    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvNew[n][i] != -1) {\n-                if (!mapNew.count(vvNew[n][i]))\n-                    return -12;\n-                const auto it{mapInfo.find(vvNew[n][i])};\n-                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n-                    return -19;\n-                }\n-                if (--mapNew[vvNew[n][i]] == 0)\n-                    mapNew.erase(vvNew[n][i]);\n+            const AddrInfo& info{it_found->second};\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n             }\n+            fChanceFactor *= 1.2;\n         }\n     }\n-\n-    if (setTried.size())\n-        return -13;\n-    if (mapNew.size())\n-        return -15;\n-    if (nKey.IsNull())\n-        return -16;\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n-    return 0;\n }\n \n-void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -865,38 +760,41 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size\n \n     // gather a list of random nodes, skipping those of low quality\n     const int64_t now{GetAdjustedTime()};\n+    std::vector<CAddress> addresses;\n     for (unsigned int n = 0; n < vRandom.size(); n++) {\n-        if (vAddr.size() >= nNodes)\n+        if (addresses.size() >= nNodes)\n             break;\n \n         int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);\n         const auto it{mapInfo.find(vRandom[n])};\n         assert(it != mapInfo.end());\n \n-        const CAddrInfo& ai{it->second};\n+        const AddrInfo& ai{it->second};\n \n         // Filter by network (optional)\n         if (network != std::nullopt && ai.GetNetClass() != network) continue;\n \n         // Filter for quality\n         if (ai.IsTerrible(now)) continue;\n \n-        vAddr.push_back(ai);\n+        addresses.push_back(ai);\n     }\n+\n+    return addresses;\n }\n \n-void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n+void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -908,17 +806,17 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n         info.nTime = nTime;\n }\n \n-void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -928,7 +826,7 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n     info.nServices = nServices;\n }\n \n-void CAddrMan::ResolveCollisions_()\n+void AddrManImpl::ResolveCollisions_()\n {\n     AssertLockHeld(cs);\n \n@@ -941,7 +839,7 @@ void CAddrMan::ResolveCollisions_()\n         if (mapInfo.count(id_new) != 1) {\n             erase_collision = true;\n         } else {\n-            CAddrInfo& info_new = mapInfo[id_new];\n+            AddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n             int tried_bucket = info_new.GetTriedBucket(nKey, m_asmap);\n@@ -952,7 +850,7 @@ void CAddrMan::ResolveCollisions_()\n \n                 // Get the to-be-evicted address that is being tested\n                 int id_old = vvTried[tried_bucket][tried_bucket_pos];\n-                CAddrInfo& info_old = mapInfo[id_old];\n+                AddrInfo& info_old = mapInfo[id_old];\n \n                 // Has successfully connected in last X hours\n                 if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n@@ -989,11 +887,11 @@ void CAddrMan::ResolveCollisions_()\n     }\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision_()\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n {\n     AssertLockHeld(cs);\n \n-    if (m_tried_collisions.size() == 0) return CAddrInfo();\n+    if (m_tried_collisions.size() == 0) return {};\n \n     std::set<int>::iterator it = m_tried_collisions.begin();\n \n@@ -1004,16 +902,291 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     // If id_new not found in mapInfo remove it from m_tried_collisions\n     if (mapInfo.count(id_new) != 1) {\n         m_tried_collisions.erase(it);\n-        return CAddrInfo();\n+        return {};\n     }\n \n-    const CAddrInfo& newInfo = mapInfo[id_new];\n+    const AddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n     int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n-    int id_old = vvTried[tried_bucket][tried_bucket_pos];\n+    const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n+    return {info_old, info_old.nLastTry};\n+}\n+\n+void AddrManImpl::Check() const\n+{\n+    AssertLockHeld(cs);\n+\n+    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n+    if (m_consistency_check_ratio == 0) return;\n+    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n+\n+    const int err{ForceCheckAddrman()};\n+    if (err) {\n+        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+        assert(false);\n+    }\n+}\n+\n+int AddrManImpl::ForceCheckAddrman() const\n+{\n+    AssertLockHeld(cs);\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n+\n+    std::unordered_set<int> setTried;\n+    std::unordered_map<int, int> mapNew;\n+\n+    if (vRandom.size() != (size_t)(nTried + nNew))\n+        return -7;\n+\n+    for (const auto& entry : mapInfo) {\n+        int n = entry.first;\n+        const AddrInfo& info = entry.second;\n+        if (info.fInTried) {\n+            if (!info.nLastSuccess)\n+                return -1;\n+            if (info.nRefCount)\n+                return -2;\n+            setTried.insert(n);\n+        } else {\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                return -3;\n+            if (!info.nRefCount)\n+                return -4;\n+            mapNew[n] = info.nRefCount;\n+        }\n+        const auto it{mapAddr.find(info)};\n+        if (it == mapAddr.end() || it->second != n) {\n+            return -5;\n+        }\n+        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n+            return -14;\n+        if (info.nLastTry < 0)\n+            return -6;\n+        if (info.nLastSuccess < 0)\n+            return -8;\n+    }\n+\n+    if (setTried.size() != (size_t)nTried)\n+        return -9;\n+    if (mapNew.size() != (size_t)nNew)\n+        return -10;\n+\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvTried[n][i] != -1) {\n+                if (!setTried.count(vvTried[n][i]))\n+                    return -11;\n+                const auto it{mapInfo.find(vvTried[n][i])};\n+                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n+                    return -17;\n+                }\n+                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n+                    return -18;\n+                }\n+                setTried.erase(vvTried[n][i]);\n+            }\n+        }\n+    }\n+\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[n][i] != -1) {\n+                if (!mapNew.count(vvNew[n][i]))\n+                    return -12;\n+                const auto it{mapInfo.find(vvNew[n][i])};\n+                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n+                    return -19;\n+                }\n+                if (--mapNew[vvNew[n][i]] == 0)\n+                    mapNew.erase(vvNew[n][i]);\n+            }\n+        }\n+    }\n+\n+    if (setTried.size())\n+        return -13;\n+    if (mapNew.size())\n+        return -15;\n+    if (nKey.IsNull())\n+        return -16;\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n+    return 0;\n+}\n+\n+size_t AddrManImpl::size() const\n+{\n+    LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n+    return vRandom.size();\n+}\n+\n+bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    LOCK(cs);\n+    int nAdd = 0;\n+    Check();\n+    for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+        nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n+    Check();\n+    if (nAdd) {\n+        LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+    }\n+    return nAdd > 0;\n+}\n+\n+void AddrManImpl::Good(const CService& addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Good_(addr, /* test_before_evict */ true, nTime);\n+    Check();\n+}\n \n-    return mapInfo[id_old];\n+void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Attempt_(addr, fCountFailure, nTime);\n+    Check();\n+}\n+\n+void AddrManImpl::ResolveCollisions()\n+{\n+    LOCK(cs);\n+    Check();\n+    ResolveCollisions_();\n+    Check();\n+}\n+\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision()\n+{\n+    LOCK(cs);\n+    Check();\n+    const auto ret = SelectTriedCollision_();\n+    Check();\n+    return ret;\n+}\n+\n+std::pair<CAddress, int64_t> AddrManImpl::Select(bool newOnly) const\n+{\n+    LOCK(cs);\n+    Check();\n+    const auto addrRet = Select_(newOnly);\n+    Check();\n+    return addrRet;\n+}\n+\n+std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    LOCK(cs);\n+    Check();\n+    const auto addresses = GetAddr_(max_addresses, max_pct, network);\n+    Check();\n+    return addresses;\n+}\n+\n+void AddrManImpl::Connected(const CService& addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Connected_(addr, nTime);\n+    Check();\n+}\n+\n+void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)\n+{\n+    LOCK(cs);\n+    Check();\n+    SetServices_(addr, nServices);\n+    Check();\n+}\n+\n+const std::vector<bool>& AddrManImpl::GetAsmap() const\n+{\n+    return m_asmap;\n+}\n+\n+AddrMan::AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+    : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n+\n+AddrMan::~AddrMan() = default;\n+\n+template <typename Stream>\n+void AddrMan::Serialize(Stream& s_) const\n+{\n+    m_impl->Serialize<Stream>(s_);\n+}\n+\n+template <typename Stream>\n+void AddrMan::Unserialize(Stream& s_)\n+{\n+    m_impl->Unserialize<Stream>(s_);\n+}\n+\n+// explicit instantiation\n+template void AddrMan::Serialize(CHashWriter& s) const;\n+template void AddrMan::Serialize(CAutoFile& s) const;\n+template void AddrMan::Serialize(CDataStream& s) const;\n+template void AddrMan::Unserialize(CAutoFile& s);\n+template void AddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void AddrMan::Unserialize(CDataStream& s);\n+template void AddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n+size_t AddrMan::size() const\n+{\n+    return m_impl->size();\n+}\n+\n+bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    return m_impl->Add(vAddr, source, nTimePenalty);\n+}\n+\n+void AddrMan::Good(const CService& addr, int64_t nTime)\n+{\n+    m_impl->Good(addr, nTime);\n+}\n+\n+void AddrMan::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n+{\n+    m_impl->Attempt(addr, fCountFailure, nTime);\n+}\n+\n+void AddrMan::ResolveCollisions()\n+{\n+    m_impl->ResolveCollisions();\n+}\n+\n+std::pair<CAddress, int64_t> AddrMan::SelectTriedCollision()\n+{\n+    return m_impl->SelectTriedCollision();\n+}\n+\n+std::pair<CAddress, int64_t> AddrMan::Select(bool newOnly) const\n+{\n+    return m_impl->Select(newOnly);\n+}\n+\n+std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    return m_impl->GetAddr(max_addresses, max_pct, network);\n+}\n+\n+void AddrMan::Connected(const CService& addr, int64_t nTime)\n+{\n+    m_impl->Connected(addr, nTime);\n+}\n+\n+void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)\n+{\n+    m_impl->SetServices(addr, nServices);\n+}\n+\n+const std::vector<bool>& AddrMan::GetAsmap() const\n+{\n+    return m_impl->GetAsmap();\n }"
      },
      {
        "sha": "174ab4f811b0590732f437ed637ecdc8fb020e7d",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 39,
        "deletions": 335,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -6,94 +6,22 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include <fs.h>\n-#include <logging.h>\n #include <netaddress.h>\n #include <protocol.h>\n-#include <sync.h>\n+#include <streams.h>\n #include <timedata.h>\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n-#include <set>\n-#include <unordered_map>\n+#include <utility>\n #include <vector>\n \n+class AddrManImpl;\n+\n /** Default for -checkaddrman */\n static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n \n-/**\n- * Extended statistics about a CAddress\n- */\n-class CAddrInfo : public CAddress\n-{\n-public:\n-    //! last try whatsoever by us (memory only)\n-    int64_t nLastTry{0};\n-\n-    //! last counted attempt (memory only)\n-    int64_t nLastCountAttempt{0};\n-\n-private:\n-    //! where knowledge about this address first came from\n-    CNetAddr source;\n-\n-    //! last successful connection by us\n-    int64_t nLastSuccess{0};\n-\n-    //! connection attempts since last successful attempt\n-    int nAttempts{0};\n-\n-    //! reference count in new sets (memory only)\n-    int nRefCount{0};\n-\n-    //! in tried set? (memory only)\n-    bool fInTried{false};\n-\n-    //! position in vRandom\n-    mutable int nRandomPos{-1};\n-\n-    friend class CAddrMan;\n-    friend class CAddrManDeterministic;\n-\n-public:\n-\n-    SERIALIZE_METHODS(CAddrInfo, obj)\n-    {\n-        READWRITEAS(CAddress, obj);\n-        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n-    }\n-\n-    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n-    {\n-    }\n-\n-    CAddrInfo() : CAddress(), source()\n-    {\n-    }\n-\n-    //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n-    {\n-        return GetNewBucket(nKey, source, asmap);\n-    }\n-\n-    //! Calculate in which position of a bucket to store this entry.\n-    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n-\n-    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n-    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n-\n-    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n-    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n-};\n-\n /** Stochastic address manager\n  *\n  * Design goals:\n@@ -123,290 +51,64 @@ class CAddrInfo : public CAddress\n  *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n+class AddrMan\n+{\n+    const std::unique_ptr<AddrManImpl> m_impl;\n \n-/** Total number of buckets for tried addresses */\n-static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n-static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n-\n-/** Total number of buckets for new addresses */\n-static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n-static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+public:\n+    explicit AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n-/** Maximum allowed number of entries in buckets for new and tried addresses */\n-static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n-static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n+    ~AddrMan();\n \n-/**\n- * Stochastical (IP) address manager\n- */\n-class CAddrMan\n-{\n-public:\n     template <typename Stream>\n-    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Serialize(Stream& s_) const;\n \n     template <typename Stream>\n-    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n-\n-    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n-\n-    ~CAddrMan()\n-    {\n-        nKey.SetNull();\n-    }\n+    void Unserialize(Stream& s_);\n \n     //! Return the number of (unique) addresses in all tables.\n-    size_t size() const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n-        return vRandom.size();\n-    }\n+    size_t size() const;\n \n     //! Add addresses to addrman's new table.\n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        int nAdd = 0;\n-        Check();\n-        for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n-            nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n-        Check();\n-        if (nAdd) {\n-            LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n-        }\n-        return nAdd > 0;\n-    }\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n-    //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Good_(addr, /* test_before_evict */ true, nTime);\n-        Check();\n-    }\n+    //! Mark an entry as accessible, possibly moving it from \"new\" to \"tried\".\n+    void Good(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Attempt_(addr, fCountFailure, nTime);\n-        Check();\n-    }\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        ResolveCollisions_();\n-        Check();\n-    }\n-\n-    //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo ret = SelectTriedCollision_();\n-        Check();\n-        return ret;\n-    }\n+    void ResolveCollisions();\n \n     /**\n-     * Choose an address to connect to.\n+     * Randomly select an address in the tried table that another address is\n+     * attempting to evict.\n+     *\n+     * @return CAddress The record for the selected tried peer.\n+     *         int64_t  The last time we attempted to connect to that peer.\n      */\n-    CAddrInfo Select(bool newOnly = false) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo addrRet = Select_(newOnly);\n-        Check();\n-        return addrRet;\n-    }\n+    std::pair<CAddress, int64_t> SelectTriedCollision();\n \n     /**\n-     * Return all or many randomly selected addresses, optionally by network.\n+     * Choose an address to connect to.\n      *\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @return    CAddress The record for the selected peer.\n+     *            int64_t  The last time we attempted to connect to that peer.\n      */\n-    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        std::vector<CAddress> vAddr;\n-        GetAddr_(vAddr, max_addresses, max_pct, network);\n-        Check();\n-        return vAddr;\n-    }\n-\n-    //! Outer function for Connected_()\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Connected_(addr, nTime);\n-        Check();\n-    }\n-\n-    void SetServices(const CService &addr, ServiceFlags nServices)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        SetServices_(addr, nServices);\n-        Check();\n-    }\n-\n-    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n-\n-private:\n-    //! A mutex to protect the inner data structures.\n-    mutable Mutex cs;\n-\n-    //! Source of random numbers for randomization in inner loops\n-    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n-\n-    //! secret key to randomize bucket select with\n-    uint256 nKey;\n-\n-    //! Serialization versions.\n-    enum Format : uint8_t {\n-        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n-        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n-        V2_ASMAP = 2,         //!< for files including asmap version\n-        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n-    };\n-\n-    //! The maximum format this software knows it can unserialize. Also, we always serialize\n-    //! in this format.\n-    //! The format (first byte in the serialized stream) can be higher than this and\n-    //! still this software may be able to unserialize the file - if the second byte\n-    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n-    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n-\n-    //! The initial value of a field that is incremented every time an incompatible format\n-    //! change is made (such that old software versions would not be able to parse and\n-    //! understand the new file format). This is 32 because we overtook the \"key size\"\n-    //! field which was 32 historically.\n-    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n-    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n-\n-    //! last used nId\n-    int nIdCount GUARDED_BY(cs){0};\n-\n-    //! table with information about all nIds\n-    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n-\n-    //! find an nId based on its network address\n-    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n-\n-    //! randomly-ordered vector of all nIds\n-    //! This is mutable because it is unobservable outside the class, so any\n-    //! changes to it (even in const methods) are also unobservable.\n-    mutable std::vector<int> vRandom GUARDED_BY(cs);\n-\n-    // number of \"tried\" entries\n-    int nTried GUARDED_BY(cs){0};\n-\n-    //! list of \"tried\" buckets\n-    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! number of (unique) \"new\" entries\n-    int nNew GUARDED_BY(cs){0};\n-\n-    //! list of \"new\" buckets\n-    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n-    int64_t nLastGood GUARDED_BY(cs){1};\n-\n-    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n-    std::set<int> m_tried_collisions;\n-\n-    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n-    const int32_t m_consistency_check_ratio;\n-\n-    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n-    // Should be always empty if no file was provided.\n-    // This mapping is then used for bucketing nodes in Addrman.\n-    //\n-    // If asmap is provided, nodes will be bucketed by\n-    // AS they belong to, in order to make impossible for a node\n-    // to connect to several nodes hosted in a single AS.\n-    // This is done in response to Erebus attack, but also to generally\n-    // diversify the connections every node creates,\n-    // especially useful when a large fraction of nodes\n-    // operate under a couple of cloud providers.\n-    //\n-    // If a new asmap was provided, the existing records\n-    // would be re-bucketed accordingly.\n-    const std::vector<bool> m_asmap;\n-\n-    //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Swap two elements in vRandom.\n-    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Delete an entry. It must not be in tried, and have refcount 0.\n-    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n-    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Add an entry to the \"new\" table.\n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry as attempted to connect.\n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n-    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Perform consistency check, regardless of m_consistency_check_ratio.\n-    //! @returns an error code or zero.\n-    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::pair<CAddress, int64_t> Select(bool newOnly = false) const;\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n      *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n      * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n+     *\n+     * @return                   A vector of randomly selected addresses from vRandom.\n      */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const;\n \n     /** We have successfully connected to this peer. Calling this function\n      *  updates the CAddress's nTime, which is used in our IsTerrible()\n@@ -419,13 +121,15 @@ class CAddrMan\n      * @param[in]   addr     The address of the peer we were connected to\n      * @param[in]   nTime    The time that we were last connected to this peer\n      */\n-    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void Connected(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Update an entry's service bits.\n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void SetServices(const CService& addr, ServiceFlags nServices);\n+\n+    const std::vector<bool>& GetAsmap() const;\n \n-    friend class CAddrManTest;\n-    friend class CAddrManDeterministic;\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "1dc7f25f9c476dc62774c69fd485b88c060ef0ae",
        "filename": "src/addrman_impl.h",
        "status": "added",
        "additions": 271,
        "deletions": 0,
        "changes": 271,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRMAN_IMPL_H\n+#define BITCOIN_ADDRMAN_IMPL_H\n+\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <protocol.h>\n+#include <serialize.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <utility>\n+#include <vector>\n+\n+/** Total number of buckets for tried addresses */\n+static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n+/** Total number of buckets for new addresses */\n+static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+/** Maximum allowed number of entries in buckets for new and tried addresses */\n+static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n+static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n+\n+/**\n+ * Extended statistics about a CAddress\n+ */\n+class AddrInfo : public CAddress\n+{\n+public:\n+    //! last try whatsoever by us (memory only)\n+    int64_t nLastTry{0};\n+\n+    //! last counted attempt (memory only)\n+    int64_t nLastCountAttempt{0};\n+\n+    //! where knowledge about this address first came from\n+    CNetAddr source;\n+\n+    //! last successful connection by us\n+    int64_t nLastSuccess{0};\n+\n+    //! connection attempts since last successful attempt\n+    int nAttempts{0};\n+\n+    //! reference count in new sets (memory only)\n+    int nRefCount{0};\n+\n+    //! in tried set? (memory only)\n+    bool fInTried{false};\n+\n+    //! position in vRandom\n+    mutable int nRandomPos{-1};\n+\n+    SERIALIZE_METHODS(AddrInfo, obj)\n+    {\n+        READWRITEAS(CAddress, obj);\n+        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n+    }\n+\n+    AddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n+    {\n+    }\n+\n+    AddrInfo() : CAddress(), source()\n+    {\n+    }\n+\n+    //! Calculate in which \"tried\" bucket this entry belongs\n+    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n+    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n+    {\n+        return GetNewBucket(nKey, source, asmap);\n+    }\n+\n+    //! Calculate in which position of a bucket to store this entry.\n+    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n+\n+    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n+    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n+\n+    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n+    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n+};\n+\n+class AddrManImpl\n+{\n+public:\n+    AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio);\n+\n+    ~AddrManImpl();\n+\n+    template <typename Stream>\n+    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    template <typename Stream>\n+    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Good(const CService& addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::pair<CAddress, int64_t> SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::pair<CAddress, int64_t> Select(bool newOnly) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Connected(const CService& addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void SetServices(const CService& addr, ServiceFlags nServices)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    const std::vector<bool>& GetAsmap() const;\n+\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n+\n+private:\n+    //! A mutex to protect the inner data structures.\n+    mutable Mutex cs;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs){0};\n+\n+    //! table with information about all nIds\n+    std::unordered_map<int, AddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    //! This is mutable because it is unobservable outside the class, so any\n+    //! changes to it (even in const methods) are also unobservable.\n+    mutable std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs){0};\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs){0};\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n+    int64_t nLastGood GUARDED_BY(cs){1};\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n+    const int32_t m_consistency_check_ratio;\n+\n+    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n+    // Should be always empty if no file was provided.\n+    // This mapping is then used for bucketing nodes in Addrman.\n+    //\n+    // If asmap is provided, nodes will be bucketed by\n+    // AS they belong to, in order to make impossible for a node\n+    // to connect to several nodes hosted in a single AS.\n+    // This is done in response to Erebus attack, but also to generally\n+    // diversify the connections every node creates,\n+    // especially useful when a large fraction of nodes\n+    // operate under a couple of cloud providers.\n+    //\n+    // If a new asmap was provided, the existing records\n+    // would be re-bucketed accordingly.\n+    const std::vector<bool> m_asmap;\n+\n+    //! Find an entry.\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(AddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void Good_(const CService& addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    bool Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void Attempt_(const CService& addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void SetServices_(const CService& addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    std::pair<CAddress, int64_t> SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n+    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Perform consistency check, regardless of m_consistency_check_ratio.\n+    //! @returns an error code or zero.\n+    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+};\n+\n+#endif // BITCOIN_ADDRMAN_IMPL_H"
      },
      {
        "sha": "d6834a239bd911c4dfcc08fa09e4c7084cc987bd",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -53,14 +53,14 @@ static void CreateAddresses()\n     }\n }\n \n-static void AddAddressesToAddrMan(CAddrMan& addrman)\n+static void AddAddressesToAddrMan(AddrMan& addrman)\n {\n     for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n         addrman.Add(g_addresses[source_i], g_sources[source_i]);\n     }\n }\n \n-static void FillAddrMan(CAddrMan& addrman)\n+static void FillAddrMan(AddrMan& addrman)\n {\n     CreateAddresses();\n \n@@ -74,26 +74,26 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        CAddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n+        AddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n     bench.run([&] {\n         const auto& address = addrman.Select();\n-        assert(address.GetPort() > 0);\n+        assert(address.first.GetPort() > 0);\n     });\n }\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -105,7 +105,7 @@ static void AddrManGetAddr(benchmark::Bench& bench)\n \n static void AddrManAddThenGood(benchmark::Bench& bench)\n {\n-    auto markSomeAsGood = [](CAddrMan& addrman) {\n+    auto markSomeAsGood = [](AddrMan& addrman) {\n         for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n             for (size_t addr_i = 0; addr_i < NUM_ADDRESSES_PER_SOURCE; ++addr_i) {\n                 addrman.Good(g_addresses[source_i][addr_i]);\n@@ -117,12 +117,12 @@ static void AddrManAddThenGood(benchmark::Bench& bench)\n \n     bench.run([&] {\n         // To make the benchmark independent of the number of evaluations, we always prepare a new addrman.\n-        // This is necessary because CAddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n+        // This is necessary because AddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n         // to the same method and we want to do the same amount of work in every loop iteration.\n         //\n         // This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in\n-        // CAddrMan::Good() will still be noticeable.\n-        CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+        // AddrMan::Good() will still be noticeable.\n+        AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n         AddAddressesToAddrMan(addrman);\n \n         markSomeAsGood(addrman);"
      },
      {
        "sha": "7271ff22b2af52f25f158ab77a66af2d62c370d9",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -2010,17 +2010,18 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             if (nTries > 100)\n                 break;\n \n-            CAddrInfo addr;\n+            CAddress addr;\n+            int64_t addr_last_try{0};\n \n             if (fFeeler) {\n                 // First, try to get a tried table collision address. This returns\n                 // an empty (invalid) address if there are no collisions to try.\n-                addr = addrman.SelectTriedCollision();\n+                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();\n \n                 if (!addr.IsValid()) {\n                     // No tried table collisions. Select a new table address\n                     // for our feeler.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 } else if (AlreadyConnectedToAddress(addr)) {\n                     // If test-before-evict logic would have us connect to a\n                     // peer that we're already connected to, just mark that\n@@ -2029,11 +2030,11 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     // a currently-connected peer.\n                     addrman.Good(addr);\n                     // Select a new table address for our feeler instead.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 }\n             } else {\n                 // Not a feeler\n-                addr = addrman.Select();\n+                std::tie(addr, addr_last_try) = addrman.Select();\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n@@ -2050,7 +2051,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 continue;\n \n             // only consider very recently tried nodes after 30 failed attempts\n-            if (nANow - addr.nLastTry < 600 && nTries < 30)\n+            if (nANow - addr_last_try < 600 && nTries < 30)\n                 continue;\n \n             // for non-feelers, require all the services we'll want,\n@@ -2443,7 +2444,7 @@ void CConnman::SetNetworkActive(bool active)\n     }\n }\n \n-CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, CAddrMan& addrman_in, bool network_active)\n+CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in, bool network_active)\n     : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)\n {\n     SetTryNewOutboundPeer(false);"
      },
      {
        "sha": "e2071414b434f3eb9db5aa8a1df02fd100362246",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -797,7 +797,7 @@ class CConnman\n         m_onion_binds = connOptions.onion_binds;\n     }\n \n-    CConnman(uint64_t seed0, uint64_t seed1, CAddrMan& addrman, bool network_active = true);\n+    CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, bool network_active = true);\n     ~CConnman();\n     bool Start(CScheduler& scheduler, const Options& options);\n \n@@ -1049,7 +1049,7 @@ class CConnman\n     std::vector<ListenSocket> vhListenSocket;\n     std::atomic<bool> fNetworkActive{true};\n     bool fAddressesInitialized{false};\n-    CAddrMan& addrman;\n+    AddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);"
      },
      {
        "sha": "66b99aa2bb156ea4872f2398b456c89f90a4ad0b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -292,7 +292,7 @@ using PeerRef = std::shared_ptr<Peer>;\n class PeerManagerImpl final : public PeerManager\n {\n public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                     BanMan* banman, ChainstateManager& chainman,\n                     CTxMemPool& pool, bool ignore_incoming_txs);\n \n@@ -410,7 +410,7 @@ class PeerManagerImpl final : public PeerManager\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n-    CAddrMan& m_addrman;\n+    AddrMan& m_addrman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n@@ -1426,14 +1426,14 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n            (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n-std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                                BanMan* banman, ChainstateManager& chainman,\n                                                CTxMemPool& pool, bool ignore_incoming_txs)\n {\n     return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, chainman, pool, ignore_incoming_txs);\n }\n \n-PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                  BanMan* banman, ChainstateManager& chainman,\n                                  CTxMemPool& pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n@@ -2664,7 +2664,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // table is also potentially detrimental because new-table entries\n             // are subject to eviction in the event of addrman collisions.  We\n             // mitigate the information-leak by never calling\n-            // CAddrMan::Connected() on block-relay-only peers; see\n+            // AddrMan::Connected() on block-relay-only peers; see\n             // FinalizeNode().\n             //\n             // This moves an address from New to Tried table in Addrman,"
      },
      {
        "sha": "27bc40687a0597a0ff6b454af2524ea1a0a73079",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -9,7 +9,7 @@\n #include <net.h>\n #include <validationinterface.h>\n \n-class CAddrMan;\n+class AddrMan;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n@@ -37,7 +37,7 @@ struct CNodeStateStats {\n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:\n-    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                              BanMan* banman, ChainstateManager& chainman,\n                                              CTxMemPool& pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }"
      },
      {
        "sha": "f9fff5a6d5e6a68f1db6bf8663fbc199d2668305",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -165,7 +165,7 @@ void CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)\n }\n \n /**\n- * Create an \"internal\" address that represents a name or FQDN. CAddrMan uses\n+ * Create an \"internal\" address that represents a name or FQDN. AddrMan uses\n  * these fake addresses to keep track of which DNS seeds were used.\n  * @returns Whether or not the operation was successful.\n  * @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX, CNetAddr::IsInternal(), CNetAddr::IsRFC4193()"
      },
      {
        "sha": "66c8c48f08a07dcffcd45cc57b401695b7f97905",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -62,7 +62,7 @@ enum Network {\n     NET_CJDNS,\n \n     /// A set of addresses that represent the hash of a string or FQDN. We use\n-    /// them in CAddrMan to keep track of which DNS seeds were used.\n+    /// them in AddrMan to keep track of which DNS seeds were used.\n     NET_INTERNAL,\n \n     /// Dummy value to indicate the number of NET_* constants."
      },
      {
        "sha": "26873345b46724752dff4f35c47522486c046805",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -12,7 +12,7 @@\n \n class ArgsManager;\n class BanMan;\n-class CAddrMan;\n+class AddrMan;\n class CBlockPolicyEstimator;\n class CConnman;\n class CScheduler;\n@@ -39,7 +39,7 @@ class WalletClient;\n struct NodeContext {\n     //! Init interface for initializing current process and connecting to other processes.\n     interfaces::Init* init{nullptr};\n-    std::unique_ptr<CAddrMan> addrman;\n+    std::unique_ptr<AddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;"
      },
      {
        "sha": "bd6f47021956963ea1e88f3279c2fd1d29c9d833",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 105,
        "changes": 211,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <clientversion.h>\n #include <hash.h>\n@@ -21,26 +22,26 @@\n \n using namespace std::literals;\n \n-class CAddrManSerializationMock : public CAddrMan\n+class AddrManSerializationMock : public AddrMan\n {\n public:\n     virtual void Serialize(CDataStream& s) const = 0;\n \n-    CAddrManSerializationMock()\n-        : CAddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n+    AddrManSerializationMock()\n+        : AddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n     {}\n };\n \n-class CAddrManUncorrupted : public CAddrManSerializationMock\n+class AddrManUncorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n     {\n-        CAddrMan::Serialize(s);\n+        AddrMan::Serialize(s);\n     }\n };\n \n-class CAddrManCorrupted : public CAddrManSerializationMock\n+class AddrManCorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n@@ -61,12 +62,12 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n         CAddress addr = CAddress(serv, NODE_NONE);\n         CNetAddr resolved;\n         BOOST_CHECK(LookupHost(\"252.2.2.2\", resolved, false));\n-        CAddrInfo info = CAddrInfo(addr, resolved);\n+        AddrInfo info = AddrInfo(addr, resolved);\n         s << info;\n     }\n };\n \n-static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n+static CDataStream AddrmanToStream(const AddrManSerializationMock& _addrman)\n {\n     CDataStream ssPeersIn(SER_DISK, CLIENT_VERSION);\n     ssPeersIn << Params().MessageStart();\n@@ -76,44 +77,44 @@ static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n     return CDataStream(vchData, SER_DISK, CLIENT_VERSION);\n }\n \n-class CAddrManTest : public CAddrMan\n+class AddrManTest : public AddrMan\n {\n private:\n     bool deterministic;\n public:\n-    explicit CAddrManTest(bool makeDeterministic = true,\n-                          std::vector<bool> asmap = std::vector<bool>())\n-        : CAddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n+    explicit AddrManTest(bool makeDeterministic = true,\n+                         std::vector<bool> asmap = std::vector<bool>())\n+        : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;\n     }\n \n-    CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Find(addr, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Find(addr, pnId);\n     }\n \n-    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Create(addr, addrSource, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Create(addr, addrSource, pnId);\n     }\n \n     void Delete(int nId)\n     {\n-        LOCK(cs);\n-        CAddrMan::Delete(nId);\n+        LOCK(m_impl->cs);\n+        m_impl->Delete(nId);\n     }\n \n     // Used to test deserialization\n     std::pair<int, int> GetBucketAndEntry(const CAddress& addr)\n     {\n-        LOCK(cs);\n-        int nId = mapAddr[addr];\n+        LOCK(m_impl->cs);\n+        int nId = m_impl->mapAddr[addr];\n         for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n             for (int entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n-                if (nId == vvNew[bucket][entry]) {\n+                if (nId == m_impl->vvNew[bucket][entry]) {\n                     return std::pair<int, int>(bucket, entry);\n                 }\n             }\n@@ -165,20 +166,20 @@ BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n {\n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test: Does Addrman respond correctly when empty.\n     BOOST_CHECK_EQUAL(addrman->size(), 0U);\n-    CAddrInfo addr_null = addrman->Select();\n+    auto addr_null = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n     // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman->size(), 1U);\n-    CAddrInfo addr_ret1 = addrman->Select();\n+    auto addr_ret1 = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Does IP address deduplication work correctly.\n@@ -199,7 +200,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     BOOST_CHECK(addrman->size() >= 1);\n \n     // Test: reset addrman and test AddrMan::Add multiple addresses works as expected\n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     std::vector<CAddress> vAddr;\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n@@ -209,7 +210,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -223,22 +224,22 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     BOOST_CHECK(!addrman.Add({CAddress(addr1_port, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select();\n+    auto addr_ret2 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     bool newOnly = true;\n-    CAddrInfo addr_ret3 = addrman.Select(newOnly);\n+    auto addr_ret3 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n \n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -248,16 +249,16 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     bool newOnly = true;\n-    CAddrInfo addr_ret1 = addrman.Select(newOnly);\n+    auto addr_ret1 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select(newOnly);\n+    auto addr_ret2 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n-    CAddrInfo addr_ret3 = addrman.Select();\n+    auto addr_ret3 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n@@ -290,14 +291,14 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Test: Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n-        ports.insert(addrman.Select().GetPort());\n+        ports.insert(addrman.Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -326,7 +327,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -356,7 +357,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -372,44 +373,44 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     BOOST_CHECK(addrman.Add({addr3}, source1));\n \n     // Test: ensure Find returns an IP matching what we searched on.\n-    CAddrInfo* info1 = addrman.Find(addr1);\n+    AddrInfo* info1 = addrman.Find(addr1);\n     BOOST_REQUIRE(info1);\n     BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n-    CAddrInfo* info2 = addrman.Find(addr2);\n+    AddrInfo* info2 = addrman.Find(addr2);\n     BOOST_REQUIRE(info2);\n     BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n     // Test: Find returns another IP matching what we searched on.\n-    CAddrInfo* info3 = addrman.Find(addr3);\n+    AddrInfo* info3 = addrman.Find(addr3);\n     BOOST_REQUIRE(info3);\n     BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n-    CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n+    AddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n     // Test: The result should be the same as the input addr.\n     BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n \n BOOST_AUTO_TEST_CASE(addrman_delete)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -423,13 +424,13 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     addrman.Delete(nId);\n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == nullptr);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n@@ -489,15 +490,15 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -512,14 +513,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetTriedBucket(nKey1, asmap);\n@@ -531,7 +532,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -544,14 +545,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -567,13 +568,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -585,7 +586,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -598,7 +599,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -622,15 +623,15 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n // 101.8.0.0/16 AS8\n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -645,14 +646,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"101.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -664,7 +665,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -677,14 +678,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -700,13 +701,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -718,7 +719,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -731,7 +732,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -743,7 +744,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -759,9 +760,9 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n {\n     std::vector<bool> asmap1 = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n \n-    auto addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_asmap1_dup = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_noasmap = std::make_unique<CAddrManTest>();\n+    auto addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_asmap1_dup = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_noasmap = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     CAddress addr = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n@@ -791,8 +792,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1.second != bucketAndEntry_noasmap.second);\n \n     // deserializing non-asmaped peers.dat to asmaped addrman\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     addrman_noasmap->Add({addr}, default_source);\n     stream << *addrman_noasmap;\n     stream >> *addrman_asmap1;\n@@ -803,8 +804,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1_deser.second == bucketAndEntry_asmap1_dup.second);\n \n     // used to map to different buckets, now maps to the same bucket.\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.2.1.1\"), NODE_NONE);\n     addrman_noasmap->Add({addr, addr2}, default_source);\n@@ -824,7 +825,7 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n {\n     // Confirm that invalid addresses are ignored in unserialization.\n \n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     const CAddress new1{ResolveService(\"5.5.5.5\"), NODE_NONE};\n@@ -856,19 +857,19 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n     BOOST_REQUIRE(pos + sizeof(tried2_raw_replacement) <= stream.size());\n     memcpy(stream.data() + pos, tried2_raw_replacement, sizeof(tried2_raw_replacement));\n \n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     stream >> *addrman;\n     BOOST_CHECK_EQUAL(addrman->size(), 2);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add twenty two addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -879,7 +880,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n         // No collisions yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Ensure Good handles duplicates well.\n@@ -888,14 +889,14 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == 22);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n }\n \n BOOST_AUTO_TEST_CASE(addrman_noevict)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Add 35 addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -906,7 +907,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -915,11 +916,11 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr36);\n \n     BOOST_CHECK(addrman.size() == 36);\n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.19:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.19:0\");\n \n     // 36 should be discarded and 19 not evicted.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Lets create two collisions.\n     for (unsigned int i = 37; i < 59; i++) {\n@@ -928,7 +929,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Cause a collision.\n@@ -937,26 +938,26 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr59);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.10:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.10:0\");\n \n     // Cause a second collision.\n     BOOST_CHECK(!addrman.Add({CAddress(addr36, NODE_NONE)}, source));\n     addrman.Good(addr36);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() != \"[::]:0\");\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add 35 addresses\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -967,7 +968,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -976,36 +977,36 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     addrman.Good(addr);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 36);\n-    CAddrInfo info = addrman.SelectTriedCollision();\n+    auto info = addrman.SelectTriedCollision().first;\n     BOOST_CHECK_EQUAL(info.ToString(), \"250.1.1.19:0\");\n \n     // Ensure test of address fails, so that it is evicted.\n     addrman.SimConnFail(info);\n \n     // Should swap 36 for 19.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If 36 was swapped for 19, then this should cause no collisions.\n     BOOST_CHECK(!addrman.Add({CAddress(addr, NODE_NONE)}, source));\n     addrman.Good(addr);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If we insert 19 it should collide with 36\n     CService addr19 = ResolveService(\"250.1.1.19\");\n     BOOST_CHECK(!addrman.Add({CAddress(addr19, NODE_NONE)}, source));\n     addrman.Good(addr19);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.36:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.36:0\");\n \n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(load_addrman)\n {\n-    CAddrManUncorrupted addrmanUncorrupted;\n+    AddrManUncorrupted addrmanUncorrupted;\n \n     CService addr1, addr2, addr3;\n     BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n@@ -1024,7 +1025,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -1041,7 +1042,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n@@ -1050,12 +1051,12 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n \n BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n {\n-    CAddrManCorrupted addrmanCorrupted;\n+    AddrManCorrupted addrmanCorrupted;\n \n     // Test that the de-serialization of corrupted addrman throws an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1071,7 +1072,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }"
      },
      {
        "sha": "cfeab9dcdc2f0e460188c47865ce9a15ca6717d0",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 38,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <merkleblock.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n@@ -27,29 +28,29 @@ FUZZ_TARGET_INIT(data_stream_addr_man, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    CAddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     try {\n         ReadFromStream(addr_man, data_stream);\n     } catch (const std::exception&) {\n     }\n }\n \n-class CAddrManDeterministic : public CAddrMan\n+class AddrManDeterministic : public AddrMan\n {\n public:\n     FuzzedDataProvider& m_fuzzed_data_provider;\n \n-    explicit CAddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n-        : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n+    explicit AddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n+        : AddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n-        WITH_LOCK(cs, insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n+        WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n     }\n \n     /**\n      * Generate a random address. Always returns a valid address.\n      */\n-    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(cs)\n+    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs)\n     {\n         CNetAddr addr;\n         if (m_fuzzed_data_provider.remaining_bytes() > 1 && m_fuzzed_data_provider.ConsumeBool()) {\n@@ -61,15 +62,15 @@ class CAddrManDeterministic : public CAddrMan\n                                                                    {4, ADDR_TORV3_SIZE},\n                                                                    {5, ADDR_I2P_SIZE},\n                                                                    {6, ADDR_CJDNS_SIZE}};\n-            uint8_t net = insecure_rand.randrange(5) + 1; // [1..5]\n+            uint8_t net = m_impl->insecure_rand.randrange(5) + 1; // [1..5]\n             if (net == 3) {\n                 net = 6;\n             }\n \n             CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n \n             s << net;\n-            s << insecure_rand.randbytes(net_len_map.at(net));\n+            s << m_impl->insecure_rand.randbytes(net_len_map.at(net));\n \n             s >> addr;\n         }\n@@ -89,7 +90,7 @@ class CAddrManDeterministic : public CAddrMan\n      */\n     void Fill()\n     {\n-        LOCK(cs);\n+        LOCK(m_impl->cs);\n \n         // Add some of the addresses directly to the \"tried\" table.\n \n@@ -102,20 +103,20 @@ class CAddrManDeterministic : public CAddrMan\n         // the latter is exhausted it just returns 0.\n         for (size_t i = 0; i < num_sources; ++i) {\n             const auto source = RandAddr();\n-            const size_t num_addresses = insecure_rand.randrange(500) + 1; // [1..500]\n+            const size_t num_addresses = m_impl->insecure_rand.randrange(500) + 1; // [1..500]\n \n             for (size_t j = 0; j < num_addresses; ++j) {\n                 const auto addr = CAddress{CService{RandAddr(), 8333}, NODE_NETWORK};\n-                const auto time_penalty = insecure_rand.randrange(100000001);\n-                Add_(addr, source, time_penalty);\n+                const auto time_penalty = m_impl->insecure_rand.randrange(100000001);\n+                m_impl->Add_(addr, source, time_penalty);\n \n-                if (n > 0 && mapInfo.size() % n == 0) {\n-                    Good_(addr, false, GetTime());\n+                if (n > 0 && m_impl->mapInfo.size() % n == 0) {\n+                    m_impl->Good_(addr, false, GetTime());\n                 }\n \n                 // Add 10% of the addresses from more than one source.\n-                if (insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n-                    Add_(addr, prev_source, time_penalty);\n+                if (m_impl->insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n+                    m_impl->Add_({addr}, prev_source, time_penalty);\n                 }\n             }\n             prev_source = source;\n@@ -129,69 +130,69 @@ class CAddrManDeterministic : public CAddrMan\n      * - vvNew entries refer to the same addresses\n      * - vvTried entries refer to the same addresses\n      */\n-    bool operator==(const CAddrManDeterministic& other)\n+    bool operator==(const AddrManDeterministic& other)\n     {\n-        LOCK2(cs, other.cs);\n+        LOCK2(m_impl->cs, other.m_impl->cs);\n \n-        if (mapInfo.size() != other.mapInfo.size() || nNew != other.nNew ||\n-            nTried != other.nTried) {\n+        if (m_impl->mapInfo.size() != other.m_impl->mapInfo.size() || m_impl->nNew != other.m_impl->nNew ||\n+            m_impl->nTried != other.m_impl->nTried) {\n             return false;\n         }\n \n         // Check that all values in `mapInfo` are equal to all values in `other.mapInfo`.\n         // Keys may be different.\n \n-        using CAddrInfoHasher = std::function<size_t(const CAddrInfo&)>;\n-        using CAddrInfoEq = std::function<bool(const CAddrInfo&, const CAddrInfo&)>;\n+        using AddrInfoHasher = std::function<size_t(const AddrInfo&)>;\n+        using AddrInfoEq = std::function<bool(const AddrInfo&, const AddrInfo&)>;\n \n         CNetAddrHash netaddr_hasher;\n \n-        CAddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const CAddrInfo& a) {\n+        AddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const AddrInfo& a) {\n             return netaddr_hasher(static_cast<CNetAddr>(a)) ^ netaddr_hasher(a.source) ^\n                    a.nLastSuccess ^ a.nAttempts ^ a.nRefCount ^ a.fInTried;\n         };\n \n-        CAddrInfoEq addrinfo_eq = [](const CAddrInfo& lhs, const CAddrInfo& rhs) {\n+        AddrInfoEq addrinfo_eq = [](const AddrInfo& lhs, const AddrInfo& rhs) {\n             return static_cast<CNetAddr>(lhs) == static_cast<CNetAddr>(rhs) &&\n                    lhs.source == rhs.source && lhs.nLastSuccess == rhs.nLastSuccess &&\n                    lhs.nAttempts == rhs.nAttempts && lhs.nRefCount == rhs.nRefCount &&\n                    lhs.fInTried == rhs.fInTried;\n         };\n \n-        using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n+        using Addresses = std::unordered_set<AddrInfo, AddrInfoHasher, AddrInfoEq>;\n \n-        const size_t num_addresses{mapInfo.size()};\n+        const size_t num_addresses{m_impl->mapInfo.size()};\n \n         Addresses addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : mapInfo) {\n+        for (const auto& [id, addr] : m_impl->mapInfo) {\n             addresses.insert(addr);\n         }\n \n         Addresses other_addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : other.mapInfo) {\n+        for (const auto& [id, addr] : other.m_impl->mapInfo) {\n             other_addresses.insert(addr);\n         }\n \n         if (addresses != other_addresses) {\n             return false;\n         }\n \n-        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(cs, other.cs) {\n+        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs, other.m_impl->cs) {\n             if (id == -1 && other_id == -1) {\n                 return true;\n             }\n             if ((id == -1 && other_id != -1) || (id != -1 && other_id == -1)) {\n                 return false;\n             }\n-            return mapInfo.at(id) == other.mapInfo.at(other_id);\n+            return m_impl->mapInfo.at(id) == other.m_impl->mapInfo.at(other_id);\n         };\n \n         // Check that `vvNew` contains the same addresses as `other.vvNew`. Notice - `vvNew[i][j]`\n         // contains just an id and the address is to be found in `mapInfo.at(id)`. The ids\n         // themselves may differ between `vvNew` and `other.vvNew`.\n         for (size_t i = 0; i < ADDRMAN_NEW_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvNew[i][j], other.vvNew[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvNew[i][j], other.m_impl->vvNew[i][j])) {\n                     return false;\n                 }\n             }\n@@ -200,7 +201,7 @@ class CAddrManDeterministic : public CAddrMan\n         // Same for `vvTried`.\n         for (size_t i = 0; i < ADDRMAN_TRIED_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvTried[i][j], other.vvTried[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvTried[i][j], other.m_impl->vvTried[i][j])) {\n                     return false;\n                 }\n             }\n@@ -222,7 +223,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    auto addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+    auto addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n         CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n@@ -231,10 +232,10 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         try {\n             ds >> *addr_man_ptr;\n         } catch (const std::ios_base::failure&) {\n-            addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+            addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n         }\n     }\n-    CAddrManDeterministic& addr_man = *addr_man_ptr;\n+    AddrManDeterministic& addr_man = *addr_man_ptr;\n     while (fuzzed_data_provider.ConsumeBool()) {\n         CallOneOf(\n             fuzzed_data_provider,\n@@ -283,7 +284,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n                 }\n             });\n     }\n-    const CAddrMan& const_addr_man{addr_man};\n+    const AddrMan& const_addr_man{addr_man};\n     (void)const_addr_man.GetAddr(\n         /* max_addresses */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n         /* max_pct */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n@@ -301,8 +302,8 @@ FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n \n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    CAddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n-    CAddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n \n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n "
      },
      {
        "sha": "d381345a0d4d3d4376c70d904f496d497e3d007c",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -25,7 +25,7 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);"
      },
      {
        "sha": "a9325fa738b223f8734f77e396ef4d48027546a6",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <blockencodings.h>\n #include <blockfilter.h>\n #include <chain.h>\n@@ -104,7 +105,7 @@ FUZZ_TARGET_DESERIALIZE(block_filter_deserialize, {\n     DeserializeFromFuzzingInput(buffer, block_filter);\n })\n FUZZ_TARGET_DESERIALIZE(addr_info_deserialize, {\n-    CAddrInfo addr_info;\n+    AddrInfo addr_info;\n     DeserializeFromFuzzingInput(buffer, addr_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_file_info_deserialize, {\n@@ -188,7 +189,7 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    CAddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {"
      },
      {
        "sha": "ebefa9974e773e41c476b02d68d6ba828272e9a4",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -192,7 +192,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<CAddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.addrman = std::make_unique<AddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,"
      },
      {
        "sha": "6d62864a4a8c71b78dfb9d476d75b9c73ece7331",
        "filename": "src/util/syscall_sandbox.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 8,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/util/syscall_sandbox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/src/util/syscall_sandbox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/syscall_sandbox.cpp?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -40,6 +40,24 @@ bool g_syscall_sandbox_log_violation_before_terminating{false};\n #error Syscall sandbox is an experimental feature currently available only under Linux x86-64.\n #endif // defined(__x86_64__)\n \n+#ifndef SECCOMP_RET_KILL_PROCESS\n+#define SECCOMP_RET_KILL_PROCESS 0x80000000U\n+#endif\n+\n+// Define system call numbers for x86_64 that are referenced in the system call profile\n+// but not provided by the kernel headers used in the GUIX build.\n+#ifndef __NR_statx\n+#define __NR_statx 332\n+#endif\n+\n+#ifndef __NR_getrandom\n+#define __NR_getrandom 318\n+#endif\n+\n+#ifndef __NR_membarrier\n+#define __NR_membarrier 324\n+#endif\n+\n // This list of syscalls in LINUX_SYSCALLS is only used to map syscall numbers to syscall names in\n // order to be able to print user friendly error messages which include the syscall name in addition\n // to the syscall number.\n@@ -158,9 +176,7 @@ const std::map<uint32_t, std::string> LINUX_SYSCALLS{\n     {__NR_getpmsg, \"getpmsg\"},\n     {__NR_getppid, \"getppid\"},\n     {__NR_getpriority, \"getpriority\"},\n-#if defined(__NR_getrandom)\n     {__NR_getrandom, \"getrandom\"},\n-#endif // defined(__NR_getrandom)\n     {__NR_getresgid, \"getresgid\"},\n     {__NR_getresuid, \"getresuid\"},\n     {__NR_getrlimit, \"getrlimit\"},\n@@ -208,9 +224,7 @@ const std::map<uint32_t, std::string> LINUX_SYSCALLS{\n     {__NR_lstat, \"lstat\"},\n     {__NR_madvise, \"madvise\"},\n     {__NR_mbind, \"mbind\"},\n-#if defined(__NR_membarrier)\n     {__NR_membarrier, \"membarrier\"},\n-#endif // defined(__NR_membarrier)\n     {__NR_memfd_create, \"memfd_create\"},\n     {__NR_migrate_pages, \"migrate_pages\"},\n     {__NR_mincore, \"mincore\"},\n@@ -511,9 +525,7 @@ class SeccompPolicyBuilder\n     {\n         allowed_syscalls.insert(__NR_brk);     // change data segment size\n         allowed_syscalls.insert(__NR_madvise); // give advice about use of memory\n-#if defined(__NR_membarrier)\n         allowed_syscalls.insert(__NR_membarrier); // issue memory barriers on a set of threads\n-#endif // defined(__NR_membarrier)\n         allowed_syscalls.insert(__NR_mlock);    // lock memory\n         allowed_syscalls.insert(__NR_mmap);     // map files or devices into memory\n         allowed_syscalls.insert(__NR_mprotect); // set protection on a region of memory\n@@ -593,9 +605,7 @@ class SeccompPolicyBuilder\n \n     void AllowGetRandom()\n     {\n-#if defined(__NR_getrandom)\n         allowed_syscalls.insert(__NR_getrandom); // obtain a series of random bytes\n-#endif // defined(__NR_getrandom)\n     }\n \n     void AllowGetSimpleId()"
      },
      {
        "sha": "93d50c13692176f72ecdc17d1ef1dc3dffc2a354",
        "filename": "test/functional/feature_addrman.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8e6545b94e1c9dfd71aecf241948a34890a33d2/test/functional/feature_addrman.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8e6545b94e1c9dfd71aecf241948a34890a33d2/test/functional/feature_addrman.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_addrman.py?ref=a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "patch": "@@ -109,15 +109,15 @@ def run_test(self):\n         self.stop_node(0)\n         write_addrman(peers_dat, len_tried=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n \n         self.log.info(\"Check that corrupt addrman cannot be read (len_new)\")\n         self.stop_node(0)\n         write_addrman(peers_dat, len_new=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n "
      }
    ]
  },
  {
    "sha": "0b1a129f2c05a1622ec02b9dab7a316586539723",
    "node_id": "C_kwDOABII59oAKDBiMWExMjlmMmMwNWExNjIyZWMwMmI5ZGFiN2EzMTY1ODY1Mzk3MjM",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:26:52Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:26:52Z"
      },
      "message": "Remove encoding from fileinput.input()",
      "tree": {
        "sha": "9026a6ca05bc86525499a961de02f00bf6a44ae0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9026a6ca05bc86525499a961de02f00bf6a44ae0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0b1a129f2c05a1622ec02b9dab7a316586539723",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b1a129f2c05a1622ec02b9dab7a316586539723",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0b1a129f2c05a1622ec02b9dab7a316586539723",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b1a129f2c05a1622ec02b9dab7a316586539723/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8e6545b94e1c9dfd71aecf241948a34890a33d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8e6545b94e1c9dfd71aecf241948a34890a33d2"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "faabb8d03ef3e8032dd36b3a1c7d05022d721652",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b1a129f2c05a1622ec02b9dab7a316586539723/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b1a129f2c05a1622ec02b9dab7a316586539723/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=0b1a129f2c05a1622ec02b9dab7a316586539723",
        "patch": "@@ -80,7 +80,7 @@ def find_between( s, first, last ):\n     version = config_dict[\"PACKAGE_VERSION\"].strip('\"')\n     config_dict[\"PACKAGE_STRING\"] = f\"\\\"Bitcoin Core {version}\\\"\"\n \n-    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h', ), inplace=True, encoding=\"utf8\"):\n+    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h', ), inplace=True):\n         header = \"\"\n         if line.startswith(\"#define\"):\n             header = line.split(\" \")[1]\n@@ -112,7 +112,7 @@ def main():\n             with open(vcxproj_filename, 'w', encoding='utf-8') as vcxproj_file:\n                 vcxproj_file.write(vcxproj_in_file.read().replace(\n                     '@SOURCE_FILES@\\n', content))\n-                    \n+\n     parse_config_into_btc_config()\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h'), os.path.join(SOURCE_DIR, 'config/bitcoin-config.h'))\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/libsecp256k1_config.h'), os.path.join(SOURCE_DIR, 'secp256k1/src/libsecp256k1-config.h'))"
      }
    ]
  },
  {
    "sha": "1ea2d36c3574efd6b51174a5481bd6cc39897596",
    "node_id": "C_kwDOABII59oAKDFlYTJkMzZjMzU3NGVmZDZiNTExNzRhNTQ4MWJkNmNjMzk4OTc1OTY",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-05T00:41:41Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:21Z"
      },
      "message": "sandbox: add newfstatat to allowed filesystem syscalls",
      "tree": {
        "sha": "bbeeb032a7d8ad44358b9e3fa3374c432edd1023",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bbeeb032a7d8ad44358b9e3fa3374c432edd1023"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ea2d36c3574efd6b51174a5481bd6cc39897596",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ea2d36c3574efd6b51174a5481bd6cc39897596",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ea2d36c3574efd6b51174a5481bd6cc39897596",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ea2d36c3574efd6b51174a5481bd6cc39897596/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "371f0aeeb4b15aec79905aa29d3203cf76c17544",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/371f0aeeb4b15aec79905aa29d3203cf76c17544",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/371f0aeeb4b15aec79905aa29d3203cf76c17544"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "83d69dd72d60738aac0faf4c626ceeb6a2808c27",
        "filename": "src/util/syscall_sandbox.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ea2d36c3574efd6b51174a5481bd6cc39897596/src/util/syscall_sandbox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ea2d36c3574efd6b51174a5481bd6cc39897596/src/util/syscall_sandbox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/syscall_sandbox.cpp?ref=1ea2d36c3574efd6b51174a5481bd6cc39897596",
        "patch": "@@ -545,6 +545,7 @@ class SeccompPolicyBuilder\n         allowed_syscalls.insert(__NR_fdatasync);  // synchronize a file's in-core state with storage device\n         allowed_syscalls.insert(__NR_flock);      // apply or remove an advisory lock on an open file\n         allowed_syscalls.insert(__NR_fstat);      // get file status\n+        allowed_syscalls.insert(__NR_newfstatat); // get file status\n         allowed_syscalls.insert(__NR_fsync);      // synchronize a file's in-core state with storage device\n         allowed_syscalls.insert(__NR_ftruncate);  // truncate a file to a specified length\n         allowed_syscalls.insert(__NR_getcwd);     // get current working directory"
      }
    ]
  },
  {
    "sha": "13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
    "node_id": "C_kwDOABII59oAKDEzYjNiNmU3YWE2NWNmN2M0Y2IzZTA1MzAyOWJkZjcwMjg4ZjgzZGE",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-10-05T01:13:55Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:21Z"
      },
      "message": "sandbox: add copy_file_range to allowed filesystem syscalls",
      "tree": {
        "sha": "9f3b184f4effd68f934a3769049a076a6bf3a41b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9f3b184f4effd68f934a3769049a076a6bf3a41b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1ea2d36c3574efd6b51174a5481bd6cc39897596",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ea2d36c3574efd6b51174a5481bd6cc39897596",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1ea2d36c3574efd6b51174a5481bd6cc39897596"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 27,
      "deletions": 26
    },
    "files": [
      {
        "sha": "2b479a072e0cb46dfbc44b8179b61b56dcaf513b",
        "filename": "src/util/syscall_sandbox.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 26,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da/src/util/syscall_sandbox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da/src/util/syscall_sandbox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/syscall_sandbox.cpp?ref=13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
        "patch": "@@ -536,32 +536,33 @@ class SeccompPolicyBuilder\n \n     void AllowFileSystem()\n     {\n-        allowed_syscalls.insert(__NR_access);     // check user's permissions for a file\n-        allowed_syscalls.insert(__NR_chdir);      // change working directory\n-        allowed_syscalls.insert(__NR_chmod);      // change permissions of a file\n-        allowed_syscalls.insert(__NR_fallocate);  // manipulate file space\n-        allowed_syscalls.insert(__NR_fchmod);     // change permissions of a file\n-        allowed_syscalls.insert(__NR_fchown);     // change ownership of a file\n-        allowed_syscalls.insert(__NR_fdatasync);  // synchronize a file's in-core state with storage device\n-        allowed_syscalls.insert(__NR_flock);      // apply or remove an advisory lock on an open file\n-        allowed_syscalls.insert(__NR_fstat);      // get file status\n-        allowed_syscalls.insert(__NR_newfstatat); // get file status\n-        allowed_syscalls.insert(__NR_fsync);      // synchronize a file's in-core state with storage device\n-        allowed_syscalls.insert(__NR_ftruncate);  // truncate a file to a specified length\n-        allowed_syscalls.insert(__NR_getcwd);     // get current working directory\n-        allowed_syscalls.insert(__NR_getdents);   // get directory entries\n-        allowed_syscalls.insert(__NR_getdents64); // get directory entries\n-        allowed_syscalls.insert(__NR_lstat);      // get file status\n-        allowed_syscalls.insert(__NR_mkdir);      // create a directory\n-        allowed_syscalls.insert(__NR_open);       // open and possibly create a file\n-        allowed_syscalls.insert(__NR_openat);     // open and possibly create a file\n-        allowed_syscalls.insert(__NR_readlink);   // read value of a symbolic link\n-        allowed_syscalls.insert(__NR_rename);     // change the name or location of a file\n-        allowed_syscalls.insert(__NR_rmdir);      // delete a directory\n-        allowed_syscalls.insert(__NR_stat);       // get file status\n-        allowed_syscalls.insert(__NR_statfs);     // get filesystem statistics\n-        allowed_syscalls.insert(__NR_statx);      // get file status (extended)\n-        allowed_syscalls.insert(__NR_unlink);     // delete a name and possibly the file it refers to\n+        allowed_syscalls.insert(__NR_access);          // check user's permissions for a file\n+        allowed_syscalls.insert(__NR_chdir);           // change working directory\n+        allowed_syscalls.insert(__NR_chmod);           // change permissions of a file\n+        allowed_syscalls.insert(__NR_copy_file_range); // copy a range of data from one file to another\n+        allowed_syscalls.insert(__NR_fallocate);       // manipulate file space\n+        allowed_syscalls.insert(__NR_fchmod);          // change permissions of a file\n+        allowed_syscalls.insert(__NR_fchown);          // change ownership of a file\n+        allowed_syscalls.insert(__NR_fdatasync);       // synchronize a file's in-core state with storage device\n+        allowed_syscalls.insert(__NR_flock);           // apply or remove an advisory lock on an open file\n+        allowed_syscalls.insert(__NR_fstat);           // get file status\n+        allowed_syscalls.insert(__NR_newfstatat);      // get file status\n+        allowed_syscalls.insert(__NR_fsync);           // synchronize a file's in-core state with storage device\n+        allowed_syscalls.insert(__NR_ftruncate);       // truncate a file to a specified length\n+        allowed_syscalls.insert(__NR_getcwd);          // get current working directory\n+        allowed_syscalls.insert(__NR_getdents);        // get directory entries\n+        allowed_syscalls.insert(__NR_getdents64);      // get directory entries\n+        allowed_syscalls.insert(__NR_lstat);           // get file status\n+        allowed_syscalls.insert(__NR_mkdir);           // create a directory\n+        allowed_syscalls.insert(__NR_open);            // open and possibly create a file\n+        allowed_syscalls.insert(__NR_openat);          // open and possibly create a file\n+        allowed_syscalls.insert(__NR_readlink);        // read value of a symbolic link\n+        allowed_syscalls.insert(__NR_rename);          // change the name or location of a file\n+        allowed_syscalls.insert(__NR_rmdir);           // delete a directory\n+        allowed_syscalls.insert(__NR_stat);            // get file status\n+        allowed_syscalls.insert(__NR_statfs);          // get filesystem statistics\n+        allowed_syscalls.insert(__NR_statx);           // get file status (extended)\n+        allowed_syscalls.insert(__NR_unlink);          // delete a name and possibly the file it refers to\n     }\n \n     void AllowFutex()"
      }
    ]
  },
  {
    "sha": "84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
    "node_id": "C_kwDOABII59oAKDg0ZDcwMTFjZTdmZGY1YjhhNjg3NzRlYThkOGI1YTczOTgxZDJjZjM",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T16:37:52Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:22Z"
      },
      "message": "fixes #23073\n\nAdded function to msvc-autogen.py that automatically parses changes from\nconfigure.ac into bitcoin_config.h.\nThe function supports following values:\n- CLIENT_VERSION_BUILD\n- CLIENT_VERSION_IS_RELEASE\n- CLIENT_VERSION_MAJOR\n- CLIENT_VERSION_MINOR\n- COPYRIGHT_YEAR\n- PACKAGE_STRING\n- PACKAGE_VERSION\n\nWas missing a bracket\n\nAdded UTF-8 encoding to open()\n\ntypo\n\nActually call the function",
      "tree": {
        "sha": "2babe78d53d5a6fba8c79319486791b85ac638fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2babe78d53d5a6fba8c79319486791b85ac638fa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/13b3b6e7aa65cf7c4cb3e053029bdf70288f83da"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 35,
      "deletions": 0
    },
    "files": [
      {
        "sha": "93931148c938ba585ee4c65456b9557626e66de0",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
        "patch": "@@ -6,6 +6,7 @@\n import os\n import re\n import argparse\n+import fileinput\n from shutil import copyfile\n \n SOURCE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'src'))\n@@ -57,6 +58,38 @@ def set_common_properties(toolset):\n     with open(os.path.join(SOURCE_DIR, '../build_msvc/common.init.vcxproj'), 'w', encoding='utf-8',newline='\\n') as wfile:\n         wfile.write(s)\n \n+def parse_config_into_btc_config():\n+    def find_between( s, first, last ):\n+        try:\n+            start = s.index( first ) + len( first )\n+            end = s.index( last, start )\n+            return s[start:end]\n+        except ValueError:\n+            return \"\"\n+\n+    config_info = []\n+    with open(os.path.join(SOURCE_DIR,'../configure.ac'), encoding=\"utf8\") as f:\n+        for line in f:\n+            if line.startswith(\"define\"):\n+                config_info.append(find_between(line, \"(_\", \")\"))\n+\n+    config_info = [c for c in config_info if not c.startswith(\"COPYRIGHT_HOLDERS\")]\n+\n+    config_dict = dict(item.split(\", \") for item in config_info)\n+    config_dict[\"PACKAGE_VERSION\"] = f\"\\\"{config_dict['CLIENT_VERSION_MAJOR']}.{config_dict['CLIENT_VERSION_MINOR']}.{config_dict['CLIENT_VERSION_BUILD']}\\\"\"\n+    version = config_dict[\"PACKAGE_VERSION\"].strip('\"')\n+    config_dict[\"PACKAGE_STRING\"] = f\"\\\"Bitcoin Core {version}\\\"\"\n+\n+    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h', ), inplace=True, encoding=\"utf8\"):\n+        header = \"\"\n+        if line.startswith(\"#define\"):\n+            header = line.split(\" \")[1]\n+        if header in config_dict:\n+            print(f\"#define {header} {config_dict[header]}\\n\", end='')\n+        else:\n+            print(line, end='')\n+\n+\n def main():\n     parser = argparse.ArgumentParser(description='Bitcoin-core msbuild configuration initialiser.')\n     parser.add_argument('-toolset', nargs='?',help='Optionally sets the msbuild platform toolset, e.g. v142 for Visual Studio 2019.'\n@@ -79,6 +112,8 @@ def main():\n             with open(vcxproj_filename, 'w', encoding='utf-8') as vcxproj_file:\n                 vcxproj_file.write(vcxproj_in_file.read().replace(\n                     '@SOURCE_FILES@\\n', content))\n+                    \n+    parse_config_into_btc_config()\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h'), os.path.join(SOURCE_DIR, 'config/bitcoin-config.h'))\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/libsecp256k1_config.h'), os.path.join(SOURCE_DIR, 'secp256k1/src/libsecp256k1-config.h'))\n "
      }
    ]
  },
  {
    "sha": "f9b2dff79db30c35ec24776118e4020649ef7daf",
    "node_id": "C_kwDOABII59oAKGY5YjJkZmY3OWRiMzBjMzVlYzI0Nzc2MTE4ZTQwMjA2NDllZjdkYWY",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-24T20:14:39Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[move-only] Move CAddrMan function definitions to cpp\n\nIn preparation for introducing the pimpl pattern to addrman, move all function\nbodies out of the header file.\n\nReview hint: use git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "d0bf46cd9a18e58394607a3987cf1e7154333509",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0bf46cd9a18e58394607a3987cf1e7154333509"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9b2dff79db30c35ec24776118e4020649ef7daf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9b2dff79db30c35ec24776118e4020649ef7daf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9b2dff79db30c35ec24776118e4020649ef7daf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9b2dff79db30c35ec24776118e4020649ef7daf/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/84d7011ce7fdf5b8a68774ea8d8b5a73981d2cf3"
      }
    ],
    "stats": {
      "total": 198,
      "additions": 111,
      "deletions": 87
    },
    "files": [
      {
        "sha": "0fa8edd3164d93be24ea253bce0cbb08946d6a54",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9b2dff79db30c35ec24776118e4020649ef7daf/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9b2dff79db30c35ec24776118e4020649ef7daf/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=f9b2dff79db30c35ec24776118e4020649ef7daf",
        "patch": "@@ -119,6 +119,11 @@ CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consiste\n     }\n }\n \n+CAddrMan::~CAddrMan()\n+{\n+    nKey.SetNull();\n+}\n+\n template <typename Stream>\n void CAddrMan::Serialize(Stream& s_) const\n {\n@@ -1017,3 +1022,97 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n \n     return mapInfo[id_old];\n }\n+\n+size_t CAddrMan::size() const\n+{\n+    LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n+    return vRandom.size();\n+}\n+\n+bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    LOCK(cs);\n+    int nAdd = 0;\n+    Check();\n+    for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+        nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n+    Check();\n+    if (nAdd) {\n+        LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+    }\n+    return nAdd > 0;\n+}\n+\n+void CAddrMan::Good(const CService &addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Good_(addr, /* test_before_evict */ true, nTime);\n+    Check();\n+}\n+\n+void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Attempt_(addr, fCountFailure, nTime);\n+    Check();\n+}\n+\n+\n+void CAddrMan::ResolveCollisions()\n+{\n+    LOCK(cs);\n+    Check();\n+    ResolveCollisions_();\n+    Check();\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision()\n+{\n+    LOCK(cs);\n+    Check();\n+    const CAddrInfo ret = SelectTriedCollision_();\n+    Check();\n+    return ret;\n+}\n+\n+CAddrInfo CAddrMan::Select(bool newOnly) const\n+{\n+    LOCK(cs);\n+    Check();\n+    const CAddrInfo addrRet = Select_(newOnly);\n+    Check();\n+    return addrRet;\n+}\n+\n+std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    LOCK(cs);\n+    Check();\n+    std::vector<CAddress> vAddr;\n+    GetAddr_(vAddr, max_addresses, max_pct, network);\n+    Check();\n+    return vAddr;\n+}\n+\n+void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Connected_(addr, nTime);\n+    Check();\n+}\n+\n+void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+{\n+    LOCK(cs);\n+    Check();\n+    SetServices_(addr, nServices);\n+    Check();\n+}\n+\n+const std::vector<bool>& CAddrMan::GetAsmap() const\n+{\n+    return m_asmap;\n+}"
      },
      {
        "sha": "bc2f934caa4a3d573f475c3761929ec91600539e",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 12,
        "deletions": 87,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9b2dff79db30c35ec24776118e4020649ef7daf/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9b2dff79db30c35ec24776118e4020649ef7daf/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=f9b2dff79db30c35ec24776118e4020649ef7daf",
        "patch": "@@ -150,88 +150,33 @@ class CAddrMan\n \n     explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n-    ~CAddrMan()\n-    {\n-        nKey.SetNull();\n-    }\n+    ~CAddrMan();\n \n     //! Return the number of (unique) addresses in all tables.\n-    size_t size() const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n-        return vRandom.size();\n-    }\n+    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Add addresses to addrman's new table.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        int nAdd = 0;\n-        Check();\n-        for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n-            nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n-        Check();\n-        if (nAdd) {\n-            LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n-        }\n-        return nAdd > 0;\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Mark an entry as accessible.\n     void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Good_(addr, /* test_before_evict */ true, nTime);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Mark an entry as connection attempted to.\n     void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Attempt_(addr, fCountFailure, nTime);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        ResolveCollisions_();\n-        Check();\n-    }\n+    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo ret = SelectTriedCollision_();\n-        Check();\n-        return ret;\n-    }\n+    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     /**\n      * Choose an address to connect to.\n      */\n-    CAddrInfo Select(bool newOnly = false) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo addrRet = Select_(newOnly);\n-        Check();\n-        return addrRet;\n-    }\n+    CAddrInfo Select(bool newOnly = false) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n@@ -241,36 +186,16 @@ class CAddrMan\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n      */\n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        std::vector<CAddress> vAddr;\n-        GetAddr_(vAddr, max_addresses, max_pct, network);\n-        Check();\n-        return vAddr;\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Outer function for Connected_()\n     void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Connected_(addr, nTime);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     void SetServices(const CService &addr, ServiceFlags nServices)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        SetServices_(addr, nServices);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n+    const std::vector<bool>& GetAsmap() const;\n \n private:\n     //! A mutex to protect the inner data structures."
      }
    ]
  },
  {
    "sha": "f3749ae6256eb7d5478068cfecd7c434d4c71875",
    "node_id": "C_kwDOABII59oAKGYzNzQ5YWU2MjU2ZWI3ZDU0NzgwNjhjZmVjZDdjNDM0ZDRjNzE4NzU",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T19:46:43Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[move-only] Match ordering of CAddrMan declarations and definitions\n\nAlso move `Check` and `ForceCheckAddrman` to be after the `FunctionName_` functions.\n\nReview hint: use git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "f01e242f97f7e8c4836f2ada26a157b240ad49ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f01e242f97f7e8c4836f2ada26a157b240ad49ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3749ae6256eb7d5478068cfecd7c434d4c71875",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3749ae6256eb7d5478068cfecd7c434d4c71875",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3749ae6256eb7d5478068cfecd7c434d4c71875",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3749ae6256eb7d5478068cfecd7c434d4c71875/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9b2dff79db30c35ec24776118e4020649ef7daf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9b2dff79db30c35ec24776118e4020649ef7daf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9b2dff79db30c35ec24776118e4020649ef7daf"
      }
    ],
    "stats": {
      "total": 245,
      "additions": 123,
      "deletions": 122
    },
    "files": [
      {
        "sha": "99c4f00d6d2322d2483b55c2181b1eb2b981cc6e",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 102,
        "changes": 205,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3749ae6256eb7d5478068cfecd7c434d4c71875/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3749ae6256eb7d5478068cfecd7c434d4c71875/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=f3749ae6256eb7d5478068cfecd7c434d4c71875",
        "patch": "@@ -753,108 +753,6 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n     }\n }\n \n-void CAddrMan::Check() const\n-{\n-    AssertLockHeld(cs);\n-\n-    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n-    if (m_consistency_check_ratio == 0) return;\n-    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n-\n-    const int err{ForceCheckAddrman()};\n-    if (err) {\n-        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n-        assert(false);\n-    }\n-}\n-\n-int CAddrMan::ForceCheckAddrman() const\n-{\n-    AssertLockHeld(cs);\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n-\n-    std::unordered_set<int> setTried;\n-    std::unordered_map<int, int> mapNew;\n-\n-    if (vRandom.size() != (size_t)(nTried + nNew))\n-        return -7;\n-\n-    for (const auto& entry : mapInfo) {\n-        int n = entry.first;\n-        const CAddrInfo& info = entry.second;\n-        if (info.fInTried) {\n-            if (!info.nLastSuccess)\n-                return -1;\n-            if (info.nRefCount)\n-                return -2;\n-            setTried.insert(n);\n-        } else {\n-            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n-                return -3;\n-            if (!info.nRefCount)\n-                return -4;\n-            mapNew[n] = info.nRefCount;\n-        }\n-        const auto it{mapAddr.find(info)};\n-        if (it == mapAddr.end() || it->second != n) {\n-            return -5;\n-        }\n-        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n-            return -14;\n-        if (info.nLastTry < 0)\n-            return -6;\n-        if (info.nLastSuccess < 0)\n-            return -8;\n-    }\n-\n-    if (setTried.size() != (size_t)nTried)\n-        return -9;\n-    if (mapNew.size() != (size_t)nNew)\n-        return -10;\n-\n-    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvTried[n][i] != -1) {\n-                if (!setTried.count(vvTried[n][i]))\n-                    return -11;\n-                const auto it{mapInfo.find(vvTried[n][i])};\n-                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n-                    return -17;\n-                }\n-                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n-                    return -18;\n-                }\n-                setTried.erase(vvTried[n][i]);\n-            }\n-        }\n-    }\n-\n-    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvNew[n][i] != -1) {\n-                if (!mapNew.count(vvNew[n][i]))\n-                    return -12;\n-                const auto it{mapInfo.find(vvNew[n][i])};\n-                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n-                    return -19;\n-                }\n-                if (--mapNew[vvNew[n][i]] == 0)\n-                    mapNew.erase(vvNew[n][i]);\n-            }\n-        }\n-    }\n-\n-    if (setTried.size())\n-        return -13;\n-    if (mapNew.size())\n-        return -15;\n-    if (nKey.IsNull())\n-        return -16;\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n-    return 0;\n-}\n \n void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n@@ -1023,6 +921,109 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     return mapInfo[id_old];\n }\n \n+void CAddrMan::Check() const\n+{\n+    AssertLockHeld(cs);\n+\n+    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n+    if (m_consistency_check_ratio == 0) return;\n+    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n+\n+    const int err{ForceCheckAddrman()};\n+    if (err) {\n+        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+        assert(false);\n+    }\n+}\n+\n+int CAddrMan::ForceCheckAddrman() const\n+{\n+    AssertLockHeld(cs);\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n+\n+    std::unordered_set<int> setTried;\n+    std::unordered_map<int, int> mapNew;\n+\n+    if (vRandom.size() != (size_t)(nTried + nNew))\n+        return -7;\n+\n+    for (const auto& entry : mapInfo) {\n+        int n = entry.first;\n+        const CAddrInfo& info = entry.second;\n+        if (info.fInTried) {\n+            if (!info.nLastSuccess)\n+                return -1;\n+            if (info.nRefCount)\n+                return -2;\n+            setTried.insert(n);\n+        } else {\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                return -3;\n+            if (!info.nRefCount)\n+                return -4;\n+            mapNew[n] = info.nRefCount;\n+        }\n+        const auto it{mapAddr.find(info)};\n+        if (it == mapAddr.end() || it->second != n) {\n+            return -5;\n+        }\n+        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n+            return -14;\n+        if (info.nLastTry < 0)\n+            return -6;\n+        if (info.nLastSuccess < 0)\n+            return -8;\n+    }\n+\n+    if (setTried.size() != (size_t)nTried)\n+        return -9;\n+    if (mapNew.size() != (size_t)nNew)\n+        return -10;\n+\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvTried[n][i] != -1) {\n+                if (!setTried.count(vvTried[n][i]))\n+                    return -11;\n+                const auto it{mapInfo.find(vvTried[n][i])};\n+                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n+                    return -17;\n+                }\n+                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n+                    return -18;\n+                }\n+                setTried.erase(vvTried[n][i]);\n+            }\n+        }\n+    }\n+\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[n][i] != -1) {\n+                if (!mapNew.count(vvNew[n][i]))\n+                    return -12;\n+                const auto it{mapInfo.find(vvNew[n][i])};\n+                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n+                    return -19;\n+                }\n+                if (--mapNew[vvNew[n][i]] == 0)\n+                    mapNew.erase(vvNew[n][i]);\n+            }\n+        }\n+    }\n+\n+    if (setTried.size())\n+        return -13;\n+    if (mapNew.size())\n+        return -15;\n+    if (nKey.IsNull())\n+        return -16;\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n+    return 0;\n+}\n+\n size_t CAddrMan::size() const\n {\n     LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead"
      },
      {
        "sha": "d3d764c9c64e77009ebe75ec19dd6abdd402ff68",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3749ae6256eb7d5478068cfecd7c434d4c71875/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3749ae6256eb7d5478068cfecd7c434d4c71875/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=f3749ae6256eb7d5478068cfecd7c434d4c71875",
        "patch": "@@ -142,16 +142,16 @@ static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n class CAddrMan\n {\n public:\n+    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n+\n+    ~CAddrMan();\n+\n     template <typename Stream>\n     void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     template <typename Stream>\n     void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n-\n-    ~CAddrMan();\n-\n     //! Return the number of (unique) addresses in all tables.\n     size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n@@ -289,15 +289,15 @@ class CAddrMan\n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     //! Delete an entry. It must not be in tried, and have refcount 0.\n     void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n     void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n@@ -310,19 +310,6 @@ class CAddrMan\n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n-    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Perform consistency check, regardless of m_consistency_check_ratio.\n-    //! @returns an error code or zero.\n-    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n      *\n@@ -349,6 +336,19 @@ class CAddrMan\n     //! Update an entry's service bits.\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n+    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Perform consistency check, regardless of m_consistency_check_ratio.\n+    //! @returns an error code or zero.\n+    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n     friend class CAddrManTest;\n     friend class CAddrManDeterministic;\n };"
      }
    ]
  },
  {
    "sha": "b351ad731232f344bfb5cb7293bec9175d9993eb",
    "node_id": "C_kwDOABII59oAKGIzNTFhZDczMTIzMmYzNDRiZmI1Y2I3MjkzYmVjOTE3NWQ5OTkzZWI",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-01T18:21:29Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[addrman] Introduce CAddrMan::Impl to encapsulate addrman implementation.\n\nIntroduce the pimpl pattern for CAddrMan to separate the implementation details\nfrom the externally used object representation. This reduces compile-time\ndependencies and conceptually clarifies AddrMan's interface from the\nimplementation specifics.\n\nSince the unit & fuzz tests currently rely on accessing CAddrMan internals, this\ncommit introduces addrman_impl.h, which is exclusively imported by addrman.cpp\nand test files.\n\nReview hint: git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "a3c1dab4f22bff459b8d911ca9bea63cbe028e81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a3c1dab4f22bff459b8d911ca9bea63cbe028e81"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b351ad731232f344bfb5cb7293bec9175d9993eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b351ad731232f344bfb5cb7293bec9175d9993eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b351ad731232f344bfb5cb7293bec9175d9993eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b351ad731232f344bfb5cb7293bec9175d9993eb/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3749ae6256eb7d5478068cfecd7c434d4c71875",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3749ae6256eb7d5478068cfecd7c434d4c71875",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3749ae6256eb7d5478068cfecd7c434d4c71875"
      }
    ],
    "stats": {
      "total": 616,
      "additions": 371,
      "deletions": 245
    },
    "files": [
      {
        "sha": "12fdc9ad7588514e2920812359b5b084860bc91e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b351ad731232f344bfb5cb7293bec9175d9993eb/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b351ad731232f344bfb5cb7293bec9175d9993eb/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b351ad731232f344bfb5cb7293bec9175d9993eb",
        "patch": "@@ -117,6 +117,7 @@ endif\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addrman.h \\\n+  addrman_impl.h \\\n   attributes.h \\\n   banman.h \\\n   base58.h \\"
      },
      {
        "sha": "2fc6ca29a12e72ab649aff88114cd6c3637f99f4",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 114,
        "deletions": 43,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b351ad731232f344bfb5cb7293bec9175d9993eb/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b351ad731232f344bfb5cb7293bec9175d9993eb/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=b351ad731232f344bfb5cb7293bec9175d9993eb",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <addrman.h>\n+#include <addrman_impl.h>\n \n #include <clientversion.h>\n #include <hash.h>\n@@ -101,7 +102,7 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrManImpl::AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio)\n     : insecure_rand{deterministic}\n     , nKey{deterministic ? uint256{1} : insecure_rand.rand256()}\n     , m_consistency_check_ratio{consistency_check_ratio}\n@@ -119,13 +120,13 @@ CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consiste\n     }\n }\n \n-CAddrMan::~CAddrMan()\n+AddrManImpl::~AddrManImpl()\n {\n     nKey.SetNull();\n }\n \n template <typename Stream>\n-void CAddrMan::Serialize(Stream& s_) const\n+void AddrManImpl::Serialize(Stream& s_) const\n {\n     LOCK(cs);\n \n@@ -228,7 +229,7 @@ void CAddrMan::Serialize(Stream& s_) const\n }\n \n template <typename Stream>\n-void CAddrMan::Unserialize(Stream& s_)\n+void AddrManImpl::Unserialize(Stream& s_)\n {\n     LOCK(cs);\n \n@@ -399,16 +400,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     }\n }\n \n-// explicit instantiation\n-template void CAddrMan::Serialize(CHashWriter& s) const;\n-template void CAddrMan::Serialize(CAutoFile& s) const;\n-template void CAddrMan::Serialize(CDataStream& s) const;\n-template void CAddrMan::Unserialize(CAutoFile& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n-template void CAddrMan::Unserialize(CDataStream& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n-\n-CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n+CAddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -423,7 +415,7 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n     return nullptr;\n }\n \n-CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n+CAddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -437,7 +429,7 @@ CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, in\n     return &mapInfo[nId];\n }\n \n-void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n+void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n {\n     AssertLockHeld(cs);\n \n@@ -461,7 +453,7 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n     vRandom[nRndPos2] = nId1;\n }\n \n-void CAddrMan::Delete(int nId)\n+void AddrManImpl::Delete(int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -477,7 +469,7 @@ void CAddrMan::Delete(int nId)\n     nNew--;\n }\n \n-void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n+void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n {\n     AssertLockHeld(cs);\n \n@@ -494,7 +486,7 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n     }\n }\n \n-void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n+void AddrManImpl::MakeTried(CAddrInfo& info, int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -547,7 +539,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n+void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n@@ -603,7 +595,7 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n     }\n }\n \n-bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     AssertLockHeld(cs);\n \n@@ -678,7 +670,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     return fNew;\n }\n \n-void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n@@ -702,7 +694,7 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n     }\n }\n \n-CAddrInfo CAddrMan::Select_(bool newOnly) const\n+CAddrInfo AddrManImpl::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n@@ -753,8 +745,7 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n     }\n }\n \n-\n-void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -789,7 +780,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size\n     }\n }\n \n-void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n+void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n@@ -811,7 +802,7 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n         info.nTime = nTime;\n }\n \n-void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)\n {\n     AssertLockHeld(cs);\n \n@@ -831,7 +822,7 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n     info.nServices = nServices;\n }\n \n-void CAddrMan::ResolveCollisions_()\n+void AddrManImpl::ResolveCollisions_()\n {\n     AssertLockHeld(cs);\n \n@@ -892,7 +883,7 @@ void CAddrMan::ResolveCollisions_()\n     }\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision_()\n+CAddrInfo AddrManImpl::SelectTriedCollision_()\n {\n     AssertLockHeld(cs);\n \n@@ -921,7 +912,7 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     return mapInfo[id_old];\n }\n \n-void CAddrMan::Check() const\n+void AddrManImpl::Check() const\n {\n     AssertLockHeld(cs);\n \n@@ -936,7 +927,7 @@ void CAddrMan::Check() const\n     }\n }\n \n-int CAddrMan::ForceCheckAddrman() const\n+int AddrManImpl::ForceCheckAddrman() const\n {\n     AssertLockHeld(cs);\n \n@@ -1024,13 +1015,13 @@ int CAddrMan::ForceCheckAddrman() const\n     return 0;\n }\n \n-size_t CAddrMan::size() const\n+size_t AddrManImpl::size() const\n {\n     LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n     return vRandom.size();\n }\n \n-bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     LOCK(cs);\n     int nAdd = 0;\n@@ -1044,32 +1035,31 @@ bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, i\n     return nAdd > 0;\n }\n \n-void CAddrMan::Good(const CService &addr, int64_t nTime)\n+void AddrManImpl::Good(const CService &addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Good_(addr, /* test_before_evict */ true, nTime);\n     Check();\n }\n \n-void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Attempt_(addr, fCountFailure, nTime);\n     Check();\n }\n \n-\n-void CAddrMan::ResolveCollisions()\n+void AddrManImpl::ResolveCollisions()\n {\n     LOCK(cs);\n     Check();\n     ResolveCollisions_();\n     Check();\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision()\n+CAddrInfo AddrManImpl::SelectTriedCollision()\n {\n     LOCK(cs);\n     Check();\n@@ -1078,7 +1068,7 @@ CAddrInfo CAddrMan::SelectTriedCollision()\n     return ret;\n }\n \n-CAddrInfo CAddrMan::Select(bool newOnly) const\n+CAddrInfo AddrManImpl::Select(bool newOnly) const\n {\n     LOCK(cs);\n     Check();\n@@ -1087,7 +1077,7 @@ CAddrInfo CAddrMan::Select(bool newOnly) const\n     return addrRet;\n }\n \n-std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     LOCK(cs);\n     Check();\n@@ -1097,23 +1087,104 @@ std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, st\n     return vAddr;\n }\n \n-void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+void AddrManImpl::Connected(const CService &addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Connected_(addr, nTime);\n     Check();\n }\n \n-void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices(const CService &addr, ServiceFlags nServices)\n {\n     LOCK(cs);\n     Check();\n     SetServices_(addr, nServices);\n     Check();\n }\n \n-const std::vector<bool>& CAddrMan::GetAsmap() const\n+const std::vector<bool>& AddrManImpl::GetAsmap() const\n {\n     return m_asmap;\n }\n+\n+CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+    : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n+\n+CAddrMan::~CAddrMan() = default;\n+\n+template <typename Stream>\n+void CAddrMan::Serialize(Stream& s_) const\n+{\n+    m_impl->Serialize<Stream>(s_);\n+}\n+\n+template <typename Stream>\n+void CAddrMan::Unserialize(Stream& s_)\n+{\n+    m_impl->Unserialize<Stream>(s_);\n+}\n+\n+// explicit instantiation\n+template void CAddrMan::Serialize(CHashWriter& s) const;\n+template void CAddrMan::Serialize(CAutoFile& s) const;\n+template void CAddrMan::Serialize(CDataStream& s) const;\n+template void CAddrMan::Unserialize(CAutoFile& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void CAddrMan::Unserialize(CDataStream& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n+size_t CAddrMan::size() const\n+{\n+    return m_impl->size();\n+}\n+\n+bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    return m_impl->Add(vAddr, source, nTimePenalty);\n+}\n+\n+void CAddrMan::Good(const CService &addr, int64_t nTime)\n+{\n+    m_impl->Good(addr, nTime);\n+}\n+\n+void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+{\n+    m_impl->Attempt(addr, fCountFailure, nTime);\n+}\n+\n+void CAddrMan::ResolveCollisions()\n+{\n+    m_impl->ResolveCollisions();\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision()\n+{\n+    return m_impl->SelectTriedCollision();\n+}\n+\n+CAddrInfo CAddrMan::Select(bool newOnly) const\n+{\n+    return m_impl->Select(newOnly);\n+}\n+\n+std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    return m_impl->GetAddr(max_addresses, max_pct, network);\n+}\n+\n+void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+{\n+    m_impl->Connected(addr, nTime);\n+}\n+\n+void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+{\n+    m_impl->SetServices(addr, nServices);\n+}\n+\n+const std::vector<bool>& CAddrMan::GetAsmap() const\n+{\n+    return m_impl->GetAsmap();\n+}"
      },
      {
        "sha": "2135295b89248600c5e30f2cbc8669567e83a43a",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 17,
        "deletions": 171,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b351ad731232f344bfb5cb7293bec9175d9993eb/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b351ad731232f344bfb5cb7293bec9175d9993eb/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=b351ad731232f344bfb5cb7293bec9175d9993eb",
        "patch": "@@ -19,6 +19,8 @@\n #include <unordered_map>\n #include <vector>\n \n+class AddrManImpl;\n+\n /** Default for -checkaddrman */\n static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n \n@@ -53,7 +55,7 @@ class CAddrInfo : public CAddress\n     //! position in vRandom\n     mutable int nRandomPos{-1};\n \n-    friend class CAddrMan;\n+    friend class AddrManImpl;\n     friend class CAddrManDeterministic;\n \n public:\n@@ -141,42 +143,41 @@ static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n  */\n class CAddrMan\n {\n+    const std::unique_ptr<AddrManImpl> m_impl;\n+\n public:\n     explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n     ~CAddrMan();\n \n     template <typename Stream>\n-    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Serialize(Stream& s_) const;\n \n     template <typename Stream>\n-    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Unserialize(Stream& s_);\n \n     //! Return the number of (unique) addresses in all tables.\n-    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    size_t size() const;\n \n     //! Add addresses to addrman's new table.\n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n     //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Good(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void ResolveCollisions();\n \n     //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    CAddrInfo SelectTriedCollision();\n \n     /**\n      * Choose an address to connect to.\n      */\n-    CAddrInfo Select(bool newOnly = false) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    CAddrInfo Select(bool newOnly = false) const;\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n@@ -185,170 +186,15 @@ class CAddrMan\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n      */\n-    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const;\n \n     //! Outer function for Connected_()\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n-    void SetServices(const CService &addr, ServiceFlags nServices)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n \n     const std::vector<bool>& GetAsmap() const;\n \n-private:\n-    //! A mutex to protect the inner data structures.\n-    mutable Mutex cs;\n-\n-    //! Source of random numbers for randomization in inner loops\n-    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n-\n-    //! secret key to randomize bucket select with\n-    uint256 nKey;\n-\n-    //! Serialization versions.\n-    enum Format : uint8_t {\n-        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n-        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n-        V2_ASMAP = 2,         //!< for files including asmap version\n-        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n-    };\n-\n-    //! The maximum format this software knows it can unserialize. Also, we always serialize\n-    //! in this format.\n-    //! The format (first byte in the serialized stream) can be higher than this and\n-    //! still this software may be able to unserialize the file - if the second byte\n-    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n-    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n-\n-    //! The initial value of a field that is incremented every time an incompatible format\n-    //! change is made (such that old software versions would not be able to parse and\n-    //! understand the new file format). This is 32 because we overtook the \"key size\"\n-    //! field which was 32 historically.\n-    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n-    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n-\n-    //! last used nId\n-    int nIdCount GUARDED_BY(cs){0};\n-\n-    //! table with information about all nIds\n-    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n-\n-    //! find an nId based on its network address\n-    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n-\n-    //! randomly-ordered vector of all nIds\n-    //! This is mutable because it is unobservable outside the class, so any\n-    //! changes to it (even in const methods) are also unobservable.\n-    mutable std::vector<int> vRandom GUARDED_BY(cs);\n-\n-    // number of \"tried\" entries\n-    int nTried GUARDED_BY(cs){0};\n-\n-    //! list of \"tried\" buckets\n-    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! number of (unique) \"new\" entries\n-    int nNew GUARDED_BY(cs){0};\n-\n-    //! list of \"new\" buckets\n-    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n-    int64_t nLastGood GUARDED_BY(cs){1};\n-\n-    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n-    std::set<int> m_tried_collisions;\n-\n-    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n-    const int32_t m_consistency_check_ratio;\n-\n-    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n-    // Should be always empty if no file was provided.\n-    // This mapping is then used for bucketing nodes in Addrman.\n-    //\n-    // If asmap is provided, nodes will be bucketed by\n-    // AS they belong to, in order to make impossible for a node\n-    // to connect to several nodes hosted in a single AS.\n-    // This is done in response to Erebus attack, but also to generally\n-    // diversify the connections every node creates,\n-    // especially useful when a large fraction of nodes\n-    // operate under a couple of cloud providers.\n-    //\n-    // If a new asmap was provided, the existing records\n-    // would be re-bucketed accordingly.\n-    const std::vector<bool> m_asmap;\n-\n-    //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Swap two elements in vRandom.\n-    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Delete an entry. It must not be in tried, and have refcount 0.\n-    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n-    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Add an entry to the \"new\" table.\n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry as attempted to connect.\n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    /**\n-     * Return all or many randomly selected addresses, optionally by network.\n-     *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n-     */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    /** We have successfully connected to this peer. Calling this function\n-     *  updates the CAddress's nTime, which is used in our IsTerrible()\n-     *  decisions and gossiped to peers. Callers should be careful that updating\n-     *  this information doesn't leak topology information to network spies.\n-     *\n-     *  net_processing calls this function when it *disconnects* from a peer to\n-     *  not leak information about currently connected peers.\n-     *\n-     * @param[in]   addr     The address of the peer we were connected to\n-     * @param[in]   nTime    The time that we were last connected to this peer\n-     */\n-    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Update an entry's service bits.\n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n-    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Perform consistency check, regardless of m_consistency_check_ratio.\n-    //! @returns an error code or zero.\n-    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     friend class CAddrManTest;\n     friend class CAddrManDeterministic;\n };"
      },
      {
        "sha": "ee4b55e5c4c75bdbdad25670ac622ea8b75a4815",
        "filename": "src/addrman_impl.h",
        "status": "added",
        "additions": 206,
        "deletions": 0,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b351ad731232f344bfb5cb7293bec9175d9993eb/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b351ad731232f344bfb5cb7293bec9175d9993eb/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=b351ad731232f344bfb5cb7293bec9175d9993eb",
        "patch": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRMAN_IMPL_H\n+#define BITCOIN_ADDRMAN_IMPL_H\n+\n+class AddrManImpl\n+{\n+public:\n+    AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio);\n+\n+    ~AddrManImpl();\n+\n+    template <typename Stream>\n+    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    template <typename Stream>\n+    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Good(const CService &addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    CAddrInfo Select(bool newOnly) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Connected(const CService &addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void SetServices(const CService &addr, ServiceFlags nServices)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    const std::vector<bool>& GetAsmap() const;\n+\n+    friend class CAddrManTest;\n+    friend class CAddrManDeterministic;\n+\n+private:\n+    //! A mutex to protect the inner data structures.\n+    mutable Mutex cs;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs){0};\n+\n+    //! table with information about all nIds\n+    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    //! This is mutable because it is unobservable outside the class, so any\n+    //! changes to it (even in const methods) are also unobservable.\n+    mutable std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs){0};\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs){0};\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n+    int64_t nLastGood GUARDED_BY(cs){1};\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n+    const int32_t m_consistency_check_ratio;\n+\n+    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n+    // Should be always empty if no file was provided.\n+    // This mapping is then used for bucketing nodes in Addrman.\n+    //\n+    // If asmap is provided, nodes will be bucketed by\n+    // AS they belong to, in order to make impossible for a node\n+    // to connect to several nodes hosted in a single AS.\n+    // This is done in response to Erebus attack, but also to generally\n+    // diversify the connections every node creates,\n+    // especially useful when a large fraction of nodes\n+    // operate under a couple of cloud providers.\n+    //\n+    // If a new asmap was provided, the existing records\n+    // would be re-bucketed accordingly.\n+    const std::vector<bool> m_asmap;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n+    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Perform consistency check, regardless of m_consistency_check_ratio.\n+    //! @returns an error code or zero.\n+    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+};\n+\n+#endif // BITCOIN_ADDRMAN_IMPL_H"
      },
      {
        "sha": "41c298e036449896047441bf4df7d53860da6f00",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b351ad731232f344bfb5cb7293bec9175d9993eb/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b351ad731232f344bfb5cb7293bec9175d9993eb/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=b351ad731232f344bfb5cb7293bec9175d9993eb",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <clientversion.h>\n #include <hash.h>\n@@ -90,30 +91,30 @@ class CAddrManTest : public CAddrMan\n \n     CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Find(addr, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Find(addr, pnId);\n     }\n \n     CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Create(addr, addrSource, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Create(addr, addrSource, pnId);\n     }\n \n     void Delete(int nId)\n     {\n-        LOCK(cs);\n-        CAddrMan::Delete(nId);\n+        LOCK(m_impl->cs);\n+        m_impl->Delete(nId);\n     }\n \n     // Used to test deserialization\n     std::pair<int, int> GetBucketAndEntry(const CAddress& addr)\n     {\n-        LOCK(cs);\n-        int nId = mapAddr[addr];\n+        LOCK(m_impl->cs);\n+        int nId = m_impl->mapAddr[addr];\n         for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n             for (int entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n-                if (nId == vvNew[bucket][entry]) {\n+                if (nId == m_impl->vvNew[bucket][entry]) {\n                     return std::pair<int, int>(bucket, entry);\n                 }\n             }"
      },
      {
        "sha": "6625b69b142125eb9b8e4e50d0766f8217ecea66",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 22,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b351ad731232f344bfb5cb7293bec9175d9993eb/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b351ad731232f344bfb5cb7293bec9175d9993eb/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=b351ad731232f344bfb5cb7293bec9175d9993eb",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <merkleblock.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n@@ -43,13 +44,13 @@ class CAddrManDeterministic : public CAddrMan\n         : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n-        WITH_LOCK(cs, insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n+        WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n     }\n \n     /**\n      * Generate a random address. Always returns a valid address.\n      */\n-    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(cs)\n+    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs)\n     {\n         CNetAddr addr;\n         if (m_fuzzed_data_provider.remaining_bytes() > 1 && m_fuzzed_data_provider.ConsumeBool()) {\n@@ -61,15 +62,15 @@ class CAddrManDeterministic : public CAddrMan\n                                                                    {4, ADDR_TORV3_SIZE},\n                                                                    {5, ADDR_I2P_SIZE},\n                                                                    {6, ADDR_CJDNS_SIZE}};\n-            uint8_t net = insecure_rand.randrange(5) + 1; // [1..5]\n+            uint8_t net = m_impl->insecure_rand.randrange(5) + 1; // [1..5]\n             if (net == 3) {\n                 net = 6;\n             }\n \n             CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n \n             s << net;\n-            s << insecure_rand.randbytes(net_len_map.at(net));\n+            s << m_impl->insecure_rand.randbytes(net_len_map.at(net));\n \n             s >> addr;\n         }\n@@ -89,7 +90,7 @@ class CAddrManDeterministic : public CAddrMan\n      */\n     void Fill()\n     {\n-        LOCK(cs);\n+        LOCK(m_impl->cs);\n \n         // Add some of the addresses directly to the \"tried\" table.\n \n@@ -102,20 +103,20 @@ class CAddrManDeterministic : public CAddrMan\n         // the latter is exhausted it just returns 0.\n         for (size_t i = 0; i < num_sources; ++i) {\n             const auto source = RandAddr();\n-            const size_t num_addresses = insecure_rand.randrange(500) + 1; // [1..500]\n+            const size_t num_addresses = m_impl->insecure_rand.randrange(500) + 1; // [1..500]\n \n             for (size_t j = 0; j < num_addresses; ++j) {\n                 const auto addr = CAddress{CService{RandAddr(), 8333}, NODE_NETWORK};\n-                const auto time_penalty = insecure_rand.randrange(100000001);\n-                Add_(addr, source, time_penalty);\n+                const auto time_penalty = m_impl->insecure_rand.randrange(100000001);\n+                m_impl->Add_(addr, source, time_penalty);\n \n-                if (n > 0 && mapInfo.size() % n == 0) {\n-                    Good_(addr, false, GetTime());\n+                if (n > 0 && m_impl->mapInfo.size() % n == 0) {\n+                    m_impl->Good_(addr, false, GetTime());\n                 }\n \n                 // Add 10% of the addresses from more than one source.\n-                if (insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n-                    Add_(addr, prev_source, time_penalty);\n+                if (m_impl->insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n+                    m_impl->Add_({addr}, prev_source, time_penalty);\n                 }\n             }\n             prev_source = source;\n@@ -131,10 +132,10 @@ class CAddrManDeterministic : public CAddrMan\n      */\n     bool operator==(const CAddrManDeterministic& other)\n     {\n-        LOCK2(cs, other.cs);\n+        LOCK2(m_impl->cs, other.m_impl->cs);\n \n-        if (mapInfo.size() != other.mapInfo.size() || nNew != other.nNew ||\n-            nTried != other.nTried) {\n+        if (m_impl->mapInfo.size() != other.m_impl->mapInfo.size() || m_impl->nNew != other.m_impl->nNew ||\n+            m_impl->nTried != other.m_impl->nTried) {\n             return false;\n         }\n \n@@ -160,38 +161,38 @@ class CAddrManDeterministic : public CAddrMan\n \n         using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n \n-        const size_t num_addresses{mapInfo.size()};\n+        const size_t num_addresses{m_impl->mapInfo.size()};\n \n         Addresses addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : mapInfo) {\n+        for (const auto& [id, addr] : m_impl->mapInfo) {\n             addresses.insert(addr);\n         }\n \n         Addresses other_addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : other.mapInfo) {\n+        for (const auto& [id, addr] : other.m_impl->mapInfo) {\n             other_addresses.insert(addr);\n         }\n \n         if (addresses != other_addresses) {\n             return false;\n         }\n \n-        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(cs, other.cs) {\n+        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs, other.m_impl->cs) {\n             if (id == -1 && other_id == -1) {\n                 return true;\n             }\n             if ((id == -1 && other_id != -1) || (id != -1 && other_id == -1)) {\n                 return false;\n             }\n-            return mapInfo.at(id) == other.mapInfo.at(other_id);\n+            return m_impl->mapInfo.at(id) == other.m_impl->mapInfo.at(other_id);\n         };\n \n         // Check that `vvNew` contains the same addresses as `other.vvNew`. Notice - `vvNew[i][j]`\n         // contains just an id and the address is to be found in `mapInfo.at(id)`. The ids\n         // themselves may differ between `vvNew` and `other.vvNew`.\n         for (size_t i = 0; i < ADDRMAN_NEW_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvNew[i][j], other.vvNew[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvNew[i][j], other.m_impl->vvNew[i][j])) {\n                     return false;\n                 }\n             }\n@@ -200,7 +201,7 @@ class CAddrManDeterministic : public CAddrMan\n         // Same for `vvTried`.\n         for (size_t i = 0; i < ADDRMAN_TRIED_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvTried[i][j], other.vvTried[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvTried[i][j], other.m_impl->vvTried[i][j])) {\n                     return false;\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
    "node_id": "C_kwDOABII59oAKDE0YmM0OGMwNGU1MDE4MmQ2NjQ3MWQ4ZDQ4Zjk0MmUyYTFlYjhiMWQ",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-25T22:40:59Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[net, addrman] Remove external dependencies on CAddrInfo objects\n\nCAddrInfo objects are an implementation detail of how AddrMan manages and adds\nmetadata to different records. Encapsulate this logic by updating Select &\nSelectTriedCollision to return the additional info that the callers need.",
      "tree": {
        "sha": "6892510f383bb67780cc5689d159940fb441d76c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6892510f383bb67780cc5689d159940fb441d76c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b351ad731232f344bfb5cb7293bec9175d9993eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b351ad731232f344bfb5cb7293bec9175d9993eb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b351ad731232f344bfb5cb7293bec9175d9993eb"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 70,
      "deletions": 60
    },
    "files": [
      {
        "sha": "324bab7292cdba466c1ec79d42f95ac697a4f63c",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 21,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "patch": "@@ -694,15 +694,13 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTi\n     }\n }\n \n-CAddrInfo AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n-    if (vRandom.empty())\n-        return CAddrInfo();\n+    if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0)\n-        return CAddrInfo();\n+    if (newOnly && nNew == 0) return {};\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n@@ -720,8 +718,9 @@ CAddrInfo AddrManImpl::Select_(bool newOnly) const\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n             const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n+            }\n             fChanceFactor *= 1.2;\n         }\n     } else {\n@@ -738,8 +737,9 @@ CAddrInfo AddrManImpl::Select_(bool newOnly) const\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n             const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n+            }\n             fChanceFactor *= 1.2;\n         }\n     }\n@@ -883,11 +883,11 @@ void AddrManImpl::ResolveCollisions_()\n     }\n }\n \n-CAddrInfo AddrManImpl::SelectTriedCollision_()\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n {\n     AssertLockHeld(cs);\n \n-    if (m_tried_collisions.size() == 0) return CAddrInfo();\n+    if (m_tried_collisions.size() == 0) return {};\n \n     std::set<int>::iterator it = m_tried_collisions.begin();\n \n@@ -898,7 +898,7 @@ CAddrInfo AddrManImpl::SelectTriedCollision_()\n     // If id_new not found in mapInfo remove it from m_tried_collisions\n     if (mapInfo.count(id_new) != 1) {\n         m_tried_collisions.erase(it);\n-        return CAddrInfo();\n+        return {};\n     }\n \n     const CAddrInfo& newInfo = mapInfo[id_new];\n@@ -907,9 +907,8 @@ CAddrInfo AddrManImpl::SelectTriedCollision_()\n     int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n-    int id_old = vvTried[tried_bucket][tried_bucket_pos];\n-\n-    return mapInfo[id_old];\n+    const CAddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n+    return {info_old, info_old.nLastTry};\n }\n \n void AddrManImpl::Check() const\n@@ -1059,20 +1058,20 @@ void AddrManImpl::ResolveCollisions()\n     Check();\n }\n \n-CAddrInfo AddrManImpl::SelectTriedCollision()\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision()\n {\n     LOCK(cs);\n     Check();\n-    const CAddrInfo ret = SelectTriedCollision_();\n+    const auto ret = SelectTriedCollision_();\n     Check();\n     return ret;\n }\n \n-CAddrInfo AddrManImpl::Select(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrManImpl::Select(bool newOnly) const\n {\n     LOCK(cs);\n     Check();\n-    const CAddrInfo addrRet = Select_(newOnly);\n+    const auto addrRet = Select_(newOnly);\n     Check();\n     return addrRet;\n }\n@@ -1159,12 +1158,12 @@ void CAddrMan::ResolveCollisions()\n     m_impl->ResolveCollisions();\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision()\n+std::pair<CAddress, int64_t> CAddrMan::SelectTriedCollision()\n {\n     return m_impl->SelectTriedCollision();\n }\n \n-CAddrInfo CAddrMan::Select(bool newOnly) const\n+std::pair<CAddress, int64_t> CAddrMan::Select(bool newOnly) const\n {\n     return m_impl->Select(newOnly);\n }"
      },
      {
        "sha": "d176d0a42c180df0fc656e68644573f90ae48286",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 13,
        "deletions": 3,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "patch": "@@ -171,13 +171,23 @@ class CAddrMan\n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions();\n \n-    //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision();\n+    /**\n+     * Randomly select an address in the tried table that another address is\n+     * attempting to evict.\n+     *\n+     * @return CAddress The record for the selected tried peer.\n+     *         int64_t  The last time we attempted to connect to that peer.\n+     */\n+    std::pair<CAddress, int64_t> SelectTriedCollision();\n \n     /**\n      * Choose an address to connect to.\n+     *\n+     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @return    CAddress The record for the selected peer.\n+     *            int64_t  The last time we attempted to connect to that peer.\n      */\n-    CAddrInfo Select(bool newOnly = false) const;\n+    std::pair<CAddress, int64_t> Select(bool newOnly = false) const;\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network."
      },
      {
        "sha": "6752d5b81d14a24b5613810f29a7c1d308961192",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "patch": "@@ -31,9 +31,9 @@ class AddrManImpl\n \n     void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    std::pair<CAddress, int64_t> SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    CAddrInfo Select(bool newOnly) const\n+    std::pair<CAddress, int64_t>  Select(bool newOnly) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n@@ -161,7 +161,7 @@ class AddrManImpl\n     void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n@@ -193,7 +193,7 @@ class AddrManImpl\n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::pair<CAddress, int64_t> SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n     void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);"
      },
      {
        "sha": "b4c2e35f42222bca0a5fd7b8c873a8d031f9d2b4",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "patch": "@@ -87,7 +87,7 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n     bench.run([&] {\n         const auto& address = addrman.Select();\n-        assert(address.GetPort() > 0);\n+        assert(address.first.GetPort() > 0);\n     });\n }\n "
      },
      {
        "sha": "60218d9dc1b76f51503dbb9cfec79918d5d042ce",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "patch": "@@ -2010,17 +2010,18 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             if (nTries > 100)\n                 break;\n \n-            CAddrInfo addr;\n+            CAddress addr;\n+            int64_t addr_last_try{0};\n \n             if (fFeeler) {\n                 // First, try to get a tried table collision address. This returns\n                 // an empty (invalid) address if there are no collisions to try.\n-                addr = addrman.SelectTriedCollision();\n+                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();\n \n                 if (!addr.IsValid()) {\n                     // No tried table collisions. Select a new table address\n                     // for our feeler.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 } else if (AlreadyConnectedToAddress(addr)) {\n                     // If test-before-evict logic would have us connect to a\n                     // peer that we're already connected to, just mark that\n@@ -2029,11 +2030,11 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     // a currently-connected peer.\n                     addrman.Good(addr);\n                     // Select a new table address for our feeler instead.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 }\n             } else {\n                 // Not a feeler\n-                addr = addrman.Select();\n+                std::tie(addr, addr_last_try) = addrman.Select();\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n@@ -2050,7 +2051,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 continue;\n \n             // only consider very recently tried nodes after 30 failed attempts\n-            if (nANow - addr.nLastTry < 600 && nTries < 30)\n+            if (nANow - addr_last_try < 600 && nTries < 30)\n                 continue;\n \n             // for non-feelers, require all the services we'll want,"
      },
      {
        "sha": "022f60a8ede05b1543000815a16faaa505a7c4a0",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14bc48c04e50182d66471d8d48f942e2a1eb8b1d/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "patch": "@@ -172,14 +172,14 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n     // Test: Does Addrman respond correctly when empty.\n     BOOST_CHECK_EQUAL(addrman->size(), 0U);\n-    CAddrInfo addr_null = addrman->Select();\n+    auto addr_null = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n     // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman->size(), 1U);\n-    CAddrInfo addr_ret1 = addrman->Select();\n+    auto addr_ret1 = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Does IP address deduplication work correctly.\n@@ -224,15 +224,15 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     BOOST_CHECK(!addrman.Add({CAddress(addr1_port, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select();\n+    auto addr_ret2 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     bool newOnly = true;\n-    CAddrInfo addr_ret3 = addrman.Select(newOnly);\n+    auto addr_ret3 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n@@ -249,16 +249,16 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     bool newOnly = true;\n-    CAddrInfo addr_ret1 = addrman.Select(newOnly);\n+    auto addr_ret1 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select(newOnly);\n+    auto addr_ret2 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n-    CAddrInfo addr_ret3 = addrman.Select();\n+    auto addr_ret3 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Test: Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n-        ports.insert(addrman.Select().GetPort());\n+        ports.insert(addrman.Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n@@ -869,7 +869,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add twenty two addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -880,7 +880,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n         // No collisions yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Ensure Good handles duplicates well.\n@@ -889,7 +889,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == 22);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n }\n@@ -907,7 +907,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -916,11 +916,11 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr36);\n \n     BOOST_CHECK(addrman.size() == 36);\n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.19:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.19:0\");\n \n     // 36 should be discarded and 19 not evicted.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Lets create two collisions.\n     for (unsigned int i = 37; i < 59; i++) {\n@@ -929,7 +929,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Cause a collision.\n@@ -938,16 +938,16 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr59);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.10:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.10:0\");\n \n     // Cause a second collision.\n     BOOST_CHECK(!addrman.Add({CAddress(addr36, NODE_NONE)}, source));\n     addrman.Good(addr36);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() != \"[::]:0\");\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n@@ -957,7 +957,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add 35 addresses\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -968,7 +968,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -977,31 +977,31 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     addrman.Good(addr);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 36);\n-    CAddrInfo info = addrman.SelectTriedCollision();\n+    auto info = addrman.SelectTriedCollision().first;\n     BOOST_CHECK_EQUAL(info.ToString(), \"250.1.1.19:0\");\n \n     // Ensure test of address fails, so that it is evicted.\n     addrman.SimConnFail(info);\n \n     // Should swap 36 for 19.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If 36 was swapped for 19, then this should cause no collisions.\n     BOOST_CHECK(!addrman.Add({CAddress(addr, NODE_NONE)}, source));\n     addrman.Good(addr);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If we insert 19 it should collide with 36\n     CService addr19 = ResolveService(\"250.1.1.19\");\n     BOOST_CHECK(!addrman.Add({CAddress(addr19, NODE_NONE)}, source));\n     addrman.Good(addr19);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.36:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.36:0\");\n \n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(load_addrman)"
      }
    ]
  },
  {
    "sha": "85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
    "node_id": "C_kwDOABII59oAKDg1YTFlN2VkNGZhY2IzZmZlMmE2YmE4NTU4YTY1MjFjMGUyMmY5OWM",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-04T00:26:56Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[move-only] Move CAddrInfo to test-only header file\n\nNow that no bitcoind callers require knowledge of the CAddrInfo object, it can\nbe moved into the test-only header file.\n\nReview hint: use git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "f9fe3e26da1744683d60a4987ee738577229d370",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f9fe3e26da1744683d60a4987ee738577229d370"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14bc48c04e50182d66471d8d48f942e2a1eb8b1d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/14bc48c04e50182d66471d8d48f942e2a1eb8b1d"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 73,
      "deletions": 72
    },
    "files": [
      {
        "sha": "33298df5cc1a1d8c59ca2028e6534728268a7e58",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 0,
        "deletions": 72,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
        "patch": "@@ -24,78 +24,6 @@ class AddrManImpl;\n /** Default for -checkaddrman */\n static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n \n-/**\n- * Extended statistics about a CAddress\n- */\n-class CAddrInfo : public CAddress\n-{\n-public:\n-    //! last try whatsoever by us (memory only)\n-    int64_t nLastTry{0};\n-\n-    //! last counted attempt (memory only)\n-    int64_t nLastCountAttempt{0};\n-\n-private:\n-    //! where knowledge about this address first came from\n-    CNetAddr source;\n-\n-    //! last successful connection by us\n-    int64_t nLastSuccess{0};\n-\n-    //! connection attempts since last successful attempt\n-    int nAttempts{0};\n-\n-    //! reference count in new sets (memory only)\n-    int nRefCount{0};\n-\n-    //! in tried set? (memory only)\n-    bool fInTried{false};\n-\n-    //! position in vRandom\n-    mutable int nRandomPos{-1};\n-\n-    friend class AddrManImpl;\n-    friend class CAddrManDeterministic;\n-\n-public:\n-\n-    SERIALIZE_METHODS(CAddrInfo, obj)\n-    {\n-        READWRITEAS(CAddress, obj);\n-        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n-    }\n-\n-    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n-    {\n-    }\n-\n-    CAddrInfo() : CAddress(), source()\n-    {\n-    }\n-\n-    //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n-    {\n-        return GetNewBucket(nKey, source, asmap);\n-    }\n-\n-    //! Calculate in which position of a bucket to store this entry.\n-    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n-\n-    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n-    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n-\n-    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n-    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n-};\n-\n /** Stochastic address manager\n  *\n  * Design goals:"
      },
      {
        "sha": "fec98c416a132f6a67ba87ed82b9f82bc3af7ee5",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
        "patch": "@@ -5,6 +5,78 @@\n #ifndef BITCOIN_ADDRMAN_IMPL_H\n #define BITCOIN_ADDRMAN_IMPL_H\n \n+/**\n+ * Extended statistics about a CAddress\n+ */\n+class CAddrInfo : public CAddress\n+{\n+public:\n+    //! last try whatsoever by us (memory only)\n+    int64_t nLastTry{0};\n+\n+    //! last counted attempt (memory only)\n+    int64_t nLastCountAttempt{0};\n+\n+private:\n+    //! where knowledge about this address first came from\n+    CNetAddr source;\n+\n+    //! last successful connection by us\n+    int64_t nLastSuccess{0};\n+\n+    //! connection attempts since last successful attempt\n+    int nAttempts{0};\n+\n+    //! reference count in new sets (memory only)\n+    int nRefCount{0};\n+\n+    //! in tried set? (memory only)\n+    bool fInTried{false};\n+\n+    //! position in vRandom\n+    mutable int nRandomPos{-1};\n+\n+    friend class AddrManImpl;\n+    friend class CAddrManDeterministic;\n+\n+public:\n+\n+    SERIALIZE_METHODS(CAddrInfo, obj)\n+    {\n+        READWRITEAS(CAddress, obj);\n+        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n+    }\n+\n+    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n+    {\n+    }\n+\n+    CAddrInfo() : CAddress(), source()\n+    {\n+    }\n+\n+    //! Calculate in which \"tried\" bucket this entry belongs\n+    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n+    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n+    {\n+        return GetNewBucket(nKey, source, asmap);\n+    }\n+\n+    //! Calculate in which position of a bucket to store this entry.\n+    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n+\n+    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n+    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n+\n+    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n+    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n+};\n+\n class AddrManImpl\n {\n public:"
      },
      {
        "sha": "8297cfa481d1b1242259fcd0833d0d9fd0e89fb0",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <blockencodings.h>\n #include <blockfilter.h>\n #include <chain.h>"
      }
    ]
  },
  {
    "sha": "8954b80a54cdd0b4d32678beb88ffa378e5fc026",
    "node_id": "C_kwDOABII59oAKDg5NTRiODBhNTRjZGQwYjRkMzI2NzhiZWI4OGZmYTM3OGU1ZmMwMjY",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-10T20:32:42Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[addrman] Change CAddrInfo access\n\nSince knowledge of CAddrInfo is limited to callsites that import\naddrman_impl.h, only objects in addrman.cpp or the tests have access. Thus we\ncan remove calling them friends and make the members public.",
      "tree": {
        "sha": "7bccb9881142a9dcd28b3e6443a2eb7901b4b597",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7bccb9881142a9dcd28b3e6443a2eb7901b4b597"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8954b80a54cdd0b4d32678beb88ffa378e5fc026",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8954b80a54cdd0b4d32678beb88ffa378e5fc026",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8954b80a54cdd0b4d32678beb88ffa378e5fc026",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8954b80a54cdd0b4d32678beb88ffa378e5fc026/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/85a1e7ed4facb3ffe2a6ba8558a6521c0e22f99c"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 0,
      "deletions": 6
    },
    "files": [
      {
        "sha": "8da814b1472a0c023523f7ccb9304fe2493a4432",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8954b80a54cdd0b4d32678beb88ffa378e5fc026/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8954b80a54cdd0b4d32678beb88ffa378e5fc026/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=8954b80a54cdd0b4d32678beb88ffa378e5fc026",
        "patch": "@@ -17,7 +17,6 @@ class CAddrInfo : public CAddress\n     //! last counted attempt (memory only)\n     int64_t nLastCountAttempt{0};\n \n-private:\n     //! where knowledge about this address first came from\n     CNetAddr source;\n \n@@ -36,11 +35,6 @@ class CAddrInfo : public CAddress\n     //! position in vRandom\n     mutable int nRandomPos{-1};\n \n-    friend class AddrManImpl;\n-    friend class CAddrManDeterministic;\n-\n-public:\n-\n     SERIALIZE_METHODS(CAddrInfo, obj)\n     {\n         READWRITEAS(CAddress, obj);"
      }
    ]
  },
  {
    "sha": "7d2f7378410ad9c168944745feeca065280558cc",
    "node_id": "C_kwDOABII59oAKDdkMmY3Mzc4NDEwYWQ5YzE2ODk0NDc0NWZlZWNhMDY1MjgwNTU4Y2M",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-04T00:26:10Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[move-only] Move constants to test-only header\n\nReview hint: git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "56bcc4c9d2c58f04d770c7bf06693f924ea95de7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/56bcc4c9d2c58f04d770c7bf06693f924ea95de7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d2f7378410ad9c168944745feeca065280558cc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d2f7378410ad9c168944745feeca065280558cc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d2f7378410ad9c168944745feeca065280558cc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d2f7378410ad9c168944745feeca065280558cc/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8954b80a54cdd0b4d32678beb88ffa378e5fc026",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8954b80a54cdd0b4d32678beb88ffa378e5fc026",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8954b80a54cdd0b4d32678beb88ffa378e5fc026"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 10,
      "deletions": 16
    },
    "files": [
      {
        "sha": "688265d345f12080ea40b69ecfc6c75fae8aa0a1",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d2f7378410ad9c168944745feeca065280558cc/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d2f7378410ad9c168944745feeca065280558cc/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=7d2f7378410ad9c168944745feeca065280558cc",
        "patch": "@@ -53,22 +53,6 @@ static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n  *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n-\n-/** Total number of buckets for tried addresses */\n-static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n-static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n-\n-/** Total number of buckets for new addresses */\n-static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n-static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n-\n-/** Maximum allowed number of entries in buckets for new and tried addresses */\n-static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n-static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n-\n-/**\n- * Stochastical (IP) address manager\n- */\n class CAddrMan\n {\n     const std::unique_ptr<AddrManImpl> m_impl;"
      },
      {
        "sha": "1d13df803d9de2008654d1dc62f2e3800118b304",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d2f7378410ad9c168944745feeca065280558cc/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d2f7378410ad9c168944745feeca065280558cc/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=7d2f7378410ad9c168944745feeca065280558cc",
        "patch": "@@ -5,6 +5,16 @@\n #ifndef BITCOIN_ADDRMAN_IMPL_H\n #define BITCOIN_ADDRMAN_IMPL_H\n \n+/** Total number of buckets for tried addresses */\n+static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n+/** Total number of buckets for new addresses */\n+static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+/** Maximum allowed number of entries in buckets for new and tried addresses */\n+static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n+static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n+\n /**\n  * Extended statistics about a CAddress\n  */"
      }
    ]
  },
  {
    "sha": "88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
    "node_id": "C_kwDOABII59oAKDg4ZWQwZjAwZTM2ZDQ1NmJlMGY0ZGM4ODFiNWE0YjMxYmVmMmQ4MGM",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-22T21:47:49Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[refactor] Update GetAddr_() function signature\n\nUpdate so the internal function signature matches the external one, as is the\ncase for the other addrman functions.",
      "tree": {
        "sha": "43a71dd19979b0c2d18c94da512be60a9e059123",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/43a71dd19979b0c2d18c94da512be60a9e059123"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d2f7378410ad9c168944745feeca065280558cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d2f7378410ad9c168944745feeca065280558cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d2f7378410ad9c168944745feeca065280558cc"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 11,
      "deletions": 8
    },
    "files": [
      {
        "sha": "40e087f5fb8bc653bf4002821dfcde19b7537736",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
        "patch": "@@ -745,7 +745,7 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n     }\n }\n \n-void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -759,8 +759,9 @@ void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, s\n \n     // gather a list of random nodes, skipping those of low quality\n     const int64_t now{GetAdjustedTime()};\n+    std::vector<CAddress> addresses;\n     for (unsigned int n = 0; n < vRandom.size(); n++) {\n-        if (vAddr.size() >= nNodes)\n+        if (addresses.size() >= nNodes)\n             break;\n \n         int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;\n@@ -776,8 +777,10 @@ void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, s\n         // Filter for quality\n         if (ai.IsTerrible(now)) continue;\n \n-        vAddr.push_back(ai);\n+        addresses.push_back(ai);\n     }\n+\n+    return addresses;\n }\n \n void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n@@ -1080,10 +1083,9 @@ std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct,\n {\n     LOCK(cs);\n     Check();\n-    std::vector<CAddress> vAddr;\n-    GetAddr_(vAddr, max_addresses, max_pct, network);\n+    const auto addresses = GetAddr_(max_addresses, max_pct, network);\n     Check();\n-    return vAddr;\n+    return addresses;\n }\n \n void AddrManImpl::Connected(const CService &addr, int64_t nTime)"
      },
      {
        "sha": "918034caf88356c98108ae60f235ae15563232fa",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
        "patch": "@@ -242,12 +242,13 @@ class AddrManImpl\n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n      *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n      * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n+     *\n+     * @returns                  A vector of randomly selected addresses from vRandom.\n      */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** We have successfully connected to this peer. Calling this function\n      *  updates the CAddress's nTime, which is used in our IsTerrible()"
      }
    ]
  },
  {
    "sha": "28a124096b2505c5f15436ba72db0ce079fd3cdd",
    "node_id": "C_kwDOABII59oAKDI4YTEyNDA5NmIyNTA1YzVmMTU0MzZiYTcyZGIwY2UwNzlmZDNjZGQ",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-04T00:27:11Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[doc] Update comments\n\nMaintain comments on the external interfaces rather than on the internal\nfunctions that implement them.",
      "tree": {
        "sha": "d39da712d0a7aeccc945f4a2017575dc1edee596",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d39da712d0a7aeccc945f4a2017575dc1edee596"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28a124096b2505c5f15436ba72db0ce079fd3cdd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28a124096b2505c5f15436ba72db0ce079fd3cdd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/28a124096b2505c5f15436ba72db0ce079fd3cdd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28a124096b2505c5f15436ba72db0ce079fd3cdd/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/88ed0f00e36d456be0f4dc881b5a4b31bef2d80c"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 16,
      "deletions": 30
    },
    "files": [
      {
        "sha": "3ccd3751bc6971867e1df32f9846faa9e91add25",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a124096b2505c5f15436ba72db0ce079fd3cdd/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a124096b2505c5f15436ba72db0ce079fd3cdd/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=28a124096b2505c5f15436ba72db0ce079fd3cdd",
        "patch": "@@ -23,7 +23,7 @@\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n /** Over how many buckets entries with new addresses originating from a single group are spread */\n static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n-/** Maximum number of times an address can be added to the new table */\n+/** Maximum number of times an address can occur in the new table */\n static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n /** How old addresses can maximally be */\n static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};"
      },
      {
        "sha": "84c2bf2201b7c536fc8cd9214231ee07128b164a",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a124096b2505c5f15436ba72db0ce079fd3cdd/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a124096b2505c5f15436ba72db0ce079fd3cdd/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=28a124096b2505c5f15436ba72db0ce079fd3cdd",
        "patch": "@@ -74,7 +74,7 @@ class CAddrMan\n     //! Add addresses to addrman's new table.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n-    //! Mark an entry as accessible.\n+    //! Mark an entry as accessible, possibly moving it from \"new\" to \"tried\".\n     void Good(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n@@ -107,12 +107,25 @@ class CAddrMan\n      * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n+     *\n+     * @return                   A vector of randomly selected addresses from vRandom.\n      */\n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const;\n \n-    //! Outer function for Connected_()\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n     void Connected(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n+    //! Update an entry's service bits.\n     void SetServices(const CService &addr, ServiceFlags nServices);\n \n     const std::vector<bool>& GetAsmap() const;"
      },
      {
        "sha": "160efb2c0ed042d3b2f0176c112860785eb572b2",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 27,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/28a124096b2505c5f15436ba72db0ce079fd3cdd/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/28a124096b2505c5f15436ba72db0ce079fd3cdd/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=28a124096b2505c5f15436ba72db0ce079fd3cdd",
        "patch": "@@ -227,49 +227,22 @@ class AddrManImpl\n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n     void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Add an entry to the \"new\" table.\n     bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Mark an entry as attempted to connect.\n     void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    /**\n-     * Return all or many randomly selected addresses, optionally by network.\n-     *\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n-     *\n-     * @returns                  A vector of randomly selected addresses from vRandom.\n-     */\n     std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    /** We have successfully connected to this peer. Calling this function\n-     *  updates the CAddress's nTime, which is used in our IsTerrible()\n-     *  decisions and gossiped to peers. Callers should be careful that updating\n-     *  this information doesn't leak topology information to network spies.\n-     *\n-     *  net_processing calls this function when it *disconnects* from a peer to\n-     *  not leak information about currently connected peers.\n-     *\n-     * @param[in]   addr     The address of the peer we were connected to\n-     * @param[in]   nTime    The time that we were last connected to this peer\n-     */\n     void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Update an entry's service bits.\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Return a random to-be-evicted tried table address.\n     std::pair<CAddress, int64_t> SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected."
      }
    ]
  },
  {
    "sha": "01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
    "node_id": "C_kwDOABII59oAKDAxZjU3NjU5NTBlNWMzZWNmYjZmM2NmMWZmYmVkYWFmOGFmN2M1NTc",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-10T22:37:41Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[includes] Fix up included files",
      "tree": {
        "sha": "cd2b99c517613f447a4939432e9f4e354d6e9bb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd2b99c517613f447a4939432e9f4e354d6e9bb2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "28a124096b2505c5f15436ba72db0ce079fd3cdd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28a124096b2505c5f15436ba72db0ce079fd3cdd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/28a124096b2505c5f15436ba72db0ce079fd3cdd"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 23,
      "deletions": 9
    },
    "files": [
      {
        "sha": "ef1538b6e9f19dffd6a0486c60ed5b6664693672",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
        "patch": "@@ -6,18 +6,19 @@\n #include <addrman.h>\n #include <addrman_impl.h>\n \n-#include <clientversion.h>\n #include <hash.h>\n-#include <logging.h>\n #include <netaddress.h>\n+#include <protocol.h>\n+#include <random.h>\n #include <serialize.h>\n #include <streams.h>\n+#include <timedata.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n #include <util/check.h>\n \n #include <cmath>\n #include <optional>\n-#include <unordered_map>\n-#include <unordered_set>\n \n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};"
      },
      {
        "sha": "b0944bcfd59f0fe6429aeaa8fbc549ad19eaa6e1",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
        "patch": "@@ -6,17 +6,15 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include <fs.h>\n-#include <logging.h>\n #include <netaddress.h>\n #include <protocol.h>\n-#include <sync.h>\n+#include <streams.h>\n #include <timedata.h>\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n-#include <set>\n-#include <unordered_map>\n+#include <utility>\n #include <vector>\n \n class AddrManImpl;"
      },
      {
        "sha": "c37c7b4779899c48dfeaccc1760c28c792c42a24",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
        "patch": "@@ -5,6 +5,21 @@\n #ifndef BITCOIN_ADDRMAN_IMPL_H\n #define BITCOIN_ADDRMAN_IMPL_H\n \n+#include <logging.h>\n+#include <netaddress.h>\n+#include <protocol.h>\n+#include <serialize.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <utility>\n+#include <vector>\n+\n /** Total number of buckets for tried addresses */\n static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};"
      }
    ]
  },
  {
    "sha": "a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
    "node_id": "C_kwDOABII59oAKGE5ZDAzMDE0YTRlZWZjYWI1MDBhOWQ2NzY4ZDlkN2NiMTliODZiYmY",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-11T00:16:37Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "scripted-diff: Rename CAddrMan to AddrMan\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l CAddrMan src/ test/ | xargs sed -i 's/CAddrMan/AddrMan/g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "87dba303cc46fdfc9fcfe9337afc9533b2b92b7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87dba303cc46fdfc9fcfe9337afc9533b2b92b7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/01f5765950e5c3ecfb6f3cf1ffbedaaf8af7c557"
      }
    ],
    "stats": {
      "total": 244,
      "additions": 122,
      "deletions": 122
    },
    "files": [
      {
        "sha": "50fd09101ee568cd305b05ed1f3b7682dd828056",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -170,21 +170,21 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr)\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)\n {\n     const auto pathAddr = args.GetDataDirNet() / \"peers.dat\";\n     return SerializeFileDB(\"peers\", pathAddr, addr, CLIENT_VERSION);\n }\n \n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers)\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers)\n {\n     DeserializeDB(ssPeers, addr, false);\n }\n \n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman)\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n {\n     auto check_addrman = std::clamp<int32_t>(args.GetIntArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+    addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n \n     int64_t nStart = GetTimeMillis();\n     const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n@@ -193,7 +193,7 @@ std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const A\n         LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n     } catch (const DbNotFoundError&) {\n         // Addrman can be in an inconsistent state after failure, reset it\n-        addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n         LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", path_addr);\n         DumpPeerAddresses(args, *addrman);\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "19be4b5bb4ee284c92745c7115c9ec1042c02f83",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -14,14 +14,14 @@\n #include <vector>\n \n class ArgsManager;\n-class CAddrMan;\n+class AddrMan;\n class CAddress;\n class CDataStream;\n struct bilingual_str;\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr);\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr);\n /** Only used by tests. */\n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers);\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers);\n \n /** Access to the banlist database (banlist.json) */\n class CBanDB\n@@ -48,7 +48,7 @@ class CBanDB\n };\n \n /** Returns an error string on failure */\n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman);\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman);\n \n /**\n  * Dump the anchor IP address database (anchors.dat)"
      },
      {
        "sha": "42d4b5a6e5322cfd700095b4a74932dd0b2c9ba3",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -269,14 +269,14 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]\",\n                     nNew,\n                     ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]\",\n                     nTried,\n                     ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n@@ -1110,83 +1110,83 @@ const std::vector<bool>& AddrManImpl::GetAsmap() const\n     return m_asmap;\n }\n \n-CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrMan::AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n     : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n \n-CAddrMan::~CAddrMan() = default;\n+AddrMan::~AddrMan() = default;\n \n template <typename Stream>\n-void CAddrMan::Serialize(Stream& s_) const\n+void AddrMan::Serialize(Stream& s_) const\n {\n     m_impl->Serialize<Stream>(s_);\n }\n \n template <typename Stream>\n-void CAddrMan::Unserialize(Stream& s_)\n+void AddrMan::Unserialize(Stream& s_)\n {\n     m_impl->Unserialize<Stream>(s_);\n }\n \n // explicit instantiation\n-template void CAddrMan::Serialize(CHashWriter& s) const;\n-template void CAddrMan::Serialize(CAutoFile& s) const;\n-template void CAddrMan::Serialize(CDataStream& s) const;\n-template void CAddrMan::Unserialize(CAutoFile& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n-template void CAddrMan::Unserialize(CDataStream& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n-\n-size_t CAddrMan::size() const\n+template void AddrMan::Serialize(CHashWriter& s) const;\n+template void AddrMan::Serialize(CAutoFile& s) const;\n+template void AddrMan::Serialize(CDataStream& s) const;\n+template void AddrMan::Unserialize(CAutoFile& s);\n+template void AddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void AddrMan::Unserialize(CDataStream& s);\n+template void AddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n+size_t AddrMan::size() const\n {\n     return m_impl->size();\n }\n \n-bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     return m_impl->Add(vAddr, source, nTimePenalty);\n }\n \n-void CAddrMan::Good(const CService &addr, int64_t nTime)\n+void AddrMan::Good(const CService &addr, int64_t nTime)\n {\n     m_impl->Good(addr, nTime);\n }\n \n-void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n {\n     m_impl->Attempt(addr, fCountFailure, nTime);\n }\n \n-void CAddrMan::ResolveCollisions()\n+void AddrMan::ResolveCollisions()\n {\n     m_impl->ResolveCollisions();\n }\n \n-std::pair<CAddress, int64_t> CAddrMan::SelectTriedCollision()\n+std::pair<CAddress, int64_t> AddrMan::SelectTriedCollision()\n {\n     return m_impl->SelectTriedCollision();\n }\n \n-std::pair<CAddress, int64_t> CAddrMan::Select(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrMan::Select(bool newOnly) const\n {\n     return m_impl->Select(newOnly);\n }\n \n-std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     return m_impl->GetAddr(max_addresses, max_pct, network);\n }\n \n-void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+void AddrMan::Connected(const CService &addr, int64_t nTime)\n {\n     m_impl->Connected(addr, nTime);\n }\n \n-void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n {\n     m_impl->SetServices(addr, nServices);\n }\n \n-const std::vector<bool>& CAddrMan::GetAsmap() const\n+const std::vector<bool>& AddrMan::GetAsmap() const\n {\n     return m_impl->GetAsmap();\n }"
      },
      {
        "sha": "fcb21478326294ac17dbbf0afa6737c5f9d2b7c2",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -51,14 +51,14 @@ static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n  *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n-class CAddrMan\n+class AddrMan\n {\n     const std::unique_ptr<AddrManImpl> m_impl;\n \n public:\n-    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n+    explicit AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n-    ~CAddrMan();\n+    ~AddrMan();\n \n     template <typename Stream>\n     void Serialize(Stream& s_) const;\n@@ -128,8 +128,8 @@ class CAddrMan\n \n     const std::vector<bool>& GetAsmap() const;\n \n-    friend class CAddrManTest;\n-    friend class CAddrManDeterministic;\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "f9deb171911853f7a83e005ea904bdbe75984731",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -138,8 +138,8 @@ class AddrManImpl\n \n     const std::vector<bool>& GetAsmap() const;\n \n-    friend class CAddrManTest;\n-    friend class CAddrManDeterministic;\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n \n private:\n     //! A mutex to protect the inner data structures."
      },
      {
        "sha": "d6834a239bd911c4dfcc08fa09e4c7084cc987bd",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -53,14 +53,14 @@ static void CreateAddresses()\n     }\n }\n \n-static void AddAddressesToAddrMan(CAddrMan& addrman)\n+static void AddAddressesToAddrMan(AddrMan& addrman)\n {\n     for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n         addrman.Add(g_addresses[source_i], g_sources[source_i]);\n     }\n }\n \n-static void FillAddrMan(CAddrMan& addrman)\n+static void FillAddrMan(AddrMan& addrman)\n {\n     CreateAddresses();\n \n@@ -74,14 +74,14 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        CAddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n+        AddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -93,7 +93,7 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -105,7 +105,7 @@ static void AddrManGetAddr(benchmark::Bench& bench)\n \n static void AddrManAddThenGood(benchmark::Bench& bench)\n {\n-    auto markSomeAsGood = [](CAddrMan& addrman) {\n+    auto markSomeAsGood = [](AddrMan& addrman) {\n         for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n             for (size_t addr_i = 0; addr_i < NUM_ADDRESSES_PER_SOURCE; ++addr_i) {\n                 addrman.Good(g_addresses[source_i][addr_i]);\n@@ -117,12 +117,12 @@ static void AddrManAddThenGood(benchmark::Bench& bench)\n \n     bench.run([&] {\n         // To make the benchmark independent of the number of evaluations, we always prepare a new addrman.\n-        // This is necessary because CAddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n+        // This is necessary because AddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n         // to the same method and we want to do the same amount of work in every loop iteration.\n         //\n         // This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in\n-        // CAddrMan::Good() will still be noticeable.\n-        CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+        // AddrMan::Good() will still be noticeable.\n+        AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n         AddAddressesToAddrMan(addrman);\n \n         markSomeAsGood(addrman);"
      },
      {
        "sha": "7271ff22b2af52f25f158ab77a66af2d62c370d9",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -2444,7 +2444,7 @@ void CConnman::SetNetworkActive(bool active)\n     }\n }\n \n-CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, CAddrMan& addrman_in, bool network_active)\n+CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in, bool network_active)\n     : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)\n {\n     SetTryNewOutboundPeer(false);"
      },
      {
        "sha": "e2071414b434f3eb9db5aa8a1df02fd100362246",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -797,7 +797,7 @@ class CConnman\n         m_onion_binds = connOptions.onion_binds;\n     }\n \n-    CConnman(uint64_t seed0, uint64_t seed1, CAddrMan& addrman, bool network_active = true);\n+    CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, bool network_active = true);\n     ~CConnman();\n     bool Start(CScheduler& scheduler, const Options& options);\n \n@@ -1049,7 +1049,7 @@ class CConnman\n     std::vector<ListenSocket> vhListenSocket;\n     std::atomic<bool> fNetworkActive{true};\n     bool fAddressesInitialized{false};\n-    CAddrMan& addrman;\n+    AddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);"
      },
      {
        "sha": "66b99aa2bb156ea4872f2398b456c89f90a4ad0b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -292,7 +292,7 @@ using PeerRef = std::shared_ptr<Peer>;\n class PeerManagerImpl final : public PeerManager\n {\n public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                     BanMan* banman, ChainstateManager& chainman,\n                     CTxMemPool& pool, bool ignore_incoming_txs);\n \n@@ -410,7 +410,7 @@ class PeerManagerImpl final : public PeerManager\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n-    CAddrMan& m_addrman;\n+    AddrMan& m_addrman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n@@ -1426,14 +1426,14 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n            (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n-std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                                BanMan* banman, ChainstateManager& chainman,\n                                                CTxMemPool& pool, bool ignore_incoming_txs)\n {\n     return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, chainman, pool, ignore_incoming_txs);\n }\n \n-PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                  BanMan* banman, ChainstateManager& chainman,\n                                  CTxMemPool& pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n@@ -2664,7 +2664,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // table is also potentially detrimental because new-table entries\n             // are subject to eviction in the event of addrman collisions.  We\n             // mitigate the information-leak by never calling\n-            // CAddrMan::Connected() on block-relay-only peers; see\n+            // AddrMan::Connected() on block-relay-only peers; see\n             // FinalizeNode().\n             //\n             // This moves an address from New to Tried table in Addrman,"
      },
      {
        "sha": "27bc40687a0597a0ff6b454af2524ea1a0a73079",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -9,7 +9,7 @@\n #include <net.h>\n #include <validationinterface.h>\n \n-class CAddrMan;\n+class AddrMan;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n@@ -37,7 +37,7 @@ struct CNodeStateStats {\n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:\n-    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                              BanMan* banman, ChainstateManager& chainman,\n                                              CTxMemPool& pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }"
      },
      {
        "sha": "f9fff5a6d5e6a68f1db6bf8663fbc199d2668305",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -165,7 +165,7 @@ void CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)\n }\n \n /**\n- * Create an \"internal\" address that represents a name or FQDN. CAddrMan uses\n+ * Create an \"internal\" address that represents a name or FQDN. AddrMan uses\n  * these fake addresses to keep track of which DNS seeds were used.\n  * @returns Whether or not the operation was successful.\n  * @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX, CNetAddr::IsInternal(), CNetAddr::IsRFC4193()"
      },
      {
        "sha": "66c8c48f08a07dcffcd45cc57b401695b7f97905",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -62,7 +62,7 @@ enum Network {\n     NET_CJDNS,\n \n     /// A set of addresses that represent the hash of a string or FQDN. We use\n-    /// them in CAddrMan to keep track of which DNS seeds were used.\n+    /// them in AddrMan to keep track of which DNS seeds were used.\n     NET_INTERNAL,\n \n     /// Dummy value to indicate the number of NET_* constants."
      },
      {
        "sha": "26873345b46724752dff4f35c47522486c046805",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -12,7 +12,7 @@\n \n class ArgsManager;\n class BanMan;\n-class CAddrMan;\n+class AddrMan;\n class CBlockPolicyEstimator;\n class CConnman;\n class CScheduler;\n@@ -39,7 +39,7 @@ class WalletClient;\n struct NodeContext {\n     //! Init interface for initializing current process and connecting to other processes.\n     interfaces::Init* init{nullptr};\n-    std::unique_ptr<CAddrMan> addrman;\n+    std::unique_ptr<AddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;"
      },
      {
        "sha": "d532eed1da33b90794e977e75009d362477e2ede",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -22,26 +22,26 @@\n \n using namespace std::literals;\n \n-class CAddrManSerializationMock : public CAddrMan\n+class AddrManSerializationMock : public AddrMan\n {\n public:\n     virtual void Serialize(CDataStream& s) const = 0;\n \n-    CAddrManSerializationMock()\n-        : CAddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n+    AddrManSerializationMock()\n+        : AddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n     {}\n };\n \n-class CAddrManUncorrupted : public CAddrManSerializationMock\n+class AddrManUncorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n     {\n-        CAddrMan::Serialize(s);\n+        AddrMan::Serialize(s);\n     }\n };\n \n-class CAddrManCorrupted : public CAddrManSerializationMock\n+class AddrManCorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n@@ -67,7 +67,7 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n     }\n };\n \n-static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n+static CDataStream AddrmanToStream(const AddrManSerializationMock& _addrman)\n {\n     CDataStream ssPeersIn(SER_DISK, CLIENT_VERSION);\n     ssPeersIn << Params().MessageStart();\n@@ -77,14 +77,14 @@ static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n     return CDataStream(vchData, SER_DISK, CLIENT_VERSION);\n }\n \n-class CAddrManTest : public CAddrMan\n+class AddrManTest : public AddrMan\n {\n private:\n     bool deterministic;\n public:\n-    explicit CAddrManTest(bool makeDeterministic = true,\n+    explicit AddrManTest(bool makeDeterministic = true,\n                           std::vector<bool> asmap = std::vector<bool>())\n-        : CAddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n+        : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;\n     }\n@@ -166,7 +166,7 @@ BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n {\n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -200,7 +200,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     BOOST_CHECK(addrman->size() >= 1);\n \n     // Test: reset addrman and test AddrMan::Add multiple addresses works as expected\n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     std::vector<CAddress> vAddr;\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n@@ -210,7 +210,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -239,7 +239,7 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -298,7 +298,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -327,7 +327,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -357,7 +357,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -390,7 +390,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -410,7 +410,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n \n BOOST_AUTO_TEST_CASE(addrman_delete)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -430,7 +430,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n@@ -490,7 +490,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -545,7 +545,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -623,7 +623,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n // 101.8.0.0/16 AS8\n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -678,7 +678,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -760,9 +760,9 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n {\n     std::vector<bool> asmap1 = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n \n-    auto addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_asmap1_dup = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_noasmap = std::make_unique<CAddrManTest>();\n+    auto addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_asmap1_dup = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_noasmap = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     CAddress addr = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n@@ -792,8 +792,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1.second != bucketAndEntry_noasmap.second);\n \n     // deserializing non-asmaped peers.dat to asmaped addrman\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     addrman_noasmap->Add({addr}, default_source);\n     stream << *addrman_noasmap;\n     stream >> *addrman_asmap1;\n@@ -804,8 +804,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1_deser.second == bucketAndEntry_asmap1_dup.second);\n \n     // used to map to different buckets, now maps to the same bucket.\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.2.1.1\"), NODE_NONE);\n     addrman_noasmap->Add({addr, addr2}, default_source);\n@@ -825,7 +825,7 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n {\n     // Confirm that invalid addresses are ignored in unserialization.\n \n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     const CAddress new1{ResolveService(\"5.5.5.5\"), NODE_NONE};\n@@ -857,14 +857,14 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n     BOOST_REQUIRE(pos + sizeof(tried2_raw_replacement) <= stream.size());\n     memcpy(stream.data() + pos, tried2_raw_replacement, sizeof(tried2_raw_replacement));\n \n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     stream >> *addrman;\n     BOOST_CHECK_EQUAL(addrman->size(), 2);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -896,7 +896,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n BOOST_AUTO_TEST_CASE(addrman_noevict)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Add 35 addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -952,7 +952,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -1006,7 +1006,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n BOOST_AUTO_TEST_CASE(load_addrman)\n {\n-    CAddrManUncorrupted addrmanUncorrupted;\n+    AddrManUncorrupted addrmanUncorrupted;\n \n     CService addr1, addr2, addr3;\n     BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n@@ -1025,7 +1025,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -1042,7 +1042,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n@@ -1051,12 +1051,12 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n \n BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n {\n-    CAddrManCorrupted addrmanCorrupted;\n+    AddrManCorrupted addrmanCorrupted;\n \n     // Test that the de-serialization of corrupted addrman throws an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1072,7 +1072,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }"
      },
      {
        "sha": "d68002667ac58fe0ec15a478f9b0fe8c424805ff",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -28,20 +28,20 @@ FUZZ_TARGET_INIT(data_stream_addr_man, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    CAddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     try {\n         ReadFromStream(addr_man, data_stream);\n     } catch (const std::exception&) {\n     }\n }\n \n-class CAddrManDeterministic : public CAddrMan\n+class AddrManDeterministic : public AddrMan\n {\n public:\n     FuzzedDataProvider& m_fuzzed_data_provider;\n \n-    explicit CAddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n-        : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n+    explicit AddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n+        : AddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n         WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n@@ -130,7 +130,7 @@ class CAddrManDeterministic : public CAddrMan\n      * - vvNew entries refer to the same addresses\n      * - vvTried entries refer to the same addresses\n      */\n-    bool operator==(const CAddrManDeterministic& other)\n+    bool operator==(const AddrManDeterministic& other)\n     {\n         LOCK2(m_impl->cs, other.m_impl->cs);\n \n@@ -223,7 +223,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    auto addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+    auto addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n         CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n@@ -232,10 +232,10 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         try {\n             ds >> *addr_man_ptr;\n         } catch (const std::ios_base::failure&) {\n-            addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+            addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n         }\n     }\n-    CAddrManDeterministic& addr_man = *addr_man_ptr;\n+    AddrManDeterministic& addr_man = *addr_man_ptr;\n     while (fuzzed_data_provider.ConsumeBool()) {\n         CallOneOf(\n             fuzzed_data_provider,\n@@ -284,7 +284,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n                 }\n             });\n     }\n-    const CAddrMan& const_addr_man{addr_man};\n+    const AddrMan& const_addr_man{addr_man};\n     (void)const_addr_man.GetAddr(\n         /* max_addresses */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n         /* max_pct */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n@@ -302,8 +302,8 @@ FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n \n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    CAddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n-    CAddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n \n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n "
      },
      {
        "sha": "d381345a0d4d3d4376c70d904f496d497e3d007c",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -25,7 +25,7 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);"
      },
      {
        "sha": "b1a07b482e94e23e5622a036234ccdc6add96867",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -189,7 +189,7 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    CAddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {"
      },
      {
        "sha": "ebefa9974e773e41c476b02d68d6ba828272e9a4",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -192,7 +192,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<CAddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.addrman = std::make_unique<AddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,"
      },
      {
        "sha": "93d50c13692176f72ecdc17d1ef1dc3dffc2a354",
        "filename": "test/functional/feature_addrman.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/test/functional/feature_addrman.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf/test/functional/feature_addrman.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_addrman.py?ref=a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "patch": "@@ -109,15 +109,15 @@ def run_test(self):\n         self.stop_node(0)\n         write_addrman(peers_dat, len_tried=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n \n         self.log.info(\"Check that corrupt addrman cannot be read (len_new)\")\n         self.stop_node(0)\n         write_addrman(peers_dat, len_new=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n "
      }
    ]
  },
  {
    "sha": "57ad5fc329a3c767f44342cec408ccc071069145",
    "node_id": "C_kwDOABII59oAKDU3YWQ1ZmMzMjlhM2M3NjdmNDQzNDJjZWM0MDhjY2MwNzEwNjkxNDU",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-11T00:33:25Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "scripted-diff: Rename CAddrInfo to AddrInfo\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l CAddrInfo src/ | xargs sed -i 's/CAddrInfo/AddrInfo/g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "464222888ecc42eadde4e88adbe590c328e3ec0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/464222888ecc42eadde4e88adbe590c328e3ec0f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57ad5fc329a3c767f44342cec408ccc071069145",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57ad5fc329a3c767f44342cec408ccc071069145",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57ad5fc329a3c767f44342cec408ccc071069145",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57ad5fc329a3c767f44342cec408ccc071069145/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a9d03014a4eefcab500a9d6768d9d7cb19b86bbf"
      }
    ],
    "stats": {
      "total": 154,
      "additions": 77,
      "deletions": 77
    },
    "files": [
      {
        "sha": "c015026cbc2129a3cb013e7e1b79fb293f1f292e",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 35,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57ad5fc329a3c767f44342cec408ccc071069145/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57ad5fc329a3c767f44342cec408ccc071069145/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=57ad5fc329a3c767f44342cec408ccc071069145",
        "patch": "@@ -41,7 +41,7 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n@@ -51,7 +51,7 @@ int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asma\n     return tried_bucket;\n }\n \n-int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n@@ -62,13 +62,13 @@ int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std:\n     return new_bucket;\n }\n \n-int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+int AddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n }\n \n-bool CAddrInfo::IsTerrible(int64_t nNow) const\n+bool AddrInfo::IsTerrible(int64_t nNow) const\n {\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n         return false;\n@@ -88,7 +88,7 @@ bool CAddrInfo::IsTerrible(int64_t nNow) const\n     return false;\n }\n \n-double CAddrInfo::GetChance(int64_t nNow) const\n+double AddrInfo::GetChance(int64_t nNow) const\n {\n     double fChance = 1.0;\n     int64_t nSinceLastTry = std::max<int64_t>(nNow - nLastTry, 0);\n@@ -190,7 +190,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     int nIds = 0;\n     for (const auto& entry : mapInfo) {\n         mapUnkIds[entry.first] = nIds;\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo &info = entry.second;\n         if (info.nRefCount) {\n             assert(nIds != nNew); // this means nNew was wrong, oh ow\n             s << info;\n@@ -199,7 +199,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     }\n     nIds = 0;\n     for (const auto& entry : mapInfo) {\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo &info = entry.second;\n         if (info.fInTried) {\n             assert(nIds != nTried); // this means nTried was wrong, oh ow\n             s << info;\n@@ -283,7 +283,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     // Deserialize entries from the new table.\n     for (int n = 0; n < nNew; n++) {\n-        CAddrInfo &info = mapInfo[n];\n+        AddrInfo &info = mapInfo[n];\n         s >> info;\n         mapAddr[info] = n;\n         info.nRandomPos = vRandom.size();\n@@ -294,7 +294,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     // Deserialize entries from the tried table.\n     int nLost = 0;\n     for (int n = 0; n < nTried; n++) {\n-        CAddrInfo info;\n+        AddrInfo info;\n         s >> info;\n         int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n         int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n@@ -351,7 +351,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     for (auto bucket_entry : bucket_entries) {\n         int bucket{bucket_entry.first};\n         const int entry_index{bucket_entry.second};\n-        CAddrInfo& info = mapInfo[entry_index];\n+        AddrInfo& info = mapInfo[entry_index];\n \n         // Don't store the entry in the new bucket if it's not a valid address for our addrman\n         if (!info.IsValid()) continue;\n@@ -401,7 +401,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     }\n }\n \n-CAddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n+AddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -416,12 +416,12 @@ CAddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n     return nullptr;\n }\n \n-CAddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n+AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     AssertLockHeld(cs);\n \n     int nId = nIdCount++;\n-    mapInfo[nId] = CAddrInfo(addr, addrSource);\n+    mapInfo[nId] = AddrInfo(addr, addrSource);\n     mapAddr[addr] = nId;\n     mapInfo[nId].nRandomPos = vRandom.size();\n     vRandom.push_back(nId);\n@@ -459,7 +459,7 @@ void AddrManImpl::Delete(int nId)\n     AssertLockHeld(cs);\n \n     assert(mapInfo.count(nId) != 0);\n-    CAddrInfo& info = mapInfo[nId];\n+    AddrInfo& info = mapInfo[nId];\n     assert(!info.fInTried);\n     assert(info.nRefCount == 0);\n \n@@ -477,7 +477,7 @@ void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n     // if there is an entry in the specified bucket, delete it.\n     if (vvNew[nUBucket][nUBucketPos] != -1) {\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n-        CAddrInfo& infoDelete = mapInfo[nIdDelete];\n+        AddrInfo& infoDelete = mapInfo[nIdDelete];\n         assert(infoDelete.nRefCount > 0);\n         infoDelete.nRefCount--;\n         vvNew[nUBucket][nUBucketPos] = -1;\n@@ -487,7 +487,7 @@ void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n     }\n }\n \n-void AddrManImpl::MakeTried(CAddrInfo& info, int nId)\n+void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -515,7 +515,7 @@ void AddrManImpl::MakeTried(CAddrInfo& info, int nId)\n         // find an item to evict\n         int nIdEvict = vvTried[nKBucket][nKBucketPos];\n         assert(mapInfo.count(nIdEvict) == 1);\n-        CAddrInfo& infoOld = mapInfo[nIdEvict];\n+        AddrInfo& infoOld = mapInfo[nIdEvict];\n \n         // Remove the to-be-evicted item from the tried set.\n         infoOld.fInTried = false;\n@@ -548,13 +548,13 @@ void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nT\n \n     nLastGood = nTime;\n \n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -605,7 +605,7 @@ bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTi\n \n     bool fNew = false;\n     int nId;\n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // Do not set a penalty for a source's self-announcement\n     if (addr == source) {\n@@ -652,7 +652,7 @@ bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTi\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n         if (!fInsert) {\n-            CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n+            AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n             if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n                 // Overwrite the existing new table entry.\n                 fInsert = true;\n@@ -675,13 +675,13 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTi\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -718,7 +718,7 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n             int nId = vvTried[nKBucket][nKBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n+            const AddrInfo& info{it_found->second};\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n                 return {info, info.nLastTry};\n             }\n@@ -737,7 +737,7 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n             int nId = vvNew[nUBucket][nUBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n+            const AddrInfo& info{it_found->second};\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n                 return {info, info.nLastTry};\n             }\n@@ -770,7 +770,7 @@ std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct\n         const auto it{mapInfo.find(vRandom[n])};\n         assert(it != mapInfo.end());\n \n-        const CAddrInfo& ai{it->second};\n+        const AddrInfo& ai{it->second};\n \n         // Filter by network (optional)\n         if (network != std::nullopt && ai.GetNetClass() != network) continue;\n@@ -788,13 +788,13 @@ void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -810,13 +810,13 @@ void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -839,7 +839,7 @@ void AddrManImpl::ResolveCollisions_()\n         if (mapInfo.count(id_new) != 1) {\n             erase_collision = true;\n         } else {\n-            CAddrInfo& info_new = mapInfo[id_new];\n+            AddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n             int tried_bucket = info_new.GetTriedBucket(nKey, m_asmap);\n@@ -850,7 +850,7 @@ void AddrManImpl::ResolveCollisions_()\n \n                 // Get the to-be-evicted address that is being tested\n                 int id_old = vvTried[tried_bucket][tried_bucket_pos];\n-                CAddrInfo& info_old = mapInfo[id_old];\n+                AddrInfo& info_old = mapInfo[id_old];\n \n                 // Has successfully connected in last X hours\n                 if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n@@ -905,13 +905,13 @@ std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n         return {};\n     }\n \n-    const CAddrInfo& newInfo = mapInfo[id_new];\n+    const AddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n     int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n-    const CAddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n+    const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n     return {info_old, info_old.nLastTry};\n }\n \n@@ -944,7 +944,7 @@ int AddrManImpl::ForceCheckAddrman() const\n \n     for (const auto& entry : mapInfo) {\n         int n = entry.first;\n-        const CAddrInfo& info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.fInTried) {\n             if (!info.nLastSuccess)\n                 return -1;"
      },
      {
        "sha": "157f7d5da658c7e67a337afaa08903879307e711",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57ad5fc329a3c767f44342cec408ccc071069145/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57ad5fc329a3c767f44342cec408ccc071069145/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=57ad5fc329a3c767f44342cec408ccc071069145",
        "patch": "@@ -33,7 +33,7 @@ static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n /**\n  * Extended statistics about a CAddress\n  */\n-class CAddrInfo : public CAddress\n+class AddrInfo : public CAddress\n {\n public:\n     //! last try whatsoever by us (memory only)\n@@ -60,17 +60,17 @@ class CAddrInfo : public CAddress\n     //! position in vRandom\n     mutable int nRandomPos{-1};\n \n-    SERIALIZE_METHODS(CAddrInfo, obj)\n+    SERIALIZE_METHODS(AddrInfo, obj)\n     {\n         READWRITEAS(CAddress, obj);\n         READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n     }\n \n-    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n+    AddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n     {\n     }\n \n-    CAddrInfo() : CAddress(), source()\n+    AddrInfo() : CAddress(), source()\n     {\n     }\n \n@@ -177,7 +177,7 @@ class AddrManImpl\n     int nIdCount GUARDED_BY(cs){0};\n \n     //! table with information about all nIds\n-    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+    std::unordered_map<int, AddrInfo> mapInfo GUARDED_BY(cs);\n \n     //! find an nId based on its network address\n     std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n@@ -225,10 +225,10 @@ class AddrManImpl\n     const std::vector<bool> m_asmap;\n \n     //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -240,7 +240,7 @@ class AddrManImpl\n     void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void MakeTried(AddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      },
      {
        "sha": "69ad7c7e24f31673306ad54021c5c71680f2694d",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57ad5fc329a3c767f44342cec408ccc071069145/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57ad5fc329a3c767f44342cec408ccc071069145/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=57ad5fc329a3c767f44342cec408ccc071069145",
        "patch": "@@ -62,7 +62,7 @@ class AddrManCorrupted : public AddrManSerializationMock\n         CAddress addr = CAddress(serv, NODE_NONE);\n         CNetAddr resolved;\n         BOOST_CHECK(LookupHost(\"252.2.2.2\", resolved, false));\n-        CAddrInfo info = CAddrInfo(addr, resolved);\n+        AddrInfo info = AddrInfo(addr, resolved);\n         s << info;\n     }\n };\n@@ -89,13 +89,13 @@ class AddrManTest : public AddrMan\n         deterministic = makeDeterministic;\n     }\n \n-    CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n         LOCK(m_impl->cs);\n         return m_impl->Find(addr, pnId);\n     }\n \n-    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n         LOCK(m_impl->cs);\n         return m_impl->Create(addr, addrSource, pnId);\n@@ -373,17 +373,17 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     BOOST_CHECK(addrman.Add({addr3}, source1));\n \n     // Test: ensure Find returns an IP matching what we searched on.\n-    CAddrInfo* info1 = addrman.Find(addr1);\n+    AddrInfo* info1 = addrman.Find(addr1);\n     BOOST_REQUIRE(info1);\n     BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n-    CAddrInfo* info2 = addrman.Find(addr2);\n+    AddrInfo* info2 = addrman.Find(addr2);\n     BOOST_REQUIRE(info2);\n     BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n     // Test: Find returns another IP matching what we searched on.\n-    CAddrInfo* info3 = addrman.Find(addr3);\n+    AddrInfo* info3 = addrman.Find(addr3);\n     BOOST_REQUIRE(info3);\n     BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n@@ -398,12 +398,12 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n-    CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n+    AddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n     // Test: The result should be the same as the input addr.\n     BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n@@ -424,7 +424,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     addrman.Delete(nId);\n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == nullptr);\n }\n \n@@ -498,7 +498,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -513,14 +513,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetTriedBucket(nKey1, asmap);\n@@ -532,7 +532,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -552,7 +552,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -568,13 +568,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -586,7 +586,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -599,7 +599,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -631,7 +631,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -646,14 +646,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"101.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -665,7 +665,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -685,7 +685,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -701,13 +701,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -719,7 +719,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -732,7 +732,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -744,7 +744,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);"
      },
      {
        "sha": "cfeab9dcdc2f0e460188c47865ce9a15ca6717d0",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57ad5fc329a3c767f44342cec408ccc071069145/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57ad5fc329a3c767f44342cec408ccc071069145/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=57ad5fc329a3c767f44342cec408ccc071069145",
        "patch": "@@ -142,24 +142,24 @@ class AddrManDeterministic : public AddrMan\n         // Check that all values in `mapInfo` are equal to all values in `other.mapInfo`.\n         // Keys may be different.\n \n-        using CAddrInfoHasher = std::function<size_t(const CAddrInfo&)>;\n-        using CAddrInfoEq = std::function<bool(const CAddrInfo&, const CAddrInfo&)>;\n+        using AddrInfoHasher = std::function<size_t(const AddrInfo&)>;\n+        using AddrInfoEq = std::function<bool(const AddrInfo&, const AddrInfo&)>;\n \n         CNetAddrHash netaddr_hasher;\n \n-        CAddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const CAddrInfo& a) {\n+        AddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const AddrInfo& a) {\n             return netaddr_hasher(static_cast<CNetAddr>(a)) ^ netaddr_hasher(a.source) ^\n                    a.nLastSuccess ^ a.nAttempts ^ a.nRefCount ^ a.fInTried;\n         };\n \n-        CAddrInfoEq addrinfo_eq = [](const CAddrInfo& lhs, const CAddrInfo& rhs) {\n+        AddrInfoEq addrinfo_eq = [](const AddrInfo& lhs, const AddrInfo& rhs) {\n             return static_cast<CNetAddr>(lhs) == static_cast<CNetAddr>(rhs) &&\n                    lhs.source == rhs.source && lhs.nLastSuccess == rhs.nLastSuccess &&\n                    lhs.nAttempts == rhs.nAttempts && lhs.nRefCount == rhs.nRefCount &&\n                    lhs.fInTried == rhs.fInTried;\n         };\n \n-        using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n+        using Addresses = std::unordered_set<AddrInfo, AddrInfoHasher, AddrInfoEq>;\n \n         const size_t num_addresses{m_impl->mapInfo.size()};\n "
      },
      {
        "sha": "a9325fa738b223f8734f77e396ef4d48027546a6",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57ad5fc329a3c767f44342cec408ccc071069145/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57ad5fc329a3c767f44342cec408ccc071069145/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=57ad5fc329a3c767f44342cec408ccc071069145",
        "patch": "@@ -105,7 +105,7 @@ FUZZ_TARGET_DESERIALIZE(block_filter_deserialize, {\n     DeserializeFromFuzzingInput(buffer, block_filter);\n })\n FUZZ_TARGET_DESERIALIZE(addr_info_deserialize, {\n-    CAddrInfo addr_info;\n+    AddrInfo addr_info;\n     DeserializeFromFuzzingInput(buffer, addr_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_file_info_deserialize, {"
      }
    ]
  },
  {
    "sha": "a006613159780f3bdecf2cdfe4885e59eeaa0534",
    "node_id": "C_kwDOABII59oAKGEwMDY2MTMxNTk3ODBmM2JkZWNmMmNkZmU0ODg1ZTU5ZWVhYTA1MzQ",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-11T00:53:57Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "[style] Run changed files through clang formatter.",
      "tree": {
        "sha": "f1e394d2c0e50bfc85558f289a931511b30e91ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f1e394d2c0e50bfc85558f289a931511b30e91ef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a006613159780f3bdecf2cdfe4885e59eeaa0534",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a006613159780f3bdecf2cdfe4885e59eeaa0534",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a006613159780f3bdecf2cdfe4885e59eeaa0534",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a006613159780f3bdecf2cdfe4885e59eeaa0534/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57ad5fc329a3c767f44342cec408ccc071069145",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57ad5fc329a3c767f44342cec408ccc071069145",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57ad5fc329a3c767f44342cec408ccc071069145"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 34,
      "deletions": 34
    },
    "files": [
      {
        "sha": "c364a7710b458a0440b04a2fcb20a74eaec16b12",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=a006613159780f3bdecf2cdfe4885e59eeaa0534",
        "patch": "@@ -41,7 +41,7 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool>& asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n@@ -51,7 +51,7 @@ int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap\n     return tried_bucket;\n }\n \n-int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool>& asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n@@ -62,7 +62,7 @@ int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::\n     return new_bucket;\n }\n \n-int AddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int nBucket) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n@@ -190,7 +190,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     int nIds = 0;\n     for (const auto& entry : mapInfo) {\n         mapUnkIds[entry.first] = nIds;\n-        const AddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.nRefCount) {\n             assert(nIds != nNew); // this means nNew was wrong, oh ow\n             s << info;\n@@ -199,7 +199,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     }\n     nIds = 0;\n     for (const auto& entry : mapInfo) {\n-        const AddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.fInTried) {\n             assert(nIds != nTried); // this means nTried was wrong, oh ow\n             s << info;\n@@ -283,7 +283,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     // Deserialize entries from the new table.\n     for (int n = 0; n < nNew; n++) {\n-        AddrInfo &info = mapInfo[n];\n+        AddrInfo& info = mapInfo[n];\n         s >> info;\n         mapAddr[info] = n;\n         info.nRandomPos = vRandom.size();\n@@ -1024,7 +1024,7 @@ size_t AddrManImpl::size() const\n     return vRandom.size();\n }\n \n-bool AddrManImpl::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     LOCK(cs);\n     int nAdd = 0;\n@@ -1038,15 +1038,15 @@ bool AddrManImpl::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source\n     return nAdd > 0;\n }\n \n-void AddrManImpl::Good(const CService &addr, int64_t nTime)\n+void AddrManImpl::Good(const CService& addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Good_(addr, /* test_before_evict */ true, nTime);\n     Check();\n }\n \n-void AddrManImpl::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n@@ -1089,15 +1089,15 @@ std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct,\n     return addresses;\n }\n \n-void AddrManImpl::Connected(const CService &addr, int64_t nTime)\n+void AddrManImpl::Connected(const CService& addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Connected_(addr, nTime);\n     Check();\n }\n \n-void AddrManImpl::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)\n {\n     LOCK(cs);\n     Check();\n@@ -1141,17 +1141,17 @@ size_t AddrMan::size() const\n     return m_impl->size();\n }\n \n-bool AddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     return m_impl->Add(vAddr, source, nTimePenalty);\n }\n \n-void AddrMan::Good(const CService &addr, int64_t nTime)\n+void AddrMan::Good(const CService& addr, int64_t nTime)\n {\n     m_impl->Good(addr, nTime);\n }\n \n-void AddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrMan::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     m_impl->Attempt(addr, fCountFailure, nTime);\n }\n@@ -1176,12 +1176,12 @@ std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std\n     return m_impl->GetAddr(max_addresses, max_pct, network);\n }\n \n-void AddrMan::Connected(const CService &addr, int64_t nTime)\n+void AddrMan::Connected(const CService& addr, int64_t nTime)\n {\n     m_impl->Connected(addr, nTime);\n }\n \n-void AddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)\n {\n     m_impl->SetServices(addr, nServices);\n }"
      },
      {
        "sha": "174ab4f811b0590732f437ed637ecdc8fb020e7d",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=a006613159780f3bdecf2cdfe4885e59eeaa0534",
        "patch": "@@ -70,13 +70,13 @@ class AddrMan\n     size_t size() const;\n \n     //! Add addresses to addrman's new table.\n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n     //! Mark an entry as accessible, possibly moving it from \"new\" to \"tried\".\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime());\n+    void Good(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions();\n@@ -121,10 +121,10 @@ class AddrMan\n      * @param[in]   addr     The address of the peer we were connected to\n      * @param[in]   nTime    The time that we were last connected to this peer\n      */\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime());\n+    void Connected(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Update an entry's service bits.\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void SetServices(const CService& addr, ServiceFlags nServices);\n \n     const std::vector<bool>& GetAsmap() const;\n "
      },
      {
        "sha": "1dc7f25f9c476dc62774c69fd485b88c060ef0ae",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=a006613159780f3bdecf2cdfe4885e59eeaa0534",
        "patch": "@@ -111,29 +111,29 @@ class AddrManImpl\n \n     size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void Good(const CService &addr, int64_t nTime)\n+    void Good(const CService& addr, int64_t nTime)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     std::pair<CAddress, int64_t> SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    std::pair<CAddress, int64_t>  Select(bool newOnly) const\n+    std::pair<CAddress, int64_t> Select(bool newOnly) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void Connected(const CService &addr, int64_t nTime)\n+    void Connected(const CService& addr, int64_t nTime)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void SetServices(const CService &addr, ServiceFlags nServices)\n+    void SetServices(const CService& addr, ServiceFlags nServices)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     const std::vector<bool>& GetAsmap() const;\n@@ -225,10 +225,10 @@ class AddrManImpl\n     const std::vector<bool> m_asmap;\n \n     //! Find an entry.\n-    AddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    AddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -242,19 +242,19 @@ class AddrManImpl\n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n     void MakeTried(AddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void Good_(const CService& addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    bool Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void Attempt_(const CService& addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void SetServices_(const CService& addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      },
      {
        "sha": "bd6f47021956963ea1e88f3279c2fd1d29c9d833",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a006613159780f3bdecf2cdfe4885e59eeaa0534/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=a006613159780f3bdecf2cdfe4885e59eeaa0534",
        "patch": "@@ -83,7 +83,7 @@ class AddrManTest : public AddrMan\n     bool deterministic;\n public:\n     explicit AddrManTest(bool makeDeterministic = true,\n-                          std::vector<bool> asmap = std::vector<bool>())\n+                         std::vector<bool> asmap = std::vector<bool>())\n         : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;"
      }
    ]
  },
  {
    "sha": "cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
    "node_id": "C_kwDOABII59oAKGNiZjFiMTE0ZmQ3OGNjMGUwMDFmOWM1Y2JiZjA5OGRjZGY1Zjg3YTY",
    "commit": {
      "author": {
        "name": "W. J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2021-10-04T22:07:44Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "util: Define SECCOMP_RET_KILL_PROCESS if not provided by the headers\n\nDefine `SECCOMP_RET_KILL_PROCESS` as it isn't defined in the headers, as\nis the case for the GUIX build on this platform.",
      "tree": {
        "sha": "75778d805e8f2f059210191c564ea9290e5e0d3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/75778d805e8f2f059210191c564ea9290e5e0d3e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a006613159780f3bdecf2cdfe4885e59eeaa0534",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a006613159780f3bdecf2cdfe4885e59eeaa0534",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a006613159780f3bdecf2cdfe4885e59eeaa0534"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 4,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9ed8768c01a56a96ffad03bff2f9aa40ea3df016",
        "filename": "src/util/syscall_sandbox.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6/src/util/syscall_sandbox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6/src/util/syscall_sandbox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/syscall_sandbox.cpp?ref=cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
        "patch": "@@ -40,6 +40,10 @@ bool g_syscall_sandbox_log_violation_before_terminating{false};\n #error Syscall sandbox is an experimental feature currently available only under Linux x86-64.\n #endif // defined(__x86_64__)\n \n+#ifndef SECCOMP_RET_KILL_PROCESS\n+#define SECCOMP_RET_KILL_PROCESS 0x80000000U\n+#endif\n+\n // This list of syscalls in LINUX_SYSCALLS is only used to map syscall numbers to syscall names in\n // order to be able to print user friendly error messages which include the syscall name in addition\n // to the syscall number."
      }
    ]
  },
  {
    "sha": "8532e3ff20e9d04987a20346fc3b1aaccdead762",
    "node_id": "C_kwDOABII59oAKDg1MzJlM2ZmMjBlOWQwNDk4N2EyMDM0NmZjM2IxYWFjY2RlYWQ3NjI",
    "commit": {
      "author": {
        "name": "W. J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2021-10-05T06:13:02Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "util: Make sure syscall numbers used in profile are defined\n\nDefine the following syscall numbers for x86_64, so that the profile\nwill be the same no matter what kernel is built against, including\nkernels that don't have `__NR_statx`:\n```c++\n #define __NR_statx 332\n #define __NR_getrandom 318\n #define __NR_membarrier 324\n```",
      "tree": {
        "sha": "75135f800bcc4ebfd06a18748da773e9969077d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/75135f800bcc4ebfd06a18748da773e9969077d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8532e3ff20e9d04987a20346fc3b1aaccdead762",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8532e3ff20e9d04987a20346fc3b1aaccdead762",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8532e3ff20e9d04987a20346fc3b1aaccdead762",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8532e3ff20e9d04987a20346fc3b1aaccdead762/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cbf1b114fd78cc0e001f9c5cbbf098dcdf5f87a6"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 14,
      "deletions": 8
    },
    "files": [
      {
        "sha": "6d62864a4a8c71b78dfb9d476d75b9c73ece7331",
        "filename": "src/util/syscall_sandbox.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8532e3ff20e9d04987a20346fc3b1aaccdead762/src/util/syscall_sandbox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8532e3ff20e9d04987a20346fc3b1aaccdead762/src/util/syscall_sandbox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/syscall_sandbox.cpp?ref=8532e3ff20e9d04987a20346fc3b1aaccdead762",
        "patch": "@@ -44,6 +44,20 @@ bool g_syscall_sandbox_log_violation_before_terminating{false};\n #define SECCOMP_RET_KILL_PROCESS 0x80000000U\n #endif\n \n+// Define system call numbers for x86_64 that are referenced in the system call profile\n+// but not provided by the kernel headers used in the GUIX build.\n+#ifndef __NR_statx\n+#define __NR_statx 332\n+#endif\n+\n+#ifndef __NR_getrandom\n+#define __NR_getrandom 318\n+#endif\n+\n+#ifndef __NR_membarrier\n+#define __NR_membarrier 324\n+#endif\n+\n // This list of syscalls in LINUX_SYSCALLS is only used to map syscall numbers to syscall names in\n // order to be able to print user friendly error messages which include the syscall name in addition\n // to the syscall number.\n@@ -162,9 +176,7 @@ const std::map<uint32_t, std::string> LINUX_SYSCALLS{\n     {__NR_getpmsg, \"getpmsg\"},\n     {__NR_getppid, \"getppid\"},\n     {__NR_getpriority, \"getpriority\"},\n-#if defined(__NR_getrandom)\n     {__NR_getrandom, \"getrandom\"},\n-#endif // defined(__NR_getrandom)\n     {__NR_getresgid, \"getresgid\"},\n     {__NR_getresuid, \"getresuid\"},\n     {__NR_getrlimit, \"getrlimit\"},\n@@ -212,9 +224,7 @@ const std::map<uint32_t, std::string> LINUX_SYSCALLS{\n     {__NR_lstat, \"lstat\"},\n     {__NR_madvise, \"madvise\"},\n     {__NR_mbind, \"mbind\"},\n-#if defined(__NR_membarrier)\n     {__NR_membarrier, \"membarrier\"},\n-#endif // defined(__NR_membarrier)\n     {__NR_memfd_create, \"memfd_create\"},\n     {__NR_migrate_pages, \"migrate_pages\"},\n     {__NR_mincore, \"mincore\"},\n@@ -515,9 +525,7 @@ class SeccompPolicyBuilder\n     {\n         allowed_syscalls.insert(__NR_brk);     // change data segment size\n         allowed_syscalls.insert(__NR_madvise); // give advice about use of memory\n-#if defined(__NR_membarrier)\n         allowed_syscalls.insert(__NR_membarrier); // issue memory barriers on a set of threads\n-#endif // defined(__NR_membarrier)\n         allowed_syscalls.insert(__NR_mlock);    // lock memory\n         allowed_syscalls.insert(__NR_mmap);     // map files or devices into memory\n         allowed_syscalls.insert(__NR_mprotect); // set protection on a region of memory\n@@ -597,9 +605,7 @@ class SeccompPolicyBuilder\n \n     void AllowGetRandom()\n     {\n-#if defined(__NR_getrandom)\n         allowed_syscalls.insert(__NR_getrandom); // obtain a series of random bytes\n-#endif // defined(__NR_getrandom)\n     }\n \n     void AllowGetSimpleId()"
      }
    ]
  },
  {
    "sha": "d90bba86ce709b4b8deff4da43bb04194cfda031",
    "node_id": "C_kwDOABII59oAKGQ5MGJiYTg2Y2U3MDliNGI4ZGVmZjRkYTQzYmIwNDE5NGNmZGEwMzE",
    "commit": {
      "author": {
        "name": "W. J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2021-10-01T19:59:48Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "contrib: Ask for captcha in signet getcoins.py\n\nAs the faucet will always ask for a captcha now, the current script is\nno longer usable.\n\nChange the script to print the captcha in dot-matrix to the terminal,\nusing unicode Braille characters.",
      "tree": {
        "sha": "6265810020e8d02dc860a66ef4dffb113c1f9844",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6265810020e8d02dc860a66ef4dffb113c1f9844"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d90bba86ce709b4b8deff4da43bb04194cfda031",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d90bba86ce709b4b8deff4da43bb04194cfda031",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d90bba86ce709b4b8deff4da43bb04194cfda031",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d90bba86ce709b4b8deff4da43bb04194cfda031/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8532e3ff20e9d04987a20346fc3b1aaccdead762",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8532e3ff20e9d04987a20346fc3b1aaccdead762",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8532e3ff20e9d04987a20346fc3b1aaccdead762"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 91,
      "deletions": 3
    },
    "files": [
      {
        "sha": "3d0aa5d132f095e2046f3ed0a1e380c5833d2dd7",
        "filename": "contrib/signet/getcoins.py",
        "status": "modified",
        "additions": 91,
        "deletions": 3,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d90bba86ce709b4b8deff4da43bb04194cfda031/contrib/signet/getcoins.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d90bba86ce709b4b8deff4da43bb04194cfda031/contrib/signet/getcoins.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/getcoins.py?ref=d90bba86ce709b4b8deff4da43bb04194cfda031",
        "patch": "@@ -4,18 +4,77 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n import argparse\n+import io\n+import requests\n import subprocess\n import sys\n-import requests\n \n DEFAULT_GLOBAL_FAUCET = 'https://signetfaucet.com/claim'\n+DEFAULT_GLOBAL_CAPTCHA = 'https://signetfaucet.com/captcha'\n GLOBAL_FIRST_BLOCK_HASH = '00000086d6b2636cb2a392d45edc4ec544a10024d30141c9adf4bfd9de533b53'\n \n+# braille unicode block\n+BASE = 0x2800\n+BIT_PER_PIXEL = [\n+    [0x01, 0x08],\n+    [0x02, 0x10],\n+    [0x04, 0x20],\n+    [0x40, 0x80],\n+]\n+BW = 2\n+BH = 4\n+\n+# imagemagick or compatible fork (used for converting SVG)\n+CONVERT = 'convert'\n+\n+class PPMImage:\n+    '''\n+    Load a PPM image (Pillow-ish API).\n+    '''\n+    def __init__(self, f):\n+        if f.readline() != b'P6\\n':\n+            raise ValueError('Invalid ppm format: header')\n+        line = f.readline()\n+        (width, height) = (int(x) for x in line.rstrip().split(b' '))\n+        if f.readline() != b'255\\n':\n+            raise ValueError('Invalid ppm format: color depth')\n+        data = f.read(width * height * 3)\n+        stride = width * 3\n+        self.size = (width, height)\n+        self._grid = [[tuple(data[stride * y + 3 * x:stride * y + 3 * (x + 1)]) for x in range(width)] for y in range(height)]\n+\n+    def getpixel(self, pos):\n+        return self._grid[pos[1]][pos[0]]\n+\n+def print_image(img, threshold=128):\n+    '''Print black-and-white image to terminal in braille unicode characters.'''\n+    x_blocks = (img.size[0] + BW - 1) // BW\n+    y_blocks = (img.size[1] + BH - 1) // BH\n+\n+    for yb in range(y_blocks):\n+        line = []\n+        for xb in range(x_blocks):\n+            ch = BASE\n+            for y in range(BH):\n+                for x in range(BW):\n+                    try:\n+                        val = img.getpixel((xb * BW + x, yb * BH + y))\n+                    except IndexError:\n+                        pass\n+                    else:\n+                        if val[0] < threshold:\n+                            ch |= BIT_PER_PIXEL[y][x]\n+            line.append(chr(ch))\n+        print(''.join(line))\n+\n parser = argparse.ArgumentParser(description='Script to get coins from a faucet.', epilog='You may need to start with double-dash (--) when providing bitcoin-cli arguments.')\n parser.add_argument('-c', '--cmd', dest='cmd', default='bitcoin-cli', help='bitcoin-cli command to use')\n parser.add_argument('-f', '--faucet', dest='faucet', default=DEFAULT_GLOBAL_FAUCET, help='URL of the faucet')\n+parser.add_argument('-g', '--captcha', dest='captcha', default=DEFAULT_GLOBAL_CAPTCHA, help='URL of the faucet captcha, or empty if no captcha is needed')\n parser.add_argument('-a', '--addr', dest='addr', default='', help='Bitcoin address to which the faucet should send')\n parser.add_argument('-p', '--password', dest='password', default='', help='Faucet password, if any')\n+parser.add_argument('-n', '--amount', dest='amount', default='0.001', help='Amount to request (0.001-0.1, default is 0.001)')\n+parser.add_argument('-i', '--imagemagick', dest='imagemagick', default=CONVERT, help='Path to imagemagick convert utility')\n parser.add_argument('bitcoin_cli_args', nargs='*', help='Arguments to pass on to bitcoin-cli (default: -signet)')\n \n args = parser.parse_args()\n@@ -43,14 +102,43 @@ def bitcoin_cli(rpc_command_and_params):\n     if curr_signet_hash != GLOBAL_FIRST_BLOCK_HASH:\n         print('The global faucet cannot be used with a custom Signet network. Please use the global signet or setup your custom faucet to use this functionality.\\n')\n         exit(1)\n+else:\n+    # For custom faucets, don't request captcha by default.\n+    if args.captcha == DEFAULT_GLOBAL_CAPTCHA:\n+        args.captcha = ''\n \n if args.addr == '':\n     # get address for receiving coins\n     args.addr = bitcoin_cli(['getnewaddress', 'faucet', 'bech32'])\n \n-data = {'address': args.addr, 'password': args.password}\n+data = {'address': args.addr, 'password': args.password, 'amount': args.amount}\n+\n+# Store cookies\n+# for debugging: print(session.cookies.get_dict())\n+session = requests.Session()\n+\n+if args.captcha != '': # Retrieve a captcha\n+    try:\n+        res = session.get(args.captcha)\n+    except:\n+        print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n+        exit(1)\n+\n+    # Convert SVG image to PPM, and load it\n+    try:\n+        rv = subprocess.run([args.imagemagick, '-', '-depth', '8', 'ppm:-'], input=res.content, check=True, capture_output=True)\n+    except FileNotFoundError:\n+        print('The binary', args.imagemagick, 'could not be found. Please make sure ImageMagick (or a compatible fork) is installed and that the correct path is specified.')\n+        exit(1)\n+    img = PPMImage(io.BytesIO(rv.stdout))\n+\n+    # Terminal interaction\n+    print_image(img)\n+    print('Enter captcha: ', end='')\n+    data['captcha'] = input()\n+\n try:\n-    res = requests.post(args.faucet, data=data)\n+    res = session.post(args.faucet, data=data)\n except:\n     print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n     exit(1)"
      }
    ]
  },
  {
    "sha": "6eaed606a861ec08aff21afdb78848b52b41e532",
    "node_id": "C_kwDOABII59oAKDZlYWVkNjA2YTg2MWVjMDhhZmYyMWFmZGI3ODg0OGI1MmI0MWU1MzI",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:26:52Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:30:39Z"
      },
      "message": "Remove encoding from fileinput.input()",
      "tree": {
        "sha": "9026a6ca05bc86525499a961de02f00bf6a44ae0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9026a6ca05bc86525499a961de02f00bf6a44ae0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6eaed606a861ec08aff21afdb78848b52b41e532",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6eaed606a861ec08aff21afdb78848b52b41e532",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6eaed606a861ec08aff21afdb78848b52b41e532",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6eaed606a861ec08aff21afdb78848b52b41e532/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d90bba86ce709b4b8deff4da43bb04194cfda031",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d90bba86ce709b4b8deff4da43bb04194cfda031",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d90bba86ce709b4b8deff4da43bb04194cfda031"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "faabb8d03ef3e8032dd36b3a1c7d05022d721652",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eaed606a861ec08aff21afdb78848b52b41e532/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eaed606a861ec08aff21afdb78848b52b41e532/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=6eaed606a861ec08aff21afdb78848b52b41e532",
        "patch": "@@ -80,7 +80,7 @@ def find_between( s, first, last ):\n     version = config_dict[\"PACKAGE_VERSION\"].strip('\"')\n     config_dict[\"PACKAGE_STRING\"] = f\"\\\"Bitcoin Core {version}\\\"\"\n \n-    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h', ), inplace=True, encoding=\"utf8\"):\n+    for line in fileinput.input(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h', ), inplace=True):\n         header = \"\"\n         if line.startswith(\"#define\"):\n             header = line.split(\" \")[1]\n@@ -112,7 +112,7 @@ def main():\n             with open(vcxproj_filename, 'w', encoding='utf-8') as vcxproj_file:\n                 vcxproj_file.write(vcxproj_in_file.read().replace(\n                     '@SOURCE_FILES@\\n', content))\n-                    \n+\n     parse_config_into_btc_config()\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/bitcoin_config.h'), os.path.join(SOURCE_DIR, 'config/bitcoin-config.h'))\n     copyfile(os.path.join(SOURCE_DIR,'../build_msvc/libsecp256k1_config.h'), os.path.join(SOURCE_DIR, 'secp256k1/src/libsecp256k1-config.h'))"
      }
    ]
  },
  {
    "sha": "b29952bbc2bbd809e5148a04213972258d196ef0",
    "node_id": "C_kwDOABII59oAKGIyOTk1MmJiYzJiYmQ4MDllNTE0OGEwNDIxMzk3MjI1OGQxOTZlZjA",
    "commit": {
      "author": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:31:05Z"
      },
      "committer": {
        "name": "CallMeMisterOwl",
        "email": "denizhasler@outlook.de",
        "date": "2021-10-05T20:31:05Z"
      },
      "message": "Merge branch 'auto_gen_MSVC_issue' of https://github.com/CallMeMisterOwl/bitcoin into auto_gen_MSVC_issue\nmerge",
      "tree": {
        "sha": "9026a6ca05bc86525499a961de02f00bf6a44ae0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9026a6ca05bc86525499a961de02f00bf6a44ae0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b29952bbc2bbd809e5148a04213972258d196ef0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b29952bbc2bbd809e5148a04213972258d196ef0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b29952bbc2bbd809e5148a04213972258d196ef0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b29952bbc2bbd809e5148a04213972258d196ef0/comments",
    "author": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "CallMeMisterOwl",
      "id": 51458033,
      "node_id": "MDQ6VXNlcjUxNDU4MDMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/51458033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CallMeMisterOwl",
      "html_url": "https://github.com/CallMeMisterOwl",
      "followers_url": "https://api.github.com/users/CallMeMisterOwl/followers",
      "following_url": "https://api.github.com/users/CallMeMisterOwl/following{/other_user}",
      "gists_url": "https://api.github.com/users/CallMeMisterOwl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CallMeMisterOwl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CallMeMisterOwl/subscriptions",
      "organizations_url": "https://api.github.com/users/CallMeMisterOwl/orgs",
      "repos_url": "https://api.github.com/users/CallMeMisterOwl/repos",
      "events_url": "https://api.github.com/users/CallMeMisterOwl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CallMeMisterOwl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6eaed606a861ec08aff21afdb78848b52b41e532",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6eaed606a861ec08aff21afdb78848b52b41e532",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6eaed606a861ec08aff21afdb78848b52b41e532"
      },
      {
        "sha": "0b1a129f2c05a1622ec02b9dab7a316586539723",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b1a129f2c05a1622ec02b9dab7a316586539723",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0b1a129f2c05a1622ec02b9dab7a316586539723"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  }
]