[
  {
    "sha": "a0d8cff498eddbbf560b3853864d73f2d100d23e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMGQ4Y2ZmNDk4ZWRkYmJmNTYwYjM4NTM4NjRkNzNmMmQxMDBkMjNl",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-09-07T10:11:00Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-09-07T10:18:20Z"
      },
      "message": "Skip selecting collisions in feeler iterations\n\nIf we're going to connect to a feeler (as decided by a timer),\nwe should not \"waste\" this iteration on connecting to a collision.\nThe collisions belong to the \"tried\" table, so connecting to them\ndon't accomplish the goal of feelers.",
      "tree": {
        "sha": "9127066999ee29182d42a3a2364be23077c2464c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9127066999ee29182d42a3a2364be23077c2464c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a0d8cff498eddbbf560b3853864d73f2d100d23e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0d8cff498eddbbf560b3853864d73f2d100d23e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a0d8cff498eddbbf560b3853864d73f2d100d23e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0d8cff498eddbbf560b3853864d73f2d100d23e/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "78cb45d72251e85db07e8500bbdd2e9460b132b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78cb45d72251e85db07e8500bbdd2e9460b132b2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/78cb45d72251e85db07e8500bbdd2e9460b132b2"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 15,
      "deletions": 5
    },
    "files": [
      {
        "sha": "6e44deb99c4564e3498d760e7b178f686e170a46",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 5,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0d8cff498eddbbf560b3853864d73f2d100d23e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0d8cff498eddbbf560b3853864d73f2d100d23e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a0d8cff498eddbbf560b3853864d73f2d100d23e",
        "patch": "@@ -1924,11 +1924,21 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         int nTries = 0;\n         while (!interruptNet)\n         {\n-            CAddrInfo addr = addrman.SelectTriedCollision();\n-\n-            // SelectTriedCollision returns an invalid address if it is empty.\n-            if (!fFeeler || !addr.IsValid()) {\n-                addr = addrman.Select(fFeeler);\n+            CAddrInfo addr;\n+\n+            // For non-feeler connections, attempt to connect to an address among the collisions\n+            // in our \"tried\" table.\n+            // For feelers iterations, since feelers should be selected from the \"new\" table in the AddrMan,\n+            // skip selecting collisions.\n+            if (!fFeeler) {\n+                // SelectTriedCollision returns an invalid address if it is empty.\n+                addr = addrman.SelectTriedCollision();\n+                if (!addr.IsValid()) {\n+                    // If no collisions, consider an address from the \"tried\" table.\n+                    addr = addrman.Select(true);\n+                }\n+            } else {\n+                addr = addrman.Select(false);\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups"
      }
    ]
  },
  {
    "sha": "0c3e80db428493857f63de5a3ecf3866448fb824",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzNlODBkYjQyODQ5Mzg1N2Y2M2RlNWEzZWNmMzg2NjQ0OGZiODI0",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-09-07T10:37:31Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-09-07T10:37:31Z"
      },
      "message": "Refactor code around feeler connection",
      "tree": {
        "sha": "d83b0b8c44d45872bbc75bcdf40eb6c214883505",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d83b0b8c44d45872bbc75bcdf40eb6c214883505"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c3e80db428493857f63de5a3ecf3866448fb824",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c3e80db428493857f63de5a3ecf3866448fb824",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c3e80db428493857f63de5a3ecf3866448fb824",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c3e80db428493857f63de5a3ecf3866448fb824/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a0d8cff498eddbbf560b3853864d73f2d100d23e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0d8cff498eddbbf560b3853864d73f2d100d23e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a0d8cff498eddbbf560b3853864d73f2d100d23e"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "3709f78388200afc0922c553fc4618c7fc4aa591",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c3e80db428493857f63de5a3ecf3866448fb824/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c3e80db428493857f63de5a3ecf3866448fb824/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=0c3e80db428493857f63de5a3ecf3866448fb824",
        "patch": "@@ -1892,7 +1892,6 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n \n         ConnectionType conn_type = ConnectionType::OUTBOUND_FULL_RELAY;\n         int64_t nTime = GetTimeMicros();\n-        bool fFeeler = false;\n \n         // Determine what type of connection to open. Opening\n         // OUTBOUND_FULL_RELAY connections gets the highest priority until we\n@@ -1912,7 +1911,6 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         } else if (nTime > nNextFeeler) {\n             nNextFeeler = PoissonNextSend(nTime, FEELER_INTERVAL);\n             conn_type = ConnectionType::FEELER;\n-            fFeeler = true;\n         } else {\n             // skip to next iteration of while loop\n             continue;\n@@ -1930,22 +1928,24 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             // in our \"tried\" table.\n             // For feelers iterations, since feelers should be selected from the \"new\" table in the AddrMan,\n             // skip selecting collisions.\n-            if (!fFeeler) {\n+            // Also require non-feelers to be distinct network groups to preserve connection diversity.\n+            // It's much less relevant for feelers, because it's a frequent procedure\n+            // to sanitize AddrMan (not critical), and selecting from AddrMan is\n+            // sufficiently (for this case) random/difficult-to-Sybil due to the bucketing.\n+            if (conn_type != ConnectionType::FEELER) {\n                 // SelectTriedCollision returns an invalid address if it is empty.\n                 addr = addrman.SelectTriedCollision();\n                 if (!addr.IsValid()) {\n                     // If no collisions, consider an address from the \"tried\" table.\n                     addr = addrman.Select(true);\n                 }\n+                if (setConnected.count(addr.GetGroup(addrman.m_asmap))) {\n+                    break;\n+                }\n             } else {\n                 addr = addrman.Select(false);\n             }\n \n-            // Require outbound connections, other than feelers, to be to distinct network groups\n-            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.m_asmap))) {\n-                break;\n-            }\n-\n             // if we selected an invalid or local address, restart\n             if (!addr.IsValid() || IsLocal(addr)) {\n                 break;\n@@ -1968,9 +1968,9 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             // for non-feelers, require all the services we'll want,\n             // for feelers, only require they be a full node (only because most\n             // SPV clients don't have a good address DB available)\n-            if (!fFeeler && !HasAllDesirableServiceFlags(addr.nServices)) {\n+            if (conn_type != ConnectionType::FEELER && !HasAllDesirableServiceFlags(addr.nServices)) {\n                 continue;\n-            } else if (fFeeler && !MayHaveUsefulAddressDB(addr.nServices)) {\n+            } else if (conn_type == ConnectionType::FEELER && !MayHaveUsefulAddressDB(addr.nServices)) {\n                 continue;\n             }\n \n@@ -1984,7 +1984,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n \n         if (addrConnect.IsValid()) {\n \n-            if (fFeeler) {\n+            if (conn_type == ConnectionType::FEELER) {\n                 // Add small amount of random noise before connection to avoid synchronization.\n                 int randsleep = GetRandInt(FEELER_SLEEP_WINDOW * 1000);\n                 if (!interruptNet.sleep_for(std::chrono::milliseconds(randsleep)))"
      }
    ]
  }
]