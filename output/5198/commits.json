[
  {
    "sha": "1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYzBhYTkxMTBlMGNiZTIwN2YxNmU4YmYyY2M2YzQxMGI5ZWMxY2Vm",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-31T03:34:30Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-31T05:07:05Z"
      },
      "message": "Update serialize comments to be doxygen compatible",
      "tree": {
        "sha": "8c335dacd99fb1419fa34801de7ec88d07d1ad11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c335dacd99fb1419fa34801de7ec88d07d1ad11"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8d2396c9c41cbd5b8746f48f41180697f58b0681",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d2396c9c41cbd5b8746f48f41180697f58b0681",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d2396c9c41cbd5b8746f48f41180697f58b0681"
      }
    ],
    "stats": {
      "total": 178,
      "additions": 100,
      "deletions": 78
    },
    "files": [
      {
        "sha": "ad38a3fa22a181ec636a24005610c36bd00bf1d4",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 100,
        "deletions": 78,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=1c0aa9110e0cbe207f16e8bf2cc6c410b9ec1cef",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_SERIALIZE_H\n@@ -22,23 +22,28 @@ class CScript;\n \n static const unsigned int MAX_SIZE = 0x02000000;\n \n-// Used to bypass the rule against non-const reference to temporary\n-// where it makes sense with wrappers such as CFlatData or CTxDB\n+/**\n+ * Used to bypass the rule against non-const reference to temporary\n+ * where it makes sense with wrappers such as CFlatData or CTxDB\n+ */\n template<typename T>\n inline T& REF(const T& val)\n {\n     return const_cast<T&>(val);\n }\n \n-// Used to acquire a non-const pointer \"this\" to generate bodies\n-// of const serialization operations from a template\n+/**\n+ * Used to acquire a non-const pointer \"this\" to generate bodies\n+ * of const serialization operations from a template\n+ */\n template<typename T>\n inline T* NCONST_PTR(const T* val)\n {\n     return const_cast<T*>(val);\n }\n \n-/** Get begin pointer of vector (non-const version).\n+/** \n+ * Get begin pointer of vector (non-const version).\n  * @note These functions avoid the undefined case of indexing into an empty\n  * vector, as well as that of indexing after the end of the vector.\n  */\n@@ -82,10 +87,12 @@ enum\n \n #define READWRITE(obj)      (::SerReadWrite(s, (obj), nType, nVersion, ser_action))\n \n-/* Implement three methods for serializable objects. These are actually wrappers over\n+/** \n+ * Implement three methods for serializable objects. These are actually wrappers over\n  * \"SerializationOp\" template, which implements the body of each class' serialization\n  * code. Adding \"ADD_SERIALIZE_METHODS\" in the body of the class causes these wrappers to be\n- * added as members. */\n+ * added as members. \n+ */\n #define ADD_SERIALIZE_METHODS                                                          \\\n     size_t GetSerializeSize(int nType, int nVersion) const {                         \\\n         CSizeComputer s(nType, nVersion);                                            \\\n@@ -103,9 +110,9 @@ enum\n \n \n \n-//\n-// Basic types\n-//\n+/*\n+ * Basic Types\n+ */\n #define WRITEDATA(s, obj)   s.write((char*)&(obj), sizeof(obj))\n #define READDATA(s, obj)    s.read((char*)&(obj), sizeof(obj))\n \n@@ -160,13 +167,13 @@ template<typename Stream> inline void Unserialize(Stream& s, bool& a, int, int=0\n \n \n \n-//\n-// Compact size\n-//  size <  253        -- 1 byte\n-//  size <= USHRT_MAX  -- 3 bytes  (253 + 2 bytes)\n-//  size <= UINT_MAX   -- 5 bytes  (254 + 4 bytes)\n-//  size >  UINT_MAX   -- 9 bytes  (255 + 8 bytes)\n-//\n+/**\n+ * Compact Size\n+ * size <  253        -- 1 byte\n+ * size <= USHRT_MAX  -- 3 bytes  (253 + 2 bytes)\n+ * size <= UINT_MAX   -- 5 bytes  (254 + 4 bytes)\n+ * size >  UINT_MAX   -- 9 bytes  (255 + 8 bytes)\n+ */\n inline unsigned int GetSizeOfCompactSize(uint64_t nSize)\n {\n     if (nSize < 253)             return sizeof(unsigned char);\n@@ -246,27 +253,29 @@ uint64_t ReadCompactSize(Stream& is)\n     return nSizeRet;\n }\n \n-// Variable-length integers: bytes are a MSB base-128 encoding of the number.\n-// The high bit in each byte signifies whether another digit follows. To make\n-// the encoding is one-to-one, one is subtracted from all but the last digit.\n-// Thus, the byte sequence a[] with length len, where all but the last byte\n-// has bit 128 set, encodes the number:\n-//\n-//   (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n-//\n-// Properties:\n-// * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n-// * Every integer has exactly one encoding\n-// * Encoding does not depend on size of original integer type\n-// * No redundancy: every (infinite) byte sequence corresponds to a list\n-//   of encoded integers.\n-//\n-// 0:         [0x00]  256:        [0x81 0x00]\n-// 1:         [0x01]  16383:      [0xFE 0x7F]\n-// 127:       [0x7F]  16384:      [0xFF 0x00]\n-// 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n-// 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n-// 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+/**\n+ * Variable-length integers: bytes are a MSB base-128 encoding of the number.\n+ * The high bit in each byte signifies whether another digit follows. To make\n+ * sure the encoding is one-to-one, one is subtracted from all but the last digit.\n+ * Thus, the byte sequence a[] with length len, where all but the last byte\n+ * has bit 128 set, encodes the number:\n+ * \n+ *  (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n+ * \n+ * Properties:\n+ * * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n+ * * Every integer has exactly one encoding\n+ * * Encoding does not depend on size of original integer type\n+ * * No redundancy: every (infinite) byte sequence corresponds to a list\n+ *   of encoded integers.\n+ * \n+ * 0:         [0x00]  256:        [0x81 0x00]\n+ * 1:         [0x01]  16383:      [0xFE 0x7F]\n+ * 127:       [0x7F]  16384:      [0xFF 0x00]\n+ * 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n+ * 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n+ * 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+ */\n \n template<typename I>\n inline unsigned int GetSizeOfVarInt(I n)\n@@ -317,7 +326,8 @@ I ReadVarInt(Stream& is)\n #define VARINT(obj) REF(WrapVarInt(REF(obj)))\n #define LIMITED_STRING(obj,n) REF(LimitedString< n >(REF(obj)))\n \n-/** Wrapper for serializing arrays and POD.\n+/** \n+ * Wrapper for serializing arrays and POD.\n  */\n class CFlatData\n {\n@@ -415,17 +425,21 @@ class LimitedString\n template<typename I>\n CVarInt<I> WrapVarInt(I& n) { return CVarInt<I>(n); }\n \n-//\n-// Forward declarations\n-//\n+/**\n+ * Forward declarations\n+ */\n \n-// string\n+/**\n+ *  string\n+ */\n template<typename C> unsigned int GetSerializeSize(const std::basic_string<C>& str, int, int=0);\n template<typename Stream, typename C> void Serialize(Stream& os, const std::basic_string<C>& str, int, int=0);\n template<typename Stream, typename C> void Unserialize(Stream& is, std::basic_string<C>& str, int, int=0);\n \n-// vector\n-// vectors of unsigned char are a special case and are intended to be serialized as a single opaque blob.\n+/**\n+ * vector\n+ * vectors of unsigned char are a special case and are intended to be serialized as a single opaque blob.\n+ */\n template<typename T, typename A> unsigned int GetSerializeSize_impl(const std::vector<T, A>& v, int nType, int nVersion, const unsigned char&);\n template<typename T, typename A, typename V> unsigned int GetSerializeSize_impl(const std::vector<T, A>& v, int nType, int nVersion, const V&);\n template<typename T, typename A> inline unsigned int GetSerializeSize(const std::vector<T, A>& v, int nType, int nVersion);\n@@ -436,22 +450,30 @@ template<typename Stream, typename T, typename A> void Unserialize_impl(Stream&\n template<typename Stream, typename T, typename A, typename V> void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion, const V&);\n template<typename Stream, typename T, typename A> inline void Unserialize(Stream& is, std::vector<T, A>& v, int nType, int nVersion);\n \n-// others derived from vector\n+/**\n+ * others derived from vector\n+ */\n extern inline unsigned int GetSerializeSize(const CScript& v, int nType, int nVersion);\n template<typename Stream> void Serialize(Stream& os, const CScript& v, int nType, int nVersion);\n template<typename Stream> void Unserialize(Stream& is, CScript& v, int nType, int nVersion);\n \n-// pair\n+/**\n+ * pair\n+ */\n template<typename K, typename T> unsigned int GetSerializeSize(const std::pair<K, T>& item, int nType, int nVersion);\n template<typename Stream, typename K, typename T> void Serialize(Stream& os, const std::pair<K, T>& item, int nType, int nVersion);\n template<typename Stream, typename K, typename T> void Unserialize(Stream& is, std::pair<K, T>& item, int nType, int nVersion);\n \n-// map\n+/**\n+ * map\n+ */\n template<typename K, typename T, typename Pred, typename A> unsigned int GetSerializeSize(const std::map<K, T, Pred, A>& m, int nType, int nVersion);\n template<typename Stream, typename K, typename T, typename Pred, typename A> void Serialize(Stream& os, const std::map<K, T, Pred, A>& m, int nType, int nVersion);\n template<typename Stream, typename K, typename T, typename Pred, typename A> void Unserialize(Stream& is, std::map<K, T, Pred, A>& m, int nType, int nVersion);\n \n-// set\n+/**\n+ * set\n+ */\n template<typename K, typename Pred, typename A> unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion);\n template<typename Stream, typename K, typename Pred, typename A> void Serialize(Stream& os, const std::set<K, Pred, A>& m, int nType, int nVersion);\n template<typename Stream, typename K, typename Pred, typename A> void Unserialize(Stream& is, std::set<K, Pred, A>& m, int nType, int nVersion);\n@@ -460,12 +482,12 @@ template<typename Stream, typename K, typename Pred, typename A> void Unserializ\n \n \n \n-//\n-// If none of the specialized versions above matched, default to calling member function.\n-// \"int nType\" is changed to \"long nType\" to keep from getting an ambiguous overload error.\n-// The compiler will only cast int to long if none of the other templates matched.\n-// Thanks to Boost serialization for this idea.\n-//\n+/**\n+ * If none of the specialized versions above matched, default to calling member function.\n+ * \"int nType\" is changed to \"long nType\" to keep from getting an ambiguous overload error.\n+ * The compiler will only cast int to long if none of the other templates matched.\n+ * Thanks to Boost serialization for this idea.\n+ */\n template<typename T>\n inline unsigned int GetSerializeSize(const T& a, long nType, int nVersion)\n {\n@@ -488,9 +510,9 @@ inline void Unserialize(Stream& is, T& a, long nType, int nVersion)\n \n \n \n-//\n-// string\n-//\n+/**\n+ * string\n+ */\n template<typename C>\n unsigned int GetSerializeSize(const std::basic_string<C>& str, int, int)\n {\n@@ -516,9 +538,9 @@ void Unserialize(Stream& is, std::basic_string<C>& str, int, int)\n \n \n \n-//\n-// vector\n-//\n+/**\n+ * vector\n+ */\n template<typename T, typename A>\n unsigned int GetSerializeSize_impl(const std::vector<T, A>& v, int nType, int nVersion, const unsigned char&)\n {\n@@ -606,9 +628,9 @@ inline void Unserialize(Stream& is, std::vector<T, A>& v, int nType, int nVersio\n \n \n \n-//\n-// others derived from vector\n-//\n+/**\n+ * others derived from vector\n+ */\n inline unsigned int GetSerializeSize(const CScript& v, int nType, int nVersion)\n {\n     return GetSerializeSize((const std::vector<unsigned char>&)v, nType, nVersion);\n@@ -628,9 +650,9 @@ void Unserialize(Stream& is, CScript& v, int nType, int nVersion)\n \n \n \n-//\n-// pair\n-//\n+/**\n+ * pair\n+ */\n template<typename K, typename T>\n unsigned int GetSerializeSize(const std::pair<K, T>& item, int nType, int nVersion)\n {\n@@ -653,9 +675,9 @@ void Unserialize(Stream& is, std::pair<K, T>& item, int nType, int nVersion)\n \n \n \n-//\n-// map\n-//\n+/**\n+ * map\n+ */\n template<typename K, typename T, typename Pred, typename A>\n unsigned int GetSerializeSize(const std::map<K, T, Pred, A>& m, int nType, int nVersion)\n {\n@@ -689,9 +711,9 @@ void Unserialize(Stream& is, std::map<K, T, Pred, A>& m, int nType, int nVersion\n \n \n \n-//\n-// set\n-//\n+/**\n+ * set\n+ */\n template<typename K, typename Pred, typename A>\n unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n {\n@@ -725,9 +747,9 @@ void Unserialize(Stream& is, std::set<K, Pred, A>& m, int nType, int nVersion)\n \n \n \n-//\n-// Support for ADD_SERIALIZE_METHODS and READWRITE macro\n-//\n+/**\n+ * Support for ADD_SERIALIZE_METHODS and READWRITE macro\n+ */\n struct CSerActionSerialize\n {\n     bool ForRead() const { return false; }"
      }
    ]
  }
]