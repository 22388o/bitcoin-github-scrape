[
  {
    "sha": "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzdiOTMyNGNhM2YzZmZiMTc4YmVhNTZhOTZlYTIzZjdlMDM4M2Ni",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-15T23:49:18Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-18T18:58:32Z"
      },
      "message": "Pure python EC\n\nThis removes the dependency on OpenSSL for the interaction tests, by providing a pure-Python\ntoy implementation of secp256k1.",
      "tree": {
        "sha": "f25be12fbce29ce778be82f779f0d40c1d3b0b3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f25be12fbce29ce778be82f779f0d40c1d3b0b3c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "598323911e930d67e678e464353eb570ad3bf2b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/598323911e930d67e678e464353eb570ad3bf2b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/598323911e930d67e678e464353eb570ad3bf2b7"
      }
    ],
    "stats": {
      "total": 573,
      "additions": 346,
      "deletions": 227
    },
    "files": [
      {
        "sha": "b7814bf33e5d4f7039478802591f6ae4e01ef09a",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "patch": "@@ -32,7 +32,7 @@\n import time\n \n from test_framework.blocktools import (create_block, create_coinbase)\n-from test_framework.key import CECKey\n+from test_framework.key import ECKey\n from test_framework.messages import (\n     CBlockHeader,\n     COutPoint,\n@@ -104,9 +104,9 @@ def run_test(self):\n         self.blocks = []\n \n         # Get a pubkey for the coinbase TXO\n-        coinbase_key = CECKey()\n-        coinbase_key.set_secretbytes(b\"horsebattery\")\n-        coinbase_pubkey = coinbase_key.get_pubkey()\n+        coinbase_key = ECKey()\n+        coinbase_key.generate()\n+        coinbase_pubkey = coinbase_key.get_pubkey().get_bytes()\n \n         # Create the first block with a coinbase output to our key\n         height = 1"
      },
      {
        "sha": "61f705e239c0ebc8319438c2c1001fcbeaa4382b",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "patch": "@@ -14,7 +14,7 @@\n     get_legacy_sigopcount_block,\n     MAX_BLOCK_SIGOPS,\n )\n-from test_framework.key import CECKey\n+from test_framework.key import ECKey\n from test_framework.messages import (\n     CBlock,\n     COIN,\n@@ -86,9 +86,9 @@ def run_test(self):\n         self.bootstrap_p2p()  # Add one p2p connection to the node\n \n         self.block_heights = {}\n-        self.coinbase_key = CECKey()\n-        self.coinbase_key.set_secretbytes(b\"horsebattery\")\n-        self.coinbase_pubkey = self.coinbase_key.get_pubkey()\n+        self.coinbase_key = ECKey()\n+        self.coinbase_key.generate()\n+        self.coinbase_pubkey = self.coinbase_key.get_pubkey().get_bytes()\n         self.tip = None\n         self.blocks = {}\n         self.genesis_hash = int(self.nodes[0].getbestblockhash(), 16)\n@@ -528,7 +528,7 @@ def run_test(self):\n             tx.vin.append(CTxIn(COutPoint(b39.vtx[i].sha256, 0), b''))\n             # Note: must pass the redeem_script (not p2sh_script) to the signature hash function\n             (sighash, err) = SignatureHash(redeem_script, tx, 1, SIGHASH_ALL)\n-            sig = self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))\n+            sig = self.coinbase_key.sign_ecdsa(sighash) + bytes(bytearray([SIGHASH_ALL]))\n             scriptSig = CScript([sig, redeem_script])\n \n             tx.vin[1].scriptSig = scriptSig\n@@ -1284,7 +1284,7 @@ def sign_tx(self, tx, spend_tx):\n             tx.vin[0].scriptSig = CScript()\n             return\n         (sighash, err) = SignatureHash(spend_tx.vout[0].scriptPubKey, tx, 0, SIGHASH_ALL)\n-        tx.vin[0].scriptSig = CScript([self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n+        tx.vin[0].scriptSig = CScript([self.coinbase_key.sign_ecdsa(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n \n     def create_and_sign_transaction(self, spend_tx, value, script=CScript([OP_TRUE])):\n         tx = self.create_tx(spend_tx, 0, value, script)"
      },
      {
        "sha": "0a53ceee862093d42617459ecf5955beddd4c370",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 11,
        "deletions": 12,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "patch": "@@ -9,7 +9,7 @@\n import time\n \n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, get_witness_script, WITNESS_COMMITMENT_HEADER\n-from test_framework.key import CECKey, CPubKey\n+from test_framework.key import ECKey\n from test_framework.messages import (\n     BIP125_SEQUENCE_NUMBER,\n     CBlock,\n@@ -100,7 +100,7 @@ def get_p2pkh_script(pubkeyhash):\n def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n     \"\"\"Add signature for a P2PK witness program.\"\"\"\n     tx_hash = SegwitVersion1SignatureHash(script, tx_to, in_idx, hashtype, value)\n-    signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n+    signature = key.sign_ecdsa(tx_hash) + chr(hashtype).encode('latin-1')\n     tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n     tx_to.rehash()\n \n@@ -1479,10 +1479,9 @@ def test_uncompressed_pubkey(self):\n \n         # Segwit transactions using uncompressed pubkeys are not accepted\n         # under default policy, but should still pass consensus.\n-        key = CECKey()\n-        key.set_secretbytes(b\"9\")\n-        key.set_compressed(False)\n-        pubkey = CPubKey(key.get_pubkey())\n+        key = ECKey()\n+        key.generate(False)\n+        pubkey = key.get_pubkey().get_bytes()\n         assert_equal(len(pubkey), 65)  # This should be an uncompressed pubkey\n \n         utxo = self.utxo.pop(0)\n@@ -1512,7 +1511,7 @@ def test_uncompressed_pubkey(self):\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_wsh))\n         script = get_p2pkh_script(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n-        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n+        signature = key.sign_ecdsa(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n         tx2.rehash()\n@@ -1566,7 +1565,7 @@ def test_uncompressed_pubkey(self):\n         tx5.vin.append(CTxIn(COutPoint(tx4.sha256, 0), b\"\"))\n         tx5.vout.append(CTxOut(tx4.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         (sig_hash, err) = SignatureHash(script_pubkey, tx5, 0, SIGHASH_ALL)\n-        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n+        signature = key.sign_ecdsa(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n         tx5.vin[0].scriptSig = CScript([signature, pubkey])\n         tx5.rehash()\n         # Should pass policy and consensus.\n@@ -1579,9 +1578,9 @@ def test_uncompressed_pubkey(self):\n     @subtest\n     def test_signature_version_1(self):\n \n-        key = CECKey()\n-        key.set_secretbytes(b\"9\")\n-        pubkey = CPubKey(key.get_pubkey())\n+        key = ECKey()\n+        key.generate()\n+        pubkey = key.get_pubkey().get_bytes()\n \n         witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n         witness_hash = sha256(witness_program)\n@@ -1716,7 +1715,7 @@ def test_signature_version_1(self):\n \n         script = get_p2pkh_script(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n-        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n+        signature = key.sign_ecdsa(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n \n         # Check that we can't have a scriptSig\n         tx2.vin[0].scriptSig = CScript([signature, pubkey])"
      },
      {
        "sha": "996de5f94fbf02b501c776f04a4bd49479a2922f",
        "filename": "test/functional/test_framework/key.py",
        "status": "modified",
        "additions": 324,
        "deletions": 204,
        "changes": 528,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/functional/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/key.py?ref=8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "patch": "@@ -1,226 +1,346 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def modinv(a, n):\n+    \"\"\"Compute the modular inverse of a modulo n\n \n+    See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers\n+    \"\"\"\n+    t1, t2 = 0, 1\n+    r1, r2 = n, a\n+    while r2 != 0:\n+        q = r1 // r2\n+        t1, t2 = t2, t1 - q * t2\n+        r1, r2 = r2, r1 - q * r2\n+    if r1 > 1:\n+        return None\n+    if t1 < 0:\n+        t1 += n\n+    return t1\n+\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n+\n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\n+\n+    For p = 3 mod 4, if a square root exists, it is equal to a**((p+1)/4) mod p.\n+    \"\"\"\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x2 = (m**2 - 2*s) % self.p\n+        y2 = (m*(s - x2) - 8*y1_4) % self.p\n+        z2 = (2*y1*z1) % self.p\n+        return (x2, y2, z2)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add(self, p1, p2):\n+        \"\"\"Add two Jacobian tuples p1 and p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        if z1 == 0:\n+            return p2\n+        if z2 == 0:\n+            return p1\n+        if z1 == 1:\n+            return self.add_mixed(p2, p1)\n+        if z2 == 1:\n+            return self.add_mixed(p1, p2)\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        z2_2 = (z2**2) % self.p\n+        z2_3 = (z2_2 * z2) % self.p\n+        u1 = (x1 * z2_2) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s1 = (y1 * z2_3) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if u1 == u2:\n+            if (s1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - u1\n+        r = s2 - s1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (u1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def mul(self, ps):\n+        \"\"\"Compute a (multi) point multiplication\n+\n+        ps is a list of (Jacobian tuple, scalar) pairs.\n+        \"\"\"\n+        r = (0, 1, 0)\n+        for i in range(255, -1, -1):\n+            r = self.double(r)\n+            for (p, n) in ps:\n+                if ((n >> i) & 1):\n+                    r = self.add(r, p)\n+        return r\n+\n+SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n-# Thx to Sam Devlin for the ctypes magic 64-bit fix.\n-def _check_result(val, func, args):\n-    if val == 0:\n-        raise ValueError\n-    else:\n-        return ctypes.c_void_p (val)\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.errcheck = _check_result\n-\n-class CECKey():\n-    \"\"\"Wrapper around OpenSSL's EC_KEY\"\"\"\n-\n-    POINT_CONVERSION_COMPRESSED = 2\n-    POINT_CONVERSION_UNCOMPRESSED = 4\n+class ECPubKey():\n+    \"\"\"A secp256k1 public key\"\"\"\n \n     def __init__(self):\n-        self.k = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)\n-\n-    def __del__(self):\n-        if ssl:\n-            ssl.EC_KEY_free(self.k)\n-        self.k = None\n-\n-    def set_secretbytes(self, secret):\n-        priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())\n-        group = ssl.EC_KEY_get0_group(self.k)\n-        pub_key = ssl.EC_POINT_new(group)\n-        ctx = ssl.BN_CTX_new()\n-        if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):\n-            raise ValueError(\"Could not derive public key from the supplied secret.\")\n-        ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)\n-        ssl.EC_KEY_set_private_key(self.k, priv_key)\n-        ssl.EC_KEY_set_public_key(self.k, pub_key)\n-        ssl.EC_POINT_free(pub_key)\n-        ssl.BN_CTX_free(ctx)\n-        return self.k\n-\n-    def set_privkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def set_pubkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def get_privkey(self):\n-        size = ssl.i2d_ECPrivateKey(self.k, 0)\n-        mb_pri = ctypes.create_string_buffer(size)\n-        ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))\n-        return mb_pri.raw\n-\n-    def get_pubkey(self):\n-        size = ssl.i2o_ECPublicKey(self.k, 0)\n-        mb = ctypes.create_string_buffer(size)\n-        ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))\n-        return mb.raw\n-\n-    def get_raw_ecdh_key(self, other_pubkey):\n-        ecdh_keybuffer = ctypes.create_string_buffer(32)\n-        r = ssl.ECDH_compute_key(ctypes.pointer(ecdh_keybuffer), 32,\n-                                 ssl.EC_KEY_get0_public_key(other_pubkey.k),\n-                                 self.k, 0)\n-        if r != 32:\n-            raise Exception('CKey.get_ecdh_key(): ECDH_compute_key() failed')\n-        return ecdh_keybuffer.raw\n-\n-    def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n-        # FIXME: be warned it's not clear what the kdf should be as a default\n-        r = self.get_raw_ecdh_key(other_pubkey)\n-        return kdf(r)\n-\n-    def sign(self, hash, low_s = True):\n-        # FIXME: need unit tests for below cases\n-        if not isinstance(hash, bytes):\n-            raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n-        if len(hash) != 32:\n-            raise ValueError('Hash must be exactly 32 bytes long')\n-\n-        sig_size0 = ctypes.c_uint32()\n-        sig_size0.value = ssl.ECDSA_size(self.k)\n-        mb_sig = ctypes.create_string_buffer(sig_size0.value)\n-        result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n-        assert 1 == result\n-        assert mb_sig.raw[0] == 0x30\n-        assert mb_sig.raw[1] == sig_size0.value - 2\n-        total_size = mb_sig.raw[1]\n-        assert mb_sig.raw[2] == 2\n-        r_size = mb_sig.raw[3]\n-        assert mb_sig.raw[4 + r_size] == 2\n-        s_size = mb_sig.raw[5 + r_size]\n-        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n-        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n-            return mb_sig.raw[:sig_size0.value]\n-        else:\n-            low_s_value = SECP256K1_ORDER - s_value\n-            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n-            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n-                low_s_bytes = low_s_bytes[1:]\n-            new_s_size = len(low_s_bytes)\n-            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n-            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n-            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n-\n-    def verify(self, hash, sig):\n-        \"\"\"Verify a DER signature\"\"\"\n-        return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1\n-\n-    def set_compressed(self, compressed):\n-        if compressed:\n-            form = self.POINT_CONVERSION_COMPRESSED\n+        \"\"\"Construct an uninitialized public key\"\"\"\n+        self.valid = False\n+\n+    def set(self, data):\n+        \"\"\"Construct a public key from a serialization in compressed or uncompressed format\"\"\"\n+        if (len(data) == 65 and data[0] == 0x04):\n+            p = (int.from_bytes(data[1:33], 'big'), int.from_bytes(data[33:65], 'big'), 1)\n+            self.valid = SECP256K1.on_curve(p)\n+            if self.valid:\n+                self.p = p\n+                self.compressed = False\n+        elif (len(data) == 33 and (data[0] == 0x02 or data[0] == 0x03)):\n+            x = int.from_bytes(data[1:33], 'big')\n+            if SECP256K1.is_x_coord(x):\n+                p = SECP256K1.lift_x(x)\n+                if (p[1] & 1) != (data[0] & 1):\n+                    p = SECP256K1.negate(p)\n+                self.p = p\n+                self.valid = True\n+                self.compressed = True\n+            else:\n+                self.valid = False\n         else:\n-            form = self.POINT_CONVERSION_UNCOMPRESSED\n-        ssl.EC_KEY_set_conv_form(self.k, form)\n-\n+            self.valid = False\n \n-class CPubKey(bytes):\n-    \"\"\"An encapsulated public key\n-\n-    Attributes:\n+    @property\n+    def is_compressed(self):\n+        return self.compressed\n \n-    is_valid      - Corresponds to CPubKey.IsValid()\n-    is_fullyvalid - Corresponds to CPubKey.IsFullyValid()\n-    is_compressed - Corresponds to CPubKey.IsCompressed()\n-    \"\"\"\n+    @property\n+    def is_valid(self):\n+        return self.valid\n+\n+    def get_bytes(self):\n+        assert(self.valid)\n+        p = SECP256K1.affine(self.p)\n+        if p is None:\n+            return None\n+        if self.compressed:\n+            return bytes([0x02 + (p[1] & 1)]) + p[0].to_bytes(32, 'big')\n+        else:\n+            return bytes([0x04]) + p[0].to_bytes(32, 'big') + p[1].to_bytes(32, 'big')\n+\n+    def verify_ecdsa(self, sig, msg, low_s=True):\n+        \"\"\"Verify a strictly DER-encoded ECDSA signature against this pubkey.\"\"\"\n+        assert(self.valid)\n+        if (sig[1] + 2 != len(sig)):\n+            return False\n+        if (len(sig) < 4):\n+            return False\n+        if (sig[0] != 0x30):\n+            return False\n+        if (sig[2] != 0x02):\n+            return False\n+        rlen = sig[3]\n+        if (len(sig) < 6 + rlen):\n+            return False\n+        if rlen < 1 or rlen > 33:\n+            return False\n+        if sig[4] >= 0x80:\n+            return False\n+        if (rlen > 1 and (sig[4] == 0) and not (sig[5] & 0x80)):\n+            return False\n+        r = int.from_bytes(sig[4:4+rlen], 'big')\n+        if (sig[4+rlen] != 0x02):\n+            return False\n+        slen = sig[5+rlen]\n+        if slen < 1 or slen > 33:\n+            return False\n+        if (len(sig) != 6 + rlen + slen):\n+            return False\n+        if sig[6+rlen] >= 0x80:\n+            return False\n+        if (slen > 1 and (sig[6+rlen] == 0) and not (sig[7+rlen] & 0x80)):\n+            return False\n+        s = int.from_bytes(sig[6+rlen:6+rlen+slen], 'big')\n+        if r < 1 or s < 1 or r >= SECP256K1_ORDER or s >= SECP256K1_ORDER:\n+            return False\n+        if low_s and s >= SECP256K1_ORDER_HALF:\n+            return False\n+        z = int.from_bytes(msg, 'big')\n+        w = modinv(s, SECP256K1_ORDER)\n+        u1 = z*w % SECP256K1_ORDER\n+        u2 = r*w % SECP256K1_ORDER\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, u1), (self.p, u2)]))\n+        if R is None or R[0] != r:\n+            return False\n+        return True\n+\n+class ECKey():\n+    \"\"\"A secp256k1 private key\"\"\"\n \n-    def __new__(cls, buf, _cec_key=None):\n-        self = super(CPubKey, cls).__new__(cls, buf)\n-        if _cec_key is None:\n-            _cec_key = CECKey()\n-        self._cec_key = _cec_key\n-        self.is_fullyvalid = _cec_key.set_pubkey(self) != 0\n-        return self\n+    def __init__(self):\n+        self.valid = False\n+\n+    def set(self, secret, compressed):\n+        \"\"\"Construct a private key object with given 32-byte secret and compressed flag.\"\"\"\n+        assert(len(secret) == 32)\n+        secret = int.from_bytes(secret, 'big')\n+        self.valid = (secret > 0 and secret < SECP256K1_ORDER)\n+        if self.valid:\n+            self.secret = secret\n+            self.compressed = compressed\n+\n+    def generate(self, compressed=True):\n+        \"\"\"Generate a random private key (compressed or uncompressed).\"\"\"\n+        self.set(random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big'), compressed)\n+\n+    def get_bytes(self):\n+        \"\"\"Retrieve the 32-byte representation of this key.\"\"\"\n+        assert(self.valid)\n+        return self.secret.to_bytes(32, 'big')\n \n     @property\n     def is_valid(self):\n-        return len(self) > 0\n+        return self.valid\n \n     @property\n     def is_compressed(self):\n-        return len(self) == 33\n-\n-    def verify(self, hash, sig):\n-        return self._cec_key.verify(hash, sig)\n-\n-    def __str__(self):\n-        return repr(self)\n-\n-    def __repr__(self):\n-        return '%s(%s)' % (self.__class__.__name__, super(CPubKey, self).__repr__())\n+        return self.compressed\n \n+    def get_pubkey(self):\n+        \"\"\"Compute an ECPubKey object for this secret key.\"\"\"\n+        assert(self.valid)\n+        ret = ECPubKey()\n+        p = SECP256K1.mul([(SECP256K1_G, self.secret)])\n+        ret.p = p\n+        ret.valid = True\n+        ret.compressed = self.compressed\n+        return ret\n+\n+    def sign_ecdsa(self, msg, low_s=True):\n+        \"\"\"Construct a DER-encoded ECDSA signature with this key.\"\"\"\n+        assert(self.valid)\n+        z = int.from_bytes(msg, 'big')\n+        # Note: no RFC6979, but a simple random nonce (some tests rely on distinct transactions for the same operation)\n+        k = random.randrange(1, SECP256K1_ORDER)\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, k)]))\n+        r = R[0] % SECP256K1_ORDER\n+        s = (modinv(k, SECP256K1_ORDER) * (z + self.secret * r)) % SECP256K1_ORDER\n+        if low_s and s > SECP256K1_ORDER_HALF:\n+            s = SECP256K1_ORDER - s\n+        rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n+        sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n+        return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb"
      },
      {
        "sha": "588ba428d755d737bb4039b00b4223ad364a8d67",
        "filename": "test/lint/lint-python-dead-code.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/lint/lint-python-dead-code.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb/test/lint/lint-python-dead-code.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python-dead-code.sh?ref=8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "patch": "@@ -15,5 +15,5 @@ fi\n \n vulture \\\n     --min-confidence 60 \\\n-    --ignore-names \"argtypes,connection_lost,connection_made,converter,data_received,daemon,errcheck,get_ecdh_key,get_privkey,is_compressed,is_fullyvalid,msg_generic,on_*,optionxform,restype,set_privkey,profile_with_perf\" \\\n+    --ignore-names \"argtypes,connection_lost,connection_made,converter,data_received,daemon,errcheck,is_compressed,is_valid,verify_ecdsa,msg_generic,on_*,optionxform,restype,profile_with_perf\" \\\n     $(git ls-files -- \"*.py\" \":(exclude)contrib/\" \":(exclude)test/functional/data/invalid_txs.py\")"
      }
    ]
  },
  {
    "sha": "b67978529ad02fc2665f2362418dc53db2e25e17",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNjc5Nzg1MjlhZDAyZmMyNjY1ZjIzNjI0MThkYzUzZGIyZTI1ZTE3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-04-18T17:47:24Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-04-18T20:23:26Z"
      },
      "message": "Add comments to Python ECDSA implementation",
      "tree": {
        "sha": "8c848e9c3472dc0ff7ed540858b905943b6753f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c848e9c3472dc0ff7ed540858b905943b6753f3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b67978529ad02fc2665f2362418dc53db2e25e17",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b67978529ad02fc2665f2362418dc53db2e25e17",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b67978529ad02fc2665f2362418dc53db2e25e17",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b67978529ad02fc2665f2362418dc53db2e25e17/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 56,
      "deletions": 16
    },
    "files": [
      {
        "sha": "912c0ca978e31dc0fb70593240f6dd2f2a00c482",
        "filename": "test/functional/test_framework/key.py",
        "status": "modified",
        "additions": 56,
        "deletions": 16,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b67978529ad02fc2665f2362418dc53db2e25e17/test/functional/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b67978529ad02fc2665f2362418dc53db2e25e17/test/functional/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/key.py?ref=b67978529ad02fc2665f2362418dc53db2e25e17",
        "patch": "@@ -1,18 +1,17 @@\n # Copyright (c) 2019 Pieter Wuille\n-\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test-only secp256k1 elliptic curve implementation\n \n WARNING: This code is slow, uses bad randomness, does not properly protect\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n-anything but tests.\n-\"\"\"\n-\n+anything but tests.\"\"\"\n import random\n \n def modinv(a, n):\n     \"\"\"Compute the modular inverse of a modulo n\n \n-    See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers\n+    See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers.\n     \"\"\"\n     t1, t2 = 0, 1\n     r1, r2 = n, a\n@@ -30,8 +29,9 @@ def jacobi_symbol(n, k):\n     \"\"\"Compute the Jacobi symbol of n modulo k\n \n     See http://en.wikipedia.org/wiki/Jacobi_symbol\n-    \"\"\"\n-    assert k > 0 and k & 1\n+\n+    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n+    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n     n %= k\n     t = 0\n     while n != 0:\n@@ -47,11 +47,18 @@ def jacobi_symbol(n, k):\n     return 0\n \n def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p\n+    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n \n-    For p = 3 mod 4, if a square root exists, it is equal to a**((p+1)/4) mod p.\n+    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n+\n+    Limiting this function to only work for p % 4 = 3 means we don't need to\n+    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n+    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n+\n+    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n     \"\"\"\n-    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    if p % 4 != 3:\n+        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n     sqrt = pow(a, (p + 1)//4, p)\n     if pow(sqrt, 2, p) == a % p:\n         return sqrt\n@@ -65,7 +72,9 @@ def __init__(self, p, a, b):\n         self.b = b % p\n \n     def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n+\n+        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n         x1, y1, z1 = p1\n         if z1 == 0:\n             return None\n@@ -101,7 +110,9 @@ def lift_x(self, x):\n         return (x, y, 1)\n \n     def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        \"\"\"Double a Jacobian tuple p1\n+\n+        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n         x1, y1, z1 = p1\n         if z1 == 0:\n             return (0, 1, 0)\n@@ -119,10 +130,13 @@ def double(self, p1):\n         return (x2, y2, z2)\n \n     def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n+\n+        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n         x1, y1, z1 = p1\n         x2, y2, z2 = p2\n         assert(z2 == 1)\n+        # Adding to the point at infinity is a no-op\n         if z1 == 0:\n             return p2\n         z1_2 = (z1**2) % self.p\n@@ -131,7 +145,9 @@ def add_mixed(self, p1, p2):\n         s2 = (y2 * z1_3) % self.p\n         if x1 == u2:\n             if (y1 != s2):\n+                # p1 and p2 are inverses. Return the point at infinity.\n                 return (0, 1, 0)\n+            # p1 == p2. The formulas below fail when the two points are equal.\n             return self.double(p1)\n         h = u2 - x1\n         r = s2 - y1\n@@ -144,13 +160,17 @@ def add_mixed(self, p1, p2):\n         return (x3, y3, z3)\n \n     def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\"\"\"\n+        \"\"\"Add two Jacobian tuples p1 and p2\n+\n+        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n         x1, y1, z1 = p1\n         x2, y2, z2 = p2\n+        # Adding the point at infinity is a no-op\n         if z1 == 0:\n             return p2\n         if z2 == 0:\n             return p1\n+        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n         if z1 == 1:\n             return self.add_mixed(p2, p1)\n         if z2 == 1:\n@@ -165,7 +185,9 @@ def add(self, p1, p2):\n         s2 = (y2 * z1_3) % self.p\n         if u1 == u2:\n             if (s1 != s2):\n+                # p1 and p2 are inverses. Return the point at infinity.\n                 return (0, 1, 0)\n+            # p1 == p2. The formulas below fail when the two points are equal.\n             return self.double(p1)\n         h = u2 - u1\n         r = s2 - s1\n@@ -214,6 +236,8 @@ def set(self, data):\n             x = int.from_bytes(data[1:33], 'big')\n             if SECP256K1.is_x_coord(x):\n                 p = SECP256K1.lift_x(x)\n+                # if the oddness of the y co-ord isn't correct, find the other\n+                # valid y\n                 if (p[1] & 1) != (data[0] & 1):\n                     p = SECP256K1.negate(p)\n                 self.p = p\n@@ -243,8 +267,14 @@ def get_bytes(self):\n             return bytes([0x04]) + p[0].to_bytes(32, 'big') + p[1].to_bytes(32, 'big')\n \n     def verify_ecdsa(self, sig, msg, low_s=True):\n-        \"\"\"Verify a strictly DER-encoded ECDSA signature against this pubkey.\"\"\"\n+        \"\"\"Verify a strictly DER-encoded ECDSA signature against this pubkey.\n+\n+        See https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm for the\n+        ECDSA verifier algorithm\"\"\"\n         assert(self.valid)\n+\n+        # Extract r and s from the DER formatted signature. Return false for\n+        # any DER encoding errors.\n         if (sig[1] + 2 != len(sig)):\n             return False\n         if (len(sig) < 4):\n@@ -275,11 +305,15 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n         if (slen > 1 and (sig[6+rlen] == 0) and not (sig[7+rlen] & 0x80)):\n             return False\n         s = int.from_bytes(sig[6+rlen:6+rlen+slen], 'big')\n+\n+        # Verify that r and s are within the group order\n         if r < 1 or s < 1 or r >= SECP256K1_ORDER or s >= SECP256K1_ORDER:\n             return False\n         if low_s and s >= SECP256K1_ORDER_HALF:\n             return False\n         z = int.from_bytes(msg, 'big')\n+\n+        # Run verifier algorithm on r, s\n         w = modinv(s, SECP256K1_ORDER)\n         u1 = z*w % SECP256K1_ORDER\n         u2 = r*w % SECP256K1_ORDER\n@@ -331,7 +365,10 @@ def get_pubkey(self):\n         return ret\n \n     def sign_ecdsa(self, msg, low_s=True):\n-        \"\"\"Construct a DER-encoded ECDSA signature with this key.\"\"\"\n+        \"\"\"Construct a DER-encoded ECDSA signature with this key.\n+\n+        See https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm for the\n+        ECDSA signer algorithm.\"\"\"\n         assert(self.valid)\n         z = int.from_bytes(msg, 'big')\n         # Note: no RFC6979, but a simple random nonce (some tests rely on distinct transactions for the same operation)\n@@ -341,6 +378,9 @@ def sign_ecdsa(self, msg, low_s=True):\n         s = (modinv(k, SECP256K1_ORDER) * (z + self.secret * r)) % SECP256K1_ORDER\n         if low_s and s > SECP256K1_ORDER_HALF:\n             s = SECP256K1_ORDER - s\n+        # Represent in DER format. The byte representations of r and s have\n+        # length rounded up (255 bits becomes 32 bytes and 256 bits becomes 33\n+        # bytes).\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb"
      }
    ]
  }
]