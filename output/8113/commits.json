[
  {
    "sha": "1111b80df84aa7bc72fbddcc7bafde43f0835d90",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMTExYjgwZGY4NGFhN2JjNzJmYmRkY2M3YmFmZGU0M2YwODM1ZDkw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-28T13:32:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-13T21:53:06Z"
      },
      "message": "Rework addnode behaviour\n\n* Use CNode::addeName to track whether a connection to a name is already open\n  * A new connection to a previously-connected by-name addednode is only opened when\n    the previous one closes (even if the name starts resolving to something else)\n  * At most one connection is opened per addednode (even if the name resolves to multiple)\n* Unify the code between ThreadOpenAddedNodeConnections and getaddednodeinfo\n  * Information about open connections is always returned, and the dns argument becomes a dummy\n  * An IP address and inbound/outbound is only reported for the (at most 1) open connection",
      "tree": {
        "sha": "62c4a019d9f1fab94fea3894735ff77d2bc1ffff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/62c4a019d9f1fab94fea3894735ff77d2bc1ffff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1111b80df84aa7bc72fbddcc7bafde43f0835d90",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1111b80df84aa7bc72fbddcc7bafde43f0835d90",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1111b80df84aa7bc72fbddcc7bafde43f0835d90",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1111b80df84aa7bc72fbddcc7bafde43f0835d90/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be9711e597071c813bdd72c2866c547f117e4865",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be9711e597071c813bdd72c2866c547f117e4865",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be9711e597071c813bdd72c2866c547f117e4865"
      }
    ],
    "stats": {
      "total": 212,
      "additions": 91,
      "deletions": 121
    },
    "files": [
      {
        "sha": "4d27db7604d0ba0d666fc9b5009f0d7f38513f2b",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 48,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1111b80df84aa7bc72fbddcc7bafde43f0835d90/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1111b80df84aa7bc72fbddcc7bafde43f0835d90/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1111b80df84aa7bc72fbddcc7bafde43f0835d90",
        "patch": "@@ -1616,68 +1616,79 @@ void ThreadOpenConnections()\n     }\n }\n \n-void ThreadOpenAddedConnections()\n+std::vector<AddedNodeInfo> GetAddedNodeInfo()\n {\n+    std::vector<AddedNodeInfo> ret;\n+\n+    std::list<std::string> lAddresses(0);\n     {\n         LOCK(cs_vAddedNodes);\n-        vAddedNodes = mapMultiArgs[\"-addnode\"];\n+        ret.reserve(vAddedNodes.size());\n+        BOOST_FOREACH(const std::string& strAddNode, vAddedNodes)\n+            lAddresses.push_back(strAddNode);\n     }\n \n-    if (HaveNameProxy()) {\n-        while(true) {\n-            std::list<std::string> lAddresses(0);\n-            {\n-                LOCK(cs_vAddedNodes);\n-                BOOST_FOREACH(const std::string& strAddNode, vAddedNodes)\n-                    lAddresses.push_back(strAddNode);\n+\n+    // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService\n+    std::map<CService, bool> mapConnected;\n+    std::map<std::string, std::pair<bool, CService>> mapConnectedByName;\n+    {\n+        LOCK(cs_vNodes);\n+        for (const CNode* pnode : vNodes) {\n+            if (pnode->addr.IsValid()) {\n+                mapConnected[pnode->addr] = pnode->fInbound;\n             }\n-            BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n-                CAddress addr;\n-                CSemaphoreGrant grant(*semOutbound);\n-                OpenNetworkConnection(addr, false, &grant, strAddNode.c_str());\n-                MilliSleep(500);\n+            if (!pnode->addrName.empty()) {\n+                mapConnectedByName[pnode->addrName] = std::make_pair(pnode->fInbound, static_cast<const CService&>(pnode->addr));\n             }\n-            MilliSleep(120000); // Retry every 2 minutes\n         }\n     }\n \n+    BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n+        CService service(strAddNode, Params().GetDefaultPort());\n+        if (service.IsValid()) {\n+            // strAddNode is an IP:port\n+            auto it = mapConnected.find(service);\n+            if (it != mapConnected.end()) {\n+                ret.push_back(AddedNodeInfo{strAddNode, service, true, it->second});\n+            } else {\n+                ret.push_back(AddedNodeInfo{strAddNode, CService(), false, false});\n+            }\n+        } else {\n+            // strAddNode is a name\n+            auto it = mapConnectedByName.find(strAddNode);\n+            if (it != mapConnectedByName.end()) {\n+                ret.push_back(AddedNodeInfo{strAddNode, it->second.second, true, it->second.first});\n+            } else {\n+                ret.push_back(AddedNodeInfo{strAddNode, CService(), false, false});\n+            }\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n+void ThreadOpenAddedConnections()\n+{\n+    {\n+        LOCK(cs_vAddedNodes);\n+        vAddedNodes = mapMultiArgs[\"-addnode\"];\n+    }\n+\n     for (unsigned int i = 0; true; i++)\n     {\n-        std::list<std::string> lAddresses(0);\n-        {\n-            LOCK(cs_vAddedNodes);\n-            BOOST_FOREACH(const std::string& strAddNode, vAddedNodes)\n-                lAddresses.push_back(strAddNode);\n+        std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();\n+        for (const AddedNodeInfo& info : vInfo) {\n+            if (!info.fConnected) {\n+                CSemaphoreGrant grant(*semOutbound);\n+                // If strAddedNode is an IP/port, decode it immediately, so\n+                // OpenNetworkConnection can detect existing connections to that IP/port.\n+                CService service(info.strAddedNode, Params().GetDefaultPort());\n+                OpenNetworkConnection(CAddress(service, NODE_NONE), false, &grant, info.strAddedNode.c_str(), false);\n+                MilliSleep(500);\n+            }\n         }\n \n-        std::list<std::vector<CService> > lservAddressesToAdd(0);\n-        BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n-            std::vector<CService> vservNode(0);\n-            if(Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n-                lservAddressesToAdd.push_back(vservNode);\n-        }\n-        // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n-        // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n-        {\n-            LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n-                for (std::list<std::vector<CService> >::iterator it = lservAddressesToAdd.begin(); it != lservAddressesToAdd.end(); it++)\n-                    BOOST_FOREACH(const CService& addrNode, *(it))\n-                        if (pnode->addr == addrNode)\n-                        {\n-                            it = lservAddressesToAdd.erase(it);\n-                            it--;\n-                            break;\n-                        }\n-        }\n-        BOOST_FOREACH(std::vector<CService>& vserv, lservAddressesToAdd)\n-        {\n-            CSemaphoreGrant grant(*semOutbound);\n-            /* We want -addnode to work even for nodes that don't provide all\n-             * wanted services, so pass in nServices=NODE_NONE to CAddress. */\n-            OpenNetworkConnection(CAddress(vserv[i % vserv.size()], NODE_NONE), false, &grant);\n-            MilliSleep(500);\n-        }\n         MilliSleep(120000); // Retry every 2 minutes\n     }\n }"
      },
      {
        "sha": "54a86d88dc88704e455cc8c803ecf6717c64c050",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1111b80df84aa7bc72fbddcc7bafde43f0835d90/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1111b80df84aa7bc72fbddcc7bafde43f0835d90/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=1111b80df84aa7bc72fbddcc7bafde43f0835d90",
        "patch": "@@ -818,4 +818,14 @@ class CBanDB\n /** Return a timestamp in the future (in microseconds) for exponentially distributed events. */\n int64_t PoissonNextSend(int64_t nNow, int average_interval_seconds);\n \n+struct AddedNodeInfo\n+{\n+    std::string strAddedNode;\n+    CService resolvedAddress;\n+    bool fConnected;\n+    bool fInbound;\n+};\n+\n+std::vector<AddedNodeInfo> GetAddedNodeInfo();\n+\n #endif // BITCOIN_NET_H"
      },
      {
        "sha": "b85c7b2e1aaa547bab62b627a1cecf95c2ad8483",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 73,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1111b80df84aa7bc72fbddcc7bafde43f0835d90/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1111b80df84aa7bc72fbddcc7bafde43f0835d90/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=1111b80df84aa7bc72fbddcc7bafde43f0835d90",
        "patch": "@@ -271,25 +271,22 @@ UniValue getaddednodeinfo(const UniValue& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n         throw runtime_error(\n-            \"getaddednodeinfo dns ( \\\"node\\\" )\\n\"\n+            \"getaddednodeinfo dummy ( \\\"node\\\" )\\n\"\n             \"\\nReturns information about the given added node, or all added nodes\\n\"\n             \"(note that onetry addnodes are not listed here)\\n\"\n-            \"If dns is false, only a list of added nodes will be provided,\\n\"\n-            \"otherwise connected information will also be available.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. dns        (boolean, required) If false, only a list of added nodes will be provided, otherwise connected information will also be available.\\n\"\n+            \"1. dummy      (boolean, required) Kept for historical purposes but ignored\\n\"\n             \"2. \\\"node\\\"   (string, optional) If provided, return information about this specific node, otherwise all nodes are returned.\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n-            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node ip address\\n\"\n+            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node ip address or name (as provided to addnode)\\n\"\n             \"    \\\"connected\\\" : true|false,          (boolean) If connected\\n\"\n-            \"    \\\"addresses\\\" : [\\n\"\n+            \"    \\\"addresses\\\" : [                    (list of objects) Only when connected = true\\n\"\n             \"       {\\n\"\n-            \"         \\\"address\\\" : \\\"192.168.0.201:8333\\\",  (string) The bitcoin server host and port\\n\"\n+            \"         \\\"address\\\" : \\\"192.168.0.201:8333\\\",  (string) The bitcoin server IP and port we're connected to\\n\"\n             \"         \\\"connected\\\" : \\\"outbound\\\"           (string) connection, inbound or outbound\\n\"\n             \"       }\\n\"\n-            \"       ,...\\n\"\n             \"     ]\\n\"\n             \"  }\\n\"\n             \"  ,...\\n\"\n@@ -300,83 +297,35 @@ UniValue getaddednodeinfo(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getaddednodeinfo\", \"true, \\\"192.168.0.201\\\"\")\n         );\n \n-    bool fDns = params[0].get_bool();\n+    std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();\n \n-    list<string> laddedNodes(0);\n-    if (params.size() == 1)\n-    {\n-        LOCK(cs_vAddedNodes);\n-        BOOST_FOREACH(const std::string& strAddNode, vAddedNodes)\n-            laddedNodes.push_back(strAddNode);\n-    }\n-    else\n-    {\n-        string strNode = params[1].get_str();\n-        LOCK(cs_vAddedNodes);\n-        BOOST_FOREACH(const std::string& strAddNode, vAddedNodes) {\n-            if (strAddNode == strNode)\n-            {\n-                laddedNodes.push_back(strAddNode);\n+    if (params.size() == 2) {\n+        bool found = false;\n+        for (const AddedNodeInfo& info : vInfo) {\n+            if (info.strAddedNode == params[1].get_str()) {\n+                vInfo.assign(1, info);\n+                found = true;\n                 break;\n             }\n         }\n-        if (laddedNodes.size() == 0)\n+        if (!found) {\n             throw JSONRPCError(RPC_CLIENT_NODE_NOT_ADDED, \"Error: Node has not been added.\");\n-    }\n-\n-    UniValue ret(UniValue::VARR);\n-    if (!fDns)\n-    {\n-        BOOST_FOREACH (const std::string& strAddNode, laddedNodes) {\n-            UniValue obj(UniValue::VOBJ);\n-            obj.push_back(Pair(\"addednode\", strAddNode));\n-            ret.push_back(obj);\n         }\n-        return ret;\n     }\n \n-    list<pair<string, vector<CService> > > laddedAddreses(0);\n-    BOOST_FOREACH(const std::string& strAddNode, laddedNodes) {\n-        vector<CService> vservNode(0);\n-        if(Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n-            laddedAddreses.push_back(make_pair(strAddNode, vservNode));\n-        else\n-        {\n-            UniValue obj(UniValue::VOBJ);\n-            obj.push_back(Pair(\"addednode\", strAddNode));\n-            obj.push_back(Pair(\"connected\", false));\n-            UniValue addresses(UniValue::VARR);\n-            obj.push_back(Pair(\"addresses\", addresses));\n-            ret.push_back(obj);\n-        }\n-    }\n+    UniValue ret(UniValue::VARR);\n \n-    LOCK(cs_vNodes);\n-    for (list<pair<string, vector<CService> > >::iterator it = laddedAddreses.begin(); it != laddedAddreses.end(); it++)\n-    {\n+    for (const AddedNodeInfo& info : vInfo) {\n         UniValue obj(UniValue::VOBJ);\n-        obj.push_back(Pair(\"addednode\", it->first));\n-\n+        obj.push_back(Pair(\"addednode\", info.strAddedNode));\n+        obj.push_back(Pair(\"connected\", info.fConnected));\n         UniValue addresses(UniValue::VARR);\n-        bool fConnected = false;\n-        BOOST_FOREACH(const CService& addrNode, it->second) {\n-            bool fFound = false;\n-            UniValue node(UniValue::VOBJ);\n-            node.push_back(Pair(\"address\", addrNode.ToString()));\n-            BOOST_FOREACH(CNode* pnode, vNodes) {\n-                if (pnode->addr == addrNode)\n-                {\n-                    fFound = true;\n-                    fConnected = true;\n-                    node.push_back(Pair(\"connected\", pnode->fInbound ? \"inbound\" : \"outbound\"));\n-                    break;\n-                }\n-            }\n-            if (!fFound)\n-                node.push_back(Pair(\"connected\", \"false\"));\n-            addresses.push_back(node);\n+        if (info.fConnected) {\n+            UniValue address(UniValue::VOBJ);\n+            address.push_back(Pair(\"address\", info.resolvedAddress.ToString()));\n+            address.push_back(Pair(\"connected\", info.fInbound ? \"inbound\" : \"outbound\"));\n+            addresses.push_back(address);\n         }\n-        obj.push_back(Pair(\"connected\", fConnected));\n         obj.push_back(Pair(\"addresses\", addresses));\n         ret.push_back(obj);\n     }"
      }
    ]
  },
  {
    "sha": "f9f5cfc50637f2cd1540923caf337e2651ec1625",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOWY1Y2ZjNTA2MzdmMmNkMTU0MDkyM2NhZjMzN2UyNjUxZWMxNjI1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-28T14:22:02Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-13T21:53:08Z"
      },
      "message": "Prevent duplicate connections where one is by name and another by ip",
      "tree": {
        "sha": "fbf53e04f9f8cc71d9538691e5b9c153b0826a69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fbf53e04f9f8cc71d9538691e5b9c153b0826a69"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9f5cfc50637f2cd1540923caf337e2651ec1625",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9f5cfc50637f2cd1540923caf337e2651ec1625",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9f5cfc50637f2cd1540923caf337e2651ec1625",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9f5cfc50637f2cd1540923caf337e2651ec1625/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1111b80df84aa7bc72fbddcc7bafde43f0835d90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1111b80df84aa7bc72fbddcc7bafde43f0835d90",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1111b80df84aa7bc72fbddcc7bafde43f0835d90"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "30a6bc896db2209d6335e421da4007afb2aea697",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9f5cfc50637f2cd1540923caf337e2651ec1625/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9f5cfc50637f2cd1540923caf337e2651ec1625/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=f9f5cfc50637f2cd1540923caf337e2651ec1625",
        "patch": "@@ -400,6 +400,26 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure\n             return NULL;\n         }\n \n+        if (pszDest && addrConnect.IsValid()) {\n+            // It is possible that we already have a connection to the IP/port pszDest resolved to.\n+            // In that case, drop the connection that was just created, and return the existing CNode instead.\n+            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n+            // name catch this early.\n+            CNode* pnode = FindNode((CService)addrConnect);\n+            if (pnode)\n+            {\n+                pnode->AddRef();\n+                {\n+                    LOCK(cs_vNodes);\n+                    if (pnode->addrName.empty()) {\n+                        pnode->addrName = std::string(pszDest);\n+                    }\n+                }\n+                CloseSocket(hSocket);\n+                return pnode;\n+            }\n+        }\n+\n         addrman.Attempt(addrConnect, fCountFailure);\n \n         // Add node"
      }
    ]
  },
  {
    "sha": "1a5a4e648873c4cd88b936648ebf2858393e5510",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYTVhNGU2NDg4NzNjNGNkODhiOTM2NjQ4ZWJmMjg1ODM5M2U1NTEw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-28T14:44:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-13T21:53:08Z"
      },
      "message": "Randomize name lookup result in ConnectSocketByName",
      "tree": {
        "sha": "48e7d68293a0028a0239a441bd8fd276c675a216",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/48e7d68293a0028a0239a441bd8fd276c675a216"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a5a4e648873c4cd88b936648ebf2858393e5510",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a5a4e648873c4cd88b936648ebf2858393e5510",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1a5a4e648873c4cd88b936648ebf2858393e5510",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a5a4e648873c4cd88b936648ebf2858393e5510/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9f5cfc50637f2cd1540923caf337e2651ec1625",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9f5cfc50637f2cd1540923caf337e2651ec1625",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9f5cfc50637f2cd1540923caf337e2651ec1625"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e2a516986c11682ae66aac7e754680637bd35872",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a5a4e648873c4cd88b936648ebf2858393e5510/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a5a4e648873c4cd88b936648ebf2858393e5510/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=1a5a4e648873c4cd88b936648ebf2858393e5510",
        "patch": "@@ -621,10 +621,10 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n     proxyType nameProxy;\n     GetNameProxy(nameProxy);\n \n-    CService addrResolved;\n-    if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy())) {\n-        if (addrResolved.IsValid()) {\n-            addr = addrResolved;\n+    std::vector<CService> addrResolved;\n+    if (Lookup(strDest.c_str(), addrResolved, port, fNameLookup && !HaveNameProxy(), 256)) {\n+        if (addrResolved.size() > 0) {\n+            addr = addrResolved[GetRand(addrResolved.size())];\n             return ConnectSocket(addr, hSocketRet, nTimeout);\n         }\n     }"
      }
    ]
  }
]