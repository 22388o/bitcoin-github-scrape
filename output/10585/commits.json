[
  {
    "sha": "ae6bf7aeb5521eb58affd69bb370763e4380257d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZTZiZjdhZWI1NTIxZWI1OGFmZmQ2OWJiMzcwNzYzZTQzODAyNTdk",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-24T03:00:46Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:04:37Z"
      },
      "message": "Added ProbabilityTarget/Estimate support to arith_uint256.\n\nIn order to make the probability target (nBits-style) more intuitive to generate based on an expected probability, two functions were added to arith_uint256 -- SetProbabilityTarget(pt) and GetProbabilityEstimate().\n\nThe former will set the arith_uint256 to a difficulty approximately equal to pt, i.e. if pt = 1.0 (100% probability), the result will be 0b1111... and if pt = 0.5 (50%), the result will be 0b01111... and so on.\n\nThe latter will do the inverse, i.e. take the arith_uint256 value as a difficulty target and return a probability that a random hash will be lower than the target.",
      "tree": {
        "sha": "4ad2adf81454011bb28ee5006f3eef848ab2b3e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ad2adf81454011bb28ee5006f3eef848ab2b3e1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae6bf7aeb5521eb58affd69bb370763e4380257d",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk499cACgkQV692LbM1\nMyIAKA/9HgJLkj4CQglSKUK4sbofUHQL2IRI8zmwpT5CVNDU+DVgt45suy1zrohd\nezO9Z22P9Egtd9lnp1q2fqcSlKnqt1bQCemSxfV0kLK6g+/XIBanBejOW+IJ1OK9\n9wluXdJx8mPOl/EoRxXroiuJ6J8jryq1hJvC6coxXIQ4rL8UBGRw4liE86BaFPDq\nlceGv5nOSbLZuW77H5NTLmDgX7O55DzSUHrvsQrFqbOmLlMgkaVU2Bh0YXbiKL6b\n5F2xIz3um/uCAEugPlp89rgUzm21yJFWism1auFlWKbV5rl0V78IXqo+ITxQILTh\nh0NNo/kSgphpEO1Ozi+pKh1WeHPoiwWFIaT6/OBiWPbkPLafWNUHmzUpDxHuDcoY\nRzyP36q1nEhRqD3fr0rNXzYxWGqKte+lPl80KxHatVelqkmJ9sgihI6m0qyG9ouQ\nCiD1xzLuNz9z97gh9KErIKn2Gai1W07RyW0zPvLLk95kEzlAoHm5XFCHs5Jr8mFz\nQmjsUAYL3YGegzF2ZEC8pcld4BqG6Z2pyFcU5vSoaOtnXilSylb6I0blG1v9cQl0\na9vSQEy+byidJ7GcNcgDy80GBhzUTUgLGGwq4zu8niO4jdu0Nx1LvDfwGu5RN5er\nBwmk6qjfhLvy8XYdIOF8HQw6TX7hHL6dac5nhNy6BhA2Tm8GVxk=\n=Bdfu\n-----END PGP SIGNATURE-----",
        "payload": "tree 4ad2adf81454011bb28ee5006f3eef848ab2b3e1\nparent e801084decf4542d57cf5ddb95820643766a172a\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1493002846 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496905477 +0900\n\nAdded ProbabilityTarget/Estimate support to arith_uint256.\n\nIn order to make the probability target (nBits-style) more intuitive to generate based on an expected probability, two functions were added to arith_uint256 -- SetProbabilityTarget(pt) and GetProbabilityEstimate().\n\nThe former will set the arith_uint256 to a difficulty approximately equal to pt, i.e. if pt = 1.0 (100% probability), the result will be 0b1111... and if pt = 0.5 (50%), the result will be 0b01111... and so on.\n\nThe latter will do the inverse, i.e. take the arith_uint256 value as a difficulty target and return a probability that a random hash will be lower than the target.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6bf7aeb5521eb58affd69bb370763e4380257d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ae6bf7aeb5521eb58affd69bb370763e4380257d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6bf7aeb5521eb58affd69bb370763e4380257d/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e801084decf4542d57cf5ddb95820643766a172a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e801084decf4542d57cf5ddb95820643766a172a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e801084decf4542d57cf5ddb95820643766a172a"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 53,
      "deletions": 0
    },
    "files": [
      {
        "sha": "00d3848beb5da837b9d192952820c755283bcaed",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6bf7aeb5521eb58affd69bb370763e4380257d/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6bf7aeb5521eb58affd69bb370763e4380257d/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=ae6bf7aeb5521eb58affd69bb370763e4380257d",
        "patch": "@@ -244,6 +244,44 @@ uint32_t arith_uint256::GetCompact(bool fNegative) const\n     return nCompact;\n }\n \n+arith_uint256& arith_uint256::SetProbabilityTarget(double pt)\n+{\n+    double pti = 1.0 - pt;      // we are actually summating the probability of failing, whereas pt is the desired probability of success\n+    double psum = 0.0;          // sum of probabilities\n+    double pcurr = 1.0/2;       // probability at current bit\n+    // unset bits to satisfy probability\n+    for (int k = WIDTH - 1; k >= 0; k--) {\n+        uint32_t pbit = 0x80000000; // current bit value\n+        uint32_t v = 0;\n+        for (unsigned int i = 0; psum < pti && i < 32; i++) {\n+            if (psum + pcurr <= pti) {\n+                psum += pcurr;\n+                v |= pbit;\n+            }\n+            pcurr /= 2;\n+            pbit >>= 1;\n+        }\n+        pn[k] = ~v;\n+    }\n+    return *this;\n+}\n+\n+double arith_uint256::GetProbabilityEstimate() const\n+{\n+    double psum = 0.0;\n+    double pcurr = 1.0/2;       // probability at current bit\n+    for (int k = WIDTH - 1; k >= 0; k--) {\n+        uint32_t pbit = 0x80000000; // current bit value\n+        uint32_t v = ~pn[k];\n+        for (unsigned int i = 0; i < 32; i++) {\n+            if (v & pbit) psum += pcurr;\n+            pcurr /= 2;\n+            pbit >>= 1;\n+        }\n+    }\n+    return 1.0 - psum;\n+}\n+\n uint256 ArithToUint256(const arith_uint256 &a)\n {\n     uint256 b;"
      },
      {
        "sha": "1e02b5bbc0446e2e70f97aba40ed6eeca424ce9a",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6bf7aeb5521eb58affd69bb370763e4380257d/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6bf7aeb5521eb58affd69bb370763e4380257d/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=ae6bf7aeb5521eb58affd69bb370763e4380257d",
        "patch": "@@ -280,6 +280,21 @@ class arith_uint256 : public base_uint<256> {\n     arith_uint256& SetCompact(uint32_t nCompact, bool *pfNegative = NULL, bool *pfOverflow = NULL);\n     uint32_t GetCompact(bool fNegative = false) const;\n \n+    /**\n+     * Set the value so that a random 256 bit digest will be smaller than this\n+     * 1/pt number of times on average.\n+     * @param  pt Probability target, in the range [0..1]\n+     * @return    Updated self\n+     */\n+    arith_uint256& SetProbabilityTarget(double pt);\n+\n+    /**\n+     * Obtain an estimate probability that a random 256 bit digest will be\n+     * smaller than this.\n+     * @return Probability estimate, in the range [0..1]\n+     */\n+    double GetProbabilityEstimate() const;\n+\n     friend uint256 ArithToUint256(const arith_uint256 &);\n     friend arith_uint256 UintToArith256(const uint256 &);\n };"
      }
    ]
  },
  {
    "sha": "c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMWU0NzY0YmMyZmVjMzhkZGQ2ZDg2Mjg2ZjBhMjEwYmZmM2Q2OWRm",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-24T03:01:14Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:08:07Z"
      },
      "message": "[test] Added tests for arith_uint256::SetProbabilityTarget/GetProbabilityEstimate.",
      "tree": {
        "sha": "a3d1a174d5aec4d43813a46ca576efad8c68033d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a3d1a174d5aec4d43813a46ca576efad8c68033d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk49/EACgkQV692LbM1\nMyJj+w/7BGlSNKp2jp/lY3Nl2l15V2LvoQoFVQxhghRikh3FJ5jfe7TVVH4igN98\nPdhnwgKECauDyldg8Ui7psOCXCdj1AYzZWmSc23CjXuc/wt+37l5SE3FIV9qTv1z\n6250fYNVIDvVoIdKmU8rnDOshYe0dSHukjl3igvLyayqIimDtE55vDcwadCUCNFa\nAqLTTw6tEH9XMjILnJregLkYbqDge/DcWkSvf/Uby7+NauyXbMbjrePdaDMKc+Tm\nyU+nbhAbHdH5FsA2pcFypGP2zJQOgQdLK65YYLyqzWf+VaJV8CXhvI2n5ikhQo4u\ndsDNh45p2qsaqOqv3S5NDOTMjCJBL/vn+Rl4uQAwI2OannK2S4HHM/7dF+OHtg8f\nW/c/3ZlSjeDmExFN5UPe2Da95WIO0DwuEMzB+LCTz0QmsBozGUT0okwmj8FKqIlk\nRXcM6bKAhQ6wgtxoVpK/a/UYL5HvqkDMc3hUX/mOno1X/B2CXN3iD3yQmg8gE0Mn\nngbqHyArXcZTfdlBhv0wUOqdlQFoSLtM0sLvM9mxzZEXyvTIGKLo4018zi00IeWc\nmcnRuYvcDi0iHbBrrK4XIhw+mPU1x6d4f7lH5DqPgXT6okwrp47mIxpXJ5h1y1A8\noT0ki04cP6Q42BKjN6ZVIL3KJt0kxLIZgoOtARSQcN7fT8FaG40=\n=b4A9\n-----END PGP SIGNATURE-----",
        "payload": "tree a3d1a174d5aec4d43813a46ca576efad8c68033d\nparent ae6bf7aeb5521eb58affd69bb370763e4380257d\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1493002874 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496905687 +0900\n\n[test] Added tests for arith_uint256::SetProbabilityTarget/GetProbabilityEstimate.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1e4764bc2fec38ddd6d86286f0a210bff3d69df/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ae6bf7aeb5521eb58affd69bb370763e4380257d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6bf7aeb5521eb58affd69bb370763e4380257d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ae6bf7aeb5521eb58affd69bb370763e4380257d"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 11,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0ed66118b0f5dee4fdfc8cfb1f56f5effc660c92",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1e4764bc2fec38ddd6d86286f0a210bff3d69df/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1e4764bc2fec38ddd6d86286f0a210bff3d69df/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
        "patch": "@@ -537,6 +537,17 @@ BOOST_AUTO_TEST_CASE(bignum_SetCompact)\n     BOOST_CHECK_EQUAL(fOverflow, true);\n }\n \n+BOOST_AUTO_TEST_CASE(probabilityTarget)\n+{\n+    arith_uint256 t;\n+    for (uint32_t target_attempts = 1; target_attempts < 256; target_attempts++) {\n+        double pt = 1.0/target_attempts;\n+        t.SetProbabilityTarget(pt);\n+        double got = t.GetProbabilityEstimate();\n+        BOOST_CHECK(std::abs(got - pt) < 0.0000001);\n+    }\n+}\n+\n \n BOOST_AUTO_TEST_CASE( getmaxcoverage ) // some more tests just to get 100% coverage\n {"
      }
    ]
  },
  {
    "sha": "cc9b380d2a7998bd2ba361fb00d7685054f7578f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzliMzgwZDJhNzk5OGJkMmJhMzYxZmIwMGQ3Njg1MDU0Zjc1Nzhm",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:17:10Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:08:33Z"
      },
      "message": "[pow] Added generic proof of work class.\n\nA new set of classes in pow/pow.h/cpp which serve as the parents for all the proof of work algorithms (contained in the powa:: namespace).\n\nThe powa::challenge class is a container for challenges offered by peers, and powa::solution is a container for solutions to challenges.\n\npowa::callback is used to ping-back solvers when a solution was found. There's a helper-class powa::callback_proxy which is used when an instance needs to use itself as the callback (as opposed to creating a new instance and handing ownership over to the prover).\n\npowa::pow is the base algorithm class inherited by the algorithm implementations, and finally powa::powchain is a simple wrapper for chaining algorithms together (e.g. sha256(cuckoo-cycle)).",
      "tree": {
        "sha": "591e77f4b289a4ce9feffdd875ac39a7e6e30307",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/591e77f4b289a4ce9feffdd875ac39a7e6e30307"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc9b380d2a7998bd2ba361fb00d7685054f7578f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk4+UAACgkQV692LbM1\nMyL9Qw//bCSWL0GxMDxUprlnLx3QaUzBiPE/87pT2dgTa3rraOxpTk1Qac9Wcf5b\n+1RF1ly3XhuUzImX7c7YswyvyCKAxKCP+tCqINjkG7bs9z1qN8qpoPICKc5FmmzG\n3OUMTVrRd6ETLR0IIoYGSUvE58lq3ms8EdM5e4b/kZF2zANe0bbM4hm3SJ2U2eKV\nzNreSEDPeH6fRx0ya9eXF2QgcoihsWO5HH4W1XT2XBUFu2RgVXdYqw8AFpsgnGNC\ns8fdZ2v2v07+gAgSQ2iirb7Al86S1kSx68ALkKMWvfdJ8T29RkhF9eEeHCSGtqzs\npACve9yhYh+c5S0ujRxnK7fHYwLdKRmPiSnJ/qm81KzvV2r4Qw6dX13ks4JIkU++\nrbOxw3EJvYjyq6VgXVevEaK984Tv1Xfjdki4oBbp/ibdL33zKfGFWUWfycezMdWE\nFIh/QXlOm1zjW17RYQSGveXtSDU7j0nlS2pOWDVzPwQchGtrEysJF5fkXGKlwe6X\nkJdKxU+4EBXnqOjKHnwaXOu/OKwpPRah3dIc7M0dn7HLZ/WyqW8xSvEm1O/yi/at\nughqusiRyHWOlIaOZiT20ZK6m/1BtV/OiCTBLAZUYjOrKw/R/Z5oxlzbhTEXTZzz\nxy4pbhGaZo4j85sLxr+NUIMcUu76jJr548w3h5YKYNJbp9hk6mo=\n=Eq2D\n-----END PGP SIGNATURE-----",
        "payload": "tree 591e77f4b289a4ce9feffdd875ac39a7e6e30307\nparent c1e4764bc2fec38ddd6d86286f0a210bff3d69df\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491902230 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496905713 +0900\n\n[pow] Added generic proof of work class.\n\nA new set of classes in pow/pow.h/cpp which serve as the parents for all the proof of work algorithms (contained in the powa:: namespace).\n\nThe powa::challenge class is a container for challenges offered by peers, and powa::solution is a container for solutions to challenges.\n\npowa::callback is used to ping-back solvers when a solution was found. There's a helper-class powa::callback_proxy which is used when an instance needs to use itself as the callback (as opposed to creating a new instance and handing ownership over to the prover).\n\npowa::pow is the base algorithm class inherited by the algorithm implementations, and finally powa::powchain is a simple wrapper for chaining algorithms together (e.g. sha256(cuckoo-cycle)).\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc9b380d2a7998bd2ba361fb00d7685054f7578f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc9b380d2a7998bd2ba361fb00d7685054f7578f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc9b380d2a7998bd2ba361fb00d7685054f7578f/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1e4764bc2fec38ddd6d86286f0a210bff3d69df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c1e4764bc2fec38ddd6d86286f0a210bff3d69df"
      }
    ],
    "stats": {
      "total": 306,
      "additions": 306,
      "deletions": 0
    },
    "files": [
      {
        "sha": "cd95963afb249356cbafea8cbbe902d3814d089f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc9b380d2a7998bd2ba361fb00d7685054f7578f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc9b380d2a7998bd2ba361fb00d7685054f7578f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=cc9b380d2a7998bd2ba361fb00d7685054f7578f",
        "patch": "@@ -121,6 +121,7 @@ BITCOIN_CORE_H = \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n+  pow/pow.h \\\n   pow.h \\\n   protocol.h \\\n   random.h \\\n@@ -199,6 +200,7 @@ libbitcoin_server_a_SOURCES = \\\n   policy/fees.cpp \\\n   policy/policy.cpp \\\n   policy/rbf.cpp \\\n+  pow/pow.cpp \\\n   pow.cpp \\\n   rest.cpp \\\n   rpc/blockchain.cpp \\"
      },
      {
        "sha": "bc14edb18f03c1e299f640dd3799a7cebf1988f0",
        "filename": "src/pow/pow.cpp",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc9b380d2a7998bd2ba361fb00d7685054f7578f/src/pow/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc9b380d2a7998bd2ba361fb00d7685054f7578f/src/pow/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/pow.cpp?ref=cc9b380d2a7998bd2ba361fb00d7685054f7578f",
        "patch": "@@ -0,0 +1,23 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"pow/pow.h\"\n+#include \"pow/cuckoo_cycle/cuckoo_cycle.h\"\n+#include \"pow/sha256/sha256.h\"\n+\n+namespace powa {\n+\n+bool fZeroStartingNonce = false;\n+\n+pow_ref pow::create(const uint32_t powid, challenge_ref c_in, callback_ref cb_in) {\n+    switch (powid) {\n+    case POWID_CUCKOO_CYCLE: return pow_ref(new cuckoo_cycle::cuckoo_cycle(cuckoo_cycle::cc_challenge_ref(new cuckoo_cycle::cc_challenge(*c_in)), cb_in));\n+    case POWID_SHA256:       return pow_ref(new sha256(challenge_ref(new sha256challenge(*c_in)), cb_in));\n+    default:\n+        fprintf(stderr, \"error: unknown powid:%u\\n\", powid);\n+        return nullptr;\n+    }\n+}\n+\n+}  // namespace powa"
      },
      {
        "sha": "56b6f359ec2b809bbe05adfa65984fd5c0990ef8",
        "filename": "src/pow/pow.h",
        "status": "added",
        "additions": 281,
        "deletions": 0,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc9b380d2a7998bd2ba361fb00d7685054f7578f/src/pow/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc9b380d2a7998bd2ba361fb00d7685054f7578f/src/pow/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/pow.h?ref=cc9b380d2a7998bd2ba361fb00d7685054f7578f",
        "patch": "@@ -0,0 +1,281 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POW_POW_H\n+#define BITCOIN_POW_POW_H\n+\n+#include <vector>\n+#include <stdint.h>\n+\n+#include \"random.h\"\n+#include \"serialize.h\"\n+#include \"tinyformat.h\"\n+\n+namespace powa {\n+\n+extern bool fZeroStartingNonce; ///< used for debugging to get deterministic challenges\n+\n+class challenge;\n+class solution;\n+class callback;\n+class pow;\n+\n+typedef std::shared_ptr<challenge> challenge_ref;\n+typedef std::shared_ptr<solution> solution_ref;\n+typedef std::shared_ptr<callback> callback_ref;\n+typedef std::shared_ptr<pow> pow_ref;\n+\n+enum solver_state {\n+    state_ready    = 1,  //!< ready to run\n+    state_running  = 2,  //!< currently running\n+    state_paused   = 3,  //!< ran out of ticks, and waiting to resume\n+    state_aborted  = 4,  //!< run was aborted\n+    state_stopped  = 5,  //!< no longer running\n+    state_term     = 6,  //!< asked to terminate\n+};\n+\n+static const uint32_t POWID_SHA256       = 1;\n+static const uint32_t POWID_CUCKOO_CYCLE = 2;\n+\n+class container {\n+public:\n+    std::vector<uint8_t> params;\n+    container() {}\n+    container(const std::vector<uint8_t>& params_in) : params(params_in) {}\n+    container(const container& other) { params = other.params; }\n+    void set_params(const uint8_t* arr, const uint32_t size) { params = std::vector<uint8_t>(arr, arr + size); }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(params);\n+    }\n+\n+    virtual bool operator==(const container& other) const {\n+        return params == other.params;\n+    }\n+};\n+\n+class challenge : public container {\n+public:\n+    container config;\n+    using container::container;\n+    challenge() : container() {}\n+    challenge(const challenge& other) : container(other) { config = other.config; }\n+    void randomize(const uint32_t bytes, const uint32_t offset = 0) {\n+        if (params.size() < bytes) params.resize(bytes);\n+        GetRandBytes(&params.begin()[offset], bytes);\n+    }\n+    /**\n+     * Generate a random challenge of this POW type.\n+     * @param  size Number of random bytes to generate.\n+     * @return      A challenge whose params consists of size random bytes.\n+     */\n+    static challenge* random_challenge(const uint32_t size) {\n+        challenge* c = new challenge();\n+        c->randomize(size);\n+        return c;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(config);\n+        READWRITE(params);\n+    }\n+};\n+\n+class solution : public container {\n+public:\n+    using container::container;\n+    solution() : container() {}\n+    template<typename T> solution(T t) {\n+        params.resize(sizeof(T));\n+        memcpy(&params[0], &t, sizeof(T));\n+    }\n+};\n+\n+class pow;\n+\n+class callback {\n+public:\n+    virtual ~callback() {}\n+    /**\n+     * Called whenever a solution is found to a given challenge. This method\n+     * should return true if the solution satisfies external requirements or\n+     * false if the solver should continue finding solutions.\n+     * @param  p The proof of work\n+     * @param  c The challenge\n+     * @param  s The solution\n+     * @return   Whether the solver should continue looking.\n+     */\n+    virtual bool found_solution(const pow& p, challenge_ref c, solution_ref s) {\n+        assert(!\"not implemented found_solution callback\");\n+    }\n+};\n+\n+class callback_proxy : public callback {\n+public:\n+    callback* actual;\n+    callback_proxy(callback* actual_in) : actual(actual_in) {}\n+    bool found_solution(const pow& p, challenge_ref c, solution_ref s) override {\n+        return actual->found_solution(p, c, s);\n+    }\n+};\n+\n+class pow {\n+public:\n+    uint32_t powid;\n+    challenge_ref c;\n+    callback_ref cb;\n+    solver_state state;\n+    int32_t ticks_left;\n+\n+    static pow_ref create(const uint32_t powid, challenge_ref c_in, callback_ref cb_in = nullptr);\n+\n+    pow(uint32_t powid_in, challenge_ref c_in, callback_ref cb_in = nullptr) : powid(powid_in), c(c_in), cb(cb_in), state(state_ready) {}\n+\n+    /**\n+     * Determine if s is a valid solution to c.\n+     * @param  s A solution to this POW\n+     * @return   Whether the solution solves the challenge.\n+     */\n+    virtual bool is_valid(solution& s) const = 0;\n+\n+    /**\n+     * Set the given vector to the output given the solution s.\n+     * @param s      The solution on which output should be based.\n+     * @param output The output produced by this POW.\n+     */\n+    virtual void set_output(solution& s, std::vector<uint8_t>& output) = 0;\n+\n+    /**\n+     * Attempt to solve c in the given number of threads over the given number\n+     * of ticks. Whenever a solution is found, cb.found_solution is called with\n+     * the given solution.\n+     * @param threads    The number of threads to spin up to solve.\n+     * @param background If true, the solver will create a new thread and work from there, returning control to the caller immediately.\n+     * @param ticks      Number of ticks (cycles) to attempt before temporarily pausing. If -1, unlimited.\n+     */\n+    virtual void solve(uint32_t threads = 0, bool background = false, int32_t ticks = -1) = 0;\n+\n+    /**\n+     * Stop solving.\n+     */\n+    virtual void abort() {\n+        if (state == state_running) state = state_term;\n+    }\n+\n+    virtual int64_t expected_iteration_cycles() const = 0;\n+    virtual int64_t expected_invprob() const = 0;\n+\n+    bool operator==(const pow& other) const {\n+        return powid == other.powid &&\n+            *c == *other.c;\n+    }\n+\n+    virtual std::string to_string() const {\n+        return strprintf(\"POW<id=%u; ptr=%p>\", powid, this);\n+    }\n+};\n+\n+class powchain : public pow, public callback {\n+public:\n+    std::vector<pow_ref> pows;\n+\n+    powchain(challenge_ref c_in = challenge_ref(new challenge()), callback_ref cb_in = nullptr) : pow(0, c_in, cb_in) {}\n+\n+    void add_pow(pow_ref p) {\n+        pows.push_back(p);\n+    }\n+\n+    bool found_solution(const pow& p, challenge_ref c, solution_ref s) override {\n+        if (p == *pows.back()) {\n+            if (!is_valid(*s)) return false;\n+            return cb->found_solution(*this, c, s);\n+        }\n+        assert(p == *pows.front());\n+        return cb->found_solution(p, c, s);\n+    }\n+\n+    bool is_valid(solution& s) const override {\n+        solution z = s;\n+        std::vector<uint8_t> output;\n+        for (auto it = pows.rbegin(); it != pows.rend(); ++it) {\n+            pow* p = it->get();\n+            if (!p->is_valid(z)) return false;\n+            p->set_output(z, output);\n+            z = solution(output);\n+        }\n+        return true;\n+    }\n+\n+    void set_output(solution& s, std::vector<uint8_t>& output) override {\n+        pows.back()->set_output(s, output);\n+    }\n+\n+    void solve(uint32_t threads = 0, bool background = false, int32_t ticks = -1) override {\n+        pows.back()->cb = callback_ref(new callback_proxy(this));\n+        pows.back()->solve(threads, false, ticks);\n+        state = pows.back()->state; // TODO: deal with background case (right now using false for background always)\n+    }\n+\n+    int64_t expected_iteration_cycles() const override {\n+        int64_t cycles = 0;\n+        for (pow_ref p : pows) {\n+            cycles += p->expected_iteration_cycles();\n+        }\n+        return cycles;\n+    }\n+\n+    int64_t expected_invprob() const override {\n+        int64_t invprob = 1;\n+        for (pow_ref p : pows) {\n+            invprob *= p->expected_invprob();\n+        }\n+        return invprob;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        if (ser_action.ForRead()) {\n+            uint8_t pows_size;\n+            READWRITE(pows_size);\n+            pows.resize(pows_size);\n+            for (uint32_t i = 0; i < pows_size; i++) {\n+                uint32_t powid;\n+                challenge_ref c(new challenge());\n+                READWRITE(powid);\n+                READWRITE(*c);\n+                pow_ref p = pow::create(powid, c);\n+                pows[i] = p;\n+            }\n+            return;\n+        }\n+\n+        // Writing to stream\n+        uint8_t pows_size = pows.size();\n+        READWRITE(pows_size);\n+        for (pow_ref p : pows) {\n+            READWRITE(p->powid);\n+            READWRITE(*p->c);\n+        }\n+    }\n+\n+    virtual std::string to_string() const override {\n+        std::string s = strprintf(\"POW-chain<%p>[\", this);\n+        for (pow_ref p : pows) {\n+            s += \"\\n\\t\" + p->to_string();\n+        }\n+        return s + \"\\n]\";\n+    }\n+};\n+\n+}  // namespace powa\n+\n+#endif  // BITCOIN_POW_POW_H"
      }
    ]
  },
  {
    "sha": "260857464182f9a9f8fa10dd5f68eab21a8bba23",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNjA4NTc0NjQxODJmOWE5ZjhmYTEwZGQ1ZjY4ZWFiMjFhOGJiYTIz",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:20:16Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:14:09Z"
      },
      "message": "Imported cuckoo cycle code.\n\nOrigin: https://github.com/tromp/cuckoo\n\nThis commit is purposefully left as closely resembling the original source as possible, although some tweaks have been put in (in particular namespace embedding). A separate commit adapts it for the Bitcoin codebase.",
      "tree": {
        "sha": "f614485f51a32155ade03cb53a789d746e70094a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f614485f51a32155ade03cb53a789d746e70094a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/260857464182f9a9f8fa10dd5f68eab21a8bba23",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk4+a8ACgkQV692LbM1\nMyKBsg/7Bs2PGF6jqRZCmpTZi8HoQLgsIbq/BCGQUE0mXe89WegUoovGjKuDcOSv\n8iPU4XyYGDezC1syaFw2xZUq+zEJenLTov+OU7t8E9v9J80w7SpDIrM16vIbAZHa\ntRtggTymm0OZB+kIIU8I1w3KfkpOKIeRh4PUlpirrSdP9BY9u3iU8/KF02fAZ1KI\nFtXNADyp2QQ8itqnNhQdK5QBNs4nUvdrct6/ASw2pxfv5yaaOxXso2K39syYNNi+\n1Ms2Ns/Bo0ACPTyZhO1FmnU8ErNAhsqTnJCkroQPVmiN+EG7Q6b438zFVJNVvAae\nMCjwrF8tYFEavPcZ3i0aEnPjfbN46aeN+46GAcQqyunN/5QI7TejcDEi6sGlTC/f\nND2U55Sh5hZhbM7SRMsZJKG9W6E6URABaZoEMzPmaQlCW94SdCS+pKZuJRdtpAs2\ngh0q8eIk7ZGlgl+Xo1ZY5UvdrM7guVTBUDSNC1x2/hGru2n3bfEwpBP87jv5k4k9\nDWafCGTuPx4ihFpOYNmfwgBlYG+EeZgoWdnjSFu3PGmAsKIeRJoMbKMLHTaxRf8R\n0CSLKIJ385orsK3I4AD3WgBSzvnN1bXxxndCHMftq+uhuPEPirSwvY6gBbzrgJI4\nLGn45aBnEb5ZNNXT+Q7sMRfyRS/HGUPtU3ng9T6jOTD46OmD4qk=\n=rlz9\n-----END PGP SIGNATURE-----",
        "payload": "tree f614485f51a32155ade03cb53a789d746e70094a\nparent cc9b380d2a7998bd2ba361fb00d7685054f7578f\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491902416 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496906049 +0900\n\nImported cuckoo cycle code.\n\nOrigin: https://github.com/tromp/cuckoo\n\nThis commit is purposefully left as closely resembling the original source as possible, although some tweaks have been put in (in particular namespace embedding). A separate commit adapts it for the Bitcoin codebase.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/260857464182f9a9f8fa10dd5f68eab21a8bba23",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/260857464182f9a9f8fa10dd5f68eab21a8bba23",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/260857464182f9a9f8fa10dd5f68eab21a8bba23/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc9b380d2a7998bd2ba361fb00d7685054f7578f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc9b380d2a7998bd2ba361fb00d7685054f7578f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc9b380d2a7998bd2ba361fb00d7685054f7578f"
      }
    ],
    "stats": {
      "total": 766,
      "additions": 766,
      "deletions": 0
    },
    "files": [
      {
        "sha": "566814ce857e90260079d2711b01e958a7507e47",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "patch": "@@ -121,6 +121,9 @@ BITCOIN_CORE_H = \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n+  pow/cuckoo_cycle/cuckoo_miner.h \\\n+  pow/cuckoo_cycle/cuckoo.h \\\n+  pow/cuckoo_cycle/siphash.h \\\n   pow/pow.h \\\n   pow.h \\\n   protocol.h \\"
      },
      {
        "sha": "89ccdb1ca9c2d00bf333c313811c91e324f4134a",
        "filename": "src/pow/cuckoo_cycle/LICENSE.txt",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/LICENSE.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/LICENSE.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/LICENSE.txt?ref=260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "patch": "@@ -0,0 +1,21 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2013-2016 John Tromp\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
      },
      {
        "sha": "48503f696bbe5f544044698c806053034aac1a31",
        "filename": "src/pow/cuckoo_cycle/cuckoo.h",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/cuckoo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/cuckoo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/cuckoo.h?ref=260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "patch": "@@ -0,0 +1,93 @@\n+// Cuckoo Cycle, a memory-hard proof-of-work\n+// Copyright (c) 2013-2016 John Tromp\n+\n+#ifndef BITCOIN_POW_CUCKOO_CYCLE_CUCKOO_H\n+#define BITCOIN_POW_CUCKOO_CYCLE_CUCKOO_H\n+\n+#include <stdint.h> // for types uint32_t,uint64_t\n+#include <string.h> // for functions strlen, memset\n+#include \"siphash.h\"\n+// both cuckoo.c and cuckoo_miner.h need htole32\n+#ifdef __APPLE__\n+#include \"osx_barrier.h\"\n+#include <machine/endian.h>\n+#include <libkern/OSByteOrder.h>\n+#define htole32(x) OSSwapHostToLittleInt32(x)\n+#else\n+#include <endian.h>\n+#endif\n+\n+namespace powa {\n+\n+namespace cuckoo_cycle {\n+\n+// proof-of-work parameters\n+#ifndef SIZESHIFT\n+// the main parameter is the 2log of the graph size,\n+// which is the size in bits of the node identifiers\n+#define SIZESHIFT 20\n+#endif\n+#ifndef PROOFSIZE\n+// the next most important parameter is (even) length\n+// of the cycle to be found. a minimum of 12 is recommended\n+#define PROOFSIZE 42\n+#endif\n+\n+// the graph size / number of nodes\n+static const u64 SIZE = 1ULL<<SIZESHIFT;\n+// number of nodes in one partition (eg. all even nodes)\n+static const u64 HALFSIZE = SIZE/2;\n+// used to mask siphash output\n+static const u64 NODEMASK = HALFSIZE-1;\n+\n+// generate edge endpoint in cuckoo graph without partition bit\n+u64 _sipnode(siphash_keys *keys, u64 nonce, u32 uorv) {\n+  return siphash24(keys, 2*nonce + uorv) & NODEMASK;\n+}\n+\n+// generate edge endpoint in cuckoo graph\n+u64 sipnode(siphash_keys *keys, u64 nonce, u32 uorv) {\n+  return _sipnode(keys, nonce, uorv) << 1 | uorv;\n+}\n+\n+enum verify_code { POW_OK, POW_HEADER_LENGTH, POW_TOO_BIG, POW_TOO_SMALL, POW_NON_MATCHING, POW_BRANCH, POW_DEAD_END, POW_SHORT_CYCLE};\n+const char *errstr[] = { \"OK\", \"wrong header length\", \"proof too big\", \"proof too small\", \"endpoints don't match up\", \"branch in cycle\", \"cycle dead ends\", \"cycle too short\"};\n+\n+// verify that nonces are ascending and form a cycle in header-generated graph\n+int verify(u32 nonces[PROOFSIZE], const char *headernonce, const u32 headerlen) {\n+  if (headerlen != HEADERLEN)\n+    return POW_HEADER_LENGTH;\n+  siphash_keys keys;\n+  setheader(&keys, headernonce);\n+  u32 uvs[2*PROOFSIZE];\n+  u32 xor0=0,xor1=0;\n+  for (u32 n = 0; n < PROOFSIZE; n++) {\n+    if (nonces[n] >= HALFSIZE)\n+      return POW_TOO_BIG;\n+    if (n && nonces[n] <= nonces[n-1])\n+      return POW_TOO_SMALL;\n+    xor0 ^= uvs[2*n  ] = sipnode(&keys, nonces[n], 0);\n+    xor1 ^= uvs[2*n+1] = sipnode(&keys, nonces[n], 1);\n+  }\n+  if (xor0|xor1)                        // matching endpoints imply zero xors\n+    return POW_NON_MATCHING;\n+  u32 n = 0, i = 0, j;\n+  do {                        // follow cycle\n+    for (u32 k = j = i; (k = (k+2) % (2*PROOFSIZE)) != i; ) {\n+      if (uvs[k] == uvs[i]) { // find other edge endpoint identical to one at i\n+        if (j != i)           // already found one before\n+          return POW_BRANCH;\n+        j = k;\n+      }\n+    } if (j == i) return POW_DEAD_END;  // no matching endpoint\n+    i = j^1;\n+    n++;\n+  } while (i != 0);           // must cycle back to start or we would have found branch\n+  return n == PROOFSIZE ? POW_OK : POW_SHORT_CYCLE;\n+}\n+\n+}  // namespace cuckoo_cycle\n+\n+}  // namespace powa\n+\n+#endif  // BITCOIN_POW_CUCKOO_CYCLE_CUCKOO_H"
      },
      {
        "sha": "3fbc4390a40ed2af228d04321203cf771199d2e3",
        "filename": "src/pow/cuckoo_cycle/cuckoo_miner.h",
        "status": "added",
        "additions": 486,
        "deletions": 0,
        "changes": 486,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/cuckoo_miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/cuckoo_miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/cuckoo_miner.h?ref=260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "patch": "@@ -0,0 +1,486 @@\n+// Cuckoo Cycle, a memory-hard proof-of-work\n+// Copyright (c) 2013-2016 John Tromp\n+// The edge-trimming memory optimization is due to Dave Andersen\n+// http://da-data.blogspot.com/2014/03/a-public-review-of-cuckoo-cycle.html\n+// The use of prefetching was suggested by Alexander Peslyak (aka Solar Designer)\n+// define SINGLECYCLING to run cycle finding single threaded which runs slower\n+// but avoids losing cycles to race conditions (not worth it in my testing)\n+\n+#ifndef BITCOIN_POW_CUCKOO_CYCLE_CUCKOO_MINER_H\n+#define BITCOIN_POW_CUCKOO_CYCLE_CUCKOO_MINER_H\n+\n+#include \"cuckoo.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <pthread.h>\n+#include <assert.h>\n+#include <set>\n+\n+#ifdef ATOMIC\n+#include <atomic>\n+#endif\n+\n+namespace powa {\n+\n+namespace cuckoo_cycle {\n+\n+#ifdef ATOMIC\n+typedef std::atomic<u32> au32;\n+typedef std::atomic<u64> au64;\n+#else\n+typedef u32 au32;\n+typedef u64 au64;\n+#endif\n+\n+#ifndef SIZEOF_TWICE_ATOM\n+#define SIZEOF_TWICE_ATOM 4\n+#endif\n+#if SIZEOF_TWICE_ATOM == 8\n+typedef au64 atwice;\n+typedef u64 uatwice;\n+#elif SIZEOF_TWICE_ATOM == 4\n+typedef au32 atwice;\n+typedef u32 uatwice;\n+#elif SIZEOF_TWICE_ATOM == 1\n+typedef unsigned char atwice;\n+typedef unsigned char uatwice;\n+#else\n+#error not implemented\n+#endif\n+\n+#if SIZESHIFT <= 32\n+typedef u32 nonce_t;\n+typedef u32 node_t;\n+#else\n+typedef u64 nonce_t;\n+typedef u64 node_t;\n+#endif\n+\n+// algorithm/performance parameters\n+#ifndef PART_BITS\n+// #bits used to partition edge set processing to save memory\n+// a value of 0 does no partitioning and is fastest\n+// a value of 1 partitions in two, making twice_set the\n+// same size as shrinkingset at about 33% slowdown\n+// higher values are not that interesting\n+#define PART_BITS 0\n+#endif\n+\n+#ifndef NPREFETCH\n+// how many prefetches to queue up\n+// before accessing the memory\n+// must be a multiple of NSIPHASH\n+#define NPREFETCH 32\n+#endif\n+\n+#ifndef IDXSHIFT\n+// we want sizeof(cuckoo_hash) == sizeof(twice_set), so\n+// CUCKOO_SIZE * sizeof(u64)   == 2 * ONCE_BITS / 32\n+// CUCKOO_SIZE * 2             == 2 * ONCE_BITS / 32\n+// (SIZE >> IDXSHIFT) * 2      == 2 * ONCE_BITS / 32\n+// SIZE >> IDXSHIFT            == HALFSIZE >> PART_BITS >> 5\n+// IDXSHIFT                    == 1 + PART_BITS + 5\n+#define IDXSHIFT (PART_BITS + 6)\n+#endif\n+// grow with cube root of size, hardly affected by trimming\n+const static u32 MAXCCPATHLEN = 8 << (SIZESHIFT/3);\n+\n+const static u32 PART_MASK = (1 << PART_BITS) - 1;\n+const static u64 ONCE_BITS = HALFSIZE >> PART_BITS;\n+const static u64 TWICE_BYTES = (2 * ONCE_BITS) / 8;\n+const static u64 TWICE_ATOMS = TWICE_BYTES / sizeof(atwice);\n+const static u32 TWICE_PER_ATOM = sizeof(atwice) * 4;\n+\n+class twice_set {\n+public:\n+  atwice *bits;\n+\n+  twice_set() {\n+    bits = (atwice *)calloc(TWICE_ATOMS, sizeof(atwice));\n+    assert(bits != 0);\n+  }\n+  void clear() {\n+    assert(bits);\n+    memset(bits, 0, TWICE_ATOMS*sizeof(atwice));\n+  }\n+ void prefetch(node_t u) const {\n+#ifdef PREFETCH\n+    __builtin_prefetch((const void *)(&bits[u/TWICE_PER_ATOM]), /*READ=*/0, /*TEMPORAL=*/0);\n+#endif\n+  }\n+  void set(node_t u) {\n+    node_t idx = u/TWICE_PER_ATOM;\n+    uatwice bit = (uatwice)1 << (2 * (u%TWICE_PER_ATOM));\n+#ifdef ATOMIC\n+    uatwice old = std::atomic_fetch_or_explicit(&bits[idx], bit, std::memory_order_relaxed);\n+    if (old & bit) std::atomic_fetch_or_explicit(&bits[idx], bit<<1, std::memory_order_relaxed);\n+#else\n+    uatwice old = bits[idx];\n+    bits[idx] = old | (bit + (old & bit));\n+#endif\n+  }\n+  bool test(node_t u) const {\n+#ifdef ATOMIC\n+    return ((bits[u/TWICE_PER_ATOM].load(std::memory_order_relaxed)\n+            >> (2 * (u%TWICE_PER_ATOM))) & 2) != 0;\n+#else\n+    return (bits[u/TWICE_PER_ATOM] >> (2 * (u%TWICE_PER_ATOM)) & 2) != 0;\n+#endif\n+  }\n+  ~twice_set() {\n+    free(bits);\n+  }\n+};\n+\n+// set that starts out full and gets reset by threads on disjoint words\n+class shrinkingset {\n+public:\n+  u64 *bits;\n+  u64 *cnt;\n+  u32 nthreads;\n+\n+  shrinkingset(const u32 nt) {\n+    bits = (u64 *)malloc(HALFSIZE/8);\n+    cnt  = (u64 *)malloc(nt * sizeof(u64));\n+    nthreads = nt;\n+  }\n+  void clear() {\n+    memset(bits, 0, HALFSIZE/8);\n+    memset(cnt, 0, nthreads * sizeof(u64));\n+    cnt[0] = HALFSIZE;\n+  }\n+  u64 count() const {\n+    u64 sum = 0LL;\n+    for (u32 i=0; i<nthreads; i++)\n+      sum += cnt[i];\n+    return sum;\n+  }\n+  void reset(nonce_t n, u32 thread) {\n+    bits[n/64] |= 1LL << (n%64);\n+    cnt[thread]--;\n+  }\n+  bool test(node_t n) const {\n+    return !((bits[n/64] >> (n%64)) & 1LL);\n+  }\n+  u64 block(node_t n) const {\n+    return ~bits[n/64];\n+  }\n+};\n+\n+const static u64 CUCKOO_SIZE = SIZE >> IDXSHIFT;\n+const static u64 CUCKOO_MASK = CUCKOO_SIZE - 1;\n+// number of (least significant) key bits that survives leftshift by SIZESHIFT\n+const static u32 KEYBITS = 64-SIZESHIFT;\n+const static u64 KEYMASK = (1LL << KEYBITS) - 1;\n+const static u64 MAXDRIFT = 1LL << (KEYBITS - IDXSHIFT);\n+\n+class cuckoo_hash {\n+public:\n+  au64 *cuckoo;\n+\n+  cuckoo_hash(void *recycle) {\n+    cuckoo = (au64 *)recycle;\n+    memset(cuckoo, 0, CUCKOO_SIZE*sizeof(au64));\n+  }\n+  void set(node_t u, node_t v) {\n+    u64 niew = (u64)u << SIZESHIFT | v;\n+    for (node_t ui = u >> IDXSHIFT; ; ui = (ui+1) & CUCKOO_MASK) {\n+#if !defined(SINGLECYCLING) && defined(ATOMIC)\n+      u64 old = 0;\n+      if (cuckoo[ui].compare_exchange_strong(old, niew, std::memory_order_relaxed))\n+        return;\n+      if ((old >> SIZESHIFT) == (u & KEYMASK)) {\n+        cuckoo[ui].store(niew, std::memory_order_relaxed);\n+        return;\n+      }\n+#else\n+      u64 old = cuckoo[ui];\n+      if (old == 0 || (old >> SIZESHIFT) == (u & KEYMASK)) {\n+        cuckoo[ui] = niew;\n+        return;\n+      }\n+#endif\n+    }\n+  }\n+  node_t operator[](node_t u) const {\n+    for (node_t ui = u >> IDXSHIFT; ; ui = (ui+1) & CUCKOO_MASK) {\n+#if !defined(SINGLECYCLING) && defined(ATOMIC)\n+      u64 cu = cuckoo[ui].load(std::memory_order_relaxed);\n+#else\n+      u64 cu = cuckoo[ui];\n+#endif\n+      if (!cu)\n+        return 0;\n+      if ((cu >> SIZESHIFT) == (u & KEYMASK)) {\n+        assert(((ui - (u >> IDXSHIFT)) & CUCKOO_MASK) < MAXDRIFT);\n+        return (node_t)(cu & (SIZE-1));\n+      }\n+    }\n+  }\n+};\n+\n+class cuckoo_ctx {\n+public:\n+  siphash_keys sip_keys;\n+  shrinkingset *alive;\n+  twice_set *nonleaf;\n+  cuckoo_hash *cuckoo;\n+  nonce_t (*sols)[PROOFSIZE];\n+  u32 maxsols;\n+  au32 nsols;\n+  u32 nthreads;\n+  u32 ntrims;\n+  pthread_barrier_t barry;\n+\n+  cuckoo_ctx(u32 n_threads, u32 n_trims, u32 max_sols) {\n+    nthreads = n_threads;\n+    alive = new shrinkingset(nthreads);\n+    cuckoo = 0;\n+    nonleaf = new twice_set;\n+    ntrims = n_trims;\n+    int err = pthread_barrier_init(&barry, NULL, nthreads);\n+    assert(err == 0);\n+    sols = (nonce_t (*)[PROOFSIZE])calloc(maxsols = max_sols, PROOFSIZE*sizeof(nonce_t));\n+    assert(sols != 0);\n+    nsols = 0;\n+  }\n+  void setheadernonce(char* headernonce, const u32 len, const u32 nonce) {\n+    ((u32 *)headernonce)[len/sizeof(u32)-1] = htole32(nonce); // place nonce at end\n+    setheader(&sip_keys, headernonce);\n+    alive->clear(); // set all edges to be alive\n+    nsols = 0;\n+  }\n+  ~cuckoo_ctx() {\n+    delete alive;\n+    delete nonleaf;\n+    delete cuckoo;\n+  }\n+  void prefetch(const u64 *hashes, const u32 part) const {\n+    for (u32 i=0; i < NSIPHASH; i++) {\n+      u32 u = hashes[i] & NODEMASK;\n+      if ((u & PART_MASK) == part) {\n+        nonleaf->prefetch(u >> PART_MASK);\n+      }\n+    }\n+  }\n+  void node_deg(const u64 *hashes, const u32 nsiphash, const u32 part) const {\n+    for (u32 i=0; i < nsiphash; i++) {\n+      u32 u = hashes[i] & NODEMASK;\n+      if ((u & PART_MASK) == part) {\n+        nonleaf->set(u >>= PART_BITS);\n+      }\n+    }\n+  }\n+  void count_node_deg(const u32 id, const u32 uorv, const u32 part) {\n+    alignas(64) u64 indices[NSIPHASH];\n+    alignas(64) u64 hashes[NPREFETCH];\n+\n+    memset(hashes, 0, NPREFETCH * sizeof(u64)); // allow many nonleaf->set(0) to reduce branching\n+    u32 nidx = 0;\n+    for (nonce_t block = id*64; block < HALFSIZE; block += nthreads*64) {\n+      u64 alive64 = alive->block(block);\n+      for (nonce_t nonce = block-1; alive64; ) { // -1 compensates for 1-based ffs\n+        u32 ffs = __builtin_ffsll(alive64);\n+        nonce += ffs; alive64 >>= ffs;\n+        indices[nidx++ % NSIPHASH] = 2*nonce + uorv;\n+        if (nidx % NSIPHASH == 0) {\n+          node_deg(hashes+nidx-NSIPHASH, NSIPHASH, part);\n+          siphash24xN(&sip_keys, indices, hashes+nidx-NSIPHASH);\n+          prefetch(hashes+nidx-NSIPHASH, part);\n+          nidx %= NPREFETCH;\n+        }\n+        if (ffs & 64) break; // can't shift by 64\n+      }\n+    }\n+    node_deg(hashes, NPREFETCH, part);\n+    if (nidx % NSIPHASH != 0) {\n+      siphash24xN(&sip_keys, indices, hashes+(nidx&-NSIPHASH));\n+      node_deg(hashes+(nidx&-NSIPHASH), nidx%NSIPHASH, part);\n+    }\n+  }\n+  void kill(const u64 *hashes, const u64 *indices, const u32 nsiphash,\n+             const u32 part, const u32 id) const {\n+    for (u32 i=0; i < nsiphash; i++) {\n+      u32 u = hashes[i] & NODEMASK;\n+      if ((u & PART_MASK) == part && !nonleaf->test(u >> PART_BITS)) {\n+        alive->reset(indices[i]/2, id);\n+      }\n+    }\n+  }\n+  void kill_leaf_edges(const u32 id, const u32 uorv, const u32 part) {\n+    alignas(64) u64 indices[NPREFETCH];\n+    alignas(64) u64 hashes[NPREFETCH];\n+\n+    memset(hashes, 0, NPREFETCH * sizeof(u64)); // allow many nonleaf->test(0) to reduce branching\n+    u32 nidx = 0;\n+    for (nonce_t block = id*64; block < HALFSIZE; block += nthreads*64) {\n+      u64 alive64 = alive->block(block);\n+      for (nonce_t nonce = block-1; alive64; ) { // -1 compensates for 1-based ffs\n+        u32 ffs = __builtin_ffsll(alive64);\n+        nonce += ffs; alive64 >>= ffs;\n+        indices[nidx++] = 2*nonce + uorv;\n+        if (nidx % NSIPHASH == 0) {\n+          siphash24xN(&sip_keys, indices+nidx-NSIPHASH, hashes+nidx-NSIPHASH);\n+          prefetch(hashes+nidx-NSIPHASH, part);\n+          nidx %= NPREFETCH;\n+          kill(hashes+nidx, indices+nidx, NSIPHASH, part, id);\n+        }\n+        if (ffs & 64) break; // can't shift by 64\n+      }\n+    }\n+    const u32 pnsip = nidx & -NSIPHASH;\n+    if (pnsip != nidx) {\n+      siphash24xN(&sip_keys, indices+pnsip, hashes+pnsip);\n+    }\n+    kill(hashes, indices, nidx, part, id);\n+    const u32 nnsip = pnsip + NSIPHASH;\n+    kill(hashes+nnsip, indices+nnsip, NPREFETCH-nnsip, part, id);\n+  }\n+  void solution(node_t *us, u32 nu, node_t *vs, u32 nv) {\n+    typedef std::pair<node_t,node_t> edge;\n+    std::set<edge> cycle;\n+    u32 n = 0;\n+    cycle.insert(edge(*us, *vs));\n+    while (nu--)\n+      cycle.insert(edge(us[(nu+1)&~1], us[nu|1])); // u's in even position; v's in odd\n+    while (nv--)\n+      cycle.insert(edge(vs[nv|1], vs[(nv+1)&~1])); // u's in odd position; v's in even\n+  #ifdef ATOMIC\n+    u32 soli = std::atomic_fetch_add_explicit(&nsols, 1U, std::memory_order_relaxed);\n+  #else\n+    u32 soli = nsols++;\n+  #endif\n+    for (nonce_t block = 0; block < HALFSIZE; block += 64) {\n+      u64 alive64 = alive->block(block);\n+      for (nonce_t nonce = block-1; alive64; ) { // -1 compensates for 1-based ffs\n+        u32 ffs = __builtin_ffsll(alive64);\n+        nonce += ffs; alive64 >>= ffs;\n+        edge e(sipnode(&sip_keys, nonce, 0), sipnode(&sip_keys, nonce, 1));\n+        if (cycle.find(e) != cycle.end()) {\n+          sols[soli][n++] = nonce;\n+  #ifdef SHOWSOL\n+          printf(\"e(%x)=(%x,%x)%c\", nonce, e.first, e.second, n==PROOFSIZE?'\\n':' ');\n+  #endif\n+          if (PROOFSIZE > 2)\n+            cycle.erase(e);\n+        }\n+        if (ffs & 64) break; // can't shift by 64\n+      }\n+    }\n+    assert(n==PROOFSIZE);\n+  }\n+};\n+\n+typedef struct {\n+  u32 id;\n+  pthread_t thread;\n+  cuckoo_ctx *ctx;\n+} thread_ctx;\n+\n+void barrier(pthread_barrier_t *barry) {\n+  int rc = pthread_barrier_wait(barry);\n+  if (rc != 0 && rc != PTHREAD_BARRIER_SERIAL_THREAD) {\n+    printf(\"Could not wait on barrier\\n\");\n+    pthread_exit(NULL);\n+  }\n+}\n+\n+u32 path(cuckoo_hash &cuckoo, node_t u, node_t *us) {\n+  u32 nu;\n+  for (nu = 0; u; u = cuckoo[u]) {\n+    if (nu >= MAXCCPATHLEN) {\n+      while (nu-- && us[nu] != u) ;\n+      // if (!~nu)\n+      //   printf(\"maximum path length exceeded\\n\");\n+      // else printf(\"illegal %4d-cycle\\n\", MAXCCPATHLEN-nu);\n+      pthread_exit(NULL);\n+    }\n+    us[nu++] = u;\n+  }\n+  return nu-1;\n+}\n+\n+void *worker(void *vp) {\n+  thread_ctx *tp = (thread_ctx *)vp;\n+  cuckoo_ctx *ctx = tp->ctx;\n+\n+  shrinkingset *alive = ctx->alive;\n+  u32 load = 100LL * HALFSIZE / CUCKOO_SIZE;\n+  // if (tp->id == 0)\n+  //   printf(\"initial load %d%%\\n\", load);\n+  for (u32 round=1; round <= ctx->ntrims; round++) {\n+    // if (tp->id == 0) printf(\"round %2d partition loads\", round);\n+    for (u32 uorv = 0; uorv < 2; uorv++) {\n+      for (u32 part = 0; part <= PART_MASK; part++) {\n+        if (tp->id == 0)\n+          ctx->nonleaf->clear(); // clear all counts\n+        barrier(&ctx->barry);\n+        ctx->count_node_deg(tp->id,uorv,part);\n+        barrier(&ctx->barry);\n+        ctx->kill_leaf_edges(tp->id,uorv,part);\n+        barrier(&ctx->barry);\n+        // if (tp->id == 0) {\n+        //   u32 load = (u32)(100LL * alive->count() / CUCKOO_SIZE);\n+        //   printf(\" %c%d %4d%%\", \"UV\"[uorv], part, load);\n+        // }\n+      }\n+    }\n+    // if (tp->id == 0) printf(\"\\n\");\n+  }\n+  if (tp->id == 0) {\n+    load = (u32)(100LL * alive->count() / CUCKOO_SIZE);\n+    // printf(\"nonce %d: %d trims completed  final load %d%%\\n\", ctx->nonce, ctx->ntrims, load);\n+    if (load >= 90) {\n+      printf(\"overloaded! exiting...\");\n+      pthread_exit(NULL);\n+    }\n+    ctx->cuckoo = new cuckoo_hash(ctx->nonleaf->bits);\n+  }\n+#ifdef SINGLECYCLING\n+  else pthread_exit(NULL);\n+#else\n+  barrier(&ctx->barry);\n+#endif\n+  cuckoo_hash &cuckoo = *ctx->cuckoo;\n+  node_t us[MAXCCPATHLEN], vs[MAXCCPATHLEN];\n+#ifdef SINGLECYCLING\n+  for (nonce_t block = 0; block < HALFSIZE; block += 64) {\n+#else\n+  for (nonce_t block = tp->id*64; block < HALFSIZE; block += ctx->nthreads*64) {\n+#endif\n+    u64 alive64 = alive->block(block);\n+    for (nonce_t nonce = block-1; alive64; ) { // -1 compensates for 1-based ffs\n+      u32 ffs = __builtin_ffsll(alive64);\n+      nonce += ffs; alive64 >>= ffs;\n+      node_t u0=sipnode(&ctx->sip_keys, nonce, 0), v0=sipnode(&ctx->sip_keys, nonce, 1);\n+      if (u0) {// ignore vertex 0 so it can be used as nil for cuckoo[]\n+        u32 nu = path(cuckoo, u0, us), nv = path(cuckoo, v0, vs);\n+        if (us[nu] == vs[nv]) {\n+          u32 min = nu < nv ? nu : nv;\n+          for (nu -= min, nv -= min; us[nu] != vs[nv]; nu++, nv++) ;\n+          u32 len = nu + nv + 1;\n+          // printf(\"%4d-cycle found at %d:%d%%\\n\", len, tp->id, (u32)(nonce*100LL/HALFSIZE));\n+          if (len == PROOFSIZE && ctx->nsols < ctx->maxsols)\n+            ctx->solution(us, nu, vs, nv);\n+        } else if (nu < nv) {\n+          while (nu--)\n+            cuckoo.set(us[nu+1], us[nu]);\n+          cuckoo.set(u0, v0);\n+        } else {\n+          while (nv--)\n+            cuckoo.set(vs[nv+1], vs[nv]);\n+          cuckoo.set(v0, u0);\n+        }\n+      }\n+      if (ffs & 64) break; // can't shift by 64\n+    }\n+  }\n+  pthread_exit(NULL);\n+  return 0;\n+}\n+\n+}  // namespace cuckoo_cycle\n+\n+}  // namespace powa\n+\n+#endif  // BITCOIN_POW_CUCKOO_CYCLE_CUCKOO_MINER_H"
      },
      {
        "sha": "698cf25d79e98507eec61929ed2f9b8625c7f08d",
        "filename": "src/pow/cuckoo_cycle/osx_barrier.h",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/osx_barrier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/osx_barrier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/osx_barrier.h?ref=260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "patch": "@@ -0,0 +1,83 @@\n+#ifndef BITCOIN_POW_CUCKOO_CYCLE_OSX_BARRIER_H\n+#define BITCOIN_POW_CUCKOO_CYCLE_OSX_BARRIER_H\n+\n+#ifdef __APPLE__\n+\n+#ifndef PTHREAD_BARRIER_H_\n+#define PTHREAD_BARRIER_H_\n+\n+#include <pthread.h>\n+#include <errno.h>\n+\n+namespace powa {\n+\n+namespace cuckoo_cycle {\n+\n+typedef int pthread_barrierattr_t;\n+#define PTHREAD_BARRIER_SERIAL_THREAD 1\n+\n+typedef struct\n+{\n+    pthread_mutex_t mutex;\n+    pthread_cond_t cond;\n+    int count;\n+    int tripCount;\n+} pthread_barrier_t;\n+\n+\n+int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)\n+{\n+    if(count == 0)\n+    {\n+        errno = EINVAL;\n+        return -1;\n+    }\n+    if(pthread_mutex_init(&barrier->mutex, 0) < 0)\n+    {\n+        return -1;\n+    }\n+    if(pthread_cond_init(&barrier->cond, 0) < 0)\n+    {\n+        pthread_mutex_destroy(&barrier->mutex);\n+        return -1;\n+    }\n+    barrier->tripCount = count;\n+    barrier->count = 0;\n+\n+    return 0;\n+}\n+\n+int pthread_barrier_destroy(pthread_barrier_t *barrier)\n+{\n+    pthread_cond_destroy(&barrier->cond);\n+    pthread_mutex_destroy(&barrier->mutex);\n+    return 0;\n+}\n+\n+int pthread_barrier_wait(pthread_barrier_t *barrier)\n+{\n+    pthread_mutex_lock(&barrier->mutex);\n+    ++(barrier->count);\n+    if(barrier->count >= barrier->tripCount)\n+    {\n+        barrier->count = 0;\n+        pthread_cond_broadcast(&barrier->cond);\n+        pthread_mutex_unlock(&barrier->mutex);\n+        return PTHREAD_BARRIER_SERIAL_THREAD;\n+    }\n+    else\n+    {\n+        pthread_cond_wait(&barrier->cond, &(barrier->mutex));\n+        pthread_mutex_unlock(&barrier->mutex);\n+        return 0;\n+    }\n+}\n+\n+}  // namespace cuckoo_cycle\n+\n+}  // namespace powa\n+\n+#endif  // PTHREAD_BARRIER_H_\n+#endif  // __APPLE__\n+\n+#endif  // BITCOIN_POW_CUCKOO_CYCLE_OSX_BARRIER_H"
      },
      {
        "sha": "3bd97f3d8d8b1f860ed2226e7c40ccd97973d0b8",
        "filename": "src/pow/cuckoo_cycle/siphash.h",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/siphash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/260857464182f9a9f8fa10dd5f68eab21a8bba23/src/pow/cuckoo_cycle/siphash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/siphash.h?ref=260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "patch": "@@ -0,0 +1,80 @@\n+#ifndef INCLUDE_SIPHASH_H\n+#define INCLUDE_SIPHASH_H\n+#include <stdint.h> // for types uint32_t,uint64_t\n+#include <openssl/sha.h> // if openssl absent, use #include \"sha256.c\"\n+#include <immintrin.h>\n+\n+namespace powa {\n+\n+namespace cuckoo_cycle {\n+\n+// length of header hashed into siphash key\n+#ifndef HEADERLEN\n+#define HEADERLEN 80\n+#endif\n+\n+// save some keystrokes since i'm a lazy typer\n+typedef uint32_t u32;\n+typedef uint64_t u64;\n+\n+// siphash uses a pair of 64-bit keys,\n+typedef struct {\n+  u64 k0;\n+  u64 k1;\n+} siphash_keys;\n+\n+#define U8TO64_LE(p) \\\n+  (((u64)((p)[0])      ) | ((u64)((p)[1]) <<  8) | \\\n+   ((u64)((p)[2]) << 16) | ((u64)((p)[3]) << 24) | \\\n+   ((u64)((p)[4]) << 32) | ((u64)((p)[5]) << 40) | \\\n+   ((u64)((p)[6]) << 48) | ((u64)((p)[7]) << 56))\n+\n+#ifndef SHA256\n+#define SHA256(d, n, md) do { \\\n+    SHA256_CTX c; \\\n+    SHA256_Init(&c); \\\n+    SHA256_Update(&c, d, n); \\\n+    SHA256_Final(md, &c); \\\n+  } while (0)\n+#endif\n+\n+// derive siphash key from fixed length header\n+void setheader(siphash_keys *keys, const char *header) {\n+  unsigned char hdrkey[32];\n+  SHA256((unsigned char *)header, HEADERLEN, hdrkey);\n+  keys->k0 = U8TO64_LE(hdrkey);\n+  keys->k1 = U8TO64_LE(hdrkey+8);\n+}\n+\n+#define ROTL(x,b) (u64)( ((x) << (b)) | ( (x) >> (64 - (b))) )\n+#define SIPROUND \\\n+  do { \\\n+    v0 += v1; v2 += v3; v1 = ROTL(v1,13); \\\n+    v3 = ROTL(v3,16); v1 ^= v0; v3 ^= v2; \\\n+    v0 = ROTL(v0,32); v2 += v1; v0 += v3; \\\n+    v1 = ROTL(v1,17);   v3 = ROTL(v3,21); \\\n+    v1 ^= v2; v3 ^= v0; v2 = ROTL(v2,32); \\\n+  } while(0)\n+\n+// SipHash-2-4 specialized to precomputed key and 8 byte nonces\n+u64 siphash24(const siphash_keys *keys, const u64 nonce) {\n+  u64 v0 = keys->k0 ^ 0x736f6d6570736575ULL, v1 = keys->k1 ^ 0x646f72616e646f6dULL,\n+      v2 = keys->k0 ^ 0x6c7967656e657261ULL, v3 = keys->k1 ^ 0x7465646279746573ULL ^ nonce;\n+  SIPROUND; SIPROUND;\n+  v0 ^= nonce;\n+  v2 ^= 0xff;\n+  SIPROUND; SIPROUND; SIPROUND; SIPROUND;\n+  return (v0 ^ v1) ^ (v2  ^ v3);\n+}\n+\n+#define NSIPHASH 1\n+\n+inline void siphash24xN(const siphash_keys *keys, const u64 *indices, u64 * hashes) {\n+  *hashes = siphash24(keys, *indices);\n+}\n+\n+}  // namespace cuckoo_cycle\n+\n+}  // namespace powa\n+\n+#endif // ifdef INCLUDE_SIPHASH_H"
      }
    ]
  },
  {
    "sha": "9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Y2I0MDc0OWIxNTQ1YjA0YWQ3YzMyYzhhNTVkOTNlNTBjMWIyYzAz",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:22:21Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:16:00Z"
      },
      "message": "[pow] Added wrapper around cuckoo cycle code.",
      "tree": {
        "sha": "d081728842dcddbc5fe5f1a760240392cace3409",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d081728842dcddbc5fe5f1a760240392cace3409"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk4+eUACgkQV692LbM1\nMyIMsQ//axQ3fP/KzwYSc7VJU36sVx3hytS7Z8eF1iNSQCOx+YpnLJEYm9mQSI84\nHeL2q+yvm705F8Gj4WG8jfJ4oZLORDpGa68KvaFdMjOhOElkRLLTD8nh063cE8bk\nDZbxbPtqGpn4yvqey1TAdwaMRXu3ZuY9wM84rHwohJcOZ8+wCObpIOuYB1bjW9CF\ns4CdqputjEN1JI9ZbW7GJxh2i0G7bo/gSpi0wV8CcKy+LGGDL1xNwb6HHY1jizo4\n9ye71gjHPcNIFteXjuBWZ3tn9/6+S991bdmXvh+fcbnxa0MwO5OhVIUi2uWLJWQa\nZt7zse+lYHHUYLNCSDPo6CsIbW5ewiCk0+nYIbtViMmx3LfuTLkb+LPGK4HaDVv0\nqQDTLSyBKmPRS0CZiMnXF+RfORXtPUkXcMDzh5unoQv1tT0cN5q3YeurZhOFFrma\ng+RsfD7gk4QFPD+nCkiccXcGwMk+cNaqr/F88oOJ9wooDcvz5rlu8eBVIjLLwhs/\nopCeuo0yM1QMEUqAZZFOFiDcV8j+QWQmJpjcjCbEk8IcmgOtpnRt15oRknhxl3Al\n3NRk6Oa+rhhKTFp+E9Lqrl8fQmNTPzTSl282GhX4tqVzPOrIaqF2g7Xhmtw703A9\np4rDmsV+8NSzTmAYUqrnjWjRSTJLvUWSWeeorb/lTUWeo+CaKIY=\n=JKCf\n-----END PGP SIGNATURE-----",
        "payload": "tree d081728842dcddbc5fe5f1a760240392cace3409\nparent 260857464182f9a9f8fa10dd5f68eab21a8bba23\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491902541 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496906160 +0900\n\n[pow] Added wrapper around cuckoo cycle code.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/260857464182f9a9f8fa10dd5f68eab21a8bba23",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/260857464182f9a9f8fa10dd5f68eab21a8bba23"
      }
    ],
    "stats": {
      "total": 237,
      "additions": 237,
      "deletions": 0
    },
    "files": [
      {
        "sha": "47928df8dca203a35e63ea41e347110e916f0137",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
        "patch": "@@ -121,6 +121,7 @@ BITCOIN_CORE_H = \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n+  pow/cuckoo_cycle/cuckoo_cycle.h \\\n   pow/cuckoo_cycle/cuckoo_miner.h \\\n   pow/cuckoo_cycle/cuckoo.h \\\n   pow/cuckoo_cycle/siphash.h \\\n@@ -320,6 +321,7 @@ libbitcoin_common_a_SOURCES = \\\n   netaddress.cpp \\\n   netbase.cpp \\\n   policy/feerate.cpp \\\n+  pow/cuckoo_cycle/cuckoo_cycle.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\\n   script/sign.cpp \\"
      },
      {
        "sha": "cf3b8aa0982ebc6ef099d7b9497df49511de1238",
        "filename": "src/pow/cuckoo_cycle/cuckoo_cycle.cpp",
        "status": "added",
        "additions": 101,
        "deletions": 0,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/src/pow/cuckoo_cycle/cuckoo_cycle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/src/pow/cuckoo_cycle/cuckoo_cycle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/cuckoo_cycle.cpp?ref=9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
        "patch": "@@ -0,0 +1,101 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"cuckoo_cycle.h\"\n+\n+#include <algorithm>\n+\n+#include \"../random.h\"\n+\n+namespace powa {\n+\n+namespace cuckoo_cycle {\n+\n+int cuckoo_cycle::last_err = POW_OK;\n+\n+cuckoo_cycle::~cuckoo_cycle() {\n+    if (thread) {\n+        if (state == state_running) {\n+            state = state_term;\n+            thread->join();\n+        }\n+        delete thread;\n+        thread = nullptr;\n+    }\n+}\n+\n+void cuckoo_cycle::solve(uint32_t threads, bool background, int32_t ticks) {\n+    assert(state == state_ready || state == state_paused);\n+    if (state == state_ready && !fZeroStartingNonce) {\n+        // randomize nonce\n+        GetRandBytes((unsigned char*)&next_nonce, sizeof(next_nonce));\n+    }\n+    state = state_running;\n+    ticks_left = ticks;\n+    if (c->params.size() != HEADERLEN - 4) {\n+        c->params.resize(HEADERLEN - 4);\n+    }\n+    if (background) {\n+        thread = new std::thread(&cuckoo_cycle::solve_async, this, threads ?: 1);\n+    } else {\n+        solve_async(threads ?: 1);\n+    }\n+}\n+\n+void cuckoo_cycle::abort() {\n+    if (state != state_running) return;\n+    state = state_term;\n+    thread->join();\n+}\n+\n+void cuckoo_cycle::solve_async(uint32_t thread_count) { // asynchronous\n+    int ntrims = 1 + (PART_BITS+3)*(PART_BITS+4)/2;\n+    int nonce  = next_nonce;\n+    thread_ctx* threads = new thread_ctx[thread_count];\n+    assert(threads);\n+    size_t wx = std::min((size_t)80, c->params.size() + 4);\n+    char* ws = new char[wx];\n+    memcpy(ws, &c->params[0], c->params.size());\n+    ctx = new cuckoo_ctx(thread_count, ntrims, 8, c->proofsize_min, c->proofsize_max);\n+    while (state == state_running) {\n+        ctx->setheadernonce(ws, wx, nonce);\n+        for (uint32_t t = 0; t < thread_count; t++) {\n+            threads[t].id = t;\n+            threads[t].ctx = ctx;\n+            int err = pthread_create(&threads[t].thread, nullptr, worker, (void*)&threads[t]);\n+            assert(err == 0);\n+        }\n+        for (uint32_t t = 0; t < thread_count; t++) {\n+            int err = pthread_join(threads[t].thread, nullptr);\n+            assert(err == 0);\n+        }\n+        // if we are aborted due to deallocation we don't want to talk to callback\n+        // even if we have solutions, so we break on term\n+        if (state != state_running) break;\n+        for (unsigned s = 0; s < ctx->nsols; s++) {\n+            nonce_t proofsize = ctx->sols[s][ctx->proofsize_max];\n+            printf(\"- solution with proofsize = %u found for nonce = %d\\n\", proofsize, nonce);\n+            solution_ref sol(new solution());\n+            sol->params.resize(4 * (1 + proofsize));\n+            SetNonce(sol, nonce);\n+            SetKeys(sol, ctx->sols[s], proofsize);\n+            if (cb->found_solution(*this, c, sol)) {\n+                state = state_stopped;\n+                break;\n+            }\n+        }\n+        nonce++;\n+        ticks_left -= ticks_left > -1;\n+        if (ticks_left == 0) state = state_paused;\n+    }\n+    if (state == state_term) state = state_aborted;\n+    delete ctx;\n+    delete [] ws;\n+    delete [] threads;\n+    next_nonce = nonce;\n+}\n+\n+}  // namespace cuckoo_cycle\n+\n+}  // namespace powa"
      },
      {
        "sha": "e1ab830476a249c39629b5fc72fce1b7a8e8110e",
        "filename": "src/pow/cuckoo_cycle/cuckoo_cycle.h",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/src/pow/cuckoo_cycle/cuckoo_cycle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03/src/pow/cuckoo_cycle/cuckoo_cycle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/cuckoo_cycle.h?ref=9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
        "patch": "@@ -0,0 +1,134 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POW_CUCKOO_CYCLE_H\n+#define BITCOIN_POW_CUCKOO_CYCLE_H\n+\n+#include <thread>\n+\n+#include \"pow/pow.h\"\n+#include \"cuckoo_miner.h\"\n+\n+namespace powa {\n+\n+namespace cuckoo_cycle {\n+\n+class cc_challenge;\n+\n+typedef std::shared_ptr<cc_challenge> cc_challenge_ref;\n+\n+class cc_challenge : public challenge {\n+public:\n+    using challenge::challenge;\n+    uint8_t sizeshift;\n+    uint16_t proofsize_min;\n+    uint16_t proofsize_max;\n+\n+    cc_challenge() : challenge() {\n+        config.params.resize(5);\n+        uint8_t* configb = &config.params[0];\n+        *configb = sizeshift = SIZESHIFT;\n+        configb += 1;\n+        *(uint16_t*)configb = proofsize_min = 12;\n+        configb += 2;\n+        *(uint16_t*)configb = proofsize_max = 228;\n+    }\n+\n+    cc_challenge(const challenge& other) : challenge(other) {\n+        assert(config.params.size() == 5);\n+        uint8_t* configb = &config.params[0];\n+        sizeshift = *configb;\n+        // TODO: deal with the fact we don't support certain size shifts; currently this is ignored\n+        configb += 1;\n+        proofsize_min = *(uint16_t*)configb;\n+        configb += 2;\n+        proofsize_max = *(uint16_t*)configb;\n+        // TODO: validate proofsizes; must be even, max must >= min, ...\n+    }\n+\n+    static cc_challenge_ref random_challenge(const uint8_t len = HEADERLEN - 4) {\n+        cc_challenge* c = new cc_challenge();\n+        c->params.resize(len);\n+        c->randomize(c->params.size());\n+        return cc_challenge_ref(c);\n+    }\n+\n+    cc_challenge& operator=(const cc_challenge& other) {\n+        params = other.params;\n+        return *this;\n+    }\n+\n+    bool operator==(const cc_challenge& other) const {\n+        return !memcmp(&params[0], &other.params[0], params.size());\n+    }\n+};\n+\n+inline uint32_t GetNonce(solution_ref& s) { return *(uint32_t*)&s->params[0]; }\n+inline uint32_t* GetKeys(solution_ref& s) { return &((uint32_t*)&s->params[0])[1]; }\n+inline void SetNonce(solution_ref& s, uint32_t nonce) { memcpy(&s->params[0], &nonce, 4); }\n+inline void SetKeys(solution_ref& s, uint32_t* keys, uint16_t count) { memcpy(&s->params[4], keys, count * 4); }\n+\n+class cuckoo_cycle : public pow {\n+public:\n+    std::thread* thread;\n+    cc_challenge_ref c;\n+    cuckoo_ctx* ctx;\n+    int next_nonce;\n+    static int last_err;               ///< last error after call to is_valid()\n+    cuckoo_cycle(cc_challenge_ref c_in, callback_ref cb_in = nullptr) : pow(POWID_CUCKOO_CYCLE, c_in, cb_in), thread(nullptr), c(c_in), next_nonce(0) {}\n+    ~cuckoo_cycle();\n+\n+    std::string last_error_string() {\n+        return errstr[last_err];\n+    }\n+\n+    bool is_valid(solution& s) const override {\n+        if (s.params.size() < size_t(1 + c->proofsize_min) * 4 ||\n+            s.params.size() > size_t(1 + c->proofsize_max) * 4) {\n+            return false; // 1 nonce + edges, all 32 bit\n+        }\n+        u32* values = (u32*)&s.params[0];\n+        u32 nonce = values[0];\n+        u32* keys = &values[1];\n+        uint16_t proofsize = (s.params.size() >> 2) - 1;\n+        printf(\"CC is_valid(): nonce=%u, proofsize=%u\\n\", nonce, proofsize);\n+\n+        char headernonce[HEADERLEN];\n+        u32 hdrlen = c.get()->params.size();\n+        memcpy(headernonce, &c.get()->params[0], hdrlen);\n+        if (hdrlen < sizeof(headernonce)) memset(headernonce + hdrlen, 0, sizeof(headernonce) - hdrlen);\n+        ((u32 *)headernonce)[HEADERLEN/sizeof(u32)-1] = htole32(nonce);\n+\n+        last_err = verify(keys, headernonce, HEADERLEN, proofsize);\n+        return (last_err == POW_OK);\n+    }\n+\n+    void set_output(solution& s, std::vector<uint8_t>& output) override {\n+        // the output for a CC POW is the solution in full\n+        output.resize(s.params.size());\n+        memcpy(&output[0], &s.params[0], s.params.size());\n+    }\n+\n+    void solve(uint32_t threads = 0, bool background = false, int32_t ticks = -1) override;\n+\n+    int64_t expected_iteration_cycles() const override { return 150000000000; }\n+    int64_t expected_invprob()          const override {\n+        // we require 12/228 at this point, or we expect a 1/999 probability of solving\n+        return c->proofsize_min == 12 && c->proofsize_max == 228 ? 1 : 999;\n+    }\n+\n+    void abort() override;\n+\n+    virtual std::string to_string() const override {\n+        return strprintf(\"Cuckoo-Cycle<%p; ps=[%u, %u]>\", this, c->proofsize_min, c->proofsize_max);\n+    }\n+private:\n+    void solve_async(uint32_t thread_count);\n+};\n+\n+}  // namespace cuckoo_cycle\n+\n+}  // namespace powa\n+\n+#endif  // BITCOIN_POW_CUCKOO_CYCLE_H"
      }
    ]
  },
  {
    "sha": "ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYTliZDY3ZTQzYmI1MWQ4MDc0MzEyOGM1YWE2YjdmOTBhMWEzYTMz",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:23:24Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:16:54Z"
      },
      "message": "[pow] Added simple SHA256 POW algorithm.",
      "tree": {
        "sha": "e12852b911c21b6bb1e79927294490f1df751120",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e12852b911c21b6bb1e79927294490f1df751120"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk4+fsACgkQV692LbM1\nMyIu8Q/9EokymLRvkNmUTqV2RHfPySyHFUKwZPQpKJlzRnMJD96PA4BJXbBHLzWU\nFGAlvalJD7+DV9lfZg3K5HkgpoyGM2Gqm+kCVO2iNzXMlOZu95NzFdkGTr5tJ1Vs\nHFkz4ATCu5CNazmUa1jfeNZjHG40r1md+q3o/9gqdMMpWtmpHcXb1A/tHGmRrK8r\noeNm3QvEmAw4Pn0RSaH3/ySfwP95ogG3hAshsoGplNq7Pxc9SPsR8oa5lmUrqF0v\nG+4v/xZgN2zIgaQBEY4Xh//0g5CVw1UE3bktuWqOxNNFH6jp/c1UGNVVigB7hmSK\nWf2eUPFIUPJ5kGlPraWjt2qhBF/0uPrXiAk49rd83BZNescWVAA/DY7+cySAnsvH\nruPI8koi7xMSSV569Gkj/AG8n7lGSYqmDBfSuG/cjpgJ33TE+d3MDRtB85S84VH3\n3DKTa2ADZ3W0izkFVLmS3GprAg18qsw/EmgFjYCG6fI44sKs4TDFG3DlhIiSbT9N\nt/f3oMsG/9Lb7jnf+DnXBSQeiSlnNZrJzmVU6VIZT79CyRPyWEK9koJCBxUJcIcB\nkmdFYUQFS1eBXyI+qRckKSU7nhkALfV7UvmMfqhN+t1Cgs6UdfRlgEnxnbJxF0kJ\n3PlbcuKskifaVvgmrlmSfHFnjOyyLCi1YxQd6lCSbwqlkhZW4DU=\n=O+gJ\n-----END PGP SIGNATURE-----",
        "payload": "tree e12852b911c21b6bb1e79927294490f1df751120\nparent 9cb40749b1545b04ad7c32c8a55d93e50c1b2c03\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491902604 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496906214 +0900\n\n[pow] Added simple SHA256 POW algorithm.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9cb40749b1545b04ad7c32c8a55d93e50c1b2c03"
      }
    ],
    "stats": {
      "total": 164,
      "additions": 164,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f52fd89910309ef593c102166ea5f8959e3d9311",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
        "patch": "@@ -126,6 +126,7 @@ BITCOIN_CORE_H = \\\n   pow/cuckoo_cycle/cuckoo.h \\\n   pow/cuckoo_cycle/siphash.h \\\n   pow/pow.h \\\n+  pow/sha256/sha256.h \\\n   pow.h \\\n   protocol.h \\\n   random.h \\"
      },
      {
        "sha": "68f17fe87c1b5b802566de16e017c4528e77a0f3",
        "filename": "src/pow/sha256/sha256.h",
        "status": "added",
        "additions": 163,
        "deletions": 0,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33/src/pow/sha256/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33/src/pow/sha256/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/sha256/sha256.h?ref=ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
        "patch": "@@ -0,0 +1,163 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POW_SHA256_H\n+#define BITCOIN_POW_SHA256_H\n+\n+#include <algorithm>\n+\n+#include \"crypto/sha256.h\"\n+#include \"arith_uint256.h\"\n+#include \"uint256.h\"\n+#include \"pow/pow.h\"\n+\n+namespace powa {\n+\n+class sha256;\n+typedef std::shared_ptr<sha256> sha256_ref;\n+\n+class sha256challenge : public challenge {\n+public:\n+    using challenge::challenge;\n+    uint32_t compact_target;\n+    uint8_t nonce_size;\n+    uint32_t nonce_offset;\n+    sha256challenge(const challenge& other) : challenge(other) {\n+        assert(config.params.size() == 9);\n+        uint8_t* configb = &config.params[0];\n+        compact_target = *(uint32_t*)configb;\n+        configb += 4;\n+        nonce_size = configb[0];\n+        configb++;\n+        nonce_offset = *(uint32_t*)configb;\n+    }\n+    sha256challenge(const uint32_t compact_target_in, const uint8_t nonce_size_in, const uint32_t nonce_offset_in, const uint32_t size) {\n+        compact_target = compact_target_in;\n+        nonce_size = nonce_size_in;\n+        nonce_offset = nonce_offset_in;\n+        uint32_t realsize = std::max(nonce_size_in + nonce_offset_in, size);\n+        params.resize(realsize);\n+        config.params.resize(9);\n+        uint8_t* configb = &config.params[0];\n+        *(uint32_t*)configb = compact_target;\n+        configb += 4;\n+        configb[0] = nonce_size;\n+        configb++;\n+        *(uint32_t*)configb = nonce_offset;\n+    }\n+    static challenge_ref random_challenge(const uint32_t compact_target_in, const uint8_t nonce_size_in, const uint32_t nonce_offset_in, const uint32_t size) {\n+        sha256challenge* c = new sha256challenge(compact_target_in, nonce_size_in, nonce_offset_in, size);\n+        c->randomize(c->params.size());\n+        return challenge_ref(c);\n+    }\n+};\n+\n+class sha256 : public pow {\n+public:\n+    uint64_t next_nonce;\n+    sha256challenge* sc;\n+    sha256(challenge_ref c_in, callback_ref cb_in = nullptr) : pow(POWID_SHA256, c_in, cb_in), next_nonce(0), sc((sha256challenge*)c_in.get()) {}\n+\n+    uint256 get_hash(solution& s) const {\n+        // two modes: if nonce_size is 0 we simply append, otherwise we expect\n+        // the solution to be the size of the nonce only\n+        uint32_t size;\n+        uint8_t* data;\n+        if (sc->nonce_size == 0) {\n+            // append\n+            size = sc->params.size() + s.params.size();\n+            data = new uint8_t[size];\n+            memcpy(data, &sc->params[0], sc->params.size());\n+            memcpy(&data[sc->params.size()], &s.params[0], s.params.size());\n+        } else {\n+            // insert nonce only, retaining remaining challenge params\n+            if (s.params.size() != sc->nonce_size) return uint256();\n+            size = std::max(uint32_t(sc->nonce_offset + sc->nonce_size), uint32_t(sc->params.size()));\n+            data = new uint8_t[size];\n+            memcpy(data, &sc->params[0], sc->params.size());\n+            memcpy(&data[sc->nonce_offset], &s.params[0], s.params.size());\n+        }\n+        uint256 hash;\n+        CSHA256().Write(data, size).Finalize(hash.begin());\n+        delete [] data;\n+        return hash;\n+    }\n+\n+    bool is_valid(solution& s) const override {\n+        uint256 hash = get_hash(s);\n+        arith_uint256 target;\n+        target.SetCompact(sc->compact_target);\n+        printf(\"sha256: is_valid():\\n\\t%s\\n>\\t%s\\n\", target.ToString().c_str(), hash.ToString().c_str());\n+        return target > UintToArith256(hash);\n+    }\n+\n+    void set_output(solution& s, std::vector<uint8_t>& output) override {\n+        // the output for a sha256 POW is the full hash\n+        output.resize(32);\n+        memcpy(&output[0], get_hash(s).begin(), 32);\n+    }\n+\n+    template<typename T>\n+    void solve_t(T startnonce) {\n+        CSHA256 sha;\n+        uint256 hash;\n+        arith_uint256 target;\n+\n+        uint32_t size = std::max(uint32_t(sc->nonce_offset + sc->nonce_size), uint32_t(sc->params.size()));\n+        uint8_t* data = new uint8_t[size];\n+        memcpy(data, &sc->params[0], sc->params.size());\n+        T& refnonce = *(T*)&data[sc->nonce_offset];\n+        target.SetCompact(sc->compact_target);\n+        bool satisfied = false;\n+        for (refnonce = startnonce; state == state_running && !satisfied && refnonce + 1 != startnonce; refnonce++) {\n+            sha.Write(data, size);\n+            sha.Finalize(hash.begin());\n+            sha.Reset();\n+            if (UintToArith256(hash) < target) {\n+                solution_ref s(new solution(refnonce));\n+                satisfied = cb->found_solution(*this, c, s);\n+            }\n+            ticks_left -= ticks_left > -1;\n+            if (ticks_left == 0) break; // ran out of ticks\n+        }\n+        next_nonce = refnonce;\n+        delete [] data;\n+        state = state == state_term ? state_aborted : state_stopped;\n+    }\n+\n+    void solve(uint32_t threads = 0, bool background = false, int32_t ticks = -1) override {\n+        assert(state == state_ready || state == state_paused);\n+        if (background || threads > 1) printf(\"warning: sha256 solver does not spawn threads\\n\");\n+        if (state == state_ready && sc->nonce_size > 0 && !fZeroStartingNonce) {\n+            // randomize nonce\n+            GetRandBytes((unsigned char*)&next_nonce, sizeof(next_nonce));\n+        }\n+        state = state_running;\n+        ticks_left = ticks;\n+        solution_ref s(new solution());\n+        switch (sc->nonce_size) {\n+        case 0: if (is_valid(*s)) { cb->found_solution(*this, c, s); } return;\n+        case 4: solve_t((uint32_t)next_nonce); return;\n+        case 8: solve_t(next_nonce); return;\n+        default: return; // we don't support this nonce size\n+        }\n+    }\n+\n+    int64_t expected_iteration_cycles() const override { return 11000; }\n+\n+    int64_t expected_invprob() const override {\n+        arith_uint256 u;\n+        u.SetCompact(sc->compact_target);\n+        return 1.0 / u.GetProbabilityEstimate();\n+    }\n+\n+    virtual std::string to_string() const override {\n+        assert(sc == c.get());\n+        return strprintf(\"SHA256<%p; target = %x; params# = %lu>\", this, sc->compact_target, sc->params.size());\n+    }\n+};\n+\n+}  // namespace powa\n+\n+#endif  // BITCOIN_POW_SHA256_H"
      }
    ]
  },
  {
    "sha": "fcbf410337e476158752c35f0d3590deb675d9f5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmY2JmNDEwMzM3ZTQ3NjE1ODc1MmMzNWYwZDM1OTBkZWI2NzVkOWY1",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-03-25T18:51:47Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:17:16Z"
      },
      "message": "Added anti-DoS via POW class.\n\nA new set of classes specifically targeting anti-DoS via POW in src/ados.h/cpp in the ados:: namespace.\n\nados::offer is an offered service provided for solving a POW challenge, including expiration and purpose according to BIP-154.\n\nados::callback extends powa::callback as a general-purpose anti-DoS callback.\n\nados::connection_challenge is an ados::callback specialization which retains a CAddress taken from a CNode which is connected to with the given challenge/solution when/if solved.\n\nThere are also a number of helper functions:\n- ados::begin_solving() takes an offer and an investment (number of ticks) and will attempt to solve the offer in the background\n- ados::expected_solution_time(o) gives an estimate in seconds on how long it would take on average to solve the challenge in the offer\n- ados::solvable(o) returns a bool on whether the given offer's challenge is considered solvable within the time constraints\n- ados::challenge_peer(peer, purpose, pressure) constructs and sends a challenge to peer for the given purpose; pressure determines the difficulty of the challenge, and is in the range [0..1]\n- ados::check_solution(o) takes an offer and checks if its given solution is a valid solution to the contained challenge",
      "tree": {
        "sha": "076ab8215fb42e966218c1ce2dfbe4b3882b243a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/076ab8215fb42e966218c1ce2dfbe4b3882b243a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fcbf410337e476158752c35f0d3590deb675d9f5",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk4+7oACgkQV692LbM1\nMyLNSQ/+Mh6PttMcbKak5LDnEQ+9kM61T94bTmLDLmR2NnvTGejPgpAK3bvEz8qs\n4cXRtPu23Omjr6bA38ApTyruJjU+dSrSiz/viAHlcJUQMCQw/kiEvq+kUSW2SuEG\n9O44s4XIS5tz5naO58/vMwPPnVMwdrDmV+e7IgK3nuK6J7xYX+IjjI3nbbL+sgo6\nvAdMKIyA86Qeo5BVL+vWTD6xGwA1jmRR68ybjEhUK2TUfioJK8oXrwYmC9ss+hqH\nRz/cVsqxC/I1Jw5sRy6PpkYdvEnqgL9HGS/857EsgZmIFoNhgWgfDqwGcSGh2xaY\n7YNbTZRArFpLia+6pGBY2dr5F9AFQMWVV9ETUxGybDkMqqZsq5QZuPspkqLs8uWK\nCfQAQ2pt5lv9P2YLXSkhklbU62Ob5qmDOAW6zQemNl7KjjTUaGTD00z4wgjORWE/\nhQUw/dHSit3aVZQCf00opCN5jX5XMfiDG9ErmiF/lk6YnUXqfOnHUyGkZuGp/+/x\nPmEj78P4Ck9Ly20eIgulXP2gDj3HP10ed0BPv7UBrzx0J/m9QZf7FEjSYg4MD4/P\npuZPNsXGESZU+FDsFLp+skK78/Xz/Rluir7wlSp6hE388LA0eddIS8cnoMs7wHe9\nhGkb9eICbKtLB7Lw3yfQJJyhDse5bzxx4e7eQNr+NfexzdelWK4=\n=z3Vr\n-----END PGP SIGNATURE-----",
        "payload": "tree 076ab8215fb42e966218c1ce2dfbe4b3882b243a\nparent ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1490467907 -0700\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496906236 +0900\n\nAdded anti-DoS via POW class.\n\nA new set of classes specifically targeting anti-DoS via POW in src/ados.h/cpp in the ados:: namespace.\n\nados::offer is an offered service provided for solving a POW challenge, including expiration and purpose according to BIP-154.\n\nados::callback extends powa::callback as a general-purpose anti-DoS callback.\n\nados::connection_challenge is an ados::callback specialization which retains a CAddress taken from a CNode which is connected to with the given challenge/solution when/if solved.\n\nThere are also a number of helper functions:\n- ados::begin_solving() takes an offer and an investment (number of ticks) and will attempt to solve the offer in the background\n- ados::expected_solution_time(o) gives an estimate in seconds on how long it would take on average to solve the challenge in the offer\n- ados::solvable(o) returns a bool on whether the given offer's challenge is considered solvable within the time constraints\n- ados::challenge_peer(peer, purpose, pressure) constructs and sends a challenge to peer for the given purpose; pressure determines the difficulty of the challenge, and is in the range [0..1]\n- ados::check_solution(o) takes an offer and checks if its given solution is a valid solution to the contained challenge\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcbf410337e476158752c35f0d3590deb675d9f5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fcbf410337e476158752c35f0d3590deb675d9f5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcbf410337e476158752c35f0d3590deb675d9f5/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ea9bd67e43bb51d80743128c5aa6b7f90a1a3a33"
      }
    ],
    "stats": {
      "total": 331,
      "additions": 331,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7887a7b98f251ec3b10ca5c6bffd497869e2ad8b",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fcbf410337e476158752c35f0d3590deb675d9f5/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fcbf410337e476158752c35f0d3590deb675d9f5/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fcbf410337e476158752c35f0d3590deb675d9f5",
        "patch": "@@ -78,6 +78,7 @@ endif\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addrman.h \\\n+  ados.h \\\n   base58.h \\\n   bloom.h \\\n   blockencodings.h \\\n@@ -188,6 +189,7 @@ libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n   addrdb.cpp \\\n   addrman.cpp \\\n+  ados.cpp \\\n   bloom.cpp \\\n   blockencodings.cpp \\\n   chain.cpp \\"
      },
      {
        "sha": "f6ecbc932260d4938e606f6c6ce7a9ffaeaacda7",
        "filename": "src/ados.cpp",
        "status": "added",
        "additions": 189,
        "deletions": 0,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fcbf410337e476158752c35f0d3590deb675d9f5/src/ados.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fcbf410337e476158752c35f0d3590deb675d9f5/src/ados.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ados.cpp?ref=fcbf410337e476158752c35f0d3590deb675d9f5",
        "patch": "@@ -0,0 +1,189 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"ados.h\"\n+#include \"net.h\"\n+#include \"netmessagemaker.h\"\n+#include \"hash.h\"\n+#include \"arith_uint256.h\"\n+#include \"key.h\"\n+#include \"pow/sha256/sha256.h\"\n+#include \"pow/cuckoo_cycle/cuckoo_cycle.h\"\n+\n+#include <vector>\n+#include <map>\n+\n+namespace ados {\n+\n+connection_challenge::connection_challenge(CNode& peer, offer_ref o_in) : callback(o_in), addr(peer.addr) {}\n+\n+bool connection_challenge::solved_challenge(powa::solution_ref sol) {\n+    o->sol = sol;\n+    printf(\"reconnecting to peer %s\\n\", addr.ToString().c_str());\n+    g_connman.get()->OpenNetworkConnection(addr, false, NULL, NULL, false, false, true, o);\n+    return true;\n+}\n+\n+struct task {\n+    uint32_t investment; ///< ticks per attempt\n+    offer_ref o;         ///< offer associated with task\n+    task(uint32_t investment_in, offer_ref o_in) : investment(investment_in), o(o_in) {}\n+\n+    bool operator==(const task& other) const { return investment == other.investment && o.get() == other.o.get(); }\n+};\n+\n+struct expiring_hash {\n+    int64_t expiration;\n+    uint256 hash;\n+    bool operator<(const expiring_hash& other) const { return expiration < other.expiration || (expiration == other.expiration && hash < other.hash); }\n+};\n+\n+CKey* ados_key = NULL;\n+std::set<expiring_hash> known_challenges;\n+std::vector<task> tasks;\n+std::thread* thread;\n+std::atomic<bool> solving(false);\n+\n+void make_keypair() {\n+    ados_key = new CKey();\n+    ados_key->MakeNewKey(true);\n+}\n+\n+void solve_async() {\n+    while (tasks.size() > 0) {\n+        for (uint32_t i = 0; i < tasks.size(); ++i) {\n+            task t = tasks[i];\n+            t.o->pow->solve(0, t.investment);\n+            if (t.o->pow->state == powa::solver_state::state_stopped) {\n+                // solver finished\n+                assert(tasks[i] == t);\n+                tasks.erase(tasks.begin() + i);\n+                --i;\n+            }\n+        }\n+        solving = tasks.size() > 0;\n+    }\n+}\n+\n+void solve() {\n+    if (solving) return;\n+    solving = true;\n+    thread = new std::thread(solve_async);\n+}\n+\n+void begin_solving(offer_ref o, uint32_t investment) {\n+    printf(\"- begin solving with cb %p and solver %p\\n\", o->pow->cb.get(), o->pow.get());\n+    tasks.emplace_back(investment, o);\n+    solve();\n+}\n+\n+void challenge_peer(CNode& peer, uint32_t purpose, double pressure) {\n+    printf(\"- challenging peer: pressure = %.4lf\\n\", pressure);\n+    const CNetMsgMaker msgMaker(INIT_PROTO_VERSION);\n+    int64_t creation = GetTime();\n+    int64_t expiration = creation + 600 * (1.0 + pressure);\n+    double probtgt = 1.0 / (1.0 + pressure * pressure * 15.0); // 0, 0.26, 0.37, 0.45, ..., 0.89, 0.93, 0.97, 1.0 (p = sqrt((v-1)/15))\n+    uint32_t target_cmpct = arith_uint256().SetProbabilityTarget(probtgt).GetCompact(false);\n+\n+    powa::challenge_ref chlg(new powa::sha256challenge(target_cmpct, 0, 0, 0));\n+    powa::cuckoo_cycle::cc_challenge_ref chlg2 = powa::cuckoo_cycle::cc_challenge::random_challenge();\n+    powa::pow_ref alg(new powa::sha256(chlg));\n+    powa::pow_ref alg2(new powa::cuckoo_cycle::cuckoo_cycle(chlg2));\n+    powa::powchain chain;\n+    chain.add_pow(alg);\n+    chain.add_pow(alg2);\n+\n+    if (!ados_key) make_keypair();\n+    CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n+    ss << chain << purpose << expiration;\n+    uint256 sighash = ss.GetHash();\n+    printf(\"outgoing challenge hash = %s\\n\", sighash.ToString().c_str());\n+    std::vector<unsigned char> vchSig;\n+    ados_key->Sign(sighash, vchSig);\n+\n+    g_connman.get()->PushMessage(&peer, msgMaker.Make(\n+        NetMsgType::CHALLENGE,\n+        chain,\n+        purpose,\n+        expiration,\n+        vchSig\n+    ));\n+}\n+\n+bool check_challenge_hash(const int64_t expiration, uint256& sighash) {\n+    int64_t now = GetTime();\n+    bool result = true;\n+    auto it = known_challenges.begin();\n+    printf(\"check challenge hash for expiration %lld, hash %s\\n\", expiration, sighash.ToString().c_str());\n+    while (it != known_challenges.end()) {\n+        auto curr = it++;\n+        expiring_hash eh = *curr;\n+        printf(\"got %lld with %s\\n\", eh.expiration, eh.hash.ToString().c_str());\n+        result &= eh.hash != sighash;\n+        if (eh.expiration < now) {\n+            known_challenges.erase(curr);\n+        }\n+    }\n+    printf(\"challenge hash check result = %s\\n\", result ? \"true\" : \"false\");\n+    if (result) {\n+        known_challenges.insert({ expiration, sighash });\n+    }\n+    return result;\n+}\n+\n+bool check_solution(offer_ref o) {\n+    printf(\"checking solution\\n\");\n+\n+    int64_t now = GetTime();\n+    if (o->expiration < now) {\n+        printf(\"\\texpired\\n\");\n+        return false; // expired\n+    }\n+\n+    // firstly, we determine if this is a challenge we issued that we haven't received a solution to yet\n+\n+    if (!ados_key) {\n+        printf(\"\\tno ados key (we have issued no challenges since startup)\\n\");\n+        return false; // we have issued no challenges\n+    }\n+\n+    CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n+    ss << *o->chain << o->purpose << o->expiration;\n+    uint256 sighash = ss.GetHash();\n+    printf(\"\\tchallenge hash = %s\\n\", sighash.ToString().c_str());\n+\n+    // check challenge hash against known hashes\n+    if (!check_challenge_hash(o->expiration, sighash)) {\n+        printf(\"\\tchallenge hash check failure (known hash)\\n\");\n+        return false;\n+    }\n+\n+    // check signature\n+    if (!ados_key->GetPubKey().Verify(sighash, o->vchSig)) {\n+        printf(\"\\tsig verification failed (not our challenge)\\n\");\n+        return false;\n+    }\n+\n+    // we now know this is our challenge; check the solution\n+    if (!o->pow->is_valid(*o->sol)) {\n+        printf(\"\\tis_valid() failed (solution invalid or does not satisfy target)\\n\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+double expected_solution_time(offer_ref o) {\n+    int64_t cycles = o->chain->expected_iteration_cycles();\n+    int64_t attempts = o->chain->expected_invprob();\n+    return (cycles * attempts) / 2.195e9;\n+}\n+\n+bool solvable(offer_ref o) {\n+    double est = expected_solution_time(o);\n+    int64_t eta = GetTime() + (int64_t)(est * 1.5);\n+    return (eta < o->expiration);\n+}\n+\n+}  // namespace ados"
      },
      {
        "sha": "1d2b488f09459c9cb410198fcf66fbc8029a5c06",
        "filename": "src/ados.h",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fcbf410337e476158752c35f0d3590deb675d9f5/src/ados.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fcbf410337e476158752c35f0d3590deb675d9f5/src/ados.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ados.h?ref=fcbf410337e476158752c35f0d3590deb675d9f5",
        "patch": "@@ -0,0 +1,140 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+/**\n+ * Anti-DoS mechanism using proof of work to grant temporary privileges to\n+ * peers who successfully solve a given challenge. It is simultaneously an\n+ * interface for solving posed challenges in order to obtain said\n+ * privileges.\n+ */\n+\n+#ifndef BITCOIN_ADOS_H\n+#define BITCOIN_ADOS_H\n+\n+#include \"protocol.h\"\n+#include \"pow/pow.h\"\n+\n+class CNode;\n+class CAddress;\n+\n+namespace ados {\n+\n+static const uint32_t PURPOSE_CONNECT = 1;\n+\n+struct offer {\n+    powa::pow_ref pow;\n+    powa::powchain* chain;\n+    powa::solution_ref sol;\n+    uint32_t purpose;\n+    int64_t expiration;\n+    std::vector<unsigned char> vchSig;\n+    bool is_challenge;\n+\n+    offer(bool is_challenge_in = true) : is_challenge(is_challenge_in) {}\n+\n+    bool operator==(const offer& other) const {\n+        return pow.get() == other.pow.get() &&\n+            purpose == other.purpose &&\n+            expiration == other.expiration;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        if (!pow.get()) pow.reset(chain = new powa::powchain());\n+        if (!sol.get()) sol.reset(new powa::solution());\n+        printf(\"offer serializing pow %p\\n\", pow.get());\n+        READWRITE(*chain);\n+        printf(\"offer serializing purpose\\n\");\n+        READWRITE(purpose);\n+        READWRITE(expiration);\n+        READWRITE(vchSig);\n+        if (!is_challenge || !ser_action.ForRead()) READWRITE(*sol);\n+        printf(\"offer serializing done\\n\");\n+    }\n+};\n+typedef std::shared_ptr<offer> offer_ref;\n+\n+class callback : public powa::callback {\n+public:\n+    offer_ref o;\n+\n+    callback() {}\n+    callback(offer_ref o_in) : o(o_in) {}\n+\n+    /**\n+     * A challenge presented to us by a peer was solved.\n+     * @param  challenge The challenge that was solved.\n+     * @param  solution  The solution.\n+     * @return           Whether the given solution satisfies external requirements. If false, another solution is attempted.\n+     */\n+    virtual bool solved_challenge(powa::solution_ref solution) {\n+        return true; // stop finding solutions; return true here to continue searching\n+    }\n+\n+    bool found_solution(const powa::pow& pow_, powa::challenge_ref challenge, powa::solution_ref solution) override {\n+        return solved_challenge(solution);\n+    }\n+\n+    virtual ~callback() {\n+        if (o->pow.get()) o->pow->abort();\n+    }\n+};\n+\n+class connection_challenge : public callback {\n+public:\n+    CAddress addr;\n+    connection_challenge(CNode& peer, offer_ref o_in);\n+    bool solved_challenge(powa::solution_ref sol) override;\n+};\n+\n+/**\n+ * Begin to solve the challenge for the given offer. The investment\n+ * defines the amount of ticks to use per attempt, before moving on to\n+ * other challenges (if any).\n+ * @param o          Reference to offer object.\n+ * @param investment Investment (tick cap) per attempt.\n+ */\n+void begin_solving(offer_ref o, uint32_t investment = 10000);\n+\n+/**\n+ * Derive a rough estimate on the estimated time to solve the challenge for the\n+ * given offer.\n+ * @param  o Reference to offer object.\n+ * @return   An estimate in seconds.\n+ */\n+double expected_solution_time(offer_ref o);\n+\n+/**\n+ * Determine if the challenge for the given offer is solvable. It is considered\n+ * solvable if 1.5 times the expected solution time is less than the time until\n+ * the offer expires.\n+ * @param  o Reference to offer object.\n+ * @return   True if the offer is most likely solvable, false if it probably isn't.\n+ */\n+bool solvable(offer_ref o);\n+\n+/**\n+ * Send a CHALLENGE message to the given peer for the given purpose under the\n+ * given amount of pressure. The pressure is a value between 0 and 1 which\n+ * indicates how difficult the challenge should be.\n+ * @param peer     The CNode peer object.\n+ * @param purpose  The purpose of the challenge, e.g. PURPOSE_CONNECT.\n+ * @param pressure The current pressure value, between 0 and 1.\n+ */\n+void challenge_peer(CNode& peer, uint32_t purpose, double pressure);\n+\n+/**\n+ * Check if the given solution is valid. This includes making sure we signed\n+ * the challenge, that it wasn't solved previously by someone else, that it\n+ * isn't expired, and that its solution validly solves the challenge.\n+ * @param  o Reference to offer object, which must have a solution.\n+ * @return   True if the offer has been successfully solved, false otherwise.\n+ */\n+bool check_solution(offer_ref o);\n+\n+}  // namespace ados\n+\n+#endif  // BITCOIN_ADOS_H"
      }
    ]
  },
  {
    "sha": "b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDZlNjAyYTNhNTJkMTJhOGYxYTQ3NDNjZThkODI0NzI5NmQ4MGMw",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-05-01T09:00:09Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T07:24:43Z"
      },
      "message": "[net] Added support for POW slots.\n\nA new nPOWConnectionSlots ivar is added to connection options and fRequirePOW is added to CNode.\n\nThe logic upon incoming connections for evictions is changed to (1) include a fRequirePOW bool which defaults to false and is set to true if the number of inbound connections exceeds nMaxInbound - nPOWConnectionSlots, and (2) to attempt eviction if the number of inbound exceeds nMaxInbound. Assuming the connection is accepted, fRequirePOW is set in the node as appropriate.\n\nCConnman::OpenNetworkConnection has an added ados::offer which, if set, is inserted into the newly connected node and subsequently sent before the version message.\n\nNetMsgType::SOLUTION and NetMsgType::CHALLENGE are added and handled in net_processing, and NODE_DOSPROT is added as bit 5 (note: this needs to be explicitly defined probably in BIP-154).",
      "tree": {
        "sha": "bd8bc2a50768d2b675b80cd0ed9ae880190e2942",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd8bc2a50768d2b675b80cd0ed9ae880190e2942"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk5GEYACgkQV692LbM1\nMyI/nQ//bslb635//iCHbZ/CwXf8AqSn1KYVB8R9k6smt24MTmd4iGbGK5LVMoKI\niYWzWpjZru5YwE80GQM4DmROWW/JkSnrLGBeb3MnvlRWAQvVTaUlN03x4lZTemXu\ncusfkVopo1n09Vsxena7+DpD15VitMTxblCXGl4Dg26jlTgQagpUiz/Be55oq/Nj\nqH/h9U6wI/k4auhHD7BtxXSDhW6us0/lgs8f7nmjW2/SrR+XszAm4OmsU+B0CL/C\nzkp2PCAF0+QSGo6euEBffzsNXpgB3pkv2lwDRDhvKqKQXd8garU6tgdEGzR3aDCA\n5fqE46WRLhRXAD0YS35XEcJzynthw/QxX224Bw09OO3qKAHklfAQ2GKgb+ADQ1uJ\n3U+sHN/n+DU4f0GJ35vPXW1KxmWgaQshYvQY9a1LfCt++KgiuOhDxGC9Sw6mdjzp\nt8IvY+O3liJCyZUPEh6QK36qnAfOv5kSGN97c6qXIZ+1PuQl40k5Zjlf4zdL/BOS\n6T/BssalfYKUkaOGSUZCbD8K2W6cO3JMtrzQRNGGZ5Hi9owDzJjPUrOsi/xMN+Mj\n4xXrvuE+icY0DC2TTBuB6LtTiGTdI+pLLnda3K4HvOUdO78UNwpYYbkY9FtVxP20\nwT+JY8dLSzg8o0LDKfkdaUrT8XgQJFXOKCMxDxFMBWNqvlh+Ovw=\n=izD0\n-----END PGP SIGNATURE-----",
        "payload": "tree bd8bc2a50768d2b675b80cd0ed9ae880190e2942\nparent fcbf410337e476158752c35f0d3590deb675d9f5\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1493629209 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496906683 +0900\n\n[net] Added support for POW slots.\n\nA new nPOWConnectionSlots ivar is added to connection options and fRequirePOW is added to CNode.\n\nThe logic upon incoming connections for evictions is changed to (1) include a fRequirePOW bool which defaults to false and is set to true if the number of inbound connections exceeds nMaxInbound - nPOWConnectionSlots, and (2) to attempt eviction if the number of inbound exceeds nMaxInbound. Assuming the connection is accepted, fRequirePOW is set in the node as appropriate.\n\nCConnman::OpenNetworkConnection has an added ados::offer which, if set, is inserted into the newly connected node and subsequently sent before the version message.\n\nNetMsgType::SOLUTION and NetMsgType::CHALLENGE are added and handled in net_processing, and NODE_DOSPROT is added as bit 5 (note: this needs to be explicitly defined probably in BIP-154).\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fcbf410337e476158752c35f0d3590deb675d9f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcbf410337e476158752c35f0d3590deb675d9f5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fcbf410337e476158752c35f0d3590deb675d9f5"
      }
    ],
    "stats": {
      "total": 142,
      "additions": 137,
      "deletions": 5
    },
    "files": [
      {
        "sha": "2e6ec0788b9f7ed44229a4b6265835aee7083781",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "patch": "@@ -816,7 +816,9 @@ namespace { // Variables internal to initialization process only\n \n ServiceFlags nRelevantServices = NODE_NETWORK;\n int nMaxConnections;\n+int nPOWConnectionSlots;\n int nUserMaxConnections;\n+int nUserPOWConnectionSlots;\n int nFD;\n ServiceFlags nLocalServices = NODE_NETWORK;\n \n@@ -904,6 +906,8 @@ bool AppInitParameterInteraction()\n                 (gArgs.IsArgSet(\"-whitebind\") ? gArgs.GetArgs(\"-whitebind\").size() : 0), size_t(1));\n     nUserMaxConnections = GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n+    nUserPOWConnectionSlots = GetArg(\"-powconnectionslots\", DEFAULT_POW_CONNECTION_SLOTS);\n+    nPOWConnectionSlots = std::max(nUserPOWConnectionSlots, 0);\n \n     // Trim requested connection counts, to fit into system limitations\n     nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS)), 0);\n@@ -1649,6 +1653,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nLocalServices = nLocalServices;\n     connOptions.nRelevantServices = nRelevantServices;\n     connOptions.nMaxConnections = nMaxConnections;\n+    connOptions.nPOWConnectionSlots = nPOWConnectionSlots;\n     connOptions.nMaxOutbound = std::min(MAX_OUTBOUND_CONNECTIONS, connOptions.nMaxConnections);\n     connOptions.nMaxAddnode = MAX_ADDNODE_CONNECTIONS;\n     connOptions.nMaxFeeler = 1;"
      },
      {
        "sha": "cd4616bbc98a10cc565f4e2a414e039e4bc1777c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "patch": "@@ -21,6 +21,7 @@\n #include \"scheduler.h\"\n #include \"ui_interface.h\"\n #include \"utilstrencodings.h\"\n+#include \"ados.h\"\n \n #ifdef WIN32\n #include <string.h>\n@@ -1100,9 +1101,13 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n         return;\n     }\n \n-    if (nInbound >= nMaxInbound)\n+    bool fRequirePOW = false;\n+    if (nInbound >= nMaxInbound - nPOWConnectionSlots)\n     {\n-        if (!AttemptToEvictConnection()) {\n+        // We're out of free slots; any POW slots around? If not, try to evict\n+        // somebody; if that fails, we give up\n+        fRequirePOW = true;\n+        if (nInbound >= nMaxInbound && !AttemptToEvictConnection()) {\n             // No connection to evict, disconnect the new connection\n             LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");\n             CloseSocket(hSocket);\n@@ -1116,6 +1121,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n+    pnode->fRequirePOW = fRequirePOW;\n     pnode->fWhitelisted = whitelisted;\n     GetNodeSignals().InitializeNode(pnode, *this);\n \n@@ -1944,7 +1950,7 @@ void CConnman::ThreadOpenAddedConnections()\n }\n \n // if successful, this moves the passed grant to the constructed node\n-bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode, const ados::offer_ref offer)\n {\n     //\n     // Initiate outbound network connection\n@@ -1967,6 +1973,9 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n \n     if (!pnode)\n         return false;\n+    if (offer) {\n+        pnode->offer = offer;\n+    }\n     if (grantOutbound)\n         grantOutbound->MoveTo(pnode->grantOutbound);\n     if (fOneShot)\n@@ -2218,6 +2227,7 @@ CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In) : nSeed0(nSeed0In), nSe\n     semOutbound = NULL;\n     semAddnode = NULL;\n     nMaxConnections = 0;\n+    nPOWConnectionSlots = 0;\n     nMaxOutbound = 0;\n     nMaxAddnode = 0;\n     nBestHeight = 0;\n@@ -2240,6 +2250,7 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n     nRelevantServices = connOptions.nRelevantServices;\n     nLocalServices = connOptions.nLocalServices;\n     nMaxConnections = connOptions.nMaxConnections;\n+    nPOWConnectionSlots = connOptions.nPOWConnectionSlots;\n     nMaxOutbound = std::min((connOptions.nMaxOutbound), nMaxConnections);\n     nMaxAddnode = connOptions.nMaxAddnode;\n     nMaxFeeler = connOptions.nMaxFeeler;\n@@ -2647,6 +2658,12 @@ ServiceFlags CConnman::GetLocalServices() const\n     return nLocalServices;\n }\n \n+double CConnman::GetPressure()\n+{\n+    int nMaxInbound = nMaxConnections - (nMaxOutbound + nMaxFeeler + nPOWConnectionSlots);\n+    return ((double)GetNodeCount(CONNECTIONS_ALL) - nMaxInbound) / nPOWConnectionSlots;\n+}\n+\n void CConnman::SetBestHeight(int height)\n {\n     nBestHeight.store(height, std::memory_order_release);\n@@ -2692,6 +2709,9 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fClient = false; // set by version message\n     fFeeler = false;\n     fSuccessfullyConnected = false;\n+    fRequirePOW = false;\n+    offer = nullptr;\n+    fDidPOW = false;\n     fDisconnect = false;\n     nRefCount = 0;\n     nSendSize = 0;"
      },
      {
        "sha": "da3967270431851ddf53d453d88a69eecc6580b2",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "patch": "@@ -21,6 +21,7 @@\n #include \"sync.h\"\n #include \"uint256.h\"\n #include \"threadinterrupt.h\"\n+#include \"ados.h\"\n \n #include <atomic>\n #include <deque>\n@@ -75,6 +76,8 @@ static const size_t MAPASKFOR_MAX_SZ = MAX_INV_SZ;\n static const size_t SETASKFOR_MAX_SZ = 2 * MAX_INV_SZ;\n /** The maximum number of peer connections to maintain. */\n static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125;\n+/** The number of proof-of-work connection slots to retain. */\n+static const unsigned int DEFAULT_POW_CONNECTION_SLOTS = 50;\n /** The default for -maxuploadtarget. 0 = Unlimited */\n static const uint64_t DEFAULT_MAX_UPLOAD_TARGET = 0;\n /** The default timeframe for -maxuploadtarget. 1 day. */\n@@ -135,6 +138,7 @@ class CConnman\n         ServiceFlags nLocalServices = NODE_NONE;\n         ServiceFlags nRelevantServices = NODE_NONE;\n         int nMaxConnections = 0;\n+        int nPOWConnectionSlots = 0;\n         int nMaxOutbound = 0;\n         int nMaxAddnode = 0;\n         int nMaxFeeler = 0;\n@@ -154,7 +158,7 @@ class CConnman\n     bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n     bool GetNetworkActive() const { return fNetworkActive; };\n     void SetNetworkActive(bool active);\n-    bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n+    bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false, const ados::offer_ref offer = nullptr);\n     bool CheckIncomingNonce(uint64_t nonce);\n \n     bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n@@ -273,6 +277,15 @@ class CConnman\n     uint64_t GetTotalBytesRecv();\n     uint64_t GetTotalBytesSent();\n \n+    /**\n+     * Calculate the pressure (work load) as a value in the range [0..1], where\n+     * 0 means no pressure and 1 means maximum pressure. This is calculated as\n+     *      (connections - free) / pow_slots\n+     * This reaches the 1.0 point at (nMaxConnections - nMaxOutbound - nMaxFeeler).\n+     * @return Pressure value.\n+     */\n+    double GetPressure();\n+\n     void SetBestHeight(int height);\n     int GetBestHeight() const;\n \n@@ -377,6 +390,7 @@ class CConnman\n     CSemaphore *semOutbound;\n     CSemaphore *semAddnode;\n     int nMaxConnections;\n+    int nPOWConnectionSlots;\n     int nMaxOutbound;\n     int nMaxAddnode;\n     int nMaxFeeler;\n@@ -602,6 +616,9 @@ class CNode\n     std::string strSubVer, cleanSubVer;\n     CCriticalSection cs_SubVer; // used for both cleanSubVer and strSubVer\n     bool fWhitelisted; // This peer can bypass DoS banning.\n+    bool fRequirePOW; // We require this node to solve a POW challenge\n+    bool fDidPOW; // This peer solved a POW challenge for us\n+    ados::offer_ref offer; // An offer with a challenge that we solved for this peer\n     bool fFeeler; // If true this node is being used as a short lived feeler.\n     bool fOneShot;\n     bool fAddnode;"
      },
      {
        "sha": "35d1a177fd135553526a6ea541780d1088ad8d87",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 1,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "patch": "@@ -29,6 +29,7 @@\n #include \"utilmoneystr.h\"\n #include \"utilstrencodings.h\"\n #include \"validationinterface.h\"\n+#include \"ados.h\"\n \n #include <boost/thread.hpp>\n \n@@ -274,8 +275,16 @@ void InitializeNode(CNode *pnode, CConnman& connman) {\n         LOCK(cs_main);\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n     }\n-    if(!pnode->fInbound)\n+    if(!pnode->fInbound) {\n+        if (pnode->offer) {\n+            connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::SOLUTION, *pnode->offer));\n+            // TODO: set flag in pnode that we solved for them\n+            pnode->offer = nullptr;\n+        }\n+        // TODO: verify that above is not at risk of arriving after below version push which would result\n+        // TODO: in an invalid disconnect from the peer despite solving their challenge\n         PushNodeVersion(pnode, connman, GetTime());\n+    }\n }\n \n void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n@@ -1238,6 +1247,66 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n     }\n \n+\n+    else if (strCommand == NetMsgType::SOLUTION)\n+    {\n+        // The node is providing us with a solution to a challenge in order to\n+        // connect.\n+        LogPrint(BCLog::NET, \"We are being given a solution\\n\");\n+        ados::offer_ref offer(new ados::offer(false));\n+        vRecv >> *offer;\n+        if (!ados::check_solution(offer)) {\n+            // bye\n+            LogPrint(BCLog::NET, \"The provided solution did not pass. Re-challenge and disconnect.\\n\");\n+            ados::challenge_peer(*pfrom, ados::PURPOSE_CONNECT, connman.GetPressure());\n+            pfrom->fDisconnect = true;\n+            return false;\n+        }\n+        LogPrint(BCLog::NET, \"Solution passed.\\n\");\n+        pfrom->fRequirePOW = false; // no longer required\n+        pfrom->fDidPOW = true; // treat them like special snowflakes\n+        return true;\n+    }\n+\n+\n+    else if (strCommand == NetMsgType::CHALLENGE)\n+    {\n+        // The node requires us to solve a challenge before they will talk to\n+        // us.\n+        LogPrint(BCLog::NET, \"We are being challenged\\n\");\n+        if (pfrom->fInbound) {\n+            // we don't take challenges from incoming connections\n+            LogPrint(BCLog::NET, \"An inbound connection is asking us to solve a challenge to connect. Only outbound connections may do so.\\n\");\n+            LOCK(cs_main);\n+            Misbehaving(pfrom->GetId(), 10);\n+            pfrom->fDisconnect = true;\n+            return false;\n+        }\n+        ados::offer_ref offer(new ados::offer());\n+        vRecv >> *offer;\n+        // Is this solvable?\n+        if (!ados::solvable(offer)) {\n+            LogPrint(BCLog::NET, \"Challenge too hard: expected solve time %.2fs\\n\", ados::expected_solution_time(offer));\n+            return false;\n+        } else {\n+            LogPrint(BCLog::NET, \"Solving challenge: expected solve time %.2fs; expiration in %lus\\n\", ados::expected_solution_time(offer), offer->expiration - GetTime());\n+        }\n+        offer->pow->cb.reset(new ados::connection_challenge(*pfrom, offer));\n+        ados::begin_solving(offer);\n+        return true;\n+    }\n+\n+\n+    else if (pfrom->fRequirePOW)\n+    {\n+        LogPrint(BCLog::NET, \"Peer must do POW to connect; challenge and disco\\n\");\n+        // The node did not give a solution and must solve a challenge before we\n+        // will establish a connection. Challenge it and disconnect.\n+        ados::challenge_peer(*pfrom, ados::PURPOSE_CONNECT, connman.GetPressure());\n+        pfrom->fDisconnect = true;\n+        return true;\n+    }\n+\n     else if (strCommand == NetMsgType::VERSION)\n     {\n         // Each connection can only send one version message"
      },
      {
        "sha": "3564044e8c88da18bd18bf207745030db78bfad5",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "patch": "@@ -39,6 +39,8 @@ const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n+const char *CHALLENGE=\"challenge\";\n+const char *SOLUTION=\"solution\";\n };\n \n /** All known message types. Keep this in the same order as the list of\n@@ -71,6 +73,8 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::CMPCTBLOCK,\n     NetMsgType::GETBLOCKTXN,\n     NetMsgType::BLOCKTXN,\n+    NetMsgType::CHALLENGE,\n+    NetMsgType::SOLUTION,\n };\n const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n "
      },
      {
        "sha": "594fe0b7b2cada2f84b46f093c17a5d82beb0acc",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b06e602a3a52d12a8f1a4743ce8d8247296d80c0/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "patch": "@@ -240,6 +240,20 @@ extern const char *GETBLOCKTXN;\n  * @since protocol version 70014 as described by BIP 152\n  */\n extern const char *BLOCKTXN;\n+/**\n+ * Contains a proof of work challenge for elevated privileges.\n+ * The challenge is composed of four parts -- a POW specification,\n+ * a purpose specifier, an expiration date, and a signature.\n+ * If the challenged peer solves the challenge, they are\n+ * given the specified reward if it is still available.\n+ */\n+extern const char *CHALLENGE;\n+/**\n+ * Contains a solution to a proof of work challenge for elevated\n+ * privileges. The solution contains a challenge in its entirety, and solution\n+ * to the challenge.\n+ */\n+extern const char *SOLUTION;\n };\n \n /* Get a vector of all valid message types (see above) */\n@@ -267,6 +281,9 @@ enum ServiceFlags : uint64_t {\n     // NODE_XTHIN means the node supports Xtreme Thinblocks\n     // If this is turned off then the node will not service nor make xthin requests\n     NODE_XTHIN = (1 << 4),\n+    // NODE_DOSPROT means the node is able to provide and solve challenges intended\n+    // to alleviate DoS pressure on the network\n+    NODE_DOSPROT = (1 << 5),\n \n     // Bits 24-31 are reserved for temporary experiments. Just pick a bit that\n     // isn't getting used, or one not being used much, and notify the"
      }
    ]
  },
  {
    "sha": "36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNmRkNDY2NGZkMWFkMjljN2JiZDhhN2Y2M2E4OGNkZWE1ZmFjNzY4",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-06T06:51:02Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T09:26:30Z"
      },
      "message": "[qt] Added NODE_DOSPROT to guiutil",
      "tree": {
        "sha": "fe07b5c8ce6f88e993920f1de4b74718e3b430db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe07b5c8ce6f88e993920f1de4b74718e3b430db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk5GFMACgkQV692LbM1\nMyJRdw/9FiZvWym0xk+liZE9l21LZBCZ73Y/azC6RDs7ng5+mmyZFLKk8RSUISs+\nqsPfHrrahMGj6P0FHQTo1cb3et5jZ8hwRg/XfmKK8Zxnl3QWcBlbKubmk5vaPUnG\nDeiwEJk3Ldn15PZBKyHk7/HGHDCCv1FZqZ/aR3woQpIWkcy2N9KrhBxjypQWckzt\n1KGDmFCEqv6ELZiMORxxvVDtvr/VUW0kh4hiXrAjDlWWDYjx6e/mFRHjKQhGXrtN\neywxUwr4YKYXcYfVQJRyoE3UeMo0knNL1rPWR6piQtZEbFixp1MS/Jf12GA5vF9t\nDa1qWtXPewAANPBJMGjvu+eogm1le7T+o2+nvxzZy2x/AIgkmHi+b1xOnJ7Xg7pR\nUDGkK6mxNnsKCE+UMGSL3vQm2yBts0hBMb/MF3p5AnKOfbM1vRLa9u2dfwYlIDYZ\nywiXt10tA9LwG2rn2GMZKzH+zF1yH9IZmOv96HRuRc6xKf7eFjWBC98Ov8LNp+ni\nC+wIFOEoxyxraH8NSTXLey0jDwltqPxxsMuUJvOBqBvkbOR1DKQsH+9uTbcFHIxb\ntlH37O06Tia41Fu5unhvHKvsqYBOc7Qu3ErIIKFx6IH6sZ4WrmShE3fxLIFErdgS\n9DLe+52QQcJ3EjoV3Nsp2TkYq1vT6N4sBuUgMA0vTi0pLdXNsDw=\n=ClLg\n-----END PGP SIGNATURE-----",
        "payload": "tree fe07b5c8ce6f88e993920f1de4b74718e3b430db\nparent b06e602a3a52d12a8f1a4743ce8d8247296d80c0\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491461462 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496913990 +0900\n\n[qt] Added NODE_DOSPROT to guiutil\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b06e602a3a52d12a8f1a4743ce8d8247296d80c0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b06e602a3a52d12a8f1a4743ce8d8247296d80c0"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 3,
      "deletions": 0
    },
    "files": [
      {
        "sha": "83ddfb9c63a32d91442f89a8c881281312d18bae",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
        "patch": "@@ -930,6 +930,9 @@ QString formatServicesStr(quint64 mask)\n             case NODE_XTHIN:\n                 strList.append(\"XTHIN\");\n                 break;\n+            case NODE_DOSPROT:\n+                strList.append(\"DOSPROT\");\n+                break;\n             default:\n                 strList.append(QString(\"%1[%2]\").arg(\"UNKNOWN\").arg(check));\n             }"
      }
    ]
  },
  {
    "sha": "ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZGIyZDJhMjI3ZWFiMDNlMmZmMmNhNTkzODJmN2YyNzQzZDJiZDJi",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:29:18Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-08T09:26:44Z"
      },
      "message": "[test] Added tests for SHA256 POW.",
      "tree": {
        "sha": "d0aba8b490a6fce0739158a084c5243b3bc7af94",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0aba8b490a6fce0739158a084c5243b3bc7af94"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlk5GFkACgkQV692LbM1\nMyJFSg/9GDtctif6H2u1vrLy2AdC4CR+ZXzCwHLN4GINW/L/xPdlkNNziN6+l9Ei\nzjx9soIOCNMuOUpaFuWgMA1aENC8jJEPWKzL0pM+PJoNqgP4Ek/SC22JP8ZXdlQ5\nsY5cu1U0FobI542TV+8MGnscepADBVDVHUFT5ayGx0xSRGW1NeWkfevzw6ELMXry\nas90AHxgLCoM7+yoAe5sNeIguO5i2iaG2CDdT9txmOC0DlbSSoVpNqDcuSfSuAM/\nybCnrAoIP8TbD5ABRWsyCtVJPIjmaYabkJrj0oCYnkXY++F9v2S/4tNbGbGrWHKQ\nStDURGycjHfsyCVixck3wYoYN69ipb1IKYT/RozdzTekwbGE5tyzHZ0xdXZrsoxE\nCEckNXHkxEZWDy3YrhubgrlFUKyjSLm1m/pPGeXk06MzZF3QyG1y2v34VKwz6osR\nqOdVTJkGGRMBFqgj1M/v84zqfbsbantKfDic32kgXJtlmIZC+TcyPeRZjIgJKEtM\nZwYLhmZxsAFuxHtjjFYrHK0o596h7+5APkEcJnITnwgNiJVqWudqah9rgl+Dvstn\n/edrVBy3fID50Mj2vnDgMEygL5ZN2jkywSzMAGt800Ta8fY+RS5QOpsZdGlQm5BQ\n5SVEkxjezdsWFGxmLj/UhZnwRKXPbUvaxjtH70NKqAxKuqF56Yw=\n=0+T2\n-----END PGP SIGNATURE-----",
        "payload": "tree d0aba8b490a6fce0739158a084c5243b3bc7af94\nparent 36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491902958 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1496914004 +0900\n\n[test] Added tests for SHA256 POW.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/36dd4664fd1ad29c7bbd8a7f63a88cdea5fac768"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 77,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f4e100ae39bb1b0b3d7ddff9450d8fb7248e99c9",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
        "patch": "@@ -56,6 +56,7 @@ BITCOIN_TESTS =\\\n   test/pmt_tests.cpp \\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n+  test/pow_sha256_tests.cpp \\\n   test/prevector_tests.cpp \\\n   test/raii_event_tests.cpp \\\n   test/random_tests.cpp \\"
      },
      {
        "sha": "55df5dfe1188982ab404492b69eb1ac1bf8211e6",
        "filename": "src/test/pow_sha256_tests.cpp",
        "status": "added",
        "additions": 76,
        "deletions": 0,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b/src/test/pow_sha256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b/src/test/pow_sha256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_sha256_tests.cpp?ref=ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
        "patch": "@@ -0,0 +1,76 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"pow/sha256/sha256.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+int WriteHex(uint8_t* dst, const char* hex) {\n+\tint i = 0;\n+\twhile (hex[i]) {\n+\t\tchar l = hex[i++];\n+\t\tchar r = hex[i++];\n+\t\tuint8_t v = (l >= 'a' && l <= 'f' ? 10 + l - 'a' : l - '0');\n+\t\t*(dst++) = (v << 4) | (r >= 'a' && r <= 'f' ? 10 + r - 'a' : r - '0');\n+\t}\n+\treturn i;\n+}\n+\n+class collector_sha256 : public powa::callback {\n+public:\n+\tbool finished;\n+\tpowa::solution_ref sol;\n+\tcollector_sha256(powa::solution_ref sol_in) : finished(false), sol(sol_in) {}\n+\tbool found_solution(const powa::pow& p, powa::challenge_ref c, powa::solution_ref s) override {\n+\t\tprintf(\"found solution\\n\");\n+\t\tsol = s;\n+\t\tfinished = true;\n+\t\treturn true;\n+\t}\n+};\n+\n+BOOST_FIXTURE_TEST_SUITE(pow_sha256_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(pow_sha256_tests)\n+{\n+\tpowa::fZeroStartingNonce = true;\n+\t// zero header case\n+\t{\n+\t\tpowa::challenge_ref chlg(new powa::sha256challenge(0x200fffff, 4, 0, 0));\n+\t\tcollector_sha256* coll = new collector_sha256(powa::solution_ref(new powa::solution((uint32_t)0)));\n+\t\tpowa::callback_ref collref(coll);\n+\t\tpowa::sha256 alg(chlg, collref);\n+\t\t// the zero bit solution should not solve the zero header challenge\n+\t\tBOOST_CHECK(!alg.is_valid(*coll->sol));\n+\t\t// now solve the challenge; it should be solved within 5 attempts\n+\t\talg.solve(0, false, 5);\n+\t\t// we should have solved the challenge\n+\t\tBOOST_CHECK(coll->finished == true);\n+\t\t// the solution should now solve the challenge\n+\t\tBOOST_CHECK(alg.is_valid(*coll->sol));\n+\t\tprintf(\"done zero header case\\n\");\n+\t}\n+\n+\t// HEADERLEN byte header case\n+\t{\n+\t\tuint8_t randomness[80];\n+\t\tWriteHex(randomness, \"43fcd0d3ee002389ff95c7e2c568aa0d5206688dd05589d5d5b040fd4bf837081911b814c02405e88c49bc52dc8a77ea48d73dc42d195740db2fa90498613fdfe96da5c2e3ba8deca6c65b9635\");\n+\t\tpowa::challenge_ref chlg(new powa::sha256challenge(0x200fffff, 4, 76, 80));\n+\t\tcollector_sha256* coll = new collector_sha256(powa::solution_ref(new powa::solution((uint32_t)0)));\n+\t\tpowa::callback_ref collref(coll);\n+\t\tchlg->set_params(randomness, 80);\n+\t\tpowa::sha256 alg(chlg, collref);\n+\t\t// the zero bit solution does not solve the random header challenge (it isn't random, or we wouldn't be sure about that)\n+\t\tBOOST_CHECK(!alg.is_valid(*coll->sol));\n+\t\t// now solve the challenge; it should be solved within 11 attempts\n+\t\talg.solve(0, false, 11);\n+\t\t// we should have solved the challenge\n+\t\tBOOST_CHECK(coll->finished == true);\n+\t\t// the solution should now solve the challenge\n+\t\tBOOST_CHECK(alg.is_valid(*coll->sol));\n+\t}\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "f1b5a74d8dc197a4966901f472744284d1f26d83",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMWI1YTc0ZDhkYzE5N2E0OTY2OTAxZjQ3Mjc0NDI4NGQxZjI2ZDgz",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:29:51Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-14T06:45:33Z"
      },
      "message": "[test] Added tests for cuckoo cycle POW.",
      "tree": {
        "sha": "dff13c3bb3d1107c3554c5f0a1ce767e98496189",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dff13c3bb3d1107c3554c5f0a1ce767e98496189"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1b5a74d8dc197a4966901f472744284d1f26d83",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAllA240ACgkQV692LbM1\nMyLqiA/9HefuVv5MmUQ6Uqnh5G0NdPf4BJjgWaSaiKr2OCWhYdy3u0cxb27jyCQP\nVh1fTqd+Ul5iTTSJpZzyCCxGk310SbB/E8AluppvLmnO1zYWxmRUMAv96xm62fJj\nFX3AgZ7CB+C3CKRyT8Tm5p17yG+Miyu4pbma/skLvdRf3LmXATEz8o1xiTiDcVsc\n8UyFtR0JCG1Knsc+oxQCf95Y9Z6G1z1j/nAhaRj1T+X4y8bG9YkXGHC5x2T4oJz7\nYId8J6s7GN+WWJEUYwpAues243ZuNKjC7S7iF6TkMyRuyHcrkKCVd9DskBtDdeHD\nI+ur3HwBAxLZHPlQkwbNhuH3BC+2nfS657MxU/6GNZhdkElGJIVxReOHyDAZjxua\n6O/qb1rb+YOpjAnjmD4y9khY0sU/t+z/4qLKpBwtqIZnTmqjg4+x59tL6hUNUN6y\njLxmU3nYJ4CIGB2HHWsbkBFfaQSuAxBaV+qAhrrLk6wOrIrDnn+v28qyOEquWK1d\nZnnt0gTRtjE9WrpxirzBnM1txzoeYk9096LptTnK4IOA3e1tJkVPm38MV/PDP8M6\nnmmLeHuMs13P9BUUMwf65JcP+cJR5KO+njSreENZ09lTJm7YFLzxjUUj6MK4lS5h\ndJjZZC9YQSPn5CKdO5qi+SUPGTRunpj5LTvX1QgwAHB4N+MKIs8=\n=KKAP\n-----END PGP SIGNATURE-----",
        "payload": "tree dff13c3bb3d1107c3554c5f0a1ce767e98496189\nparent ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491902991 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1497422733 +0900\n\n[test] Added tests for cuckoo cycle POW.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1b5a74d8dc197a4966901f472744284d1f26d83",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f1b5a74d8dc197a4966901f472744284d1f26d83",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1b5a74d8dc197a4966901f472744284d1f26d83/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ddb2d2a227eab03e2ff2ca59382f7f2743d2bd2b"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 72,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3d530022d99810d40551f5709430383b0f29c9c2",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1b5a74d8dc197a4966901f472744284d1f26d83/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1b5a74d8dc197a4966901f472744284d1f26d83/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=f1b5a74d8dc197a4966901f472744284d1f26d83",
        "patch": "@@ -57,6 +57,7 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/pow_sha256_tests.cpp \\\n+  test/pow_cuckoo_cycle_tests.cpp \\\n   test/prevector_tests.cpp \\\n   test/raii_event_tests.cpp \\\n   test/random_tests.cpp \\"
      },
      {
        "sha": "7d04e8765f1ffc43fbf5df60844ff9975e68b41d",
        "filename": "src/test/pow_cuckoo_cycle_tests.cpp",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1b5a74d8dc197a4966901f472744284d1f26d83/src/test/pow_cuckoo_cycle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1b5a74d8dc197a4966901f472744284d1f26d83/src/test/pow_cuckoo_cycle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_cuckoo_cycle_tests.cpp?ref=f1b5a74d8dc197a4966901f472744284d1f26d83",
        "patch": "@@ -0,0 +1,71 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"pow/cuckoo_cycle/cuckoo_cycle.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+class cc_collector : public powa::callback {\n+public:\n+\tbool finished;\n+\tpowa::solution_ref sol;\n+\tcc_collector(powa::solution_ref _sol) : finished(false), sol(_sol) {}\n+\tbool found_solution(const powa::pow& p, powa::challenge_ref c, powa::solution_ref s) override {\n+\t\tsol = s;\n+\t\tfinished = true;\n+\t\treturn true;\n+\t}\n+};\n+\n+BOOST_FIXTURE_TEST_SUITE(pow_cuckoo_cycle_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(pow_cuckoo_cycle_tests)\n+{\n+\tpowa::fZeroStartingNonce = true;\n+\t// zero header case\n+\t{\n+\t\tuint32_t nonces[42];\n+\t\tmemset(nonces, 0, sizeof(nonces));\n+\t\tpowa::cuckoo_cycle::cc_challenge_ref chlg(new powa::cuckoo_cycle::cc_challenge());\n+\t\tpowa::solution_ref sol(new powa::solution());\n+\t\tsol->params.resize(4 * 43);\n+\t\tmemset(&sol->params[0], 0, 4 * 43);\n+\t\tcc_collector* coll = new cc_collector(sol);\n+\t\tpowa::callback_ref collref(coll);\n+\t\tpowa::cuckoo_cycle::cuckoo_cycle alg(chlg, collref);\n+\t\t// the zero bit solution should not solve the zero header challenge\n+\t\tBOOST_CHECK(!alg.is_valid(*coll->sol));\n+\t\t// now solve the challenge; it should find a solution at nonce 2\n+\t\talg.next_nonce = 2;\n+\t\talg.solve(0, false, 1);\n+\t\t// we should have solved the challenge\n+\t\tBOOST_CHECK(coll->finished == true);\n+\t\t// the solution should now solve the challenge\n+\t\tBOOST_CHECK(alg.is_valid(*coll->sol));\n+\t}\n+\n+\t// HEADERLEN byte header case\n+\t{\n+\t\tuint32_t nonces[42];\n+\t\tmemset(nonces, 0, sizeof(nonces));\n+\t\tpowa::cuckoo_cycle::cc_challenge_ref chlg = powa::cuckoo_cycle::cc_challenge::random_challenge(HEADERLEN);\n+\t\tpowa::solution_ref sol(new powa::solution());\n+\t\tsol->params.resize(4 * 43);\n+\t\tmemset(&sol->params[0], 0, 4 * 43);\n+\t\tcc_collector* coll = new cc_collector(sol);\n+\t\tpowa::callback_ref collref(coll);\n+\t\tpowa::cuckoo_cycle::cuckoo_cycle alg(chlg, collref);\n+\t\t// the zero bit solution should not solve the random header challenge\n+\t\tBOOST_CHECK(!alg.is_valid(*coll->sol));\n+\t\t// now solve the challenge; it should find a solution before nonce 5\n+\t\talg.solve(0, false, 5);\n+\t\t// we should have solved the challenge\n+\t\tBOOST_CHECK(coll->finished == true);\n+\t\t// the solution should now solve the challenge\n+\t\tBOOST_CHECK(alg.is_valid(*coll->sol));\n+\t}\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGU0MDJiMWZmMWE0OTQ3NWRkOWE5MDMwYmZjYTQyZjQzZGI1NmRk",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:30:27Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-14T06:45:34Z"
      },
      "message": "[test] Added tests for powchain (multiple chained proofs of work in one challenge).",
      "tree": {
        "sha": "664c15902c4c10651c5be2b2504f131f095b8f9d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/664c15902c4c10651c5be2b2504f131f095b8f9d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAllA244ACgkQV692LbM1\nMyLzKRAAk5AocJ5OX/bgr8x1+Se2mcS0opT3rdmw/S9EyFWsxTGca8rEGIVnQwDZ\nC9K+VApjtpjXGHbdIbEJ3vVbuQZ8jCh+XmsDEJEi2c0SCXmg7FesYQi7s6SlwYBo\nMN4ed/4ghDnyH2mZpupsZJNUKpK0KtuF3UeGQfQCZuWX8S9GO+TZKWEpdkG1LpcK\nUVE0rn/N0fzq1W19iMV5TA83bB4YiRLWlYv5x8+80wiV/jwuluyhCcLTfE56VgJE\niloQ3Lk3XovkaW8/MCxqECBAHP8Z88URuNYIxapbXDzPB+uq22bwJQp+4O1b3YvA\nldchFjrZyFZL8rBb59f1X/LUH9FgwQA4XftlzGJIWlfLTT6E5GV2BKse1bwZDJp3\n78I5CKKXKIgqmQw7ZHcj3roaBLwus5xgdkpmHakjDTNXEwWAGK2LRZwGS/kVocUQ\nf1fjhllww1Fr/ojWDjuoLUDMWdpmlCh2xdF0PXKm1waoNpw2AReKzosa3eBX9t2O\nWZ2RQEAEvML9NW9JKTdmkikVjTbQnKYEKiXMn5ysQnpJ4+yeO3U4LCcnCjWxIPbD\n/eGMgvbqQ5F3/9b/H3XOsBDvYOEwM2FMMlfvhSxDl8tmx3vXVagVdJdd3D4MVmQ5\nGv6Zo+F2HUxt1iPaEcBtcBIBGco1okl4swrjFUY3NCpVra+ts6U=\n=voDR\n-----END PGP SIGNATURE-----",
        "payload": "tree 664c15902c4c10651c5be2b2504f131f095b8f9d\nparent f1b5a74d8dc197a4966901f472744284d1f26d83\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491903027 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1497422734 +0900\n\n[test] Added tests for powchain (multiple chained proofs of work in one challenge).\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0e402b1ff1a49475dd9a9030bfca42f43db56dd/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f1b5a74d8dc197a4966901f472744284d1f26d83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1b5a74d8dc197a4966901f472744284d1f26d83",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f1b5a74d8dc197a4966901f472744284d1f26d83"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 59,
      "deletions": 0
    },
    "files": [
      {
        "sha": "207c99e92f4aaad26d65641b45849818c9933c9f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0e402b1ff1a49475dd9a9030bfca42f43db56dd/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0e402b1ff1a49475dd9a9030bfca42f43db56dd/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
        "patch": "@@ -56,6 +56,7 @@ BITCOIN_TESTS =\\\n   test/pmt_tests.cpp \\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n+  test/pow_chain_tests.cpp \\\n   test/pow_sha256_tests.cpp \\\n   test/pow_cuckoo_cycle_tests.cpp \\\n   test/prevector_tests.cpp \\"
      },
      {
        "sha": "738f1cc8b69f932b494eaf181b181b4746408448",
        "filename": "src/test/pow_chain_tests.cpp",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0e402b1ff1a49475dd9a9030bfca42f43db56dd/src/test/pow_chain_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0e402b1ff1a49475dd9a9030bfca42f43db56dd/src/test/pow_chain_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_chain_tests.cpp?ref=d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"pow/sha256/sha256.h\"\n+#include \"pow/cuckoo_cycle/cuckoo_cycle.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+class collector_chain : public powa::callback {\n+public:\n+\tbool finished;\n+\tpowa::solution_ref sol;\n+\tcollector_chain(powa::solution_ref sol_in) : finished(false), sol(sol_in) {}\n+\tbool found_solution(const powa::pow& p, powa::challenge_ref c, powa::solution_ref s) override {\n+\t\tprintf(\"found solution\\n\");\n+\t\tsol = s;\n+\t\tfinished = true;\n+\t\treturn true;\n+\t}\n+};\n+\n+BOOST_FIXTURE_TEST_SUITE(pow_chain_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(pow_chain_tests)\n+{\n+\tpowa::fZeroStartingNonce = true;\n+\t// zero header case\n+\t{\n+\t\tpowa::challenge_ref chlg(new powa::sha256challenge(0x207fffff, 0, 0, 0));\n+\t\tpowa::cuckoo_cycle::cc_challenge_ref chlg2(new powa::cuckoo_cycle::cc_challenge());\n+\t\tchlg2->params.resize(80);\n+\t\tmemset(&chlg2->params[0], 0, 80);\n+\t\tpowa::solution_ref sol(new powa::solution());\n+\t\tsol->params.resize(4 * 43);\n+\t\tmemset(&sol->params[0], 0, 4 * 43);\n+\t\tcollector_chain* coll = new collector_chain(sol);\n+\t\tpowa::callback_ref collref(coll);\n+\t\tpowa::pow_ref alg(new powa::sha256(chlg));\n+\t\tpowa::pow_ref alg2(new powa::cuckoo_cycle::cuckoo_cycle(chlg2));\n+\t\tpowa::powchain chain;\n+\t\tchain.add_pow(alg);\n+\t\tchain.add_pow(alg2);\n+\t\tchain.cb = collref;\n+\t\t// the zero bit solution should not solve the zero header challenge\n+\t\tBOOST_CHECK(!chain.is_valid(*coll->sol));\n+\t\t// now solve the challenge; it should be solved within 5 attempts\n+\t\tchain.solve(0, false, 200);\n+\t\t// we should have solved the challenge\n+\t\tBOOST_CHECK(coll->finished == true);\n+\t\t// the solution should now solve the challenge\n+\t\tBOOST_CHECK(chain.is_valid(*coll->sol));\n+\t\tprintf(\"done zero header case\\n\");\n+\t}\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "dd06cd710e416d0576a899c9745ce290aa6907e9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZDA2Y2Q3MTBlNDE2ZDA1NzZhODk5Yzk3NDVjZTI5MGFhNjkwN2U5",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-04-11T09:50:39Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-14T06:45:35Z"
      },
      "message": "Modified base cuckoo cycle implementation for Bitcoin.\n\nMakes use of e.g. CSHA256 instead of openssl, as well as numerous fixes and clean ups of unused stuff.\n\nNote: Still using a built-in siphash instead of the available one, which should probably be addressed.",
      "tree": {
        "sha": "0ea77f87c728205a7dd525e514bdc1dcbcc0524d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ea77f87c728205a7dd525e514bdc1dcbcc0524d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd06cd710e416d0576a899c9745ce290aa6907e9",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAllA248ACgkQV692LbM1\nMyJKEg//UT0HL4CKHWO+0ySa4duSBDIwn0oCC/m6gBEpr93IBviC0EcPuWItOdKr\nwT2Cc/5/ZBNi1Y3jXsxeygIh0FZI1wwmAJXOHtOtRz4Q0WYx+e4pDSwLdFsAhbcM\nZHA6lGBaDSDXswuHnwlhCB45j8k2rilR6okdoKXLKJQNJsUFrRvWbyzYOB+70f/m\ncenkJdZwE1IZRzL5+qNAP5C2eiVuz6o8mYnQIFkvqIAH1TH04tqlZQXWfS6TlzbX\nlOkd+nTsrb0pPUC5Vhv53Rv9NHO0urqsnze55XLNNoWomfaO0a2YnBMNbsLWVZoK\n94FuRADPV32Zggrq896WO1eQKC0LdlCddr8O0tPGFV2E6hbn/SRq0PmEK26LGxIF\nWzYTCBVrPCea3RkQWtqXdVxOe7xNBIUlvfrEPwpRUm5L8LpvCNhRVDmT1EvC+vjy\nt1UEBDBBfqV72ZsZlsabUfSz94vrea2UDt/A6MYFQORv5w81kSZ5cM/1TqeGpnXp\np4et6PhII14nsNIwLW1SaQJ01NSeWwbm/nKNlS6yLVrhGjIRJn9pjHUu79ydXI8/\nkbAlkVmaljf8eUeWF7WsUGOAU0ng5ZJND0FB32YGkuQG2Fg/y57p6WE+YSfQgb71\nMq08pcytwvc2EYiJmNumdbdbxVyl+WqZhX3/fh90UpQRoHmQ+Gc=\n=vBWd\n-----END PGP SIGNATURE-----",
        "payload": "tree 0ea77f87c728205a7dd525e514bdc1dcbcc0524d\nparent d0e402b1ff1a49475dd9a9030bfca42f43db56dd\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1491904239 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1497422735 +0900\n\nModified base cuckoo cycle implementation for Bitcoin.\n\nMakes use of e.g. CSHA256 instead of openssl, as well as numerous fixes and clean ups of unused stuff.\n\nNote: Still using a built-in siphash instead of the available one, which should probably be addressed.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd06cd710e416d0576a899c9745ce290aa6907e9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dd06cd710e416d0576a899c9745ce290aa6907e9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd06cd710e416d0576a899c9745ce290aa6907e9/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0e402b1ff1a49475dd9a9030bfca42f43db56dd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0e402b1ff1a49475dd9a9030bfca42f43db56dd"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 67,
      "deletions": 57
    },
    "files": [
      {
        "sha": "0ba5fcc2e98985c0011c25623dc2f21e5eaeaaff",
        "filename": "src/pow/cuckoo_cycle/cuckoo.h",
        "status": "modified",
        "additions": 37,
        "deletions": 29,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/cuckoo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/cuckoo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/cuckoo.h?ref=dd06cd710e416d0576a899c9745ce290aa6907e9",
        "patch": "@@ -7,14 +7,10 @@\n #include <stdint.h> // for types uint32_t,uint64_t\n #include <string.h> // for functions strlen, memset\n #include \"siphash.h\"\n-// both cuckoo.c and cuckoo_miner.h need htole32\n+#include \"compat/endian.h\"\n+\n #ifdef __APPLE__\n #include \"osx_barrier.h\"\n-#include <machine/endian.h>\n-#include <libkern/OSByteOrder.h>\n-#define htole32(x) OSSwapHostToLittleInt32(x)\n-#else\n-#include <endian.h>\n #endif\n \n namespace powa {\n@@ -25,12 +21,7 @@ namespace cuckoo_cycle {\n #ifndef SIZESHIFT\n // the main parameter is the 2log of the graph size,\n // which is the size in bits of the node identifiers\n-#define SIZESHIFT 20\n-#endif\n-#ifndef PROOFSIZE\n-// the next most important parameter is (even) length\n-// of the cycle to be found. a minimum of 12 is recommended\n-#define PROOFSIZE 42\n+#define SIZESHIFT 28\n #endif\n \n // the graph size / number of nodes\n@@ -41,49 +32,66 @@ static const u64 HALFSIZE = SIZE/2;\n static const u64 NODEMASK = HALFSIZE-1;\n \n // generate edge endpoint in cuckoo graph without partition bit\n-u64 _sipnode(siphash_keys *keys, u64 nonce, u32 uorv) {\n+inline u64 _sipnode(siphash_keys *keys, u64 nonce, u32 uorv) {\n   return siphash24(keys, 2*nonce + uorv) & NODEMASK;\n }\n \n // generate edge endpoint in cuckoo graph\n-u64 sipnode(siphash_keys *keys, u64 nonce, u32 uorv) {\n+inline u64 sipnode(siphash_keys *keys, u64 nonce, u32 uorv) {\n   return _sipnode(keys, nonce, uorv) << 1 | uorv;\n }\n \n enum verify_code { POW_OK, POW_HEADER_LENGTH, POW_TOO_BIG, POW_TOO_SMALL, POW_NON_MATCHING, POW_BRANCH, POW_DEAD_END, POW_SHORT_CYCLE};\n-const char *errstr[] = { \"OK\", \"wrong header length\", \"proof too big\", \"proof too small\", \"endpoints don't match up\", \"branch in cycle\", \"cycle dead ends\", \"cycle too short\"};\n+static const char *errstr[] = { \"OK\", \"wrong header length\", \"proof too big\", \"proof too small\", \"endpoints don't match up\", \"branch in cycle\", \"cycle dead ends\", \"cycle too short\"};\n \n // verify that nonces are ascending and form a cycle in header-generated graph\n-int verify(u32 nonces[PROOFSIZE], const char *headernonce, const u32 headerlen) {\n+inline int verify(u32* nonces, const char *headernonce, const u32 headerlen, const uint16_t proofsize) {\n   if (headerlen != HEADERLEN)\n     return POW_HEADER_LENGTH;\n   siphash_keys keys;\n   setheader(&keys, headernonce);\n-  u32 uvs[2*PROOFSIZE];\n+  u32* uvs = new u32[2*proofsize];\n   u32 xor0=0,xor1=0;\n-  for (u32 n = 0; n < PROOFSIZE; n++) {\n-    if (nonces[n] >= HALFSIZE)\n-      return POW_TOO_BIG;\n-    if (n && nonces[n] <= nonces[n-1])\n-      return POW_TOO_SMALL;\n-    xor0 ^= uvs[2*n  ] = sipnode(&keys, nonces[n], 0);\n-    xor1 ^= uvs[2*n+1] = sipnode(&keys, nonces[n], 1);\n+  int err = POW_OK;\n+  for (u32 n = 0; err == POW_OK && n < proofsize; n++) {\n+    if (nonces[n] >= HALFSIZE) {\n+      err = POW_TOO_BIG;\n+    } else if (n && nonces[n] <= nonces[n-1]) {\n+      err = POW_TOO_SMALL;\n+    } else {\n+      xor0 ^= uvs[2*n  ] = sipnode(&keys, nonces[n], 0);\n+      xor1 ^= uvs[2*n+1] = sipnode(&keys, nonces[n], 1);\n+    }\n   }\n-  if (xor0|xor1)                        // matching endpoints imply zero xors\n+  if (err != POW_OK) {\n+    delete [] uvs;\n+    return err;\n+  }\n+  if (xor0|xor1) {                      // matching endpoints imply zero xors\n+    delete [] uvs;\n     return POW_NON_MATCHING;\n+  }\n   u32 n = 0, i = 0, j;\n   do {                        // follow cycle\n-    for (u32 k = j = i; (k = (k+2) % (2*PROOFSIZE)) != i; ) {\n+    for (u32 k = j = i; (k = (k+2) % (2*proofsize)) != i; ) {\n       if (uvs[k] == uvs[i]) { // find other edge endpoint identical to one at i\n-        if (j != i)           // already found one before\n+        if (j != i) {          // already found one before\n+          delete [] uvs;\n           return POW_BRANCH;\n+        }\n         j = k;\n       }\n-    } if (j == i) return POW_DEAD_END;  // no matching endpoint\n+    }\n+    if (j == i) {\n+      // no matching endpoint\n+      delete [] uvs;\n+      return POW_DEAD_END;\n+    }\n     i = j^1;\n     n++;\n   } while (i != 0);           // must cycle back to start or we would have found branch\n-  return n == PROOFSIZE ? POW_OK : POW_SHORT_CYCLE;\n+  delete [] uvs;\n+  return n == proofsize ? POW_OK : POW_SHORT_CYCLE;\n }\n \n }  // namespace cuckoo_cycle"
      },
      {
        "sha": "045250a5a93db4bf1a201379800df83d5d663ef5",
        "filename": "src/pow/cuckoo_cycle/cuckoo_miner.h",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/cuckoo_miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/cuckoo_miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/cuckoo_miner.h?ref=dd06cd710e416d0576a899c9745ce290aa6907e9",
        "patch": "@@ -225,22 +225,27 @@ class cuckoo_ctx {\n   shrinkingset *alive;\n   twice_set *nonleaf;\n   cuckoo_hash *cuckoo;\n-  nonce_t (*sols)[PROOFSIZE];\n+  nonce_t **sols;\n   u32 maxsols;\n   au32 nsols;\n   u32 nthreads;\n   u32 ntrims;\n+  uint16_t proofsize_min;\n+  uint16_t proofsize_max;\n   pthread_barrier_t barry;\n \n-  cuckoo_ctx(u32 n_threads, u32 n_trims, u32 max_sols) {\n+  cuckoo_ctx(u32 n_threads, u32 n_trims, u32 max_sols, uint16_t proofsize_min_in, uint16_t proofsize_max_in) {\n+    proofsize_min = proofsize_min_in;\n+    proofsize_max = proofsize_max_in;\n     nthreads = n_threads;\n     alive = new shrinkingset(nthreads);\n     cuckoo = 0;\n     nonleaf = new twice_set;\n     ntrims = n_trims;\n     int err = pthread_barrier_init(&barry, NULL, nthreads);\n     assert(err == 0);\n-    sols = (nonce_t (*)[PROOFSIZE])calloc(maxsols = max_sols, PROOFSIZE*sizeof(nonce_t));\n+    sols = (nonce_t**)calloc(maxsols = max_sols, sizeof(nonce_t*));\n+    for (u32 i = 0; i < max_sols; i++) sols[i] = (nonce_t*)calloc(proofsize_max + 1, sizeof(nonce_t));\n     assert(sols != 0);\n     nsols = 0;\n   }\n@@ -254,6 +259,8 @@ class cuckoo_ctx {\n     delete alive;\n     delete nonleaf;\n     delete cuckoo;\n+    for (u32 i = 0; i < maxsols; i++) free(sols[i]);\n+    free(sols);\n   }\n   void prefetch(const u64 *hashes, const u32 part) const {\n     for (u32 i=0; i < NSIPHASH; i++) {\n@@ -336,7 +343,7 @@ class cuckoo_ctx {\n     const u32 nnsip = pnsip + NSIPHASH;\n     kill(hashes+nnsip, indices+nnsip, NPREFETCH-nnsip, part, id);\n   }\n-  void solution(node_t *us, u32 nu, node_t *vs, u32 nv) {\n+  void solution(node_t *us, u32 nu, node_t *vs, u32 nv, uint16_t proofsize) {\n     typedef std::pair<node_t,node_t> edge;\n     std::set<edge> cycle;\n     u32 n = 0;\n@@ -359,15 +366,16 @@ class cuckoo_ctx {\n         if (cycle.find(e) != cycle.end()) {\n           sols[soli][n++] = nonce;\n   #ifdef SHOWSOL\n-          printf(\"e(%x)=(%x,%x)%c\", nonce, e.first, e.second, n==PROOFSIZE?'\\n':' ');\n+          printf(\"e(%x)=(%x,%x)%c\", nonce, e.first, e.second, n == proofsize?'\\n':' ');\n   #endif\n-          if (PROOFSIZE > 2)\n+          if (proofsize_min > 2)\n             cycle.erase(e);\n         }\n         if (ffs & 64) break; // can't shift by 64\n       }\n     }\n-    assert(n==PROOFSIZE);\n+    assert(n == proofsize);\n+    sols[soli][proofsize_max] = n; // store actual proofsize as last entry in solution\n   }\n };\n \n@@ -377,15 +385,15 @@ typedef struct {\n   cuckoo_ctx *ctx;\n } thread_ctx;\n \n-void barrier(pthread_barrier_t *barry) {\n+inline void barrier(pthread_barrier_t *barry) {\n   int rc = pthread_barrier_wait(barry);\n   if (rc != 0 && rc != PTHREAD_BARRIER_SERIAL_THREAD) {\n     printf(\"Could not wait on barrier\\n\");\n     pthread_exit(NULL);\n   }\n }\n \n-u32 path(cuckoo_hash &cuckoo, node_t u, node_t *us) {\n+inline u32 path(cuckoo_hash &cuckoo, node_t u, node_t *us) {\n   u32 nu;\n   for (nu = 0; u; u = cuckoo[u]) {\n     if (nu >= MAXCCPATHLEN) {\n@@ -400,7 +408,7 @@ u32 path(cuckoo_hash &cuckoo, node_t u, node_t *us) {\n   return nu-1;\n }\n \n-void *worker(void *vp) {\n+inline void *worker(void *vp) {\n   thread_ctx *tp = (thread_ctx *)vp;\n   cuckoo_ctx *ctx = tp->ctx;\n \n@@ -460,8 +468,8 @@ void *worker(void *vp) {\n           for (nu -= min, nv -= min; us[nu] != vs[nv]; nu++, nv++) ;\n           u32 len = nu + nv + 1;\n           // printf(\"%4d-cycle found at %d:%d%%\\n\", len, tp->id, (u32)(nonce*100LL/HALFSIZE));\n-          if (len == PROOFSIZE && ctx->nsols < ctx->maxsols)\n-            ctx->solution(us, nu, vs, nv);\n+          if (len >= ctx->proofsize_min && len <= ctx->proofsize_max && ctx->nsols < ctx->maxsols)\n+            ctx->solution(us, nu, vs, nv, len);\n         } else if (nu < nv) {\n           while (nu--)\n             cuckoo.set(us[nu+1], us[nu]);"
      },
      {
        "sha": "d14506713c17e964fb822d620f278102d5e1b546",
        "filename": "src/pow/cuckoo_cycle/osx_barrier.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/osx_barrier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/osx_barrier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/osx_barrier.h?ref=dd06cd710e416d0576a899c9745ce290aa6907e9",
        "patch": "@@ -25,7 +25,7 @@ typedef struct\n } pthread_barrier_t;\n \n \n-int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)\n+inline int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)\n {\n     if(count == 0)\n     {\n@@ -47,14 +47,14 @@ int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t\n     return 0;\n }\n \n-int pthread_barrier_destroy(pthread_barrier_t *barrier)\n+inline int pthread_barrier_destroy(pthread_barrier_t *barrier)\n {\n     pthread_cond_destroy(&barrier->cond);\n     pthread_mutex_destroy(&barrier->mutex);\n     return 0;\n }\n \n-int pthread_barrier_wait(pthread_barrier_t *barrier)\n+inline int pthread_barrier_wait(pthread_barrier_t *barrier)\n {\n     pthread_mutex_lock(&barrier->mutex);\n     ++(barrier->count);"
      },
      {
        "sha": "d8510136a7beea0cf0a38fc58c1f08e01102ca0a",
        "filename": "src/pow/cuckoo_cycle/siphash.h",
        "status": "modified",
        "additions": 7,
        "deletions": 13,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/siphash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd06cd710e416d0576a899c9745ce290aa6907e9/src/pow/cuckoo_cycle/siphash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow/cuckoo_cycle/siphash.h?ref=dd06cd710e416d0576a899c9745ce290aa6907e9",
        "patch": "@@ -1,8 +1,7 @@\n-#ifndef INCLUDE_SIPHASH_H\n-#define INCLUDE_SIPHASH_H\n+#ifndef BITCOIN_POW_CUCKOO_CYCLE_SIPHASH_H\n+#define BITCOIN_POW_CUCKOO_CYCLE_SIPHASH_H\n #include <stdint.h> // for types uint32_t,uint64_t\n-#include <openssl/sha.h> // if openssl absent, use #include \"sha256.c\"\n-#include <immintrin.h>\n+#include \"hash.h\"\n \n namespace powa {\n \n@@ -30,16 +29,11 @@ typedef struct {\n    ((u64)((p)[6]) << 48) | ((u64)((p)[7]) << 56))\n \n #ifndef SHA256\n-#define SHA256(d, n, md) do { \\\n-    SHA256_CTX c; \\\n-    SHA256_Init(&c); \\\n-    SHA256_Update(&c, d, n); \\\n-    SHA256_Final(md, &c); \\\n-  } while (0)\n+#define SHA256(d, n, md) CSHA256().Write(d, n).Finalize(md)\n #endif\n \n // derive siphash key from fixed length header\n-void setheader(siphash_keys *keys, const char *header) {\n+inline void setheader(siphash_keys *keys, const char *header) {\n   unsigned char hdrkey[32];\n   SHA256((unsigned char *)header, HEADERLEN, hdrkey);\n   keys->k0 = U8TO64_LE(hdrkey);\n@@ -57,7 +51,7 @@ void setheader(siphash_keys *keys, const char *header) {\n   } while(0)\n \n // SipHash-2-4 specialized to precomputed key and 8 byte nonces\n-u64 siphash24(const siphash_keys *keys, const u64 nonce) {\n+inline u64 siphash24(const siphash_keys *keys, const u64 nonce) {\n   u64 v0 = keys->k0 ^ 0x736f6d6570736575ULL, v1 = keys->k1 ^ 0x646f72616e646f6dULL,\n       v2 = keys->k0 ^ 0x6c7967656e657261ULL, v3 = keys->k1 ^ 0x7465646279746573ULL ^ nonce;\n   SIPROUND; SIPROUND;\n@@ -77,4 +71,4 @@ inline void siphash24xN(const siphash_keys *keys, const u64 *indices, u64 * hash\n \n }  // namespace powa\n \n-#endif // ifdef INCLUDE_SIPHASH_H\n+#endif // BITCOIN_POW_CUCKOO_CYCLE_SIPHASH_H"
      }
    ]
  },
  {
    "sha": "b98fd4d81437ceb1ecda1058b0b6bd4f89f70807",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOThmZDRkODE0MzdjZWIxZWNkYTEwNThiMGI2YmQ0Zjg5ZjcwODA3",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-05-01T06:00:14Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-06-14T06:45:35Z"
      },
      "message": "[doc] Add -powconnectionslots to help.",
      "tree": {
        "sha": "0e50d3bcd73a61a58a0071cdb8aaa6d2fd68f2a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e50d3bcd73a61a58a0071cdb8aaa6d2fd68f2a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAllA248ACgkQV692LbM1\nMyKTAA//WCYCt0stXNGp3CfQs/Wm+NQQhARODB/34/zocJeyv/q9s9MhHL+Rf+eN\nhjKpKwkhMHacI3esJTiS9iNBk6wcMcUGyRZbNpXI90ln5IkNPH9cexjBHMnVMqrJ\nNrydIxstlhskI1d5RfNCgQLDslnfEjhLP9v4oQECAgw0qsKgevwDibSb9UIX1Ria\ndUv0gr+ojLwL6yLeaiKAEnORyaunPAaxeGJA4qO2HXeY8pghElBqfaR6lja5BSro\nKRrIsh3rjp69v5O+R/rtTIkKpj+831VVzcTcNynssVYhOYQTDeIvr3DbXIkxO/7S\nA1EytFeqlhzf+d9PPcaJiJCC2/8OyEeCjZQzia9Qzx00pZt8MLFt904T55dMzrsY\nOa1QpmXnyywHxlNLdaP5lB312Bb0Jt5e6uxVf+UxnPANbhG3IB9xdQ5mH/e0alKN\nWMwHxJmSyqQK0d1ODdt+yreXv2mjW79k6NHjiAjjAsyICoey6P71i5Q5o0FsFxVB\nmTG9XtMOKIY6FtIBy8mClhi/9smWrn45YDUOZf2wQ63+elJQTFwAuFzXJwTHbOFH\nQQ/bHwr1vLEzH3aSWE0Mv0v4PLyfHfwdRNifrqsLL8qNt61DVp9FDrwYJCgdZxuB\nGpzLSjtE849Mfupo0mMfOteaezKaOZXEr5OMJxbC6+CO8cE7z18=\n=EZSj\n-----END PGP SIGNATURE-----",
        "payload": "tree 0e50d3bcd73a61a58a0071cdb8aaa6d2fd68f2a7\nparent dd06cd710e416d0576a899c9745ce290aa6907e9\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1493618414 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1497422735 +0900\n\n[doc] Add -powconnectionslots to help.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dd06cd710e416d0576a899c9745ce290aa6907e9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd06cd710e416d0576a899c9745ce290aa6907e9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dd06cd710e416d0576a899c9745ce290aa6907e9"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f9acf6ffaae3d987b31f7c72ebc96e07da0b430a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b98fd4d81437ceb1ecda1058b0b6bd4f89f70807",
        "patch": "@@ -391,6 +391,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n     strUsage += HelpMessageOpt(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION));\n     strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS));\n+    strUsage += HelpMessageOpt(\"-powconnectionslots=<n>\", strprintf(_(\"Reserve <n> slots for proof of work challenged peers (default: %u)\"), DEFAULT_POW_CONNECTION_SLOTS));\n     strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXRECEIVEBUFFER));\n     strUsage += HelpMessageOpt(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXSENDBUFFER));\n     strUsage += HelpMessageOpt(\"-maxtimeadjustment\", strprintf(_(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\"), DEFAULT_MAX_TIME_ADJUSTMENT));"
      },
      {
        "sha": "03d999562bec6d3a5aefb0ee5abfe528d410d602",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b98fd4d81437ceb1ecda1058b0b6bd4f89f70807/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=b98fd4d81437ceb1ecda1058b0b6bd4f89f70807",
        "patch": "@@ -310,6 +310,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Location of the auth cookie (default: data di\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maintain at most <n> connections to peers (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Make the wallet broadcast transactions\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Reserve <n> slots for proof of work challenged peers (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Need to specify a port with -whitebind: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Node relay options:\"),"
      }
    ]
  }
]