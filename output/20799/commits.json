[
  {
    "sha": "9071a7e728083d88caf9d7394082d374764795e2",
    "node_id": "C_kwDOABII59oAKDkwNzFhN2U3MjgwODNkODhjYWY5ZDczOTQwODJkMzc0NzY0Nzk1ZTI",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T14:29:52Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:06:14Z"
      },
      "message": "[net] Stop testing version 1 compact blocks.\n\nSupport for version 1 is removed in the following commits.",
      "tree": {
        "sha": "ec9e9e3734aeae83c2bf2763c2d1249c4c43542b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec9e9e3734aeae83c2bf2763c2d1249c4c43542b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9071a7e728083d88caf9d7394082d374764795e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9071a7e728083d88caf9d7394082d374764795e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9071a7e728083d88caf9d7394082d374764795e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9071a7e728083d88caf9d7394082d374764795e2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24abd8312ec1caa04f9b3bd92cd960e28ca91e17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24abd8312ec1caa04f9b3bd92cd960e28ca91e17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24abd8312ec1caa04f9b3bd92cd960e28ca91e17"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 45,
      "deletions": 100
    },
    "files": [
      {
        "sha": "70d95b24ce78f4a535c2ab2c4126dce96992eea2",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 45,
        "deletions": 100,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9071a7e728083d88caf9d7394082d374764795e2/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9071a7e728083d88caf9d7394082d374764795e2/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=9071a7e728083d88caf9d7394082d374764795e2",
        "patch": "@@ -2,11 +2,7 @@\n # Copyright (c) 2016-2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test compact blocks (BIP 152).\n-\n-Version 1 compact blocks are pre-segwit (txids)\n-Version 2 compact blocks are post-segwit (wtxids)\n-\"\"\"\n+\"\"\"Test compact blocks (BIP 152).\"\"\"\n import random\n \n from test_framework.blocktools import (\n@@ -31,7 +27,6 @@\n     MSG_BLOCK,\n     MSG_CMPCT_BLOCK,\n     MSG_WITNESS_FLAG,\n-    NODE_NETWORK,\n     P2PHeaderAndShortIDs,\n     PrefilledTransaction,\n     calculate_shortid,\n@@ -68,15 +63,14 @@\n \n # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n class TestP2PConn(P2PInterface):\n-    def __init__(self, cmpct_version):\n+    def __init__(self):\n         super().__init__()\n         self.last_sendcmpct = []\n         self.block_announced = False\n         # Store the hashes of blocks we've seen announced.\n         # This is for synchronizing the p2p message traffic,\n         # so we can eg wait until a particular block is announced.\n         self.announced_blockhashes = set()\n-        self.cmpct_version = cmpct_version\n \n     def on_sendcmpct(self, message):\n         self.last_sendcmpct.append(message)\n@@ -186,24 +180,21 @@ def make_utxos(self):\n \n     # Test \"sendcmpct\" (between peers preferring the same version):\n     # - No compact block announcements unless sendcmpct is sent.\n-    # - If sendcmpct is sent with version > preferred_version, the message is ignored.\n+    # - If sendcmpct is sent with version > 2, the message is ignored.\n     # - If sendcmpct is sent with boolean 0, then block announcements are not\n     #   made with compact blocks.\n     # - If sendcmpct is then sent with boolean 1, then new block announcements\n     #   are made with compact blocks.\n-    # If old_node is passed in, request compact blocks with version=preferred-1\n-    # and verify that it receives block announcements via compact block.\n-    def test_sendcmpct(self, test_node, old_node=None):\n-        preferred_version = test_node.cmpct_version\n+    def test_sendcmpct(self, test_node):\n         node = self.nodes[0]\n \n         # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n             return (len(test_node.last_sendcmpct) > 0)\n         test_node.wait_until(received_sendcmpct, timeout=30)\n         with p2p_lock:\n-            # Check that the first version received is the preferred one\n-            assert_equal(test_node.last_sendcmpct[0].version, preferred_version)\n+            # Check that the first version received is version 2\n+            assert_equal(test_node.last_sendcmpct[0].version, 2)\n             # And that we receive versions down to 1.\n             assert_equal(test_node.last_sendcmpct[-1].version, 1)\n             test_node.last_sendcmpct = []\n@@ -234,21 +225,21 @@ def check_announcement_of_new_block(node, peer, predicate):\n         test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with too-high version\n-        test_node.send_and_ping(msg_sendcmpct(announce=True, version=preferred_version+1))\n+        test_node.send_and_ping(msg_sendcmpct(announce=True, version=3))\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Headers sync before next test.\n         test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with valid version, but announce=False\n-        test_node.send_and_ping(msg_sendcmpct(announce=False, version=preferred_version))\n+        test_node.send_and_ping(msg_sendcmpct(announce=False, version=2))\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n \n         # Headers sync before next test.\n         test_node.request_headers_and_sync(locator=[tip])\n \n         # Finally, try a SENDCMPCT message with announce=True\n-        test_node.send_and_ping(msg_sendcmpct(announce=True, version=preferred_version))\n+        test_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time (no headers sync should be needed!)\n@@ -258,22 +249,14 @@ def check_announcement_of_new_block(node, peer, predicate):\n         test_node.send_and_ping(msg_sendheaders())\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n-        # Try one more time, after sending a version-1, announce=false message.\n-        test_node.send_and_ping(msg_sendcmpct(announce=False, version=preferred_version-1))\n+        # Try one more time, after sending a version=1, announce=false message.\n+        test_node.send_and_ping(msg_sendcmpct(announce=False, version=1))\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Now turn off announcements\n-        test_node.send_and_ping(msg_sendcmpct(announce=False, version=preferred_version))\n+        test_node.send_and_ping(msg_sendcmpct(announce=False, version=2))\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message and \"headers\" in p.last_message)\n \n-        if old_node is not None:\n-            # Verify that a peer using an older protocol version can receive\n-            # announcements from this node.\n-            old_node.send_and_ping(msg_sendcmpct(announce=True, version=preferred_version-1))\n-            # Header sync\n-            old_node.request_headers_and_sync(locator=[tip])\n-            check_announcement_of_new_block(node, old_node, lambda p: \"cmpctblock\" in p.last_message)\n-\n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n         self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n@@ -290,8 +273,7 @@ def test_invalid_cmpctblock_message(self):\n \n     # Compare the generated shortids to what we expect based on BIP 152, given\n     # bitcoind's choice of nonce.\n-    def test_compactblock_construction(self, test_node, use_witness_address=True):\n-        version = test_node.cmpct_version\n+    def test_compactblock_construction(self, test_node):\n         node = self.nodes[0]\n         # Generate a bunch of transactions.\n         self.generate(node, COINBASE_MATURITY + 1)\n@@ -306,8 +288,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n             if not tx.wit.is_null():\n                 segwit_tx_generated = True\n \n-        if use_witness_address:\n-            assert segwit_tx_generated  # check that our test is not broken\n+        assert segwit_tx_generated  # check that our test is not broken\n \n         # Wait until we've seen the block announcement for the resulting tip\n         tip = int(node.getbestblockhash(), 16)\n@@ -334,7 +315,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         with p2p_lock:\n             # Convert the on-the-wire representation to absolute indexes\n             header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n-        self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n+        self.check_compactblock_construction_from_block(header_and_shortids, block_hash, block)\n \n         # Now fetch the compact block using a normal non-announce getdata\n         test_node.clear_block_announcement()\n@@ -348,9 +329,9 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         with p2p_lock:\n             # Convert the on-the-wire representation to absolute indexes\n             header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n-        self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n+        self.check_compactblock_construction_from_block(header_and_shortids, block_hash, block)\n \n-    def check_compactblock_construction_from_block(self, version, header_and_shortids, block_hash, block):\n+    def check_compactblock_construction_from_block(self, header_and_shortids, block_hash, block):\n         # Check that we got the right block!\n         header_and_shortids.header.calc_sha256()\n         assert_equal(header_and_shortids.header.sha256, block_hash)\n@@ -367,11 +348,7 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n \n             # And this checks the witness\n             wtxid = entry.tx.calc_sha256(True)\n-            if version == 2:\n-                assert_equal(wtxid, block.vtx[entry.index].calc_sha256(True))\n-            else:\n-                # Shouldn't have received a witness\n-                assert entry.tx.wit.is_null()\n+            assert_equal(wtxid, block.vtx[entry.index].calc_sha256(True))\n \n         # Check that the cmpctblock message announced all the transactions.\n         assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n@@ -387,9 +364,7 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n                 # Already checked prefilled transactions above\n                 header_and_shortids.prefilled_txn.pop(0)\n             else:\n-                tx_hash = block.vtx[index].sha256\n-                if version == 2:\n-                    tx_hash = block.vtx[index].calc_sha256(True)\n+                tx_hash = block.vtx[index].calc_sha256(True)\n                 shortid = calculate_shortid(k0, k1, tx_hash)\n                 assert_equal(shortid, header_and_shortids.shortids[0])\n                 header_and_shortids.shortids.pop(0)\n@@ -398,16 +373,12 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n     # Test that bitcoind requests compact blocks when we announce new blocks\n     # via header or inv, and that responding to getblocktxn causes the block\n     # to be successfully reconstructed.\n-    # Post-segwit: upgraded nodes would only make this request of cb-version-2,\n-    # NODE_WITNESS peers.  Unupgraded nodes would still make this request of\n-    # any cb-version-1-supporting peer.\n-    def test_compactblock_requests(self, test_node, segwit=True):\n-        version = test_node.cmpct_version\n+    def test_compactblock_requests(self, test_node):\n         node = self.nodes[0]\n         # Try announcing a block with an inv or header, expect a compactblock\n         # request\n         for announce in [\"inv\", \"header\"]:\n-            block = self.build_block_on_tip(node, segwit=segwit)\n+            block = self.build_block_on_tip(node, segwit=True)\n \n             if announce == \"inv\":\n                 test_node.send_message(msg_inv([CInv(MSG_BLOCK, block.sha256)]))\n@@ -423,9 +394,7 @@ def test_compactblock_requests(self, test_node, segwit=True):\n             comp_block.header = CBlockHeader(block)\n             comp_block.nonce = 0\n             [k0, k1] = comp_block.get_siphash_keys()\n-            coinbase_hash = block.vtx[0].sha256\n-            if version == 2:\n-                coinbase_hash = block.vtx[0].calc_sha256(True)\n+            coinbase_hash = block.vtx[0].calc_sha256(True)\n             comp_block.shortids = [calculate_shortid(k0, k1, coinbase_hash)]\n             test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n@@ -436,10 +405,7 @@ def test_compactblock_requests(self, test_node, segwit=True):\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n             # Send the coinbase, and verify that the tip advances.\n-            if version == 2:\n-                msg = msg_blocktxn()\n-            else:\n-                msg = msg_no_witness_blocktxn()\n+            msg = msg_blocktxn()\n             msg.block_transactions.blockhash = block.sha256\n             msg.block_transactions.transactions = [block.vtx[0]]\n             test_node.send_and_ping(msg)\n@@ -465,9 +431,7 @@ def build_block_with_transactions(self, node, utxo, num_transactions):\n     # node needs, and that responding to them causes the block to be\n     # reconstructed.\n     def test_getblocktxn_requests(self, test_node):\n-        version = test_node.cmpct_version\n         node = self.nodes[0]\n-        with_witness = (version == 2)\n \n         def test_getblocktxn_response(compact_block, peer, expected_result):\n             msg = msg_cmpctblock(compact_block.to_p2p())\n@@ -488,13 +452,12 @@ def test_tip_after_message(node, peer, msg, tip):\n         block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block, use_witness=with_witness)\n+        comp_block.initialize_from_block(block, use_witness=True)\n \n         test_getblocktxn_response(comp_block, test_node, [1, 2, 3, 4, 5])\n \n         msg_bt = msg_no_witness_blocktxn()\n-        if with_witness:\n-            msg_bt = msg_blocktxn()  # serialize with witnesses\n+        msg_bt = msg_blocktxn()  # serialize with witnesses\n         msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n         test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n@@ -503,7 +466,7 @@ def test_tip_after_message(node, peer, msg, tip):\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n \n         # Now try interspersing the prefilled transactions\n-        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5], use_witness=with_witness)\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5], use_witness=True)\n         test_getblocktxn_response(comp_block, test_node, [2, 3, 4])\n         msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n         test_tip_after_message(node, test_node, msg_bt, block.sha256)\n@@ -517,7 +480,7 @@ def test_tip_after_message(node, peer, msg, tip):\n \n         # Prefill 4 out of the 6 transactions, and verify that only the one\n         # that was not in the mempool is requested.\n-        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4], use_witness=with_witness)\n+        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4], use_witness=True)\n         test_getblocktxn_response(comp_block, test_node, [5])\n \n         msg_bt.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n@@ -541,7 +504,7 @@ def test_tip_after_message(node, peer, msg, tip):\n             test_node.last_message.pop(\"getblocktxn\", None)\n \n         # Send compact block\n-        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=with_witness)\n+        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=True)\n         test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)\n         with p2p_lock:\n             # Shouldn't have gotten a request for any transaction\n@@ -550,7 +513,6 @@ def test_tip_after_message(node, peer, msg, tip):\n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n     def test_incorrect_blocktxn_response(self, test_node):\n-        version = test_node.cmpct_version\n         node = self.nodes[0]\n         utxo = self.utxos.pop(0)\n \n@@ -567,7 +529,7 @@ def test_incorrect_blocktxn_response(self, test_node):\n \n         # Send compact block\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=(version == 2))\n+        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=True)\n         test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n         absolute_indexes = []\n         with p2p_lock:\n@@ -583,9 +545,7 @@ def test_incorrect_blocktxn_response(self, test_node):\n         # different peer provide the block further down, so that we're still\n         # verifying that the block isn't marked bad permanently. This is good\n         # enough for now.\n-        msg = msg_no_witness_blocktxn()\n-        if version == 2:\n-            msg = msg_blocktxn()\n+        msg = msg_blocktxn()\n         msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n         test_node.send_and_ping(msg)\n \n@@ -598,14 +558,10 @@ def test_incorrect_blocktxn_response(self, test_node):\n                test_node.last_message[\"getdata\"].inv[0].type == MSG_BLOCK | MSG_WITNESS_FLAG\n \n         # Deliver the block\n-        if version == 2:\n-            test_node.send_and_ping(msg_block(block))\n-        else:\n-            test_node.send_and_ping(msg_no_witness_block(block))\n+        test_node.send_and_ping(msg_block(block))\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n     def test_getblocktxn_handler(self, test_node):\n-        version = test_node.cmpct_version\n         node = self.nodes[0]\n         # bitcoind will not send blocktxn responses for blocks whose height is\n         # more than 10 blocks deep.\n@@ -631,12 +587,8 @@ def test_getblocktxn_handler(self, test_node):\n                     tx = test_node.last_message[\"blocktxn\"].block_transactions.transactions.pop(0)\n                     tx.calc_sha256()\n                     assert_equal(tx.sha256, block.vtx[index].sha256)\n-                    if version == 1:\n-                        # Witnesses should have been stripped\n-                        assert tx.wit.is_null()\n-                    else:\n-                        # Check that the witness matches\n-                        assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n+                    # Check that the witness matches\n+                    assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n                 test_node.last_message.pop(\"blocktxn\", None)\n             current_height -= 1\n \n@@ -730,25 +682,23 @@ def test_end_to_end_block_relay(self, listeners):\n \n     # Test that we don't get disconnected if we relay a compact block with valid header,\n     # but invalid transactions.\n-    def test_invalid_tx_in_compactblock(self, test_node, use_segwit=True):\n+    def test_invalid_tx_in_compactblock(self, test_node):\n         node = self.nodes[0]\n         assert len(self.utxos)\n         utxo = self.utxos[0]\n \n         block = self.build_block_with_transactions(node, utxo, 5)\n         del block.vtx[3]\n         block.hashMerkleRoot = block.calc_merkle_root()\n-        if use_segwit:\n-            # If we're testing with segwit, also drop the coinbase witness,\n-            # but include the witness commitment.\n-            add_witness_commitment(block)\n-            block.vtx[0].wit.vtxinwit = []\n+        # Drop the coinbase witness but include the witness commitment.\n+        add_witness_commitment(block)\n+        block.vtx[0].wit.vtxinwit = []\n         block.solve()\n \n         # Now send the compact block with all transactions prefilled, and\n         # verify that we don't get disconnected.\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block, prefill_list=[0, 1, 2, 3, 4], use_witness=use_segwit)\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 2, 3, 4], use_witness=True)\n         msg = msg_cmpctblock(comp_block.to_p2p())\n         test_node.send_and_ping(msg)\n \n@@ -762,7 +712,7 @@ def request_cb_announcements(self, peer):\n         node = self.nodes[0]\n         tip = node.getbestblockhash()\n         peer.get_headers(locator=[int(tip, 16)], hashstop=0)\n-        peer.send_and_ping(msg_sendcmpct(announce=True, version=peer.cmpct_version))\n+        peer.send_and_ping(msg_sendcmpct(announce=True, version=2))\n \n     def test_compactblock_reconstruction_multiple_peers(self, stalling_peer, delivery_peer):\n         node = self.nodes[0]\n@@ -816,7 +766,7 @@ def announce_cmpct_block(node, peer):\n \n     def test_highbandwidth_mode_states_via_getpeerinfo(self):\n         # create new p2p connection for a fresh state w/o any prior sendcmpct messages sent\n-        hb_test_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))\n+        hb_test_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n \n         # assert the RPC getpeerinfo boolean fields `bip152_hb_{to, from}`\n         # match the given parameters for the last peer of a given node\n@@ -847,21 +797,19 @@ def run_test(self):\n         self.generate(self.nodes[0], 1)\n \n         # Setup the p2p connections\n-        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))\n-        self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=1), services=NODE_NETWORK)\n-        self.additional_segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.additional_segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n \n         # We will need UTXOs to construct transactions in later tests.\n         self.make_utxos()\n \n         assert softfork_active(self.nodes[0], \"segwit\")\n \n         self.log.info(\"Testing SENDCMPCT p2p message... \")\n-        self.test_sendcmpct(self.segwit_node, old_node=self.old_node)\n+        self.test_sendcmpct(self.segwit_node)\n         self.test_sendcmpct(self.additional_segwit_node)\n \n         self.log.info(\"Testing compactblock construction...\")\n-        self.test_compactblock_construction(self.old_node)\n         self.test_compactblock_construction(self.segwit_node)\n \n         self.log.info(\"Testing compactblock requests (segwit node)... \")\n@@ -872,11 +820,9 @@ def run_test(self):\n \n         self.log.info(\"Testing getblocktxn handler (segwit node should return witnesses)...\")\n         self.test_getblocktxn_handler(self.segwit_node)\n-        self.test_getblocktxn_handler(self.old_node)\n \n         self.log.info(\"Testing compactblock requests/announcements not at chain tip...\")\n         self.test_compactblocks_not_at_tip(self.segwit_node)\n-        self.test_compactblocks_not_at_tip(self.old_node)\n \n         self.log.info(\"Testing handling of incorrect blocktxn responses...\")\n         self.test_incorrect_blocktxn_response(self.segwit_node)\n@@ -889,13 +835,12 @@ def run_test(self):\n         # (Post-segwit activation, blocks won't propagate from node0 to node1\n         # automatically, so don't bother testing a block announced to node0.)\n         self.log.info(\"Testing end-to-end block relay...\")\n-        self.request_cb_announcements(self.old_node)\n         self.request_cb_announcements(self.segwit_node)\n-        self.test_end_to_end_block_relay([self.segwit_node, self.old_node])\n+        self.request_cb_announcements(self.additional_segwit_node)\n+        self.test_end_to_end_block_relay([self.segwit_node, self.additional_segwit_node])\n \n         self.log.info(\"Testing handling of invalid compact blocks...\")\n         self.test_invalid_tx_in_compactblock(self.segwit_node)\n-        self.test_invalid_tx_in_compactblock(self.old_node)\n \n         self.log.info(\"Testing invalid index in cmpctblock message...\")\n         self.test_invalid_cmpctblock_message()"
      }
    ]
  },
  {
    "sha": "8d560ed807e74b4f69411072f58802221c609823",
    "node_id": "C_kwDOABII59oAKDhkNTYwZWQ4MDdlNzRiNGY2OTQxMTA3MmY1ODgwMjIyMWM2MDk4MjM",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:09:04Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:20:05Z"
      },
      "message": "[net processing] Only advertise support for version 2 compact blocks\n\nSubsequent commits will remove support.",
      "tree": {
        "sha": "5754092982d0c04cd681849c2b074dbc11dd1400",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5754092982d0c04cd681849c2b074dbc11dd1400"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d560ed807e74b4f69411072f58802221c609823",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d560ed807e74b4f69411072f58802221c609823",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8d560ed807e74b4f69411072f58802221c609823",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d560ed807e74b4f69411072f58802221c609823/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9071a7e728083d88caf9d7394082d374764795e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9071a7e728083d88caf9d7394082d374764795e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9071a7e728083d88caf9d7394082d374764795e2"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 11,
      "deletions": 16
    },
    "files": [
      {
        "sha": "c89f3de4e29f6a2288117884ee11653bce972770",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d560ed807e74b4f69411072f58802221c609823/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d560ed807e74b4f69411072f58802221c609823/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8d560ed807e74b4f69411072f58802221c609823",
        "patch": "@@ -164,6 +164,8 @@ static constexpr double MAX_ADDR_RATE_PER_SECOND{0.1};\n  *  based increments won't go above this, but the MAX_ADDR_TO_SEND increment following GETADDR\n  *  is exempt from this limit). */\n static constexpr size_t MAX_ADDR_PROCESSING_TOKEN_BUCKET{MAX_ADDR_TO_SEND};\n+/** The compactblocks version we support. See BIP 152. */\n+static constexpr uint64_t CMPCTBLOCKS_VERSION{2};\n \n // Internal stuff\n namespace {\n@@ -921,19 +923,18 @@ void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n         }\n         m_connman.ForNode(nodeid, [this](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n             AssertLockHeld(::cs_main);\n-            uint64_t nCMPCTBLOCKVersion = 2;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n-                m_connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [this, nCMPCTBLOCKVersion](CNode* pnodeStop){\n-                    m_connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));\n+                m_connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [this](CNode* pnodeStop){\n+                    m_connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/ false, /*version=*/ CMPCTBLOCKS_VERSION));\n                     // save BIP152 bandwidth state: we select peer to be low-bandwidth\n                     pnodeStop->m_bip152_highbandwidth_to = false;\n                     return true;\n                 });\n                 lNodesAnnouncingHeaderAndIDs.pop_front();\n             }\n-            m_connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/true, nCMPCTBLOCKVersion));\n+            m_connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/ true, /*version=*/ CMPCTBLOCKS_VERSION));\n             // save BIP152 bandwidth state: we select peer to be high-bandwidth\n             pfrom->m_bip152_highbandwidth_to = true;\n             lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n@@ -2730,16 +2731,12 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n         if (pfrom.GetCommonVersion() >= SHORT_IDS_BLOCKS_VERSION) {\n-            // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n+            // Tell our peer we are willing to provide version 2 cmpctblocks.\n             // However, we do not request new block announcements using\n             // cmpctblock messages.\n             // We send this to non-NODE NETWORK peers as well, because\n             // they may wish to request compact blocks from us\n-            bool fAnnounceUsingCMPCTBLOCK = false;\n-            uint64_t nCMPCTBLOCKVersion = 2;\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n-            nCMPCTBLOCKVersion = 1;\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/ false, /*version=*/ CMPCTBLOCKS_VERSION));\n         }\n         pfrom.fSuccessfullyConnected = true;\n         return;"
      },
      {
        "sha": "ddefb43fcee366c04eed03acdf83126bf447e96d",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d560ed807e74b4f69411072f58802221c609823/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d560ed807e74b4f69411072f58802221c609823/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=8d560ed807e74b4f69411072f58802221c609823",
        "patch": "@@ -193,10 +193,8 @@ def received_sendcmpct():\n             return (len(test_node.last_sendcmpct) > 0)\n         test_node.wait_until(received_sendcmpct, timeout=30)\n         with p2p_lock:\n-            # Check that the first version received is version 2\n+            # Check that version 2 is received.\n             assert_equal(test_node.last_sendcmpct[0].version, 2)\n-            # And that we receive versions down to 1.\n-            assert_equal(test_node.last_sendcmpct[-1].version, 1)\n             test_node.last_sendcmpct = []\n \n         tip = int(node.getbestblockhash(), 16)"
      },
      {
        "sha": "0000d963ad36a7ea4c55054659ae9beb52ee8536",
        "filename": "test/functional/p2p_compactblocks_blocksonly.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d560ed807e74b4f69411072f58802221c609823/test/functional/p2p_compactblocks_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d560ed807e74b4f69411072f58802221c609823/test/functional/p2p_compactblocks_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks_blocksonly.py?ref=8d560ed807e74b4f69411072f58802221c609823",
        "patch": "@@ -48,7 +48,7 @@ def run_test(self):\n         p2p_conn_high_bw = self.nodes[1].add_p2p_connection(P2PInterface())\n         p2p_conn_low_bw = self.nodes[3].add_p2p_connection(P2PInterface())\n         for conn in [p2p_conn_blocksonly, p2p_conn_high_bw, p2p_conn_low_bw]:\n-            assert_equal(conn.message_count['sendcmpct'], 2)\n+            assert_equal(conn.message_count['sendcmpct'], 1)\n             conn.send_and_ping(msg_sendcmpct(announce=False, version=2))\n \n         # Nodes:\n@@ -74,14 +74,14 @@ def run_test(self):\n         # receiving a new valid block at the tip.\n         p2p_conn_blocksonly.send_and_ping(msg_block(block0))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block0.sha256)\n-        assert_equal(p2p_conn_blocksonly.message_count['sendcmpct'], 2)\n+        assert_equal(p2p_conn_blocksonly.message_count['sendcmpct'], 1)\n         assert_equal(p2p_conn_blocksonly.last_message['sendcmpct'].announce, False)\n \n         # A normal node participating in transaction relay should request BIP152\n         # high bandwidth mode upon receiving a new valid block at the tip.\n         p2p_conn_high_bw.send_and_ping(msg_block(block0))\n         assert_equal(int(self.nodes[1].getbestblockhash(), 16), block0.sha256)\n-        p2p_conn_high_bw.wait_until(lambda: p2p_conn_high_bw.message_count['sendcmpct'] == 3)\n+        p2p_conn_high_bw.wait_until(lambda: p2p_conn_high_bw.message_count['sendcmpct'] == 2)\n         assert_equal(p2p_conn_high_bw.last_message['sendcmpct'].announce, True)\n \n         # Don't send a block from the p2p_conn_low_bw so the low bandwidth node"
      }
    ]
  },
  {
    "sha": "255c528a0fabae8aac4d93e75867ab4a172cedb5",
    "node_id": "C_kwDOABII59oAKDI1NWM1MjhhMGZhYmFlOGFhYzRkOTNlNzU4NjdhYjRhMTcyY2VkYjU",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:14:23Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:23:24Z"
      },
      "message": "[net processing] Only accept SENDCMPCT with version = 2\n\nSubsequent commits will remove support for other versions of compact blocks.\n\nAdd a test that a received `sendcmpct` message with version = 1 is\nignored.",
      "tree": {
        "sha": "52b12f76c10aceb48a067b34202aadcae733c28c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/52b12f76c10aceb48a067b34202aadcae733c28c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/255c528a0fabae8aac4d93e75867ab4a172cedb5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/255c528a0fabae8aac4d93e75867ab4a172cedb5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/255c528a0fabae8aac4d93e75867ab4a172cedb5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/255c528a0fabae8aac4d93e75867ab4a172cedb5/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8d560ed807e74b4f69411072f58802221c609823",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d560ed807e74b4f69411072f58802221c609823",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d560ed807e74b4f69411072f58802221c609823"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 26,
      "deletions": 16
    },
    "files": [
      {
        "sha": "c33a39f2aed3ed77f7196dc06534a0f8657273c8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 16,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/255c528a0fabae8aac4d93e75867ab4a172cedb5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/255c528a0fabae8aac4d93e75867ab4a172cedb5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=255c528a0fabae8aac4d93e75867ab4a172cedb5",
        "patch": "@@ -2752,22 +2752,24 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         bool fAnnounceUsingCMPCTBLOCK = false;\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n-        if (nCMPCTBLOCKVersion == 1 || nCMPCTBLOCKVersion == 2) {\n-            LOCK(cs_main);\n-            // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n-            if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n-                State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n-                State(pfrom.GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n-            }\n-            if (State(pfrom.GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) { // ignore later version announces\n-                State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n-                // save whether peer selects us as BIP152 high-bandwidth peer\n-                // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n-                pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n-            }\n-            if (!State(pfrom.GetId())->fSupportsDesiredCmpctVersion) {\n-                State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n-            }\n+\n+        // Only support compact block relay with witnesses\n+        if (nCMPCTBLOCKVersion != CMPCTBLOCKS_VERSION) return;\n+\n+        LOCK(cs_main);\n+        // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n+        if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n+            State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n+            State(pfrom.GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+        }\n+        if (State(pfrom.GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) { // ignore later version announces\n+            State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            // save whether peer selects us as BIP152 high-bandwidth peer\n+            // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n+            pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n+        }\n+        if (!State(pfrom.GetId())->fSupportsDesiredCmpctVersion) {\n+            State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n         }\n         return;\n     }"
      },
      {
        "sha": "94cd2c1ead764292dfdec833cf3b7ef3b45e8343",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/255c528a0fabae8aac4d93e75867ab4a172cedb5/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/255c528a0fabae8aac4d93e75867ab4a172cedb5/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=255c528a0fabae8aac4d93e75867ab4a172cedb5",
        "patch": "@@ -180,6 +180,7 @@ def make_utxos(self):\n \n     # Test \"sendcmpct\" (between peers preferring the same version):\n     # - No compact block announcements unless sendcmpct is sent.\n+    # - If sendcmpct is sent with version = 1, the message is ignored.\n     # - If sendcmpct is sent with version > 2, the message is ignored.\n     # - If sendcmpct is sent with boolean 0, then block announcements are not\n     #   made with compact blocks.\n@@ -222,6 +223,13 @@ def check_announcement_of_new_block(node, peer, predicate):\n         # Before each test, sync the headers chain.\n         test_node.request_headers_and_sync(locator=[tip])\n \n+        # Now try a SENDCMPCT message with too-low version\n+        test_node.send_and_ping(msg_sendcmpct(announce=True, version=1))\n+        check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n+\n+        # Headers sync before next test.\n+        test_node.request_headers_and_sync(locator=[tip])\n+\n         # Now try a SENDCMPCT message with too-high version\n         test_node.send_and_ping(msg_sendcmpct(announce=True, version=3))\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)"
      }
    ]
  },
  {
    "sha": "fe4a59efa77bf6da2694688a35c904699c6b03a7",
    "node_id": "C_kwDOABII59oAKGZlNGE1OWVmYTc3YmY2ZGEyNjk0Njg4YTM1YzkwNDY5OWM2YjAzYTc",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:17:53Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:31:07Z"
      },
      "message": "[net processing] Simplify SENDCMPCT processing\n\nnCMPCTBLOCKVersion must always be 2 when processing.",
      "tree": {
        "sha": "eca4aa31132745f604e2ad9590c1164a79e1e05f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eca4aa31132745f604e2ad9590c1164a79e1e05f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fe4a59efa77bf6da2694688a35c904699c6b03a7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe4a59efa77bf6da2694688a35c904699c6b03a7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fe4a59efa77bf6da2694688a35c904699c6b03a7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe4a59efa77bf6da2694688a35c904699c6b03a7/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "255c528a0fabae8aac4d93e75867ab4a172cedb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/255c528a0fabae8aac4d93e75867ab4a172cedb5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/255c528a0fabae8aac4d93e75867ab4a172cedb5"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 3,
      "deletions": 5
    },
    "files": [
      {
        "sha": "5c7805d9a74286ded9e2919d1b43eaa4eea14c03",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe4a59efa77bf6da2694688a35c904699c6b03a7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe4a59efa77bf6da2694688a35c904699c6b03a7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fe4a59efa77bf6da2694688a35c904699c6b03a7",
        "patch": "@@ -2760,17 +2760,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n         if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n             State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n-            State(pfrom.GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+            State(pfrom.GetId())->fWantsCmpctWitness = true;\n         }\n-        if (State(pfrom.GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) { // ignore later version announces\n+        if (State(pfrom.GetId())->fWantsCmpctWitness) {\n             State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n             // save whether peer selects us as BIP152 high-bandwidth peer\n             // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n             pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n         }\n-        if (!State(pfrom.GetId())->fSupportsDesiredCmpctVersion) {\n-            State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n-        }\n+        State(pfrom.GetId())->fSupportsDesiredCmpctVersion = true;\n         return;\n     }\n "
      }
    ]
  },
  {
    "sha": "b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
    "node_id": "C_kwDOABII59oAKGI5ZDdjYmVjYWRmNjZmOGRmY2RmYjk2YzBiNTA1MmYyMDIzMjA4OTM",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:24:17Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:40:37Z"
      },
      "message": "[net processing] Remove fSupportsDesiredCmpctVersion\n\nIt is now completely redundant with fProvidesHeadersAndIDs.",
      "tree": {
        "sha": "f2ee22b8b5c7bce6ad5f88fb5893bf646af539b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f2ee22b8b5c7bce6ad5f88fb5893bf646af539b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9d7cbecadf66f8dfcdfb96c0b5052f202320893/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fe4a59efa77bf6da2694688a35c904699c6b03a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe4a59efa77bf6da2694688a35c904699c6b03a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe4a59efa77bf6da2694688a35c904699c6b03a7"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 4,
      "deletions": 12
    },
    "files": [
      {
        "sha": "efbfde67491d587d1812fc548f5202c550093239",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 12,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9d7cbecadf66f8dfcdfb96c0b5052f202320893/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9d7cbecadf66f8dfcdfb96c0b5052f202320893/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
        "patch": "@@ -701,19 +701,12 @@ struct CNodeState {\n     bool fPreferHeaderAndIDs{false};\n     /**\n       * Whether this peer will send us cmpctblocks if we request them.\n-      * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,\n-      * but is used as a flag to \"lock in\" the version of compact blocks (fWantsCmpctWitness) we send.\n       */\n     bool fProvidesHeaderAndIDs{false};\n     //! Whether this peer can give us witnesses\n     bool fHaveWitness{false};\n     //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n     bool fWantsCmpctWitness{false};\n-    /**\n-     * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,\n-     * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n-     */\n-    bool fSupportsDesiredCmpctVersion{false};\n \n     /** State used to enforce CHAIN_SYNC_TIMEOUT and EXTRA_PEER_CHECK_INTERVAL logic.\n       *\n@@ -894,8 +887,8 @@ void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n     if (m_ignore_incoming_txs) return;\n \n     CNodeState* nodestate = State(nodeid);\n-    if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n-        // Never ask from peers who can't provide witnesses.\n+    if (!nodestate || !nodestate->fProvidesHeaderAndIDs) {\n+        // Don't request compact blocks if the peer has not signalled support\n         return;\n     }\n     if (nodestate->fProvidesHeaderAndIDs) {\n@@ -2174,7 +2167,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                 }\n                 if (vGetData.size() > 0) {\n                     if (!m_ignore_incoming_txs &&\n-                        nodestate->fSupportsDesiredCmpctVersion &&\n+                        nodestate->fProvidesHeaderAndIDs &&\n                         vGetData.size() == 1 &&\n                         mapBlocksInFlight.size() == 1 &&\n                         pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n@@ -2768,7 +2761,6 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n             pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n         }\n-        State(pfrom.GetId())->fSupportsDesiredCmpctVersion = true;\n         return;\n     }\n \n@@ -3495,7 +3487,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT) && !nodestate->fSupportsDesiredCmpctVersion) {\n+        if (DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT) && !nodestate->fProvidesHeaderAndIDs) {\n             // Don't bother trying to process compact blocks from v1 peers\n             // after segwit activates.\n             return;"
      }
    ]
  },
  {
    "sha": "b4083acaf1f0bd4f0c202f4434ba009b0259d179",
    "node_id": "C_kwDOABII59oAKGI0MDgzYWNhZjFmMGJkNGYwYzIwMmY0NDM0YmEwMDliMDI1OWQxNzk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:28:42Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:40:39Z"
      },
      "message": "[net processing] Remove fWantsCmpctWitness\n\nIt is now completely redundant with fProvidesHeadersAndIDs.",
      "tree": {
        "sha": "fab0c6d26fbceff4d4bf5b7e7fcda069265ff679",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fab0c6d26fbceff4d4bf5b7e7fcda069265ff679"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4083acaf1f0bd4f0c202f4434ba009b0259d179",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4083acaf1f0bd4f0c202f4434ba009b0259d179",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4083acaf1f0bd4f0c202f4434ba009b0259d179",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4083acaf1f0bd4f0c202f4434ba009b0259d179/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9d7cbecadf66f8dfcdfb96c0b5052f202320893",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9d7cbecadf66f8dfcdfb96c0b5052f202320893"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 9,
      "deletions": 13
    },
    "files": [
      {
        "sha": "83da6d21dbc9e73550ec3d84d1cc39566e169726",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 13,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4083acaf1f0bd4f0c202f4434ba009b0259d179/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4083acaf1f0bd4f0c202f4434ba009b0259d179/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b4083acaf1f0bd4f0c202f4434ba009b0259d179",
        "patch": "@@ -705,8 +705,6 @@ struct CNodeState {\n     bool fProvidesHeaderAndIDs{false};\n     //! Whether this peer can give us witnesses\n     bool fHaveWitness{false};\n-    //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n-    bool fWantsCmpctWitness{false};\n \n     /** State used to enforce CHAIN_SYNC_TIMEOUT and EXTRA_PEER_CHECK_INTERVAL logic.\n       *\n@@ -1540,7 +1538,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n         CNodeState &state = *State(pnode->GetId());\n         // If the peer has, or we announced to them the previous block already,\n         // but we don't think they have this one, go ahead and announce it\n-        if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n+        if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fProvidesHeaderAndIDs) &&\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerManager::NewPoWValidBlock\",\n@@ -1852,7 +1850,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n             // they won't have a useful mempool to match against a compact block,\n             // and we don't feel like constructing the object for them, so\n             // instead we respond with the full, non-compact block.\n-            bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n+            bool fPeerWantsWitness = State(pfrom.GetId())->fProvidesHeaderAndIDs;\n             int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n             if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                 if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n@@ -2023,7 +2021,7 @@ void PeerManagerImpl::SendBlockTransactions(CNode& pfrom, const CBlock& block, c\n     }\n     LOCK(cs_main);\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n-    int nSendFlags = State(pfrom.GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+    int nSendFlags = State(pfrom.GetId())->fProvidesHeaderAndIDs ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n     m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n@@ -2750,12 +2748,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (nCMPCTBLOCKVersion != CMPCTBLOCKS_VERSION) return;\n \n         LOCK(cs_main);\n-        // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n         if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n             State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n-            State(pfrom.GetId())->fWantsCmpctWitness = true;\n         }\n-        if (State(pfrom.GetId())->fWantsCmpctWitness) {\n+        if (State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n             State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n             // save whether peer selects us as BIP152 high-bandwidth peer\n             // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n@@ -3111,7 +3107,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // actually receive all the data read from disk over the network.\n         LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom.GetId(), MAX_BLOCKTXN_DEPTH);\n         CInv inv;\n-        WITH_LOCK(cs_main, inv.type = State(pfrom.GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n+        WITH_LOCK(cs_main, inv.type = State(pfrom.GetId())->fProvidesHeaderAndIDs ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n         inv.hash = req.blockhash;\n         WITH_LOCK(peer->m_getdata_requests_mutex, peer->m_getdata_requests.push_back(inv));\n         // The message processing loop will go around again (without pausing) and we'll respond then\n@@ -4633,16 +4629,16 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                             vHeaders.front().GetHash().ToString(), pto->GetId());\n \n-                    int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+                    int nSendFlags = state.fProvidesHeaderAndIDs ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n                     bool fGotBlockFromCache = false;\n                     {\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n-                            if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n+                            if (state.fProvidesHeaderAndIDs || !fWitnessesPresentInMostRecentCompactBlock)\n                                 m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n-                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n+                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fProvidesHeaderAndIDs);\n                                 m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                             fGotBlockFromCache = true;\n@@ -4652,7 +4648,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         CBlock block;\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n-                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n+                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.fProvidesHeaderAndIDs);\n                         m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;"
      }
    ]
  },
  {
    "sha": "3632976d459966389fc39cd8f2d5ee3b338ffcb0",
    "node_id": "C_kwDOABII59oAKDM2MzI5NzZkNDU5OTY2Mzg5ZmMzOWNkOGYyZDVlZTNiMzM4ZmZjYjA",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:35:24Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:40:39Z"
      },
      "message": "[net processing] Tidy up SENDCMPCT processing\n\n- use better local variable names\n- drop unnecessary if statements",
      "tree": {
        "sha": "c6b91a1ccf53cfcdf7b4641b90d4331869ffb77c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c6b91a1ccf53cfcdf7b4641b90d4331869ffb77c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3632976d459966389fc39cd8f2d5ee3b338ffcb0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3632976d459966389fc39cd8f2d5ee3b338ffcb0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3632976d459966389fc39cd8f2d5ee3b338ffcb0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3632976d459966389fc39cd8f2d5ee3b338ffcb0/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4083acaf1f0bd4f0c202f4434ba009b0259d179",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4083acaf1f0bd4f0c202f4434ba009b0259d179",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4083acaf1f0bd4f0c202f4434ba009b0259d179"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 10,
      "deletions": 13
    },
    "files": [
      {
        "sha": "0c80bab34158ea1ea978dad2be78eeb3b33bb8db",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 13,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3632976d459966389fc39cd8f2d5ee3b338ffcb0/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3632976d459966389fc39cd8f2d5ee3b338ffcb0/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3632976d459966389fc39cd8f2d5ee3b338ffcb0",
        "patch": "@@ -2740,23 +2740,20 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     }\n \n     if (msg_type == NetMsgType::SENDCMPCT) {\n-        bool fAnnounceUsingCMPCTBLOCK = false;\n-        uint64_t nCMPCTBLOCKVersion = 0;\n-        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n+        bool sendcmpct_hb{false};\n+        uint64_t sendcmpct_version{0};\n+        vRecv >> sendcmpct_hb >> sendcmpct_version;\n \n         // Only support compact block relay with witnesses\n-        if (nCMPCTBLOCKVersion != CMPCTBLOCKS_VERSION) return;\n+        if (sendcmpct_version != CMPCTBLOCKS_VERSION) return;\n \n         LOCK(cs_main);\n-        if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n-            State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n-        }\n-        if (State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n-            State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n-            // save whether peer selects us as BIP152 high-bandwidth peer\n-            // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n-            pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n-        }\n+        CNodeState* nodestate = State(pfrom.GetId());\n+        nodestate->fProvidesHeaderAndIDs = true;\n+        nodestate->fPreferHeaderAndIDs = sendcmpct_hb;\n+        // save whether peer selects us as BIP152 high-bandwidth peer\n+        // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n+        pfrom.m_bip152_highbandwidth_from = sendcmpct_hb;\n         return;\n     }\n "
      }
    ]
  },
  {
    "sha": "90500c4271c69aea5f4b48e1600a6f4eccb73c73",
    "node_id": "C_kwDOABII59oAKDkwNTAwYzQyNzFjNjlhZWE1ZjRiNDhlMTYwMGE2ZjRlY2NiNzNjNzM",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:41:58Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:40:53Z"
      },
      "message": "[net processing] Rename CNodeState compact block members\n\nfPreferHeaderAndIDs -> m_sendcmpct_hb\nfProvidesHeaderAndIDs -> m_sendcmpct",
      "tree": {
        "sha": "2dc910cc8950c488ee513a4da8e70303e0b89b37",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2dc910cc8950c488ee513a4da8e70303e0b89b37"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/90500c4271c69aea5f4b48e1600a6f4eccb73c73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90500c4271c69aea5f4b48e1600a6f4eccb73c73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/90500c4271c69aea5f4b48e1600a6f4eccb73c73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90500c4271c69aea5f4b48e1600a6f4eccb73c73/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3632976d459966389fc39cd8f2d5ee3b338ffcb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3632976d459966389fc39cd8f2d5ee3b338ffcb0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3632976d459966389fc39cd8f2d5ee3b338ffcb0"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 20,
      "deletions": 22
    },
    "files": [
      {
        "sha": "4d9fae81ea3f662b827a4a6c0a861236360d60ca",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 22,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90500c4271c69aea5f4b48e1600a6f4eccb73c73/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90500c4271c69aea5f4b48e1600a6f4eccb73c73/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=90500c4271c69aea5f4b48e1600a6f4eccb73c73",
        "patch": "@@ -697,12 +697,10 @@ struct CNodeState {\n     bool fPreferredDownload{false};\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n     bool fPreferHeaders{false};\n-    //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n-    bool fPreferHeaderAndIDs{false};\n-    /**\n-      * Whether this peer will send us cmpctblocks if we request them.\n-      */\n-    bool fProvidesHeaderAndIDs{false};\n+    /** Whether this peer wants cmpctblocks (when possible) for block announcements. */\n+    bool m_sendcmpct_hb{false};\n+    /** Whether this peer will send us cmpctblocks if we request them. */\n+    bool m_sendcmpct{false};\n     //! Whether this peer can give us witnesses\n     bool fHaveWitness{false};\n \n@@ -885,11 +883,11 @@ void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n     if (m_ignore_incoming_txs) return;\n \n     CNodeState* nodestate = State(nodeid);\n-    if (!nodestate || !nodestate->fProvidesHeaderAndIDs) {\n+    if (!nodestate || !nodestate->m_sendcmpct) {\n         // Don't request compact blocks if the peer has not signalled support\n         return;\n     }\n-    if (nodestate->fProvidesHeaderAndIDs) {\n+    if (nodestate->m_sendcmpct) {\n         int num_outbound_hb_peers = 0;\n         for (std::list<NodeId>::iterator it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); it++) {\n             if (*it == nodeid) {\n@@ -1538,7 +1536,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n         CNodeState &state = *State(pnode->GetId());\n         // If the peer has, or we announced to them the previous block already,\n         // but we don't think they have this one, go ahead and announce it\n-        if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fProvidesHeaderAndIDs) &&\n+        if (state.m_sendcmpct_hb && (!fWitnessEnabled || state.m_sendcmpct) &&\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerManager::NewPoWValidBlock\",\n@@ -1850,7 +1848,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n             // they won't have a useful mempool to match against a compact block,\n             // and we don't feel like constructing the object for them, so\n             // instead we respond with the full, non-compact block.\n-            bool fPeerWantsWitness = State(pfrom.GetId())->fProvidesHeaderAndIDs;\n+            bool fPeerWantsWitness = State(pfrom.GetId())->m_sendcmpct;\n             int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n             if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                 if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n@@ -2021,7 +2019,7 @@ void PeerManagerImpl::SendBlockTransactions(CNode& pfrom, const CBlock& block, c\n     }\n     LOCK(cs_main);\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n-    int nSendFlags = State(pfrom.GetId())->fProvidesHeaderAndIDs ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+    int nSendFlags = State(pfrom.GetId())->m_sendcmpct ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n     m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n@@ -2165,7 +2163,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                 }\n                 if (vGetData.size() > 0) {\n                     if (!m_ignore_incoming_txs &&\n-                        nodestate->fProvidesHeaderAndIDs &&\n+                        nodestate->m_sendcmpct &&\n                         vGetData.size() == 1 &&\n                         mapBlocksInFlight.size() == 1 &&\n                         pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n@@ -2749,8 +2747,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK(cs_main);\n         CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->fProvidesHeaderAndIDs = true;\n-        nodestate->fPreferHeaderAndIDs = sendcmpct_hb;\n+        nodestate->m_sendcmpct = true;\n+        nodestate->m_sendcmpct_hb = sendcmpct_hb;\n         // save whether peer selects us as BIP152 high-bandwidth peer\n         // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n         pfrom.m_bip152_highbandwidth_from = sendcmpct_hb;\n@@ -3104,7 +3102,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // actually receive all the data read from disk over the network.\n         LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom.GetId(), MAX_BLOCKTXN_DEPTH);\n         CInv inv;\n-        WITH_LOCK(cs_main, inv.type = State(pfrom.GetId())->fProvidesHeaderAndIDs ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n+        WITH_LOCK(cs_main, inv.type = State(pfrom.GetId())->m_sendcmpct ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n         inv.hash = req.blockhash;\n         WITH_LOCK(peer->m_getdata_requests_mutex, peer->m_getdata_requests.push_back(inv));\n         // The message processing loop will go around again (without pausing) and we'll respond then\n@@ -3480,7 +3478,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT) && !nodestate->fProvidesHeaderAndIDs) {\n+        if (DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT) && !nodestate->m_sendcmpct) {\n             // Don't bother trying to process compact blocks from v1 peers\n             // after segwit activates.\n             return;\n@@ -4567,7 +4565,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             LOCK(peer->m_block_inv_mutex);\n             std::vector<CBlock> vHeaders;\n             bool fRevertToInv = ((!state.fPreferHeaders &&\n-                                 (!state.fPreferHeaderAndIDs || peer->m_blocks_for_headers_relay.size() > 1)) ||\n+                                 (!state.m_sendcmpct_hb || peer->m_blocks_for_headers_relay.size() > 1)) ||\n                                  peer->m_blocks_for_headers_relay.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n             ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n@@ -4620,22 +4618,22 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 }\n             }\n             if (!fRevertToInv && !vHeaders.empty()) {\n-                if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n+                if (vHeaders.size() == 1 && state.m_sendcmpct_hb) {\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                             vHeaders.front().GetHash().ToString(), pto->GetId());\n \n-                    int nSendFlags = state.fProvidesHeaderAndIDs ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+                    int nSendFlags = state.m_sendcmpct ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n                     bool fGotBlockFromCache = false;\n                     {\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n-                            if (state.fProvidesHeaderAndIDs || !fWitnessesPresentInMostRecentCompactBlock)\n+                            if (state.m_sendcmpct || !fWitnessesPresentInMostRecentCompactBlock)\n                                 m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n-                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fProvidesHeaderAndIDs);\n+                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.m_sendcmpct);\n                                 m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                             fGotBlockFromCache = true;\n@@ -4645,7 +4643,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         CBlock block;\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n-                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.fProvidesHeaderAndIDs);\n+                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.m_sendcmpct);\n                         m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;"
      }
    ]
  },
  {
    "sha": "1e814a9e5048718e1b1ff0794197994a9ff63835",
    "node_id": "C_kwDOABII59oAKDFlODE0YTllNTA0ODcxOGUxYjFmZjA3OTQxOTc5OTRhOWZmNjM4MzU",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:48:34Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:40:56Z"
      },
      "message": "[net processing] Only relay blocks by cmpctblock and cache for fast relay if segwit is enabled",
      "tree": {
        "sha": "0c93e8b7cc0736148d02c21c14e12b3e1672d4a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c93e8b7cc0736148d02c21c14e12b3e1672d4a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e814a9e5048718e1b1ff0794197994a9ff63835",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e814a9e5048718e1b1ff0794197994a9ff63835",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e814a9e5048718e1b1ff0794197994a9ff63835",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e814a9e5048718e1b1ff0794197994a9ff63835/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "90500c4271c69aea5f4b48e1600a6f4eccb73c73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90500c4271c69aea5f4b48e1600a6f4eccb73c73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/90500c4271c69aea5f4b48e1600a6f4eccb73c73"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 15,
      "deletions": 37
    },
    "files": [
      {
        "sha": "d1cf7ea26d200cafca03e5871a667747aa67d7af",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 37,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e814a9e5048718e1b1ff0794197994a9ff63835/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e814a9e5048718e1b1ff0794197994a9ff63835/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1e814a9e5048718e1b1ff0794197994a9ff63835",
        "patch": "@@ -1497,7 +1497,6 @@ static RecursiveMutex cs_most_recent_block;\n static std::shared_ptr<const CBlock> most_recent_block GUARDED_BY(cs_most_recent_block);\n static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block GUARDED_BY(cs_most_recent_block);\n static uint256 most_recent_block_hash GUARDED_BY(cs_most_recent_block);\n-static bool fWitnessesPresentInMostRecentCompactBlock GUARDED_BY(cs_most_recent_block);\n \n /**\n  * Maintain state about the best-seen block and fast-announce a compact block\n@@ -1515,18 +1514,18 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n         return;\n     nHighestFastAnnounce = pindex->nHeight;\n \n-    bool fWitnessEnabled = DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT);\n+    if (!DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT)) return;\n+\n     uint256 hashBlock(pblock->GetHash());\n \n     {\n         LOCK(cs_most_recent_block);\n         most_recent_block_hash = hashBlock;\n         most_recent_block = pblock;\n         most_recent_compact_block = pcmpctblock;\n-        fWitnessesPresentInMostRecentCompactBlock = fWitnessEnabled;\n     }\n \n-    m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, &hashBlock](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n         AssertLockHeld(::cs_main);\n \n         // TODO: Avoid the repeated-serialization here\n@@ -1536,8 +1535,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n         CNodeState &state = *State(pnode->GetId());\n         // If the peer has, or we announced to them the previous block already,\n         // but we don't think they have this one, go ahead and announce it\n-        if (state.m_sendcmpct_hb && (!fWitnessEnabled || state.m_sendcmpct) &&\n-                !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n+        if (state.m_sendcmpct_hb && !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerManager::NewPoWValidBlock\",\n                     hashBlock.ToString(), pnode->GetId());\n@@ -1730,12 +1728,10 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n {\n     std::shared_ptr<const CBlock> a_recent_block;\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n-    bool fWitnessesPresentInARecentCompactBlock;\n     {\n         LOCK(cs_most_recent_block);\n         a_recent_block = most_recent_block;\n         a_recent_compact_block = most_recent_compact_block;\n-        fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n     }\n \n     bool need_activate_chain = false;\n@@ -1848,17 +1844,15 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n             // they won't have a useful mempool to match against a compact block,\n             // and we don't feel like constructing the object for them, so\n             // instead we respond with the full, non-compact block.\n-            bool fPeerWantsWitness = State(pfrom.GetId())->m_sendcmpct;\n-            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n             if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n-                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                if (a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                 } else {\n-                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, true);\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::CMPCTBLOCK, cmpctblock));\n                 }\n             } else {\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n             }\n         }\n     }\n@@ -2017,10 +2011,9 @@ void PeerManagerImpl::SendBlockTransactions(CNode& pfrom, const CBlock& block, c\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n     }\n-    LOCK(cs_main);\n+\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n-    int nSendFlags = State(pfrom.GetId())->m_sendcmpct ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n+    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCKTXN, resp));\n }\n \n void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n@@ -3101,9 +3094,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // expensive disk reads, because it will require the peer to\n         // actually receive all the data read from disk over the network.\n         LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom.GetId(), MAX_BLOCKTXN_DEPTH);\n-        CInv inv;\n-        WITH_LOCK(cs_main, inv.type = State(pfrom.GetId())->m_sendcmpct ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n-        inv.hash = req.blockhash;\n+        CInv inv(MSG_WITNESS_BLOCK, req.blockhash);\n         WITH_LOCK(peer->m_getdata_requests_mutex, peer->m_getdata_requests.push_back(inv));\n         // The message processing loop will go around again (without pausing) and we'll respond then\n         return;\n@@ -3478,12 +3469,6 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (DeploymentActiveAt(*pindex, m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT) && !nodestate->m_sendcmpct) {\n-            // Don't bother trying to process compact blocks from v1 peers\n-            // after segwit activates.\n-            return;\n-        }\n-\n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= m_chainman.ActiveChain().Height() + 2) {\n@@ -4624,27 +4609,20 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                             vHeaders.front().GetHash().ToString(), pto->GetId());\n \n-                    int nSendFlags = state.m_sendcmpct ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-\n                     bool fGotBlockFromCache = false;\n                     {\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n-                            if (state.m_sendcmpct || !fWitnessesPresentInMostRecentCompactBlock)\n-                                m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n-                            else {\n-                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.m_sendcmpct);\n-                                m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                            }\n+                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             fGotBlockFromCache = true;\n                         }\n                     }\n                     if (!fGotBlockFromCache) {\n                         CBlock block;\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n-                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.m_sendcmpct);\n-                        m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        CBlockHeaderAndShortTxIDs cmpctblock(block, true);\n+                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {"
      }
    ]
  },
  {
    "sha": "387c48fafb77caeb8ff7ffccacee8cfc79750b6e",
    "node_id": "C_kwDOABII59oAKDM4N2M0OGZhZmI3N2NhZWI4ZmY3ZmZjY2FjZWU4Y2ZjNzk3NTBiNmU",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-01-02T15:52:13Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-11-04T14:40:56Z"
      },
      "message": "[net processing] Remove redundant nodestate->m_sendcmpct check in MaybeSetPeerAsAnnouncingHeaderAndIDs()",
      "tree": {
        "sha": "533085e4673ed1161dbac17331b783e262a27a16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/533085e4673ed1161dbac17331b783e262a27a16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/387c48fafb77caeb8ff7ffccacee8cfc79750b6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/387c48fafb77caeb8ff7ffccacee8cfc79750b6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/387c48fafb77caeb8ff7ffccacee8cfc79750b6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/387c48fafb77caeb8ff7ffccacee8cfc79750b6e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1e814a9e5048718e1b1ff0794197994a9ff63835",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e814a9e5048718e1b1ff0794197994a9ff63835",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1e814a9e5048718e1b1ff0794197994a9ff63835"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 39,
      "deletions": 40
    },
    "files": [
      {
        "sha": "d6391b11c84892db13f49bd88e8c0a89f44d3448",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 40,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/387c48fafb77caeb8ff7ffccacee8cfc79750b6e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/387c48fafb77caeb8ff7ffccacee8cfc79750b6e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=387c48fafb77caeb8ff7ffccacee8cfc79750b6e",
        "patch": "@@ -887,49 +887,48 @@ void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n         // Don't request compact blocks if the peer has not signalled support\n         return;\n     }\n-    if (nodestate->m_sendcmpct) {\n-        int num_outbound_hb_peers = 0;\n-        for (std::list<NodeId>::iterator it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); it++) {\n-            if (*it == nodeid) {\n-                lNodesAnnouncingHeaderAndIDs.erase(it);\n-                lNodesAnnouncingHeaderAndIDs.push_back(nodeid);\n-                return;\n-            }\n-            CNodeState *state = State(*it);\n-            if (state != nullptr && !state->m_is_inbound) ++num_outbound_hb_peers;\n-        }\n-        if (nodestate->m_is_inbound) {\n-            // If we're adding an inbound HB peer, make sure we're not removing\n-            // our last outbound HB peer in the process.\n-            if (lNodesAnnouncingHeaderAndIDs.size() >= 3 && num_outbound_hb_peers == 1) {\n-                CNodeState *remove_node = State(lNodesAnnouncingHeaderAndIDs.front());\n-                if (remove_node != nullptr && !remove_node->m_is_inbound) {\n-                    // Put the HB outbound peer in the second slot, so that it\n-                    // doesn't get removed.\n-                    std::swap(lNodesAnnouncingHeaderAndIDs.front(), *std::next(lNodesAnnouncingHeaderAndIDs.begin()));\n-                }\n-            }\n+\n+    int num_outbound_hb_peers = 0;\n+    for (std::list<NodeId>::iterator it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); it++) {\n+        if (*it == nodeid) {\n+            lNodesAnnouncingHeaderAndIDs.erase(it);\n+            lNodesAnnouncingHeaderAndIDs.push_back(nodeid);\n+            return;\n         }\n-        m_connman.ForNode(nodeid, [this](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n-            AssertLockHeld(::cs_main);\n-            if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n-                // As per BIP152, we only get 3 of our peers to announce\n-                // blocks using compact encodings.\n-                m_connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [this](CNode* pnodeStop){\n-                    m_connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/ false, /*version=*/ CMPCTBLOCKS_VERSION));\n-                    // save BIP152 bandwidth state: we select peer to be low-bandwidth\n-                    pnodeStop->m_bip152_highbandwidth_to = false;\n-                    return true;\n-                });\n-                lNodesAnnouncingHeaderAndIDs.pop_front();\n+        CNodeState *state = State(*it);\n+        if (state != nullptr && !state->m_is_inbound) ++num_outbound_hb_peers;\n+    }\n+    if (nodestate->m_is_inbound) {\n+        // If we're adding an inbound HB peer, make sure we're not removing\n+        // our last outbound HB peer in the process.\n+        if (lNodesAnnouncingHeaderAndIDs.size() >= 3 && num_outbound_hb_peers == 1) {\n+            CNodeState *remove_node = State(lNodesAnnouncingHeaderAndIDs.front());\n+            if (remove_node != nullptr && !remove_node->m_is_inbound) {\n+                // Put the HB outbound peer in the second slot, so that it\n+                // doesn't get removed.\n+                std::swap(lNodesAnnouncingHeaderAndIDs.front(), *std::next(lNodesAnnouncingHeaderAndIDs.begin()));\n             }\n-            m_connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/ true, /*version=*/ CMPCTBLOCKS_VERSION));\n-            // save BIP152 bandwidth state: we select peer to be high-bandwidth\n-            pfrom->m_bip152_highbandwidth_to = true;\n-            lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n-            return true;\n-        });\n+        }\n     }\n+    m_connman.ForNode(nodeid, [this](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+        AssertLockHeld(::cs_main);\n+        if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n+            // As per BIP152, we only get 3 of our peers to announce\n+            // blocks using compact encodings.\n+            m_connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [this](CNode* pnodeStop){\n+                m_connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/ false, /*version=*/ CMPCTBLOCKS_VERSION));\n+                // save BIP152 bandwidth state: we select peer to be low-bandwidth\n+                pnodeStop->m_bip152_highbandwidth_to = false;\n+                return true;\n+            });\n+            lNodesAnnouncingHeaderAndIDs.pop_front();\n+        }\n+        m_connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/true, /*version=*/ CMPCTBLOCKS_VERSION));\n+        // save BIP152 bandwidth state: we select peer to be high-bandwidth\n+        pfrom->m_bip152_highbandwidth_to = true;\n+        lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n+        return true;\n+    });\n }\n \n bool PeerManagerImpl::TipMayBeStale()"
      }
    ]
  }
]