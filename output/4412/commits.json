[
  {
    "sha": "b185a620e30c434c2ee1b462eebf681ac2b04722",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMTg1YTYyMGUzMGM0MzRjMmVlMWI0NjJlZWJmNjgxYWMyYjA0NzIy",
    "commit": {
      "author": {
        "name": "anon5",
        "email": "btc-regulation@outlook.com",
        "date": "2014-06-20T11:14:06Z"
      },
      "committer": {
        "name": "anon5",
        "email": "btc-regulation@outlook.com",
        "date": "2014-06-20T11:14:06Z"
      },
      "message": "initial redlist regulatory framework",
      "tree": {
        "sha": "d9af78df10b831a230f98e823e4f3d3ecee4bab8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d9af78df10b831a230f98e823e4f3d3ecee4bab8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b185a620e30c434c2ee1b462eebf681ac2b04722",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b185a620e30c434c2ee1b462eebf681ac2b04722",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b185a620e30c434c2ee1b462eebf681ac2b04722",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b185a620e30c434c2ee1b462eebf681ac2b04722/comments",
    "author": {
      "login": "DistributedRegulation",
      "id": 7942038,
      "node_id": "MDQ6VXNlcjc5NDIwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7942038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DistributedRegulation",
      "html_url": "https://github.com/DistributedRegulation",
      "followers_url": "https://api.github.com/users/DistributedRegulation/followers",
      "following_url": "https://api.github.com/users/DistributedRegulation/following{/other_user}",
      "gists_url": "https://api.github.com/users/DistributedRegulation/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DistributedRegulation/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DistributedRegulation/subscriptions",
      "organizations_url": "https://api.github.com/users/DistributedRegulation/orgs",
      "repos_url": "https://api.github.com/users/DistributedRegulation/repos",
      "events_url": "https://api.github.com/users/DistributedRegulation/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DistributedRegulation/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "DistributedRegulation",
      "id": 7942038,
      "node_id": "MDQ6VXNlcjc5NDIwMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7942038?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DistributedRegulation",
      "html_url": "https://github.com/DistributedRegulation",
      "followers_url": "https://api.github.com/users/DistributedRegulation/followers",
      "following_url": "https://api.github.com/users/DistributedRegulation/following{/other_user}",
      "gists_url": "https://api.github.com/users/DistributedRegulation/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DistributedRegulation/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DistributedRegulation/subscriptions",
      "organizations_url": "https://api.github.com/users/DistributedRegulation/orgs",
      "repos_url": "https://api.github.com/users/DistributedRegulation/repos",
      "events_url": "https://api.github.com/users/DistributedRegulation/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DistributedRegulation/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aefbf6e30cadaf77ebee44284c74cc5449dc173f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aefbf6e30cadaf77ebee44284c74cc5449dc173f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aefbf6e30cadaf77ebee44284c74cc5449dc173f"
      }
    ],
    "stats": {
      "total": 416,
      "additions": 413,
      "deletions": 3
    },
    "files": [
      {
        "sha": "38b68c577bebd07045d685fabceb4eca01bb83e7",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -476,6 +476,7 @@ if test x$use_pkgconfig = xyes; then\n     [\n       PKG_CHECK_MODULES([SSL], [libssl], [INCLUDES=\"$INCLUDES $SSL_CFLAGS\"; LIBS=\"$LIBS $SSL_LIBS\"], [AC_MSG_ERROR(openssl  not found.)])\n       PKG_CHECK_MODULES([CRYPTO], [libcrypto], [INCLUDES=\"$INCLUDES $CRYPTO_CFLAGS\"; LIBS=\"$LIBS $CRYPTO_LIBS\"], [AC_MSG_ERROR(libcrypto  not found.)])\n+      PKG_CHECK_MODULES([CURL], [libcurl], [INCLUDES=\"$INCLUDES $CURL_CFLAGS\"; LIBS=\"$LIBS $CURL_LIBS\"], [AC_MSG_ERROR(libcurl not found.)])\n       BITCOIN_QT_CHECK([PKG_CHECK_MODULES([PROTOBUF], [protobuf], [have_protobuf=yes], [BITCOIN_QT_FAIL(libprotobuf not found)])])\n       if test x$use_qr != xno; then\n         BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])"
      },
      {
        "sha": "d5fe52f8a4b634e4419a678ff61c36cfb9b6248f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -102,6 +102,7 @@ libbitcoin_server_a_SOURCES = \\\n   miner.cpp \\\n   net.cpp \\\n   noui.cpp \\\n+  redlist.cpp \\\n   rpcblockchain.cpp \\\n   rpcmining.cpp \\\n   rpcmisc.cpp \\"
      },
      {
        "sha": "190587b8626d56b26c33532f0f7961beaceb4568",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 2,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -16,6 +16,7 @@\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n+#include \"redlist.h\"\n \n #include <sstream>\n \n@@ -77,6 +78,17 @@ namespace {\n struct CBlockIndexWorkComparator\n {\n     bool operator()(CBlockIndex *pa, CBlockIndex *pb) {\n+        // if one of the indexes contains redlisted items\n+        // that index needs to have performed more work in comparison than the switching threshold\n+        if(pb->fTainted && !pa->fTainted)\n+        {\n+            return (pb->nHeight - pa->nHeight) > GetWorkSwitchThreshold();\n+        }\n+        if(pa->fTainted && !pb->fTainted)\n+        {\n+            return (pa->nHeight - pb->nHeight) <= GetWorkSwitchThreshold();\n+        }\n+\n         // First sort by most total work, ...\n         if (pa->nChainWork > pb->nChainWork) return false;\n         if (pa->nChainWork < pb->nChainWork) return true;\n@@ -1870,7 +1882,7 @@ bool static DisconnectTip(CValidationState &state) {\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n         // ignore validation errors in resurrected transactions\n         list<CTransaction> removed;\n-        CValidationState stateDummy; \n+        CValidationState stateDummy;\n         if (!tx.IsCoinBase())\n             if (!AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))\n                 mempool.remove(tx, removed, true);\n@@ -1985,6 +1997,8 @@ void static FindMostWorkChain() {\n \n     // We have a new best.\n     chainMostWork.SetTip(pindexNew);\n+    // no longer treat this branch as tainted now that we accepted it\n+    pindexNew->fTainted = false;\n }\n \n // Try to activate to the most-work chain (thereby connecting it).\n@@ -2065,6 +2079,12 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n     pindexNew->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n+\n+    // check if we need to set the branch as one that contains redlisted items\n+    // which is either when the parent is tainted, or if we are adding a tainted block\n+    if(pindexNew->pprev != NULL && (pindexNew->pprev->fTainted || IsRedlistedBlock(block, pcoinsTip)) )\n+        pindexNew->fTainted = true;\n+\n     setBlockIndexValid.insert(pindexNew);\n \n     if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n@@ -3690,7 +3710,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n-        { \n+        {\n             LogPrint(\"mempool\", \"%s from %s %s was not accepted into the memory pool: %s\\n\", tx.GetHash().ToString(),\n                 pfrom->addr.ToString(), pfrom->cleanSubVer,\n                 state.GetRejectReason());"
      },
      {
        "sha": "5115285f747dd1c78a773bb23bae42497d1a2466",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -716,6 +716,9 @@ class CBlockIndex\n     unsigned int nBits;\n     unsigned int nNonce;\n \n+    // marks this branch as one that contains redlisted blocks\n+    bool fTainted;\n+\n     // (memory only) Sequencial id assigned to distinguish order in which blocks are received.\n     uint32_t nSequenceId;\n \n@@ -738,6 +741,8 @@ class CBlockIndex\n         nTime          = 0;\n         nBits          = 0;\n         nNonce         = 0;\n+\n+        fTainted = false;\n     }\n \n     CBlockIndex(CBlockHeader& block)\n@@ -759,6 +764,8 @@ class CBlockIndex\n         nTime          = block.nTime;\n         nBits          = block.nBits;\n         nNonce         = block.nNonce;\n+\n+        fTainted = false;\n     }\n \n     CDiskBlockPos GetBlockPos() const {"
      },
      {
        "sha": "3aaf309bd7360b3612fa77ca80b3077274c15205",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -8,6 +8,7 @@\n #include \"core.h\"\n #include \"main.h\"\n #include \"net.h\"\n+#include \"redlist.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet.h\"\n #endif\n@@ -161,12 +162,36 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             if (tx.IsCoinBase() || !IsFinalTx(tx, pindexPrev->nHeight + 1))\n                 continue;\n \n+            // Check Redlist against every CTxOut\n+            bool redlistedTxOut = false;\n+            bool redlistedTxIn = false;\n+            BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+            {\n+                if (IsRedlistedScriptPubKey(getRedList(), txout.scriptPubKey))\n+                {\n+                    LogPrintf(\"Transaction rejected.\\n\");\n+                    redlistedTxOut = true;\n+                    break;\n+                }\n+            }\n+            if (redlistedTxOut) continue;\n+\n             COrphan* porphan = NULL;\n             double dPriority = 0;\n             int64_t nTotalIn = 0;\n             bool fMissingInputs = false;\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             {\n+                if(view.HaveInputs(tx) && !tx.IsCoinBase()) \n+                {\n+                    if(IsRedlistedScriptSig(getRedList(), txin.scriptSig))\n+                    {\n+                        LogPrintf(\"Transaction rejected.\\n\");\n+                        redlistedTxIn = true;\n+                        break;\n+                    }\n+                }\n+                \n                 // Read prev transaction\n                 if (!view.HaveCoins(txin.prevout.hash))\n                 {\n@@ -204,6 +229,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n                 dPriority += (double)nValueIn * nConf;\n             }\n+            if(redlistedTxIn) continue;\n             if (fMissingInputs) continue;\n \n             // Priority is sum(valuein * age) / modified_txsize"
      },
      {
        "sha": "266662b756faf49a16941d3637642f8c2db38aec",
        "filename": "src/redlist.cpp",
        "status": "added",
        "additions": 237,
        "deletions": 0,
        "changes": 237,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/redlist.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/redlist.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/redlist.cpp?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -0,0 +1,237 @@\n+#include \"redlist.h\"\n+#include \"main.h\"\n+#include \"base58.h\"\n+#include <curl/curl.h>\n+\n+using namespace std;\n+using namespace boost;\n+\n+RedList* globalRedlist;\n+\n+uint256 GetWorkSwitchThreshold()\n+{\n+    return REDLIST_SWITCH_THRESHOLD;\n+}\n+\n+bool IsRedlistedBlock(const CBlock& block, CCoinsViewCache* view)\n+{\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+    {\n+        if(IsRedlistedTransaction(tx, view))\n+            return true;\n+    }\n+\n+    return false;\n+}\n+\n+class CScriptKeysVisitor : public boost::static_visitor<void> {\n+private:\n+    std::vector<CKeyID> &vKeys;\n+\n+public:\n+    CScriptKeysVisitor(std::vector<CKeyID> &vKeysIn) : vKeys(vKeysIn) {}\n+\n+    void Process(const CScript &script) {\n+        txnouttype type;\n+        std::vector<CTxDestination> vDest;\n+        int nRequired;\n+        if (ExtractDestinations(script, type, vDest, nRequired)) {\n+            BOOST_FOREACH(const CTxDestination &dest, vDest)\n+                boost::apply_visitor(*this, dest);\n+        }\n+    }\n+\n+    void operator()(const CKeyID &keyId) {\n+        vKeys.push_back(keyId);\n+    }\n+\n+    void operator()(const CScriptID &scriptId) {}\n+\n+    void operator()(const CNoDestination &none) {}\n+};\n+\n+void ExtractKeys(const CScript& scriptPubKey, std::vector<CKeyID> &vKeys) {\n+    CScriptKeysVisitor(vKeys).Process(scriptPubKey);\n+}\n+\n+bool IsRedlistedTransaction(const CTransaction& tx, CCoinsViewCache* view)\n+{\n+    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    {\n+        if (IsRedlistedScriptPubKey(getRedList(), txout.scriptPubKey))\n+            return true;\n+    }\n+\n+    // if it's not available, then the output is spent\n+    if(view->HaveInputs(tx) && !tx.IsCoinBase()) {\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            if (IsRedlistedScriptSig(getRedList(), txin.scriptSig))\n+                return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+bool IsRedlistedPubKey(RedList* rlist, basic_string<char> hashPubKey)\n+{\n+    return !(rlist->find(hashPubKey) == rlist->end());\n+}\n+\n+bool IsRedlistedScriptPubKey(RedList* rlist, CScript scriptPubKey)\n+{\n+    LogPrintf(\"Checking scriptPubKey: \\n%d\\n\", scriptPubKey.ToString());\n+    std::vector<CKeyID> vKeys;\n+    ExtractKeys(scriptPubKey, vKeys);\n+    BOOST_FOREACH(const CKeyID &key, vKeys)\n+    {\n+        CBitcoinAddress addr;\n+        addr.Set(key);\n+        LogPrintf(\"Transaction contained key: %s\\n\", addr.ToString());\n+        if(IsRedlistedPubKey(getRedList(), addr.ToString()))\n+        {    \n+            LogPrintf(\"CScript contains redlisted key: %s\\n\", addr.ToString());\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+bool IsRedlistedScriptSig(RedList* rlist, CScript scriptSig)\n+{\n+    \n+    LogPrintf(\"Checking scriptSig: \\n%s\\n\", scriptSig.ToString()); \n+    CScript::const_iterator pbeg = scriptSig.begin();\n+    CScript::const_iterator pend = scriptSig.end();\n+    opcodetype opcode;\n+    vector <unsigned char> vch;\n+   \n+    while(pbeg < pend)\n+    {\n+        scriptSig.GetOp(pbeg, opcode, vch);\n+        CBitcoinAddress addr;\n+        addr.Set(CKeyID(Hash160(vch)));\n+        if(IsRedlistedPubKey(getRedList(), addr.ToString()))\n+        {\n+            LogPrintf(\"ScriptSig contains redlisted key: %s\\n\", addr.ToString());\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+class curlbuffer {\n+    public:\n+        char* ptr;\n+        size_t len;\n+\n+        curlbuffer()\n+        {\n+            len = 0;\n+            ptr = (char*) malloc(sizeof(char)*1);\n+            ptr[0] = '\\0';\n+        }\n+};\n+\n+size_t writefunc(char* ptr, size_t size, size_t nmemb, curlbuffer* b)\n+{\n+    size_t new_len = b->len + size*nmemb;\n+    b->ptr = (char*) realloc(b->ptr, new_len+1);\n+    if (b->ptr == NULL) {\n+        fprintf(stderr, \"realloc() failed\\n\");\n+        return 0;\n+    }\n+\n+    memcpy(b->ptr+b->len, ptr, size*nmemb);\n+    b->ptr[new_len] = '\\0';\n+    b->len = new_len;\n+\n+    return size*nmemb;\n+}\n+\n+/**\n+ * Create a new redlist and return the pointer\n+ */\n+RedList* buildRedList()\n+{\n+    RedList* rList = new RedList;\n+    CURL* curl;\n+    CURLcode res;\n+    curlbuffer* buffer = new curlbuffer();\n+    basic_string<char> body;\n+\n+    // TODO init can only be done once...\n+    curl = curl_easy_init();\n+\n+    // TODO error handling\n+    if(!curl) {\n+        LogPrintf(\"Could not init curl.\");\n+        return NULL;\n+    }\n+\n+    curl_easy_setopt(curl, CURLOPT_URL, REDLIST_URL);\n+    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);\n+    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n+    curl_easy_setopt(curl, CURLOPT_WRITEDATA, buffer);\n+\n+    // perform the request, res will get the return code\n+    res = curl_easy_perform(curl);\n+\n+    // check for errors\n+    // TODO exit?\n+    if(res != CURLE_OK) {\n+        LogPrintf(\"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n+        curl_easy_cleanup(curl);\n+        return NULL;\n+    }\n+\n+    // always cleanup\n+    curl_easy_cleanup(curl);\n+\n+    // get the list from the \"HTTPS\" source ;-)\n+    body = basic_string<char>(buffer->ptr);\n+\n+    // tokenize it\n+    tokenizer<> tok(body);\n+    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end(); ++beg)\n+    {\n+        rList->insert(*beg);\n+    }\n+\n+    return rList;\n+}\n+\n+void redlistAddress(basic_string<char> address)\n+{\n+    if(globalRedlist == NULL)\n+    {\n+        globalRedlist = new RedList;\n+    }\n+    globalRedlist->insert(address);\n+}\n+\n+RedList* getRedList() {\n+    // TODO rebuild if redlist is outdated\n+    if(globalRedlist == NULL) {\n+        updateRedList();\n+    }\n+\n+    return globalRedlist;\n+}\n+\n+void resetRedlist()\n+{\n+    globalRedlist = NULL;\n+}\n+\n+bool updateRedList() {\n+    RedList* list = buildRedList();\n+\n+    if(list == NULL ) {\n+        return false;\n+    }\n+\n+    globalRedlist = list;\n+    return true;\n+}"
      },
      {
        "sha": "cc59a09f0d87088f1b0cea5156212c88ea7e6a5f",
        "filename": "src/redlist.h",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/redlist.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/redlist.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/redlist.h?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -0,0 +1,74 @@\n+#include \"core.h\"\n+#include \"coins.h\"\n+#include \"rpcserver.h\"\n+\n+#include <boost/unordered_set.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/case_conv.hpp>\n+#include <boost/functional/hash.hpp>\n+#include <boost/tokenizer.hpp>\n+\n+#ifndef REDLIST_URL\n+#   define REDLIST_URL \"https://redlist.url\"\n+#endif\n+\n+#ifndef REDLIST_SWITCH_THRESHOLD\n+#   define REDLIST_SWITCH_THRESHOLD 2             //2 blocks\n+#endif\n+\n+using namespace std;\n+using namespace boost;\n+\n+struct string_ihash: std::unary_function<std::basic_string<char>, std::size_t>\n+{\n+    std::size_t operator()(std::basic_string<char> const& x) const {\n+        boost::hash<std::basic_string<char> > hasher;\n+        std::basic_string<char> copy = std::basic_string<char>(x);\n+        boost::to_lower(copy);\n+        return hasher(copy);\n+    }\n+};\n+\n+struct string_iequals: std::binary_function<std::basic_string<char>, std::basic_string<char>, bool>\n+{\n+    bool operator()(std::basic_string<char> const& x, std::basic_string<char> const& y) const {\n+        return boost::iequals<std::basic_string<char>, std::basic_string<char> >(x, y);\n+    }\n+};\n+\n+/*\n+ * Unordered list storing the actual red list.\n+ * Function contains(x) is approximately O(1).\n+ */\n+typedef boost::unordered_set<\n+    std::basic_string<char>,\n+    string_ihash,\n+    string_iequals\n+> RedList;\n+\n+/*\n+ * Checks if the given hashPubKey is contained in the red list.\n+ */\n+bool IsRedlistedPubKey(RedList* rlist, std::basic_string<char> hashPubKey);\n+bool IsRedlistedBlock(const CBlock& block, CCoinsViewCache* view);\n+bool IsRedlistedTransaction(const CTransaction& tx, CCoinsViewCache* view);\n+bool IsRedlistedScriptPubKey(RedList* rlist, CScript scriptPubKey);\n+bool IsRedlistedScriptSig(RedList* rlist, CScript scriptPubKey);\n+\n+void redlistAddress(std::basic_string<char> address);\n+void resetRedlist();\n+\n+/* Builds a new redlist from the redlist source\n+ */\n+RedList* buildRedList();\n+\n+/* Get a redlist.\n+ * Will not rebuild it from source if it exists and is not outdated.\n+ */\n+RedList* getRedList();\n+\n+/* Force an update of the global redlist\n+ */\n+bool updateRedList();\n+\n+uint256 GetWorkSwitchThreshold();"
      },
      {
        "sha": "f4969026f01fcca37ac5666577f7c7fbe50bf8a7",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 1,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b185a620e30c434c2ee1b462eebf681ac2b04722/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b185a620e30c434c2ee1b462eebf681ac2b04722/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=b185a620e30c434c2ee1b462eebf681ac2b04722",
        "patch": "@@ -4,7 +4,8 @@\n #include \"miner.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n-\n+#include \"redlist.h\"\n+#include \"base58.h\"\n #include <boost/test/unit_test.hpp>\n \n extern void SHA256Transform(void* pstate, void* pinput, const void* pinit);\n@@ -151,6 +152,49 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     delete pblocktemplate;\n     mempool.clear();\n \n+    // redlisted address contained in scriptPubKey\n+    resetRedlist();\n+    redlistAddress(\"1KtpquhXunViNmHFSi5yCcSjt71BVskh8G\"); \n+    BOOST_CHECK(IsRedlistedPubKey(getRedList(), \"1KtpquhXunViNmHFSi5yCcSjt71BVskh8G\")); \n+    \n+    tx.vin[0].scriptSig = CScript() << OP_1;\n+    tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n+    tx.vout[0].nValue = 4900000000LL;\n+    \n+    CScript scriptPK; \n+    CBitcoinAddress address(\"1KtpquhXunViNmHFSi5yCcSjt71BVskh8G\");\n+    scriptPK.SetDestination(address.Get());\n+\n+    tx.vout[0].scriptPubKey = scriptPK;\n+    BOOST_CHECK(IsRedlistedScriptPubKey(getRedList(), tx.vout[0].scriptPubKey));\n+\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11)); \n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 1);                     //block contains only one tx\n+    BOOST_CHECK(pblocktemplate->block.vtx.at(0).IsCoinBase());                  //and that tx is coinbase\n+    delete pblocktemplate;\n+    mempool.clear();\n+\n+    // redlisted address contained in scriptSig\n+    // address & scriptSig taken from http://blockexplorer.com/tx/3e85062614d70fe2654236d149242601dbbee85593ba58dc016c7f4871330e4e\n+    resetRedlist();\n+    redlistAddress(\"1CpQDRUhU72gY3E1ksUfRFxC7oZpf3rGbZ\"); \n+    BOOST_CHECK(IsRedlistedPubKey(getRedList(), \"1CpQDRUhU72gY3E1ksUfRFxC7oZpf3rGbZ\"));  \n+    \n+    tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n+    tx.vout[0].nValue = 4900000000LL;\n+    \n+    tx.vin[0].scriptSig = CScript() << ParseHex(\"3046022100ead0092049a3bd5b65771f2f38d1423d76de78be89b10bb8a67dc64ed7500080022100ee471dd4291a9c6b45926a32c378895c9f5dd0087d309047a3dfe7446586bea301\") << ParseHex(\"040c34bef1b5fa0e76bc2a4da88943ad272468151236ec54463f5bd72a8dcb610e7bac45c840034174293121c3f88b1850a06927df119d18e28b1e978362341819\");\n+    BOOST_CHECK(IsRedlistedScriptSig(getRedList(), tx.vin[0].scriptSig));\n+    \n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11)); \n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 1);                     //block contains only one tx\n+    BOOST_CHECK(pblocktemplate->block.vtx.at(0).IsCoinBase());                  //and that tx is coinbase\n+    delete pblocktemplate;\n+    mempool.clear();\n+    \n     // coinbase in mempool\n     tx.vin.resize(1);\n     tx.vin[0].prevout.SetNull();"
      }
    ]
  }
]