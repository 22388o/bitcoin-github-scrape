[
  {
    "sha": "c067d855004d0b3b5e66aea78d92a01c435a95ed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMDY3ZDg1NTAwNGQwYjNiNWU2NmFlYTc4ZDkyYTAxYzQzNWE5NWVk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-07-12T18:53:14Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2020-01-08T21:10:17Z"
      },
      "message": "Add package-acceptance logic to mempool\n\nAccepting a single transaction to the mempool only succeeds if (among other\nthings) the feerate of the transaction is greater than both the min relay fee\nand the mempool min fee. Consequently, a transaction below the minimum fee\nmay not be accepted to the mempool, even if we later learn of a transaction\nwith a high relay fee that depends on it.\n\nThis commit adds a function that will accept a package of transactions to the\nmempool, with the following restrictions:\n\n- All package transactions must be direct parents of the final transaction.\n  This is a simple heuristic for ensuring that a candidate list of transactions\n  is in fact a package (we wouldn't want arbitrary transactions to be paying\n  for random low feerate transactions)\n\n- The feerate of the package, as a whole, exceeds the mempool min fee and the\n  min relay fee.\n\n- No transactions in the mempool conflict with any transactions in the package.\n  This is a simplification that makes the logic easier to write. Without this\n  requirement, we would need to do additional checks to ensure that no parent\n  transaction would evict a transaction from the mempool that some other child\n  depends on.\n\n- The ancestor/descendant size limits are calculated assuming that any mempool\n  ancestor of any candidate transaction is an ancestor of all the candidate\n  transactions.\n  This allows for doing simpler calculations to ensure that we're staying\n  within the mempool's package limits. If we eliminated this, we would need to\n  do much more careful package calculations for each candidate transaction and each\n  in-mempool ancestor.\n\nThis commit does not include any accessor function for utilizing this logic (eg\nby exposing this function at the p2p or rpc layer).",
      "tree": {
        "sha": "05531a6d0c631ab45da3b945ec5c80c67de95ed7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05531a6d0c631ab45da3b945ec5c80c67de95ed7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c067d855004d0b3b5e66aea78d92a01c435a95ed",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c067d855004d0b3b5e66aea78d92a01c435a95ed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c067d855004d0b3b5e66aea78d92a01c435a95ed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c067d855004d0b3b5e66aea78d92a01c435a95ed/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6196e930018181301b5972842ae384ea4288ff34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6196e930018181301b5972842ae384ea4288ff34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6196e930018181301b5972842ae384ea4288ff34"
      }
    ],
    "stats": {
      "total": 189,
      "additions": 174,
      "deletions": 15
    },
    "files": [
      {
        "sha": "4a8da1d5c2d218feffd262e90c9a12ae48a54d2f",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c067d855004d0b3b5e66aea78d92a01c435a95ed/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c067d855004d0b3b5e66aea78d92a01c435a95ed/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=c067d855004d0b3b5e66aea78d92a01c435a95ed",
        "patch": "@@ -899,6 +899,12 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n     CTransactionRef ptx = mempool.get(outpoint.hash);\n+    if (!ptx) {\n+        // If a coin is missing from the mempool, check to see if it's part of\n+        // a candidate package\n+        auto it = package_tx.find(outpoint.hash);\n+        if (it != package_tx.end()) ptx = it->second;\n+    }\n     if (ptx) {\n         if (outpoint.n < ptx->vout.size()) {\n             coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);"
      },
      {
        "sha": "5257fa205822fb606f509fe04ce6ee6e215e7542",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c067d855004d0b3b5e66aea78d92a01c435a95ed/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c067d855004d0b3b5e66aea78d92a01c435a95ed/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=c067d855004d0b3b5e66aea78d92a01c435a95ed",
        "patch": "@@ -752,8 +752,12 @@ class CTxMemPool\n  */\n class CCoinsViewMemPool : public CCoinsViewBacked\n {\n+public:\n+    void AddPotentialTransaction(const CTransactionRef& ptx) { package_tx.emplace(ptx->GetHash(), ptx); }\n+\n protected:\n     const CTxMemPool& mempool;\n+    std::map<uint256, const CTransactionRef> package_tx;\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);"
      },
      {
        "sha": "ed4d41e5d7c4873543a9d9516686c761ed3039d1",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 164,
        "deletions": 15,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c067d855004d0b3b5e66aea78d92a01c435a95ed/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c067d855004d0b3b5e66aea78d92a01c435a95ed/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=c067d855004d0b3b5e66aea78d92a01c435a95ed",
        "patch": "@@ -235,10 +235,9 @@ bool TestLockPointValidity(const LockPoints* lp)\n     return true;\n }\n \n-bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n+static bool CheckSequenceLocks(CCoinsViewCache &view, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n-    AssertLockHeld(pool.cs);\n \n     CBlockIndex* tip = ::ChainActive().Tip();\n     assert(tip != nullptr);\n@@ -260,14 +259,12 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n         lockPair.second = lp->time;\n     }\n     else {\n-        // CoinsTip() contains the UTXO set for ::ChainActive().Tip()\n-        CCoinsViewMemPool viewMemPool(&::ChainstateActive().CoinsTip(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n             const CTxIn& txin = tx.vin[txinIndex];\n             Coin coin;\n-            if (!viewMemPool.GetCoin(txin.prevout, coin)) {\n+            if (!view.GetCoin(txin.prevout, coin)) {\n                 return error(\"%s: Missing input\", __func__);\n             }\n             if (coin.nHeight == MEMPOOL_HEIGHT) {\n@@ -307,6 +304,14 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n+bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n+{\n+    AssertLockHeld(cs_main);\n+    CCoinsViewMemPool viewMemPool(&::ChainstateActive().CoinsTip(), pool);\n+    CCoinsViewCache view(&viewMemPool);\n+    return CheckSequenceLocks(view, tx, flags, lp, useExistingLockPoints);\n+}\n+\n // Returns the script flags which should be checked for a given block\n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n \n@@ -459,11 +464,14 @@ class MemPoolAccept\n     // Single transaction acceptance\n     bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+    // Multiple transaction acceptance\n+    bool AcceptMultipleTransactions(const std::list<CTransactionRef>& tx_list, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n private:\n     // All the intermediate state that gets passed between the various levels\n     // of checking a given transaction.\n     struct Workspace {\n-        Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        Workspace(const CTransactionRef& ptx, bool _cpfpable) : m_cpfpable(_cpfpable), m_ptx(ptx), m_hash(ptx->GetHash()) {}\n         std::set<uint256> m_conflicts;\n         CTxMemPool::setEntries m_all_conflicting;\n         CTxMemPool::setEntries m_ancestors;\n@@ -474,6 +482,8 @@ class MemPoolAccept\n         CAmount m_conflicting_fees;\n         size_t m_conflicting_size;\n \n+        const bool m_cpfpable; // whether the fee-checks for this tx can be satisfied by another tx\n+\n         const CTransactionRef& m_ptx;\n         const uint256& m_hash;\n     };\n@@ -519,7 +529,8 @@ class MemPoolAccept\n     CCoinsViewMemPool m_viewmempool;\n     CCoinsView m_dummy;\n \n-    // The package limits in effect at the time of invocation.\n+    // Package acceptance uses a heuristic to test against these limits,\n+    // separately from what is done in PreChecks().\n     const size_t m_limit_ancestors;\n     const size_t m_limit_ancestor_size;\n     // These may be modified while evaluating a transaction (eg to account for\n@@ -537,7 +548,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Copy/alias what we need out of args\n     TxValidationState &state = args.m_state;\n     const int64_t nAcceptTime = args.m_accept_time;\n-    const bool bypass_limits = args.m_bypass_limits;\n+    const bool bypass_limits = args.m_bypass_limits || ws.m_cpfpable;\n     const CAmount& nAbsurdFee = args.m_absurd_fee;\n     std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;\n \n@@ -655,9 +666,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Only accept BIP68 sequence locked transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n-    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-    // CoinsViewCache instead of create its own\n-    if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+    if (!CheckSequenceLocks(m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n     CAmount nFees = 0;\n@@ -698,8 +707,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         return state.Invalid(TxValidationResult::TX_NOT_STANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-    // No transactions are allowed below minRelayTxFee except from disconnected\n-    // blocks\n+    // No transactions are allowed below minRelayTxFee/mempool min fee except\n+    // from disconnected blocks\n     if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n     if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -962,7 +971,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n     TxValidationState &state = args.m_state;\n-    const bool bypass_limits = args.m_bypass_limits;\n+    const bool bypass_limits = args.m_bypass_limits || ws.m_cpfpable;\n \n     CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n     CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n@@ -1009,7 +1018,7 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n     AssertLockHeld(cs_main);\n     LOCK(m_pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n \n-    Workspace workspace(ptx);\n+    Workspace workspace(ptx, /* m_cpfpable */ false);\n \n     if (!PreChecks(args, workspace)) return false;\n \n@@ -1033,6 +1042,146 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n     return true;\n }\n \n+\n+bool MemPoolAccept::AcceptMultipleTransactions(const std::list<CTransactionRef>& tx_list, ATMPArgs& args)\n+{\n+    AssertLockHeld(cs_main);\n+    LOCK(m_pool.cs);\n+\n+    std::list<Workspace> tx_workspaces;\n+\n+    for (const CTransactionRef& ptx : tx_list) {\n+        // The last transaction must be validated for making it past the fee\n+        // checks on its own, to prevent packages from including low-fee,\n+        // unnecessary children that are attached to higher fee parents.\n+        tx_workspaces.emplace_back(Workspace(ptx, ptx != tx_list.back()));\n+        Workspace &ws = tx_workspaces.back();\n+\n+        if (!PreChecks(args, ws)) return false;\n+\n+        // For now, do not allow replacements in package transactions. If we\n+        // relax this, we would need to check that no child transaction depends\n+        // on any in-mempool transaction that conflicts with any package\n+        // transaction.\n+        if (!ws.m_conflicts.empty()) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, strprintf(\"mempool conflicts with tx %s\", ptx->GetHash().ToString()));\n+        }\n+        // Add this transaction to our coinsview, so that subsequent\n+        // transactions in this package will have their inputs available.\n+        m_viewmempool.AddPotentialTransaction(ptx);\n+    }\n+\n+    // Check overall package feerate\n+    size_t total_size=0;\n+    CAmount total_fee=0;\n+    uint64_t total_count = tx_list.size();\n+    for (const Workspace& ws : tx_workspaces) {\n+        total_size += ws.m_entry->GetTxSize();\n+        total_fee += ws.m_modified_fees;\n+    }\n+    if (!CheckFeeRate(total_size, total_fee, args.m_state)) return false;\n+\n+    // The ancestor/descendant limit calculations in PreChecks() will be overly\n+    // permissive, because not all ancestors will be known as we descend down\n+    // the package. Thus the ancestor checks done by\n+    // CalculateMemPoolAncestors() will be incomplete. If any ancestor or\n+    // descendant limit is violated in one of those checks, however, we know\n+    // the package will not be accepted when we include all ancestors, as the\n+    // ancestor/descendant size/counts only go up as we add more ancestors to\n+    // each transaction.\n+    // We will end up needing to recalculate setAncestors for each transaction\n+    // prior to calling Finalize, but we should do the correct package-size\n+    // calculations before we call ScriptChecks(), to avoid CPU-DoS.\n+\n+    // For now, do something conservative -- assume that the union of ancestors\n+    // of each transaction is an ancestor of every transaction, for package\n+    // size purposes.\n+    CTxMemPool::setEntries all_ancestors;\n+    for (const Workspace& ws : tx_workspaces) {\n+        all_ancestors.insert(ws.m_ancestors.begin(), ws.m_ancestors.end());\n+    }\n+\n+    if (total_count + all_ancestors.size() > m_limit_ancestors) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, strprintf(\"exceeds ancestor count limit [package: %u limit: %u]\", total_count + all_ancestors.size(), m_limit_ancestors));\n+    }\n+\n+    // Check the package limits for every ancestor, assuming the whole package\n+    // descends from each.\n+    size_t ancestor_size = total_size;\n+    for (auto tx_iter : all_ancestors) {\n+        if (tx_iter->GetSizeWithDescendants() + total_size > m_limit_descendant_size) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", tx_iter->GetTx().GetHash().ToString(), m_limit_descendant_size));\n+        }\n+        if (tx_iter->GetCountWithDescendants() + total_count > m_limit_descendants) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", tx_iter->GetTx().GetHash().ToString(), m_limit_descendants));\n+        }\n+        ancestor_size += tx_iter->GetTxSize();\n+    }\n+\n+    // In case we have no in-mempool ancestors, we must check the transaction\n+    // package itself.\n+    if (total_size > m_limit_descendant_size) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", tx_list.front()->GetHash().ToString(), m_limit_descendant_size));\n+    }\n+    if (ancestor_size > m_limit_ancestor_size) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, strprintf(\"exceeds ancestor size limit for tx %s [limit: %u]\", tx_list.back()->GetHash().ToString(), m_limit_ancestor_size));\n+    }\n+\n+    // Make sure all transactions are ancestors of the last one.\n+    // For now, just check that the last transaction has all prior transactions\n+    // as direct inputs. We can relax this in the future for bigger packages.\n+    std::set<uint256> last_tx_parents;\n+    for (auto input : tx_list.back()->vin) {\n+        last_tx_parents.insert(input.prevout.hash);\n+    }\n+    for (auto ptx : tx_list) {\n+        if (ptx == tx_list.back()) break;\n+        if (last_tx_parents.count(ptx->GetHash()) == 0) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"only direct parents are allowed in package\");\n+        }\n+    }\n+\n+    // Do the script checks after all policy checks are done\n+    std::vector<PrecomputedTransactionData> txdata;\n+    txdata.reserve(tx_list.size());\n+    for (auto wit = tx_workspaces.begin(); wit != tx_workspaces.end(); ++wit) {\n+        txdata.emplace_back(*wit->m_ptx);\n+        if (!PolicyScriptChecks(args, *wit, txdata.back())) return false;\n+    }\n+\n+    // This package should be accepted except possibly for failing in\n+    // TrimToSize(), which we can't exercise without actually adding to the\n+    // mempool and seeing what would happen. Note that we are not adding\n+    // these transactions to the script cache, unlike in the single-tx case.\n+    if (args.m_test_accept) return true;\n+\n+    // Add everything to the mempool, and make sure the last transaction makes\n+    // it in.\n+    size_t i=0;\n+    for (auto wit = tx_workspaces.begin(); wit != tx_workspaces.end(); ++wit, ++i) {\n+        // Recheck the scripts with consensus flags and cache script execution\n+        // success. We have to wait until all the inputs are in the mempool or\n+        // in the utxo set (for now) before we can invoke this. This should\n+        // not fail unless there's a logic bug in our script validation, but if\n+        // it somehow were to fail on some child tx, we would potentially be\n+        // allowing parents into the mempool with this logic.\n+        if (!ConsensusScriptChecks(args, *wit, txdata[i])) return false;\n+\n+        // Recalculate ancestors for every transaction after the first, because\n+        // previously the ancestor sets were missing package transactions that\n+        // were not yet in the mempool at the time PreChecks() was called.\n+        if (wit != tx_workspaces.begin()) {\n+            wit->m_ancestors.clear();\n+            std::string dummy_string;\n+            // Don't worry about the return value here; it must pass based on\n+            // the checks above. TODO: assert on passing?\n+            m_pool.CalculateMemPoolAncestors(*(wit->m_entry), wit->m_ancestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, dummy_string);\n+        }\n+        if (!Finalize(args, *wit)) return false;\n+    }\n+    return true;\n+}\n+\n } // anon namespace\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/"
      }
    ]
  },
  {
    "sha": "6a3bdba0746efe9a38f560bb116a8425e0410cb7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTNiZGJhMDc0NmVmZTlhMzhmNTYwYmIxMTZhODQyNWUwNDEwY2I3",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-07-16T19:59:32Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2020-01-09T03:45:59Z"
      },
      "message": "Implement package relay for 2-tx packages from the orphan pool\n\nExposes a simple use case for package relay -- if we receive a child\ntransaction that is missing a parent, then we request the parent from our\npeers.\n\nIf a peer responds with a transaction that is rejected from the mempool due to\nfeerate, we have an opportunity to accept that parent along with the child, if\nthe child's feerate is sufficiently high and the child is missing no other\nparents.",
      "tree": {
        "sha": "531da32be675a904879d034637ca46549ba5b11b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/531da32be675a904879d034637ca46549ba5b11b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a3bdba0746efe9a38f560bb116a8425e0410cb7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a3bdba0746efe9a38f560bb116a8425e0410cb7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a3bdba0746efe9a38f560bb116a8425e0410cb7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a3bdba0746efe9a38f560bb116a8425e0410cb7/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c067d855004d0b3b5e66aea78d92a01c435a95ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c067d855004d0b3b5e66aea78d92a01c435a95ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c067d855004d0b3b5e66aea78d92a01c435a95ed"
      }
    ],
    "stats": {
      "total": 158,
      "additions": 122,
      "deletions": 36
    },
    "files": [
      {
        "sha": "e24a5f18ff13dc23a08830d131aa86dcdce31623",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=6a3bdba0746efe9a38f560bb116a8425e0410cb7",
        "patch": "@@ -41,7 +41,8 @@ enum class TxValidationResult {\n      * Currently this is only used if the transaction already exists in the mempool or on chain.\n      */\n     TX_CONFLICT,\n-    TX_MEMPOOL_POLICY,        //!< violated mempool's fee/size/descendant/RBF/etc limits\n+    TX_MEMPOOL_POLICY,        //!< violated mempool's size/descendant/RBF/etc limits\n+    TX_MEMPOOL_INSUFFICIENT_FEE, //!< violated mempool's feerate requirements\n };\n \n /** A \"reason\" why a block was invalid, suitable for determining whether the"
      },
      {
        "sha": "2dc10737a616a956dd26992b5576ea7f8af71be7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 33,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6a3bdba0746efe9a38f560bb116a8425e0410cb7",
        "patch": "@@ -742,6 +742,20 @@ void RequestTx(CNodeState* state, const uint256& txid, std::chrono::microseconds\n     peer_download_state.m_tx_process_time.emplace(process_time, txid);\n }\n \n+// Add to a peer's orphan_work_set after processing a given transaction.\n+void UpdateOrphanWorkSet(const CTransaction& tx, CNode *peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+{\n+    const uint256& hash = tx.GetHash();\n+    for (unsigned int i=0; i < tx.vout.size(); i++) {\n+        auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(hash, i));\n+        if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                peer->orphan_work_set.insert(elem->first);\n+            }\n+        }\n+    }\n+}\n+\n } // namespace\n \n // This function is used for testing the stale tip eviction logic, see\n@@ -1078,6 +1092,7 @@ static bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state,\n     case TxValidationResult::TX_WITNESS_MUTATED:\n     case TxValidationResult::TX_CONFLICT:\n     case TxValidationResult::TX_MEMPOOL_POLICY:\n+    case TxValidationResult::TX_MEMPOOL_INSUFFICIENT_FEE:\n         break;\n     }\n     if (message != \"\") {\n@@ -2504,15 +2519,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!AlreadyHave(inv) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n-            RelayTransaction(tx.GetHash(), *connman);\n-            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));\n-                if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n-                    for (const auto& elem : it_by_prev->second) {\n-                        pfrom->orphan_work_set.insert(elem->first);\n-                    }\n-                }\n-            }\n+            RelayTransaction(ptx->GetHash(), *connman);\n+            UpdateOrphanWorkSet(tx, pfrom);\n \n             pfrom->nLastTXTime = GetTime();\n \n@@ -2557,32 +2565,78 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 recentRejects->insert(tx.GetHash());\n             }\n         } else {\n-            if (!tx.HasWitness() && state.GetResult() != TxValidationResult::TX_WITNESS_MUTATED) {\n-                // Do not use rejection cache for witness transactions or\n-                // witness-stripped transactions, as they can have been malleated.\n-                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                assert(recentRejects);\n-                recentRejects->insert(tx.GetHash());\n-                if (RecursiveDynamicUsage(*ptx) < 100000) {\n+            // If this tx didn't make it in due to feerate, and there is a tx\n+            // in the orphan pool -- then maybe that tx is only missing this\n+            // one parent.\n+            // Try to process the pair as a package.\n+            bool added_as_package = false;\n+            if (state.GetResult() == TxValidationResult::TX_MEMPOOL_INSUFFICIENT_FEE) {\n+                std::list<std::map<uint256, COrphanTx>::iterator> orphans_missing_this_tx;\n+                for (size_t i=0; i<tx.vout.size(); ++i) {\n+                    auto it = mapOrphanTransactionsByPrev.find(COutPoint(tx.GetHash(), i));\n+                    if (it != mapOrphanTransactionsByPrev.end()) {\n+                        for (auto orphan_iter : it->second) orphans_missing_this_tx.push_back(orphan_iter);\n+                    }\n+                }\n+                if (!orphans_missing_this_tx.empty()) {\n+                    const COrphanTx &orphan_tx = orphans_missing_this_tx.front()->second;\n+                    // Pick the first transaction, and process the pair. If it's\n+                    // missing other inputs, this will of course fail.\n+                    std::list<CTransactionRef> package;\n+                    package.push_back(ptx);\n+                    package.push_back(orphan_tx.tx);\n+                    TxValidationState package_state;\n+                    if (AcceptPackageToMemoryPool(mempool, state, package, &lRemovedTxn, 0 /* nAbsurdFee */, false /* test_accept */)) {\n+                        LogPrintf(\"package accepted!!\\n\"); // XXX: improve logging\n+                        added_as_package = true;\n+                        mempool.check(&::ChainstateActive().CoinsTip());\n+                        EraseOrphanTx(orphan_tx.tx->GetHash());\n+                        for (auto package_tx : package) RelayTransaction(package_tx->GetHash(), *connman);\n+                        for (auto package_tx : package) UpdateOrphanWorkSet(*package_tx, pfrom);\n+\n+                        pfrom->nLastTXTime = GetTime();\n+\n+                        for (auto package_tx : package) {\n+                            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+                                    pfrom->GetId(),\n+                                    package_tx->GetHash().ToString(),\n+                                    mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n+                        }\n+\n+                        // Recursively process any orphan transactions that depended on these\n+                        ProcessOrphanTx(connman, pfrom->orphan_work_set, lRemovedTxn);\n+                    }\n+                }\n+            }\n+\n+            if (!added_as_package) {\n+                if (!tx.HasWitness() && state.GetResult() != TxValidationResult::TX_WITNESS_MUTATED) {\n+                    // Do not use rejection cache for witness transactions or\n+                    // witness-stripped transactions, as they can have been malleated.\n+                    // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+                    assert(recentRejects);\n+                    recentRejects->insert(tx.GetHash());\n+                    if (RecursiveDynamicUsage(*ptx) < 100000) {\n+                        AddToCompactExtraTransactions(ptx);\n+                    }\n+                } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {\n                     AddToCompactExtraTransactions(ptx);\n                 }\n-            } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n-\n-            if (pfrom->HasPermission(PF_FORCERELAY)) {\n-                // Always relay transactions received from whitelisted peers, even\n-                // if they were already in the mempool or rejected from it due\n-                // to policy, allowing the node to function as a gateway for\n-                // nodes hidden behind it.\n-                //\n-                // Never relay transactions that might result in being\n-                // disconnected (or banned).\n-                if (state.IsInvalid() && TxRelayMayResultInDisconnect(state)) {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n-                } else {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n-                    RelayTransaction(tx.GetHash(), *connman);\n+\n+                if (pfrom->HasPermission(PF_FORCERELAY)) {\n+                    // Always relay transactions received from whitelisted peers, even\n+                    // if they were already in the mempool or rejected from it due\n+                    // to policy, allowing the node to function as a gateway for\n+                    // nodes hidden behind it.\n+                    //\n+                    // Never relay transactions that might result in being\n+                    // disconnected (or banned).\n+                    if (state.IsInvalid() && TxRelayMayResultInDisconnect(state)) {\n+                        LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n+                    } else {\n+                        LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n+                        RelayTransaction(tx.GetHash(), *connman);\n+                    }\n                 }\n             }\n         }"
      },
      {
        "sha": "db2ca85a978f0f23b41f14dd3e1d989c2b3b9108",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 2,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6a3bdba0746efe9a38f560bb116a8425e0410cb7",
        "patch": "@@ -514,11 +514,11 @@ class MemPoolAccept\n     {\n         CAmount mempoolRejectFee = m_pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n         if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_INSUFFICIENT_FEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n         }\n \n         if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_INSUFFICIENT_FEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n         }\n         return true;\n     }\n@@ -1207,6 +1207,33 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     return res;\n }\n \n+bool AcceptPackageToMemoryPool(CTxMemPool& pool, TxValidationState& state,\n+        std::list<CTransactionRef>& tx_list,\n+        std::list<CTransactionRef>* replaced_transactions,\n+        const CAmount nAbsurdFee, bool test_accept)\n+{\n+    const CChainParams& chainparams = Params();\n+    AssertLockHeld(cs_main);\n+\n+    std::vector<COutPoint> coins_to_uncache;\n+    MemPoolAccept::ATMPArgs args { chainparams, state, GetTime(), replaced_transactions, /* m_bypass_limits */ false, nAbsurdFee, coins_to_uncache, test_accept };\n+    bool res = MemPoolAccept(pool).AcceptMultipleTransactions(tx_list, args);\n+\n+    if (!res) {\n+        // Remove coins that were not present in the coins cache beforehand;\n+        // this is to prevent memory DoS in case we receive a large number of\n+        // invalid transactions that attempt to overrun the in-memory coins cache\n+        // (`CCoinsViewCache::cacheCoins`).\n+        for (const COutPoint& hashTx : coins_to_uncache) {\n+            ::ChainstateActive().CoinsTip().Uncache(hashTx);\n+        }\n+    }\n+    // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n+    BlockValidationState stateDummy;\n+    ::ChainstateActive().FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n+    return res;\n+}\n+\n bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n                         std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)"
      },
      {
        "sha": "8ac305bd936c471363f30a912b7304dfa49b8b70",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a3bdba0746efe9a38f560bb116a8425e0410cb7/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=6a3bdba0746efe9a38f560bb116a8425e0410cb7",
        "patch": "@@ -278,6 +278,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTrans\n                         std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+bool AcceptPackageToMemoryPool(CTxMemPool& pool, TxValidationState &state, std::list<CTransactionRef>& tx_list,\n+                               std::list<CTransactionRef>* replaced_transactions,\n+                               const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n /** Get the BIP9 state for a given deployment at the current tip. */\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);\n "
      }
    ]
  }
]