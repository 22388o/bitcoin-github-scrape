meshcollider,2021-11-23 04:08:00,"@ryanofsky and @sipa, this addresses most of your review comments in #16807 so you may like to take a look, thanks!",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-976153462,976153462,
laanwj,2021-11-24 10:15:30,"> Notably, this removes the hardcoded GF1024 tables in favour of constexpr table generation.\n\nWow, this makes the compiler generate the table? Agree this is better for understandability, just wonder, does this have any noticeable impact on compilation time?",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-977731383,977731383,
meshcollider,2021-11-24 21:26:50,"> @laanwj Wow, this makes the compiler generate the table? Agree this is better for understandability, just wonder, does this have any noticeable impact on compilation time?\n\nIt shouldn't do, each element of the table only takes a few bitwise operations on 16 bit integers and the table is only 1024 elements.\n\n\nEDIT: a quick test compiling that file using clang takes 0.24 on master and 0.",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-978244288,978244288,
laanwj,2021-11-29 13:42:23,"I checked the assembly output from clang 13.0.0 and gcc 9.3.0 that the tables are indeed a) generated constants in `.rodata` and b) different from before (as expected and mentioned in the commit description) c) match between compilers.\n```\n	.type	_ZN6bech3212_GLOBAL__N_110GF1024_LOGE,@object # @_ZN6bech3212_GLOBAL__N_110GF1024_LOGE\n	.section	.rodata,""a"",@progbits\n	.p2align	1\n_ZN6bech3212",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-981645627,981645627,
MarcoFalke,2021-11-29 13:46:27,"> (I did not have anything to check them against).\n\nLooks like the `GF1024_EXP` you posted differs from the one that is removed in this pull?",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-981648812,981648812,
sipa,2021-11-29 13:55:34,"I will review in detail shortly, but I suspect that @meshcollider perhaps included the table changes corresponding to https://github.com/sipa/bech32/pull/64 here? There is Sage code there that generates the tables too, if someone wants something to compare against.",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-981656156,981656156,
laanwj,2021-11-29 13:56:33,"> Looks like the GF1024_EXP you posted differs from the one that is removed in this pull?\n\nBoth tables are. From the commit:\n\n> Note that the tables generated by this code are different to the previous\nhardcoded tables, because we simplify to encoding (e) as 1 || 0 rather\nthan 9 || 15 (as was done in PR 64 of the bech32 repo).\n\nI began this test with the intent to compare if they w",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-981656959,981656959,
meshcollider,2021-11-29 20:52:25,"I'm happy to split that commit into two, the first deriving the existing table and then the second modifying to the new table, if that would help review?\n\nThe length difference (1024 vs 1023) is just because the sage code also includes (a)^1023 = 1 = (a)^0.",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-982012078,982012078,
sipa,2021-11-29 22:48:54,"ACK 98124a63946d6f7d665864adbef35a863423ca47, with or without nits.",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-982093315,982093315,
meshcollider,2021-11-30 00:41:41,"Updated to address all of @sipa's nits, and split the GF1024 constexpr commit into two:\n- the first keeps the table the same, and generates it at compile time.\n- the second modifies the generation to use the simpler encoding from sipa/bech32#64",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-982171270,982171270,
laanwj,2021-11-30 15:43:32,"Thanks, re-checked:\n\n- gcc and clang output for `tables` of 1e24b1d385d64892389985afc058c83410c44311 matches the output of the sage script\n- gcc and clang output for `tables` of 83dc0b6392a99ea99e2d67d6893d715e48340023 matches `GF1024_EXP + GF1024_LOG` of the commit before it\n\nCode review ACK 1e24b1d385d64892389985afc058c83410c44311",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-982759557,982759557,
gruve-p,2021-11-30 15:51:18,ACK https://github.com/bitcoin/bitcoin/pull/23577/commits/1e24b1d385d64892389985afc058c83410c44311,https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-982766884,982766884,
sipa,2021-11-30 15:59:21,"Verified the generated tables by adding the assertions generated by this Sage code:\n\n```python\n# Binary field\nB.<b> = GF(2)\n# Polynomials over the binary field\nBP.<bp> = B[]\n# Encoder field GF(32)\nF.<f> = GF(32, modulus=bp^5 + bp^3 + 1, repr='int')\n# Polynomials over the encoder field\nFP.<fp> = F[]\n# Decoder field GF(1024)\nE.<e> = F.extension(modulus=fp^2 + F.fetch_int(9)*f",https://github.com/bitcoin/bitcoin/pull/23577#issuecomment-982774494,982774494,
sipa,2021-11-29 21:10:59,"This may be a bit of a philosophical point, touching on difference between specific field and field definition up to isomorphism.\n\nStill, I don't think it's sufficient (or at least confusing) to say it is *a* primitive element of GF(1024). It is specifically one of the roots of `x^2 + 9x + 23`. Things work out well because this is a primitive polynomial, and thus its root in the extension fiel",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758738152,758738152,src/bech32.cpp
sipa,2021-11-29 21:16:40,"How about this?\n\n> Define F=GF(32) as the set of polynomials over GF(2) modulo x^5 + x^3 + 1. We will represent elements of F as their integer encoding (e.g. 11 to mean x^3 + x + 1). Define E=GF(1024) as an extension of F, namely the set of polynomials over F modulo x^2+ 9x + 23. We will represent the element (ax + b) of F as the integer 32*a+b. Let e be the primitive element x of F (represent",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758741688,758741688,src/bech32.cpp
meshcollider,2021-11-29 21:20:41,"This is the definition of a primitive element. From Wikipedia:\n\n> In field theory, a primitive element of a finite field GF(q) is a generator of the multiplicative group of the field. In other words, α ∈ GF(q) is called a primitive element if it is a primitive (q − 1)th root of unity in GF(q); this means that each non-zero element of GF(q) can be written as α^i for some integer i.\n\nBut I a",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758744225,758744225,src/bech32.cpp
sipa,2021-11-29 21:31:38,"Thanks, though I still have a nit: you haven't defined an encoding for GF(32) elements, so the number 9 and 23 have no meaning.",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758751055,758751055,src/bech32.cpp
sipa,2021-11-29 22:29:38,"Nit: there is really no way to know these are the *actual* error locations. They're a guess, except under the assumption that no more than 2 substitution errors have been made, in which case they're guaranteed to be correct.\n\n",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758785746,758785746,doc/release-notes-16807.md
sipa,2021-11-29 22:32:21,Nit: the generate functions here don't really match our coding style.,https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758787342,758787342,src/bech32.cpp
sipa,2021-11-29 23:06:46,"I *assume* this doesn't actually materialize the tables twice, as `tables` would be an unused symbol in an anonymous namespace. Still, if you'd want to avoid the copying at compile-time (or rule out the risk that it gets emitted twice in the binary), these `GF1024_EXP` and `GF1024_LOG` variables could be references (e.g. `constexpr const std::array<int16_t, 1023>&`).",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r758804660,758804660,src/bech32.cpp
laanwj,2021-11-30 15:19:37,"After the recent push I cannot find `GF1024_EXP` and `GF1024_LOG` as symbols anymore in the compiled output. I think that makes sense as they're references to `tables` now, which is fine, just need to adapt my comparison script.",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r759384292,759384292,src/bech32.cpp
sipa,2021-11-30 15:58:37,"Using a const reference here is counterproductive, it seems: the result appears to be that the *reference* is constexpr, but the value it is bound to isn't because it is a temporary, so the actual SYNDROME_CONSTS values aren't constexpr (I noticed when trying to add static_assertions on them).",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r759423778,759423778,src/bech32.cpp
meshcollider,2021-11-30 17:14:50,"Ah okay, will revert this change then.",https://github.com/bitcoin/bitcoin/pull/23577#discussion_r759495339,759495339,src/bech32.cpp
