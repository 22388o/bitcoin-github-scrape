[
  {
    "sha": "f9ec3f0fadb11ee9889af977e16915f5d6e01944",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOWVjM2YwZmFkYjExZWU5ODg5YWY5NzdlMTY5MTVmNWQ2ZTAxOTQ0",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2015-02-23T19:27:44Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-22T19:53:48Z"
      },
      "message": "Add block pruning functionality\n\nThis adds a -prune=N option to bitcoind, which if set to N>0 will enable block\nfile pruning. When pruning is enabled, block and undo files will be deleted to\ntry to keep total space used by those files to below the prune target (N, in\nMB) specified by the user, subject to some constraints:\n\n- The last 288 blocks on the main chain are always kept (MIN_BLOCKS_TO_KEEP),\n- N must be at least 550MB (chosen as a value for the target that could\n  reasonably be met, with some assumptions about block sizes, orphan rates,\n  etc; see comment in main.h),\n- No blocks are pruned until chainActive is at least 100,000 blocks long (on\n  mainnet; defined separately for mainnet, testnet, and regtest in chainparams\n  as nPruneAfterHeight).\n\nThis unsets NODE_NETWORK if pruning is enabled.\n\nAlso included is an RPC test for pruning (pruning.py).\n\nThanks to @rdponticelli for earlier work on this feature; this is based in\npart off that work.",
      "tree": {
        "sha": "e709d74bad3f89ac7b6916f18a844038b48c8bfd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e709d74bad3f89ac7b6916f18a844038b48c8bfd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9ec3f0fadb11ee9889af977e16915f5d6e01944",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9ec3f0fadb11ee9889af977e16915f5d6e01944",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9ec3f0fadb11ee9889af977e16915f5d6e01944",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9ec3f0fadb11ee9889af977e16915f5d6e01944/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6ea3bcede1cbbf89486b9d67329e0110c4624ae"
      }
    ],
    "stats": {
      "total": 781,
      "additions": 744,
      "deletions": 37
    },
    "files": [
      {
        "sha": "f26cbee1e26f6028f38ea7b06e628edc9b359cad",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "added",
        "additions": 356,
        "deletions": 0,
        "changes": 356,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -0,0 +1,356 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test pruning code\n+# ********\n+# WARNING:\n+# This test uses 4GB of disk space and takes in excess of 30 mins to run\n+# ********\n+\n+from test_framework import BitcoinTestFramework\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+import os.path\n+\n+def calc_usage(blockdir):\n+    return sum(os.path.getsize(blockdir+f) for f in os.listdir(blockdir) if os.path.isfile(blockdir+f))/(1024*1024)\n+\n+class PruneTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        self.utxo = []\n+        self.address = [\"\",\"\"]\n+\n+        # Some pre-processing to create a bunch of OP_RETURN txouts to insert into transactions we create\n+        # So we have big transactions and full blocks to fill up our block files\n+\n+        # create one script_pubkey\n+        script_pubkey = \"6a4d0200\" #OP_RETURN OP_PUSH2 512 bytes\n+        for i in xrange (512):\n+            script_pubkey = script_pubkey + \"01\"\n+        # concatenate 128 txouts of above script_pubkey which we'll insert before the txout for change\n+        self.txouts = \"81\"\n+        for k in xrange(128):\n+            # add txout value\n+            self.txouts = self.txouts + \"0000000000000000\"\n+            # add length of script_pubkey\n+            self.txouts = self.txouts + \"fd0402\"\n+            # add script_pubkey\n+            self.txouts = self.txouts + script_pubkey\n+\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.is_network_split = False\n+\n+        # Create nodes 0 and 1 to mine\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=300))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=300))\n+\n+        # Create node 2 to test pruning\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=300))\n+        self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n+\n+        self.address[0] = self.nodes[0].getnewaddress()\n+        self.address[1] = self.nodes[1].getnewaddress()\n+\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[1], 2)\n+        connect_nodes(self.nodes[2], 0)\n+        sync_blocks(self.nodes[0:3])\n+\n+    def create_big_chain(self):\n+        # Start by creating some coinbases we can spend later\n+        self.nodes[1].generate(200)\n+        sync_blocks(self.nodes[0:2])\n+        self.nodes[0].generate(150)\n+        # Then mine enough full blocks to create more than 550MB of data\n+        for i in xrange(645):\n+            self.mine_full_block(self.nodes[0], self.address[0])\n+\n+        sync_blocks(self.nodes[0:3])\n+\n+    def test_height_min(self):\n+        if not os.path.isfile(self.prunedir+\"blk00000.dat\"):\n+            raise AssertionError(\"blk00000.dat is missing, pruning too early\")\n+        print \"Success\"\n+        print \"Though we're already using more than 550MB, current usage:\", calc_usage(self.prunedir)\n+        print \"Mining 25 more blocks should cause the first block file to be pruned\"\n+        # Pruning doesn't run until we're allocating another chunk, 20 full blocks past the height cutoff will ensure this\n+        for i in xrange(25):\n+            self.mine_full_block(self.nodes[0],self.address[0])\n+\n+        waitstart = time.time()\n+        while os.path.isfile(self.prunedir+\"blk00000.dat\"):\n+            time.sleep(0.1)\n+            if time.time() - waitstart > 10:\n+                raise AssertionError(\"blk00000.dat not pruned when it should be\")\n+\n+        print \"Success\"\n+        usage = calc_usage(self.prunedir)\n+        print \"Usage should be below target:\", usage\n+        if (usage > 550):\n+            raise AssertionError(\"Pruning target not being met\")\n+\n+    def create_chain_with_staleblocks(self):\n+        # Create stale blocks in manageable sized chunks\n+        print \"Mine 24 (stale) blocks on Node 1, followed by 25 (main chain) block reorg from Node 0, for 12 rounds\"\n+\n+        for j in xrange(12):\n+            # Disconnect node 0 so it can mine a longer reorg chain without knowing about node 1's soon-to-be-stale chain\n+            # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n+            # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n+            stop_node(self.nodes[0],0)\n+            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=300)\n+            # Mine 24 blocks in node 1\n+            self.utxo = self.nodes[1].listunspent()\n+            for i in xrange(24):\n+                if j == 0:\n+                    self.mine_full_block(self.nodes[1],self.address[1])\n+                else:\n+                    self.nodes[1].generate(1) #tx's already in mempool from previous disconnects\n+\n+            # Reorg back with 25 block chain from node 0\n+            self.utxo = self.nodes[0].listunspent()\n+            for i in xrange(25): \n+                self.mine_full_block(self.nodes[0],self.address[0])\n+\n+            # Create connections in the order so both nodes can see the reorg at the same time\n+            connect_nodes(self.nodes[1], 0)\n+            connect_nodes(self.nodes[2], 0)\n+            sync_blocks(self.nodes[0:3])\n+\n+        print \"Usage can be over target because of high stale rate:\", calc_usage(self.prunedir)\n+\n+    def reorg_test(self):\n+        # Node 1 will mine a 300 block chain starting 287 blocks back from Node 0 and Node 2's tip\n+        # This will cause Node 2 to do a reorg requiring 288 blocks of undo data to the reorg_test chain\n+        # Reboot node 1 to clear its mempool (hopefully make the invalidate faster)\n+        # Lower the block max size so we don't keep mining all our big mempool transactions (from disconnected blocks)\n+        stop_node(self.nodes[1],1)\n+        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=300)\n+\n+        height = self.nodes[1].getblockcount()\n+        print \"Current block height:\", height\n+\n+        invalidheight = height-287\n+        badhash = self.nodes[1].getblockhash(invalidheight)\n+        print \"Invalidating block at height:\",invalidheight,badhash\n+        self.nodes[1].invalidateblock(badhash)\n+\n+        # We've now switched to our previously mined-24 block fork on node 1, but thats not what we want\n+        # So invalidate that fork as well, until we're on the same chain as node 0/2 (but at an ancestor 288 blocks ago)\n+        mainchainhash = self.nodes[0].getblockhash(invalidheight - 1)\n+        curhash = self.nodes[1].getblockhash(invalidheight - 1)\n+        while curhash != mainchainhash:\n+            self.nodes[1].invalidateblock(curhash)\n+            curhash = self.nodes[1].getblockhash(invalidheight - 1)\n+\n+        assert(self.nodes[1].getblockcount() == invalidheight - 1)\n+        print \"New best height\", self.nodes[1].getblockcount()\n+\n+        # Reboot node1 to clear those giant tx's from mempool\n+        stop_node(self.nodes[1],1)\n+        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=300)\n+\n+        print \"Generating new longer chain of 300 more blocks\"\n+        self.nodes[1].generate(300)\n+\n+        print \"Reconnect nodes\"\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[2], 1)\n+        sync_blocks(self.nodes[0:3])\n+\n+        print \"Verify height on node 2:\",self.nodes[2].getblockcount()\n+        print \"Usage possibly still high bc of stale blocks in block files:\", calc_usage(self.prunedir)\n+\n+        print \"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\"\n+        self.nodes[0].generate(220) #node 0 has many large tx's in its mempool from the disconnects\n+        sync_blocks(self.nodes[0:3])\n+\n+        usage = calc_usage(self.prunedir)\n+        print \"Usage should be below target:\", usage\n+        if (usage > 550):\n+            raise AssertionError(\"Pruning target not being met\")\n+\n+        return invalidheight,badhash\n+\n+    def reorg_back(self):\n+        # Verify that a block on the old main chain fork has been pruned away\n+        try:\n+            self.nodes[2].getblock(self.forkhash)\n+            raise AssertionError(\"Old block wasn't pruned so can't test redownload\")\n+        except JSONRPCException as e:\n+            print \"Will need to redownload block\",self.forkheight\n+\n+        # Verify that we have enough history to reorg back to the fork point\n+        # Although this is more than 288 blocks, because this chain was written more recently\n+        # and only its other 299 small and 220 large block are in the block files after it,\n+        # its expected to still be retained\n+        self.nodes[2].getblock(self.nodes[2].getblockhash(self.forkheight))\n+\n+        first_reorg_height = self.nodes[2].getblockcount()\n+        curchainhash = self.nodes[2].getblockhash(self.mainchainheight)\n+        self.nodes[2].invalidateblock(curchainhash)\n+        goalbestheight = self.mainchainheight\n+        goalbesthash = self.mainchainhash2\n+\n+        # As of 0.10 the current block download logic is not able to reorg to the original chain created in\n+        # create_chain_with_stale_blocks because it doesn't know of any peer thats on that chain from which to\n+        # redownload its missing blocks.\n+        # Invalidate the reorg_test chain in node 0 as well, it can successfully switch to the original chain\n+        # because it has all the block data.\n+        # However it must mine enough blocks to have a more work chain than the reorg_test chain in order\n+        # to trigger node 2's block download logic.\n+        # At this point node 2 is within 288 blocks of the fork point so it will preserve its ability to reorg\n+        if self.nodes[2].getblockcount() < self.mainchainheight:\n+            blocks_to_mine = first_reorg_height + 1 - self.mainchainheight\n+            print \"Rewind node 0 to prev main chain to mine longer chain to trigger redownload. Blocks needed:\", blocks_to_mine\n+            self.nodes[0].invalidateblock(curchainhash)\n+            assert(self.nodes[0].getblockcount() == self.mainchainheight)\n+            assert(self.nodes[0].getbestblockhash() == self.mainchainhash2)\n+            goalbesthash = self.nodes[0].generate(blocks_to_mine)[-1]\n+            goalbestheight = first_reorg_height + 1\n+\n+        print \"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\"\n+        waitstart = time.time()\n+        while self.nodes[2].getblockcount() < goalbestheight:\n+            time.sleep(0.1)\n+            if time.time() - waitstart > 300:\n+                raise AssertionError(\"Node 2 didn't reorg to proper height\")\n+        assert(self.nodes[2].getbestblockhash() == goalbesthash)\n+        # Verify we can now have the data for a block previously pruned\n+        assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n+\n+    def mine_full_block(self, node, address):\n+        # Want to create a full block\n+        # We'll generate a 66k transaction below, and 14 of them is close to the 1MB block limit\n+        for j in xrange(14):\n+            if len(self.utxo) < 14:\n+                self.utxo = node.listunspent()\n+            inputs=[]\n+            outputs = {}\n+            t = self.utxo.pop()\n+            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n+            remchange = t[\"amount\"] - Decimal(\"0.001000\")\n+            outputs[address]=remchange\n+            # Create a basic transaction that will send change back to ourself after account for a fee\n+            # And then insert the 128 generated transaction outs in the middle rawtx[92] is where the #\n+            # of txouts is stored and is the only thing we overwrite from the original transaction\n+            rawtx = node.createrawtransaction(inputs, outputs)\n+            newtx = rawtx[0:92]\n+            newtx = newtx + self.txouts\n+            newtx = newtx + rawtx[94:]\n+            # Appears to be ever so slightly faster to sign with SIGHASH_NONE\n+            signresult = node.signrawtransaction(newtx,None,None,\"NONE\")\n+            txid = node.sendrawtransaction(signresult[\"hex\"], True)\n+        # Mine a full sized block which will be these transactions we just created\n+        node.generate(1)\n+\n+\n+    def run_test(self):\n+        print \"Warning! This test requires 4GB of disk space and takes over 30 mins\"\n+        print \"Mining a big blockchain of 995 blocks\"\n+        self.create_big_chain()\n+        # Chain diagram key:\n+        # *   blocks on main chain\n+        # +,&,$,@ blocks on other forks\n+        # X   invalidated block\n+        # N1  Node 1\n+        #\n+        # Start by mining a simple chain that all nodes have\n+        # N0=N1=N2 **...*(995)\n+\n+        print \"Check that we haven't started pruning yet because we're below PruneAfterHeight\"\n+        self.test_height_min()\n+        # Extend this chain past the PruneAfterHeight\n+        # N0=N1=N2 **...*(1020)\n+\n+        print \"Check that we'll exceed disk space target if we have a very high stale block rate\"\n+        self.create_chain_with_staleblocks()\n+        # Disconnect N0\n+        # And mine a 24 block chain on N1 and a separate 25 block chain on N0\n+        # N1=N2 **...*+...+(1044)\n+        # N0    **...**...**(1045)\n+        #\n+        # reconnect nodes causing reorg on N1 and N2\n+        # N1=N2 **...*(1020) *...**(1045)\n+        #                   \\\n+        #                    +...+(1044)\n+        #\n+        # repeat this process until you have 12 stale forks hanging off the\n+        # main chain on N1 and N2\n+        # N0    *************************...***************************(1320)\n+        #\n+        # N1=N2 **...*(1020) *...**(1045) *..         ..**(1295) *...**(1320)\n+        #                   \\            \\                      \\\n+        #                    +...+(1044)  &..                    $...$(1319)\n+\n+        # Save some current chain state for later use\n+        self.mainchainheight = self.nodes[2].getblockcount()   #1320\n+        self.mainchainhash2 = self.nodes[2].getblockhash(self.mainchainheight)\n+\n+        print \"Check that we can survive a 288 block reorg still\"\n+        (self.forkheight,self.forkhash) = self.reorg_test() #(1033, )\n+        # Now create a 288 block reorg by mining a longer chain on N1\n+        # First disconnect N1\n+        # Then invalidate 1033 on main chain and 1032 on fork so height is 1032 on main chain\n+        # N1   **...*(1020) **...**(1032)X..\n+        #                  \\\n+        #                   ++...+(1031)X..\n+        #\n+        # Now mine 300 more blocks on N1\n+        # N1    **...*(1020) **...**(1032) @@...@(1332)\n+        #                 \\               \\\n+        #                  \\               X...\n+        #                   \\                 \\\n+        #                    ++...+(1031)X..   ..\n+        #\n+        # Reconnect nodes and mine 220 more blocks on N1\n+        # N1    **...*(1020) **...**(1032) @@...@@@(1552)\n+        #                 \\               \\\n+        #                  \\               X...\n+        #                   \\                 \\\n+        #                    ++...+(1031)X..   ..\n+        #\n+        # N2    **...*(1020) **...**(1032) @@...@@@(1552)\n+        #                 \\               \\\n+        #                  \\               *...**(1320)\n+        #                   \\                 \\\n+        #                    ++...++(1044)     ..\n+        #\n+        # N0    ********************(1032) @@...@@@(1552) \n+        #                                 \\\n+        #                                  *...**(1320)\n+\n+        print \"Test that we can rerequest a block we previously pruned if needed for a reorg\"\n+        self.reorg_back()\n+        # Verify that N2 still has block 1033 on current chain (@), but not on main chain (*)\n+        # Invalidate 1033 on current chain (@) on N2 and we should be able to reorg to\n+        # original main chain (*), but will require redownload of some blocks\n+        # In order to have a peer we think we can download from, must also perform this invalidation\n+        # on N0 and mine a new longest chain to trigger.\n+        # Final result:\n+        # N0    ********************(1032) **...****(1553)\n+        #                                 \\\n+        #                                  X@...@@@(1552)\n+        #\n+        # N2    **...*(1020) **...**(1032) **...****(1553)\n+        #                 \\               \\\n+        #                  \\               X@...@@@(1552)\n+        #                   \\\n+        #                    +..\n+        #\n+        # N1 doesn't change because 1033 on main chain (*) is invalid\n+\n+        print \"Done\"\n+\n+if __name__ == '__main__':\n+    PruneTest().main()"
      },
      {
        "sha": "cf789f48e25921329cd131c07fe97ea659c5c97d",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -158,7 +158,7 @@ def _rpchost_to_args(rpchost):\n         rv += ['-rpcport=' + rpcport]\n     return rv\n \n-def start_node(i, dirname, extra_args=None, rpchost=None):\n+def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None):\n     \"\"\"\n     Start a bitcoind and return RPC connection to it\n     \"\"\"\n@@ -172,7 +172,10 @@ def start_node(i, dirname, extra_args=None, rpchost=None):\n                           [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n     devnull.close()\n     url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n-    proxy = AuthServiceProxy(url)\n+    if timewait is not None:\n+        proxy = AuthServiceProxy(url, timeout=timewait)\n+    else:\n+        proxy = AuthServiceProxy(url)\n     proxy.url = url # store URL on proxy for info\n     return proxy\n "
      },
      {
        "sha": "589c7b5472fd3ee88e69bf8cdb5c2df1848bda53",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -121,6 +121,7 @@ class CMainParams : public CChainParams {\n         vAlertPubKey = ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\");\n         nDefaultPort = 8333;\n         nMinerThreads = 0;\n+        nPruneAfterHeight = 100000;\n \n         /**\n          * Build the genesis block. Note that the output of the genesis coinbase cannot\n@@ -198,6 +199,7 @@ class CTestNetParams : public CMainParams {\n         vAlertPubKey = ParseHex(\"04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a\");\n         nDefaultPort = 18333;\n         nMinerThreads = 0;\n+        nPruneAfterHeight = 1000;\n \n         //! Modify the testnet genesis block so the timestamp is valid for a later start.\n         genesis.nTime = 1296688602;\n@@ -257,6 +259,7 @@ class CRegTestParams : public CTestNetParams {\n         consensus.hashGenesisBlock = genesis.GetHash();\n         nDefaultPort = 18444;\n         assert(consensus.hashGenesisBlock == uint256S(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\n+        nPruneAfterHeight = 1000;\n \n         vFixedSeeds.clear(); //! Regtest mode doesn't have any fixed seeds.\n         vSeeds.clear();  //! Regtest mode doesn't have any DNS seeds."
      },
      {
        "sha": "5e974123dc85bb7fd5b32aa70e974dd90d1b7157",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -58,6 +58,7 @@ class CChainParams\n     bool DefaultConsistencyChecks() const { return fDefaultConsistencyChecks; }\n     /** Make standard checks */\n     bool RequireStandard() const { return fRequireStandard; }\n+    int64_t PruneAfterHeight() const { return nPruneAfterHeight; }\n     /** Make miner stop after a block is found. In RPC, don't return until nGenProcLimit blocks are generated */\n     bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n     /** In the future use NetworkIDString() for RPC fields */\n@@ -77,6 +78,7 @@ class CChainParams\n     std::vector<unsigned char> vAlertPubKey;\n     int nDefaultPort;\n     int nMinerThreads;\n+    uint64_t nPruneAfterHeight;\n     std::vector<CDNSSeedData> vSeeds;\n     std::vector<unsigned char> base58Prefixes[MAX_BASE58_TYPES];\n     std::string strNetworkID;"
      },
      {
        "sha": "b648a237bfcb8c35fba455b122a4240e116470c7",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 4,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -275,7 +275,12 @@ std::string HelpMessage(HelpMessageMode mode)\n #ifndef WIN32\n     strUsage += HelpMessageOpt(\"-pid=<file>\", strprintf(_(\"Specify pid file (default: %s)\"), \"bitcoind.pid\"));\n #endif\n-    strUsage += HelpMessageOpt(\"-reindex\", _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-prune=<n>\", _(\"Reduce storage requirements by pruning (deleting) old blocks. This mode disables wallet support and is incompatible with -txindex.\") + \" \" +\n+            _(\"Warning: Reverting this setting requires re-downloading the entire blockchain.\") + \" \" +\n+            _(\"(default: 0 = disable pruning blocks,\") + \" \" +\n+            strprintf(_(\">%u = target size in MiB to use for block files)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n+strUsage += HelpMessageOpt(\"-reindex\", _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\"on startup\"));\n+\n #if !defined(WIN32)\n     strUsage += HelpMessageOpt(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"));\n #endif\n@@ -352,7 +357,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(_(\"Run a thread to flush wallet periodically (default: %u)\"), 1));\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(_(\"Stop running after importing blocks from disk (default: %u)\"), 0));\n     }\n-    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net, proxy\"; // Don't translate these and qt below\n+    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net, proxy, prune\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n         debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n@@ -458,10 +463,33 @@ struct CImportingNow\n     }\n };\n \n+\n+// If we're using -prune with -reindex, then delete block files that will be ignored by the\n+// reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile\n+// is missing, and since pruning works by deleting the oldest block file first, just check\n+// for block file 0, and if it doesn't exist, delete all the block files in the\n+// directory (since they won't be read by the reindex but will take up disk space).\n+void DeleteAllBlockFiles()\n+{\n+    if (boost::filesystem::exists(GetBlockPosFilename(CDiskBlockPos(0, 0), \"blk\")))\n+        return;\n+\n+    LogPrintf(\"Removing all blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n+    boost::filesystem::path blocksdir = GetDataDir() / \"blocks\";\n+    for (boost::filesystem::directory_iterator it(blocksdir); it != boost::filesystem::directory_iterator(); it++) {\n+        if (is_regular_file(*it)) {\n+            if ((it->path().filename().string().length() == 12) &&\n+                (it->path().filename().string().substr(8,4) == \".dat\") &&\n+                ((it->path().filename().string().substr(0,3) == \"blk\") ||\n+                 (it->path().filename().string().substr(0,3) == \"rev\")))\n+                boost::filesystem::remove(it->path());\n+        }\n+    }\n+}\n+\n void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n {\n     RenameThread(\"bitcoin-loadblk\");\n-\n     // -reindex\n     if (fReindex) {\n         CImportingNow imp;\n@@ -674,6 +702,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (nFD - MIN_CORE_FILEDESCRIPTORS < nMaxConnections)\n         nMaxConnections = nFD - MIN_CORE_FILEDESCRIPTORS;\n \n+    // if using block pruning, then disable txindex\n+    // also disable the wallet (for now, until SPV support is implemented in wallet)\n+    if (GetArg(\"-prune\", 0)) {\n+        if (GetBoolArg(\"-txindex\", false))\n+            return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n+#ifdef ENABLE_WALLET\n+        if (!GetBoolArg(\"-disablewallet\", false)) {\n+            if (SoftSetBoolArg(\"-disablewallet\", true))\n+                LogPrintf(\"%s : parameter interaction: -prune -> setting -disablewallet=1\\n\", __func__);\n+            else\n+                return InitError(_(\"Can't run with a wallet in prune mode.\"));\n+        }\n+#endif\n+    }\n+\n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n     fDebug = !mapMultiArgs[\"-debug\"].empty();\n@@ -710,6 +753,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n         nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS;\n \n     fServer = GetBoolArg(\"-server\", false);\n+\n+    // block pruning; get the amount of disk space (in MB) to allot for block & undo files\n+    int64_t nSignedPruneTarget = GetArg(\"-prune\", 0) * 1024 * 1024;\n+    if (nSignedPruneTarget < 0) {\n+        return InitError(_(\"Prune cannot be configured with a negative value.\"));\n+    }\n+    nPruneTarget = (uint64_t) nSignedPruneTarget;\n+    if (nPruneTarget) {\n+        if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) {\n+            return InitError(strprintf(_(\"Prune configured below the minimum of %d MB.  Please use a higher number.\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n+        }\n+        LogPrintf(\"Prune configured to target %uMiB on disk for block and undo files.\\n\", nPruneTarget / 1024 / 1024);\n+        fPruneMode = true;\n+    }\n+\n #ifdef ENABLE_WALLET\n     bool fDisableWallet = GetBoolArg(\"-disablewallet\", false);\n #endif\n@@ -1030,8 +1088,12 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n                 pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n \n-                if (fReindex)\n+                if (fReindex) {\n                     pblocktree->WriteReindexing(true);\n+                    //If we're reindexing in prune mode, wipe away all our block and undo data files\n+                    if (fPruneMode)\n+                        DeleteAllBlockFiles();\n+                }\n \n                 if (!LoadBlockIndex()) {\n                     strLoadError = _(\"Error loading block database\");\n@@ -1055,7 +1117,18 @@ bool AppInit2(boost::thread_group& threadGroup)\n                     break;\n                 }\n \n+                // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n+                // in the past, but is now trying to run unpruned.\n+                if (fHavePruned && !fPruneMode) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain\");\n+                    break;\n+                }\n+\n                 uiInterface.InitMessage(_(\"Verifying blocks...\"));\n+                if (fHavePruned && GetArg(\"-checkblocks\", 288) > MIN_BLOCKS_TO_KEEP) {\n+                    LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; -checkblocks=%d may fail\\n\",\n+                        MIN_BLOCKS_TO_KEEP, GetArg(\"-checkblocks\", 288));\n+                }\n                 if (!CVerifyDB().VerifyDB(pcoinsdbview, GetArg(\"-checklevel\", 3),\n                               GetArg(\"-checkblocks\", 288))) {\n                     strLoadError = _(\"Corrupted block database detected\");\n@@ -1106,6 +1179,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n         mempool.ReadFeeEstimates(est_filein);\n     fFeeEstimatesInitialized = true;\n \n+    // if prune mode, unset NODE_NETWORK and prune block files\n+    if (fPruneMode) {\n+        LogPrintf(\"Unsetting NODE_NETWORK on prune mode\\n\");\n+        nLocalServices &= ~NODE_NETWORK;\n+        if (!fReindex) {\n+            PruneAndFlush();\n+        }\n+    }\n+\n     // ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n     if (fDisableWallet) {"
      },
      {
        "sha": "bf32ac91e7778154733c048d4642ff848f47ab6c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 248,
        "deletions": 30,
        "changes": 278,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -52,9 +52,12 @@ int nScriptCheckThreads = 0;\n bool fImporting = false;\n bool fReindex = false;\n bool fTxIndex = false;\n+bool fHavePruned = false;\n+bool fPruneMode = false;\n bool fIsBareMultisigStd = true;\n bool fCheckBlockIndex = false;\n unsigned int nCoinCacheSize = 5000;\n+uint64_t nPruneTarget = 0;\n \n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n CFeeRate minRelayTxFee = CFeeRate(1000);\n@@ -110,17 +113,25 @@ namespace {\n \n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n-     * as good as our current tip or better. Entries may be failed, though.\n+     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n+     * missing the data for the block.\n      */\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n     /** Number of nodes with fSyncStarted. */\n     int nSyncStarted = 0;\n-    /** All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions. */\n+    /** All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n+      * Pruned nodes may have entries where B is missing data.\n+      */\n     multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n     int nLastBlockFile = 0;\n+    /** Global flag to indicate we should check to see if there are\n+     *  block/undo files that should be deleted.  Set on startup\n+     *  or if we allocate more file space when we're in prune mode\n+     */\n+    bool fCheckForPruning = false;\n \n     /**\n      * Every received block is assigned a unique and increasing identifier, so we\n@@ -1849,23 +1860,38 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n }\n \n enum FlushStateMode {\n+    FLUSH_STATE_NONE,\n     FLUSH_STATE_IF_NEEDED,\n     FLUSH_STATE_PERIODIC,\n     FLUSH_STATE_ALWAYS\n };\n \n /**\n  * Update the on-disk chain state.\n- * The caches and indexes are flushed if either they're too large, forceWrite is set, or\n- * fast is not set and it's been a while since the last write.\n+ * The caches and indexes are flushed depending on the mode we're called with\n+ * if they're too large, if it's been a while since the last write,\n+ * or always and in all cases if we're in prune mode and are deleting files.\n  */\n bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n-    LOCK(cs_main);\n+    LOCK2(cs_main, cs_LastBlockFile);\n     static int64_t nLastWrite = 0;\n+    std::set<int> setFilesToPrune;\n+    bool fFlushForPrune = false;\n     try {\n+    if (fPruneMode && fCheckForPruning) {\n+        FindFilesToPrune(setFilesToPrune);\n+        if (!setFilesToPrune.empty()) {\n+            fFlushForPrune = true;\n+            if (!fHavePruned) {\n+                pblocktree->WriteFlag(\"prunedblockfiles\", true);\n+                fHavePruned = true;\n+            }\n+        }\n+    }\n     if ((mode == FLUSH_STATE_ALWAYS) ||\n         ((mode == FLUSH_STATE_PERIODIC || mode == FLUSH_STATE_IF_NEEDED) && pcoinsTip->GetCacheSize() > nCoinCacheSize) ||\n-        (mode == FLUSH_STATE_PERIODIC && GetTimeMicros() > nLastWrite + DATABASE_WRITE_INTERVAL * 1000000)) {\n+        (mode == FLUSH_STATE_PERIODIC && GetTimeMicros() > nLastWrite + DATABASE_WRITE_INTERVAL * 1000000) ||\n+        fFlushForPrune) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n@@ -1893,9 +1919,16 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n                 return state.Abort(\"Files to write to block index database\");\n             }\n         }\n-        // Finally flush the chainstate (which may refer to block index entries).\n+        // Flush the chainstate (which may refer to block index entries).\n         if (!pcoinsTip->Flush())\n             return state.Abort(\"Failed to write to coin database\");\n+\n+        // Finally remove any pruned files\n+        if (fFlushForPrune) {\n+            UnlinkPrunedFiles(setFilesToPrune);\n+            fCheckForPruning = false;\n+        }\n+\n         // Update best block in wallet (so we can detect restored wallets).\n         if (mode != FLUSH_STATE_IF_NEEDED) {\n             GetMainSignals().SetBestChain(chainActive.GetLocator());\n@@ -1913,6 +1946,12 @@ void FlushStateToDisk() {\n     FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n }\n \n+void PruneAndFlush() {\n+    CValidationState state;\n+    fCheckForPruning = true;\n+    FlushStateToDisk(state, FLUSH_STATE_NONE);\n+}\n+\n /** Update chainActive and related internal data structures. */\n void static UpdateTip(CBlockIndex *pindexNew) {\n     chainActive.SetTip(pindexNew);\n@@ -2083,15 +2122,29 @@ static CBlockIndex* FindMostWorkChain() {\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n-            assert(pindexTest->nStatus & BLOCK_HAVE_DATA);\n             assert(pindexTest->nChainTx || pindexTest->nHeight == 0);\n-            if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n-                // Candidate has an invalid ancestor, remove entire chain from the set.\n-                if (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n+\n+            // Pruned nodes may have entries in setBlockIndexCandidates for\n+            // which block files have been deleted.  Remove those as candidates\n+            // for the most work chain if we come across them; we can't switch\n+            // to a chain unless we have all the non-active-chain parent blocks.\n+            bool fFailedChain = pindexTest->nStatus & BLOCK_FAILED_MASK;\n+            bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n+            if (fFailedChain || fMissingData) {\n+                // Candidate chain is not usable (either invalid or missing data)\n+                if (fFailedChain && (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n                     pindexBestInvalid = pindexNew;\n                 CBlockIndex *pindexFailed = pindexNew;\n+                // Remove the entire chain from the set.\n                 while (pindexTest != pindexFailed) {\n-                    pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n+                    if (fFailedChain) {\n+                        pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n+                    } else if (fMissingData) {\n+                        // If we're missing data, then add back to mapBlocksUnlinked,\n+                        // so that if the block arrives in the future we can try adding\n+                        // to setBlockIndexCandidates again.\n+                        mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));\n+                    }\n                     setBlockIndexCandidates.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n                 }\n@@ -2219,7 +2272,9 @@ bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n             uint256 hashNewTip = pindexNewTip->GetBlockHash();\n             // Relay inventory, but don't relay old inventory during initial block download.\n             int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-            {\n+            // Don't relay blocks if pruning -- could cause a peer to try to download, resulting\n+            // in a stalled download if the block file is pruned before the request.\n+            if (nLocalServices & NODE_NETWORK) {\n                 LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n                     if (chainActive.Height() > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n@@ -2419,6 +2474,8 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n         unsigned int nOldChunks = (pos.nPos + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n         unsigned int nNewChunks = (vinfoBlockFile[nFile].nSize + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n         if (nNewChunks > nOldChunks) {\n+            if (fPruneMode)\n+                fCheckForPruning = true;\n             if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)) {\n                 FILE *file = OpenBlockFile(pos);\n                 if (file) {\n@@ -2450,6 +2507,8 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n     unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n     unsigned int nNewChunks = (nNewSize + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n     if (nNewChunks > nOldChunks) {\n+        if (fPruneMode)\n+            fCheckForPruning = true;\n         if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)) {\n             FILE *file = OpenUndoFile(pos);\n             if (file) {\n@@ -2665,7 +2724,10 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     if (!AcceptBlockHeader(block, state, &pindex))\n         return false;\n \n-    if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+    // If we're pruning, ensure that we don't allow a peer to dump a copy\n+    // of old blocks.  But we might need blocks that are not on the main chain\n+    // to handle a reorg, even if we've processed once.\n+    if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n         // TODO: deal better with duplicate blocks.\n         // return state.DoS(20, error(\"AcceptBlock(): already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n         return true;\n@@ -2698,6 +2760,9 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n         return state.Abort(std::string(\"System error: \") + e.what());\n     }\n \n+    if (fCheckForPruning)\n+        FlushStateToDisk(state, FLUSH_STATE_NONE); // we just allocated more disk space for block files\n+\n     return true;\n }\n \n@@ -2785,6 +2850,112 @@ bool AbortNode(const std::string &strMessage, const std::string &userMessage) {\n     return false;\n }\n \n+\n+/**\n+ * BLOCK PRUNING CODE\n+ */\n+\n+/* Calculate the amount of disk space the block & undo files currently use */\n+uint64_t CalculateCurrentUsage()\n+{\n+    uint64_t retval = 0;\n+    BOOST_FOREACH(const CBlockFileInfo &file, vinfoBlockFile) {\n+        retval += file.nSize + file.nUndoSize;\n+    }\n+    return retval;\n+}\n+\n+/* Prune a block file (modify associated database entries)*/\n+void PruneOneBlockFile(const int fileNumber)\n+{\n+    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {\n+        CBlockIndex* pindex = it->second;\n+        if (pindex->nFile == fileNumber) {\n+            pindex->nStatus &= ~BLOCK_HAVE_DATA;\n+            pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n+            pindex->nFile = 0;\n+            pindex->nDataPos = 0;\n+            pindex->nUndoPos = 0;\n+            setDirtyBlockIndex.insert(pindex);\n+\n+            // Prune from mapBlocksUnlinked -- any block we prune would have\n+            // to be downloaded again in order to consider its chain, at which\n+            // point it would be considered as a candidate for\n+            // mapBlocksUnlinked or setBlockIndexCandidates.\n+            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);\n+            while (range.first != range.second) {\n+                std::multimap<CBlockIndex *, CBlockIndex *>::iterator it = range.first;\n+                range.first++;\n+                if (it->second == pindex) {\n+                    mapBlocksUnlinked.erase(it);\n+                }\n+            }\n+        }\n+    }\n+\n+    vinfoBlockFile[fileNumber].SetNull();\n+    setDirtyFileInfo.insert(fileNumber);\n+}\n+\n+\n+void UnlinkPrunedFiles(std::set<int>& setFilesToPrune)\n+{\n+    for (set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n+        CDiskBlockPos pos(*it, 0);\n+        boost::filesystem::remove(GetBlockPosFilename(pos, \"blk\"));\n+        boost::filesystem::remove(GetBlockPosFilename(pos, \"rev\"));\n+        LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it);\n+    }\n+}\n+\n+/* Calculate the block/rev files that should be deleted to remain under target*/\n+void FindFilesToPrune(std::set<int>& setFilesToPrune)\n+{\n+    LOCK2(cs_main, cs_LastBlockFile);\n+    if (chainActive.Tip() == NULL || nPruneTarget == 0) {\n+        return;\n+    }\n+    if (chainActive.Tip()->nHeight <= Params().PruneAfterHeight()) {\n+        return;\n+    }\n+\n+    unsigned int nLastBlockWeMustKeep = chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP;\n+    uint64_t nCurrentUsage = CalculateCurrentUsage();\n+    // We don't check to prune until after we've allocated new space for files\n+    // So we should leave a buffer under our target to account for another allocation\n+    // before the next pruning.\n+    uint64_t nBuffer = BLOCKFILE_CHUNK_SIZE + UNDOFILE_CHUNK_SIZE;\n+    uint64_t nBytesToPrune;\n+    int count=0;\n+\n+    if (nCurrentUsage + nBuffer >= nPruneTarget) {\n+        for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n+            nBytesToPrune = vinfoBlockFile[fileNumber].nSize + vinfoBlockFile[fileNumber].nUndoSize;\n+\n+            if (vinfoBlockFile[fileNumber].nSize == 0)\n+                continue;\n+\n+            if (nCurrentUsage + nBuffer < nPruneTarget)  // are we below our target?\n+                break;\n+\n+            // don't prune files that could have a block within MIN_BLOCKS_TO_KEEP of the main chain's tip\n+            if (vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeMustKeep)\n+                break;\n+\n+            PruneOneBlockFile(fileNumber);\n+            // Queue up the files for removal\n+            setFilesToPrune.insert(fileNumber);\n+            nCurrentUsage -= nBytesToPrune;\n+            count++;\n+        }\n+    }\n+\n+    LogPrint(\"prune\", \"Prune: target=%dMiB actual=%dMiB diff=%dMiB min_must_keep=%d removed %d blk/rev pairs\\n\",\n+           nPruneTarget/1024/1024, nCurrentUsage/1024/1024,\n+           ((int64_t)nPruneTarget - (int64_t)nCurrentUsage)/1024/1024,\n+           nLastBlockWeMustKeep, count);\n+}\n+\n bool CheckDiskSpace(uint64_t nAdditionalBytes)\n {\n     uint64_t nFreeBytesAvailable = boost::filesystem::space(GetDataDir()).available;\n@@ -2872,7 +3043,9 @@ bool static LoadBlockIndexDB()\n     {\n         CBlockIndex* pindex = item.second;\n         pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);\n-        if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+        // We can link the chain of blocks for which we've received transactions at some point.\n+        // Pruned nodes may have deleted the block.\n+        if (pindex->nTx > 0) {\n             if (pindex->pprev) {\n                 if (pindex->pprev->nChainTx) {\n                     pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n@@ -2929,6 +3102,11 @@ bool static LoadBlockIndexDB()\n         }\n     }\n \n+    // Check whether we have ever pruned block & undo files\n+    pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned);\n+    if (fHavePruned)\n+        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n+\n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n     pblocktree->ReadReindexing(fReindexing);\n@@ -3069,6 +3247,7 @@ void UnloadBlockIndex()\n         delete entry.second;\n     }\n     mapBlockIndex.clear();\n+    fHavePruned = false;\n }\n \n bool LoadBlockIndex()\n@@ -3260,6 +3439,7 @@ void static CheckBlockIndex()\n     int nHeight = 0;\n     CBlockIndex* pindexFirstInvalid = NULL; // Oldest ancestor of pindex which is invalid.\n     CBlockIndex* pindexFirstMissing = NULL; // Oldest ancestor of pindex which does not have BLOCK_HAVE_DATA.\n+    CBlockIndex* pindexFirstNeverProcessed = NULL; // Oldest ancestor of pindex for which nTx == 0.\n     CBlockIndex* pindexFirstNotTreeValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_TREE (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotTransactionsValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotChainValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).\n@@ -3268,6 +3448,7 @@ void static CheckBlockIndex()\n         nNodes++;\n         if (pindexFirstInvalid == NULL && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;\n         if (pindexFirstMissing == NULL && !(pindex->nStatus & BLOCK_HAVE_DATA)) pindexFirstMissing = pindex;\n+        if (pindexFirstNeverProcessed == NULL && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;\n         if (pindex->pprev != NULL && pindexFirstNotTreeValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TREE) pindexFirstNotTreeValid = pindex;\n         if (pindex->pprev != NULL && pindexFirstNotTransactionsValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TRANSACTIONS) pindexFirstNotTransactionsValid = pindex;\n         if (pindex->pprev != NULL && pindexFirstNotChainValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_CHAIN) pindexFirstNotChainValid = pindex;\n@@ -3279,12 +3460,21 @@ void static CheckBlockIndex()\n             assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.\n             assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.\n         }\n-        // HAVE_DATA is equivalent to VALID_TRANSACTIONS and equivalent to nTx > 0 (we stored the number of transactions in the block)\n-        assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));\n-        assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0));\n         if (pindex->nChainTx == 0) assert(pindex->nSequenceId == 0);  // nSequenceId can't be set for blocks that aren't linked\n-        // All parents having data is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.\n-        assert((pindexFirstMissing != NULL) == (pindex->nChainTx == 0)); // nChainTx == 0 is used to signal that all parent block's transaction data is available.\n+        // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).\n+        // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.\n+        if (!fHavePruned) {\n+            // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0\n+            assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));\n+            assert(pindexFirstMissing == pindexFirstNeverProcessed);\n+        } else {\n+            // If we have pruned, then we can only say that HAVE_DATA implies nTx > 0\n+            if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);\n+        }\n+        if (pindex->nStatus & BLOCK_HAVE_UNDO) assert(pindex->nStatus & BLOCK_HAVE_DATA);\n+        assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0)); // This is pruning-independent.\n+        // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.\n+        assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).\n         assert((pindexFirstNotTransactionsValid != NULL) == (pindex->nChainTx == 0));\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n         assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n@@ -3297,11 +3487,20 @@ void static CheckBlockIndex()\n             // Checks for not-invalid blocks.\n             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.\n         }\n-        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstMissing == NULL) {\n-            if (pindexFirstInvalid == NULL) { // If this block sorts at least as good as the current tip and is valid, it must be in setBlockIndexCandidates.\n-                 assert(setBlockIndexCandidates.count(pindex));\n+        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {\n+            if (pindexFirstInvalid == NULL) {\n+                // If this block sorts at least as good as the current tip and\n+                // is valid and we have all data for its parents, it must be in\n+                // setBlockIndexCandidates.  chainActive.Tip() must also be there\n+                // even if some data has been pruned.\n+                if (pindexFirstMissing == NULL || pindex == chainActive.Tip()) {\n+                    assert(setBlockIndexCandidates.count(pindex));\n+                }\n+                // If some parent is missing, then it could be that this block was in\n+                // setBlockIndexCandidates but had to be removed because of the missing data.\n+                // In this case it must be in mapBlocksUnlinked -- see test below.\n             }\n-        } else { // If this block sorts worse than the current tip, it cannot be in setBlockIndexCandidates.\n+        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.\n             assert(setBlockIndexCandidates.count(pindex) == 0);\n         }\n         // Check whether this block is in mapBlocksUnlinked.\n@@ -3315,12 +3514,28 @@ void static CheckBlockIndex()\n             }\n             rangeUnlinked.first++;\n         }\n-        if (pindex->pprev && pindex->nStatus & BLOCK_HAVE_DATA && pindexFirstMissing != NULL) {\n-            if (pindexFirstInvalid == NULL) { // If this block has block data available, some parent doesn't, and has no invalid parents, it must be in mapBlocksUnlinked.\n-                assert(foundInUnlinked);\n+        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != NULL && pindexFirstInvalid == NULL) {\n+            // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.\n+            assert(foundInUnlinked);\n+        }\n+        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA\n+        if (pindexFirstMissing == NULL) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.\n+        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == NULL && pindexFirstMissing != NULL) {\n+            // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n+            assert(fHavePruned); // We must have pruned.\n+            // This block may have entered mapBlocksUnlinked if:\n+            //  - it has a descendant that at some point had more work than the\n+            //    tip, and\n+            //  - we tried switching to that descendant but were missing\n+            //    data for some intermediate block between chainActive and the\n+            //    tip.\n+            // So if this block is itself better than chainActive.Tip() and it wasn't in\n+            // setBlockIndexCandidates, then it must be in mapBlocksUnlinked.\n+            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n+                if (pindexFirstInvalid == NULL) {\n+                    assert(foundInUnlinked);\n+                }\n             }\n-        } else { // If this block does not have block data available, or all parents do, it cannot be in mapBlocksUnlinked.\n-            assert(!foundInUnlinked);\n         }\n         // assert(pindex->GetBlockHash() == pindex->GetBlockHeader().GetHash()); // Perhaps too slow\n         // End: actual consistency checks.\n@@ -3340,6 +3555,7 @@ void static CheckBlockIndex()\n             // If pindex was the first with a certain property, unset the corresponding variable.\n             if (pindex == pindexFirstInvalid) pindexFirstInvalid = NULL;\n             if (pindex == pindexFirstMissing) pindexFirstMissing = NULL;\n+            if (pindex == pindexFirstNeverProcessed) pindexFirstNeverProcessed = NULL;\n             if (pindex == pindexFirstNotTreeValid) pindexFirstNotTreeValid = NULL;\n             if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = NULL;\n             if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = NULL;\n@@ -3497,7 +3713,9 @@ void static ProcessGetData(CNode* pfrom)\n                         }\n                     }\n                 }\n-                if (send)\n+                // Pruned nodes may have deleted the block, so check whether\n+                // it's available before trying to send.\n+                if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n                 {\n                     // Send block from disk\n                     CBlock block;"
      },
      {
        "sha": "d34f6c30d16c4e3752e181e5d78e088b7ba86a7f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 44,
        "deletions": 1,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9ec3f0fadb11ee9889af977e16915f5d6e01944/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=f9ec3f0fadb11ee9889af977e16915f5d6e01944",
        "patch": "@@ -132,6 +132,26 @@ extern CBlockIndex *pindexBestHeader;\n /** Minimum disk space required - used in CheckDiskSpace() */\n static const uint64_t nMinDiskSpace = 52428800;\n \n+/** Pruning-related variables and constants */\n+/** True if any block files have ever been pruned. */\n+extern bool fHavePruned;\n+/** True if we're running in -prune mode. */\n+extern bool fPruneMode;\n+/** Number of MiB of block files that we're trying to stay below. */\n+extern uint64_t nPruneTarget;\n+/** Block files containing a block-height within MIN_BLOCKS_TO_KEEP of chainActive.Tip() will not be pruned. */\n+static const signed int MIN_BLOCKS_TO_KEEP = 288;\n+\n+// Require that user allocate at least 550MB for block & undo files (blk???.dat and rev???.dat)\n+// At 1MB per block, 288 blocks = 288MB.\n+// Add 15% for Undo data = 331MB\n+// Add 20% for Orphan block rate = 397MB\n+// We want the low water mark after pruning to be at least 397 MB and since we prune in\n+// full block file chunks, we need the high water mark which triggers the prune to be\n+// one 128MB block file + added 15% undo data = 147MB greater for a total of 545MB\n+// Setting the target to > than 550MB will make it likely we can respect the target.\n+static const signed int MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n+\n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n@@ -186,6 +206,28 @@ bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, b\n bool ActivateBestChain(CValidationState &state, CBlock *pblock = NULL);\n CAmount GetBlockValue(int nHeight, const CAmount& nFees);\n \n+/**\n+ * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.\n+ * The user sets the target (in MB) on the command line or in config file.  This will be run on startup and whenever new\n+ * space is allocated in a block or undo file, staying below the target. Changing back to unpruned requires a reindex\n+ * (which in this case means the blockchain must be re-downloaded.)\n+ *\n+ * Pruning functions are called from FlushStateToDisk when the global fCheckForPruning flag has been set.\n+ * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n+ * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 10 on regtest).\n+ * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n+ * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n+ * A db flag records the fact that at least some block files have been pruned.\n+ *\n+ * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned\n+ */\n+void FindFilesToPrune(std::set<int>& setFilesToPrune);\n+\n+/**\n+ *  Actually unlink the specified files\n+ */\n+void UnlinkPrunedFiles(std::set<int>& setFilesToPrune);\n+\n /** Create a new block index entry for a given block hash */\n CBlockIndex * InsertBlockIndex(uint256 hash);\n /** Abort with a message */\n@@ -196,7 +238,8 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n void Misbehaving(NodeId nodeid, int howmuch);\n /** Flush all state, indexes and buffers to disk. */\n void FlushStateToDisk();\n-\n+/** Prune block files and flush state to disk. */\n+void PruneAndFlush();\n \n /** (try to) add transaction to memory pool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,"
      }
    ]
  }
]