[
  {
    "sha": "a591d98c322093040d59e152591f0978962f9da7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTkxZDk4YzMyMjA5MzA0MGQ1OWUxNTI1OTFmMDk3ODk2MmY5ZGE3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-22T21:03:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-22T21:03:10Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 1897b8e..22f60a6\n\n22f60a6 Merge pull request #245\n61c1b1e Merge pull request #190\nd227579 Add scalar blinding and a secp256k1_context_randomize() call.\nc146b4a Add bench_internal to gitignore.\n9c4fb23 Add a secp256k1_fe_cmov unit test.\n426fa52 Merge pull request #243\nd505a89 Merge pull request #244\n2d2707a travis: test i686 builds with gmp\ncf7f702 travis: update to new build infrastructure\nbb0ea50 Replace set/add with cmov in secp256k1_gej_add_ge.\nf3d3519 Merge pull request #241\n5c2a4fa Fix memory leak in context unit test\n14aacdc Merge pull request #239\n93226a5 secp256k1.c: Add missing DEBUG_CHECKs for sufficiently capable contexts\n6099220 Merge pull request #237\n6066bb6 Fix typo: avg -> max\n9688030 Merge pull request #236\nd899b5b Expose ability to deep-copy a context\n3608c7f Merge pull request #208\na9b6595 [API BREAK] Introduce explicit contexts\na0d3b89 Merge pull request #233\n9e8d89b Merge pull request #234\n65e70e7 Merge pull request #235\n5098f62 Improve documentation formatting consistency\n4450e24 Add a comment about the avoidance of secret data in array indexes.\n6534ee1 initialize variable\nd5b53aa Merge pull request #232\nc01df1a Avoid some implicit type conversions to make C++ compilers happy.\nbfe96ba Merge pull request #231\n33270bf Add a couple comments pointing to particular sections of RFC6979.\n41603aa Merge pull request #230\n2632019 Brace all the if/for/while.\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 22f60a62801a8a49ecd049e7a563f69a41affd8d",
      "tree": {
        "sha": "c5e77a24367eba13e9c43dc51dcf970e57d01c5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5e77a24367eba13e9c43dc51dcf970e57d01c5f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a591d98c322093040d59e152591f0978962f9da7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a591d98c322093040d59e152591f0978962f9da7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a591d98c322093040d59e152591f0978962f9da7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a591d98c322093040d59e152591f0978962f9da7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9d09322b41776a0d6ecde182f731eff77d0f052b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d09322b41776a0d6ecde182f731eff77d0f052b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9d09322b41776a0d6ecde182f731eff77d0f052b"
      }
    ],
    "stats": {
      "total": 1622,
      "additions": 1154,
      "deletions": 468
    },
    "files": [
      {
        "sha": "076ff1295f24357114dd4a07ccb30cfe0689a505",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -2,6 +2,7 @@ bench_inv\n bench_sign\n bench_verify\n bench_recover\n+bench_internal\n tests\n *.exe\n *.so"
      },
      {
        "sha": "0d8089cfe4e87a44c0fd9da376d6407f1ac31c58",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 34,
        "deletions": 7,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -1,14 +1,14 @@\n language: c\n+sudo: false\n+addons:\n+  apt:\n+    packages: libgmp-dev\n compiler:\n   - clang\n   - gcc\n-install:\n-  - sudo apt-get install -qq libssl-dev\n-  - if [ \"$BIGNUM\" = \"gmp\" -o \"$BIGNUM\" = \"auto\" ]; then sudo apt-get install --no-install-recommends --no-upgrade -qq libgmp-dev; fi\n-  - if [ -n \"$EXTRAPACKAGES\" ]; then sudo apt-get update && sudo apt-get install --no-install-recommends --no-upgrade $EXTRAPACKAGES; fi\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  ASM=no  BUILD=check  EXTRAFLAGS= HOST= EXTRAPACKAGES=\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  ASM=no  BUILD=check  EXTRAFLAGS= HOST=\n   matrix:\n     - SCALAR=32bit\n     - SCALAR=64bit\n@@ -22,8 +22,35 @@ env:\n     - BIGNUM=no       ENDOMORPHISM=yes\n     - BUILD=distcheck\n     - EXTRAFLAGS=CFLAGS=-DDETERMINISTIC\n-    - HOST=i686-linux-gnu EXTRAPACKAGES=\"gcc-multilib\"\n-    - HOST=i686-linux-gnu EXTRAPACKAGES=\"gcc-multilib\" ENDOMORPHISM=yes\n+matrix:\n+  fast_finish: true\n+  include:\n+    - compiler: clang\n+      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+            - libgmp-dev:i386\n+    - compiler: clang\n+      env: HOST=i686-linux-gnu\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+    - compiler: gcc\n+      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+    - compiler: gcc\n+      env: HOST=i686-linux-gnu\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+            - libgmp-dev:i386\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi"
      },
      {
        "sha": "06afd4c65bc8e65f5d3662e53919886c58bcc82a",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 101,
        "deletions": 49,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -40,42 +40,60 @@ extern \"C\" {\n #  define SECP256K1_ARG_NONNULL(_x)\n # endif\n \n+/** Opaque data structure that holds context information (precomputed tables etc.).\n+ *  Only functions that take a pointer to a non-const context require exclusive\n+ *  access to it. Multiple functions that take a pointer to a const context may\n+ *  run simultaneously.\n+ */\n+typedef struct secp256k1_context_struct secp256k1_context_t;\n+\n+/** Flags to pass to secp256k1_context_create. */\n+# define SECP256K1_CONTEXT_VERIFY (1 << 0)\n+# define SECP256K1_CONTEXT_SIGN   (1 << 1)\n \n-/** Flags to pass to secp256k1_start. */\n-# define SECP256K1_START_VERIFY (1 << 0)\n-# define SECP256K1_START_SIGN   (1 << 1)\n+/** Create a secp256k1 context object.\n+ *  Returns: a newly created context object.\n+ *  In:      flags: which parts of the context to initialize.\n+ */\n+secp256k1_context_t* secp256k1_context_create(\n+  int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Initialize the library. This may take some time (10-100 ms).\n- *  You need to call this before calling any other function.\n- *  It cannot run in parallel with any other functions, but once\n- *  secp256k1_start() returns, all other functions are thread-safe.\n+/** Copies a secp256k1 context object.\n+ *  Returns: a newly created context object.\n+ *  In:      ctx: an existing context to copy\n  */\n-void secp256k1_start(unsigned int flags);\n+secp256k1_context_t* secp256k1_context_clone(\n+  const secp256k1_context_t* ctx\n+) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Free all memory associated with this library. After this, no\n- *  functions can be called anymore, except secp256k1_start()\n+/** Destroy a secp256k1 context object.\n+ *  The context pointer may not be used afterwards.\n  */\n-void secp256k1_stop(void);\n+void secp256k1_context_destroy(\n+  secp256k1_context_t* ctx\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Verify an ECDSA signature.\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *          -1: invalid public key\n  *          -2: invalid signature\n- * In:       msg32:     the 32-byte message hash being verified (cannot be NULL)\n+ * In:       ctx:       a secp256k1 context object, initialized for verification.\n+ *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n  *           sig:       the signature being verified (cannot be NULL)\n  *           siglen:    the length of the signature\n  *           pubkey:    the public key to verify with (cannot be NULL)\n  *           pubkeylen: the length of pubkey\n- * Requires starting using SECP256K1_START_VERIFY.\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   const unsigned char *sig,\n   int siglen,\n   const unsigned char *pubkey,\n   int pubkeylen\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n /** A pointer to a function to deterministically generate a nonce.\n  * Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n@@ -111,15 +129,14 @@ extern const secp256k1_nonce_function_t secp256k1_nonce_function_default;\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, the private key was invalid, or there is not\n  *              enough space in the signature (as indicated by siglen).\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n+ *  In:      ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n+ *           msg32:  the 32-byte message hash being signed (cannot be NULL)\n  *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n  *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n  *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n  *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n  *  In/Out:  siglen: pointer to an int with the length of sig, which will be updated\n- *                   to contain the actual signature length (<=72). If 0 is returned, this will be\n- *                   set to zero.\n- * Requires starting using SECP256K1_START_SIGN.\n+ *                   to contain the actual signature length (<=72).\n  *\n  * The sig always has an s value in the lower half of the range (From 0x1\n  * to 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n@@ -148,145 +165,180 @@ extern const secp256k1_nonce_function_t secp256k1_nonce_function_default;\n  * be taken when this property is required for an application.\n  */\n int secp256k1_ecdsa_sign(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   unsigned char *sig,\n   int *siglen,\n   const unsigned char *seckey,\n   secp256k1_nonce_function_t noncefp,\n   const void *ndata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n \n /** Create a compact ECDSA signature (64 byte + recovery id).\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n+ *  In:      ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n+ *           msg32:  the 32-byte message hash being signed (cannot be NULL)\n  *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n  *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n  *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n  *  Out:     sig:    pointer to a 64-byte array where the signature will be placed (cannot be NULL)\n  *                   In case 0 is returned, the returned signature length will be zero.\n  *           recid:  pointer to an int, which will be updated to contain the recovery id (can be NULL)\n- * Requires starting using SECP256K1_START_SIGN.\n  */\n int secp256k1_ecdsa_sign_compact(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   unsigned char *sig64,\n   const unsigned char *seckey,\n   secp256k1_nonce_function_t noncefp,\n   const void *ndata,\n   int *recid\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Recover an ECDSA public key from a compact signature.\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  In:      msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  In:      ctx:        pointer to a context object, initialized for verification (cannot be NULL)\n+ *           msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)\n  *           sig64:      signature as 64 byte array (cannot be NULL)\n  *           compressed: whether to recover a compressed or uncompressed pubkey\n  *           recid:      the recovery id (0-3, as returned by ecdsa_sign_compact)\n  *  Out:     pubkey:     pointer to a 33 or 65 byte array to put the pubkey (cannot be NULL)\n  *           pubkeylen:  pointer to an int that will contain the pubkey length (cannot be NULL)\n- * Requires starting using SECP256K1_START_VERIFY.\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover_compact(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   const unsigned char *sig64,\n   unsigned char *pubkey,\n   int *pubkeylen,\n   int compressed,\n   int recid\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n \n /** Verify an ECDSA secret key.\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n- *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  In:      ctx: pointer to a context object (cannot be NULL)\n+ *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n  */\n-SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(const unsigned char *seckey) SECP256K1_ARG_NONNULL(1);\n+SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n+  const secp256k1_context_t* ctx,\n+  const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n \n /** Just validate a public key.\n- *  Returns: 1: valid public key\n- *           0: invalid public key\n- *  In:      pubkey:    pointer to a 33-byte or 65-byte public key (cannot be NULL).\n+ *  Returns: 1: public key is valid\n+ *           0: public key is invalid\n+ *  In:      ctx:       pointer to a context object (cannot be NULL)\n+ *           pubkey:    pointer to a 33-byte or 65-byte public key (cannot be NULL).\n  *           pubkeylen: length of pubkey\n  */\n-SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen) SECP256K1_ARG_NONNULL(1);\n+SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_verify(\n+  const secp256k1_context_t* ctx,\n+  const unsigned char *pubkey,\n+  int pubkeylen\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n \n /** Compute the public key for a secret key.\n- *  In:     compressed: whether the computed public key should be compressed\n+ *  In:     ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n+ *          compressed: whether the computed public key should be compressed\n  *          seckey:     pointer to a 32-byte private key (cannot be NULL)\n  *  Out:    pubkey:     pointer to a 33-byte (if compressed) or 65-byte (if uncompressed)\n  *                      area to store the public key (cannot be NULL)\n  *          pubkeylen:  pointer to int that will be updated to contains the pubkey's\n  *                      length (cannot be NULL)\n  *  Returns: 1: secret was valid, public key stores\n- *           0: secret was invalid, try again.\n- * Requires starting using SECP256K1_START_SIGN.\n+ *           0: secret was invalid, try again\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int *pubkeylen,\n   const unsigned char *seckey,\n   int compressed\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Decompress a public key.\n+ * In:     ctx:       pointer to a context object (cannot be NULL)\n  * In/Out: pubkey:    pointer to a 65-byte array to put the decompressed public key.\n-                      It must contain a 33-byte or 65-byte public key already (cannot be NULL)\n+ *                    It must contain a 33-byte or 65-byte public key already (cannot be NULL)\n  *         pubkeylen: pointer to the size of the public key pointed to by pubkey (cannot be NULL)\n-                      It will be updated to reflect the new size.\n- * Returns: 0 if the passed public key was invalid, 1 otherwise. If 1 is returned, the\n-            pubkey is replaced with its decompressed version.\n+ *                    It will be updated to reflect the new size.\n+ * Returns: 0: pubkey was invalid\n+ *          1: pubkey was valid, and was replaced with its decompressed version\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_decompress(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int *pubkeylen\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Export a private key in DER format. */\n+/** Export a private key in DER format.\n+ * In: ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_export(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *seckey,\n   unsigned char *privkey,\n   int *privkeylen,\n   int compressed\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Import a private key in DER format. */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_import(\n+  const secp256k1_context_t* ctx,\n   unsigned char *seckey,\n   const unsigned char *privkey,\n   int privkeylen\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a private key by adding tweak to it. */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n+  const secp256k1_context_t* ctx,\n   unsigned char *seckey,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by adding tweak times the generator to it.\n- * Requires starting with SECP256K1_START_VERIFY.\n+ * In: ctx: pointer to a context object, initialized for verification (cannot be NULL)\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int pubkeylen,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n \n /** Tweak a private key by multiplying it with tweak. */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n+  const secp256k1_context_t* ctx,\n   unsigned char *seckey,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by multiplying it with tweak.\n- * Requires starting with SECP256K1_START_VERIFY.\n+ * In: ctx: pointer to a context object, initialized for verification (cannot be NULL)\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int pubkeylen,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Updates the context randomization.\n+ *  Returns: 1: randomization successfully updated\n+ *           0: error\n+ *  In:      ctx:       pointer to a context object (cannot be NULL)\n+ *           seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n+ */\n+SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n+  secp256k1_context_t* ctx,\n+  const unsigned char *seed32\n+) SECP256K1_ARG_NONNULL(1);\n+\n \n # ifdef __cplusplus\n }"
      },
      {
        "sha": "db5f68cee1f47306c0092b14016de32f3d169f86",
        "filename": "src/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -48,7 +48,7 @@ void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), v\n     print_number(min * 1000000.0 / iter);\n     printf(\"us / avg \");\n     print_number((sum / count) * 1000000.0 / iter);\n-    printf(\"us / avg \");\n+    printf(\"us / max \");\n     print_number(max * 1000000.0 / iter);\n     printf(\"us\\n\");\n }"
      },
      {
        "sha": "56faed11a043a04825b270cc2f48fb080f112865",
        "filename": "src/bench_recover.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -9,6 +9,7 @@\n #include \"bench.h\"\n \n typedef struct {\n+    secp256k1_context_t *ctx;\n     unsigned char msg[32];\n     unsigned char sig[64];\n } bench_recover_t;\n@@ -21,7 +22,7 @@ void bench_recover(void* arg) {\n     for (i = 0; i < 20000; i++) {\n         int j;\n         int pubkeylen = 33;\n-        CHECK(secp256k1_ecdsa_recover_compact(data->msg, data->sig, pubkey, &pubkeylen, 1, i % 2));\n+        CHECK(secp256k1_ecdsa_recover_compact(data->ctx, data->msg, data->sig, pubkey, &pubkeylen, 1, i % 2));\n         for (j = 0; j < 32; j++) {\n             data->sig[j + 32] = data->msg[j];    /* Move former message to S. */\n             data->msg[j] = data->sig[j];         /* Move former R to message. */\n@@ -40,10 +41,11 @@ void bench_recover_setup(void* arg) {\n \n int main(void) {\n     bench_recover_t data;\n-    secp256k1_start(SECP256K1_START_VERIFY);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n \n     run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n \n-    secp256k1_stop();\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "072a37af516a28ef63a728062fcc4b22f011b7a3",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -9,6 +9,7 @@\n #include \"bench.h\"\n \n typedef struct {\n+    secp256k1_context_t* ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n } bench_sign_t;\n@@ -29,7 +30,7 @@ static void bench_sign(void* arg) {\n     for (i = 0; i < 20000; i++) {\n         int j;\n         int recid = 0;\n-        CHECK(secp256k1_ecdsa_sign_compact(data->msg, sig, data->key, NULL, NULL, &recid));\n+        CHECK(secp256k1_ecdsa_sign_compact(data->ctx, data->msg, sig, data->key, NULL, NULL, &recid));\n         for (j = 0; j < 32; j++) {\n             data->msg[j] = sig[j];             /* Move former R to message. */\n             data->key[j] = sig[j + 32];        /* Move former S to key.     */\n@@ -39,10 +40,11 @@ static void bench_sign(void* arg) {\n \n int main(void) {\n     bench_sign_t data;\n-    secp256k1_start(SECP256K1_START_SIGN);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n     run_benchmark(\"ecdsa_sign\", bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n \n-    secp256k1_stop();\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "c8c82752cec4f14274873a1cd96b4508a663e559",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -12,6 +12,7 @@\n #include \"bench.h\"\n \n typedef struct {\n+    secp256k1_context_t *ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n     unsigned char sig[72];\n@@ -28,7 +29,7 @@ static void benchmark_verify(void* arg) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n-        CHECK(secp256k1_ecdsa_verify(data->msg, data->sig, data->siglen, data->pubkey, data->pubkeylen) == (i == 0));\n+        CHECK(secp256k1_ecdsa_verify(data->ctx, data->msg, data->sig, data->siglen, data->pubkey, data->pubkeylen) == (i == 0));\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n@@ -39,17 +40,17 @@ int main(void) {\n     int i;\n     benchmark_verify_t data;\n \n-    secp256k1_start(SECP256K1_START_VERIFY | SECP256K1_START_SIGN);\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n \n     for (i = 0; i < 32; i++) data.msg[i] = 1 + i;\n     for (i = 0; i < 32; i++) data.key[i] = 33 + i;\n     data.siglen = 72;\n-    secp256k1_ecdsa_sign(data.msg, data.sig, &data.siglen, data.key, NULL, NULL);\n+    secp256k1_ecdsa_sign(data.ctx, data.msg, data.sig, &data.siglen, data.key, NULL, NULL);\n     data.pubkeylen = 33;\n-    CHECK(secp256k1_ec_pubkey_create(data.pubkey, &data.pubkeylen, data.key, 1));\n+    CHECK(secp256k1_ec_pubkey_create(data.ctx, data.pubkey, &data.pubkeylen, data.key, 1));\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n \n-    secp256k1_stop();\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "4ef78e8afb5ea2cbae9b031c7f484b5e9d6890ae",
        "filename": "src/ecdsa.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -9,15 +9,16 @@\n \n #include \"scalar.h\"\n #include \"group.h\"\n+#include \"ecmult.h\"\n \n typedef struct {\n     secp256k1_scalar_t r, s;\n } secp256k1_ecdsa_sig_t;\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned char *sig, int size);\n static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const secp256k1_ecdsa_sig_t *a);\n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message);\n-static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid);\n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid);\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message);\n+static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context_t *ctx, secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid);\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid);\n \n #endif"
      },
      {
        "sha": "ed1d228189d30c2b4e04aabf1e11248f38d250f3",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 58,
        "deletions": 26,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -53,35 +53,59 @@ static int secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned ch\n     int lenr;\n     int lens;\n     int overflow;\n-    if (sig[0] != 0x30) return 0;\n+    if (sig[0] != 0x30) {\n+        return 0;\n+    }\n     lenr = sig[3];\n-    if (5+lenr >= size) return 0;\n+    if (5+lenr >= size) {\n+        return 0;\n+    }\n     lens = sig[lenr+5];\n-    if (sig[1] != lenr+lens+4) return 0;\n-    if (lenr+lens+6 > size) return 0;\n-    if (sig[2] != 0x02) return 0;\n-    if (lenr == 0) return 0;\n-    if (sig[lenr+4] != 0x02) return 0;\n-    if (lens == 0) return 0;\n+    if (sig[1] != lenr+lens+4) {\n+        return 0;\n+    }\n+    if (lenr+lens+6 > size) {\n+        return 0;\n+    }\n+    if (sig[2] != 0x02) {\n+        return 0;\n+    }\n+    if (lenr == 0) {\n+        return 0;\n+    }\n+    if (sig[lenr+4] != 0x02) {\n+        return 0;\n+    }\n+    if (lens == 0) {\n+        return 0;\n+    }\n     sp = sig + 6 + lenr;\n     while (lens > 0 && sp[0] == 0) {\n         lens--;\n         sp++;\n     }\n-    if (lens > 32) return 0;\n+    if (lens > 32) {\n+        return 0;\n+    }\n     rp = sig + 4;\n     while (lenr > 0 && rp[0] == 0) {\n         lenr--;\n         rp++;\n     }\n-    if (lenr > 32) return 0;\n+    if (lenr > 32) {\n+        return 0;\n+    }\n     memcpy(ra + 32 - lenr, rp, lenr);\n     memcpy(sa + 32 - lens, sp, lens);\n     overflow = 0;\n     secp256k1_scalar_set_b32(&r->r, ra, &overflow);\n-    if (overflow) return 0;\n+    if (overflow) {\n+        return 0;\n+    }\n     secp256k1_scalar_set_b32(&r->s, sa, &overflow);\n-    if (overflow) return 0;\n+    if (overflow) {\n+        return 0;\n+    }\n     return 1;\n }\n \n@@ -93,8 +117,9 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const se\n     secp256k1_scalar_get_b32(&s[1], &a->s);\n     while (lenR > 1 && rp[0] == 0 && rp[1] < 0x80) { lenR--; rp++; }\n     while (lenS > 1 && sp[0] == 0 && sp[1] < 0x80) { lenS--; sp++; }\n-    if (*size < 6+lenS+lenR)\n+    if (*size < 6+lenS+lenR) {\n         return 0;\n+    }\n     *size = 6 + lenS + lenR;\n     sig[0] = 0x30;\n     sig[1] = 4 + lenS + lenR;\n@@ -107,21 +132,22 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const se\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n     unsigned char c[32];\n     secp256k1_scalar_t sn, u1, u2;\n     secp256k1_fe_t xr;\n     secp256k1_gej_t pubkeyj;\n     secp256k1_gej_t pr;\n \n-    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s))\n+    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_inverse_var(&sn, &sig->s);\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, &sig->r);\n     secp256k1_gej_set_ge(&pubkeyj, pubkey);\n-    secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n+    secp256k1_ecmult(ctx, &pr, &pubkeyj, &u2, &u1);\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }\n@@ -160,44 +186,47 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const se\n     return 0;\n }\n \n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid) {\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid) {\n     unsigned char brx[32];\n     secp256k1_fe_t fx;\n     secp256k1_ge_t x;\n     secp256k1_gej_t xj;\n     secp256k1_scalar_t rn, u1, u2;\n     secp256k1_gej_t qj;\n \n-    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s))\n+    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_get_b32(brx, &sig->r);\n     VERIFY_CHECK(secp256k1_fe_set_b32(&fx, brx)); /* brx comes from a scalar, so is less than the order; certainly less than p */\n     if (recid & 2) {\n-        if (secp256k1_fe_cmp_var(&fx, &secp256k1_ecdsa_const_p_minus_order) >= 0)\n+        if (secp256k1_fe_cmp_var(&fx, &secp256k1_ecdsa_const_p_minus_order) >= 0) {\n             return 0;\n+        }\n         secp256k1_fe_add(&fx, &secp256k1_ecdsa_const_order_as_fe);\n     }\n-    if (!secp256k1_ge_set_xo_var(&x, &fx, recid & 1))\n+    if (!secp256k1_ge_set_xo_var(&x, &fx, recid & 1)) {\n         return 0;\n+    }\n     secp256k1_gej_set_ge(&xj, &x);\n     secp256k1_scalar_inverse_var(&rn, &sig->r);\n     secp256k1_scalar_mul(&u1, &rn, message);\n     secp256k1_scalar_negate(&u1, &u1);\n     secp256k1_scalar_mul(&u2, &rn, &sig->s);\n-    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n+    secp256k1_ecmult(ctx, &qj, &xj, &u2, &u1);\n     secp256k1_ge_set_gej_var(pubkey, &qj);\n     return !secp256k1_gej_is_infinity(&qj);\n }\n \n-static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n+static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context_t *ctx, secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n     unsigned char b[32];\n     secp256k1_gej_t rp;\n     secp256k1_ge_t r;\n     secp256k1_scalar_t n;\n     int overflow = 0;\n \n-    secp256k1_ecmult_gen(&rp, nonce);\n+    secp256k1_ecmult_gen(ctx, &rp, nonce);\n     secp256k1_ge_set_gej(&r, &rp);\n     secp256k1_fe_normalize(&r.x);\n     secp256k1_fe_normalize(&r.y);\n@@ -209,21 +238,24 @@ static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_\n         secp256k1_ge_clear(&r);\n         return 0;\n     }\n-    if (recid)\n+    if (recid) {\n         *recid = (overflow ? 2 : 0) | (secp256k1_fe_is_odd(&r.y) ? 1 : 0);\n+    }\n     secp256k1_scalar_mul(&n, &sig->r, seckey);\n     secp256k1_scalar_add(&n, &n, message);\n     secp256k1_scalar_inverse(&sig->s, nonce);\n     secp256k1_scalar_mul(&sig->s, &sig->s, &n);\n     secp256k1_scalar_clear(&n);\n     secp256k1_gej_clear(&rp);\n     secp256k1_ge_clear(&r);\n-    if (secp256k1_scalar_is_zero(&sig->s))\n+    if (secp256k1_scalar_is_zero(&sig->s)) {\n         return 0;\n+    }\n     if (secp256k1_scalar_is_high(&sig->s)) {\n         secp256k1_scalar_negate(&sig->s, &sig->s);\n-        if (recid)\n+        if (recid) {\n             *recid ^= 1;\n+        }\n     }\n     return 1;\n }"
      },
      {
        "sha": "53b818485ed6d5158dbc6cb9e8c911c0afadbf3c",
        "filename": "src/eckey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -9,16 +9,18 @@\n \n #include \"group.h\"\n #include \"scalar.h\"\n+#include \"ecmult.h\"\n+#include \"ecmult_gen.h\"\n \n static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size);\n static int secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char *pub, int *size, int compressed);\n \n static int secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned char *privkey, int privkeylen);\n-static int secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed);\n+static int secp256k1_eckey_privkey_serialize(const secp256k1_ecmult_gen_context_t *ctx, unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed);\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n-static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n+static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n-static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n+static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n \n #endif"
      },
      {
        "sha": "a332bd34ecda4bb21357569027c602c727a50301",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 18,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -24,8 +24,9 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned cha\n             return 0;\n         }\n         secp256k1_ge_set_xy(elem, &x, &y);\n-        if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07))\n+        if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07)) {\n             return 0;\n+        }\n         return secp256k1_ge_is_valid_var(elem);\n     } else {\n         return 0;\n@@ -57,40 +58,47 @@ static int secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned\n     int len = 0;\n     int overflow = 0;\n     /* sequence header */\n-    if (end < privkey+1 || *privkey != 0x30)\n+    if (end < privkey+1 || *privkey != 0x30) {\n         return 0;\n+    }\n     privkey++;\n     /* sequence length constructor */\n-    if (end < privkey+1 || !(*privkey & 0x80))\n+    if (end < privkey+1 || !(*privkey & 0x80)) {\n         return 0;\n+    }\n     lenb = *privkey & ~0x80; privkey++;\n-    if (lenb < 1 || lenb > 2)\n+    if (lenb < 1 || lenb > 2) {\n         return 0;\n-    if (end < privkey+lenb)\n+    }\n+    if (end < privkey+lenb) {\n         return 0;\n+    }\n     /* sequence length */\n     len = privkey[lenb-1] | (lenb > 1 ? privkey[lenb-2] << 8 : 0);\n     privkey += lenb;\n-    if (end < privkey+len)\n+    if (end < privkey+len) {\n         return 0;\n+    }\n     /* sequence element 0: version number (=1) */\n-    if (end < privkey+3 || privkey[0] != 0x02 || privkey[1] != 0x01 || privkey[2] != 0x01)\n+    if (end < privkey+3 || privkey[0] != 0x02 || privkey[1] != 0x01 || privkey[2] != 0x01) {\n         return 0;\n+    }\n     privkey += 3;\n     /* sequence element 1: octet string, up to 32 bytes */\n-    if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1])\n+    if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1]) {\n         return 0;\n+    }\n     memcpy(c + 32 - privkey[1], privkey + 2, privkey[1]);\n     secp256k1_scalar_set_b32(key, c, &overflow);\n     memset(c, 0, 32);\n     return !overflow;\n }\n \n-static int secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed) {\n+static int secp256k1_eckey_privkey_serialize(const secp256k1_ecmult_gen_context_t *ctx, unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed) {\n     secp256k1_gej_t rp;\n     secp256k1_ge_t r;\n     int pubkeylen = 0;\n-    secp256k1_ecmult_gen(&rp, key);\n+    secp256k1_ecmult_gen(ctx, &rp, key);\n     secp256k1_ge_set_gej(&r, &rp);\n     if (compressed) {\n         static const unsigned char begin[] = {\n@@ -148,41 +156,45 @@ static int secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privke\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n     secp256k1_scalar_add(key, key, tweak);\n-    if (secp256k1_scalar_is_zero(key))\n+    if (secp256k1_scalar_is_zero(key)) {\n         return 0;\n+    }\n     return 1;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n     secp256k1_gej_t pt;\n     secp256k1_scalar_t one;\n     secp256k1_gej_set_ge(&pt, key);\n     secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_ecmult(&pt, &pt, &one, tweak);\n+    secp256k1_ecmult(ctx, &pt, &pt, &one, tweak);\n \n-    if (secp256k1_gej_is_infinity(&pt))\n+    if (secp256k1_gej_is_infinity(&pt)) {\n         return 0;\n+    }\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }\n \n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n-    if (secp256k1_scalar_is_zero(tweak))\n+    if (secp256k1_scalar_is_zero(tweak)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_mul(key, key, tweak);\n     return 1;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n     secp256k1_scalar_t zero;\n     secp256k1_gej_t pt;\n-    if (secp256k1_scalar_is_zero(tweak))\n+    if (secp256k1_scalar_is_zero(tweak)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_set_int(&zero, 0);\n     secp256k1_gej_set_ge(&pt, key);\n-    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n+    secp256k1_ecmult(ctx, &pt, &pt, tweak, &zero);\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }"
      },
      {
        "sha": "bab9e4ef52242e42906b630480356400c6665a70",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -10,10 +10,22 @@\n #include \"num.h\"\n #include \"group.h\"\n \n-static void secp256k1_ecmult_start(void);\n-static void secp256k1_ecmult_stop(void);\n+typedef struct {\n+    /* For accelerating the computation of a*P + b*G: */\n+    secp256k1_ge_storage_t (*pre_g)[];    /* odd multiples of the generator */\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge_storage_t (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n+#endif\n+} secp256k1_ecmult_context_t;\n+\n+static void secp256k1_ecmult_context_init(secp256k1_ecmult_context_t *ctx);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context_t *ctx);\n+static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context_t *dst,\n+                                           const secp256k1_ecmult_context_t *src);\n+static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context_t *ctx);\n+static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context_t *ctx);\n \n /** Double multiply: R = na*A + ng*G */\n-static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng);\n+static void secp256k1_ecmult(const secp256k1_ecmult_context_t *ctx, secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng);\n \n #endif"
      },
      {
        "sha": "3745633c47f91acd24926888fcf7889d4488799a",
        "filename": "src/ecmult_gen.h",
        "status": "modified",
        "additions": 27,
        "deletions": 3,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -10,10 +10,34 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-static void secp256k1_ecmult_gen_start(void);\n-static void secp256k1_ecmult_gen_stop(void);\n+typedef struct {\n+    /* For accelerating the computation of a*G:\n+     * To harden against timing attacks, use the following mechanism:\n+     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n+     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n+     *   * U_i = U * 2^i (for i=0..62)\n+     *   * U_i = U * (1-2^63) (for i=63)\n+     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n+     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n+     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+     * None of the resulting prec group elements have a known scalar, and neither do any of\n+     * the intermediate sums while computing a*G.\n+     */\n+    secp256k1_ge_storage_t (*prec)[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n+    secp256k1_scalar_t blind;\n+    secp256k1_gej_t initial;\n+} secp256k1_ecmult_gen_context_t;\n+\n+static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context_t* ctx);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context_t* ctx);\n+static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context_t *dst,\n+                                               const secp256k1_ecmult_gen_context_t* src);\n+static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context_t* ctx);\n+static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context_t* ctx);\n \n /** Multiply with the generator: R = a*G */\n-static void secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *a);\n+static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context_t* ctx, secp256k1_gej_t *r, const secp256k1_scalar_t *a);\n+\n+static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context_t *ctx, const unsigned char *seed32);\n \n #endif"
      },
      {
        "sha": "4697753ac81f85d4db62dcdaba15ed5b384dccae",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 96,
        "deletions": 38,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell      *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -10,36 +10,23 @@\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n+#include \"hash_impl.h\"\n \n-typedef struct {\n-    /* For accelerating the computation of a*G:\n-     * To harden against timing attacks, use the following mechanism:\n-     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n-     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n-     *   * U_i = U * 2^i (for i=0..62)\n-     *   * U_i = U * (1-2^63) (for i=63)\n-     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n-     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n-     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n-     * None of the resulting prec group elements have a known scalar, and neither do any of\n-     * the intermediate sums while computing a*G.\n-     */\n-    secp256k1_ge_storage_t prec[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n-} secp256k1_ecmult_gen_consts_t;\n-\n-static const secp256k1_ecmult_gen_consts_t *secp256k1_ecmult_gen_consts = NULL;\n+static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context_t *ctx) {\n+    ctx->prec = NULL;\n+}\n \n-static void secp256k1_ecmult_gen_start(void) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context_t *ctx) {\n     secp256k1_ge_t prec[1024];\n     secp256k1_gej_t gj;\n     secp256k1_gej_t nums_gej;\n-    secp256k1_ecmult_gen_consts_t *ret;\n     int i, j;\n-    if (secp256k1_ecmult_gen_consts != NULL)\n+\n+    if (ctx->prec != NULL) {\n         return;\n+    }\n \n-    /* Allocate the precomputation table. */\n-    ret = (secp256k1_ecmult_gen_consts_t*)checked_malloc(sizeof(secp256k1_ecmult_gen_consts_t));\n+    ctx->prec = (secp256k1_ge_storage_t (*)[64][16])checked_malloc(sizeof(*ctx->prec));\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -85,42 +72,113 @@ static void secp256k1_ecmult_gen_start(void) {\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {\n-            secp256k1_ge_to_storage(&ret->prec[j][i], &prec[j*16 + i]);\n+            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*16 + i]);\n         }\n     }\n+    secp256k1_ecmult_gen_blind(ctx, NULL);\n+}\n \n-    /* Set the global pointer to the precomputation table. */\n-    secp256k1_ecmult_gen_consts = ret;\n+static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context_t* ctx) {\n+    return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_stop(void) {\n-    secp256k1_ecmult_gen_consts_t *c;\n-    if (secp256k1_ecmult_gen_consts == NULL)\n-        return;\n+static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context_t *dst,\n+                                               const secp256k1_ecmult_gen_context_t *src) {\n+    if (src->prec == NULL) {\n+        dst->prec = NULL;\n+    } else {\n+        dst->prec = (secp256k1_ge_storage_t (*)[64][16])checked_malloc(sizeof(*dst->prec));\n+        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+        dst->initial = src->initial;\n+        dst->blind = src->blind;\n+    }\n+}\n \n-    c = (secp256k1_ecmult_gen_consts_t*)secp256k1_ecmult_gen_consts;\n-    secp256k1_ecmult_gen_consts = NULL;\n-    free(c);\n+static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context_t *ctx) {\n+    free(ctx->prec);\n+    secp256k1_scalar_clear(&ctx->blind);\n+    secp256k1_gej_clear(&ctx->initial);\n+    ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *gn) {\n-    const secp256k1_ecmult_gen_consts_t *c = secp256k1_ecmult_gen_consts;\n+static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context_t *ctx, secp256k1_gej_t *r, const secp256k1_scalar_t *gn) {\n     secp256k1_ge_t add;\n     secp256k1_ge_storage_t adds;\n+    secp256k1_scalar_t gnb;\n     int bits;\n     int i, j;\n-    secp256k1_gej_set_infinity(r);\n+    memset(&adds, 0, sizeof(adds));\n+    *r = ctx->initial;\n+    /* Blind scalar/point multiplication by computing (n-b)G + bG instead of nG. */\n+    secp256k1_scalar_add(&gnb, gn, &ctx->blind);\n     add.infinity = 0;\n     for (j = 0; j < 64; j++) {\n-        bits = secp256k1_scalar_get_bits(gn, j * 4, 4);\n+        bits = secp256k1_scalar_get_bits(&gnb, j * 4, 4);\n         for (i = 0; i < 16; i++) {\n-            secp256k1_ge_storage_cmov(&adds, &c->prec[j][i], i == bits);\n+            /** This uses a conditional move to avoid any secret data in array indexes.\n+             *   _Any_ use of secret indexes has been demonstrated to result in timing\n+             *   sidechannels, even when the cache-line access patterns are uniform.\n+             *  See also:\n+             *   \"A word of warning\", CHES 2013 Rump Session, by Daniel J. Bernstein and Peter Schwabe\n+             *    (https://cryptojedi.org/peter/data/chesrump-20130822.pdf) and\n+             *   \"Cache Attacks and Countermeasures: the Case of AES\", RSA 2006,\n+             *    by Dag Arne Osvik, Adi Shamir, and Eran Tromer\n+             *    (http://www.tau.ac.il/~tromer/papers/cache.pdf)\n+             */\n+            secp256k1_ge_storage_cmov(&adds, &(*ctx->prec)[j][i], i == bits);\n         }\n         secp256k1_ge_from_storage(&add, &adds);\n         secp256k1_gej_add_ge(r, r, &add);\n     }\n     bits = 0;\n     secp256k1_ge_clear(&add);\n+    secp256k1_scalar_clear(&gnb);\n+}\n+\n+/* Setup blinding values for secp256k1_ecmult_gen. */\n+static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context_t *ctx, const unsigned char *seed32) {\n+    secp256k1_scalar_t b;\n+    secp256k1_gej_t gb;\n+    secp256k1_fe_t s;\n+    unsigned char nonce32[32];\n+    secp256k1_rfc6979_hmac_sha256_t rng;\n+    int retry;\n+    if (!seed32) {\n+        /* When seed is NULL, reset the initial point and blinding value. */\n+        secp256k1_gej_set_ge(&ctx->initial, &secp256k1_ge_const_g);\n+        secp256k1_gej_neg(&ctx->initial, &ctx->initial);\n+        secp256k1_scalar_set_int(&ctx->blind, 1);\n+    }\n+    /* The prior blinding value (if not reset) is chained forward by including it in the hash. */\n+    secp256k1_scalar_get_b32(nonce32, &ctx->blind);\n+    /** Using a CSPRNG allows a failure free interface, avoids needing large amounts of random data,\n+     *   and guards against weak or adversarial seeds.  This is a simpler and safer interface than\n+     *   asking the caller for blinding values directly and expecting them to retry on failure.\n+     */\n+    secp256k1_rfc6979_hmac_sha256_initialize(&rng, seed32 ? seed32 : nonce32, 32, nonce32, 32, NULL, 0);\n+    /* Retry for out of range results to achieve uniformity. */\n+    do {\n+        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+        retry = !secp256k1_fe_set_b32(&s, nonce32);\n+        retry |= secp256k1_fe_is_zero(&s);\n+    } while (retry);\n+    /* Randomize the projection to defend against multiplier sidechannels. */\n+    secp256k1_gej_rescale(&ctx->initial, &s);\n+    secp256k1_fe_clear(&s);\n+    do {\n+        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+        secp256k1_scalar_set_b32(&b, nonce32, &retry);\n+        /* A blinding value of 0 works, but would undermine the projection hardening. */\n+        retry |= secp256k1_scalar_is_zero(&b);\n+    } while (retry);\n+    secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n+    memset(nonce32, 0, 32);\n+    secp256k1_ecmult_gen(ctx, &gb, &b);\n+    secp256k1_scalar_negate(&b, &b);\n+    ctx->blind = b;\n+    ctx->initial = gb;\n+    secp256k1_scalar_clear(&b);\n+    secp256k1_gej_clear(&gb);\n }\n \n #endif"
      },
      {
        "sha": "1b2856f83df45ca30f92a2cdb606cf903f725380",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 71,
        "deletions": 42,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -41,16 +41,17 @@ static void secp256k1_ecmult_table_precomp_gej_var(secp256k1_gej_t *pre, const s\n     int i;\n     pre[0] = *a;\n     secp256k1_gej_double_var(&d, &pre[0]);\n-    for (i = 1; i < (1 << (w-2)); i++)\n+    for (i = 1; i < (1 << (w-2)); i++) {\n         secp256k1_gej_add_var(&pre[i], &d, &pre[i-1]);\n+    }\n }\n \n static void secp256k1_ecmult_table_precomp_ge_storage_var(secp256k1_ge_storage_t *pre, const secp256k1_gej_t *a, int w) {\n     secp256k1_gej_t d;\n     int i;\n     const int table_size = 1 << (w-2);\n-    secp256k1_gej_t *prej = checked_malloc(sizeof(secp256k1_gej_t) * table_size);\n-    secp256k1_ge_t *prea = checked_malloc(sizeof(secp256k1_ge_t) * table_size);\n+    secp256k1_gej_t *prej = (secp256k1_gej_t *)checked_malloc(sizeof(secp256k1_gej_t) * table_size);\n+    secp256k1_ge_t *prea = (secp256k1_ge_t *)checked_malloc(sizeof(secp256k1_ge_t) * table_size);\n     prej[0] = *a;\n     secp256k1_gej_double_var(&d, a);\n     for (i = 1; i < table_size; i++) {\n@@ -73,73 +74,93 @@ static void secp256k1_ecmult_table_precomp_ge_storage_var(secp256k1_ge_storage_t\n     VERIFY_CHECK(((n) & 1) == 1); \\\n     VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n     VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n-    if ((n) > 0) \\\n+    if ((n) > 0) { \\\n         *(r) = (pre)[((n)-1)/2]; \\\n-    else \\\n+    } else { \\\n         secp256k1_gej_neg((r), &(pre)[(-(n)-1)/2]); \\\n+    } \\\n } while(0)\n #define ECMULT_TABLE_GET_GE_STORAGE(r,pre,n,w) do { \\\n     VERIFY_CHECK(((n) & 1) == 1); \\\n     VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n     VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n-    if ((n) > 0) \\\n+    if ((n) > 0) { \\\n         secp256k1_ge_from_storage((r), &(pre)[((n)-1)/2]); \\\n-    else {\\\n+    } else { \\\n         secp256k1_ge_from_storage((r), &(pre)[(-(n)-1)/2]); \\\n         secp256k1_ge_neg((r), (r)); \\\n     } \\\n } while(0)\n \n-typedef struct {\n-    /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_storage_t pre_g[ECMULT_TABLE_SIZE(WINDOW_G)];    /* odd multiples of the generator */\n+static void secp256k1_ecmult_context_init(secp256k1_ecmult_context_t *ctx) {\n+    ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n-    secp256k1_ge_storage_t pre_g_128[ECMULT_TABLE_SIZE(WINDOW_G)]; /* odd multiples of 2^128*generator */\n+    ctx->pre_g_128 = NULL;\n #endif\n-} secp256k1_ecmult_consts_t;\n-\n-static const secp256k1_ecmult_consts_t *secp256k1_ecmult_consts = NULL;\n+}\n \n-static void secp256k1_ecmult_start(void) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context_t *ctx) {\n     secp256k1_gej_t gj;\n-    secp256k1_ecmult_consts_t *ret;\n-    if (secp256k1_ecmult_consts != NULL)\n-        return;\n \n-    /* Allocate the precomputation table. */\n-    ret = (secp256k1_ecmult_consts_t*)checked_malloc(sizeof(secp256k1_ecmult_consts_t));\n+    if (ctx->pre_g != NULL) {\n+        return;\n+    }\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n+    ctx->pre_g = (secp256k1_ge_storage_t (*)[])checked_malloc(sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n \n     /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_table_precomp_ge_storage_var(ret->pre_g, &gj, WINDOW_G);\n+    secp256k1_ecmult_table_precomp_ge_storage_var(*ctx->pre_g, &gj, WINDOW_G);\n \n #ifdef USE_ENDOMORPHISM\n     {\n         secp256k1_gej_t g_128j;\n         int i;\n+\n+        ctx->pre_g_128 = (secp256k1_ge_storage_t (*)[])checked_malloc(sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+\n         /* calculate 2^128*generator */\n         g_128j = gj;\n-        for (i = 0; i < 128; i++)\n+        for (i = 0; i < 128; i++) {\n             secp256k1_gej_double_var(&g_128j, &g_128j);\n-        secp256k1_ecmult_table_precomp_ge_storage_var(ret->pre_g_128, &g_128j, WINDOW_G);\n+        }\n+        secp256k1_ecmult_table_precomp_ge_storage_var(*ctx->pre_g_128, &g_128j, WINDOW_G);\n     }\n #endif\n+}\n \n-    /* Set the global pointer to the precomputation table. */\n-    secp256k1_ecmult_consts = ret;\n+static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context_t *dst,\n+                                           const secp256k1_ecmult_context_t *src) {\n+    if (src->pre_g == NULL) {\n+        dst->pre_g = NULL;\n+    } else {\n+        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n+        dst->pre_g = (secp256k1_ge_storage_t (*)[])checked_malloc(size);\n+        memcpy(dst->pre_g, src->pre_g, size);\n+    }\n+#ifdef USE_ENDOMORPHISM\n+    if (src->pre_g_128 == NULL) {\n+        dst->pre_g_128 = NULL;\n+    } else {\n+        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n+        dst->pre_g_128 = (secp256k1_ge_storage_t (*)[])checked_malloc(size);\n+        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    }\n+#endif\n }\n \n-static void secp256k1_ecmult_stop(void) {\n-    secp256k1_ecmult_consts_t *c;\n-    if (secp256k1_ecmult_consts == NULL)\n-        return;\n+static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context_t *ctx) {\n+    return ctx->pre_g != NULL;\n+}\n \n-    c = (secp256k1_ecmult_consts_t*)secp256k1_ecmult_consts;\n-    secp256k1_ecmult_consts = NULL;\n-    free(c);\n+static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context_t *ctx) {\n+    free(ctx->pre_g);\n+#ifdef USE_ENDOMORPHISM\n+    free(ctx->pre_g_128);\n+#endif\n+    secp256k1_ecmult_context_init(ctx);\n }\n \n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n@@ -186,11 +207,10 @@ static int secp256k1_ecmult_wnaf(int *wnaf, const secp256k1_scalar_t *a, int w)\n     return set_bits;\n }\n \n-static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng) {\n+static void secp256k1_ecmult(const secp256k1_ecmult_context_t *ctx, secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng) {\n     secp256k1_gej_t tmpj;\n     secp256k1_gej_t pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge_t tmpa;\n-    const secp256k1_ecmult_consts_t *c = secp256k1_ecmult_consts;\n #ifdef USE_ENDOMORPHISM\n     secp256k1_gej_t pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_scalar_t na_1, na_lam;\n@@ -223,7 +243,9 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n     VERIFY_CHECK(bits_na_1 <= 130);\n     VERIFY_CHECK(bits_na_lam <= 130);\n     bits = bits_na_1;\n-    if (bits_na_lam > bits) bits = bits_na_lam;\n+    if (bits_na_lam > bits) {\n+        bits = bits_na_lam;\n+    }\n #else\n     /* build wnaf representation for na. */\n     bits_na     = secp256k1_ecmult_wnaf(wnaf_na,     na,      WINDOW_A);\n@@ -234,20 +256,27 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n     secp256k1_ecmult_table_precomp_gej_var(pre_a, a, WINDOW_A);\n \n #ifdef USE_ENDOMORPHISM\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++)\n+    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n         secp256k1_gej_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+    }\n \n     /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */\n     secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n \n     /* Build wnaf representation for ng_1 and ng_128 */\n     bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   &ng_1,   WINDOW_G);\n     bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, &ng_128, WINDOW_G);\n-    if (bits_ng_1 > bits) bits = bits_ng_1;\n-    if (bits_ng_128 > bits) bits = bits_ng_128;\n+    if (bits_ng_1 > bits) {\n+        bits = bits_ng_1;\n+    }\n+    if (bits_ng_128 > bits) {\n+        bits = bits_ng_128;\n+    }\n #else\n     bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     ng,      WINDOW_G);\n-    if (bits_ng > bits) bits = bits_ng;\n+    if (bits_ng > bits) {\n+        bits = bits_ng;\n+    }\n #endif\n \n     secp256k1_gej_set_infinity(r);\n@@ -265,11 +294,11 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n             secp256k1_gej_add_var(r, r, &tmpj);\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, c->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, c->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n #else\n@@ -278,7 +307,7 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n             secp256k1_gej_add_var(r, r, &tmpj);\n         }\n         if (i < bits_ng && (n = wnaf_ng[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, c->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n #endif"
      },
      {
        "sha": "41b280892d93d57aad22bbfd7eae7b945e9d4570",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -113,4 +113,7 @@ static void secp256k1_fe_from_storage(secp256k1_fe_t *r, const secp256k1_fe_stor\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n static void secp256k1_fe_storage_cmov(secp256k1_fe_storage_t *r, const secp256k1_fe_storage_t *a, int flag);\n \n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+static void secp256k1_fe_cmov(secp256k1_fe_t *r, const secp256k1_fe_t *a, int flag);\n+\n #endif"
      },
      {
        "sha": "871b91f9123170436392fe619674a97c53637e58",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 3,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -236,8 +236,9 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe_t *r) {\n     z1 = z0 ^ 0x3D0UL;\n \n     /* Fast return path should catch the majority of cases */\n-    if ((z0 != 0UL) & (z1 != 0x3FFFFFFUL))\n+    if ((z0 != 0UL) & (z1 != 0x3FFFFFFUL)) {\n         return 0;\n+    }\n \n     t1 = r->n[1];\n     t2 = r->n[2];\n@@ -315,8 +316,12 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe_t *a, const secp256k1_fe_t *b\n     secp256k1_fe_verify(b);\n #endif\n     for (i = 9; i >= 0; i--) {\n-        if (a->n[i] > b->n[i]) return 1;\n-        if (a->n[i] < b->n[i]) return -1;\n+        if (a->n[i] > b->n[i]) {\n+            return 1;\n+        }\n+        if (a->n[i] < b->n[i]) {\n+            return -1;\n+        }\n     }\n     return 0;\n }\n@@ -1063,6 +1068,26 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #endif\n }\n \n+static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe_t *r, const secp256k1_fe_t *a, int flag) {\n+    uint32_t mask0, mask1;\n+    mask0 = flag + ~((uint32_t)0);\n+    mask1 = ~mask0;\n+    r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n+    r->n[1] = (r->n[1] & mask0) | (a->n[1] & mask1);\n+    r->n[2] = (r->n[2] & mask0) | (a->n[2] & mask1);\n+    r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);\n+    r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);\n+    r->n[5] = (r->n[5] & mask0) | (a->n[5] & mask1);\n+    r->n[6] = (r->n[6] & mask0) | (a->n[6] & mask1);\n+    r->n[7] = (r->n[7] & mask0) | (a->n[7] & mask1);\n+    r->n[8] = (r->n[8] & mask0) | (a->n[8] & mask1);\n+    r->n[9] = (r->n[9] & mask0) | (a->n[9] & mask1);\n+#ifdef VERIFY\n+    r->magnitude = (r->magnitude & mask0) | (a->magnitude & mask1);\n+    r->normalized = (r->normalized & mask0) | (a->normalized & mask1);\n+#endif\n+}\n+\n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage_t *r, const secp256k1_fe_storage_t *a, int flag) {\n     uint32_t mask0, mask1;\n     mask0 = flag + ~((uint32_t)0);"
      },
      {
        "sha": "bda4c3dfc2de0b53a60f3303ac6059942e8c9006",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -209,8 +209,9 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe_t *r) {\n     z1 = z0 ^ 0x1000003D0ULL;\n \n     /* Fast return path should catch the majority of cases */\n-    if ((z0 != 0ULL) & (z1 != 0xFFFFFFFFFFFFFULL))\n+    if ((z0 != 0ULL) & (z1 != 0xFFFFFFFFFFFFFULL)) {\n         return 0;\n+    }\n \n     t1 = r->n[1];\n     t2 = r->n[2];\n@@ -277,8 +278,12 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe_t *a, const secp256k1_fe_t *b\n     secp256k1_fe_verify(b);\n #endif\n     for (i = 4; i >= 0; i--) {\n-        if (a->n[i] > b->n[i]) return 1;\n-        if (a->n[i] < b->n[i]) return -1;\n+        if (a->n[i] > b->n[i]) {\n+            return 1;\n+        }\n+        if (a->n[i] < b->n[i]) {\n+            return -1;\n+        }\n     }\n     return 0;\n }\n@@ -399,6 +404,21 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #endif\n }\n \n+static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe_t *r, const secp256k1_fe_t *a, int flag) {\n+    uint64_t mask0, mask1;\n+    mask0 = flag + ~((uint64_t)0);\n+    mask1 = ~mask0;\n+    r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n+    r->n[1] = (r->n[1] & mask0) | (a->n[1] & mask1);\n+    r->n[2] = (r->n[2] & mask0) | (a->n[2] & mask1);\n+    r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);\n+    r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);\n+#ifdef VERIFY\n+    r->magnitude = (r->magnitude & mask0) | (a->magnitude & mask1);\n+    r->normalized = (r->normalized & mask0) | (a->normalized & mask1);\n+#endif\n+}\n+\n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage_t *r, const secp256k1_fe_storage_t *a, int flag) {\n     uint64_t mask0, mask1;\n     mask0 = flag + ~((uint64_t)0);"
      },
      {
        "sha": "e6ec11e8f2c48c88863b61cb34dd6d778aa2da03",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 74,
        "deletions": 25,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -44,47 +44,69 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_mul(&x3, &x3, a);\n \n     x6 = x3;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x6, &x6);\n+    }\n     secp256k1_fe_mul(&x6, &x6, &x3);\n \n     x9 = x6;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x9, &x9);\n+    }\n     secp256k1_fe_mul(&x9, &x9, &x3);\n \n     x11 = x9;\n-    for (j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    for (j=0; j<2; j++) {\n+        secp256k1_fe_sqr(&x11, &x11);\n+    }\n     secp256k1_fe_mul(&x11, &x11, &x2);\n \n     x22 = x11;\n-    for (j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    for (j=0; j<11; j++) {\n+        secp256k1_fe_sqr(&x22, &x22);\n+    }\n     secp256k1_fe_mul(&x22, &x22, &x11);\n \n     x44 = x22;\n-    for (j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    for (j=0; j<22; j++) {\n+        secp256k1_fe_sqr(&x44, &x44);\n+    }\n     secp256k1_fe_mul(&x44, &x44, &x22);\n \n     x88 = x44;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x88, &x88);\n+    }\n     secp256k1_fe_mul(&x88, &x88, &x44);\n \n     x176 = x88;\n-    for (j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    for (j=0; j<88; j++) {\n+        secp256k1_fe_sqr(&x176, &x176);\n+    }\n     secp256k1_fe_mul(&x176, &x176, &x88);\n \n     x220 = x176;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x220, &x220);\n+    }\n     secp256k1_fe_mul(&x220, &x220, &x44);\n \n     x223 = x220;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x223, &x223);\n+    }\n     secp256k1_fe_mul(&x223, &x223, &x3);\n \n     /* The final result is then assembled using a sliding window over the blocks. */\n \n     t1 = x223;\n-    for (j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<23; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x22);\n-    for (j=0; j<6; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<6; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x2);\n     secp256k1_fe_sqr(&t1, &t1);\n     secp256k1_fe_sqr(r, &t1);\n@@ -111,51 +133,77 @@ static void secp256k1_fe_inv(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_mul(&x3, &x3, a);\n \n     x6 = x3;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x6, &x6);\n+    }\n     secp256k1_fe_mul(&x6, &x6, &x3);\n \n     x9 = x6;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x9, &x9);\n+    }\n     secp256k1_fe_mul(&x9, &x9, &x3);\n \n     x11 = x9;\n-    for (j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    for (j=0; j<2; j++) {\n+        secp256k1_fe_sqr(&x11, &x11);\n+    }\n     secp256k1_fe_mul(&x11, &x11, &x2);\n \n     x22 = x11;\n-    for (j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    for (j=0; j<11; j++) {\n+        secp256k1_fe_sqr(&x22, &x22);\n+    }\n     secp256k1_fe_mul(&x22, &x22, &x11);\n \n     x44 = x22;\n-    for (j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    for (j=0; j<22; j++) {\n+        secp256k1_fe_sqr(&x44, &x44);\n+    }\n     secp256k1_fe_mul(&x44, &x44, &x22);\n \n     x88 = x44;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x88, &x88);\n+    }\n     secp256k1_fe_mul(&x88, &x88, &x44);\n \n     x176 = x88;\n-    for (j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    for (j=0; j<88; j++) {\n+        secp256k1_fe_sqr(&x176, &x176);\n+    }\n     secp256k1_fe_mul(&x176, &x176, &x88);\n \n     x220 = x176;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x220, &x220);\n+    }\n     secp256k1_fe_mul(&x220, &x220, &x44);\n \n     x223 = x220;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x223, &x223);\n+    }\n     secp256k1_fe_mul(&x223, &x223, &x3);\n \n     /* The final result is then assembled using a sliding window over the blocks. */\n \n     t1 = x223;\n-    for (j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<23; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x22);\n-    for (j=0; j<5; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<5; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, a);\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x2);\n-    for (j=0; j<2; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<2; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(r, a, &t1);\n }\n \n@@ -188,8 +236,9 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_t u;\n     size_t i;\n-    if (len < 1)\n+    if (len < 1) {\n         return;\n+    }\n \n     VERIFY_CHECK((r + len <= a) || (a + len <= r));\n "
      },
      {
        "sha": "0b08b3b9910ccaf27d111e646584238857d947f5",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -115,4 +115,7 @@ static void secp256k1_ge_from_storage(secp256k1_ge_t *r, const secp256k1_ge_stor\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n static void secp256k1_ge_storage_cmov(secp256k1_ge_storage_t *r, const secp256k1_ge_storage_t *a, int flag);\n \n+/** Rescale a jacobian point by b which must be non-zero. Constant-time. */\n+static void secp256k1_gej_rescale(secp256k1_gej_t *r, const secp256k1_fe_t *b);\n+\n #endif"
      },
      {
        "sha": "0f64576fbb5231c70f17ef6d6765949f62fabb69",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 27,
        "deletions": 14,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -77,14 +77,14 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t *r, const se\n     secp256k1_fe_t *azi;\n     size_t i;\n     size_t count = 0;\n-    az = checked_malloc(sizeof(secp256k1_fe_t) * len);\n+    az = (secp256k1_fe_t *)checked_malloc(sizeof(secp256k1_fe_t) * len);\n     for (i = 0; i < len; i++) {\n         if (!a[i].infinity) {\n             az[count++] = a[i].z;\n         }\n     }\n \n-    azi = checked_malloc(sizeof(secp256k1_fe_t) * count);\n+    azi = (secp256k1_fe_t *)checked_malloc(sizeof(secp256k1_fe_t) * count);\n     secp256k1_fe_inv_all_var(count, azi, az);\n     free(az);\n \n@@ -138,11 +138,13 @@ static int secp256k1_ge_set_xo_var(secp256k1_ge_t *r, const secp256k1_fe_t *x, i\n     r->infinity = 0;\n     secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    if (!secp256k1_fe_sqrt_var(&r->y, &c))\n+    if (!secp256k1_fe_sqrt_var(&r->y, &c)) {\n         return 0;\n+    }\n     secp256k1_fe_normalize_var(&r->y);\n-    if (secp256k1_fe_is_odd(&r->y) != odd)\n+    if (secp256k1_fe_is_odd(&r->y) != odd) {\n         secp256k1_fe_negate(&r->y, &r->y, 1);\n+    }\n     return 1;\n }\n \n@@ -176,8 +178,9 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej_t *a) {\n \n static int secp256k1_gej_is_valid_var(const secp256k1_gej_t *a) {\n     secp256k1_fe_t y2, x3, z2, z6;\n-    if (a->infinity)\n+    if (a->infinity) {\n         return 0;\n+    }\n     /** y^2 = x^3 + 7\n      *  (Y/Z^3)^2 = (X/Z^2)^3 + 7\n      *  Y^2 / Z^6 = X^3 / Z^6 + 7\n@@ -195,8 +198,9 @@ static int secp256k1_gej_is_valid_var(const secp256k1_gej_t *a) {\n \n static int secp256k1_ge_is_valid_var(const secp256k1_ge_t *a) {\n     secp256k1_fe_t y2, x3, c;\n-    if (a->infinity)\n+    if (a->infinity) {\n         return 0;\n+    }\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n@@ -321,7 +325,8 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *\n }\n \n static void secp256k1_gej_add_ge(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_ge_t *b) {\n-    /* Operations: 7 mul, 5 sqr, 5 normalize, 19 mul_int/add/negate */\n+    /* Operations: 7 mul, 5 sqr, 5 normalize, 17 mul_int/add/negate/cmov */\n+    static const secp256k1_fe_t fe_1 = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n     secp256k1_fe_t zz, u1, u2, s1, s2, z, t, m, n, q, rr;\n     int infinity;\n     VERIFY_CHECK(!b->infinity);\n@@ -383,17 +388,25 @@ static void secp256k1_gej_add_ge(secp256k1_gej_t *r, const secp256k1_gej_t *a, c\n     secp256k1_fe_mul_int(&r->y, 4 * (1 - a->infinity)); /* r->y = Y3 = 4*R*(3*Q-2*R^2)-4*M^4 (4) */\n \n     /** In case a->infinity == 1, the above code results in r->x, r->y, and r->z all equal to 0.\n-     *  Add b->x to x, b->y to y, and 1 to z in that case.\n+     *  Replace r with b->x, b->y, 1 in that case.\n      */\n-    t = b->x; secp256k1_fe_mul_int(&t, a->infinity);\n-    secp256k1_fe_add(&r->x, &t);\n-    t = b->y; secp256k1_fe_mul_int(&t, a->infinity);\n-    secp256k1_fe_add(&r->y, &t);\n-    secp256k1_fe_set_int(&t, a->infinity);\n-    secp256k1_fe_add(&r->z, &t);\n+    secp256k1_fe_cmov(&r->x, &b->x, a->infinity);\n+    secp256k1_fe_cmov(&r->y, &b->y, a->infinity);\n+    secp256k1_fe_cmov(&r->z, &fe_1, a->infinity);\n     r->infinity = infinity;\n }\n \n+static void secp256k1_gej_rescale(secp256k1_gej_t *r, const secp256k1_fe_t *s) {\n+    /* Operations: 4 mul, 1 sqr */\n+    secp256k1_fe_t zz;\n+    VERIFY_CHECK(!secp256k1_fe_is_zero(s));\n+    secp256k1_fe_sqr(&zz, s);\n+    secp256k1_fe_mul(&r->x, &r->x, &zz);                /* r->x *= s^2 */\n+    secp256k1_fe_mul(&r->y, &r->y, &zz);\n+    secp256k1_fe_mul(&r->y, &r->y, s);                  /* r->y *= s^3 */\n+    secp256k1_fe_mul(&r->z, &r->z, s);                  /* r->z *= s   */\n+}\n+\n static void secp256k1_ge_to_storage(secp256k1_ge_storage_t *r, const secp256k1_ge_t *a) {\n     secp256k1_fe_t x, y;\n     VERIFY_CHECK(!a->infinity);"
      },
      {
        "sha": "9828827bcdb2d872478b57e33a671e20ea906d2c",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -176,13 +176,15 @@ static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256_t *hash, cons\n     }\n \n     secp256k1_sha256_initialize(&hash->outer);\n-    for (n = 0; n < 64; n++)\n+    for (n = 0; n < 64; n++) {\n         rkey[n] ^= 0x5c;\n+    }\n     secp256k1_sha256_write(&hash->outer, rkey, 64);\n \n     secp256k1_sha256_initialize(&hash->inner);\n-    for (n = 0; n < 64; n++)\n+    for (n = 0; n < 64; n++) {\n         rkey[n] ^= 0x5c ^ 0x36;\n+    }\n     secp256k1_sha256_write(&hash->inner, rkey, 64);\n     memset(rkey, 0, 64);\n }\n@@ -205,28 +207,32 @@ static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha2\n     static const unsigned char zero[1] = {0x00};\n     static const unsigned char one[1] = {0x01};\n \n-    memset(rng->v, 0x01, 32);\n-    memset(rng->k, 0x00, 32);\n+    memset(rng->v, 0x01, 32); /* RFC6979 3.2.b. */\n+    memset(rng->k, 0x00, 32); /* RFC6979 3.2.c. */\n \n+    /* RFC6979 3.2.d. */\n     secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n     secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n     secp256k1_hmac_sha256_write(&hmac, zero, 1);\n     secp256k1_hmac_sha256_write(&hmac, key, keylen);\n     secp256k1_hmac_sha256_write(&hmac, msg, msglen);\n     if (rnd && rndlen) {\n+        /* RFC6979 3.6 \"Additional data\". */\n         secp256k1_hmac_sha256_write(&hmac, rnd, rndlen);\n     }\n     secp256k1_hmac_sha256_finalize(&hmac, rng->k);\n     secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n     secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n     secp256k1_hmac_sha256_finalize(&hmac, rng->v);\n \n+    /* RFC6979 3.2.f. */\n     secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n     secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n     secp256k1_hmac_sha256_write(&hmac, one, 1);\n     secp256k1_hmac_sha256_write(&hmac, key, keylen);\n     secp256k1_hmac_sha256_write(&hmac, msg, msglen);\n     if (rnd && rndlen) {\n+        /* RFC6979 3.6 \"Additional data\". */\n         secp256k1_hmac_sha256_write(&hmac, rnd, rndlen);\n     }\n     secp256k1_hmac_sha256_finalize(&hmac, rng->k);\n@@ -237,6 +243,7 @@ static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha2\n }\n \n static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256_t *rng, unsigned char *out, size_t outlen) {\n+    /* RFC6979 3.2.h. */\n     static const unsigned char zero[1] = {0x00};\n     if (rng->retry) {\n         secp256k1_hmac_sha256_t hmac;"
      },
      {
        "sha": "dbbc458d5ddc7d1cea67a14e1678e9dc81881bf2",
        "filename": "src/num_gmp_impl.h",
        "status": "modified",
        "additions": 36,
        "deletions": 13,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -54,7 +54,9 @@ static void secp256k1_num_set_bin(secp256k1_num_t *r, const unsigned char *a, un\n     VERIFY_CHECK(len <= NUM_LIMBS*2);\n     r->limbs = len;\n     r->neg = 0;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+        r->limbs--;\n+    }\n }\n \n static void secp256k1_num_add_abs(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n@@ -70,7 +72,9 @@ static void secp256k1_num_sub_abs(secp256k1_num_t *r, const secp256k1_num_t *a,\n     mp_limb_t c = mpn_sub(r->data, a->data, a->limbs, b->data, b->limbs);\n     VERIFY_CHECK(c == 0);\n     r->limbs = a->limbs;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+        r->limbs--;\n+    }\n }\n \n static void secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m) {\n@@ -82,7 +86,9 @@ static void secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m) {\n         mpn_tdiv_qr(t, r->data, 0, r->data, r->limbs, m->data, m->limbs);\n         memset(t, 0, sizeof(t));\n         r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+            r->limbs--;\n+        }\n     }\n \n     if (r->neg && (r->limbs > 1 || r->data[0] != 0)) {\n@@ -125,7 +131,9 @@ static void secp256k1_num_mod_inverse(secp256k1_num_t *r, const secp256k1_num_t\n     if (sn < 0) {\n         mpn_sub(r->data, m->data, m->limbs, r->data, -sn);\n         r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+            r->limbs--;\n+        }\n     } else {\n         r->limbs = sn;\n     }\n@@ -143,15 +151,25 @@ static int secp256k1_num_is_neg(const secp256k1_num_t *a) {\n }\n \n static int secp256k1_num_cmp(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n-    if (a->limbs > b->limbs) return 1;\n-    if (a->limbs < b->limbs) return -1;\n+    if (a->limbs > b->limbs) {\n+        return 1;\n+    }\n+    if (a->limbs < b->limbs) {\n+        return -1;\n+    }\n     return mpn_cmp(a->data, b->data, a->limbs);\n }\n \n static int secp256k1_num_eq(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n-    if (a->limbs > b->limbs) return 0;\n-    if (a->limbs < b->limbs) return 0;\n-    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) return 0;\n+    if (a->limbs > b->limbs) {\n+        return 0;\n+    }\n+    if (a->limbs < b->limbs) {\n+        return 0;\n+    }\n+    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) {\n+        return 0;\n+    }\n     return mpn_cmp(a->data, b->data, a->limbs) == 0;\n }\n \n@@ -198,12 +216,15 @@ static void secp256k1_num_mul(secp256k1_num_t *r, const secp256k1_num_t *a, cons\n         r->data[0] = 0;\n         return;\n     }\n-    if (a->limbs >= b->limbs)\n+    if (a->limbs >= b->limbs) {\n         mpn_mul(tmp, a->data, a->limbs, b->data, b->limbs);\n-    else\n+    } else {\n         mpn_mul(tmp, b->data, b->limbs, a->data, a->limbs);\n+    }\n     r->limbs = a->limbs + b->limbs;\n-    if (r->limbs > 1 && tmp[r->limbs - 1]==0) r->limbs--;\n+    if (r->limbs > 1 && tmp[r->limbs - 1]==0) {\n+        r->limbs--;\n+    }\n     VERIFY_CHECK(r->limbs <= 2*NUM_LIMBS);\n     mpn_copyi(r->data, tmp, r->limbs);\n     r->neg = a->neg ^ b->neg;\n@@ -227,7 +248,9 @@ static void secp256k1_num_shift(secp256k1_num_t *r, int bits) {\n             }\n         }\n     }\n-    while (r->limbs>1 && r->data[r->limbs-1]==0) r->limbs--;\n+    while (r->limbs>1 && r->data[r->limbs-1]==0) {\n+        r->limbs--;\n+    }\n }\n \n static void secp256k1_num_negate(secp256k1_num_t *r) {"
      },
      {
        "sha": "33824983e4d529c345f4d9c0f2ae222d24777b3f",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 76,
        "deletions": 38,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -69,130 +69,168 @@ static void secp256k1_scalar_inverse(secp256k1_scalar_t *r, const secp256k1_scal\n     secp256k1_scalar_mul(&x8, &x8,  x);\n \n     secp256k1_scalar_sqr(&x15, &x8);\n-    for (i = 0; i < 6; i++)\n+    for (i = 0; i < 6; i++) {\n         secp256k1_scalar_sqr(&x15, &x15);\n+    }\n     secp256k1_scalar_mul(&x15, &x15, &x7);\n \n     secp256k1_scalar_sqr(&x30, &x15);\n-    for (i = 0; i < 14; i++)\n+    for (i = 0; i < 14; i++) {\n         secp256k1_scalar_sqr(&x30, &x30);\n+    }\n     secp256k1_scalar_mul(&x30, &x30, &x15);\n \n     secp256k1_scalar_sqr(&x60, &x30);\n-    for (i = 0; i < 29; i++)\n+    for (i = 0; i < 29; i++) {\n         secp256k1_scalar_sqr(&x60, &x60);\n+    }\n     secp256k1_scalar_mul(&x60, &x60, &x30);\n \n     secp256k1_scalar_sqr(&x120, &x60);\n-    for (i = 0; i < 59; i++)\n+    for (i = 0; i < 59; i++) {\n         secp256k1_scalar_sqr(&x120, &x120);\n+    }\n     secp256k1_scalar_mul(&x120, &x120, &x60);\n \n     secp256k1_scalar_sqr(&x127, &x120);\n-    for (i = 0; i < 6; i++)\n+    for (i = 0; i < 6; i++) {\n         secp256k1_scalar_sqr(&x127, &x127);\n+    }\n     secp256k1_scalar_mul(&x127, &x127, &x7);\n \n     /* Then accumulate the final result (t starts at x127). */\n     t = &x127;\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 3; i++) /* 0 */\n+    for (i = 0; i < 3; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 5; i++) /* 00 */\n+    for (i = 0; i < 5; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) /* 00 */\n+    for (i = 0; i < 4; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) /* 0 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) /* 000 */\n+    for (i = 0; i < 4; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 10; i++) /* 0000000 */\n+    for (i = 0; i < 10; i++) { /* 0000000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 9; i++) /* 0 */\n+    for (i = 0; i < 9; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) /* 0 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) /* 000 */\n+    for (i = 0; i < 5; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) /* 00 */\n+    for (i = 0; i < 4; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) /* 000000 */\n+    for (i = 0; i < 8; i++) { /* 000000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) /* 0 */\n+    for (i = 0; i < 3; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 6; i++) /* 00000 */\n+    for (i = 0; i < 6; i++) { /* 00000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) /* 00 */\n+    for (i = 0; i < 8; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(r, t, &x6); /* 111111 */\n }\n "
      },
      {
        "sha": "d6192dc4ed6bb876bc1c82474528d055592dab14",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 86,
        "deletions": 39,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013-2015 Pieter Wuille                              *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -19,26 +19,48 @@\n #include \"eckey_impl.h\"\n #include \"hash_impl.h\"\n \n-void secp256k1_start(unsigned int flags) {\n-    if (flags & SECP256K1_START_SIGN) {\n-        secp256k1_ecmult_gen_start();\n+struct secp256k1_context_struct {\n+    secp256k1_ecmult_context_t ecmult_ctx;\n+    secp256k1_ecmult_gen_context_t ecmult_gen_ctx;\n+};\n+\n+secp256k1_context_t* secp256k1_context_create(int flags) {\n+    secp256k1_context_t* ret = (secp256k1_context_t*)checked_malloc(sizeof(secp256k1_context_t));\n+\n+    secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n+    secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n+\n+    if (flags & SECP256K1_CONTEXT_SIGN) {\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx);\n     }\n-    if (flags & SECP256K1_START_VERIFY) {\n-        secp256k1_ecmult_start();\n+    if (flags & SECP256K1_CONTEXT_VERIFY) {\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx);\n     }\n+\n+    return ret;\n }\n \n-void secp256k1_stop(void) {\n-    secp256k1_ecmult_stop();\n-    secp256k1_ecmult_gen_stop();\n+secp256k1_context_t* secp256k1_context_clone(const secp256k1_context_t* ctx) {\n+    secp256k1_context_t* ret = (secp256k1_context_t*)checked_malloc(sizeof(secp256k1_context_t));\n+    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n+    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    return ret;\n }\n \n-int secp256k1_ecdsa_verify(const unsigned char *msg32, const unsigned char *sig, int siglen, const unsigned char *pubkey, int pubkeylen) {\n+void secp256k1_context_destroy(secp256k1_context_t* ctx) {\n+    secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n+    secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+\n+    free(ctx);\n+}\n+\n+int secp256k1_ecdsa_verify(const secp256k1_context_t* ctx, const unsigned char *msg32, const unsigned char *sig, int siglen, const unsigned char *pubkey, int pubkeylen) {\n     secp256k1_ge_t q;\n     secp256k1_ecdsa_sig_t s;\n     secp256k1_scalar_t m;\n     int ret = -3;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(sig != NULL);\n     DEBUG_CHECK(pubkey != NULL);\n@@ -47,7 +69,7 @@ int secp256k1_ecdsa_verify(const unsigned char *msg32, const unsigned char *sig,\n \n     if (secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen)) {\n         if (secp256k1_ecdsa_sig_parse(&s, sig, siglen)) {\n-            if (secp256k1_ecdsa_sig_verify(&s, &q, &m)) {\n+            if (secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &s, &q, &m)) {\n                 /* success is 1, all other values are fail */\n                 ret = 1;\n             } else {\n@@ -66,7 +88,7 @@ int secp256k1_ecdsa_verify(const unsigned char *msg32, const unsigned char *sig,\n static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, unsigned int counter, const void *data) {\n    secp256k1_rfc6979_hmac_sha256_t rng;\n    unsigned int i;\n-   secp256k1_rfc6979_hmac_sha256_initialize(&rng, key32, 32, msg32, 32, data, data != NULL ? 32 : 0);\n+   secp256k1_rfc6979_hmac_sha256_initialize(&rng, key32, 32, msg32, 32, (const unsigned char*)data, data != NULL ? 32 : 0);\n    for (i = 0; i <= counter; i++) {\n        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n    }\n@@ -77,13 +99,14 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n const secp256k1_nonce_function_t secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979;\n const secp256k1_nonce_function_t secp256k1_nonce_function_default = nonce_function_rfc6979;\n \n-int secp256k1_ecdsa_sign(const unsigned char *msg32, unsigned char *signature, int *signaturelen, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata) {\n+int secp256k1_ecdsa_sign(const secp256k1_context_t* ctx, const unsigned char *msg32, unsigned char *signature, int *signaturelen, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata) {\n     secp256k1_ecdsa_sig_t sig;\n     secp256k1_scalar_t sec, non, msg;\n     int ret = 0;\n     int overflow = 0;\n     unsigned int count = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(signature != NULL);\n     DEBUG_CHECK(signaturelen != NULL);\n@@ -105,7 +128,7 @@ int secp256k1_ecdsa_sign(const unsigned char *msg32, unsigned char *signature, i\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n             memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-                if (secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, NULL)) {\n+                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &sig, &sec, &msg, &non, NULL)) {\n                     break;\n                 }\n             }\n@@ -124,13 +147,14 @@ int secp256k1_ecdsa_sign(const unsigned char *msg32, unsigned char *signature, i\n     return ret;\n }\n \n-int secp256k1_ecdsa_sign_compact(const unsigned char *msg32, unsigned char *sig64, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata, int *recid) {\n+int secp256k1_ecdsa_sign_compact(const secp256k1_context_t* ctx, const unsigned char *msg32, unsigned char *sig64, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata, int *recid) {\n     secp256k1_ecdsa_sig_t sig;\n     secp256k1_scalar_t sec, non, msg;\n     int ret = 0;\n     int overflow = 0;\n     unsigned int count = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(sig64 != NULL);\n     DEBUG_CHECK(seckey != NULL);\n@@ -151,7 +175,7 @@ int secp256k1_ecdsa_sign_compact(const unsigned char *msg32, unsigned char *sig6\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n             memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-                if (secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, recid)) {\n+                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &sig, &sec, &msg, &non, recid)) {\n                     break;\n                 }\n             }\n@@ -171,13 +195,14 @@ int secp256k1_ecdsa_sign_compact(const unsigned char *msg32, unsigned char *sig6\n     return ret;\n }\n \n-int secp256k1_ecdsa_recover_compact(const unsigned char *msg32, const unsigned char *sig64, unsigned char *pubkey, int *pubkeylen, int compressed, int recid) {\n+int secp256k1_ecdsa_recover_compact(const secp256k1_context_t* ctx, const unsigned char *msg32, const unsigned char *sig64, unsigned char *pubkey, int *pubkeylen, int compressed, int recid) {\n     secp256k1_ge_t q;\n     secp256k1_ecdsa_sig_t sig;\n     secp256k1_scalar_t m;\n     int ret = 0;\n     int overflow = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(sig64 != NULL);\n     DEBUG_CHECK(pubkey != NULL);\n@@ -190,47 +215,52 @@ int secp256k1_ecdsa_recover_compact(const unsigned char *msg32, const unsigned c\n         if (!overflow) {\n             secp256k1_scalar_set_b32(&m, msg32, NULL);\n \n-            if (secp256k1_ecdsa_sig_recover(&sig, &q, &m, recid)) {\n+            if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &sig, &q, &m, recid)) {\n                 ret = secp256k1_eckey_pubkey_serialize(&q, pubkey, pubkeylen, compressed);\n             }\n         }\n     }\n     return ret;\n }\n \n-int secp256k1_ec_seckey_verify(const unsigned char *seckey) {\n+int secp256k1_ec_seckey_verify(const secp256k1_context_t* ctx, const unsigned char *seckey) {\n     secp256k1_scalar_t sec;\n     int ret;\n     int overflow;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(seckey != NULL);\n+    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !secp256k1_scalar_is_zero(&sec) && !overflow;\n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen) {\n+int secp256k1_ec_pubkey_verify(const secp256k1_context_t* ctx, const unsigned char *pubkey, int pubkeylen) {\n     secp256k1_ge_t q;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(pubkey != NULL);\n+    (void)ctx;\n \n     return secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen);\n }\n \n-int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed) {\n+int secp256k1_ec_pubkey_create(const secp256k1_context_t* ctx, unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed) {\n     secp256k1_gej_t pj;\n     secp256k1_ge_t p;\n     secp256k1_scalar_t sec;\n     int overflow;\n     int ret = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(pubkeylen != NULL);\n     DEBUG_CHECK(seckey != NULL);\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     if (!overflow) {\n-        secp256k1_ecmult_gen(&pj, &sec);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n         secp256k1_scalar_clear(&sec);\n         secp256k1_ge_set_gej(&p, &pj);\n         ret = secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, compressed);\n@@ -241,25 +271,28 @@ int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsi\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_decompress(unsigned char *pubkey, int *pubkeylen) {\n+int secp256k1_ec_pubkey_decompress(const secp256k1_context_t* ctx, unsigned char *pubkey, int *pubkeylen) {\n     secp256k1_ge_t p;\n     int ret = 0;\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(pubkeylen != NULL);\n+    (void)ctx;\n \n     if (secp256k1_eckey_pubkey_parse(&p, pubkey, *pubkeylen)) {\n         ret = secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, 0);\n     }\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_privkey_tweak_add(const secp256k1_context_t* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar_t term;\n     secp256k1_scalar_t sec;\n     int ret = 0;\n     int overflow = 0;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n+    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -274,20 +307,21 @@ int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *t\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_add(const secp256k1_context_t* ctx, unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n     secp256k1_ge_t p;\n     secp256k1_scalar_t term;\n     int ret = 0;\n     int overflow = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     if (!overflow) {\n         ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n         if (ret) {\n-            ret = secp256k1_eckey_pubkey_tweak_add(&p, &term);\n+            ret = secp256k1_eckey_pubkey_tweak_add(&ctx->ecmult_ctx, &p, &term);\n         }\n         if (ret) {\n             int oldlen = pubkeylen;\n@@ -299,13 +333,15 @@ int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const un\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_privkey_tweak_mul(const secp256k1_context_t* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar_t factor;\n     secp256k1_scalar_t sec;\n     int ret = 0;\n     int overflow = 0;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n+    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -319,20 +355,21 @@ int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *t\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context_t* ctx, unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n     secp256k1_ge_t p;\n     secp256k1_scalar_t factor;\n     int ret = 0;\n     int overflow = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     if (!overflow) {\n         ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n         if (ret) {\n-            ret = secp256k1_eckey_pubkey_tweak_mul(&p, &factor);\n+            ret = secp256k1_eckey_pubkey_tweak_mul(&ctx->ecmult_ctx, &p, &factor);\n         }\n         if (ret) {\n             int oldlen = pubkeylen;\n@@ -344,24 +381,27 @@ int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const un\n     return ret;\n }\n \n-int secp256k1_ec_privkey_export(const unsigned char *seckey, unsigned char *privkey, int *privkeylen, int compressed) {\n+int secp256k1_ec_privkey_export(const secp256k1_context_t* ctx, const unsigned char *seckey, unsigned char *privkey, int *privkeylen, int compressed) {\n     secp256k1_scalar_t key;\n     int ret = 0;\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(privkey != NULL);\n     DEBUG_CHECK(privkeylen != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n \n     secp256k1_scalar_set_b32(&key, seckey, NULL);\n-    ret = secp256k1_eckey_privkey_serialize(privkey, privkeylen, &key, compressed);\n+    ret = secp256k1_eckey_privkey_serialize(&ctx->ecmult_gen_ctx, privkey, privkeylen, &key, compressed);\n     secp256k1_scalar_clear(&key);\n     return ret;\n }\n \n-int secp256k1_ec_privkey_import(unsigned char *seckey, const unsigned char *privkey, int privkeylen) {\n+int secp256k1_ec_privkey_import(const secp256k1_context_t* ctx, unsigned char *seckey, const unsigned char *privkey, int privkeylen) {\n     secp256k1_scalar_t key;\n     int ret = 0;\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(privkey != NULL);\n+    (void)ctx;\n \n     ret = secp256k1_eckey_privkey_parse(&key, privkey, privkeylen);\n     if (ret) {\n@@ -370,3 +410,10 @@ int secp256k1_ec_privkey_import(unsigned char *seckey, const unsigned char *priv\n     secp256k1_scalar_clear(&key);\n     return ret;\n }\n+\n+int secp256k1_context_randomize(secp256k1_context_t* ctx, const unsigned char *seed32) {\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    return 1;\n+}"
      },
      {
        "sha": "d0e05057f296860e376ab75310c926303f3903c6",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 328,
        "deletions": 125,
        "changes": 453,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a591d98c322093040d59e152591f0978962f9da7/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a591d98c322093040d59e152591f0978962f9da7/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=a591d98c322093040d59e152591f0978962f9da7",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell      *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -24,6 +24,7 @@\n #endif\n \n static int count = 64;\n+static secp256k1_context_t *ctx = NULL;\n \n void random_field_element_test(secp256k1_fe_t *fe) {\n     do {\n@@ -55,8 +56,9 @@ void random_group_element_test(secp256k1_ge_t *ge) {\n     secp256k1_fe_t fe;\n     do {\n         random_field_element_test(&fe);\n-        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand32() & 1))\n+        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand32() & 1)) {\n             break;\n+        }\n     } while(1);\n }\n \n@@ -81,8 +83,9 @@ void random_scalar_order_test(secp256k1_scalar_t *num) {\n         int overflow = 0;\n         secp256k1_rand256_test(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(num))\n+        if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n+        }\n         break;\n     } while(1);\n }\n@@ -93,12 +96,60 @@ void random_scalar_order(secp256k1_scalar_t *num) {\n         int overflow = 0;\n         secp256k1_rand256(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(num))\n+        if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n+        }\n         break;\n     } while(1);\n }\n \n+void run_context_tests(void) {\n+    secp256k1_context_t *none = secp256k1_context_create(0);\n+    secp256k1_context_t *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context_t *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context_t *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+    secp256k1_gej_t pubj;\n+    secp256k1_ge_t pub;\n+    secp256k1_scalar_t msg, key, nonce;\n+    secp256k1_ecdsa_sig_t sig;\n+\n+    /*** clone and destroy all of them to make sure cloning was complete ***/\n+    {\n+        secp256k1_context_t *ctx_tmp;\n+\n+        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n+        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n+        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n+        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+    }\n+\n+    /*** attempt to use them ***/\n+    random_scalar_order_test(&msg);\n+    random_scalar_order_test(&key);\n+    secp256k1_ecmult_gen(&both->ecmult_gen_ctx, &pubj, &key);\n+    secp256k1_ge_set_gej(&pub, &pubj);\n+\n+    /* obtain a working nonce */\n+    do {\n+        random_scalar_order_test(&nonce);\n+    } while(!secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sig, &key, &msg, &nonce, NULL));\n+\n+    /* try signing */\n+    CHECK(secp256k1_ecdsa_sig_sign(&sign->ecmult_gen_ctx, &sig, &key, &msg, &nonce, NULL));\n+    CHECK(secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sig, &key, &msg, &nonce, NULL));\n+\n+    /* try verifying */\n+    CHECK(secp256k1_ecdsa_sig_verify(&vrfy->ecmult_ctx, &sig, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sig, &pub, &msg));\n+\n+    /* cleanup */\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n /***** HASH TESTS *****/\n \n void run_sha256_tests(void) {\n@@ -229,8 +280,9 @@ void run_rfc6979_hmac_sha256_tests(void) {\n \n #ifndef USE_NUM_NONE\n void random_num_negate(secp256k1_num_t *num) {\n-    if (secp256k1_rand32() & 1)\n+    if (secp256k1_rand32() & 1) {\n         secp256k1_num_negate(num);\n+    }\n }\n \n void random_num_order_test(secp256k1_num_t *num) {\n@@ -624,8 +676,9 @@ void random_fe_non_zero(secp256k1_fe_t *nz) {\n     while (--tries >= 0) {\n         random_fe(nz);\n         secp256k1_fe_normalize(nz);\n-        if (!secp256k1_fe_is_zero(nz))\n+        if (!secp256k1_fe_is_zero(nz)) {\n             break;\n+        }\n     }\n     /* Infinitesimal probability of spurious failure here */\n     CHECK(tries >= 0);\n@@ -700,12 +753,22 @@ void run_field_misc(void) {\n         CHECK(secp256k1_fe_equal_var(&x, &x));\n         z = x;\n         secp256k1_fe_add(&z,&y);\n-        secp256k1_fe_normalize(&z);\n+        /* Test fe conditional move; z is not normalized here. */\n+        q = x;\n+        secp256k1_fe_cmov(&x, &z, 0);\n+        secp256k1_fe_cmov(&x, &x, 1);\n+        CHECK(memcmp(&x, &z, sizeof(x)) != 0);\n+        CHECK(memcmp(&x, &q, sizeof(x)) == 0);\n+        secp256k1_fe_cmov(&q, &z, 1);\n+        CHECK(memcmp(&q, &z, sizeof(q)) == 0);\n         /* Test storage conversion and conditional moves. */\n+        secp256k1_fe_normalize(&z);\n+        CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_to_storage(&xs, &x);\n         secp256k1_fe_to_storage(&ys, &y);\n         secp256k1_fe_to_storage(&zs, &z);\n         secp256k1_fe_storage_cmov(&zs, &xs, 0);\n+        secp256k1_fe_storage_cmov(&zs, &zs, 1);\n         CHECK(memcmp(&xs, &zs, sizeof(xs)) != 0);\n         secp256k1_fe_storage_cmov(&ys, &xs, 1);\n         CHECK(memcmp(&xs, &ys, sizeof(xs)) == 0);\n@@ -765,14 +828,17 @@ void run_field_inv_all_var(void) {\n     for (i = 0; i < count; i++) {\n         size_t j;\n         size_t len = (secp256k1_rand32() & 15) + 1;\n-        for (j = 0; j < len; j++)\n+        for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n+        }\n         secp256k1_fe_inv_all_var(len, xi, x);\n-        for (j = 0; j < len; j++)\n+        for (j = 0; j < len; j++) {\n             CHECK(check_fe_inverse(&x[j], &xi[j]));\n+        }\n         secp256k1_fe_inv_all_var(len, xii, xi);\n-        for (j = 0; j < len; j++)\n+        for (j = 0; j < len; j++) {\n             CHECK(check_fe_equal(&x[j], &xii[j]));\n+        }\n     }\n }\n \n@@ -844,18 +910,42 @@ void run_sqrt(void) {\n \n void ge_equals_ge(const secp256k1_ge_t *a, const secp256k1_ge_t *b) {\n     CHECK(a->infinity == b->infinity);\n-    if (a->infinity)\n+    if (a->infinity) {\n         return;\n+    }\n     CHECK(secp256k1_fe_equal_var(&a->x, &b->x));\n     CHECK(secp256k1_fe_equal_var(&b->y, &b->y));\n }\n \n+/* This compares jacobian points including their Z, not just their geometric meaning. */\n+int gej_xyz_equals_gej(const secp256k1_gej_t *a, const secp256k1_gej_t *b) {\n+    secp256k1_gej_t a2;\n+    secp256k1_gej_t b2;\n+    int ret = 1;\n+    ret &= a->infinity == b->infinity;\n+    if (ret && !a->infinity) {\n+        a2 = *a;\n+        b2 = *b;\n+        secp256k1_fe_normalize(&a2.x);\n+        secp256k1_fe_normalize(&a2.y);\n+        secp256k1_fe_normalize(&a2.z);\n+        secp256k1_fe_normalize(&b2.x);\n+        secp256k1_fe_normalize(&b2.y);\n+        secp256k1_fe_normalize(&b2.z);\n+        ret &= secp256k1_fe_cmp_var(&a2.x, &b2.x) == 0;\n+        ret &= secp256k1_fe_cmp_var(&a2.y, &b2.y) == 0;\n+        ret &= secp256k1_fe_cmp_var(&a2.z, &b2.z) == 0;\n+    }\n+    return ret;\n+}\n+\n void ge_equals_gej(const secp256k1_ge_t *a, const secp256k1_gej_t *b) {\n     secp256k1_fe_t z2s;\n     secp256k1_fe_t u1, u2, s1, s2;\n     CHECK(a->infinity == b->infinity);\n-    if (a->infinity)\n+    if (a->infinity) {\n         return;\n+    }\n     /* Check a.x * b.z^2 == b.x && a.y * b.z^3 == b.y, to avoid inverses. */\n     secp256k1_fe_sqr(&z2s, &b->z);\n     secp256k1_fe_mul(&u1, &a->x, &z2s);\n@@ -874,8 +964,8 @@ void test_ge(void) {\n      * All magnitudes are randomized.\n      * All 17*17 combinations of points are added to eachother, using all applicable methods.\n      */\n-    secp256k1_ge_t *ge = malloc(sizeof(secp256k1_ge_t) * (1 + 4 * runs));\n-    secp256k1_gej_t *gej = malloc(sizeof(secp256k1_gej_t) * (1 + 4 * runs));\n+    secp256k1_ge_t *ge = (secp256k1_ge_t *)malloc(sizeof(secp256k1_ge_t) * (1 + 4 * runs));\n+    secp256k1_gej_t *gej = (secp256k1_gej_t *)malloc(sizeof(secp256k1_gej_t) * (1 + 4 * runs));\n     secp256k1_gej_set_infinity(&gej[0]);\n     secp256k1_ge_clear(&ge[0]);\n     secp256k1_ge_set_gej_var(&ge[0], &gej[0]);\n@@ -951,7 +1041,7 @@ void test_ge(void) {\n     /* Test adding all points together in random order equals infinity. */\n     {\n         secp256k1_gej_t sum = SECP256K1_GEJ_CONST_INFINITY;\n-        secp256k1_gej_t *gej_shuffled = malloc((4 * runs + 1) * sizeof(secp256k1_gej_t));\n+        secp256k1_gej_t *gej_shuffled = (secp256k1_gej_t *)malloc((4 * runs + 1) * sizeof(secp256k1_gej_t));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             gej_shuffled[i] = gej[i];\n         }\n@@ -972,9 +1062,12 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion. */\n     {\n-        secp256k1_ge_t *ge_set_all = malloc((4 * runs + 1) * sizeof(secp256k1_ge_t));\n+        secp256k1_ge_t *ge_set_all = (secp256k1_ge_t *)malloc((4 * runs + 1) * sizeof(secp256k1_ge_t));\n         secp256k1_ge_set_all_gej_var(4 * runs + 1, ge_set_all, gej);\n         for (i = 0; i < 4 * runs + 1; i++) {\n+            secp256k1_fe_t s;\n+            random_fe_non_zero(&s);\n+            secp256k1_gej_rescale(&gej[i], &s);\n             ge_equals_gej(&ge_set_all[i], &gej[i]);\n         }\n         free(ge_set_all);\n@@ -1025,7 +1118,7 @@ void run_ecmult_chain(void) {\n     x = a;\n     for (i = 0; i < 200*count; i++) {\n         /* in each iteration, compute X = xn*X + gn*G; */\n-        secp256k1_ecmult(&x, &x, &xn, &gn);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &x, &x, &xn, &gn);\n         /* also compute ae and ge: the actual accumulated factors for A and G */\n         /* if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G) */\n         secp256k1_scalar_mul(&ae, &ae, &xn);\n@@ -1051,7 +1144,7 @@ void run_ecmult_chain(void) {\n         }\n     }\n     /* redo the computation, but directly with the resulting ae and ge coefficients: */\n-    secp256k1_ecmult(&x2, &a, &ae, &ge);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &x2, &a, &ae, &ge);\n     secp256k1_gej_neg(&x2, &x2);\n     secp256k1_gej_add_var(&x2, &x2, &x);\n     CHECK(secp256k1_gej_is_infinity(&x2));\n@@ -1067,8 +1160,8 @@ void test_point_times_order(const secp256k1_gej_t *point) {\n     int psize = 65;\n     random_scalar_order_test(&x);\n     secp256k1_scalar_negate(&nx, &x);\n-    secp256k1_ecmult(&res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n-    secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n     CHECK(secp256k1_gej_is_valid_var(&res1) == 0);\n@@ -1141,17 +1234,96 @@ void run_wnaf(void) {\n     secp256k1_scalar_t n;\n     for (i = 0; i < count; i++) {\n         random_scalar_order(&n);\n-        if (i % 1)\n-            secp256k1_scalar_negate(&n, &n);\n         test_wnaf(&n, 4+(i%10));\n     }\n }\n \n+void test_ecmult_constants(void) {\n+    /* Test ecmult_gen() for [0..36) and [order-36..0). */\n+    secp256k1_scalar_t x;\n+    secp256k1_gej_t r;\n+    secp256k1_ge_t ng;\n+    int i;\n+    int j;\n+    secp256k1_ge_neg(&ng, &secp256k1_ge_const_g);\n+    for (i = 0; i < 36; i++ ) {\n+        secp256k1_scalar_set_int(&x, i);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &r, &x);\n+        for (j = 0; j < i; j++) {\n+            if (j == i - 1) {\n+                ge_equals_gej(&secp256k1_ge_const_g, &r);\n+            }\n+            secp256k1_gej_add_ge(&r, &r, &ng);\n+        }\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+    for (i = 1; i <= 36; i++ ) {\n+        secp256k1_scalar_set_int(&x, i);\n+        secp256k1_scalar_negate(&x, &x);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &r, &x);\n+        for (j = 0; j < i; j++) {\n+            if (j == i - 1) {\n+                ge_equals_gej(&ng, &r);\n+            }\n+            secp256k1_gej_add_ge(&r, &r, &secp256k1_ge_const_g);\n+        }\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+}\n+\n+void run_ecmult_constants(void) {\n+    test_ecmult_constants();\n+}\n+\n+void test_ecmult_gen_blind(void) {\n+    /* Test ecmult_gen() blinding and confirm that the blinding changes, the affline points match, and the z's don't match. */\n+    secp256k1_scalar_t key;\n+    secp256k1_scalar_t b;\n+    unsigned char seed32[32];\n+    secp256k1_gej_t pgej;\n+    secp256k1_gej_t pgej2;\n+    secp256k1_gej_t i;\n+    secp256k1_ge_t pge;\n+    random_scalar_order_test(&key);\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pgej, &key);\n+    secp256k1_rand256(seed32);\n+    b = ctx->ecmult_gen_ctx.blind;\n+    i = ctx->ecmult_gen_ctx.initial;\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    CHECK(!secp256k1_scalar_eq(&b, &ctx->ecmult_gen_ctx.blind));\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pgej2, &key);\n+    CHECK(!gej_xyz_equals_gej(&pgej, &pgej2));\n+    CHECK(!gej_xyz_equals_gej(&i, &ctx->ecmult_gen_ctx.initial));\n+    secp256k1_ge_set_gej(&pge, &pgej);\n+    ge_equals_gej(&pge, &pgej2);\n+}\n+\n+void test_ecmult_gen_blind_reset(void) {\n+    /* Test ecmult_gen() blinding reset and confirm that the blinding is consistent. */\n+    secp256k1_scalar_t b;\n+    secp256k1_gej_t initial;\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, 0);\n+    b = ctx->ecmult_gen_ctx.blind;\n+    initial = ctx->ecmult_gen_ctx.initial;\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, 0);\n+    CHECK(secp256k1_scalar_eq(&b, &ctx->ecmult_gen_ctx.blind));\n+    CHECK(gej_xyz_equals_gej(&initial, &ctx->ecmult_gen_ctx.initial));\n+}\n+\n+void run_ecmult_gen_blind(void) {\n+    int i;\n+    test_ecmult_gen_blind_reset();\n+    for (i = 0; i < 10; i++) {\n+        test_ecmult_gen_blind();\n+    }\n+}\n+\n+\n void random_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *key, const secp256k1_scalar_t *msg, int *recid) {\n     secp256k1_scalar_t nonce;\n     do {\n         random_scalar_order_test(&nonce);\n-    } while(!secp256k1_ecdsa_sig_sign(sig, key, msg, &nonce, recid));\n+    } while(!secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, sig, key, msg, &nonce, recid));\n }\n \n void test_ecdsa_sign_verify(void) {\n@@ -1164,15 +1336,17 @@ void test_ecdsa_sign_verify(void) {\n     int getrec;\n     random_scalar_order_test(&msg);\n     random_scalar_order_test(&key);\n-    secp256k1_ecmult_gen(&pubj, &key);\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n     getrec = secp256k1_rand32()&1;\n     random_sign(&sig, &key, &msg, getrec?&recid:NULL);\n-    if (getrec) CHECK(recid >= 0 && recid < 4);\n-    CHECK(secp256k1_ecdsa_sig_verify(&sig, &pub, &msg));\n+    if (getrec) {\n+        CHECK(recid >= 0 && recid < 4);\n+    }\n+    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &pub, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &pub, &msg));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &pub, &msg));\n }\n \n void run_ecdsa_sign_verify(void) {\n@@ -1192,15 +1366,19 @@ static int precomputed_nonce_function(unsigned char *nonce32, const unsigned cha\n \n static int nonce_function_test_fail(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, unsigned int counter, const void *data) {\n    /* Dummy nonce generator that has a fatal error on the first counter value. */\n-   if (counter == 0) return 0;\n+   if (counter == 0) {\n+       return 0;\n+   }\n    return nonce_function_rfc6979(nonce32, msg32, key32, counter - 1, data);\n }\n \n static int nonce_function_test_retry(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, unsigned int counter, const void *data) {\n    /* Dummy nonce generator that produces unacceptable nonces for the first several counter values. */\n    if (counter < 3) {\n        memset(nonce32, counter==0 ? 0 : 255, 32);\n-       if (counter == 2) nonce32[31]--;\n+       if (counter == 2) {\n+           nonce32[31]--;\n+       }\n        return 1;\n    }\n    if (counter < 5) {\n@@ -1211,12 +1389,16 @@ static int nonce_function_test_retry(unsigned char *nonce32, const unsigned char\n            0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n        };\n        memcpy(nonce32, order, 32);\n-       if (counter == 4) nonce32[31]++;\n+       if (counter == 4) {\n+           nonce32[31]++;\n+       }\n        return 1;\n    }\n    /* Retry rate of 6979 is negligible esp. as we only call this in determinstic tests. */\n    /* If someone does fine a case where it retries for secp256k1, we'd like to know. */\n-   if (counter > 5) return 0;\n+   if (counter > 5) {\n+       return 0;\n+   }\n    return nonce_function_rfc6979(nonce32, msg32, key32, counter - 5, data);\n }\n \n@@ -1257,16 +1439,16 @@ void test_ecdsa_end_to_end(void) {\n     }\n \n     /* Construct and verify corresponding public key. */\n-    CHECK(secp256k1_ec_seckey_verify(privkey) == 1);\n-    CHECK(secp256k1_ec_pubkey_create(pubkey, &pubkeylen, privkey, (secp256k1_rand32() & 3) != 0) == 1);\n+    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, pubkey, &pubkeylen, privkey, (secp256k1_rand32() & 3) != 0) == 1);\n     if (secp256k1_rand32() & 1) {\n-        CHECK(secp256k1_ec_pubkey_decompress(pubkey, &pubkeylen));\n+        CHECK(secp256k1_ec_pubkey_decompress(ctx, pubkey, &pubkeylen));\n     }\n-    CHECK(secp256k1_ec_pubkey_verify(pubkey, pubkeylen));\n+    CHECK(secp256k1_ec_pubkey_verify(ctx, pubkey, pubkeylen));\n \n     /* Verify private key import and export. */\n-    CHECK(secp256k1_ec_privkey_export(privkey, seckey, &seckeylen, secp256k1_rand32() % 2) == 1);\n-    CHECK(secp256k1_ec_privkey_import(privkey2, seckey, seckeylen) == 1);\n+    CHECK(secp256k1_ec_privkey_export(ctx, privkey, seckey, &seckeylen, secp256k1_rand32() % 2) == 1);\n+    CHECK(secp256k1_ec_privkey_import(ctx, privkey2, seckey, seckeylen) == 1);\n     CHECK(memcmp(privkey, privkey2, 32) == 0);\n \n     /* Optionally tweak the keys using addition. */\n@@ -1277,11 +1459,13 @@ void test_ecdsa_end_to_end(void) {\n         unsigned char pubkey2[65];\n         int pubkeylen2 = 65;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_add(privkey, rnd);\n-        ret2 = secp256k1_ec_pubkey_tweak_add(pubkey, pubkeylen, rnd);\n+        ret1 = secp256k1_ec_privkey_tweak_add(ctx, privkey, rnd);\n+        ret2 = secp256k1_ec_pubkey_tweak_add(ctx, pubkey, pubkeylen, rnd);\n         CHECK(ret1 == ret2);\n-        if (ret1 == 0) return;\n-        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        if (ret1 == 0) {\n+            return;\n+        }\n+        CHECK(secp256k1_ec_pubkey_create(ctx, pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n         CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n     }\n \n@@ -1293,25 +1477,27 @@ void test_ecdsa_end_to_end(void) {\n         unsigned char pubkey2[65];\n         int pubkeylen2 = 65;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_mul(privkey, rnd);\n-        ret2 = secp256k1_ec_pubkey_tweak_mul(pubkey, pubkeylen, rnd);\n+        ret1 = secp256k1_ec_privkey_tweak_mul(ctx, privkey, rnd);\n+        ret2 = secp256k1_ec_pubkey_tweak_mul(ctx, pubkey, pubkeylen, rnd);\n         CHECK(ret1 == ret2);\n-        if (ret1 == 0) return;\n-        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        if (ret1 == 0) {\n+            return;\n+        }\n+        CHECK(secp256k1_ec_pubkey_create(ctx, pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n         CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n     }\n \n     /* Sign. */\n-    CHECK(secp256k1_ecdsa_sign(message, signature, &signaturelen, privkey, NULL, NULL) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature, &signaturelen, privkey, NULL, NULL) == 1);\n     CHECK(signaturelen > 0);\n-    CHECK(secp256k1_ecdsa_sign(message, signature2, &signaturelen2, privkey, NULL, extra) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature2, &signaturelen2, privkey, NULL, extra) == 1);\n     CHECK(signaturelen2 > 0);\n     extra[31] = 1;\n-    CHECK(secp256k1_ecdsa_sign(message, signature3, &signaturelen3, privkey, NULL, extra) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature3, &signaturelen3, privkey, NULL, extra) == 1);\n     CHECK(signaturelen3 > 0);\n     extra[31] = 0;\n     extra[0] = 1;\n-    CHECK(secp256k1_ecdsa_sign(message, signature4, &signaturelen4, privkey, NULL, extra) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature4, &signaturelen4, privkey, NULL, extra) == 1);\n     CHECK(signaturelen3 > 0);\n     CHECK((signaturelen != signaturelen2) || (memcmp(signature, signature2, signaturelen) != 0));\n     CHECK((signaturelen != signaturelen3) || (memcmp(signature, signature3, signaturelen) != 0));\n@@ -1320,24 +1506,24 @@ void test_ecdsa_end_to_end(void) {\n     CHECK((signaturelen4 != signaturelen2) || (memcmp(signature4, signature2, signaturelen4) != 0));\n     CHECK((signaturelen4 != signaturelen) || (memcmp(signature4, signature, signaturelen4) != 0));\n     /* Verify. */\n-    CHECK(secp256k1_ecdsa_verify(message, signature, signaturelen, pubkey, pubkeylen) == 1);\n-    CHECK(secp256k1_ecdsa_verify(message, signature2, signaturelen2, pubkey, pubkeylen) == 1);\n-    CHECK(secp256k1_ecdsa_verify(message, signature3, signaturelen3, pubkey, pubkeylen) == 1);\n-    CHECK(secp256k1_ecdsa_verify(message, signature4, signaturelen4, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature, signaturelen, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature2, signaturelen2, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature3, signaturelen3, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature4, signaturelen4, pubkey, pubkeylen) == 1);\n     /* Destroy signature and verify again. */\n     signature[signaturelen - 1 - secp256k1_rand32() % 20] += 1 + (secp256k1_rand32() % 255);\n-    CHECK(secp256k1_ecdsa_verify(message, signature, signaturelen, pubkey, pubkeylen) != 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature, signaturelen, pubkey, pubkeylen) != 1);\n \n     /* Compact sign. */\n-    CHECK(secp256k1_ecdsa_sign_compact(message, csignature, privkey, NULL, NULL, &recid) == 1);\n+    CHECK(secp256k1_ecdsa_sign_compact(ctx, message, csignature, privkey, NULL, NULL, &recid) == 1);\n     CHECK(!is_empty_compact_signature(csignature));\n     /* Recover. */\n-    CHECK(secp256k1_ecdsa_recover_compact(message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) == 1);\n+    CHECK(secp256k1_ecdsa_recover_compact(ctx, message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) == 1);\n     CHECK(recpubkeylen == pubkeylen);\n     CHECK(memcmp(pubkey, recpubkey, pubkeylen) == 0);\n     /* Destroy signature and verify again. */\n     csignature[secp256k1_rand32() % 64] += 1 + (secp256k1_rand32() % 255);\n-    CHECK(secp256k1_ecdsa_recover_compact(message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) != 1 ||\n+    CHECK(secp256k1_ecdsa_recover_compact(ctx, message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) != 1 ||\n           memcmp(pubkey, recpubkey, pubkeylen) != 0);\n     CHECK(recpubkeylen == pubkeylen);\n \n@@ -1351,18 +1537,26 @@ void test_random_pubkeys(void) {\n     uint32_t r = secp256k1_rand32();\n     int len = (r & 3) == 0 ? 65 : 33;\n     r>>=2;\n-    if ((r & 3) == 0) len = (r & 252) >> 3;\n+    if ((r & 3) == 0) {\n+        len = (r & 252) >> 3;\n+    }\n     r>>=8;\n     if (len == 65) {\n       in[0] = (r & 2) ? 4 : (r & 1? 6 : 7);\n     } else {\n       in[0] = (r & 1) ? 2 : 3;\n     }\n     r>>=2;\n-    if ((r & 7) == 0) in[0] = (r & 2040) >> 3;\n+    if ((r & 7) == 0) {\n+        in[0] = (r & 2040) >> 3;\n+    }\n     r>>=11;\n-    if (len > 1) secp256k1_rand256(&in[1]);\n-    if (len > 33) secp256k1_rand256(&in[33]);\n+    if (len > 1) {\n+        secp256k1_rand256(&in[1]);\n+    }\n+    if (len > 33) {\n+        secp256k1_rand256(&in[33]);\n+    }\n     if (secp256k1_eckey_pubkey_parse(&elem, in, len)) {\n         unsigned char out[65];\n         unsigned char firstb;\n@@ -1374,7 +1568,9 @@ void test_random_pubkeys(void) {\n         CHECK(size == len);\n         CHECK(memcmp(&in[1], &out[1], len-1) == 0);\n         /* ... except for the type of hybrid inputs. */\n-        if ((in[0] != 6) && (in[0] != 7)) CHECK(in[0] == out[0]);\n+        if ((in[0] != 6) && (in[0] != 7)) {\n+            CHECK(in[0] == out[0]);\n+        }\n         size = 65;\n         CHECK(secp256k1_eckey_pubkey_serialize(&elem, in, &size, 0));\n         CHECK(size == 65);\n@@ -1384,8 +1580,11 @@ void test_random_pubkeys(void) {\n         in[0] = (r & 1) ? 6 : 7;\n         res = secp256k1_eckey_pubkey_parse(&elem2, in, size);\n         if (firstb == 2 || firstb == 3) {\n-            if (in[0] == firstb + 4) CHECK(res);\n-            else CHECK(!res);\n+            if (in[0] == firstb + 4) {\n+              CHECK(res);\n+            } else {\n+              CHECK(!res);\n+            }\n         }\n         if (res) {\n             ge_equals_ge(&elem,&elem2);\n@@ -1447,10 +1646,10 @@ void test_ecdsa_edge_cases(void) {\n     int pubkeyblen = 33;\n     int recid;\n \n-    CHECK(!secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 0));\n-    CHECK(secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 1));\n-    CHECK(!secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 2));\n-    CHECK(!secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 3));\n+    CHECK(!secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 0));\n+    CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 1));\n+    CHECK(!secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 2));\n+    CHECK(!secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 3));\n \n     for (recid = 0; recid < 4; recid++) {\n         int i;\n@@ -1495,42 +1694,44 @@ void test_ecdsa_edge_cases(void) {\n             0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E,\n             0x8C, 0xD0, 0x36, 0x41, 0x45, 0x02, 0x01, 0x04\n         };\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigb64, pubkeyb, &pubkeyblen, 1, recid));\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigb64, pubkeyb, &pubkeyblen, 1, recid));\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 1);\n         for (recid2 = 0; recid2 < 4; recid2++) {\n             unsigned char pubkey2b[33];\n             int pubkey2blen = 33;\n-            CHECK(secp256k1_ecdsa_recover_compact(msg32, sigb64, pubkey2b, &pubkey2blen, 1, recid2));\n+            CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigb64, pubkey2b, &pubkey2blen, 1, recid2));\n             /* Verifying with (order + r,4) should always fail. */\n-            CHECK(secp256k1_ecdsa_verify(msg32, sigbderlong, sizeof(sigbderlong), pubkey2b, pubkey2blen) != 1);\n+            CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderlong, sizeof(sigbderlong), pubkey2b, pubkey2blen) != 1);\n         }\n         /* DER parsing tests. */\n         /* Zero length r/s. */\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder_zr, sizeof(sigcder_zr), pubkeyb, pubkeyblen) == -2);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder_zs, sizeof(sigcder_zs), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder_zr, sizeof(sigcder_zr), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder_zs, sizeof(sigcder_zs), pubkeyb, pubkeyblen) == -2);\n         /* Leading zeros. */\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt1, sizeof(sigbderalt1), pubkeyb, pubkeyblen) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt2, sizeof(sigbderalt2), pubkeyb, pubkeyblen) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt1, sizeof(sigbderalt1), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt2, sizeof(sigbderalt2), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == 1);\n         sigbderalt3[4] = 1;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == -2);\n         sigbderalt4[7] = 1;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == -2);\n         /* Damage signature. */\n         sigbder[7]++;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 0);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 0);\n         sigbder[7]--;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, 6, pubkeyb, pubkeyblen) == -2);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder)-1, pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, 6, pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder)-1, pubkeyb, pubkeyblen) == -2);\n         for(i = 0; i < 8; i++) {\n             int c;\n             unsigned char orig = sigbder[i];\n             /*Try every single-byte change.*/\n             for (c = 0; c < 256; c++) {\n-                if (c == orig ) continue;\n+                if (c == orig ) {\n+                    continue;\n+                }\n                 sigbder[i] = c;\n-                CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) ==\n+                CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) ==\n                   (i==4 || i==7) ? 0 : -2 );\n             }\n             sigbder[i] = orig;\n@@ -1547,10 +1748,10 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_negate(&sig.s, &sig.s);\n         secp256k1_scalar_inverse(&sig.s, &sig.s);\n         secp256k1_scalar_set_int(&sig.r, 1);\n-        secp256k1_ecmult_gen(&keyj, &sig.r);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &keyj, &sig.r);\n         secp256k1_ge_set_gej(&key, &keyj);\n         msg = sig.s;\n-        CHECK(secp256k1_ecdsa_sig_verify(&sig, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &key, &msg) == 0);\n     }\n \n     /* Test r/s equal to zero */\n@@ -1569,18 +1770,18 @@ void test_ecdsa_edge_cases(void) {\n         };\n         unsigned char pubkeyc[65];\n         int pubkeyclen = 65;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigc64, pubkeyc, &pubkeyclen, 0, 0) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 1);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigc64, pubkeyc, &pubkeyclen, 0, 0) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 1);\n         sigcder[4] = 0;\n         sigc64[31] = 0;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n         sigcder[4] = 1;\n         sigcder[7] = 0;\n         sigc64[31] = 1;\n         sigc64[63] = 0;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n     }\n \n     /*Signature where s would be zero.*/\n@@ -1611,18 +1812,18 @@ void test_ecdsa_edge_cases(void) {\n         };\n         unsigned char sig[72];\n         int siglen = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 0);\n         CHECK(siglen == 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 0);\n         CHECK(siglen == 0);\n         msg[31] = 0xaa;\n         siglen = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 1);\n         CHECK(siglen > 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 1);\n         CHECK(siglen > 0);\n         siglen = 10;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce) != 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce) != 1);\n         CHECK(siglen == 0);\n     }\n \n@@ -1644,49 +1845,49 @@ void test_ecdsa_edge_cases(void) {\n         msg[31] = 1;\n         /* High key results in signature failure. */\n         memset(key, 0xFF, 32);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, NULL, extra) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, NULL, extra) == 0);\n         CHECK(siglen == 0);\n         /* Zero key results in signature failure. */\n         memset(key, 0, 32);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, NULL, extra) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, NULL, extra) == 0);\n         CHECK(siglen == 0);\n         /* Nonce function failure results in signature failure. */\n         key[31] = 1;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, nonce_function_test_fail, extra) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, nonce_function_test_fail, extra) == 0);\n         CHECK(siglen == 0);\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig, key, nonce_function_test_fail, extra, &recid) == 0);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig, key, nonce_function_test_fail, extra, &recid) == 0);\n         CHECK(is_empty_compact_signature(sig));\n         /* The retry loop successfully makes its way to the first good value. */\n         siglen = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, nonce_function_test_retry, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, nonce_function_test_retry, extra) == 1);\n         CHECK(siglen > 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, nonce_function_rfc6979, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, nonce_function_rfc6979, extra) == 1);\n         CHECK(siglen > 0);\n         CHECK((siglen == siglen2) && (memcmp(sig, sig2, siglen) == 0));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig, key, nonce_function_test_retry, extra, &recid) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig, key, nonce_function_test_retry, extra, &recid) == 1);\n         CHECK(!is_empty_compact_signature(sig));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig2, key, nonce_function_rfc6979, extra, &recid2) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig2, key, nonce_function_rfc6979, extra, &recid2) == 1);\n         CHECK(!is_empty_compact_signature(sig2));\n         CHECK((recid == recid2) && (memcmp(sig, sig2, 64) == 0));\n         /* The default nonce function is determinstic. */\n         siglen = 72;\n         siglen2 = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, NULL, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, NULL, extra) == 1);\n         CHECK(siglen > 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, NULL, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, NULL, extra) == 1);\n         CHECK(siglen2 > 0);\n         CHECK((siglen == siglen2) && (memcmp(sig, sig2, siglen) == 0));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig, key, NULL, extra, &recid) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig, key, NULL, extra, &recid) == 1);\n         CHECK(!is_empty_compact_signature(sig));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig2, key, NULL, extra, &recid2) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig2, key, NULL, extra, &recid2) == 1);\n         CHECK(!is_empty_compact_signature(sig));\n         CHECK((recid == recid2) && (memcmp(sig, sig2, 64) == 0));\n         /* The default nonce function changes output with different messages. */\n         for(i = 0; i < 256; i++) {\n             int j;\n             siglen2 = 72;\n             msg[0] = i;\n-            CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, NULL, extra) == 1);\n+            CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, NULL, extra) == 1);\n             CHECK(!is_empty_compact_signature(sig));\n             CHECK(secp256k1_ecdsa_sig_parse(&s[i], sig2, siglen2));\n             for (j = 0; j < i; j++) {\n@@ -1700,7 +1901,7 @@ void test_ecdsa_edge_cases(void) {\n             int j;\n             siglen2 = 72;\n             key[0] = i - 256;\n-            CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, NULL, extra) == 1);\n+            CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, NULL, extra) == 1);\n             CHECK(secp256k1_ecdsa_sig_parse(&s[i], sig2, siglen2));\n             for (j = 0; j < i; j++) {\n                 CHECK(!secp256k1_scalar_eq(&s[i].r, &s[j].r));\n@@ -1719,8 +1920,8 @@ void test_ecdsa_edge_cases(void) {\n             0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41,\n         };\n         int outlen = 300;\n-        CHECK(!secp256k1_ec_privkey_export(seckey, privkey, &outlen, 0));\n-        CHECK(!secp256k1_ec_privkey_export(seckey, privkey, &outlen, 1));\n+        CHECK(!secp256k1_ec_privkey_export(ctx, seckey, privkey, &outlen, 0));\n+        CHECK(!secp256k1_ec_privkey_export(ctx, seckey, privkey, &outlen, 1));\n     }\n }\n \n@@ -1735,7 +1936,7 @@ EC_KEY *get_openssl_key(const secp256k1_scalar_t *key) {\n     const unsigned char* pbegin = privkey;\n     int compr = secp256k1_rand32() & 1;\n     EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    CHECK(secp256k1_eckey_privkey_serialize(privkey, &privkeylen, key, compr));\n+    CHECK(secp256k1_eckey_privkey_serialize(&ctx->ecmult_gen_ctx, privkey, &privkeylen, key, compr));\n     CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n     CHECK(EC_KEY_check_key(ec_key));\n     return ec_key;\n@@ -1756,16 +1957,16 @@ void test_ecdsa_openssl(void) {\n     secp256k1_rand256_test(message);\n     secp256k1_scalar_set_b32(&msg, message, NULL);\n     random_scalar_order_test(&key);\n-    secp256k1_ecmult_gen(&qj, &key);\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &qj, &key);\n     secp256k1_ge_set_gej(&q, &qj);\n     ec_key = get_openssl_key(&key);\n     CHECK(ec_key);\n     CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n     CHECK(secp256k1_ecdsa_sig_parse(&sig, signature, sigsize));\n-    CHECK(secp256k1_ecdsa_sig_verify(&sig, &q, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &q, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg2, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &q, &msg2));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &q, &msg2));\n \n     random_sign(&sig, &key, &msg, NULL);\n     CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sig));\n@@ -1825,10 +2026,13 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    secp256k1_start(SECP256K1_START_SIGN | SECP256K1_START_VERIFY);\n+    run_context_tests();\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n \n-    /* initializing a second time shouldn't cause any harm or memory leaks. */\n-    secp256k1_start(SECP256K1_START_SIGN | SECP256K1_START_VERIFY);\n+    if (secp256k1_rand32() & 1) {\n+        secp256k1_rand256(run32);\n+        CHECK(secp256k1_context_randomize(ctx, secp256k1_rand32() & 1 ? run32 : NULL));\n+    }\n \n     run_sha256_tests();\n     run_hmac_sha256_tests();\n@@ -1858,6 +2062,8 @@ int main(int argc, char **argv) {\n     run_wnaf();\n     run_point_times_order();\n     run_ecmult_chain();\n+    run_ecmult_constants();\n+    run_ecmult_gen_blind();\n \n     /* ecdsa tests */\n     run_random_pubkeys();\n@@ -1872,9 +2078,6 @@ int main(int argc, char **argv) {\n     printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n \n     /* shutdown */\n-    secp256k1_stop();\n-\n-    /* shutting down twice shouldn't cause any double frees. */\n-    secp256k1_stop();\n+    secp256k1_context_destroy(ctx);\n     return 0;\n }"
      }
    ]
  },
  {
    "sha": "4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZGRhMjUzMTkwZTZmNWFjNjcyOGU4OGZlZmRmNmU4ZWFmNDE0MTlj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-22T21:03:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-22T21:03:10Z"
      },
      "message": "Update libsecp256k1",
      "tree": {
        "sha": "54ef6fd4552e52359b614795c203ef1a1dd070e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/54ef6fd4552e52359b614795c203ef1a1dd070e6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6ea3bcede1cbbf89486b9d67329e0110c4624ae"
      },
      {
        "sha": "a591d98c322093040d59e152591f0978962f9da7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a591d98c322093040d59e152591f0978962f9da7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a591d98c322093040d59e152591f0978962f9da7"
      }
    ],
    "stats": {
      "total": 1622,
      "additions": 1154,
      "deletions": 468
    },
    "files": [
      {
        "sha": "076ff1295f24357114dd4a07ccb30cfe0689a505",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -2,6 +2,7 @@ bench_inv\n bench_sign\n bench_verify\n bench_recover\n+bench_internal\n tests\n *.exe\n *.so"
      },
      {
        "sha": "0d8089cfe4e87a44c0fd9da376d6407f1ac31c58",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 34,
        "deletions": 7,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -1,14 +1,14 @@\n language: c\n+sudo: false\n+addons:\n+  apt:\n+    packages: libgmp-dev\n compiler:\n   - clang\n   - gcc\n-install:\n-  - sudo apt-get install -qq libssl-dev\n-  - if [ \"$BIGNUM\" = \"gmp\" -o \"$BIGNUM\" = \"auto\" ]; then sudo apt-get install --no-install-recommends --no-upgrade -qq libgmp-dev; fi\n-  - if [ -n \"$EXTRAPACKAGES\" ]; then sudo apt-get update && sudo apt-get install --no-install-recommends --no-upgrade $EXTRAPACKAGES; fi\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  ASM=no  BUILD=check  EXTRAFLAGS= HOST= EXTRAPACKAGES=\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  ASM=no  BUILD=check  EXTRAFLAGS= HOST=\n   matrix:\n     - SCALAR=32bit\n     - SCALAR=64bit\n@@ -22,8 +22,35 @@ env:\n     - BIGNUM=no       ENDOMORPHISM=yes\n     - BUILD=distcheck\n     - EXTRAFLAGS=CFLAGS=-DDETERMINISTIC\n-    - HOST=i686-linux-gnu EXTRAPACKAGES=\"gcc-multilib\"\n-    - HOST=i686-linux-gnu EXTRAPACKAGES=\"gcc-multilib\" ENDOMORPHISM=yes\n+matrix:\n+  fast_finish: true\n+  include:\n+    - compiler: clang\n+      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+            - libgmp-dev:i386\n+    - compiler: clang\n+      env: HOST=i686-linux-gnu\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+    - compiler: gcc\n+      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+    - compiler: gcc\n+      env: HOST=i686-linux-gnu\n+      addons:\n+        apt:\n+          packages:\n+            - gcc-multilib\n+            - libgmp-dev:i386\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi"
      },
      {
        "sha": "06afd4c65bc8e65f5d3662e53919886c58bcc82a",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 101,
        "deletions": 49,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -40,42 +40,60 @@ extern \"C\" {\n #  define SECP256K1_ARG_NONNULL(_x)\n # endif\n \n+/** Opaque data structure that holds context information (precomputed tables etc.).\n+ *  Only functions that take a pointer to a non-const context require exclusive\n+ *  access to it. Multiple functions that take a pointer to a const context may\n+ *  run simultaneously.\n+ */\n+typedef struct secp256k1_context_struct secp256k1_context_t;\n+\n+/** Flags to pass to secp256k1_context_create. */\n+# define SECP256K1_CONTEXT_VERIFY (1 << 0)\n+# define SECP256K1_CONTEXT_SIGN   (1 << 1)\n \n-/** Flags to pass to secp256k1_start. */\n-# define SECP256K1_START_VERIFY (1 << 0)\n-# define SECP256K1_START_SIGN   (1 << 1)\n+/** Create a secp256k1 context object.\n+ *  Returns: a newly created context object.\n+ *  In:      flags: which parts of the context to initialize.\n+ */\n+secp256k1_context_t* secp256k1_context_create(\n+  int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Initialize the library. This may take some time (10-100 ms).\n- *  You need to call this before calling any other function.\n- *  It cannot run in parallel with any other functions, but once\n- *  secp256k1_start() returns, all other functions are thread-safe.\n+/** Copies a secp256k1 context object.\n+ *  Returns: a newly created context object.\n+ *  In:      ctx: an existing context to copy\n  */\n-void secp256k1_start(unsigned int flags);\n+secp256k1_context_t* secp256k1_context_clone(\n+  const secp256k1_context_t* ctx\n+) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Free all memory associated with this library. After this, no\n- *  functions can be called anymore, except secp256k1_start()\n+/** Destroy a secp256k1 context object.\n+ *  The context pointer may not be used afterwards.\n  */\n-void secp256k1_stop(void);\n+void secp256k1_context_destroy(\n+  secp256k1_context_t* ctx\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Verify an ECDSA signature.\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *          -1: invalid public key\n  *          -2: invalid signature\n- * In:       msg32:     the 32-byte message hash being verified (cannot be NULL)\n+ * In:       ctx:       a secp256k1 context object, initialized for verification.\n+ *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n  *           sig:       the signature being verified (cannot be NULL)\n  *           siglen:    the length of the signature\n  *           pubkey:    the public key to verify with (cannot be NULL)\n  *           pubkeylen: the length of pubkey\n- * Requires starting using SECP256K1_START_VERIFY.\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   const unsigned char *sig,\n   int siglen,\n   const unsigned char *pubkey,\n   int pubkeylen\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n /** A pointer to a function to deterministically generate a nonce.\n  * Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n@@ -111,15 +129,14 @@ extern const secp256k1_nonce_function_t secp256k1_nonce_function_default;\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, the private key was invalid, or there is not\n  *              enough space in the signature (as indicated by siglen).\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n+ *  In:      ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n+ *           msg32:  the 32-byte message hash being signed (cannot be NULL)\n  *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n  *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n  *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n  *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n  *  In/Out:  siglen: pointer to an int with the length of sig, which will be updated\n- *                   to contain the actual signature length (<=72). If 0 is returned, this will be\n- *                   set to zero.\n- * Requires starting using SECP256K1_START_SIGN.\n+ *                   to contain the actual signature length (<=72).\n  *\n  * The sig always has an s value in the lower half of the range (From 0x1\n  * to 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n@@ -148,145 +165,180 @@ extern const secp256k1_nonce_function_t secp256k1_nonce_function_default;\n  * be taken when this property is required for an application.\n  */\n int secp256k1_ecdsa_sign(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   unsigned char *sig,\n   int *siglen,\n   const unsigned char *seckey,\n   secp256k1_nonce_function_t noncefp,\n   const void *ndata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n \n /** Create a compact ECDSA signature (64 byte + recovery id).\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n+ *  In:      ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n+ *           msg32:  the 32-byte message hash being signed (cannot be NULL)\n  *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n  *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n  *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n  *  Out:     sig:    pointer to a 64-byte array where the signature will be placed (cannot be NULL)\n  *                   In case 0 is returned, the returned signature length will be zero.\n  *           recid:  pointer to an int, which will be updated to contain the recovery id (can be NULL)\n- * Requires starting using SECP256K1_START_SIGN.\n  */\n int secp256k1_ecdsa_sign_compact(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   unsigned char *sig64,\n   const unsigned char *seckey,\n   secp256k1_nonce_function_t noncefp,\n   const void *ndata,\n   int *recid\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Recover an ECDSA public key from a compact signature.\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  In:      msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  In:      ctx:        pointer to a context object, initialized for verification (cannot be NULL)\n+ *           msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)\n  *           sig64:      signature as 64 byte array (cannot be NULL)\n  *           compressed: whether to recover a compressed or uncompressed pubkey\n  *           recid:      the recovery id (0-3, as returned by ecdsa_sign_compact)\n  *  Out:     pubkey:     pointer to a 33 or 65 byte array to put the pubkey (cannot be NULL)\n  *           pubkeylen:  pointer to an int that will contain the pubkey length (cannot be NULL)\n- * Requires starting using SECP256K1_START_VERIFY.\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover_compact(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *msg32,\n   const unsigned char *sig64,\n   unsigned char *pubkey,\n   int *pubkeylen,\n   int compressed,\n   int recid\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n \n /** Verify an ECDSA secret key.\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n- *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  In:      ctx: pointer to a context object (cannot be NULL)\n+ *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n  */\n-SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(const unsigned char *seckey) SECP256K1_ARG_NONNULL(1);\n+SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n+  const secp256k1_context_t* ctx,\n+  const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n \n /** Just validate a public key.\n- *  Returns: 1: valid public key\n- *           0: invalid public key\n- *  In:      pubkey:    pointer to a 33-byte or 65-byte public key (cannot be NULL).\n+ *  Returns: 1: public key is valid\n+ *           0: public key is invalid\n+ *  In:      ctx:       pointer to a context object (cannot be NULL)\n+ *           pubkey:    pointer to a 33-byte or 65-byte public key (cannot be NULL).\n  *           pubkeylen: length of pubkey\n  */\n-SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen) SECP256K1_ARG_NONNULL(1);\n+SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_verify(\n+  const secp256k1_context_t* ctx,\n+  const unsigned char *pubkey,\n+  int pubkeylen\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n \n /** Compute the public key for a secret key.\n- *  In:     compressed: whether the computed public key should be compressed\n+ *  In:     ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n+ *          compressed: whether the computed public key should be compressed\n  *          seckey:     pointer to a 32-byte private key (cannot be NULL)\n  *  Out:    pubkey:     pointer to a 33-byte (if compressed) or 65-byte (if uncompressed)\n  *                      area to store the public key (cannot be NULL)\n  *          pubkeylen:  pointer to int that will be updated to contains the pubkey's\n  *                      length (cannot be NULL)\n  *  Returns: 1: secret was valid, public key stores\n- *           0: secret was invalid, try again.\n- * Requires starting using SECP256K1_START_SIGN.\n+ *           0: secret was invalid, try again\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int *pubkeylen,\n   const unsigned char *seckey,\n   int compressed\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Decompress a public key.\n+ * In:     ctx:       pointer to a context object (cannot be NULL)\n  * In/Out: pubkey:    pointer to a 65-byte array to put the decompressed public key.\n-                      It must contain a 33-byte or 65-byte public key already (cannot be NULL)\n+ *                    It must contain a 33-byte or 65-byte public key already (cannot be NULL)\n  *         pubkeylen: pointer to the size of the public key pointed to by pubkey (cannot be NULL)\n-                      It will be updated to reflect the new size.\n- * Returns: 0 if the passed public key was invalid, 1 otherwise. If 1 is returned, the\n-            pubkey is replaced with its decompressed version.\n+ *                    It will be updated to reflect the new size.\n+ * Returns: 0: pubkey was invalid\n+ *          1: pubkey was valid, and was replaced with its decompressed version\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_decompress(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int *pubkeylen\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Export a private key in DER format. */\n+/** Export a private key in DER format.\n+ * In: ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_export(\n+  const secp256k1_context_t* ctx,\n   const unsigned char *seckey,\n   unsigned char *privkey,\n   int *privkeylen,\n   int compressed\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Import a private key in DER format. */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_import(\n+  const secp256k1_context_t* ctx,\n   unsigned char *seckey,\n   const unsigned char *privkey,\n   int privkeylen\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a private key by adding tweak to it. */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n+  const secp256k1_context_t* ctx,\n   unsigned char *seckey,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by adding tweak times the generator to it.\n- * Requires starting with SECP256K1_START_VERIFY.\n+ * In: ctx: pointer to a context object, initialized for verification (cannot be NULL)\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int pubkeylen,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n \n /** Tweak a private key by multiplying it with tweak. */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n+  const secp256k1_context_t* ctx,\n   unsigned char *seckey,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by multiplying it with tweak.\n- * Requires starting with SECP256K1_START_VERIFY.\n+ * In: ctx: pointer to a context object, initialized for verification (cannot be NULL)\n  */\n SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n+  const secp256k1_context_t* ctx,\n   unsigned char *pubkey,\n   int pubkeylen,\n   const unsigned char *tweak\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Updates the context randomization.\n+ *  Returns: 1: randomization successfully updated\n+ *           0: error\n+ *  In:      ctx:       pointer to a context object (cannot be NULL)\n+ *           seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n+ */\n+SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n+  secp256k1_context_t* ctx,\n+  const unsigned char *seed32\n+) SECP256K1_ARG_NONNULL(1);\n+\n \n # ifdef __cplusplus\n }"
      },
      {
        "sha": "db5f68cee1f47306c0092b14016de32f3d169f86",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -48,7 +48,7 @@ void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), v\n     print_number(min * 1000000.0 / iter);\n     printf(\"us / avg \");\n     print_number((sum / count) * 1000000.0 / iter);\n-    printf(\"us / avg \");\n+    printf(\"us / max \");\n     print_number(max * 1000000.0 / iter);\n     printf(\"us\\n\");\n }"
      },
      {
        "sha": "56faed11a043a04825b270cc2f48fb080f112865",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -9,6 +9,7 @@\n #include \"bench.h\"\n \n typedef struct {\n+    secp256k1_context_t *ctx;\n     unsigned char msg[32];\n     unsigned char sig[64];\n } bench_recover_t;\n@@ -21,7 +22,7 @@ void bench_recover(void* arg) {\n     for (i = 0; i < 20000; i++) {\n         int j;\n         int pubkeylen = 33;\n-        CHECK(secp256k1_ecdsa_recover_compact(data->msg, data->sig, pubkey, &pubkeylen, 1, i % 2));\n+        CHECK(secp256k1_ecdsa_recover_compact(data->ctx, data->msg, data->sig, pubkey, &pubkeylen, 1, i % 2));\n         for (j = 0; j < 32; j++) {\n             data->sig[j + 32] = data->msg[j];    /* Move former message to S. */\n             data->msg[j] = data->sig[j];         /* Move former R to message. */\n@@ -40,10 +41,11 @@ void bench_recover_setup(void* arg) {\n \n int main(void) {\n     bench_recover_t data;\n-    secp256k1_start(SECP256K1_START_VERIFY);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n \n     run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n \n-    secp256k1_stop();\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "072a37af516a28ef63a728062fcc4b22f011b7a3",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -9,6 +9,7 @@\n #include \"bench.h\"\n \n typedef struct {\n+    secp256k1_context_t* ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n } bench_sign_t;\n@@ -29,7 +30,7 @@ static void bench_sign(void* arg) {\n     for (i = 0; i < 20000; i++) {\n         int j;\n         int recid = 0;\n-        CHECK(secp256k1_ecdsa_sign_compact(data->msg, sig, data->key, NULL, NULL, &recid));\n+        CHECK(secp256k1_ecdsa_sign_compact(data->ctx, data->msg, sig, data->key, NULL, NULL, &recid));\n         for (j = 0; j < 32; j++) {\n             data->msg[j] = sig[j];             /* Move former R to message. */\n             data->key[j] = sig[j + 32];        /* Move former S to key.     */\n@@ -39,10 +40,11 @@ static void bench_sign(void* arg) {\n \n int main(void) {\n     bench_sign_t data;\n-    secp256k1_start(SECP256K1_START_SIGN);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n     run_benchmark(\"ecdsa_sign\", bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n \n-    secp256k1_stop();\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "c8c82752cec4f14274873a1cd96b4508a663e559",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -12,6 +12,7 @@\n #include \"bench.h\"\n \n typedef struct {\n+    secp256k1_context_t *ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n     unsigned char sig[72];\n@@ -28,7 +29,7 @@ static void benchmark_verify(void* arg) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n-        CHECK(secp256k1_ecdsa_verify(data->msg, data->sig, data->siglen, data->pubkey, data->pubkeylen) == (i == 0));\n+        CHECK(secp256k1_ecdsa_verify(data->ctx, data->msg, data->sig, data->siglen, data->pubkey, data->pubkeylen) == (i == 0));\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n@@ -39,17 +40,17 @@ int main(void) {\n     int i;\n     benchmark_verify_t data;\n \n-    secp256k1_start(SECP256K1_START_VERIFY | SECP256K1_START_SIGN);\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n \n     for (i = 0; i < 32; i++) data.msg[i] = 1 + i;\n     for (i = 0; i < 32; i++) data.key[i] = 33 + i;\n     data.siglen = 72;\n-    secp256k1_ecdsa_sign(data.msg, data.sig, &data.siglen, data.key, NULL, NULL);\n+    secp256k1_ecdsa_sign(data.ctx, data.msg, data.sig, &data.siglen, data.key, NULL, NULL);\n     data.pubkeylen = 33;\n-    CHECK(secp256k1_ec_pubkey_create(data.pubkey, &data.pubkeylen, data.key, 1));\n+    CHECK(secp256k1_ec_pubkey_create(data.ctx, data.pubkey, &data.pubkeylen, data.key, 1));\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n \n-    secp256k1_stop();\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "4ef78e8afb5ea2cbae9b031c7f484b5e9d6890ae",
        "filename": "src/secp256k1/src/ecdsa.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -9,15 +9,16 @@\n \n #include \"scalar.h\"\n #include \"group.h\"\n+#include \"ecmult.h\"\n \n typedef struct {\n     secp256k1_scalar_t r, s;\n } secp256k1_ecdsa_sig_t;\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned char *sig, int size);\n static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const secp256k1_ecdsa_sig_t *a);\n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message);\n-static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid);\n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid);\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message);\n+static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context_t *ctx, secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid);\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid);\n \n #endif"
      },
      {
        "sha": "ed1d228189d30c2b4e04aabf1e11248f38d250f3",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 58,
        "deletions": 26,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -53,35 +53,59 @@ static int secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned ch\n     int lenr;\n     int lens;\n     int overflow;\n-    if (sig[0] != 0x30) return 0;\n+    if (sig[0] != 0x30) {\n+        return 0;\n+    }\n     lenr = sig[3];\n-    if (5+lenr >= size) return 0;\n+    if (5+lenr >= size) {\n+        return 0;\n+    }\n     lens = sig[lenr+5];\n-    if (sig[1] != lenr+lens+4) return 0;\n-    if (lenr+lens+6 > size) return 0;\n-    if (sig[2] != 0x02) return 0;\n-    if (lenr == 0) return 0;\n-    if (sig[lenr+4] != 0x02) return 0;\n-    if (lens == 0) return 0;\n+    if (sig[1] != lenr+lens+4) {\n+        return 0;\n+    }\n+    if (lenr+lens+6 > size) {\n+        return 0;\n+    }\n+    if (sig[2] != 0x02) {\n+        return 0;\n+    }\n+    if (lenr == 0) {\n+        return 0;\n+    }\n+    if (sig[lenr+4] != 0x02) {\n+        return 0;\n+    }\n+    if (lens == 0) {\n+        return 0;\n+    }\n     sp = sig + 6 + lenr;\n     while (lens > 0 && sp[0] == 0) {\n         lens--;\n         sp++;\n     }\n-    if (lens > 32) return 0;\n+    if (lens > 32) {\n+        return 0;\n+    }\n     rp = sig + 4;\n     while (lenr > 0 && rp[0] == 0) {\n         lenr--;\n         rp++;\n     }\n-    if (lenr > 32) return 0;\n+    if (lenr > 32) {\n+        return 0;\n+    }\n     memcpy(ra + 32 - lenr, rp, lenr);\n     memcpy(sa + 32 - lens, sp, lens);\n     overflow = 0;\n     secp256k1_scalar_set_b32(&r->r, ra, &overflow);\n-    if (overflow) return 0;\n+    if (overflow) {\n+        return 0;\n+    }\n     secp256k1_scalar_set_b32(&r->s, sa, &overflow);\n-    if (overflow) return 0;\n+    if (overflow) {\n+        return 0;\n+    }\n     return 1;\n }\n \n@@ -93,8 +117,9 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const se\n     secp256k1_scalar_get_b32(&s[1], &a->s);\n     while (lenR > 1 && rp[0] == 0 && rp[1] < 0x80) { lenR--; rp++; }\n     while (lenS > 1 && sp[0] == 0 && sp[1] < 0x80) { lenS--; sp++; }\n-    if (*size < 6+lenS+lenR)\n+    if (*size < 6+lenS+lenR) {\n         return 0;\n+    }\n     *size = 6 + lenS + lenR;\n     sig[0] = 0x30;\n     sig[1] = 4 + lenS + lenR;\n@@ -107,21 +132,22 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const se\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n     unsigned char c[32];\n     secp256k1_scalar_t sn, u1, u2;\n     secp256k1_fe_t xr;\n     secp256k1_gej_t pubkeyj;\n     secp256k1_gej_t pr;\n \n-    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s))\n+    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_inverse_var(&sn, &sig->s);\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, &sig->r);\n     secp256k1_gej_set_ge(&pubkeyj, pubkey);\n-    secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n+    secp256k1_ecmult(ctx, &pr, &pubkeyj, &u2, &u1);\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }\n@@ -160,44 +186,47 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const se\n     return 0;\n }\n \n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid) {\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context_t *ctx, const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid) {\n     unsigned char brx[32];\n     secp256k1_fe_t fx;\n     secp256k1_ge_t x;\n     secp256k1_gej_t xj;\n     secp256k1_scalar_t rn, u1, u2;\n     secp256k1_gej_t qj;\n \n-    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s))\n+    if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_get_b32(brx, &sig->r);\n     VERIFY_CHECK(secp256k1_fe_set_b32(&fx, brx)); /* brx comes from a scalar, so is less than the order; certainly less than p */\n     if (recid & 2) {\n-        if (secp256k1_fe_cmp_var(&fx, &secp256k1_ecdsa_const_p_minus_order) >= 0)\n+        if (secp256k1_fe_cmp_var(&fx, &secp256k1_ecdsa_const_p_minus_order) >= 0) {\n             return 0;\n+        }\n         secp256k1_fe_add(&fx, &secp256k1_ecdsa_const_order_as_fe);\n     }\n-    if (!secp256k1_ge_set_xo_var(&x, &fx, recid & 1))\n+    if (!secp256k1_ge_set_xo_var(&x, &fx, recid & 1)) {\n         return 0;\n+    }\n     secp256k1_gej_set_ge(&xj, &x);\n     secp256k1_scalar_inverse_var(&rn, &sig->r);\n     secp256k1_scalar_mul(&u1, &rn, message);\n     secp256k1_scalar_negate(&u1, &u1);\n     secp256k1_scalar_mul(&u2, &rn, &sig->s);\n-    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n+    secp256k1_ecmult(ctx, &qj, &xj, &u2, &u1);\n     secp256k1_ge_set_gej_var(pubkey, &qj);\n     return !secp256k1_gej_is_infinity(&qj);\n }\n \n-static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n+static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context_t *ctx, secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n     unsigned char b[32];\n     secp256k1_gej_t rp;\n     secp256k1_ge_t r;\n     secp256k1_scalar_t n;\n     int overflow = 0;\n \n-    secp256k1_ecmult_gen(&rp, nonce);\n+    secp256k1_ecmult_gen(ctx, &rp, nonce);\n     secp256k1_ge_set_gej(&r, &rp);\n     secp256k1_fe_normalize(&r.x);\n     secp256k1_fe_normalize(&r.y);\n@@ -209,21 +238,24 @@ static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_\n         secp256k1_ge_clear(&r);\n         return 0;\n     }\n-    if (recid)\n+    if (recid) {\n         *recid = (overflow ? 2 : 0) | (secp256k1_fe_is_odd(&r.y) ? 1 : 0);\n+    }\n     secp256k1_scalar_mul(&n, &sig->r, seckey);\n     secp256k1_scalar_add(&n, &n, message);\n     secp256k1_scalar_inverse(&sig->s, nonce);\n     secp256k1_scalar_mul(&sig->s, &sig->s, &n);\n     secp256k1_scalar_clear(&n);\n     secp256k1_gej_clear(&rp);\n     secp256k1_ge_clear(&r);\n-    if (secp256k1_scalar_is_zero(&sig->s))\n+    if (secp256k1_scalar_is_zero(&sig->s)) {\n         return 0;\n+    }\n     if (secp256k1_scalar_is_high(&sig->s)) {\n         secp256k1_scalar_negate(&sig->s, &sig->s);\n-        if (recid)\n+        if (recid) {\n             *recid ^= 1;\n+        }\n     }\n     return 1;\n }"
      },
      {
        "sha": "53b818485ed6d5158dbc6cb9e8c911c0afadbf3c",
        "filename": "src/secp256k1/src/eckey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -9,16 +9,18 @@\n \n #include \"group.h\"\n #include \"scalar.h\"\n+#include \"ecmult.h\"\n+#include \"ecmult_gen.h\"\n \n static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size);\n static int secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char *pub, int *size, int compressed);\n \n static int secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned char *privkey, int privkeylen);\n-static int secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed);\n+static int secp256k1_eckey_privkey_serialize(const secp256k1_ecmult_gen_context_t *ctx, unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed);\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n-static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n+static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n-static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n+static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak);\n \n #endif"
      },
      {
        "sha": "a332bd34ecda4bb21357569027c602c727a50301",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 18,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -24,8 +24,9 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned cha\n             return 0;\n         }\n         secp256k1_ge_set_xy(elem, &x, &y);\n-        if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07))\n+        if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07)) {\n             return 0;\n+        }\n         return secp256k1_ge_is_valid_var(elem);\n     } else {\n         return 0;\n@@ -57,40 +58,47 @@ static int secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned\n     int len = 0;\n     int overflow = 0;\n     /* sequence header */\n-    if (end < privkey+1 || *privkey != 0x30)\n+    if (end < privkey+1 || *privkey != 0x30) {\n         return 0;\n+    }\n     privkey++;\n     /* sequence length constructor */\n-    if (end < privkey+1 || !(*privkey & 0x80))\n+    if (end < privkey+1 || !(*privkey & 0x80)) {\n         return 0;\n+    }\n     lenb = *privkey & ~0x80; privkey++;\n-    if (lenb < 1 || lenb > 2)\n+    if (lenb < 1 || lenb > 2) {\n         return 0;\n-    if (end < privkey+lenb)\n+    }\n+    if (end < privkey+lenb) {\n         return 0;\n+    }\n     /* sequence length */\n     len = privkey[lenb-1] | (lenb > 1 ? privkey[lenb-2] << 8 : 0);\n     privkey += lenb;\n-    if (end < privkey+len)\n+    if (end < privkey+len) {\n         return 0;\n+    }\n     /* sequence element 0: version number (=1) */\n-    if (end < privkey+3 || privkey[0] != 0x02 || privkey[1] != 0x01 || privkey[2] != 0x01)\n+    if (end < privkey+3 || privkey[0] != 0x02 || privkey[1] != 0x01 || privkey[2] != 0x01) {\n         return 0;\n+    }\n     privkey += 3;\n     /* sequence element 1: octet string, up to 32 bytes */\n-    if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1])\n+    if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1]) {\n         return 0;\n+    }\n     memcpy(c + 32 - privkey[1], privkey + 2, privkey[1]);\n     secp256k1_scalar_set_b32(key, c, &overflow);\n     memset(c, 0, 32);\n     return !overflow;\n }\n \n-static int secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed) {\n+static int secp256k1_eckey_privkey_serialize(const secp256k1_ecmult_gen_context_t *ctx, unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed) {\n     secp256k1_gej_t rp;\n     secp256k1_ge_t r;\n     int pubkeylen = 0;\n-    secp256k1_ecmult_gen(&rp, key);\n+    secp256k1_ecmult_gen(ctx, &rp, key);\n     secp256k1_ge_set_gej(&r, &rp);\n     if (compressed) {\n         static const unsigned char begin[] = {\n@@ -148,41 +156,45 @@ static int secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privke\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n     secp256k1_scalar_add(key, key, tweak);\n-    if (secp256k1_scalar_is_zero(key))\n+    if (secp256k1_scalar_is_zero(key)) {\n         return 0;\n+    }\n     return 1;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n     secp256k1_gej_t pt;\n     secp256k1_scalar_t one;\n     secp256k1_gej_set_ge(&pt, key);\n     secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_ecmult(&pt, &pt, &one, tweak);\n+    secp256k1_ecmult(ctx, &pt, &pt, &one, tweak);\n \n-    if (secp256k1_gej_is_infinity(&pt))\n+    if (secp256k1_gej_is_infinity(&pt)) {\n         return 0;\n+    }\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }\n \n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n-    if (secp256k1_scalar_is_zero(tweak))\n+    if (secp256k1_scalar_is_zero(tweak)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_mul(key, key, tweak);\n     return 1;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context_t *ctx, secp256k1_ge_t *key, const secp256k1_scalar_t *tweak) {\n     secp256k1_scalar_t zero;\n     secp256k1_gej_t pt;\n-    if (secp256k1_scalar_is_zero(tweak))\n+    if (secp256k1_scalar_is_zero(tweak)) {\n         return 0;\n+    }\n \n     secp256k1_scalar_set_int(&zero, 0);\n     secp256k1_gej_set_ge(&pt, key);\n-    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n+    secp256k1_ecmult(ctx, &pt, &pt, tweak, &zero);\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }"
      },
      {
        "sha": "bab9e4ef52242e42906b630480356400c6665a70",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -10,10 +10,22 @@\n #include \"num.h\"\n #include \"group.h\"\n \n-static void secp256k1_ecmult_start(void);\n-static void secp256k1_ecmult_stop(void);\n+typedef struct {\n+    /* For accelerating the computation of a*P + b*G: */\n+    secp256k1_ge_storage_t (*pre_g)[];    /* odd multiples of the generator */\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge_storage_t (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n+#endif\n+} secp256k1_ecmult_context_t;\n+\n+static void secp256k1_ecmult_context_init(secp256k1_ecmult_context_t *ctx);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context_t *ctx);\n+static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context_t *dst,\n+                                           const secp256k1_ecmult_context_t *src);\n+static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context_t *ctx);\n+static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context_t *ctx);\n \n /** Double multiply: R = na*A + ng*G */\n-static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng);\n+static void secp256k1_ecmult(const secp256k1_ecmult_context_t *ctx, secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng);\n \n #endif"
      },
      {
        "sha": "3745633c47f91acd24926888fcf7889d4488799a",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 27,
        "deletions": 3,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -10,10 +10,34 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-static void secp256k1_ecmult_gen_start(void);\n-static void secp256k1_ecmult_gen_stop(void);\n+typedef struct {\n+    /* For accelerating the computation of a*G:\n+     * To harden against timing attacks, use the following mechanism:\n+     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n+     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n+     *   * U_i = U * 2^i (for i=0..62)\n+     *   * U_i = U * (1-2^63) (for i=63)\n+     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n+     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n+     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+     * None of the resulting prec group elements have a known scalar, and neither do any of\n+     * the intermediate sums while computing a*G.\n+     */\n+    secp256k1_ge_storage_t (*prec)[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n+    secp256k1_scalar_t blind;\n+    secp256k1_gej_t initial;\n+} secp256k1_ecmult_gen_context_t;\n+\n+static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context_t* ctx);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context_t* ctx);\n+static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context_t *dst,\n+                                               const secp256k1_ecmult_gen_context_t* src);\n+static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context_t* ctx);\n+static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context_t* ctx);\n \n /** Multiply with the generator: R = a*G */\n-static void secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *a);\n+static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context_t* ctx, secp256k1_gej_t *r, const secp256k1_scalar_t *a);\n+\n+static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context_t *ctx, const unsigned char *seed32);\n \n #endif"
      },
      {
        "sha": "4697753ac81f85d4db62dcdaba15ed5b384dccae",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 96,
        "deletions": 38,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell      *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -10,36 +10,23 @@\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n+#include \"hash_impl.h\"\n \n-typedef struct {\n-    /* For accelerating the computation of a*G:\n-     * To harden against timing attacks, use the following mechanism:\n-     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n-     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n-     *   * U_i = U * 2^i (for i=0..62)\n-     *   * U_i = U * (1-2^63) (for i=63)\n-     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n-     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n-     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n-     * None of the resulting prec group elements have a known scalar, and neither do any of\n-     * the intermediate sums while computing a*G.\n-     */\n-    secp256k1_ge_storage_t prec[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n-} secp256k1_ecmult_gen_consts_t;\n-\n-static const secp256k1_ecmult_gen_consts_t *secp256k1_ecmult_gen_consts = NULL;\n+static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context_t *ctx) {\n+    ctx->prec = NULL;\n+}\n \n-static void secp256k1_ecmult_gen_start(void) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context_t *ctx) {\n     secp256k1_ge_t prec[1024];\n     secp256k1_gej_t gj;\n     secp256k1_gej_t nums_gej;\n-    secp256k1_ecmult_gen_consts_t *ret;\n     int i, j;\n-    if (secp256k1_ecmult_gen_consts != NULL)\n+\n+    if (ctx->prec != NULL) {\n         return;\n+    }\n \n-    /* Allocate the precomputation table. */\n-    ret = (secp256k1_ecmult_gen_consts_t*)checked_malloc(sizeof(secp256k1_ecmult_gen_consts_t));\n+    ctx->prec = (secp256k1_ge_storage_t (*)[64][16])checked_malloc(sizeof(*ctx->prec));\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -85,42 +72,113 @@ static void secp256k1_ecmult_gen_start(void) {\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {\n-            secp256k1_ge_to_storage(&ret->prec[j][i], &prec[j*16 + i]);\n+            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*16 + i]);\n         }\n     }\n+    secp256k1_ecmult_gen_blind(ctx, NULL);\n+}\n \n-    /* Set the global pointer to the precomputation table. */\n-    secp256k1_ecmult_gen_consts = ret;\n+static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context_t* ctx) {\n+    return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_stop(void) {\n-    secp256k1_ecmult_gen_consts_t *c;\n-    if (secp256k1_ecmult_gen_consts == NULL)\n-        return;\n+static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context_t *dst,\n+                                               const secp256k1_ecmult_gen_context_t *src) {\n+    if (src->prec == NULL) {\n+        dst->prec = NULL;\n+    } else {\n+        dst->prec = (secp256k1_ge_storage_t (*)[64][16])checked_malloc(sizeof(*dst->prec));\n+        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+        dst->initial = src->initial;\n+        dst->blind = src->blind;\n+    }\n+}\n \n-    c = (secp256k1_ecmult_gen_consts_t*)secp256k1_ecmult_gen_consts;\n-    secp256k1_ecmult_gen_consts = NULL;\n-    free(c);\n+static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context_t *ctx) {\n+    free(ctx->prec);\n+    secp256k1_scalar_clear(&ctx->blind);\n+    secp256k1_gej_clear(&ctx->initial);\n+    ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *gn) {\n-    const secp256k1_ecmult_gen_consts_t *c = secp256k1_ecmult_gen_consts;\n+static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context_t *ctx, secp256k1_gej_t *r, const secp256k1_scalar_t *gn) {\n     secp256k1_ge_t add;\n     secp256k1_ge_storage_t adds;\n+    secp256k1_scalar_t gnb;\n     int bits;\n     int i, j;\n-    secp256k1_gej_set_infinity(r);\n+    memset(&adds, 0, sizeof(adds));\n+    *r = ctx->initial;\n+    /* Blind scalar/point multiplication by computing (n-b)G + bG instead of nG. */\n+    secp256k1_scalar_add(&gnb, gn, &ctx->blind);\n     add.infinity = 0;\n     for (j = 0; j < 64; j++) {\n-        bits = secp256k1_scalar_get_bits(gn, j * 4, 4);\n+        bits = secp256k1_scalar_get_bits(&gnb, j * 4, 4);\n         for (i = 0; i < 16; i++) {\n-            secp256k1_ge_storage_cmov(&adds, &c->prec[j][i], i == bits);\n+            /** This uses a conditional move to avoid any secret data in array indexes.\n+             *   _Any_ use of secret indexes has been demonstrated to result in timing\n+             *   sidechannels, even when the cache-line access patterns are uniform.\n+             *  See also:\n+             *   \"A word of warning\", CHES 2013 Rump Session, by Daniel J. Bernstein and Peter Schwabe\n+             *    (https://cryptojedi.org/peter/data/chesrump-20130822.pdf) and\n+             *   \"Cache Attacks and Countermeasures: the Case of AES\", RSA 2006,\n+             *    by Dag Arne Osvik, Adi Shamir, and Eran Tromer\n+             *    (http://www.tau.ac.il/~tromer/papers/cache.pdf)\n+             */\n+            secp256k1_ge_storage_cmov(&adds, &(*ctx->prec)[j][i], i == bits);\n         }\n         secp256k1_ge_from_storage(&add, &adds);\n         secp256k1_gej_add_ge(r, r, &add);\n     }\n     bits = 0;\n     secp256k1_ge_clear(&add);\n+    secp256k1_scalar_clear(&gnb);\n+}\n+\n+/* Setup blinding values for secp256k1_ecmult_gen. */\n+static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context_t *ctx, const unsigned char *seed32) {\n+    secp256k1_scalar_t b;\n+    secp256k1_gej_t gb;\n+    secp256k1_fe_t s;\n+    unsigned char nonce32[32];\n+    secp256k1_rfc6979_hmac_sha256_t rng;\n+    int retry;\n+    if (!seed32) {\n+        /* When seed is NULL, reset the initial point and blinding value. */\n+        secp256k1_gej_set_ge(&ctx->initial, &secp256k1_ge_const_g);\n+        secp256k1_gej_neg(&ctx->initial, &ctx->initial);\n+        secp256k1_scalar_set_int(&ctx->blind, 1);\n+    }\n+    /* The prior blinding value (if not reset) is chained forward by including it in the hash. */\n+    secp256k1_scalar_get_b32(nonce32, &ctx->blind);\n+    /** Using a CSPRNG allows a failure free interface, avoids needing large amounts of random data,\n+     *   and guards against weak or adversarial seeds.  This is a simpler and safer interface than\n+     *   asking the caller for blinding values directly and expecting them to retry on failure.\n+     */\n+    secp256k1_rfc6979_hmac_sha256_initialize(&rng, seed32 ? seed32 : nonce32, 32, nonce32, 32, NULL, 0);\n+    /* Retry for out of range results to achieve uniformity. */\n+    do {\n+        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+        retry = !secp256k1_fe_set_b32(&s, nonce32);\n+        retry |= secp256k1_fe_is_zero(&s);\n+    } while (retry);\n+    /* Randomize the projection to defend against multiplier sidechannels. */\n+    secp256k1_gej_rescale(&ctx->initial, &s);\n+    secp256k1_fe_clear(&s);\n+    do {\n+        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+        secp256k1_scalar_set_b32(&b, nonce32, &retry);\n+        /* A blinding value of 0 works, but would undermine the projection hardening. */\n+        retry |= secp256k1_scalar_is_zero(&b);\n+    } while (retry);\n+    secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n+    memset(nonce32, 0, 32);\n+    secp256k1_ecmult_gen(ctx, &gb, &b);\n+    secp256k1_scalar_negate(&b, &b);\n+    ctx->blind = b;\n+    ctx->initial = gb;\n+    secp256k1_scalar_clear(&b);\n+    secp256k1_gej_clear(&gb);\n }\n \n #endif"
      },
      {
        "sha": "1b2856f83df45ca30f92a2cdb606cf903f725380",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 71,
        "deletions": 42,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -41,16 +41,17 @@ static void secp256k1_ecmult_table_precomp_gej_var(secp256k1_gej_t *pre, const s\n     int i;\n     pre[0] = *a;\n     secp256k1_gej_double_var(&d, &pre[0]);\n-    for (i = 1; i < (1 << (w-2)); i++)\n+    for (i = 1; i < (1 << (w-2)); i++) {\n         secp256k1_gej_add_var(&pre[i], &d, &pre[i-1]);\n+    }\n }\n \n static void secp256k1_ecmult_table_precomp_ge_storage_var(secp256k1_ge_storage_t *pre, const secp256k1_gej_t *a, int w) {\n     secp256k1_gej_t d;\n     int i;\n     const int table_size = 1 << (w-2);\n-    secp256k1_gej_t *prej = checked_malloc(sizeof(secp256k1_gej_t) * table_size);\n-    secp256k1_ge_t *prea = checked_malloc(sizeof(secp256k1_ge_t) * table_size);\n+    secp256k1_gej_t *prej = (secp256k1_gej_t *)checked_malloc(sizeof(secp256k1_gej_t) * table_size);\n+    secp256k1_ge_t *prea = (secp256k1_ge_t *)checked_malloc(sizeof(secp256k1_ge_t) * table_size);\n     prej[0] = *a;\n     secp256k1_gej_double_var(&d, a);\n     for (i = 1; i < table_size; i++) {\n@@ -73,73 +74,93 @@ static void secp256k1_ecmult_table_precomp_ge_storage_var(secp256k1_ge_storage_t\n     VERIFY_CHECK(((n) & 1) == 1); \\\n     VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n     VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n-    if ((n) > 0) \\\n+    if ((n) > 0) { \\\n         *(r) = (pre)[((n)-1)/2]; \\\n-    else \\\n+    } else { \\\n         secp256k1_gej_neg((r), &(pre)[(-(n)-1)/2]); \\\n+    } \\\n } while(0)\n #define ECMULT_TABLE_GET_GE_STORAGE(r,pre,n,w) do { \\\n     VERIFY_CHECK(((n) & 1) == 1); \\\n     VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n     VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n-    if ((n) > 0) \\\n+    if ((n) > 0) { \\\n         secp256k1_ge_from_storage((r), &(pre)[((n)-1)/2]); \\\n-    else {\\\n+    } else { \\\n         secp256k1_ge_from_storage((r), &(pre)[(-(n)-1)/2]); \\\n         secp256k1_ge_neg((r), (r)); \\\n     } \\\n } while(0)\n \n-typedef struct {\n-    /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_storage_t pre_g[ECMULT_TABLE_SIZE(WINDOW_G)];    /* odd multiples of the generator */\n+static void secp256k1_ecmult_context_init(secp256k1_ecmult_context_t *ctx) {\n+    ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n-    secp256k1_ge_storage_t pre_g_128[ECMULT_TABLE_SIZE(WINDOW_G)]; /* odd multiples of 2^128*generator */\n+    ctx->pre_g_128 = NULL;\n #endif\n-} secp256k1_ecmult_consts_t;\n-\n-static const secp256k1_ecmult_consts_t *secp256k1_ecmult_consts = NULL;\n+}\n \n-static void secp256k1_ecmult_start(void) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context_t *ctx) {\n     secp256k1_gej_t gj;\n-    secp256k1_ecmult_consts_t *ret;\n-    if (secp256k1_ecmult_consts != NULL)\n-        return;\n \n-    /* Allocate the precomputation table. */\n-    ret = (secp256k1_ecmult_consts_t*)checked_malloc(sizeof(secp256k1_ecmult_consts_t));\n+    if (ctx->pre_g != NULL) {\n+        return;\n+    }\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n+    ctx->pre_g = (secp256k1_ge_storage_t (*)[])checked_malloc(sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n \n     /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_table_precomp_ge_storage_var(ret->pre_g, &gj, WINDOW_G);\n+    secp256k1_ecmult_table_precomp_ge_storage_var(*ctx->pre_g, &gj, WINDOW_G);\n \n #ifdef USE_ENDOMORPHISM\n     {\n         secp256k1_gej_t g_128j;\n         int i;\n+\n+        ctx->pre_g_128 = (secp256k1_ge_storage_t (*)[])checked_malloc(sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+\n         /* calculate 2^128*generator */\n         g_128j = gj;\n-        for (i = 0; i < 128; i++)\n+        for (i = 0; i < 128; i++) {\n             secp256k1_gej_double_var(&g_128j, &g_128j);\n-        secp256k1_ecmult_table_precomp_ge_storage_var(ret->pre_g_128, &g_128j, WINDOW_G);\n+        }\n+        secp256k1_ecmult_table_precomp_ge_storage_var(*ctx->pre_g_128, &g_128j, WINDOW_G);\n     }\n #endif\n+}\n \n-    /* Set the global pointer to the precomputation table. */\n-    secp256k1_ecmult_consts = ret;\n+static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context_t *dst,\n+                                           const secp256k1_ecmult_context_t *src) {\n+    if (src->pre_g == NULL) {\n+        dst->pre_g = NULL;\n+    } else {\n+        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n+        dst->pre_g = (secp256k1_ge_storage_t (*)[])checked_malloc(size);\n+        memcpy(dst->pre_g, src->pre_g, size);\n+    }\n+#ifdef USE_ENDOMORPHISM\n+    if (src->pre_g_128 == NULL) {\n+        dst->pre_g_128 = NULL;\n+    } else {\n+        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n+        dst->pre_g_128 = (secp256k1_ge_storage_t (*)[])checked_malloc(size);\n+        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    }\n+#endif\n }\n \n-static void secp256k1_ecmult_stop(void) {\n-    secp256k1_ecmult_consts_t *c;\n-    if (secp256k1_ecmult_consts == NULL)\n-        return;\n+static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context_t *ctx) {\n+    return ctx->pre_g != NULL;\n+}\n \n-    c = (secp256k1_ecmult_consts_t*)secp256k1_ecmult_consts;\n-    secp256k1_ecmult_consts = NULL;\n-    free(c);\n+static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context_t *ctx) {\n+    free(ctx->pre_g);\n+#ifdef USE_ENDOMORPHISM\n+    free(ctx->pre_g_128);\n+#endif\n+    secp256k1_ecmult_context_init(ctx);\n }\n \n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n@@ -186,11 +207,10 @@ static int secp256k1_ecmult_wnaf(int *wnaf, const secp256k1_scalar_t *a, int w)\n     return set_bits;\n }\n \n-static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng) {\n+static void secp256k1_ecmult(const secp256k1_ecmult_context_t *ctx, secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_scalar_t *na, const secp256k1_scalar_t *ng) {\n     secp256k1_gej_t tmpj;\n     secp256k1_gej_t pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge_t tmpa;\n-    const secp256k1_ecmult_consts_t *c = secp256k1_ecmult_consts;\n #ifdef USE_ENDOMORPHISM\n     secp256k1_gej_t pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_scalar_t na_1, na_lam;\n@@ -223,7 +243,9 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n     VERIFY_CHECK(bits_na_1 <= 130);\n     VERIFY_CHECK(bits_na_lam <= 130);\n     bits = bits_na_1;\n-    if (bits_na_lam > bits) bits = bits_na_lam;\n+    if (bits_na_lam > bits) {\n+        bits = bits_na_lam;\n+    }\n #else\n     /* build wnaf representation for na. */\n     bits_na     = secp256k1_ecmult_wnaf(wnaf_na,     na,      WINDOW_A);\n@@ -234,20 +256,27 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n     secp256k1_ecmult_table_precomp_gej_var(pre_a, a, WINDOW_A);\n \n #ifdef USE_ENDOMORPHISM\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++)\n+    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n         secp256k1_gej_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+    }\n \n     /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */\n     secp256k1_scalar_split_128(&ng_1, &ng_128, ng);\n \n     /* Build wnaf representation for ng_1 and ng_128 */\n     bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   &ng_1,   WINDOW_G);\n     bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, &ng_128, WINDOW_G);\n-    if (bits_ng_1 > bits) bits = bits_ng_1;\n-    if (bits_ng_128 > bits) bits = bits_ng_128;\n+    if (bits_ng_1 > bits) {\n+        bits = bits_ng_1;\n+    }\n+    if (bits_ng_128 > bits) {\n+        bits = bits_ng_128;\n+    }\n #else\n     bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     ng,      WINDOW_G);\n-    if (bits_ng > bits) bits = bits_ng;\n+    if (bits_ng > bits) {\n+        bits = bits_ng;\n+    }\n #endif\n \n     secp256k1_gej_set_infinity(r);\n@@ -265,11 +294,11 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n             secp256k1_gej_add_var(r, r, &tmpj);\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, c->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, c->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n #else\n@@ -278,7 +307,7 @@ static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const\n             secp256k1_gej_add_var(r, r, &tmpj);\n         }\n         if (i < bits_ng && (n = wnaf_ng[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, c->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n             secp256k1_gej_add_ge_var(r, r, &tmpa);\n         }\n #endif"
      },
      {
        "sha": "41b280892d93d57aad22bbfd7eae7b945e9d4570",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -113,4 +113,7 @@ static void secp256k1_fe_from_storage(secp256k1_fe_t *r, const secp256k1_fe_stor\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n static void secp256k1_fe_storage_cmov(secp256k1_fe_storage_t *r, const secp256k1_fe_storage_t *a, int flag);\n \n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+static void secp256k1_fe_cmov(secp256k1_fe_t *r, const secp256k1_fe_t *a, int flag);\n+\n #endif"
      },
      {
        "sha": "871b91f9123170436392fe619674a97c53637e58",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 3,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -236,8 +236,9 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe_t *r) {\n     z1 = z0 ^ 0x3D0UL;\n \n     /* Fast return path should catch the majority of cases */\n-    if ((z0 != 0UL) & (z1 != 0x3FFFFFFUL))\n+    if ((z0 != 0UL) & (z1 != 0x3FFFFFFUL)) {\n         return 0;\n+    }\n \n     t1 = r->n[1];\n     t2 = r->n[2];\n@@ -315,8 +316,12 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe_t *a, const secp256k1_fe_t *b\n     secp256k1_fe_verify(b);\n #endif\n     for (i = 9; i >= 0; i--) {\n-        if (a->n[i] > b->n[i]) return 1;\n-        if (a->n[i] < b->n[i]) return -1;\n+        if (a->n[i] > b->n[i]) {\n+            return 1;\n+        }\n+        if (a->n[i] < b->n[i]) {\n+            return -1;\n+        }\n     }\n     return 0;\n }\n@@ -1063,6 +1068,26 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #endif\n }\n \n+static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe_t *r, const secp256k1_fe_t *a, int flag) {\n+    uint32_t mask0, mask1;\n+    mask0 = flag + ~((uint32_t)0);\n+    mask1 = ~mask0;\n+    r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n+    r->n[1] = (r->n[1] & mask0) | (a->n[1] & mask1);\n+    r->n[2] = (r->n[2] & mask0) | (a->n[2] & mask1);\n+    r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);\n+    r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);\n+    r->n[5] = (r->n[5] & mask0) | (a->n[5] & mask1);\n+    r->n[6] = (r->n[6] & mask0) | (a->n[6] & mask1);\n+    r->n[7] = (r->n[7] & mask0) | (a->n[7] & mask1);\n+    r->n[8] = (r->n[8] & mask0) | (a->n[8] & mask1);\n+    r->n[9] = (r->n[9] & mask0) | (a->n[9] & mask1);\n+#ifdef VERIFY\n+    r->magnitude = (r->magnitude & mask0) | (a->magnitude & mask1);\n+    r->normalized = (r->normalized & mask0) | (a->normalized & mask1);\n+#endif\n+}\n+\n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage_t *r, const secp256k1_fe_storage_t *a, int flag) {\n     uint32_t mask0, mask1;\n     mask0 = flag + ~((uint32_t)0);"
      },
      {
        "sha": "bda4c3dfc2de0b53a60f3303ac6059942e8c9006",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -209,8 +209,9 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe_t *r) {\n     z1 = z0 ^ 0x1000003D0ULL;\n \n     /* Fast return path should catch the majority of cases */\n-    if ((z0 != 0ULL) & (z1 != 0xFFFFFFFFFFFFFULL))\n+    if ((z0 != 0ULL) & (z1 != 0xFFFFFFFFFFFFFULL)) {\n         return 0;\n+    }\n \n     t1 = r->n[1];\n     t2 = r->n[2];\n@@ -277,8 +278,12 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe_t *a, const secp256k1_fe_t *b\n     secp256k1_fe_verify(b);\n #endif\n     for (i = 4; i >= 0; i--) {\n-        if (a->n[i] > b->n[i]) return 1;\n-        if (a->n[i] < b->n[i]) return -1;\n+        if (a->n[i] > b->n[i]) {\n+            return 1;\n+        }\n+        if (a->n[i] < b->n[i]) {\n+            return -1;\n+        }\n     }\n     return 0;\n }\n@@ -399,6 +404,21 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #endif\n }\n \n+static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe_t *r, const secp256k1_fe_t *a, int flag) {\n+    uint64_t mask0, mask1;\n+    mask0 = flag + ~((uint64_t)0);\n+    mask1 = ~mask0;\n+    r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n+    r->n[1] = (r->n[1] & mask0) | (a->n[1] & mask1);\n+    r->n[2] = (r->n[2] & mask0) | (a->n[2] & mask1);\n+    r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);\n+    r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);\n+#ifdef VERIFY\n+    r->magnitude = (r->magnitude & mask0) | (a->magnitude & mask1);\n+    r->normalized = (r->normalized & mask0) | (a->normalized & mask1);\n+#endif\n+}\n+\n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage_t *r, const secp256k1_fe_storage_t *a, int flag) {\n     uint64_t mask0, mask1;\n     mask0 = flag + ~((uint64_t)0);"
      },
      {
        "sha": "e6ec11e8f2c48c88863b61cb34dd6d778aa2da03",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 74,
        "deletions": 25,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -44,47 +44,69 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_mul(&x3, &x3, a);\n \n     x6 = x3;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x6, &x6);\n+    }\n     secp256k1_fe_mul(&x6, &x6, &x3);\n \n     x9 = x6;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x9, &x9);\n+    }\n     secp256k1_fe_mul(&x9, &x9, &x3);\n \n     x11 = x9;\n-    for (j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    for (j=0; j<2; j++) {\n+        secp256k1_fe_sqr(&x11, &x11);\n+    }\n     secp256k1_fe_mul(&x11, &x11, &x2);\n \n     x22 = x11;\n-    for (j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    for (j=0; j<11; j++) {\n+        secp256k1_fe_sqr(&x22, &x22);\n+    }\n     secp256k1_fe_mul(&x22, &x22, &x11);\n \n     x44 = x22;\n-    for (j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    for (j=0; j<22; j++) {\n+        secp256k1_fe_sqr(&x44, &x44);\n+    }\n     secp256k1_fe_mul(&x44, &x44, &x22);\n \n     x88 = x44;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x88, &x88);\n+    }\n     secp256k1_fe_mul(&x88, &x88, &x44);\n \n     x176 = x88;\n-    for (j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    for (j=0; j<88; j++) {\n+        secp256k1_fe_sqr(&x176, &x176);\n+    }\n     secp256k1_fe_mul(&x176, &x176, &x88);\n \n     x220 = x176;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x220, &x220);\n+    }\n     secp256k1_fe_mul(&x220, &x220, &x44);\n \n     x223 = x220;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x223, &x223);\n+    }\n     secp256k1_fe_mul(&x223, &x223, &x3);\n \n     /* The final result is then assembled using a sliding window over the blocks. */\n \n     t1 = x223;\n-    for (j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<23; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x22);\n-    for (j=0; j<6; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<6; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x2);\n     secp256k1_fe_sqr(&t1, &t1);\n     secp256k1_fe_sqr(r, &t1);\n@@ -111,51 +133,77 @@ static void secp256k1_fe_inv(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_mul(&x3, &x3, a);\n \n     x6 = x3;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x6, &x6);\n+    }\n     secp256k1_fe_mul(&x6, &x6, &x3);\n \n     x9 = x6;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x9, &x9);\n+    }\n     secp256k1_fe_mul(&x9, &x9, &x3);\n \n     x11 = x9;\n-    for (j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    for (j=0; j<2; j++) {\n+        secp256k1_fe_sqr(&x11, &x11);\n+    }\n     secp256k1_fe_mul(&x11, &x11, &x2);\n \n     x22 = x11;\n-    for (j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    for (j=0; j<11; j++) {\n+        secp256k1_fe_sqr(&x22, &x22);\n+    }\n     secp256k1_fe_mul(&x22, &x22, &x11);\n \n     x44 = x22;\n-    for (j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    for (j=0; j<22; j++) {\n+        secp256k1_fe_sqr(&x44, &x44);\n+    }\n     secp256k1_fe_mul(&x44, &x44, &x22);\n \n     x88 = x44;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x88, &x88);\n+    }\n     secp256k1_fe_mul(&x88, &x88, &x44);\n \n     x176 = x88;\n-    for (j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    for (j=0; j<88; j++) {\n+        secp256k1_fe_sqr(&x176, &x176);\n+    }\n     secp256k1_fe_mul(&x176, &x176, &x88);\n \n     x220 = x176;\n-    for (j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    for (j=0; j<44; j++) {\n+        secp256k1_fe_sqr(&x220, &x220);\n+    }\n     secp256k1_fe_mul(&x220, &x220, &x44);\n \n     x223 = x220;\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&x223, &x223);\n+    }\n     secp256k1_fe_mul(&x223, &x223, &x3);\n \n     /* The final result is then assembled using a sliding window over the blocks. */\n \n     t1 = x223;\n-    for (j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<23; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x22);\n-    for (j=0; j<5; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<5; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, a);\n-    for (j=0; j<3; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<3; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(&t1, &t1, &x2);\n-    for (j=0; j<2; j++) secp256k1_fe_sqr(&t1, &t1);\n+    for (j=0; j<2; j++) {\n+        secp256k1_fe_sqr(&t1, &t1);\n+    }\n     secp256k1_fe_mul(r, a, &t1);\n }\n \n@@ -188,8 +236,9 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_t u;\n     size_t i;\n-    if (len < 1)\n+    if (len < 1) {\n         return;\n+    }\n \n     VERIFY_CHECK((r + len <= a) || (a + len <= r));\n "
      },
      {
        "sha": "0b08b3b9910ccaf27d111e646584238857d947f5",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -115,4 +115,7 @@ static void secp256k1_ge_from_storage(secp256k1_ge_t *r, const secp256k1_ge_stor\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n static void secp256k1_ge_storage_cmov(secp256k1_ge_storage_t *r, const secp256k1_ge_storage_t *a, int flag);\n \n+/** Rescale a jacobian point by b which must be non-zero. Constant-time. */\n+static void secp256k1_gej_rescale(secp256k1_gej_t *r, const secp256k1_fe_t *b);\n+\n #endif"
      },
      {
        "sha": "0f64576fbb5231c70f17ef6d6765949f62fabb69",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 27,
        "deletions": 14,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -77,14 +77,14 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t *r, const se\n     secp256k1_fe_t *azi;\n     size_t i;\n     size_t count = 0;\n-    az = checked_malloc(sizeof(secp256k1_fe_t) * len);\n+    az = (secp256k1_fe_t *)checked_malloc(sizeof(secp256k1_fe_t) * len);\n     for (i = 0; i < len; i++) {\n         if (!a[i].infinity) {\n             az[count++] = a[i].z;\n         }\n     }\n \n-    azi = checked_malloc(sizeof(secp256k1_fe_t) * count);\n+    azi = (secp256k1_fe_t *)checked_malloc(sizeof(secp256k1_fe_t) * count);\n     secp256k1_fe_inv_all_var(count, azi, az);\n     free(az);\n \n@@ -138,11 +138,13 @@ static int secp256k1_ge_set_xo_var(secp256k1_ge_t *r, const secp256k1_fe_t *x, i\n     r->infinity = 0;\n     secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    if (!secp256k1_fe_sqrt_var(&r->y, &c))\n+    if (!secp256k1_fe_sqrt_var(&r->y, &c)) {\n         return 0;\n+    }\n     secp256k1_fe_normalize_var(&r->y);\n-    if (secp256k1_fe_is_odd(&r->y) != odd)\n+    if (secp256k1_fe_is_odd(&r->y) != odd) {\n         secp256k1_fe_negate(&r->y, &r->y, 1);\n+    }\n     return 1;\n }\n \n@@ -176,8 +178,9 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej_t *a) {\n \n static int secp256k1_gej_is_valid_var(const secp256k1_gej_t *a) {\n     secp256k1_fe_t y2, x3, z2, z6;\n-    if (a->infinity)\n+    if (a->infinity) {\n         return 0;\n+    }\n     /** y^2 = x^3 + 7\n      *  (Y/Z^3)^2 = (X/Z^2)^3 + 7\n      *  Y^2 / Z^6 = X^3 / Z^6 + 7\n@@ -195,8 +198,9 @@ static int secp256k1_gej_is_valid_var(const secp256k1_gej_t *a) {\n \n static int secp256k1_ge_is_valid_var(const secp256k1_ge_t *a) {\n     secp256k1_fe_t y2, x3, c;\n-    if (a->infinity)\n+    if (a->infinity) {\n         return 0;\n+    }\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n@@ -321,7 +325,8 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *\n }\n \n static void secp256k1_gej_add_ge(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_ge_t *b) {\n-    /* Operations: 7 mul, 5 sqr, 5 normalize, 19 mul_int/add/negate */\n+    /* Operations: 7 mul, 5 sqr, 5 normalize, 17 mul_int/add/negate/cmov */\n+    static const secp256k1_fe_t fe_1 = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n     secp256k1_fe_t zz, u1, u2, s1, s2, z, t, m, n, q, rr;\n     int infinity;\n     VERIFY_CHECK(!b->infinity);\n@@ -383,17 +388,25 @@ static void secp256k1_gej_add_ge(secp256k1_gej_t *r, const secp256k1_gej_t *a, c\n     secp256k1_fe_mul_int(&r->y, 4 * (1 - a->infinity)); /* r->y = Y3 = 4*R*(3*Q-2*R^2)-4*M^4 (4) */\n \n     /** In case a->infinity == 1, the above code results in r->x, r->y, and r->z all equal to 0.\n-     *  Add b->x to x, b->y to y, and 1 to z in that case.\n+     *  Replace r with b->x, b->y, 1 in that case.\n      */\n-    t = b->x; secp256k1_fe_mul_int(&t, a->infinity);\n-    secp256k1_fe_add(&r->x, &t);\n-    t = b->y; secp256k1_fe_mul_int(&t, a->infinity);\n-    secp256k1_fe_add(&r->y, &t);\n-    secp256k1_fe_set_int(&t, a->infinity);\n-    secp256k1_fe_add(&r->z, &t);\n+    secp256k1_fe_cmov(&r->x, &b->x, a->infinity);\n+    secp256k1_fe_cmov(&r->y, &b->y, a->infinity);\n+    secp256k1_fe_cmov(&r->z, &fe_1, a->infinity);\n     r->infinity = infinity;\n }\n \n+static void secp256k1_gej_rescale(secp256k1_gej_t *r, const secp256k1_fe_t *s) {\n+    /* Operations: 4 mul, 1 sqr */\n+    secp256k1_fe_t zz;\n+    VERIFY_CHECK(!secp256k1_fe_is_zero(s));\n+    secp256k1_fe_sqr(&zz, s);\n+    secp256k1_fe_mul(&r->x, &r->x, &zz);                /* r->x *= s^2 */\n+    secp256k1_fe_mul(&r->y, &r->y, &zz);\n+    secp256k1_fe_mul(&r->y, &r->y, s);                  /* r->y *= s^3 */\n+    secp256k1_fe_mul(&r->z, &r->z, s);                  /* r->z *= s   */\n+}\n+\n static void secp256k1_ge_to_storage(secp256k1_ge_storage_t *r, const secp256k1_ge_t *a) {\n     secp256k1_fe_t x, y;\n     VERIFY_CHECK(!a->infinity);"
      },
      {
        "sha": "9828827bcdb2d872478b57e33a671e20ea906d2c",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -176,13 +176,15 @@ static void secp256k1_hmac_sha256_initialize(secp256k1_hmac_sha256_t *hash, cons\n     }\n \n     secp256k1_sha256_initialize(&hash->outer);\n-    for (n = 0; n < 64; n++)\n+    for (n = 0; n < 64; n++) {\n         rkey[n] ^= 0x5c;\n+    }\n     secp256k1_sha256_write(&hash->outer, rkey, 64);\n \n     secp256k1_sha256_initialize(&hash->inner);\n-    for (n = 0; n < 64; n++)\n+    for (n = 0; n < 64; n++) {\n         rkey[n] ^= 0x5c ^ 0x36;\n+    }\n     secp256k1_sha256_write(&hash->inner, rkey, 64);\n     memset(rkey, 0, 64);\n }\n@@ -205,28 +207,32 @@ static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha2\n     static const unsigned char zero[1] = {0x00};\n     static const unsigned char one[1] = {0x01};\n \n-    memset(rng->v, 0x01, 32);\n-    memset(rng->k, 0x00, 32);\n+    memset(rng->v, 0x01, 32); /* RFC6979 3.2.b. */\n+    memset(rng->k, 0x00, 32); /* RFC6979 3.2.c. */\n \n+    /* RFC6979 3.2.d. */\n     secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n     secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n     secp256k1_hmac_sha256_write(&hmac, zero, 1);\n     secp256k1_hmac_sha256_write(&hmac, key, keylen);\n     secp256k1_hmac_sha256_write(&hmac, msg, msglen);\n     if (rnd && rndlen) {\n+        /* RFC6979 3.6 \"Additional data\". */\n         secp256k1_hmac_sha256_write(&hmac, rnd, rndlen);\n     }\n     secp256k1_hmac_sha256_finalize(&hmac, rng->k);\n     secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n     secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n     secp256k1_hmac_sha256_finalize(&hmac, rng->v);\n \n+    /* RFC6979 3.2.f. */\n     secp256k1_hmac_sha256_initialize(&hmac, rng->k, 32);\n     secp256k1_hmac_sha256_write(&hmac, rng->v, 32);\n     secp256k1_hmac_sha256_write(&hmac, one, 1);\n     secp256k1_hmac_sha256_write(&hmac, key, keylen);\n     secp256k1_hmac_sha256_write(&hmac, msg, msglen);\n     if (rnd && rndlen) {\n+        /* RFC6979 3.6 \"Additional data\". */\n         secp256k1_hmac_sha256_write(&hmac, rnd, rndlen);\n     }\n     secp256k1_hmac_sha256_finalize(&hmac, rng->k);\n@@ -237,6 +243,7 @@ static void secp256k1_rfc6979_hmac_sha256_initialize(secp256k1_rfc6979_hmac_sha2\n }\n \n static void secp256k1_rfc6979_hmac_sha256_generate(secp256k1_rfc6979_hmac_sha256_t *rng, unsigned char *out, size_t outlen) {\n+    /* RFC6979 3.2.h. */\n     static const unsigned char zero[1] = {0x00};\n     if (rng->retry) {\n         secp256k1_hmac_sha256_t hmac;"
      },
      {
        "sha": "dbbc458d5ddc7d1cea67a14e1678e9dc81881bf2",
        "filename": "src/secp256k1/src/num_gmp_impl.h",
        "status": "modified",
        "additions": 36,
        "deletions": 13,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -54,7 +54,9 @@ static void secp256k1_num_set_bin(secp256k1_num_t *r, const unsigned char *a, un\n     VERIFY_CHECK(len <= NUM_LIMBS*2);\n     r->limbs = len;\n     r->neg = 0;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+        r->limbs--;\n+    }\n }\n \n static void secp256k1_num_add_abs(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n@@ -70,7 +72,9 @@ static void secp256k1_num_sub_abs(secp256k1_num_t *r, const secp256k1_num_t *a,\n     mp_limb_t c = mpn_sub(r->data, a->data, a->limbs, b->data, b->limbs);\n     VERIFY_CHECK(c == 0);\n     r->limbs = a->limbs;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+        r->limbs--;\n+    }\n }\n \n static void secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m) {\n@@ -82,7 +86,9 @@ static void secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m) {\n         mpn_tdiv_qr(t, r->data, 0, r->data, r->limbs, m->data, m->limbs);\n         memset(t, 0, sizeof(t));\n         r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+            r->limbs--;\n+        }\n     }\n \n     if (r->neg && (r->limbs > 1 || r->data[0] != 0)) {\n@@ -125,7 +131,9 @@ static void secp256k1_num_mod_inverse(secp256k1_num_t *r, const secp256k1_num_t\n     if (sn < 0) {\n         mpn_sub(r->data, m->data, m->limbs, r->data, -sn);\n         r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n+            r->limbs--;\n+        }\n     } else {\n         r->limbs = sn;\n     }\n@@ -143,15 +151,25 @@ static int secp256k1_num_is_neg(const secp256k1_num_t *a) {\n }\n \n static int secp256k1_num_cmp(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n-    if (a->limbs > b->limbs) return 1;\n-    if (a->limbs < b->limbs) return -1;\n+    if (a->limbs > b->limbs) {\n+        return 1;\n+    }\n+    if (a->limbs < b->limbs) {\n+        return -1;\n+    }\n     return mpn_cmp(a->data, b->data, a->limbs);\n }\n \n static int secp256k1_num_eq(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n-    if (a->limbs > b->limbs) return 0;\n-    if (a->limbs < b->limbs) return 0;\n-    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) return 0;\n+    if (a->limbs > b->limbs) {\n+        return 0;\n+    }\n+    if (a->limbs < b->limbs) {\n+        return 0;\n+    }\n+    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) {\n+        return 0;\n+    }\n     return mpn_cmp(a->data, b->data, a->limbs) == 0;\n }\n \n@@ -198,12 +216,15 @@ static void secp256k1_num_mul(secp256k1_num_t *r, const secp256k1_num_t *a, cons\n         r->data[0] = 0;\n         return;\n     }\n-    if (a->limbs >= b->limbs)\n+    if (a->limbs >= b->limbs) {\n         mpn_mul(tmp, a->data, a->limbs, b->data, b->limbs);\n-    else\n+    } else {\n         mpn_mul(tmp, b->data, b->limbs, a->data, a->limbs);\n+    }\n     r->limbs = a->limbs + b->limbs;\n-    if (r->limbs > 1 && tmp[r->limbs - 1]==0) r->limbs--;\n+    if (r->limbs > 1 && tmp[r->limbs - 1]==0) {\n+        r->limbs--;\n+    }\n     VERIFY_CHECK(r->limbs <= 2*NUM_LIMBS);\n     mpn_copyi(r->data, tmp, r->limbs);\n     r->neg = a->neg ^ b->neg;\n@@ -227,7 +248,9 @@ static void secp256k1_num_shift(secp256k1_num_t *r, int bits) {\n             }\n         }\n     }\n-    while (r->limbs>1 && r->data[r->limbs-1]==0) r->limbs--;\n+    while (r->limbs>1 && r->data[r->limbs-1]==0) {\n+        r->limbs--;\n+    }\n }\n \n static void secp256k1_num_negate(secp256k1_num_t *r) {"
      },
      {
        "sha": "33824983e4d529c345f4d9c0f2ae222d24777b3f",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 76,
        "deletions": 38,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -69,130 +69,168 @@ static void secp256k1_scalar_inverse(secp256k1_scalar_t *r, const secp256k1_scal\n     secp256k1_scalar_mul(&x8, &x8,  x);\n \n     secp256k1_scalar_sqr(&x15, &x8);\n-    for (i = 0; i < 6; i++)\n+    for (i = 0; i < 6; i++) {\n         secp256k1_scalar_sqr(&x15, &x15);\n+    }\n     secp256k1_scalar_mul(&x15, &x15, &x7);\n \n     secp256k1_scalar_sqr(&x30, &x15);\n-    for (i = 0; i < 14; i++)\n+    for (i = 0; i < 14; i++) {\n         secp256k1_scalar_sqr(&x30, &x30);\n+    }\n     secp256k1_scalar_mul(&x30, &x30, &x15);\n \n     secp256k1_scalar_sqr(&x60, &x30);\n-    for (i = 0; i < 29; i++)\n+    for (i = 0; i < 29; i++) {\n         secp256k1_scalar_sqr(&x60, &x60);\n+    }\n     secp256k1_scalar_mul(&x60, &x60, &x30);\n \n     secp256k1_scalar_sqr(&x120, &x60);\n-    for (i = 0; i < 59; i++)\n+    for (i = 0; i < 59; i++) {\n         secp256k1_scalar_sqr(&x120, &x120);\n+    }\n     secp256k1_scalar_mul(&x120, &x120, &x60);\n \n     secp256k1_scalar_sqr(&x127, &x120);\n-    for (i = 0; i < 6; i++)\n+    for (i = 0; i < 6; i++) {\n         secp256k1_scalar_sqr(&x127, &x127);\n+    }\n     secp256k1_scalar_mul(&x127, &x127, &x7);\n \n     /* Then accumulate the final result (t starts at x127). */\n     t = &x127;\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 3; i++) /* 0 */\n+    for (i = 0; i < 3; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 5; i++) /* 00 */\n+    for (i = 0; i < 5; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) /* 00 */\n+    for (i = 0; i < 4; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) /* 0 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) /* 000 */\n+    for (i = 0; i < 4; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 10; i++) /* 0000000 */\n+    for (i = 0; i < 10; i++) { /* 0000000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 9; i++) /* 0 */\n+    for (i = 0; i < 9; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) /* 0 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) /* 000 */\n+    for (i = 0; i < 5; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) /* 00 */\n+    for (i = 0; i < 4; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) /* 0 */\n+    for (i = 0; i < 2; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) /* 000000 */\n+    for (i = 0; i < 8; i++) { /* 000000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) /* 0 */\n+    for (i = 0; i < 3; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) /* 00 */\n+    for (i = 0; i < 3; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 6; i++) /* 00000 */\n+    for (i = 0; i < 6; i++) { /* 00000 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) /* 00 */\n+    for (i = 0; i < 8; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n+    }\n     secp256k1_scalar_mul(r, t, &x6); /* 111111 */\n }\n "
      },
      {
        "sha": "d6192dc4ed6bb876bc1c82474528d055592dab14",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 86,
        "deletions": 39,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013-2015 Pieter Wuille                              *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -19,26 +19,48 @@\n #include \"eckey_impl.h\"\n #include \"hash_impl.h\"\n \n-void secp256k1_start(unsigned int flags) {\n-    if (flags & SECP256K1_START_SIGN) {\n-        secp256k1_ecmult_gen_start();\n+struct secp256k1_context_struct {\n+    secp256k1_ecmult_context_t ecmult_ctx;\n+    secp256k1_ecmult_gen_context_t ecmult_gen_ctx;\n+};\n+\n+secp256k1_context_t* secp256k1_context_create(int flags) {\n+    secp256k1_context_t* ret = (secp256k1_context_t*)checked_malloc(sizeof(secp256k1_context_t));\n+\n+    secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n+    secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n+\n+    if (flags & SECP256K1_CONTEXT_SIGN) {\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx);\n     }\n-    if (flags & SECP256K1_START_VERIFY) {\n-        secp256k1_ecmult_start();\n+    if (flags & SECP256K1_CONTEXT_VERIFY) {\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx);\n     }\n+\n+    return ret;\n }\n \n-void secp256k1_stop(void) {\n-    secp256k1_ecmult_stop();\n-    secp256k1_ecmult_gen_stop();\n+secp256k1_context_t* secp256k1_context_clone(const secp256k1_context_t* ctx) {\n+    secp256k1_context_t* ret = (secp256k1_context_t*)checked_malloc(sizeof(secp256k1_context_t));\n+    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n+    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    return ret;\n }\n \n-int secp256k1_ecdsa_verify(const unsigned char *msg32, const unsigned char *sig, int siglen, const unsigned char *pubkey, int pubkeylen) {\n+void secp256k1_context_destroy(secp256k1_context_t* ctx) {\n+    secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n+    secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+\n+    free(ctx);\n+}\n+\n+int secp256k1_ecdsa_verify(const secp256k1_context_t* ctx, const unsigned char *msg32, const unsigned char *sig, int siglen, const unsigned char *pubkey, int pubkeylen) {\n     secp256k1_ge_t q;\n     secp256k1_ecdsa_sig_t s;\n     secp256k1_scalar_t m;\n     int ret = -3;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(sig != NULL);\n     DEBUG_CHECK(pubkey != NULL);\n@@ -47,7 +69,7 @@ int secp256k1_ecdsa_verify(const unsigned char *msg32, const unsigned char *sig,\n \n     if (secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen)) {\n         if (secp256k1_ecdsa_sig_parse(&s, sig, siglen)) {\n-            if (secp256k1_ecdsa_sig_verify(&s, &q, &m)) {\n+            if (secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &s, &q, &m)) {\n                 /* success is 1, all other values are fail */\n                 ret = 1;\n             } else {\n@@ -66,7 +88,7 @@ int secp256k1_ecdsa_verify(const unsigned char *msg32, const unsigned char *sig,\n static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, unsigned int counter, const void *data) {\n    secp256k1_rfc6979_hmac_sha256_t rng;\n    unsigned int i;\n-   secp256k1_rfc6979_hmac_sha256_initialize(&rng, key32, 32, msg32, 32, data, data != NULL ? 32 : 0);\n+   secp256k1_rfc6979_hmac_sha256_initialize(&rng, key32, 32, msg32, 32, (const unsigned char*)data, data != NULL ? 32 : 0);\n    for (i = 0; i <= counter; i++) {\n        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n    }\n@@ -77,13 +99,14 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n const secp256k1_nonce_function_t secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979;\n const secp256k1_nonce_function_t secp256k1_nonce_function_default = nonce_function_rfc6979;\n \n-int secp256k1_ecdsa_sign(const unsigned char *msg32, unsigned char *signature, int *signaturelen, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata) {\n+int secp256k1_ecdsa_sign(const secp256k1_context_t* ctx, const unsigned char *msg32, unsigned char *signature, int *signaturelen, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata) {\n     secp256k1_ecdsa_sig_t sig;\n     secp256k1_scalar_t sec, non, msg;\n     int ret = 0;\n     int overflow = 0;\n     unsigned int count = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(signature != NULL);\n     DEBUG_CHECK(signaturelen != NULL);\n@@ -105,7 +128,7 @@ int secp256k1_ecdsa_sign(const unsigned char *msg32, unsigned char *signature, i\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n             memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-                if (secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, NULL)) {\n+                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &sig, &sec, &msg, &non, NULL)) {\n                     break;\n                 }\n             }\n@@ -124,13 +147,14 @@ int secp256k1_ecdsa_sign(const unsigned char *msg32, unsigned char *signature, i\n     return ret;\n }\n \n-int secp256k1_ecdsa_sign_compact(const unsigned char *msg32, unsigned char *sig64, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata, int *recid) {\n+int secp256k1_ecdsa_sign_compact(const secp256k1_context_t* ctx, const unsigned char *msg32, unsigned char *sig64, const unsigned char *seckey, secp256k1_nonce_function_t noncefp, const void* noncedata, int *recid) {\n     secp256k1_ecdsa_sig_t sig;\n     secp256k1_scalar_t sec, non, msg;\n     int ret = 0;\n     int overflow = 0;\n     unsigned int count = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(sig64 != NULL);\n     DEBUG_CHECK(seckey != NULL);\n@@ -151,7 +175,7 @@ int secp256k1_ecdsa_sign_compact(const unsigned char *msg32, unsigned char *sig6\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n             memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-                if (secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, recid)) {\n+                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &sig, &sec, &msg, &non, recid)) {\n                     break;\n                 }\n             }\n@@ -171,13 +195,14 @@ int secp256k1_ecdsa_sign_compact(const unsigned char *msg32, unsigned char *sig6\n     return ret;\n }\n \n-int secp256k1_ecdsa_recover_compact(const unsigned char *msg32, const unsigned char *sig64, unsigned char *pubkey, int *pubkeylen, int compressed, int recid) {\n+int secp256k1_ecdsa_recover_compact(const secp256k1_context_t* ctx, const unsigned char *msg32, const unsigned char *sig64, unsigned char *pubkey, int *pubkeylen, int compressed, int recid) {\n     secp256k1_ge_t q;\n     secp256k1_ecdsa_sig_t sig;\n     secp256k1_scalar_t m;\n     int ret = 0;\n     int overflow = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(msg32 != NULL);\n     DEBUG_CHECK(sig64 != NULL);\n     DEBUG_CHECK(pubkey != NULL);\n@@ -190,47 +215,52 @@ int secp256k1_ecdsa_recover_compact(const unsigned char *msg32, const unsigned c\n         if (!overflow) {\n             secp256k1_scalar_set_b32(&m, msg32, NULL);\n \n-            if (secp256k1_ecdsa_sig_recover(&sig, &q, &m, recid)) {\n+            if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &sig, &q, &m, recid)) {\n                 ret = secp256k1_eckey_pubkey_serialize(&q, pubkey, pubkeylen, compressed);\n             }\n         }\n     }\n     return ret;\n }\n \n-int secp256k1_ec_seckey_verify(const unsigned char *seckey) {\n+int secp256k1_ec_seckey_verify(const secp256k1_context_t* ctx, const unsigned char *seckey) {\n     secp256k1_scalar_t sec;\n     int ret;\n     int overflow;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(seckey != NULL);\n+    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !secp256k1_scalar_is_zero(&sec) && !overflow;\n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen) {\n+int secp256k1_ec_pubkey_verify(const secp256k1_context_t* ctx, const unsigned char *pubkey, int pubkeylen) {\n     secp256k1_ge_t q;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(pubkey != NULL);\n+    (void)ctx;\n \n     return secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen);\n }\n \n-int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed) {\n+int secp256k1_ec_pubkey_create(const secp256k1_context_t* ctx, unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed) {\n     secp256k1_gej_t pj;\n     secp256k1_ge_t p;\n     secp256k1_scalar_t sec;\n     int overflow;\n     int ret = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(pubkeylen != NULL);\n     DEBUG_CHECK(seckey != NULL);\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     if (!overflow) {\n-        secp256k1_ecmult_gen(&pj, &sec);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n         secp256k1_scalar_clear(&sec);\n         secp256k1_ge_set_gej(&p, &pj);\n         ret = secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, compressed);\n@@ -241,25 +271,28 @@ int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsi\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_decompress(unsigned char *pubkey, int *pubkeylen) {\n+int secp256k1_ec_pubkey_decompress(const secp256k1_context_t* ctx, unsigned char *pubkey, int *pubkeylen) {\n     secp256k1_ge_t p;\n     int ret = 0;\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(pubkeylen != NULL);\n+    (void)ctx;\n \n     if (secp256k1_eckey_pubkey_parse(&p, pubkey, *pubkeylen)) {\n         ret = secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, 0);\n     }\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_privkey_tweak_add(const secp256k1_context_t* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar_t term;\n     secp256k1_scalar_t sec;\n     int ret = 0;\n     int overflow = 0;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n+    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -274,20 +307,21 @@ int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *t\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_add(const secp256k1_context_t* ctx, unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n     secp256k1_ge_t p;\n     secp256k1_scalar_t term;\n     int ret = 0;\n     int overflow = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     if (!overflow) {\n         ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n         if (ret) {\n-            ret = secp256k1_eckey_pubkey_tweak_add(&p, &term);\n+            ret = secp256k1_eckey_pubkey_tweak_add(&ctx->ecmult_ctx, &p, &term);\n         }\n         if (ret) {\n             int oldlen = pubkeylen;\n@@ -299,13 +333,15 @@ int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const un\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_privkey_tweak_mul(const secp256k1_context_t* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar_t factor;\n     secp256k1_scalar_t sec;\n     int ret = 0;\n     int overflow = 0;\n+    DEBUG_CHECK(ctx != NULL);\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n+    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -319,20 +355,21 @@ int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *t\n     return ret;\n }\n \n-int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context_t* ctx, unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n     secp256k1_ge_t p;\n     secp256k1_scalar_t factor;\n     int ret = 0;\n     int overflow = 0;\n-    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     DEBUG_CHECK(pubkey != NULL);\n     DEBUG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     if (!overflow) {\n         ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n         if (ret) {\n-            ret = secp256k1_eckey_pubkey_tweak_mul(&p, &factor);\n+            ret = secp256k1_eckey_pubkey_tweak_mul(&ctx->ecmult_ctx, &p, &factor);\n         }\n         if (ret) {\n             int oldlen = pubkeylen;\n@@ -344,24 +381,27 @@ int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const un\n     return ret;\n }\n \n-int secp256k1_ec_privkey_export(const unsigned char *seckey, unsigned char *privkey, int *privkeylen, int compressed) {\n+int secp256k1_ec_privkey_export(const secp256k1_context_t* ctx, const unsigned char *seckey, unsigned char *privkey, int *privkeylen, int compressed) {\n     secp256k1_scalar_t key;\n     int ret = 0;\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(privkey != NULL);\n     DEBUG_CHECK(privkeylen != NULL);\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n \n     secp256k1_scalar_set_b32(&key, seckey, NULL);\n-    ret = secp256k1_eckey_privkey_serialize(privkey, privkeylen, &key, compressed);\n+    ret = secp256k1_eckey_privkey_serialize(&ctx->ecmult_gen_ctx, privkey, privkeylen, &key, compressed);\n     secp256k1_scalar_clear(&key);\n     return ret;\n }\n \n-int secp256k1_ec_privkey_import(unsigned char *seckey, const unsigned char *privkey, int privkeylen) {\n+int secp256k1_ec_privkey_import(const secp256k1_context_t* ctx, unsigned char *seckey, const unsigned char *privkey, int privkeylen) {\n     secp256k1_scalar_t key;\n     int ret = 0;\n     DEBUG_CHECK(seckey != NULL);\n     DEBUG_CHECK(privkey != NULL);\n+    (void)ctx;\n \n     ret = secp256k1_eckey_privkey_parse(&key, privkey, privkeylen);\n     if (ret) {\n@@ -370,3 +410,10 @@ int secp256k1_ec_privkey_import(unsigned char *seckey, const unsigned char *priv\n     secp256k1_scalar_clear(&key);\n     return ret;\n }\n+\n+int secp256k1_context_randomize(secp256k1_context_t* ctx, const unsigned char *seed32) {\n+    DEBUG_CHECK(ctx != NULL);\n+    DEBUG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    return 1;\n+}"
      },
      {
        "sha": "d0e05057f296860e376ab75310c926303f3903c6",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 328,
        "deletions": 125,
        "changes": 453,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dda253190e6f5ac6728e88fefdf6e8eaf41419c/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "patch": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell      *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n@@ -24,6 +24,7 @@\n #endif\n \n static int count = 64;\n+static secp256k1_context_t *ctx = NULL;\n \n void random_field_element_test(secp256k1_fe_t *fe) {\n     do {\n@@ -55,8 +56,9 @@ void random_group_element_test(secp256k1_ge_t *ge) {\n     secp256k1_fe_t fe;\n     do {\n         random_field_element_test(&fe);\n-        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand32() & 1))\n+        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand32() & 1)) {\n             break;\n+        }\n     } while(1);\n }\n \n@@ -81,8 +83,9 @@ void random_scalar_order_test(secp256k1_scalar_t *num) {\n         int overflow = 0;\n         secp256k1_rand256_test(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(num))\n+        if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n+        }\n         break;\n     } while(1);\n }\n@@ -93,12 +96,60 @@ void random_scalar_order(secp256k1_scalar_t *num) {\n         int overflow = 0;\n         secp256k1_rand256(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(num))\n+        if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n+        }\n         break;\n     } while(1);\n }\n \n+void run_context_tests(void) {\n+    secp256k1_context_t *none = secp256k1_context_create(0);\n+    secp256k1_context_t *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context_t *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context_t *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+    secp256k1_gej_t pubj;\n+    secp256k1_ge_t pub;\n+    secp256k1_scalar_t msg, key, nonce;\n+    secp256k1_ecdsa_sig_t sig;\n+\n+    /*** clone and destroy all of them to make sure cloning was complete ***/\n+    {\n+        secp256k1_context_t *ctx_tmp;\n+\n+        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n+        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n+        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n+        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+    }\n+\n+    /*** attempt to use them ***/\n+    random_scalar_order_test(&msg);\n+    random_scalar_order_test(&key);\n+    secp256k1_ecmult_gen(&both->ecmult_gen_ctx, &pubj, &key);\n+    secp256k1_ge_set_gej(&pub, &pubj);\n+\n+    /* obtain a working nonce */\n+    do {\n+        random_scalar_order_test(&nonce);\n+    } while(!secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sig, &key, &msg, &nonce, NULL));\n+\n+    /* try signing */\n+    CHECK(secp256k1_ecdsa_sig_sign(&sign->ecmult_gen_ctx, &sig, &key, &msg, &nonce, NULL));\n+    CHECK(secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sig, &key, &msg, &nonce, NULL));\n+\n+    /* try verifying */\n+    CHECK(secp256k1_ecdsa_sig_verify(&vrfy->ecmult_ctx, &sig, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sig, &pub, &msg));\n+\n+    /* cleanup */\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n /***** HASH TESTS *****/\n \n void run_sha256_tests(void) {\n@@ -229,8 +280,9 @@ void run_rfc6979_hmac_sha256_tests(void) {\n \n #ifndef USE_NUM_NONE\n void random_num_negate(secp256k1_num_t *num) {\n-    if (secp256k1_rand32() & 1)\n+    if (secp256k1_rand32() & 1) {\n         secp256k1_num_negate(num);\n+    }\n }\n \n void random_num_order_test(secp256k1_num_t *num) {\n@@ -624,8 +676,9 @@ void random_fe_non_zero(secp256k1_fe_t *nz) {\n     while (--tries >= 0) {\n         random_fe(nz);\n         secp256k1_fe_normalize(nz);\n-        if (!secp256k1_fe_is_zero(nz))\n+        if (!secp256k1_fe_is_zero(nz)) {\n             break;\n+        }\n     }\n     /* Infinitesimal probability of spurious failure here */\n     CHECK(tries >= 0);\n@@ -700,12 +753,22 @@ void run_field_misc(void) {\n         CHECK(secp256k1_fe_equal_var(&x, &x));\n         z = x;\n         secp256k1_fe_add(&z,&y);\n-        secp256k1_fe_normalize(&z);\n+        /* Test fe conditional move; z is not normalized here. */\n+        q = x;\n+        secp256k1_fe_cmov(&x, &z, 0);\n+        secp256k1_fe_cmov(&x, &x, 1);\n+        CHECK(memcmp(&x, &z, sizeof(x)) != 0);\n+        CHECK(memcmp(&x, &q, sizeof(x)) == 0);\n+        secp256k1_fe_cmov(&q, &z, 1);\n+        CHECK(memcmp(&q, &z, sizeof(q)) == 0);\n         /* Test storage conversion and conditional moves. */\n+        secp256k1_fe_normalize(&z);\n+        CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_to_storage(&xs, &x);\n         secp256k1_fe_to_storage(&ys, &y);\n         secp256k1_fe_to_storage(&zs, &z);\n         secp256k1_fe_storage_cmov(&zs, &xs, 0);\n+        secp256k1_fe_storage_cmov(&zs, &zs, 1);\n         CHECK(memcmp(&xs, &zs, sizeof(xs)) != 0);\n         secp256k1_fe_storage_cmov(&ys, &xs, 1);\n         CHECK(memcmp(&xs, &ys, sizeof(xs)) == 0);\n@@ -765,14 +828,17 @@ void run_field_inv_all_var(void) {\n     for (i = 0; i < count; i++) {\n         size_t j;\n         size_t len = (secp256k1_rand32() & 15) + 1;\n-        for (j = 0; j < len; j++)\n+        for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n+        }\n         secp256k1_fe_inv_all_var(len, xi, x);\n-        for (j = 0; j < len; j++)\n+        for (j = 0; j < len; j++) {\n             CHECK(check_fe_inverse(&x[j], &xi[j]));\n+        }\n         secp256k1_fe_inv_all_var(len, xii, xi);\n-        for (j = 0; j < len; j++)\n+        for (j = 0; j < len; j++) {\n             CHECK(check_fe_equal(&x[j], &xii[j]));\n+        }\n     }\n }\n \n@@ -844,18 +910,42 @@ void run_sqrt(void) {\n \n void ge_equals_ge(const secp256k1_ge_t *a, const secp256k1_ge_t *b) {\n     CHECK(a->infinity == b->infinity);\n-    if (a->infinity)\n+    if (a->infinity) {\n         return;\n+    }\n     CHECK(secp256k1_fe_equal_var(&a->x, &b->x));\n     CHECK(secp256k1_fe_equal_var(&b->y, &b->y));\n }\n \n+/* This compares jacobian points including their Z, not just their geometric meaning. */\n+int gej_xyz_equals_gej(const secp256k1_gej_t *a, const secp256k1_gej_t *b) {\n+    secp256k1_gej_t a2;\n+    secp256k1_gej_t b2;\n+    int ret = 1;\n+    ret &= a->infinity == b->infinity;\n+    if (ret && !a->infinity) {\n+        a2 = *a;\n+        b2 = *b;\n+        secp256k1_fe_normalize(&a2.x);\n+        secp256k1_fe_normalize(&a2.y);\n+        secp256k1_fe_normalize(&a2.z);\n+        secp256k1_fe_normalize(&b2.x);\n+        secp256k1_fe_normalize(&b2.y);\n+        secp256k1_fe_normalize(&b2.z);\n+        ret &= secp256k1_fe_cmp_var(&a2.x, &b2.x) == 0;\n+        ret &= secp256k1_fe_cmp_var(&a2.y, &b2.y) == 0;\n+        ret &= secp256k1_fe_cmp_var(&a2.z, &b2.z) == 0;\n+    }\n+    return ret;\n+}\n+\n void ge_equals_gej(const secp256k1_ge_t *a, const secp256k1_gej_t *b) {\n     secp256k1_fe_t z2s;\n     secp256k1_fe_t u1, u2, s1, s2;\n     CHECK(a->infinity == b->infinity);\n-    if (a->infinity)\n+    if (a->infinity) {\n         return;\n+    }\n     /* Check a.x * b.z^2 == b.x && a.y * b.z^3 == b.y, to avoid inverses. */\n     secp256k1_fe_sqr(&z2s, &b->z);\n     secp256k1_fe_mul(&u1, &a->x, &z2s);\n@@ -874,8 +964,8 @@ void test_ge(void) {\n      * All magnitudes are randomized.\n      * All 17*17 combinations of points are added to eachother, using all applicable methods.\n      */\n-    secp256k1_ge_t *ge = malloc(sizeof(secp256k1_ge_t) * (1 + 4 * runs));\n-    secp256k1_gej_t *gej = malloc(sizeof(secp256k1_gej_t) * (1 + 4 * runs));\n+    secp256k1_ge_t *ge = (secp256k1_ge_t *)malloc(sizeof(secp256k1_ge_t) * (1 + 4 * runs));\n+    secp256k1_gej_t *gej = (secp256k1_gej_t *)malloc(sizeof(secp256k1_gej_t) * (1 + 4 * runs));\n     secp256k1_gej_set_infinity(&gej[0]);\n     secp256k1_ge_clear(&ge[0]);\n     secp256k1_ge_set_gej_var(&ge[0], &gej[0]);\n@@ -951,7 +1041,7 @@ void test_ge(void) {\n     /* Test adding all points together in random order equals infinity. */\n     {\n         secp256k1_gej_t sum = SECP256K1_GEJ_CONST_INFINITY;\n-        secp256k1_gej_t *gej_shuffled = malloc((4 * runs + 1) * sizeof(secp256k1_gej_t));\n+        secp256k1_gej_t *gej_shuffled = (secp256k1_gej_t *)malloc((4 * runs + 1) * sizeof(secp256k1_gej_t));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             gej_shuffled[i] = gej[i];\n         }\n@@ -972,9 +1062,12 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion. */\n     {\n-        secp256k1_ge_t *ge_set_all = malloc((4 * runs + 1) * sizeof(secp256k1_ge_t));\n+        secp256k1_ge_t *ge_set_all = (secp256k1_ge_t *)malloc((4 * runs + 1) * sizeof(secp256k1_ge_t));\n         secp256k1_ge_set_all_gej_var(4 * runs + 1, ge_set_all, gej);\n         for (i = 0; i < 4 * runs + 1; i++) {\n+            secp256k1_fe_t s;\n+            random_fe_non_zero(&s);\n+            secp256k1_gej_rescale(&gej[i], &s);\n             ge_equals_gej(&ge_set_all[i], &gej[i]);\n         }\n         free(ge_set_all);\n@@ -1025,7 +1118,7 @@ void run_ecmult_chain(void) {\n     x = a;\n     for (i = 0; i < 200*count; i++) {\n         /* in each iteration, compute X = xn*X + gn*G; */\n-        secp256k1_ecmult(&x, &x, &xn, &gn);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &x, &x, &xn, &gn);\n         /* also compute ae and ge: the actual accumulated factors for A and G */\n         /* if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G) */\n         secp256k1_scalar_mul(&ae, &ae, &xn);\n@@ -1051,7 +1144,7 @@ void run_ecmult_chain(void) {\n         }\n     }\n     /* redo the computation, but directly with the resulting ae and ge coefficients: */\n-    secp256k1_ecmult(&x2, &a, &ae, &ge);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &x2, &a, &ae, &ge);\n     secp256k1_gej_neg(&x2, &x2);\n     secp256k1_gej_add_var(&x2, &x2, &x);\n     CHECK(secp256k1_gej_is_infinity(&x2));\n@@ -1067,8 +1160,8 @@ void test_point_times_order(const secp256k1_gej_t *point) {\n     int psize = 65;\n     random_scalar_order_test(&x);\n     secp256k1_scalar_negate(&nx, &x);\n-    secp256k1_ecmult(&res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n-    secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n     CHECK(secp256k1_gej_is_valid_var(&res1) == 0);\n@@ -1141,17 +1234,96 @@ void run_wnaf(void) {\n     secp256k1_scalar_t n;\n     for (i = 0; i < count; i++) {\n         random_scalar_order(&n);\n-        if (i % 1)\n-            secp256k1_scalar_negate(&n, &n);\n         test_wnaf(&n, 4+(i%10));\n     }\n }\n \n+void test_ecmult_constants(void) {\n+    /* Test ecmult_gen() for [0..36) and [order-36..0). */\n+    secp256k1_scalar_t x;\n+    secp256k1_gej_t r;\n+    secp256k1_ge_t ng;\n+    int i;\n+    int j;\n+    secp256k1_ge_neg(&ng, &secp256k1_ge_const_g);\n+    for (i = 0; i < 36; i++ ) {\n+        secp256k1_scalar_set_int(&x, i);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &r, &x);\n+        for (j = 0; j < i; j++) {\n+            if (j == i - 1) {\n+                ge_equals_gej(&secp256k1_ge_const_g, &r);\n+            }\n+            secp256k1_gej_add_ge(&r, &r, &ng);\n+        }\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+    for (i = 1; i <= 36; i++ ) {\n+        secp256k1_scalar_set_int(&x, i);\n+        secp256k1_scalar_negate(&x, &x);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &r, &x);\n+        for (j = 0; j < i; j++) {\n+            if (j == i - 1) {\n+                ge_equals_gej(&ng, &r);\n+            }\n+            secp256k1_gej_add_ge(&r, &r, &secp256k1_ge_const_g);\n+        }\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+}\n+\n+void run_ecmult_constants(void) {\n+    test_ecmult_constants();\n+}\n+\n+void test_ecmult_gen_blind(void) {\n+    /* Test ecmult_gen() blinding and confirm that the blinding changes, the affline points match, and the z's don't match. */\n+    secp256k1_scalar_t key;\n+    secp256k1_scalar_t b;\n+    unsigned char seed32[32];\n+    secp256k1_gej_t pgej;\n+    secp256k1_gej_t pgej2;\n+    secp256k1_gej_t i;\n+    secp256k1_ge_t pge;\n+    random_scalar_order_test(&key);\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pgej, &key);\n+    secp256k1_rand256(seed32);\n+    b = ctx->ecmult_gen_ctx.blind;\n+    i = ctx->ecmult_gen_ctx.initial;\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n+    CHECK(!secp256k1_scalar_eq(&b, &ctx->ecmult_gen_ctx.blind));\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pgej2, &key);\n+    CHECK(!gej_xyz_equals_gej(&pgej, &pgej2));\n+    CHECK(!gej_xyz_equals_gej(&i, &ctx->ecmult_gen_ctx.initial));\n+    secp256k1_ge_set_gej(&pge, &pgej);\n+    ge_equals_gej(&pge, &pgej2);\n+}\n+\n+void test_ecmult_gen_blind_reset(void) {\n+    /* Test ecmult_gen() blinding reset and confirm that the blinding is consistent. */\n+    secp256k1_scalar_t b;\n+    secp256k1_gej_t initial;\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, 0);\n+    b = ctx->ecmult_gen_ctx.blind;\n+    initial = ctx->ecmult_gen_ctx.initial;\n+    secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, 0);\n+    CHECK(secp256k1_scalar_eq(&b, &ctx->ecmult_gen_ctx.blind));\n+    CHECK(gej_xyz_equals_gej(&initial, &ctx->ecmult_gen_ctx.initial));\n+}\n+\n+void run_ecmult_gen_blind(void) {\n+    int i;\n+    test_ecmult_gen_blind_reset();\n+    for (i = 0; i < 10; i++) {\n+        test_ecmult_gen_blind();\n+    }\n+}\n+\n+\n void random_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *key, const secp256k1_scalar_t *msg, int *recid) {\n     secp256k1_scalar_t nonce;\n     do {\n         random_scalar_order_test(&nonce);\n-    } while(!secp256k1_ecdsa_sig_sign(sig, key, msg, &nonce, recid));\n+    } while(!secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, sig, key, msg, &nonce, recid));\n }\n \n void test_ecdsa_sign_verify(void) {\n@@ -1164,15 +1336,17 @@ void test_ecdsa_sign_verify(void) {\n     int getrec;\n     random_scalar_order_test(&msg);\n     random_scalar_order_test(&key);\n-    secp256k1_ecmult_gen(&pubj, &key);\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n     getrec = secp256k1_rand32()&1;\n     random_sign(&sig, &key, &msg, getrec?&recid:NULL);\n-    if (getrec) CHECK(recid >= 0 && recid < 4);\n-    CHECK(secp256k1_ecdsa_sig_verify(&sig, &pub, &msg));\n+    if (getrec) {\n+        CHECK(recid >= 0 && recid < 4);\n+    }\n+    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &pub, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &pub, &msg));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &pub, &msg));\n }\n \n void run_ecdsa_sign_verify(void) {\n@@ -1192,15 +1366,19 @@ static int precomputed_nonce_function(unsigned char *nonce32, const unsigned cha\n \n static int nonce_function_test_fail(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, unsigned int counter, const void *data) {\n    /* Dummy nonce generator that has a fatal error on the first counter value. */\n-   if (counter == 0) return 0;\n+   if (counter == 0) {\n+       return 0;\n+   }\n    return nonce_function_rfc6979(nonce32, msg32, key32, counter - 1, data);\n }\n \n static int nonce_function_test_retry(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, unsigned int counter, const void *data) {\n    /* Dummy nonce generator that produces unacceptable nonces for the first several counter values. */\n    if (counter < 3) {\n        memset(nonce32, counter==0 ? 0 : 255, 32);\n-       if (counter == 2) nonce32[31]--;\n+       if (counter == 2) {\n+           nonce32[31]--;\n+       }\n        return 1;\n    }\n    if (counter < 5) {\n@@ -1211,12 +1389,16 @@ static int nonce_function_test_retry(unsigned char *nonce32, const unsigned char\n            0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n        };\n        memcpy(nonce32, order, 32);\n-       if (counter == 4) nonce32[31]++;\n+       if (counter == 4) {\n+           nonce32[31]++;\n+       }\n        return 1;\n    }\n    /* Retry rate of 6979 is negligible esp. as we only call this in determinstic tests. */\n    /* If someone does fine a case where it retries for secp256k1, we'd like to know. */\n-   if (counter > 5) return 0;\n+   if (counter > 5) {\n+       return 0;\n+   }\n    return nonce_function_rfc6979(nonce32, msg32, key32, counter - 5, data);\n }\n \n@@ -1257,16 +1439,16 @@ void test_ecdsa_end_to_end(void) {\n     }\n \n     /* Construct and verify corresponding public key. */\n-    CHECK(secp256k1_ec_seckey_verify(privkey) == 1);\n-    CHECK(secp256k1_ec_pubkey_create(pubkey, &pubkeylen, privkey, (secp256k1_rand32() & 3) != 0) == 1);\n+    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, pubkey, &pubkeylen, privkey, (secp256k1_rand32() & 3) != 0) == 1);\n     if (secp256k1_rand32() & 1) {\n-        CHECK(secp256k1_ec_pubkey_decompress(pubkey, &pubkeylen));\n+        CHECK(secp256k1_ec_pubkey_decompress(ctx, pubkey, &pubkeylen));\n     }\n-    CHECK(secp256k1_ec_pubkey_verify(pubkey, pubkeylen));\n+    CHECK(secp256k1_ec_pubkey_verify(ctx, pubkey, pubkeylen));\n \n     /* Verify private key import and export. */\n-    CHECK(secp256k1_ec_privkey_export(privkey, seckey, &seckeylen, secp256k1_rand32() % 2) == 1);\n-    CHECK(secp256k1_ec_privkey_import(privkey2, seckey, seckeylen) == 1);\n+    CHECK(secp256k1_ec_privkey_export(ctx, privkey, seckey, &seckeylen, secp256k1_rand32() % 2) == 1);\n+    CHECK(secp256k1_ec_privkey_import(ctx, privkey2, seckey, seckeylen) == 1);\n     CHECK(memcmp(privkey, privkey2, 32) == 0);\n \n     /* Optionally tweak the keys using addition. */\n@@ -1277,11 +1459,13 @@ void test_ecdsa_end_to_end(void) {\n         unsigned char pubkey2[65];\n         int pubkeylen2 = 65;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_add(privkey, rnd);\n-        ret2 = secp256k1_ec_pubkey_tweak_add(pubkey, pubkeylen, rnd);\n+        ret1 = secp256k1_ec_privkey_tweak_add(ctx, privkey, rnd);\n+        ret2 = secp256k1_ec_pubkey_tweak_add(ctx, pubkey, pubkeylen, rnd);\n         CHECK(ret1 == ret2);\n-        if (ret1 == 0) return;\n-        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        if (ret1 == 0) {\n+            return;\n+        }\n+        CHECK(secp256k1_ec_pubkey_create(ctx, pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n         CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n     }\n \n@@ -1293,25 +1477,27 @@ void test_ecdsa_end_to_end(void) {\n         unsigned char pubkey2[65];\n         int pubkeylen2 = 65;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_mul(privkey, rnd);\n-        ret2 = secp256k1_ec_pubkey_tweak_mul(pubkey, pubkeylen, rnd);\n+        ret1 = secp256k1_ec_privkey_tweak_mul(ctx, privkey, rnd);\n+        ret2 = secp256k1_ec_pubkey_tweak_mul(ctx, pubkey, pubkeylen, rnd);\n         CHECK(ret1 == ret2);\n-        if (ret1 == 0) return;\n-        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        if (ret1 == 0) {\n+            return;\n+        }\n+        CHECK(secp256k1_ec_pubkey_create(ctx, pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n         CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n     }\n \n     /* Sign. */\n-    CHECK(secp256k1_ecdsa_sign(message, signature, &signaturelen, privkey, NULL, NULL) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature, &signaturelen, privkey, NULL, NULL) == 1);\n     CHECK(signaturelen > 0);\n-    CHECK(secp256k1_ecdsa_sign(message, signature2, &signaturelen2, privkey, NULL, extra) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature2, &signaturelen2, privkey, NULL, extra) == 1);\n     CHECK(signaturelen2 > 0);\n     extra[31] = 1;\n-    CHECK(secp256k1_ecdsa_sign(message, signature3, &signaturelen3, privkey, NULL, extra) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature3, &signaturelen3, privkey, NULL, extra) == 1);\n     CHECK(signaturelen3 > 0);\n     extra[31] = 0;\n     extra[0] = 1;\n-    CHECK(secp256k1_ecdsa_sign(message, signature4, &signaturelen4, privkey, NULL, extra) == 1);\n+    CHECK(secp256k1_ecdsa_sign(ctx, message, signature4, &signaturelen4, privkey, NULL, extra) == 1);\n     CHECK(signaturelen3 > 0);\n     CHECK((signaturelen != signaturelen2) || (memcmp(signature, signature2, signaturelen) != 0));\n     CHECK((signaturelen != signaturelen3) || (memcmp(signature, signature3, signaturelen) != 0));\n@@ -1320,24 +1506,24 @@ void test_ecdsa_end_to_end(void) {\n     CHECK((signaturelen4 != signaturelen2) || (memcmp(signature4, signature2, signaturelen4) != 0));\n     CHECK((signaturelen4 != signaturelen) || (memcmp(signature4, signature, signaturelen4) != 0));\n     /* Verify. */\n-    CHECK(secp256k1_ecdsa_verify(message, signature, signaturelen, pubkey, pubkeylen) == 1);\n-    CHECK(secp256k1_ecdsa_verify(message, signature2, signaturelen2, pubkey, pubkeylen) == 1);\n-    CHECK(secp256k1_ecdsa_verify(message, signature3, signaturelen3, pubkey, pubkeylen) == 1);\n-    CHECK(secp256k1_ecdsa_verify(message, signature4, signaturelen4, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature, signaturelen, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature2, signaturelen2, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature3, signaturelen3, pubkey, pubkeylen) == 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature4, signaturelen4, pubkey, pubkeylen) == 1);\n     /* Destroy signature and verify again. */\n     signature[signaturelen - 1 - secp256k1_rand32() % 20] += 1 + (secp256k1_rand32() % 255);\n-    CHECK(secp256k1_ecdsa_verify(message, signature, signaturelen, pubkey, pubkeylen) != 1);\n+    CHECK(secp256k1_ecdsa_verify(ctx, message, signature, signaturelen, pubkey, pubkeylen) != 1);\n \n     /* Compact sign. */\n-    CHECK(secp256k1_ecdsa_sign_compact(message, csignature, privkey, NULL, NULL, &recid) == 1);\n+    CHECK(secp256k1_ecdsa_sign_compact(ctx, message, csignature, privkey, NULL, NULL, &recid) == 1);\n     CHECK(!is_empty_compact_signature(csignature));\n     /* Recover. */\n-    CHECK(secp256k1_ecdsa_recover_compact(message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) == 1);\n+    CHECK(secp256k1_ecdsa_recover_compact(ctx, message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) == 1);\n     CHECK(recpubkeylen == pubkeylen);\n     CHECK(memcmp(pubkey, recpubkey, pubkeylen) == 0);\n     /* Destroy signature and verify again. */\n     csignature[secp256k1_rand32() % 64] += 1 + (secp256k1_rand32() % 255);\n-    CHECK(secp256k1_ecdsa_recover_compact(message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) != 1 ||\n+    CHECK(secp256k1_ecdsa_recover_compact(ctx, message, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) != 1 ||\n           memcmp(pubkey, recpubkey, pubkeylen) != 0);\n     CHECK(recpubkeylen == pubkeylen);\n \n@@ -1351,18 +1537,26 @@ void test_random_pubkeys(void) {\n     uint32_t r = secp256k1_rand32();\n     int len = (r & 3) == 0 ? 65 : 33;\n     r>>=2;\n-    if ((r & 3) == 0) len = (r & 252) >> 3;\n+    if ((r & 3) == 0) {\n+        len = (r & 252) >> 3;\n+    }\n     r>>=8;\n     if (len == 65) {\n       in[0] = (r & 2) ? 4 : (r & 1? 6 : 7);\n     } else {\n       in[0] = (r & 1) ? 2 : 3;\n     }\n     r>>=2;\n-    if ((r & 7) == 0) in[0] = (r & 2040) >> 3;\n+    if ((r & 7) == 0) {\n+        in[0] = (r & 2040) >> 3;\n+    }\n     r>>=11;\n-    if (len > 1) secp256k1_rand256(&in[1]);\n-    if (len > 33) secp256k1_rand256(&in[33]);\n+    if (len > 1) {\n+        secp256k1_rand256(&in[1]);\n+    }\n+    if (len > 33) {\n+        secp256k1_rand256(&in[33]);\n+    }\n     if (secp256k1_eckey_pubkey_parse(&elem, in, len)) {\n         unsigned char out[65];\n         unsigned char firstb;\n@@ -1374,7 +1568,9 @@ void test_random_pubkeys(void) {\n         CHECK(size == len);\n         CHECK(memcmp(&in[1], &out[1], len-1) == 0);\n         /* ... except for the type of hybrid inputs. */\n-        if ((in[0] != 6) && (in[0] != 7)) CHECK(in[0] == out[0]);\n+        if ((in[0] != 6) && (in[0] != 7)) {\n+            CHECK(in[0] == out[0]);\n+        }\n         size = 65;\n         CHECK(secp256k1_eckey_pubkey_serialize(&elem, in, &size, 0));\n         CHECK(size == 65);\n@@ -1384,8 +1580,11 @@ void test_random_pubkeys(void) {\n         in[0] = (r & 1) ? 6 : 7;\n         res = secp256k1_eckey_pubkey_parse(&elem2, in, size);\n         if (firstb == 2 || firstb == 3) {\n-            if (in[0] == firstb + 4) CHECK(res);\n-            else CHECK(!res);\n+            if (in[0] == firstb + 4) {\n+              CHECK(res);\n+            } else {\n+              CHECK(!res);\n+            }\n         }\n         if (res) {\n             ge_equals_ge(&elem,&elem2);\n@@ -1447,10 +1646,10 @@ void test_ecdsa_edge_cases(void) {\n     int pubkeyblen = 33;\n     int recid;\n \n-    CHECK(!secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 0));\n-    CHECK(secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 1));\n-    CHECK(!secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 2));\n-    CHECK(!secp256k1_ecdsa_recover_compact(msg32, sig64, pubkey, &pubkeylen, 0, 3));\n+    CHECK(!secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 0));\n+    CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 1));\n+    CHECK(!secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 2));\n+    CHECK(!secp256k1_ecdsa_recover_compact(ctx, msg32, sig64, pubkey, &pubkeylen, 0, 3));\n \n     for (recid = 0; recid < 4; recid++) {\n         int i;\n@@ -1495,42 +1694,44 @@ void test_ecdsa_edge_cases(void) {\n             0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E,\n             0x8C, 0xD0, 0x36, 0x41, 0x45, 0x02, 0x01, 0x04\n         };\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigb64, pubkeyb, &pubkeyblen, 1, recid));\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigb64, pubkeyb, &pubkeyblen, 1, recid));\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 1);\n         for (recid2 = 0; recid2 < 4; recid2++) {\n             unsigned char pubkey2b[33];\n             int pubkey2blen = 33;\n-            CHECK(secp256k1_ecdsa_recover_compact(msg32, sigb64, pubkey2b, &pubkey2blen, 1, recid2));\n+            CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigb64, pubkey2b, &pubkey2blen, 1, recid2));\n             /* Verifying with (order + r,4) should always fail. */\n-            CHECK(secp256k1_ecdsa_verify(msg32, sigbderlong, sizeof(sigbderlong), pubkey2b, pubkey2blen) != 1);\n+            CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderlong, sizeof(sigbderlong), pubkey2b, pubkey2blen) != 1);\n         }\n         /* DER parsing tests. */\n         /* Zero length r/s. */\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder_zr, sizeof(sigcder_zr), pubkeyb, pubkeyblen) == -2);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder_zs, sizeof(sigcder_zs), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder_zr, sizeof(sigcder_zr), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder_zs, sizeof(sigcder_zs), pubkeyb, pubkeyblen) == -2);\n         /* Leading zeros. */\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt1, sizeof(sigbderalt1), pubkeyb, pubkeyblen) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt2, sizeof(sigbderalt2), pubkeyb, pubkeyblen) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt1, sizeof(sigbderalt1), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt2, sizeof(sigbderalt2), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == 1);\n         sigbderalt3[4] = 1;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt3, sizeof(sigbderalt3), pubkeyb, pubkeyblen) == -2);\n         sigbderalt4[7] = 1;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbderalt4, sizeof(sigbderalt4), pubkeyb, pubkeyblen) == -2);\n         /* Damage signature. */\n         sigbder[7]++;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 0);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) == 0);\n         sigbder[7]--;\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, 6, pubkeyb, pubkeyblen) == -2);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder)-1, pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, 6, pubkeyb, pubkeyblen) == -2);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder)-1, pubkeyb, pubkeyblen) == -2);\n         for(i = 0; i < 8; i++) {\n             int c;\n             unsigned char orig = sigbder[i];\n             /*Try every single-byte change.*/\n             for (c = 0; c < 256; c++) {\n-                if (c == orig ) continue;\n+                if (c == orig ) {\n+                    continue;\n+                }\n                 sigbder[i] = c;\n-                CHECK(secp256k1_ecdsa_verify(msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) ==\n+                CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigbder, sizeof(sigbder), pubkeyb, pubkeyblen) ==\n                   (i==4 || i==7) ? 0 : -2 );\n             }\n             sigbder[i] = orig;\n@@ -1547,10 +1748,10 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_negate(&sig.s, &sig.s);\n         secp256k1_scalar_inverse(&sig.s, &sig.s);\n         secp256k1_scalar_set_int(&sig.r, 1);\n-        secp256k1_ecmult_gen(&keyj, &sig.r);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &keyj, &sig.r);\n         secp256k1_ge_set_gej(&key, &keyj);\n         msg = sig.s;\n-        CHECK(secp256k1_ecdsa_sig_verify(&sig, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &key, &msg) == 0);\n     }\n \n     /* Test r/s equal to zero */\n@@ -1569,18 +1770,18 @@ void test_ecdsa_edge_cases(void) {\n         };\n         unsigned char pubkeyc[65];\n         int pubkeyclen = 65;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigc64, pubkeyc, &pubkeyclen, 0, 0) == 1);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 1);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigc64, pubkeyc, &pubkeyclen, 0, 0) == 1);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 1);\n         sigcder[4] = 0;\n         sigc64[31] = 0;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n         sigcder[4] = 1;\n         sigcder[7] = 0;\n         sigc64[31] = 1;\n         sigc64[63] = 0;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n-        CHECK(secp256k1_ecdsa_verify(msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n+        CHECK(secp256k1_ecdsa_recover_compact(ctx, msg32, sigc64, pubkeyb, &pubkeyblen, 1, 0) == 0);\n+        CHECK(secp256k1_ecdsa_verify(ctx, msg32, sigcder, sizeof(sigcder), pubkeyc, pubkeyclen) == 0);\n     }\n \n     /*Signature where s would be zero.*/\n@@ -1611,18 +1812,18 @@ void test_ecdsa_edge_cases(void) {\n         };\n         unsigned char sig[72];\n         int siglen = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 0);\n         CHECK(siglen == 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 0);\n         CHECK(siglen == 0);\n         msg[31] = 0xaa;\n         siglen = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce) == 1);\n         CHECK(siglen > 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce2) == 1);\n         CHECK(siglen > 0);\n         siglen = 10;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, precomputed_nonce_function, nonce) != 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, precomputed_nonce_function, nonce) != 1);\n         CHECK(siglen == 0);\n     }\n \n@@ -1644,49 +1845,49 @@ void test_ecdsa_edge_cases(void) {\n         msg[31] = 1;\n         /* High key results in signature failure. */\n         memset(key, 0xFF, 32);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, NULL, extra) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, NULL, extra) == 0);\n         CHECK(siglen == 0);\n         /* Zero key results in signature failure. */\n         memset(key, 0, 32);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, NULL, extra) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, NULL, extra) == 0);\n         CHECK(siglen == 0);\n         /* Nonce function failure results in signature failure. */\n         key[31] = 1;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, nonce_function_test_fail, extra) == 0);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, nonce_function_test_fail, extra) == 0);\n         CHECK(siglen == 0);\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig, key, nonce_function_test_fail, extra, &recid) == 0);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig, key, nonce_function_test_fail, extra, &recid) == 0);\n         CHECK(is_empty_compact_signature(sig));\n         /* The retry loop successfully makes its way to the first good value. */\n         siglen = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, nonce_function_test_retry, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, nonce_function_test_retry, extra) == 1);\n         CHECK(siglen > 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, nonce_function_rfc6979, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, nonce_function_rfc6979, extra) == 1);\n         CHECK(siglen > 0);\n         CHECK((siglen == siglen2) && (memcmp(sig, sig2, siglen) == 0));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig, key, nonce_function_test_retry, extra, &recid) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig, key, nonce_function_test_retry, extra, &recid) == 1);\n         CHECK(!is_empty_compact_signature(sig));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig2, key, nonce_function_rfc6979, extra, &recid2) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig2, key, nonce_function_rfc6979, extra, &recid2) == 1);\n         CHECK(!is_empty_compact_signature(sig2));\n         CHECK((recid == recid2) && (memcmp(sig, sig2, 64) == 0));\n         /* The default nonce function is determinstic. */\n         siglen = 72;\n         siglen2 = 72;\n-        CHECK(secp256k1_ecdsa_sign(msg, sig, &siglen, key, NULL, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig, &siglen, key, NULL, extra) == 1);\n         CHECK(siglen > 0);\n-        CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, NULL, extra) == 1);\n+        CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, NULL, extra) == 1);\n         CHECK(siglen2 > 0);\n         CHECK((siglen == siglen2) && (memcmp(sig, sig2, siglen) == 0));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig, key, NULL, extra, &recid) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig, key, NULL, extra, &recid) == 1);\n         CHECK(!is_empty_compact_signature(sig));\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, sig2, key, NULL, extra, &recid2) == 1);\n+        CHECK(secp256k1_ecdsa_sign_compact(ctx, msg, sig2, key, NULL, extra, &recid2) == 1);\n         CHECK(!is_empty_compact_signature(sig));\n         CHECK((recid == recid2) && (memcmp(sig, sig2, 64) == 0));\n         /* The default nonce function changes output with different messages. */\n         for(i = 0; i < 256; i++) {\n             int j;\n             siglen2 = 72;\n             msg[0] = i;\n-            CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, NULL, extra) == 1);\n+            CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, NULL, extra) == 1);\n             CHECK(!is_empty_compact_signature(sig));\n             CHECK(secp256k1_ecdsa_sig_parse(&s[i], sig2, siglen2));\n             for (j = 0; j < i; j++) {\n@@ -1700,7 +1901,7 @@ void test_ecdsa_edge_cases(void) {\n             int j;\n             siglen2 = 72;\n             key[0] = i - 256;\n-            CHECK(secp256k1_ecdsa_sign(msg, sig2, &siglen2, key, NULL, extra) == 1);\n+            CHECK(secp256k1_ecdsa_sign(ctx, msg, sig2, &siglen2, key, NULL, extra) == 1);\n             CHECK(secp256k1_ecdsa_sig_parse(&s[i], sig2, siglen2));\n             for (j = 0; j < i; j++) {\n                 CHECK(!secp256k1_scalar_eq(&s[i].r, &s[j].r));\n@@ -1719,8 +1920,8 @@ void test_ecdsa_edge_cases(void) {\n             0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41,\n         };\n         int outlen = 300;\n-        CHECK(!secp256k1_ec_privkey_export(seckey, privkey, &outlen, 0));\n-        CHECK(!secp256k1_ec_privkey_export(seckey, privkey, &outlen, 1));\n+        CHECK(!secp256k1_ec_privkey_export(ctx, seckey, privkey, &outlen, 0));\n+        CHECK(!secp256k1_ec_privkey_export(ctx, seckey, privkey, &outlen, 1));\n     }\n }\n \n@@ -1735,7 +1936,7 @@ EC_KEY *get_openssl_key(const secp256k1_scalar_t *key) {\n     const unsigned char* pbegin = privkey;\n     int compr = secp256k1_rand32() & 1;\n     EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    CHECK(secp256k1_eckey_privkey_serialize(privkey, &privkeylen, key, compr));\n+    CHECK(secp256k1_eckey_privkey_serialize(&ctx->ecmult_gen_ctx, privkey, &privkeylen, key, compr));\n     CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n     CHECK(EC_KEY_check_key(ec_key));\n     return ec_key;\n@@ -1756,16 +1957,16 @@ void test_ecdsa_openssl(void) {\n     secp256k1_rand256_test(message);\n     secp256k1_scalar_set_b32(&msg, message, NULL);\n     random_scalar_order_test(&key);\n-    secp256k1_ecmult_gen(&qj, &key);\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &qj, &key);\n     secp256k1_ge_set_gej(&q, &qj);\n     ec_key = get_openssl_key(&key);\n     CHECK(ec_key);\n     CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n     CHECK(secp256k1_ecdsa_sig_parse(&sig, signature, sigsize));\n-    CHECK(secp256k1_ecdsa_sig_verify(&sig, &q, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &q, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg2, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &q, &msg2));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sig, &q, &msg2));\n \n     random_sign(&sig, &key, &msg, NULL);\n     CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sig));\n@@ -1825,10 +2026,13 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    secp256k1_start(SECP256K1_START_SIGN | SECP256K1_START_VERIFY);\n+    run_context_tests();\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n \n-    /* initializing a second time shouldn't cause any harm or memory leaks. */\n-    secp256k1_start(SECP256K1_START_SIGN | SECP256K1_START_VERIFY);\n+    if (secp256k1_rand32() & 1) {\n+        secp256k1_rand256(run32);\n+        CHECK(secp256k1_context_randomize(ctx, secp256k1_rand32() & 1 ? run32 : NULL));\n+    }\n \n     run_sha256_tests();\n     run_hmac_sha256_tests();\n@@ -1858,6 +2062,8 @@ int main(int argc, char **argv) {\n     run_wnaf();\n     run_point_times_order();\n     run_ecmult_chain();\n+    run_ecmult_constants();\n+    run_ecmult_gen_blind();\n \n     /* ecdsa tests */\n     run_random_pubkeys();\n@@ -1872,9 +2078,6 @@ int main(int argc, char **argv) {\n     printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n \n     /* shutdown */\n-    secp256k1_stop();\n-\n-    /* shutting down twice shouldn't cause any double frees. */\n-    secp256k1_stop();\n+    secp256k1_context_destroy(ctx);\n     return 0;\n }"
      }
    ]
  },
  {
    "sha": "a56054be650052361e8de79f0f03a56a043759e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTYwNTRiZTY1MDA1MjM2MWU4ZGU3OWYwZjAzYTU2YTA0Mzc1OWU1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-22T21:28:26Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-05-04T12:45:34Z"
      },
      "message": "Update key.cpp to use new libsecp256k1\n\nlibsecp256k1's API changed, so update key.cpp to use it.\n\nLibsecp256k1 now has explicit context objects, which makes it completely thread-safe.\nIn turn, keep an explicit context object in key.cpp, which is explicitly initialized\ndestroyed. This is not really pretty now, but it's more efficient than the static\ninitialized object in key.cpp (which made for example bitcoin-tx slow, as for most of\nits calls, libsecp256k1 wasn't actually needed).\n\nThis also brings in the new blinding support in libsecp256k1. By passing in a random\nseed, temporary variables during the elliptic curve computations are altered, in such\na way that if an attacker does not know the blind, observing the internal operations\nleaks less information about the keys used. This was implemented by Greg Maxwell.",
      "tree": {
        "sha": "05aec96814359918e9a87b6035e037bce5257e2a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05aec96814359918e9a87b6035e037bce5257e2a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a56054be650052361e8de79f0f03a56a043759e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a56054be650052361e8de79f0f03a56a043759e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a56054be650052361e8de79f0f03a56a043759e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a56054be650052361e8de79f0f03a56a043759e5/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4dda253190e6f5ac6728e88fefdf6e8eaf41419c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4dda253190e6f5ac6728e88fefdf6e8eaf41419c"
      }
    ],
    "stats": {
      "total": 87,
      "additions": 63,
      "deletions": 24
    },
    "files": [
      {
        "sha": "f1cdc36b7247ce728e02aaaac1442c87cc217d78",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a56054be650052361e8de79f0f03a56a043759e5/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a56054be650052361e8de79f0f03a56a043759e5/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=a56054be650052361e8de79f0f03a56a043759e5",
        "patch": "@@ -444,9 +444,18 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     tx = mergedTx;\n }\n \n+class Secp256k1Init\n+{\n+public:\n+    Secp256k1Init() { ECC_Start(); }\n+    ~Secp256k1Init() { ECC_Stop(); }\n+};\n+\n static void MutateTx(CMutableTransaction& tx, const string& command,\n                      const string& commandVal)\n {\n+    boost::scoped_ptr<Secp256k1Init> ecc;\n+\n     if (command == \"nversion\")\n         MutateTxVersion(tx, commandVal);\n     else if (command == \"locktime\")\n@@ -464,8 +473,10 @@ static void MutateTx(CMutableTransaction& tx, const string& command,\n     else if (command == \"outscript\")\n         MutateTxAddOutScript(tx, commandVal);\n \n-    else if (command == \"sign\")\n+    else if (command == \"sign\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxSign(tx, commandVal);\n+    }\n \n     else if (command == \"load\")\n         RegisterLoad(commandVal);"
      },
      {
        "sha": "854d8e94ddef59863c8e2bce0ba17df1d0bcded5",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a56054be650052361e8de79f0f03a56a043759e5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a56054be650052361e8de79f0f03a56a043759e5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=a56054be650052361e8de79f0f03a56a043759e5",
        "patch": "@@ -194,6 +194,7 @@ void Shutdown()\n     delete pwalletMain;\n     pwalletMain = NULL;\n #endif\n+    ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n \n@@ -788,6 +789,9 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n+    // Initialize elliptic curve code\n+    ECC_Start();\n+\n     // Sanity check\n     if (!InitSanityCheck())\n         return InitError(_(\"Initialization sanity check failed. Bitcoin Core is shutting down.\"));"
      },
      {
        "sha": "49941d6c7c634770f5ae1e9f02e77af1fd5a5c93",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 22,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a56054be650052361e8de79f0f03a56a043759e5/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a56054be650052361e8de79f0f03a56a043759e5/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=a56054be650052361e8de79f0f03a56a043759e5",
        "patch": "@@ -14,21 +14,7 @@\n #include <secp256k1.h>\n #include \"ecwrapper.h\"\n \n-//! anonymous namespace\n-namespace {\n-\n-class CSecp256k1Init {\n-public:\n-    CSecp256k1Init() {\n-        secp256k1_start(SECP256K1_START_SIGN);\n-    }\n-    ~CSecp256k1Init() {\n-        secp256k1_stop();\n-    }\n-};\n-static CSecp256k1Init instance_of_csecp256k1;\n-\n-} // anon namespace\n+static secp256k1_context_t* secp256k1_context = NULL;\n \n bool CKey::Check(const unsigned char *vch) {\n     return eccrypto::Check(vch);\n@@ -44,7 +30,7 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n }\n \n bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n-    if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+    if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n     fCompressed = fCompressedIn;\n     fValid = true;\n@@ -57,7 +43,7 @@ CPrivKey CKey::GetPrivKey() const {\n     int privkeylen, ret;\n     privkey.resize(279);\n     privkeylen = 279;\n-    ret = secp256k1_ec_privkey_export(begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n+    ret = secp256k1_ec_privkey_export(secp256k1_context, begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n     assert(ret);\n     privkey.resize(privkeylen);\n     return privkey;\n@@ -67,7 +53,7 @@ CPubKey CKey::GetPubKey() const {\n     assert(fValid);\n     CPubKey result;\n     int clen = 65;\n-    int ret = secp256k1_ec_pubkey_create((unsigned char*)result.begin(), &clen, begin(), fCompressed);\n+    int ret = secp256k1_ec_pubkey_create(secp256k1_context, (unsigned char*)result.begin(), &clen, begin(), fCompressed);\n     assert((int)result.size() == clen);\n     assert(ret);\n     assert(result.IsValid());\n@@ -81,7 +67,7 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_\n     int nSigLen = 72;\n     unsigned char extra_entropy[32] = {0};\n     WriteLE32(extra_entropy, test_case);\n-    int ret = secp256k1_ecdsa_sign(hash.begin(), (unsigned char*)&vchSig[0], &nSigLen, begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : NULL);\n+    int ret = secp256k1_ecdsa_sign(secp256k1_context, hash.begin(), (unsigned char*)&vchSig[0], &nSigLen, begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : NULL);\n     assert(ret);\n     vchSig.resize(nSigLen);\n     return true;\n@@ -106,15 +92,15 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n         return false;\n     vchSig.resize(65);\n     int rec = -1;\n-    int ret = secp256k1_ecdsa_sign_compact(hash.begin(), &vchSig[1], begin(), secp256k1_nonce_function_rfc6979, NULL, &rec);\n+    int ret = secp256k1_ecdsa_sign_compact(secp256k1_context, hash.begin(), &vchSig[1], begin(), secp256k1_nonce_function_rfc6979, NULL, &rec);\n     assert(ret);\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n     return true;\n }\n \n bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n-    if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+    if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n@@ -140,7 +126,7 @@ bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild\n     }\n     memcpy(ccChild, out+32, 32);\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n-    bool ret = secp256k1_ec_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n+    bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context, (unsigned char*)keyChild.begin(), out);\n     UnlockObject(out);\n     keyChild.fCompressed = true;\n     keyChild.fValid = ret;\n@@ -206,3 +192,32 @@ bool ECC_InitSanityCheck() {\n     CPubKey pubkey = key.GetPubKey();\n     return key.VerifyPubKey(pubkey);\n }\n+\n+\n+void ECC_Start() {\n+    assert(secp256k1_context == NULL);\n+\n+    secp256k1_context_t *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    assert(ctx != NULL);\n+\n+    {\n+        // Pass in a random blinding seed to the secp256k1 context.\n+        unsigned char seed[32];\n+        LockObject(seed);\n+        GetRandBytes(seed, 32);\n+        bool ret = secp256k1_context_randomize(ctx, seed);\n+        assert(ret);\n+        UnlockObject(seed);\n+    }\n+\n+    secp256k1_context = ctx;\n+}\n+\n+void ECC_Stop() {\n+    secp256k1_context_t *ctx = secp256k1_context;\n+    secp256k1_context = NULL;\n+\n+    if (ctx) {\n+        secp256k1_context_destroy(ctx);\n+    }\n+}"
      },
      {
        "sha": "89f316a14ec62da5d4d70d59f933fe74f554aa50",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a56054be650052361e8de79f0f03a56a043759e5/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a56054be650052361e8de79f0f03a56a043759e5/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=a56054be650052361e8de79f0f03a56a043759e5",
        "patch": "@@ -173,7 +173,13 @@ struct CExtKey {\n     void SetMaster(const unsigned char* seed, unsigned int nSeedLen);\n };\n \n-/** Check that required EC support is available at runtime */\n+/** Initialize the elliptic curve support. May not be called twice without calling ECC_Stop first. */\n+void ECC_Start(void);\n+\n+/** Deinitialize the elliptic curve support. No-op if ECC_Start wasn't called first. */\n+void ECC_Stop(void);\n+\n+/** Check that required EC support is available at runtime. */\n bool ECC_InitSanityCheck(void);\n \n #endif // BITCOIN_KEY_H"
      },
      {
        "sha": "b0745d3dab0ffd00a6ddae239f4ff6afc562d957",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a56054be650052361e8de79f0f03a56a043759e5/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a56054be650052361e8de79f0f03a56a043759e5/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=a56054be650052361e8de79f0f03a56a043759e5",
        "patch": "@@ -6,6 +6,7 @@\n \n #include \"test_bitcoin.h\"\n \n+#include \"key.h\"\n #include \"main.h\"\n #include \"random.h\"\n #include \"txdb.h\"\n@@ -28,13 +29,15 @@ extern void noui_connect();\n \n BasicTestingSetup::BasicTestingSetup()\n {\n+        ECC_Start();\n         SetupEnvironment();\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n         fCheckBlockIndex = true;\n         SelectParams(CBaseChainParams::MAIN);\n }\n BasicTestingSetup::~BasicTestingSetup()\n {\n+        ECC_Stop();\n }\n \n TestingSetup::TestingSetup()"
      }
    ]
  }
]