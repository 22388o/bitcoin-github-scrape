[
  {
    "sha": "fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWMxMmViZjRmM2I3N2IwNTExMmQyYjAwZjhkM2Y0NjY5NjIxYTRj",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-16T10:40:40Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-16T10:57:30Z"
      },
      "message": "net: Avoid redundant and confusing FAILED log\n\nEvery `return false` is preceeded by a detailed debug log message to\nexplain that a disconnect or misbehavior happened. Logging another\ngeneric \"FAILED\" message seems redundant.\n\nAlso, the size of the message and the message type has already been\nlogged and is thus redundant as well.\n\nFinally, claiming that message processing FAILED seems odd, because the\nmessage was fully processed to the point where it was concluded that the\npeer should be either disconnected or marked as misbehaving.",
      "tree": {
        "sha": "843d5220d83d115eb25c23c968098c7f18145a3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/843d5220d83d115eb25c23c968098c7f18145a3a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgXtwv+PyC3v8Fs3los1QmtzyXJuuSJwjOQ/zWD60njeBfIIafzHlOnDgpqnj8d\nqTYPG8WgIT3aHgvPRTbPCEuxlfb51YCWJvOMCmFC8Gwg924Kz9/ffiMjO9hjoxD/\nK9FC79dTFAwHPuWal5hBbHPIgO1oFHrakmgnDomehOICsiAfjtuAzT4PrglHksXi\nbLhBex/QFpWmVhVkmv4M2mY0QNxfpWj4cIy0pjBBRykvx2gFmAXkgpzmALcUNvfO\nspdzuO4oynPya7MyntbyhpfXEjJmduhtvdREGZI3oRu53+0S3ggtL5bKWQ8+L56f\nlylVu5Scpst0ShT+UrPgbEDjSnSWAw1OpsXhg4Na8hbr4+OfhDnVxJCyIdF7M/l6\ncjf8F9wpMXFVh2cJNA7U+8souLpaX4qN6wTo+UZfgaTN/U71mTzh4gbmP4LgmfZU\n5L22HQSB0sDjVVCF3TKJQ0jfegsdKYRYwCdB/PKohADATjz3+CCbNnHryG2du+EB\nhgD/L6jv\n=BelH\n-----END PGP SIGNATURE-----",
        "payload": "tree 843d5220d83d115eb25c23c968098c7f18145a3a\nparent 46bdd4b537cbf9a25ce170eb6831c2b092eacbc8\nauthor MarcoFalke <falke.marco@gmail.com> 1592304040 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1592305050 -0400\n\nnet: Avoid redundant and confusing FAILED log\n\nEvery `return false` is preceeded by a detailed debug log message to\nexplain that a disconnect or misbehavior happened. Logging another\ngeneric \"FAILED\" message seems redundant.\n\nAlso, the size of the message and the message type has already been\nlogged and is thus redundant as well.\n\nFinally, claiming that message processing FAILED seems odd, because the\nmessage was fully processed to the point where it was concluded that the\npeer should be either disconnected or marked as misbehaving.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "46bdd4b537cbf9a25ce170eb6831c2b092eacbc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46bdd4b537cbf9a25ce170eb6831c2b092eacbc8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/46bdd4b537cbf9a25ce170eb6831c2b092eacbc8"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "8019343fd81e263d08c0fe0e30afb0497fcb39d9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
        "patch": "@@ -1793,7 +1793,7 @@ bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n         for (const CBlockHeader& header : headers) {\n             if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n                 Misbehaving(pfrom.GetId(), 20, \"non-continuous headers sequence\");\n-                return false;\n+                return true;\n             }\n             hashLastBlock = header.GetHash();\n         }\n@@ -1809,7 +1809,7 @@ bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n     if (!chainman.ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n         if (state.IsInvalid()) {\n             MaybePunishNodeForBlock(pfrom.GetId(), state, via_compact_block, \"invalid header received\");\n-            return false;\n+            return true;\n         }\n     }\n \n@@ -2221,7 +2221,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 1);\n-            return false;\n+            return true;\n         }\n \n         int64_t nTime;\n@@ -2247,14 +2247,14 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom.GetId(), nServices, GetDesirableServiceFlags(nServices));\n             pfrom.fDisconnect = true;\n-            return false;\n+            return true;\n         }\n \n         if (nVersion < MIN_PEER_PROTO_VERSION) {\n             // disconnect from peers older than this proto version\n             LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom.GetId(), nVersion);\n             pfrom.fDisconnect = true;\n-            return false;\n+            return true;\n         }\n \n         if (!vRecv.empty())\n@@ -2381,7 +2381,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         // Must have a version message before anything else\n         LOCK(cs_main);\n         Misbehaving(pfrom.GetId(), 1);\n-        return false;\n+        return true;\n     }\n \n     // At this point, the outgoing message serialization version can't change.\n@@ -2429,7 +2429,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         // Must have a verack message before anything else\n         LOCK(cs_main);\n         Misbehaving(pfrom.GetId(), 1);\n-        return false;\n+        return true;\n     }\n \n     if (msg_type == NetMsgType::ADDR) {\n@@ -2446,7 +2446,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n-            return false;\n+            return true;\n         }\n \n         // Store the new addresses\n@@ -2522,7 +2522,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n-            return false;\n+            return true;\n         }\n \n         // We won't accept tx inv's if we're in blocks-only mode, or this is a\n@@ -2588,7 +2588,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n-            return false;\n+            return true;\n         }\n \n         LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom.GetId());\n@@ -3246,7 +3246,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         if (nCount > MAX_HEADERS_RESULTS) {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n-            return false;\n+            return true;\n         }\n         headers.resize(nCount);\n         for (unsigned int n = 0; n < nCount; n++) {"
      }
    ]
  },
  {
    "sha": "fa1904e5f0d164fbcf41398f9ebbaafe82c28419",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTE5MDRlNWYwZDE2NGZiY2Y0MTM5OGY5ZWJiYWFmZTgyYzI4NDE5",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-16T10:58:06Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-06-16T10:57:39Z"
      },
      "message": "net: Remove dead logging code\n\nfRet is never false, so the dead code can be removed and the return type\ncan be made void",
      "tree": {
        "sha": "30133ee0ee49fcd8e7e825cbd83525ae93675509",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30133ee0ee49fcd8e7e825cbd83525ae93675509"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa1904e5f0d164fbcf41398f9ebbaafe82c28419",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgtKQv9FEfAY39aOdVZdrXpaMc4KXUP6pI2KT5rc8V609Ij21GX8m0Ufqdz6cRk\nJzDuWWWhRztB3zCDFpDff7qcC4QnWXZO4tMR7cabQcS3fzbkdPXtXPyKpvoIajVG\n9rkDtWDUgj4sl+/wBdjI+6cO+MXPoNHmC01TmjE9wsJujXYQrIBqr4zLtOErRMl9\nxxPBUTMYqi/+yVQhyZrvo07UZXq/BC1180hCYah3pOFIx8bXgXnwdXrkdDQnxxRg\nR1uPMtg4omTqaPh5gpYm1I3BxRsLesfqNxulpLIHbz8WeMo1N10EP4FQyMwhlkM7\nhvOhbiGPb7rOSXIDd/TTYJVyy0JupN1caQNl7UqDSsa8eyv+ZREWjf3sccR3JcNQ\n36xduH6DcM1GWOVFmpCsl8I7u5GVFPz0hD01jZCI7SiT8tPHHx6DuAZ7oXfKhPCv\n1WrYWTfPBHIjN7KsR6g8O3ZJq/2S8dhYvpN7FRApkFUB1fuftjZeyXzM7Gmg1U2M\nPUV2SY93\n=7hkN\n-----END PGP SIGNATURE-----",
        "payload": "tree 30133ee0ee49fcd8e7e825cbd83525ae93675509\nparent fac12ebf4f3b77b05112d2b00f8d3f4669621a4c\nauthor MarcoFalke <falke.marco@gmail.com> 1592305086 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1592305059 -0400\n\nnet: Remove dead logging code\n\nfRet is never false, so the dead code can be removed and the return type\ncan be made void\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1904e5f0d164fbcf41398f9ebbaafe82c28419",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa1904e5f0d164fbcf41398f9ebbaafe82c28419",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1904e5f0d164fbcf41398f9ebbaafe82c28419/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fac12ebf4f3b77b05112d2b00f8d3f4669621a4c"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 112,
      "deletions": 96
    },
    "files": [
      {
        "sha": "a7a90adf3f1090811a13896c02f2c660c546cbf8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 94,
        "changes": 191,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1904e5f0d164fbcf41398f9ebbaafe82c28419/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1904e5f0d164fbcf41398f9ebbaafe82c28419/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa1904e5f0d164fbcf41398f9ebbaafe82c28419",
        "patch": "@@ -1746,14 +1746,14 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateManager& chainman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateManager& chainman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n {\n     const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n     size_t nCount = headers.size();\n \n     if (nCount == 0) {\n         // Nothing interesting. Stop asking this peers for more headers.\n-        return true;\n+        return;\n     }\n \n     bool received_new_header = false;\n@@ -1786,14 +1786,14 @@ bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n             if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n                 Misbehaving(pfrom.GetId(), 20);\n             }\n-            return true;\n+            return;\n         }\n \n         uint256 hashLastBlock;\n         for (const CBlockHeader& header : headers) {\n             if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n                 Misbehaving(pfrom.GetId(), 20, \"non-continuous headers sequence\");\n-                return true;\n+                return;\n             }\n             hashLastBlock = header.GetHash();\n         }\n@@ -1809,7 +1809,7 @@ bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n     if (!chainman.ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n         if (state.IsInvalid()) {\n             MaybePunishNodeForBlock(pfrom.GetId(), state, via_compact_block, \"invalid header received\");\n-            return true;\n+            return;\n         }\n     }\n \n@@ -1925,7 +1925,7 @@ bool static ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n         }\n     }\n \n-    return true;\n+    return;\n }\n \n void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n@@ -2205,13 +2205,23 @@ static void ProcessGetCFCheckPt(CNode& pfrom, CDataStream& vRecv, const CChainPa\n     connman.PushMessage(&pfrom, std::move(msg));\n }\n \n-bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, ChainstateManager& chainman, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc)\n+void ProcessMessage(\n+    CNode& pfrom,\n+    const std::string& msg_type,\n+    CDataStream& vRecv,\n+    int64_t nTimeReceived,\n+    const CChainParams& chainparams,\n+    ChainstateManager& chainman,\n+    CTxMemPool& mempool,\n+    CConnman* connman,\n+    BanMan* banman,\n+    const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(msg_type), vRecv.size(), pfrom.GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n-        return true;\n+        return;\n     }\n \n \n@@ -2221,7 +2231,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 1);\n-            return true;\n+            return;\n         }\n \n         int64_t nTime;\n@@ -2247,14 +2257,14 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom.GetId(), nServices, GetDesirableServiceFlags(nServices));\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n \n         if (nVersion < MIN_PEER_PROTO_VERSION) {\n             // disconnect from peers older than this proto version\n             LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom.GetId(), nVersion);\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n \n         if (!vRecv.empty())\n@@ -2274,7 +2284,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom.addr.ToString());\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n \n         if (pfrom.fInbound && addrMe.IsRoutable())\n@@ -2374,14 +2384,14 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             assert(pfrom.fInbound == false);\n             pfrom.fDisconnect = true;\n         }\n-        return true;\n+        return;\n     }\n \n     if (pfrom.nVersion == 0) {\n         // Must have a version message before anything else\n         LOCK(cs_main);\n         Misbehaving(pfrom.GetId(), 1);\n-        return true;\n+        return;\n     }\n \n     // At this point, the outgoing message serialization version can't change.\n@@ -2422,14 +2432,14 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom.fSuccessfullyConnected = true;\n-        return true;\n+        return;\n     }\n \n     if (!pfrom.fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n         LOCK(cs_main);\n         Misbehaving(pfrom.GetId(), 1);\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::ADDR) {\n@@ -2438,15 +2448,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n \n         // Don't want addr from older versions unless seeding\n         if (pfrom.nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)\n-            return true;\n+            return;\n         if (!pfrom.IsAddrRelayPeer()) {\n-            return true;\n+            return;\n         }\n         if (vAddr.size() > 1000)\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n-            return true;\n+            return;\n         }\n \n         // Store the new addresses\n@@ -2456,7 +2466,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         for (CAddress& addr : vAddr)\n         {\n             if (interruptMsgProc)\n-                return true;\n+                return;\n \n             // We only bother storing full nodes, though this may include\n             // things which we would not make an outbound connection to, in\n@@ -2483,13 +2493,13 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             pfrom.fGetAddr = false;\n         if (pfrom.fOneShot)\n             pfrom.fDisconnect = true;\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::SENDHEADERS) {\n         LOCK(cs_main);\n         State(pfrom.GetId())->fPreferHeaders = true;\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::SENDCMPCT) {\n@@ -2512,7 +2522,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                     State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n             }\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::INV) {\n@@ -2522,7 +2532,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n-            return true;\n+            return;\n         }\n \n         // We won't accept tx inv's if we're in blocks-only mode, or this is a\n@@ -2542,7 +2552,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         for (CInv &inv : vInv)\n         {\n             if (interruptMsgProc)\n-                return true;\n+                return;\n \n             bool fAlreadyHave = AlreadyHave(inv, mempool);\n             LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n@@ -2566,7 +2576,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 if (fBlocksOnly) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom.GetId());\n                     pfrom.fDisconnect = true;\n-                    return true;\n+                    return;\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !::ChainstateActive().IsInitialBlockDownload()) {\n                     RequestTx(State(pfrom.GetId()), inv.hash, current_time);\n                 }\n@@ -2578,7 +2588,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETDATA) {\n@@ -2588,7 +2598,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n-            return true;\n+            return;\n         }\n \n         LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom.GetId());\n@@ -2599,7 +2609,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n \n         pfrom.vRecvGetData.insert(pfrom.vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom, chainparams, connman, mempool, interruptMsgProc);\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETBLOCKS) {\n@@ -2610,7 +2620,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         if (locator.vHave.size() > MAX_LOCATOR_SZ) {\n             LogPrint(BCLog::NET, \"getblocks locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom.GetId());\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n \n         // We might have announced the currently-being-connected tip using a\n@@ -2667,7 +2677,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 break;\n             }\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETBLOCKTXN) {\n@@ -2683,15 +2693,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         }\n         if (recent_block) {\n             SendBlockTransactions(*recent_block, req, pfrom, connman);\n-            return true;\n+            return;\n         }\n \n         LOCK(cs_main);\n \n         const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);\n         if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n             LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         if (pindex->nHeight < ::ChainActive().Height() - MAX_BLOCKTXN_DEPTH) {\n@@ -2708,15 +2718,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             inv.hash = req.blockhash;\n             pfrom.vRecvGetData.push_back(inv);\n             // The message processing loop will go around again (without pausing) and we'll respond then (without cs_main)\n-            return true;\n+            return;\n         }\n \n         CBlock block;\n         bool ret = ReadBlockFromDisk(block, pindex, chainparams.GetConsensus());\n         assert(ret);\n \n         SendBlockTransactions(block, req, pfrom, connman);\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETHEADERS) {\n@@ -2727,13 +2737,13 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         if (locator.vHave.size() > MAX_LOCATOR_SZ) {\n             LogPrint(BCLog::NET, \"getheaders locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom.GetId());\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n \n         LOCK(cs_main);\n         if (::ChainstateActive().IsInitialBlockDownload() && !pfrom.HasPermission(PF_NOBAN)) {\n             LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         CNodeState *nodestate = State(pfrom.GetId());\n@@ -2743,12 +2753,12 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             // If locator is null, return the hashStop block\n             pindex = LookupBlockIndex(hashStop);\n             if (!pindex) {\n-                return true;\n+                return;\n             }\n \n             if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {\n                 LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom.GetId());\n-                return true;\n+                return;\n             }\n         }\n         else\n@@ -2783,7 +2793,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n         connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::TX) {\n@@ -2794,7 +2804,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n \n         CTransactionRef ptx;\n@@ -2925,15 +2935,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 state.ToString());\n             MaybePunishNodeForTx(pfrom.GetId(), state);\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::CMPCTBLOCK)\n     {\n         // Ignore cmpctblock received while importing\n         if (fImporting || fReindex) {\n             LogPrint(BCLog::NET, \"Unexpected cmpctblock message received from peer %d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         CBlockHeaderAndShortTxIDs cmpctblock;\n@@ -2948,7 +2958,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!::ChainstateActive().IsInitialBlockDownload())\n                 connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n-            return true;\n+            return;\n         }\n \n         if (!LookupBlockIndex(cmpctblock.header.GetHash())) {\n@@ -2961,7 +2971,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         if (!chainman.ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n             if (state.IsInvalid()) {\n                 MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n-                return true;\n+                return;\n             }\n         }\n \n@@ -2999,7 +3009,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n-            return true;\n+            return;\n \n         if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n@@ -3010,17 +3020,17 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n-            return true;\n+            return;\n         }\n \n         // If we're not close to tip yet, give up and let parallel block fetch work its magic\n         if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n-            return true;\n+            return;\n \n         if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n             // Don't bother trying to process compact blocks from v1 peers\n             // after segwit activates.\n-            return true;\n+            return;\n         }\n \n         // We want to be a bit conservative just to be extra careful about DoS\n@@ -3035,7 +3045,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                     else {\n                         // The block was already in flight using compact blocks from the same peer\n                         LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");\n-                        return true;\n+                        return;\n                     }\n                 }\n \n@@ -3044,13 +3054,13 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us invalid compact block\\n\", pfrom.GetId()));\n-                    return true;\n+                    return;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                     connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n-                    return true;\n+                    return;\n                 }\n \n                 BlockTransactionsRequest req;\n@@ -3078,7 +3088,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 ReadStatus status = tempBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status != READ_STATUS_OK) {\n                     // TODO: don't ignore failures\n-                    return true;\n+                    return;\n                 }\n                 std::vector<CTransactionRef> dummy;\n                 status = tempBlock.FillBlock(*pblock, dummy);\n@@ -3093,7 +3103,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n-                return true;\n+                return;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n                 fRevertToHeaderProcessing = true;\n@@ -3146,15 +3156,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 MarkBlockAsReceived(pblock->GetHash());\n             }\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::BLOCKTXN)\n     {\n         // Ignore blocktxn received while importing\n         if (fImporting || fReindex) {\n             LogPrint(BCLog::NET, \"Unexpected blocktxn message received from peer %d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         BlockTransactions resp;\n@@ -3169,15 +3179,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom.GetId()) {\n                 LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom.GetId());\n-                return true;\n+                return;\n             }\n \n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom.GetId()));\n-                return true;\n+                return;\n             } else if (status == READ_STATUS_FAILED) {\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n@@ -3228,15 +3238,15 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::HEADERS)\n     {\n         // Ignore headers received while importing\n         if (fImporting || fReindex) {\n             LogPrint(BCLog::NET, \"Unexpected headers message received from peer %d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         std::vector<CBlockHeader> headers;\n@@ -3246,7 +3256,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         if (nCount > MAX_HEADERS_RESULTS) {\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n-            return true;\n+            return;\n         }\n         headers.resize(nCount);\n         for (unsigned int n = 0; n < nCount; n++) {\n@@ -3262,7 +3272,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         // Ignore block received while importing\n         if (fImporting || fReindex) {\n             LogPrint(BCLog::NET, \"Unexpected block message received from peer %d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n@@ -3290,7 +3300,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             LOCK(cs_main);\n             mapBlockSource.erase(pblock->GetHash());\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETADDR) {\n@@ -3301,18 +3311,18 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         // the getaddr message mitigates the attack.\n         if (!pfrom.fInbound) {\n             LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n         if (!pfrom.IsAddrRelayPeer()) {\n             LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from block-relay-only connection. peer=%d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n         if (pfrom.fSentAddr) {\n             LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom.GetId());\n-            return true;\n+            return;\n         }\n         pfrom.fSentAddr = true;\n \n@@ -3324,7 +3334,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 pfrom.PushAddress(addr, insecure_rand);\n             }\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::MEMPOOL) {\n@@ -3335,7 +3345,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom.GetId());\n                 pfrom.fDisconnect = true;\n             }\n-            return true;\n+            return;\n         }\n \n         if (connman->OutboundTargetReached(false) && !pfrom.HasPermission(PF_MEMPOOL))\n@@ -3345,14 +3355,14 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n                 pfrom.fDisconnect = true;\n             }\n-            return true;\n+            return;\n         }\n \n         if (pfrom.m_tx_relay != nullptr) {\n             LOCK(pfrom.m_tx_relay->cs_tx_inventory);\n             pfrom.m_tx_relay->fSendMempool = true;\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::PING) {\n@@ -3373,7 +3383,7 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             // return very quickly.\n             connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::PONG) {\n@@ -3429,13 +3439,13 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n         if (bPingFinished) {\n             pfrom.nPingNonceSent = 0;\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::FILTERLOAD) {\n         if (!(pfrom.GetLocalServices() & NODE_BLOOM)) {\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n         CBloomFilter filter;\n         vRecv >> filter;\n@@ -3452,13 +3462,13 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             pfrom.m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n             pfrom.m_tx_relay->fRelayTxes = true;\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::FILTERADD) {\n         if (!(pfrom.GetLocalServices() & NODE_BLOOM)) {\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n         std::vector<unsigned char> vData;\n         vRecv >> vData;\n@@ -3480,21 +3490,21 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             LOCK(cs_main);\n             Misbehaving(pfrom.GetId(), 100);\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::FILTERCLEAR) {\n         if (!(pfrom.GetLocalServices() & NODE_BLOOM)) {\n             pfrom.fDisconnect = true;\n-            return true;\n+            return;\n         }\n         if (pfrom.m_tx_relay == nullptr) {\n-            return true;\n+            return;\n         }\n         LOCK(pfrom.m_tx_relay->cs_filter);\n         pfrom.m_tx_relay->pfilter = nullptr;\n         pfrom.m_tx_relay->fRelayTxes = true;\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::FEEFILTER) {\n@@ -3507,22 +3517,22 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom.GetId());\n         }\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETCFILTERS) {\n         ProcessGetCFilters(pfrom, vRecv, chainparams, *connman);\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETCFHEADERS) {\n         ProcessGetCFHeaders(pfrom, vRecv, chainparams, *connman);\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::GETCFCHECKPT) {\n         ProcessGetCFCheckPt(pfrom, vRecv, chainparams, *connman);\n-        return true;\n+        return;\n     }\n \n     if (msg_type == NetMsgType::NOTFOUND) {\n@@ -3547,12 +3557,12 @@ bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRec\n                 }\n             }\n         }\n-        return true;\n+        return;\n     }\n \n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n-    return true;\n+    return;\n }\n \n bool PeerLogicValidation::CheckIfBanned(CNode& pnode)\n@@ -3660,11 +3670,8 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         return fMoreWork;\n     }\n \n-    // Process message\n-    bool fRet = false;\n-    try\n-    {\n-        fRet = ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, connman, m_banman, interruptMsgProc);\n+    try {\n+        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, connman, m_banman, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3675,10 +3682,6 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         LogPrint(BCLog::NET, \"%s(%s, %u bytes): Unknown exception caught\\n\", __func__, SanitizeString(msg_type), nMessageSize);\n     }\n \n-    if (!fRet) {\n-        LogPrint(BCLog::NET, \"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(msg_type), nMessageSize, pfrom->GetId());\n-    }\n-\n     LOCK(cs_main);\n     CheckIfBanned(*pfrom);\n "
      },
      {
        "sha": "2fa751b987e17b80ec8d28a357290da2760eda69",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1904e5f0d164fbcf41398f9ebbaafe82c28419/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1904e5f0d164fbcf41398f9ebbaafe82c28419/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=fa1904e5f0d164fbcf41398f9ebbaafe82c28419",
        "patch": "@@ -30,7 +30,17 @@\n #include <string>\n #include <vector>\n \n-bool ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, ChainstateManager& chainman, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc);\n+void ProcessMessage(\n+    CNode& pfrom,\n+    const std::string& msg_type,\n+    CDataStream& vRecv,\n+    int64_t nTimeReceived,\n+    const CChainParams& chainparams,\n+    ChainstateManager& chainman,\n+    CTxMemPool& mempool,\n+    CConnman* connman,\n+    BanMan* banman,\n+    const std::atomic<bool>& interruptMsgProc);\n \n namespace {\n \n@@ -77,7 +87,10 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     connman.AddTestNode(p2p_node);\n     g_setup->m_node.peer_logic->InitializeNode(&p2p_node);\n     try {\n-        (void)ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream, GetTimeMillis(), Params(), *g_setup->m_node.chainman, *g_setup->m_node.mempool, g_setup->m_node.connman.get(), g_setup->m_node.banman.get(), std::atomic<bool>{false});\n+        ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream, GetTimeMillis(),\n+            Params(), *g_setup->m_node.chainman, *g_setup->m_node.mempool,\n+            g_setup->m_node.connman.get(), g_setup->m_node.banman.get(),\n+            std::atomic<bool>{false});\n     } catch (const std::ios_base::failure&) {\n     }\n     SyncWithValidationInterfaceQueue();"
      }
    ]
  }
]