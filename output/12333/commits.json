[
  {
    "sha": "1beea7af92994dca83facb11bbef82b24b538400",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYmVlYTdhZjkyOTk0ZGNhODNmYWNiMTFiYmVmODJiMjRiNTM4NDAw",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-02-02T11:37:50Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-02-08T18:18:28Z"
      },
      "message": "[wallet] Make CWallet::ListCoins atomic",
      "tree": {
        "sha": "b0864ca2b002fb57e38a80f7902eb3ce0aced1fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b0864ca2b002fb57e38a80f7902eb3ce0aced1fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1beea7af92994dca83facb11bbef82b24b538400",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1beea7af92994dca83facb11bbef82b24b538400",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1beea7af92994dca83facb11bbef82b24b538400",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1beea7af92994dca83facb11bbef82b24b538400/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4cad91663df381d0dff8526f3b4aa74569dfb626",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cad91663df381d0dff8526f3b4aa74569dfb626",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4cad91663df381d0dff8526f3b4aa74569dfb626"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 17,
      "deletions": 10
    },
    "files": [
      {
        "sha": "161372784b1f76794e7b27c5a1f83e88dfe34565",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1beea7af92994dca83facb11bbef82b24b538400/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1beea7af92994dca83facb11bbef82b24b538400/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=1beea7af92994dca83facb11bbef82b24b538400",
        "patch": "@@ -676,18 +676,24 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     BOOST_CHECK_EQUAL(list.begin()->second.size(), 2);\n \n     // Lock both coins. Confirm number of available coins drops to 0.\n-    std::vector<COutput> available;\n-    wallet->AvailableCoins(available);\n-    BOOST_CHECK_EQUAL(available.size(), 2);\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        std::vector<COutput> available;\n+        wallet->AvailableCoins(available);\n+        BOOST_CHECK_EQUAL(available.size(), 2);\n+    }\n     for (const auto& group : list) {\n         for (const auto& coin : group.second) {\n             LOCK(wallet->cs_wallet);\n             wallet->LockCoin(COutPoint(coin.tx->GetHash(), coin.i));\n         }\n     }\n-    wallet->AvailableCoins(available);\n-    BOOST_CHECK_EQUAL(available.size(), 0);\n-\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        std::vector<COutput> available;\n+        wallet->AvailableCoins(available);\n+        BOOST_CHECK_EQUAL(available.size(), 0);\n+    }\n     // Confirm ListCoins still returns same result as before, despite coins\n     // being locked.\n     list = wallet->ListCoins();"
      },
      {
        "sha": "e89921e95b8165c82f8c2410f9879ec6d98dfe46",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1beea7af92994dca83facb11bbef82b24b538400/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1beea7af92994dca83facb11bbef82b24b538400/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1beea7af92994dca83facb11bbef82b24b538400",
        "patch": "@@ -2198,11 +2198,12 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n \n void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t nMaximumCount, const int nMinDepth, const int nMaxDepth) const\n {\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_wallet);\n+\n     vCoins.clear();\n \n     {\n-        LOCK2(cs_main, cs_wallet);\n-\n         CAmount nTotal = 0;\n \n         for (const auto& entry : mapWallet)\n@@ -2320,11 +2321,11 @@ std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n     // avoid adding some extra complexity to the Qt code.\n \n     std::map<CTxDestination, std::vector<COutput>> result;\n-\n     std::vector<COutput> availableCoins;\n-    AvailableCoins(availableCoins);\n \n     LOCK2(cs_main, cs_wallet);\n+    AvailableCoins(availableCoins);\n+\n     for (auto& coin : availableCoins) {\n         CTxDestination address;\n         if (coin.fSpendable &&"
      }
    ]
  },
  {
    "sha": "2f960b50703a9599b82b7291139b428f4a9b96c3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjk2MGI1MDcwM2E5NTk5YjgyYjcyOTExMzliNDI4ZjRhOWI5NmMz",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-02-08T18:18:51Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2018-02-08T18:18:51Z"
      },
      "message": "[wallet] Indent only change of CWallet::AvailableCoins",
      "tree": {
        "sha": "1ce2ab66897dfc9fa4e88ac9de3ee461854417e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ce2ab66897dfc9fa4e88ac9de3ee461854417e3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f960b50703a9599b82b7291139b428f4a9b96c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f960b50703a9599b82b7291139b428f4a9b96c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f960b50703a9599b82b7291139b428f4a9b96c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f960b50703a9599b82b7291139b428f4a9b96c3/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1beea7af92994dca83facb11bbef82b24b538400",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1beea7af92994dca83facb11bbef82b24b538400",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1beea7af92994dca83facb11bbef82b24b538400"
      }
    ],
    "stats": {
      "total": 153,
      "additions": 75,
      "deletions": 78
    },
    "files": [
      {
        "sha": "068aa9fdd1e8dfaffdd04882be9842b1ac48be61",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 78,
        "changes": 153,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f960b50703a9599b82b7291139b428f4a9b96c3/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f960b50703a9599b82b7291139b428f4a9b96c3/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2f960b50703a9599b82b7291139b428f4a9b96c3",
        "patch": "@@ -2202,108 +2202,105 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n     AssertLockHeld(cs_wallet);\n \n     vCoins.clear();\n+    CAmount nTotal = 0;\n \n+    for (const auto& entry : mapWallet)\n     {\n-        CAmount nTotal = 0;\n+        const uint256& wtxid = entry.first;\n+        const CWalletTx* pcoin = &entry.second;\n \n-        for (const auto& entry : mapWallet)\n-        {\n-            const uint256& wtxid = entry.first;\n-            const CWalletTx* pcoin = &entry.second;\n+        if (!CheckFinalTx(*pcoin->tx))\n+            continue;\n \n-            if (!CheckFinalTx(*pcoin->tx))\n-                continue;\n+        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+            continue;\n \n-            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n-                continue;\n+        int nDepth = pcoin->GetDepthInMainChain();\n+        if (nDepth < 0)\n+            continue;\n \n-            int nDepth = pcoin->GetDepthInMainChain();\n-            if (nDepth < 0)\n-                continue;\n+        // We should not consider coins which aren't at least in our mempool\n+        // It's possible for these to be conflicted via ancestors which we may never be able to detect\n+        if (nDepth == 0 && !pcoin->InMempool())\n+            continue;\n \n-            // We should not consider coins which aren't at least in our mempool\n-            // It's possible for these to be conflicted via ancestors which we may never be able to detect\n-            if (nDepth == 0 && !pcoin->InMempool())\n-                continue;\n+        bool safeTx = pcoin->IsTrusted();\n+\n+        // We should not consider coins from transactions that are replacing\n+        // other transactions.\n+        //\n+        // Example: There is a transaction A which is replaced by bumpfee\n+        // transaction B. In this case, we want to prevent creation of\n+        // a transaction B' which spends an output of B.\n+        //\n+        // Reason: If transaction A were initially confirmed, transactions B\n+        // and B' would no longer be valid, so the user would have to create\n+        // a new transaction C to replace B'. However, in the case of a\n+        // one-block reorg, transactions B' and C might BOTH be accepted,\n+        // when the user only wanted one of them. Specifically, there could\n+        // be a 1-block reorg away from the chain where transactions A and C\n+        // were accepted to another chain where B, B', and C were all\n+        // accepted.\n+        if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {\n+            safeTx = false;\n+        }\n \n-            bool safeTx = pcoin->IsTrusted();\n-\n-            // We should not consider coins from transactions that are replacing\n-            // other transactions.\n-            //\n-            // Example: There is a transaction A which is replaced by bumpfee\n-            // transaction B. In this case, we want to prevent creation of\n-            // a transaction B' which spends an output of B.\n-            //\n-            // Reason: If transaction A were initially confirmed, transactions B\n-            // and B' would no longer be valid, so the user would have to create\n-            // a new transaction C to replace B'. However, in the case of a\n-            // one-block reorg, transactions B' and C might BOTH be accepted,\n-            // when the user only wanted one of them. Specifically, there could\n-            // be a 1-block reorg away from the chain where transactions A and C\n-            // were accepted to another chain where B, B', and C were all\n-            // accepted.\n-            if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {\n-                safeTx = false;\n-            }\n+        // Similarly, we should not consider coins from transactions that\n+        // have been replaced. In the example above, we would want to prevent\n+        // creation of a transaction A' spending an output of A, because if\n+        // transaction B were initially confirmed, conflicting with A and\n+        // A', we wouldn't want to the user to create a transaction D\n+        // intending to replace A', but potentially resulting in a scenario\n+        // where A, A', and D could all be accepted (instead of just B and\n+        // D, or just A and A' like the user would want).\n+        if (nDepth == 0 && pcoin->mapValue.count(\"replaced_by_txid\")) {\n+            safeTx = false;\n+        }\n \n-            // Similarly, we should not consider coins from transactions that\n-            // have been replaced. In the example above, we would want to prevent\n-            // creation of a transaction A' spending an output of A, because if\n-            // transaction B were initially confirmed, conflicting with A and\n-            // A', we wouldn't want to the user to create a transaction D\n-            // intending to replace A', but potentially resulting in a scenario\n-            // where A, A', and D could all be accepted (instead of just B and\n-            // D, or just A and A' like the user would want).\n-            if (nDepth == 0 && pcoin->mapValue.count(\"replaced_by_txid\")) {\n-                safeTx = false;\n-            }\n+        if (fOnlySafe && !safeTx) {\n+            continue;\n+        }\n \n-            if (fOnlySafe && !safeTx) {\n-                continue;\n-            }\n+        if (nDepth < nMinDepth || nDepth > nMaxDepth)\n+            continue;\n \n-            if (nDepth < nMinDepth || nDepth > nMaxDepth)\n+        for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n+            if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n                 continue;\n \n-            for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n-                if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n-                    continue;\n-\n-                if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n-                    continue;\n-\n-                if (IsLockedCoin(entry.first, i))\n-                    continue;\n+            if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n+                continue;\n \n-                if (IsSpent(wtxid, i))\n-                    continue;\n+            if (IsLockedCoin(entry.first, i))\n+                continue;\n \n-                isminetype mine = IsMine(pcoin->tx->vout[i]);\n+            if (IsSpent(wtxid, i))\n+                continue;\n \n-                if (mine == ISMINE_NO) {\n-                    continue;\n-                }\n+            isminetype mine = IsMine(pcoin->tx->vout[i]);\n \n-                bool fSpendableIn = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO);\n-                bool fSolvableIn = (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO;\n+            if (mine == ISMINE_NO) {\n+                continue;\n+            }\n \n-                vCoins.push_back(COutput(pcoin, i, nDepth, fSpendableIn, fSolvableIn, safeTx));\n+            bool fSpendableIn = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO);\n+            bool fSolvableIn = (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO;\n \n-                // Checks the sum amount of all UTXO's.\n-                if (nMinimumSumAmount != MAX_MONEY) {\n-                    nTotal += pcoin->tx->vout[i].nValue;\n+            vCoins.push_back(COutput(pcoin, i, nDepth, fSpendableIn, fSolvableIn, safeTx));\n \n-                    if (nTotal >= nMinimumSumAmount) {\n-                        return;\n-                    }\n-                }\n+            // Checks the sum amount of all UTXO's.\n+            if (nMinimumSumAmount != MAX_MONEY) {\n+                nTotal += pcoin->tx->vout[i].nValue;\n \n-                // Checks the maximum number of UTXO's.\n-                if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n+                if (nTotal >= nMinimumSumAmount) {\n                     return;\n                 }\n             }\n+\n+            // Checks the maximum number of UTXO's.\n+            if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n+                return;\n+            }\n         }\n     }\n }"
      }
    ]
  }
]