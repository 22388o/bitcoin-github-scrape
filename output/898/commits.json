[
  {
    "sha": "ec0e83664f149193ce42c64d7fd13cd1aa268be8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzBlODM2NjRmMTQ5MTkzY2U0MmM2NGQ3ZmQxM2NkMWFhMjY4YmU4",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-02-27T12:19:32Z"
      },
      "committer": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-02-27T12:19:32Z"
      },
      "message": "Refactor SelectCoinsMinConf() and add unit tests.\n\nAvailableCoins() makes a vector of available outputs which is then passed to SelectCoinsMinConf().  This allows unit tests to test the coin selection algorithm without having the whole blockchain available.",
      "tree": {
        "sha": "6f4ede5aadedfc22f4a46eafe00e616d2de8febe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f4ede5aadedfc22f4a46eafe00e616d2de8febe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec0e83664f149193ce42c64d7fd13cd1aa268be8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec0e83664f149193ce42c64d7fd13cd1aa268be8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec0e83664f149193ce42c64d7fd13cd1aa268be8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec0e83664f149193ce42c64d7fd13cd1aa268be8/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3d2b5c53cbae7ee6a2be0610e3826a5aec11b5f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d2b5c53cbae7ee6a2be0610e3826a5aec11b5f3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3d2b5c53cbae7ee6a2be0610e3826a5aec11b5f3"
      }
    ],
    "stats": {
      "total": 391,
      "additions": 343,
      "deletions": 48
    },
    "files": [
      {
        "sha": "705609464aaea184ca864efdb816117cf10aa676",
        "filename": "src/test/wallet_tests.cpp",
        "status": "added",
        "additions": 256,
        "deletions": 0,
        "changes": 256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec0e83664f149193ce42c64d7fd13cd1aa268be8/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec0e83664f149193ce42c64d7fd13cd1aa268be8/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=ec0e83664f149193ce42c64d7fd13cd1aa268be8",
        "patch": "@@ -0,0 +1,256 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"main.h\"\n+#include \"wallet.h\"\n+\n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// enables tests which currently fail, due to code which tries too hard to avoid sub-cent change\n+// #define STRICT\n+\n+using namespace std;\n+\n+BOOST_AUTO_TEST_SUITE(wallet_tests)\n+\n+static CWallet wallet;\n+static vector<COutput> vCoins;\n+\n+static void add_coin(int64 nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    static int i;\n+    CTransaction* tx = new CTransaction;\n+    tx->nLockTime = i++;        // so all transactions get different hashes\n+    tx->vout.resize(nInput+1);\n+    tx->vout[nInput].nValue = nValue;\n+    CWalletTx* wtx = new CWalletTx(&wallet, *tx);\n+    delete tx;\n+    if (fIsFromMe)\n+    {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        wtx->vin.resize(1);\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx, nInput, nAge);\n+    vCoins.push_back(output);\n+}\n+\n+static void empty_wallet(void)\n+{\n+    BOOST_FOREACH(COutput output, vCoins)\n+        delete output.tx;\n+    vCoins.clear();\n+}\n+\n+BOOST_AUTO_TEST_CASE(coin_selection_tests)\n+{\n+    static set<pair<const CWalletTx*,unsigned int> > setCoinsRet;\n+    static int64 nValueRet;\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // we can make 3 cents of new  coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 6, 6, vCoins, setCoinsRet, nValueRet));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_GT(nValueRet, 34 * CENT);         // but should get more than 34 cents\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  I'd hope to see just 2+5, but 1 gets included too\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+#else\n+        BOOST_CHECK(nValueRet == 7 * CENT || nValueRet == 8 * CENT);\n+        BOOST_CHECK(setCoinsRet.size() == 2 || setCoinsRet.size() == 3);\n+#endif\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // now clear out the wallet and start again to test chosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(72 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we hope for 5+6 but get 5+7 due to fear of sub-cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+#else\n+        BOOST_CHECK(nValueRet == 11 * CENT || nValueRet == 12 * CENT);\n+#endif\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 bitcoin in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 bitcoins in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test sub-cent change avoidance\n+        empty_wallet();\n+        add_coin(0.1*CENT);\n+        add_coin(0.2*CENT);\n+        add_coin(0.3*CENT);\n+        add_coin(0.4*CENT);\n+        add_coin(0.5*CENT);\n+\n+        // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 = 1.5 cents\n+        // we'll get sub-cent change whatever happens, so can expect 1.0 exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        // but if we add a bigger coin, making it possible to avoid sub-cent change, things change:\n+        add_coin(1111*CENT);\n+\n+        // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+#else\n+        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 1111 * CENT); // but get a single 1111 cent coin\n+#endif\n+\n+        // if we add more sub-cent coins:\n+        add_coin(0.6*CENT);\n+        add_coin(0.7*CENT);\n+\n+        // and try again to make 1.0 cents, the new coins will be used to make 2.0 cents - leaving 1.0 cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+#else\n+        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 2 * CENT); // but get a bunch of sub-cent coins totalling 2 cents\n+        BOOST_CHECK_GE(setCoinsRet.size(), 4); // 0.7 + 0.6 + 0.5 + 0.2 = 2.0 for example\n+#endif\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int i = 0; i < 20; i++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10); // in ten coins\n+#else\n+        BOOST_CHECK(nValueRet == 500000 * COIN || nValueRet == 550000 * COIN); // but get 50k too much\n+        BOOST_CHECK(setCoinsRet.size() == 10 || setCoinsRet.size() == 11); // in 11 coins\n+#endif\n+\n+        // if there's not enough in the smaller coins to make at least 1 cent change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(0.5 * CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.7 * CENT);\n+        add_coin(1111 * CENT);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(0.4 * CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.8 * CENT);\n+        add_coin(1111 * CENT);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2); // in two coins 0.4+0.6\n+#else\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // but since value of smaller coins < target+cent, we get the bigger coin again\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+#endif\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a2d2d9f8fa057b3ddf1094a1632ec1ece35772d9",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 47,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec0e83664f149193ce42c64d7fd13cd1aa268be8/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec0e83664f149193ce42c64d7fd13cd1aa268be8/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=ec0e83664f149193ce42c64d7fd13cd1aa268be8",
        "patch": "@@ -845,7 +845,32 @@ int64 CWallet::GetUnconfirmedBalance() const\n     return nTotal;\n }\n \n-bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n+// populate vCoins with vector of spendable (age, (value, (transaction, output_number))) outputs\n+void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n+{\n+    vCoins.clear();\n+\n+    CRITICAL_BLOCK(cs_wallet)\n+    {\n+        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            const CWalletTx* pcoin = &(*it).second;\n+\n+            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+                continue;\n+\n+            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+                continue;\n+\n+            for (int i = 0; i < pcoin->vout.size(); i++)\n+                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue > 0)\n+                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n+        }\n+    }\n+}\n+\n+bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n+                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -857,54 +882,32 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n     vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n     int64 nTotalLower = 0;\n \n-    CRITICAL_BLOCK(cs_wallet)\n+    BOOST_FOREACH(COutput output, vCoins)\n     {\n-       vector<const CWalletTx*> vCoins;\n-       vCoins.reserve(mapWallet.size());\n-       for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-           vCoins.push_back(&(*it).second);\n-       random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n-\n-       BOOST_FOREACH(const CWalletTx* pcoin, vCoins)\n-       {\n-            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n-                continue;\n-\n-            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n-                continue;\n+        const CWalletTx *pcoin = output.tx;\n \n-            int nDepth = pcoin->GetDepthInMainChain();\n-            if (nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n-                continue;\n-\n-            for (int i = 0; i < pcoin->vout.size(); i++)\n-            {\n-                if (pcoin->IsSpent(i) || !IsMine(pcoin->vout[i]))\n-                    continue;\n-\n-                int64 n = pcoin->vout[i].nValue;\n+        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n+            continue;\n \n-                if (n <= 0)\n-                    continue;\n+        int i = output.i;\n+        int64 n = pcoin->vout[i].nValue;\n \n-                pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n+        pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n \n-                if (n == nTargetValue)\n-                {\n-                    setCoinsRet.insert(coin.second);\n-                    nValueRet += coin.first;\n-                    return true;\n-                }\n-                else if (n < nTargetValue + CENT)\n-                {\n-                    vValue.push_back(coin);\n-                    nTotalLower += n;\n-                }\n-                else if (n < coinLowestLarger.first)\n-                {\n-                    coinLowestLarger = coin;\n-                }\n-            }\n+        if (n == nTargetValue)\n+        {\n+            setCoinsRet.insert(coin.second);\n+            nValueRet += coin.first;\n+            return true;\n+        }\n+        else if (n < nTargetValue + CENT)\n+        {\n+            vValue.push_back(coin);\n+            nTotalLower += n;\n+        }\n+        else if (n < coinLowestLarger.first)\n+        {\n+            coinLowestLarger = coin;\n         }\n     }\n \n@@ -979,22 +982,27 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n                 nValueRet += vValue[i].first;\n             }\n \n+#ifdef DEBUG\n         //// debug print\n         printf(\"SelectCoins() best subset: \");\n         for (int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n                 printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n         printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n+#endif\n     }\n \n     return true;\n }\n \n bool CWallet::SelectCoins(int64 nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n-    return (SelectCoinsMinConf(nTargetValue, 1, 6, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 1, 1, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 0, 1, setCoinsRet, nValueRet));\n+    vector<COutput> vCoins;\n+    AvailableCoins(vCoins);\n+\n+    return (SelectCoinsMinConf(nTargetValue, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 0, 1, vCoins, setCoinsRet, nValueRet));\n }\n \n "
      },
      {
        "sha": "40c70126dfb193290f3ef0d89a9e655768b290ec",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec0e83664f149193ce42c64d7fd13cd1aa268be8/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec0e83664f149193ce42c64d7fd13cd1aa268be8/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=ec0e83664f149193ce42c64d7fd13cd1aa268be8",
        "patch": "@@ -13,14 +13,15 @@\n class CWalletTx;\n class CReserveKey;\n class CWalletDB;\n+class COutput;\n \n // A CWallet is an extension of a keystore, which also maintains a set of\n // transactions and balances, and provides the ability to create new\n // transactions\n class CWallet : public CCryptoKeyStore\n {\n private:\n-    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins) const;\n     bool SelectCoins(int64 nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n     CWalletDB *pwalletdbEncryption;\n@@ -65,6 +66,8 @@ class CWallet : public CCryptoKeyStore\n \n     std::vector<unsigned char> vchDefaultKey;\n \n+    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+\n     // keystore implementation\n     // Generate a new key\n     std::vector<unsigned char> GenerateNewKey();\n@@ -554,6 +557,34 @@ class CWalletTx : public CMerkleTx\n };\n \n \n+\n+\n+class COutput\n+{\n+public:\n+    const CWalletTx *tx;\n+    int i;\n+    int nDepth;\n+\n+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn;\n+    }\n+\n+    std::string ToString() const\n+    {\n+        return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n+    }\n+\n+    void print() const\n+    {\n+        printf(\"%s\\n\", ToString().c_str());\n+    }\n+};\n+\n+\n+\n+\n //\n // Private key that includes an expiration date in case it never gets used.\n //"
      }
    ]
  },
  {
    "sha": "7244bba3fbf9bc3da0317e391e37162a2b358696",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MjQ0YmJhM2ZiZjliYzNkYTAzMTdlMzkxZTM3MTYyYTJiMzU4Njk2",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-02-27T19:41:10Z"
      },
      "committer": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-02-27T19:41:10Z"
      },
      "message": "Don't create change when it isn't necessary.\n\nIf we have three 50BTC outputs and try to spend 100BTC, we should use only two of the outputs.  Previously we were using all three.  Similarly if we have outputs of 50, 50, and 0.01 and want to spend 100BTC, we shouldn't include the 0.01 in the transaction.\n\nMove the stochastic approximation code into a new function and call it once or twice: first for <target> and then for <target+cent> if we weren't able to find a subset of coins that sum to exactly <target>.\n\nUpdated the unit tests to no longer conditionally compile out the tests which used to fail.",
      "tree": {
        "sha": "a8772b6e6a9e066363921a83feb3e260c3abc087",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8772b6e6a9e066363921a83feb3e260c3abc087"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7244bba3fbf9bc3da0317e391e37162a2b358696",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7244bba3fbf9bc3da0317e391e37162a2b358696",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7244bba3fbf9bc3da0317e391e37162a2b358696",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7244bba3fbf9bc3da0317e391e37162a2b358696/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec0e83664f149193ce42c64d7fd13cd1aa268be8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec0e83664f149193ce42c64d7fd13cd1aa268be8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec0e83664f149193ce42c64d7fd13cd1aa268be8"
      }
    ],
    "stats": {
      "total": 150,
      "additions": 71,
      "deletions": 79
    },
    "files": [
      {
        "sha": "c37f2b2a3cbbbbacbbbe614d5174bb150c9296bd",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 38,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7244bba3fbf9bc3da0317e391e37162a2b358696/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7244bba3fbf9bc3da0317e391e37162a2b358696/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=7244bba3fbf9bc3da0317e391e37162a2b358696",
        "patch": "@@ -6,9 +6,6 @@\n // how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n #define RUN_TESTS 100\n \n-// enables tests which currently fail, due to code which tries too hard to avoid sub-cent change\n-// #define STRICT\n-\n using namespace std;\n \n BOOST_AUTO_TEST_SUITE(wallet_tests)\n@@ -97,15 +94,10 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         BOOST_CHECK_GT(nValueRet, 34 * CENT);         // but should get more than 34 cents\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n-        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  I'd hope to see just 2+5, but 1 gets included too\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n         BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n-#else\n-        BOOST_CHECK(nValueRet == 7 * CENT || nValueRet == 8 * CENT);\n-        BOOST_CHECK(setCoinsRet.size() == 2 || setCoinsRet.size() == 3);\n-#endif\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n         BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n@@ -149,13 +141,9 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1); // because in the event of a tie, the biggest coin wins\n \n-        // now try making 11 cents.  we hope for 5+6 but get 5+7 due to fear of sub-cent change\n+        // now try making 11 cents.  we should get 5+6\n         BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n-#else\n-        BOOST_CHECK(nValueRet == 11 * CENT || nValueRet == 12 * CENT);\n-#endif\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n \n         // check that the smallest bigger coin is used\n@@ -189,24 +177,15 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n \n         // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5 cents\n         BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n-#else\n-        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 1111 * CENT); // but get a single 1111 cent coin\n-#endif\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n \n         // if we add more sub-cent coins:\n         add_coin(0.6*CENT);\n         add_coin(0.7*CENT);\n \n-        // and try again to make 1.0 cents, the new coins will be used to make 2.0 cents - leaving 1.0 cent change\n+        // and try again to make 1.0 cents, we can still make 1.0 cents\n         BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n-#else\n-        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 2 * CENT); // but get a bunch of sub-cent coins totalling 2 cents\n-        BOOST_CHECK_GE(setCoinsRet.size(), 4); // 0.7 + 0.6 + 0.5 + 0.2 = 2.0 for example\n-#endif\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n \n         // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n         // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n@@ -215,13 +194,8 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n             add_coin(50000 * COIN);\n \n         BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10); // in ten coins\n-#else\n-        BOOST_CHECK(nValueRet == 500000 * COIN || nValueRet == 550000 * COIN); // but get 50k too much\n-        BOOST_CHECK(setCoinsRet.size() == 10 || setCoinsRet.size() == 11); // in 11 coins\n-#endif\n \n         // if there's not enough in the smaller coins to make at least 1 cent change (0.5+0.6+0.7 < 1.0+1.0),\n         // we need to try finding an exact subset anyway\n@@ -243,13 +217,24 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(0.8 * CENT);\n         add_coin(1111 * CENT);\n         BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2); // in two coins 0.4+0.6\n-#else\n-        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // but since value of smaller coins < target+cent, we get the bigger coin again\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n-#endif\n+\n+        // test avoiding sub-cent change\n+        empty_wallet();\n+        add_coin(0.0005 * COIN);\n+        add_coin(0.01 * COIN);\n+        add_coin(1 * COIN);\n+\n+        // trying to make 1.0001 from these three coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1.0001 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.0105 * COIN);   // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        // but if we try to make 0.999, we should take the bigger of the two small coins to avoid sub-cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(0.999 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.01 * COIN);   // we should get 1 + 0.01\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n     }\n }\n "
      },
      {
        "sha": "92bbe29cd200faa1eabb8ea92da921b081d0d373",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 41,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7244bba3fbf9bc3da0317e391e37162a2b358696/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7244bba3fbf9bc3da0317e391e37162a2b358696/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=7244bba3fbf9bc3da0317e391e37162a2b358696",
        "patch": "@@ -869,6 +869,40 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n     }\n }\n \n+static void ApproximateBestSubset(vector<pair<int64, pair<const CWalletTx*,unsigned int> > >vValue, int64 nTotalLower, int64 nTargetValue,\n+                                  vector<char>& vfBest, int64& nBest, int iterations = 1000)\n+{\n+    vector<char> vfIncluded;\n+\n+    vfBest.assign(vValue.size(), true);\n+    nBest = nTotalLower;\n+\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n+    {\n+        vfIncluded.assign(vValue.size(), false);\n+        int64 nTotal = 0;\n+        bool fReachedTarget = false;\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+            for (int i = 0; i < vValue.size(); i++)\n+                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n+                {\n+                    nTotal += vValue[i].first;\n+                    vfIncluded[i] = true;\n+                    if (nTotal >= nTargetValue)\n+                    {\n+                        fReachedTarget = true;\n+                        if (nTotal < nBest)\n+                        {\n+                            nBest = nTotal;\n+                            vfBest = vfIncluded;\n+                        }\n+                        nTotal -= vValue[i].first;\n+                        vfIncluded[i] = false;\n+                    }\n+                }\n+    }\n+}\n+\n bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n                                  set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n@@ -911,7 +945,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         }\n     }\n \n-    if (nTotalLower == nTargetValue || nTotalLower == nTargetValue + CENT)\n+    if (nTotalLower == nTargetValue)\n     {\n         for (int i = 0; i < vValue.size(); ++i)\n         {\n@@ -921,7 +955,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         return true;\n     }\n \n-    if (nTotalLower < nTargetValue + (coinLowestLarger.second.first ? CENT : 0))\n+    if (nTotalLower < nTargetValue)\n     {\n         if (coinLowestLarger.second.first == NULL)\n             return false;\n@@ -930,46 +964,19 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         return true;\n     }\n \n-    if (nTotalLower >= nTargetValue + CENT)\n-        nTargetValue += CENT;\n-\n     // Solve subset sum by stochastic approximation\n-    sort(vValue.rbegin(), vValue.rend());\n-    vector<char> vfIncluded;\n-    vector<char> vfBest(vValue.size(), true);\n-    int64 nBest = nTotalLower;\n-\n-    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)\n-    {\n-        vfIncluded.assign(vValue.size(), false);\n-        int64 nTotal = 0;\n-        bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n-            for (int i = 0; i < vValue.size(); i++)\n-            {\n-                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n-                {\n-                    nTotal += vValue[i].first;\n-                    vfIncluded[i] = true;\n-                    if (nTotal >= nTargetValue)\n-                    {\n-                        fReachedTarget = true;\n-                        if (nTotal < nBest)\n-                        {\n-                            nBest = nTotal;\n-                            vfBest = vfIncluded;\n-                        }\n-                        nTotal -= vValue[i].first;\n-                        vfIncluded[i] = false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // If the next larger is still closer, return it\n-    if (coinLowestLarger.second.first && coinLowestLarger.first - nTargetValue <= nBest - nTargetValue)\n+    sort(vValue.rbegin(), vValue.rend()); // sort into descending value order\n+    vector<char> vfBest;\n+    int64 nBest;\n+\n+\tApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n+\tif (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n+\t\tApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n+\n+    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n+\t//                                   or the next bigger coin is closer), return the bigger coin\n+    if (coinLowestLarger.second.first &&\n+\t\t((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n     {\n         setCoinsRet.insert(coinLowestLarger.second);\n         nValueRet += coinLowestLarger.first;"
      }
    ]
  }
]