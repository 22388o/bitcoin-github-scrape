[
  {
    "sha": "b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMGRkNDZhMjc2NmE1NDhlOGQ3ZDk2ZmJlN2VjOGFmMmM5NTYyNDRl",
    "commit": {
      "author": {
        "name": "Jefferson Carpenter",
        "email": "jeffersoncarpenter2@gmail.com",
        "date": "2019-04-06T12:02:47Z"
      },
      "committer": {
        "name": "Jefferson Carpenter",
        "email": "jeffersoncarpenter2@gmail.com",
        "date": "2019-04-06T12:33:35Z"
      },
      "message": "Declare iterators using auto",
      "tree": {
        "sha": "579c505d82530a2a59bd7fe24ff4a08d5f7e166c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/579c505d82530a2a59bd7fe24ff4a08d5f7e166c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/comments",
    "author": {
      "login": "negatratoron",
      "id": 1197615,
      "node_id": "MDQ6VXNlcjExOTc2MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1197615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/negatratoron",
      "html_url": "https://github.com/negatratoron",
      "followers_url": "https://api.github.com/users/negatratoron/followers",
      "following_url": "https://api.github.com/users/negatratoron/following{/other_user}",
      "gists_url": "https://api.github.com/users/negatratoron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/negatratoron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/negatratoron/subscriptions",
      "organizations_url": "https://api.github.com/users/negatratoron/orgs",
      "repos_url": "https://api.github.com/users/negatratoron/repos",
      "events_url": "https://api.github.com/users/negatratoron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/negatratoron/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "negatratoron",
      "id": 1197615,
      "node_id": "MDQ6VXNlcjExOTc2MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1197615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/negatratoron",
      "html_url": "https://github.com/negatratoron",
      "followers_url": "https://api.github.com/users/negatratoron/followers",
      "following_url": "https://api.github.com/users/negatratoron/following{/other_user}",
      "gists_url": "https://api.github.com/users/negatratoron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/negatratoron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/negatratoron/subscriptions",
      "organizations_url": "https://api.github.com/users/negatratoron/orgs",
      "repos_url": "https://api.github.com/users/negatratoron/repos",
      "events_url": "https://api.github.com/users/negatratoron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/negatratoron/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "35991b162fd142d76d83e672002846c8a40eb794",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35991b162fd142d76d83e672002846c8a40eb794",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/35991b162fd142d76d83e672002846c8a40eb794"
      }
    ],
    "stats": {
      "total": 232,
      "additions": 116,
      "deletions": 116
    },
    "files": [
      {
        "sha": "079b82137a0fe95b600dc7fea3776c04c8cd78d7",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -67,12 +67,12 @@ double CAddrInfo::GetChance(int64_t nNow) const\n \n CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n-    std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);\n+    auto it = mapAddr.find(addr);\n     if (it == mapAddr.end())\n         return nullptr;\n     if (pnId)\n         *pnId = (*it).second;\n-    std::map<int, CAddrInfo>::iterator it2 = mapInfo.find((*it).second);\n+    auto it2 = mapInfo.find((*it).second);\n     if (it2 != mapInfo.end())\n         return &(*it2).second;\n     return nullptr;\n@@ -534,7 +534,7 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n \n void CAddrMan::ResolveCollisions_()\n {\n-    for (std::set<int>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {\n+    for (auto it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {\n         int id_new = *it;\n \n         bool erase_collision = false;\n@@ -595,7 +595,7 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n {\n     if (m_tried_collisions.size() == 0) return CAddrInfo();\n \n-    std::set<int>::iterator it = m_tried_collisions.begin();\n+    auto it = m_tried_collisions.begin();\n \n     // Selects a random element from m_tried_collisions\n     std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));"
      },
      {
        "sha": "e783c6f44216f5d2cf15729b0eafba8404c12adc",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -107,7 +107,7 @@ bool BanMan::IsBanned(CSubNet sub_net)\n {\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    banmap_t::iterator i = m_banned.find(sub_net);\n+    auto i = m_banned.find(sub_net);\n     if (i != m_banned.end()) {\n         CBanEntry ban_entry = (*i).second;\n         if (current_time < ban_entry.nBanUntil) {\n@@ -188,7 +188,7 @@ void BanMan::SweepBanned()\n     bool notify_ui = false;\n     {\n         LOCK(m_cs_banned);\n-        banmap_t::iterator it = m_banned.begin();\n+        auto it = m_banned.begin();\n         while (it != m_banned.end()) {\n             CSubNet sub_net = (*it).first;\n             CBanEntry ban_entry = (*it).second;"
      },
      {
        "sha": "b8c7ac39fe8efb5c43ff2be8a37d434db09ccd6a",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -70,7 +70,7 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n     if (*psz != 0)\n         return false;\n     // Skip leading zeroes in b256.\n-    std::vector<unsigned char>::iterator it = b256.begin() + (size - length);\n+    auto it = b256.begin() + (size - length);\n     while (it != b256.end() && *it == 0)\n         it++;\n     // Copy result into output vector.\n@@ -109,7 +109,7 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n         pbegin++;\n     }\n     // Skip leading zeroes in base58 result.\n-    std::vector<unsigned char>::iterator it = b58.begin() + (size - length);\n+    auto it = b58.begin() + (size - length);\n     while (it != b58.end() && *it == 0)\n         it++;\n     // Translate the result into a string."
      },
      {
        "sha": "dd45e2afcd30247719206c2a4136866c5181c5f4",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -108,7 +108,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     const std::vector<std::pair<uint256, CTxMemPool::txiter> >& vTxHashes = pool->vTxHashes;\n     for (size_t i = 0; i < vTxHashes.size(); i++) {\n         uint64_t shortid = cmpctblock.GetShortID(vTxHashes[i].first);\n-        std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n+        auto idit = shorttxids.find(shortid);\n         if (idit != shorttxids.end()) {\n             if (!have_txn[idit->second]) {\n                 txn_available[idit->second] = vTxHashes[i].second->GetSharedTx();\n@@ -134,7 +134,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n \n     for (size_t i = 0; i < extra_txn.size(); i++) {\n         uint64_t shortid = cmpctblock.GetShortID(extra_txn[i].first);\n-        std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n+        auto idit = shorttxids.find(shortid);\n         if (idit != shorttxids.end()) {\n             if (!have_txn[idit->second]) {\n                 txn_available[idit->second] = extra_txn[i].second;"
      },
      {
        "sha": "c5de4a0dfc23ddbe59d1844e387624d8941363c9",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -304,7 +304,7 @@ void CRollingBloomFilter::reset()\n     nTweak = GetRand(std::numeric_limits<unsigned int>::max());\n     nEntriesThisGeneration = 0;\n     nGeneration = 1;\n-    for (std::vector<uint64_t>::iterator it = data.begin(); it != data.end(); it++) {\n+    for (auto it = data.begin(); it != data.end(); it++) {\n         *it = 0;\n     }\n }"
      },
      {
        "sha": "e82deddc7d7ab2eb705ea4ac1dfd50fbc8163324",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -39,13 +39,13 @@ size_t CCoinsViewCache::DynamicMemoryUsage() const {\n }\n \n CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n-    CCoinsMap::iterator it = cacheCoins.find(outpoint);\n+    auto it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n     Coin tmp;\n     if (!base->GetCoin(outpoint, tmp))\n         return cacheCoins.end();\n-    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n+    auto ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n     if (ret->second.coin.IsSpent()) {\n         // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n@@ -97,7 +97,7 @@ void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool\n }\n \n bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n-    CCoinsMap::iterator it = FetchCoin(outpoint);\n+    auto it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) return false;\n     cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     if (moveout) {\n@@ -144,12 +144,12 @@ void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n }\n \n bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); it = mapCoins.erase(it)) {\n+    for (auto it = mapCoins.begin(); it != mapCoins.end(); it = mapCoins.erase(it)) {\n         // Ignore non-dirty entries (optimization).\n         if (!(it->second.flags & CCoinsCacheEntry::DIRTY)) {\n             continue;\n         }\n-        CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n+        auto itUs = cacheCoins.find(it->first);\n         if (itUs == cacheCoins.end()) {\n             // The parent cache does not have an entry, while the child does\n             // We can ignore it if it's both FRESH and pruned in the child\n@@ -210,7 +210,7 @@ bool CCoinsViewCache::Flush() {\n \n void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n-    CCoinsMap::iterator it = cacheCoins.find(hash);\n+    auto it = cacheCoins.find(hash);\n     if (it != cacheCoins.end() && it->second.flags == 0) {\n         cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);"
      },
      {
        "sha": "0d2a6c8774f9cb8245f1f8f8231addd7e8639f1b",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -318,7 +318,7 @@ static bool HTTPBindAddresses(struct evhttp* http)\n     }\n \n     // Bind addresses\n-    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+    for (auto i = endpoints.begin(); i != endpoints.end(); ++i) {\n         LogPrint(BCLog::HTTP, \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n         evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? nullptr : i->first.c_str(), i->second);\n         if (bind_handle) {\n@@ -644,8 +644,8 @@ void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPR\n \n void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n {\n-    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n-    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    auto i = pathHandlers.begin();\n+    auto iend = pathHandlers.end();\n     for (; i != iend; ++i)\n         if (i->prefix == prefix && i->exactMatch == exactMatch)\n             break;"
      },
      {
        "sha": "2d16f0016059a603eeef621bc12f853918b36fe5",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -179,7 +179,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n \n void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n {\n-    for (CTxMemPool::setEntries::iterator iit = testSet.begin(); iit != testSet.end(); ) {\n+    for (auto iit = testSet.begin(); iit != testSet.end(); ) {\n         // Only test txs not already in the block\n         if (inBlock.count(*iit)) {\n             testSet.erase(iit++);\n@@ -309,7 +309,7 @@ void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpda\n     // and modifying them for their already included ancestors\n     UpdatePackagesForAdded(inBlock, mapModifiedTx);\n \n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n+    auto mi = mempool.mapTx.get<ancestor_score>().begin();\n     CTxMemPool::txiter iter;\n \n     // Limit the number of attempts to add transactions to the block when it is"
      },
      {
        "sha": "83d585a2e0bd1c86bb51901e396a455bbba0860b",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -589,7 +589,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n         if (msg.complete()) {\n             //store received bytes per message command\n             //to prevent a memory DOS, only allow valid commands\n-            mapMsgCmdSize::iterator i = mapRecvBytesPerMsgCmd.find(msg.hdr.pchCommand);\n+            auto i = mapRecvBytesPerMsgCmd.find(msg.hdr.pchCommand);\n             if (i == mapRecvBytesPerMsgCmd.end())\n                 i = mapRecvBytesPerMsgCmd.find(NET_MESSAGE_COMMAND_OTHER);\n             assert(i != mapRecvBytesPerMsgCmd.end());\n@@ -2411,7 +2411,7 @@ bool CConnman::AddNode(const std::string& strNode)\n bool CConnman::RemoveAddedNode(const std::string& strNode)\n {\n     LOCK(cs_vAddedNodes);\n-    for(std::vector<std::string>::iterator it = vAddedNodes.begin(); it != vAddedNodes.end(); ++it) {\n+    for (auto it = vAddedNodes.begin(); it != vAddedNodes.end(); ++it) {\n         if (strNode == *it) {\n             vAddedNodes.erase(it);\n             return true;"
      },
      {
        "sha": "12828066863024e4048ec470bc1b391404ce9f43",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -386,7 +386,7 @@ limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ)\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n+    auto it = mapNodeState.find(pnode);\n     if (it == mapNodeState.end())\n         return nullptr;\n     return &it->second;\n@@ -426,7 +426,7 @@ static void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    auto itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         assert(state != nullptr);\n@@ -455,7 +455,7 @@ static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlock\n     assert(state != nullptr);\n \n     // Short-circuit most stuff in case it is from the same node\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    auto itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n         if (pit) {\n             *pit = &itInFlight->second.second;\n@@ -466,7 +466,7 @@ static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlock\n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n-    std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n+    auto it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : nullptr)});\n     state->nBlocksInFlight++;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n@@ -533,7 +533,7 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connma\n         return;\n     }\n     if (nodestate->fProvidesHeaderAndIDs) {\n-        for (std::list<NodeId>::iterator it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); it++) {\n+        for (auto it = lNodesAnnouncingHeaderAndIDs.begin(); it != lNodesAnnouncingHeaderAndIDs.end(); it++) {\n             if (*it == nodeid) {\n                 lNodesAnnouncingHeaderAndIDs.erase(it);\n                 lNodesAnnouncingHeaderAndIDs.push_back(nodeid);\n@@ -856,7 +856,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n \n int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n-    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n+    auto it = mapOrphanTransactions.find(hash);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n     for (const CTxIn& txin : it->second.tx->vin)\n@@ -888,10 +888,10 @@ void EraseOrphansFor(NodeId peer)\n {\n     LOCK(g_cs_orphans);\n     int nErased = 0;\n-    std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+    auto iter = mapOrphanTransactions.begin();\n     while (iter != mapOrphanTransactions.end())\n     {\n-        std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n+        auto maybeErase = iter++; // increment to avoid iterator becoming invalid\n         if (maybeErase->second.fromPeer == peer)\n         {\n             nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n@@ -912,10 +912,10 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n         // Sweep out expired orphan pool entries:\n         int nErased = 0;\n         int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n-        std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+        auto iter = mapOrphanTransactions.begin();\n         while (iter != mapOrphanTransactions.end())\n         {\n-            std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n+            auto maybeErase = iter++;\n             if (maybeErase->second.nTimeExpire <= nNow) {\n                 nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n             } else {\n@@ -1133,7 +1133,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n-    std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n+    auto it = mapBlockSource.find(hash);\n \n     int nDoS = 0;\n     if (state.IsInvalid(nDoS)) {\n@@ -1408,7 +1408,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n {\n     AssertLockNotHeld(cs_main);\n \n-    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n+    auto it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     {\n@@ -2619,7 +2619,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n-        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+        auto blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n@@ -2789,7 +2789,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             LOCK(cs_main);\n \n-            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+            auto it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n                 LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n@@ -3771,7 +3771,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 // Produce a vector with all candidates for sending\n                 std::vector<std::set<uint256>::iterator> vInvTx;\n                 vInvTx.reserve(pto->setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n+                for (auto it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n                     vInvTx.push_back(it);\n                 }\n                 CAmount filterrate = 0;\n@@ -3790,7 +3790,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                     // Fetch the top element from the heap\n                     std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                    std::set<uint256>::iterator it = vInvTx.back();\n+                    auto it = vInvTx.back();\n                     vInvTx.pop_back();\n                     uint256 hash = *it;\n                     // Remove it from the to-be-sent set"
      },
      {
        "sha": "b3a10e576e53a55793f27245361b7023cd6c3903",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -512,7 +512,7 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n bool CBlockPolicyEstimator::removeTx(uint256 hash, bool inBlock)\n {\n     LOCK(m_cs_fee_estimator);\n-    std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n+    auto pos = mapMemPoolTxs.find(hash);\n     if (pos != mapMemPoolTxs.end()) {\n         feeStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n         shortStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n@@ -1006,7 +1006,7 @@ FeeFilterRounder::FeeFilterRounder(const CFeeRate& minIncrementalFee)\n \n CAmount FeeFilterRounder::round(CAmount currentMinFee)\n {\n-    std::set<double>::iterator it = feeset.lower_bound(currentMinFee);\n+    auto it = feeset.lower_bound(currentMinFee);\n     if ((it != feeset.begin() && insecure_rand.rand32() % 3 != 0) || it == feeset.end()) {\n         it--;\n     }"
      },
      {
        "sha": "4271c02f9bd1f7e29a8ece14553c5d220e5399a4",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -96,9 +96,9 @@ class AddressTablePriv\n     void updateEntry(const QString &address, const QString &label, bool isMine, const QString &purpose, int status)\n     {\n         // Find address / label in model\n-        QList<AddressTableEntry>::iterator lower = qLowerBound(\n+        auto lower = qLowerBound(\n             cachedAddressTable.begin(), cachedAddressTable.end(), address, AddressTableEntryLessThan());\n-        QList<AddressTableEntry>::iterator upper = qUpperBound(\n+        auto upper = qUpperBound(\n             cachedAddressTable.begin(), cachedAddressTable.end(), address, AddressTableEntryLessThan());\n         int lowerIndex = (lower - cachedAddressTable.begin());\n         int upperIndex = (upper - cachedAddressTable.begin());"
      },
      {
        "sha": "10f4c824b9a3f67cd7c8890cdffc331914df6b3e",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -126,7 +126,7 @@ bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n \n     QUrlQuery uriQuery(uri);\n     QList<QPair<QString, QString> > items = uriQuery.queryItems();\n-    for (QList<QPair<QString, QString> >::iterator i = items.begin(); i != items.end(); i++)\n+    for (auto i = items.begin(); i != items.end(); i++)\n     {\n         bool fShouldReturnFalse = false;\n         if (i->first.startsWith(\"req-\"))"
      },
      {
        "sha": "dee3929fac8cdc8d8939e445284e584ec3577c53",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -227,7 +227,7 @@ void PeerTableModel::refresh()\n \n int PeerTableModel::getRowByNodeId(NodeId nodeid)\n {\n-    std::map<NodeId, int>::iterator it = priv->mapNodeRows.find(nodeid);\n+    auto it = priv->mapNodeRows.find(nodeid);\n     if (it == priv->mapNodeRows.end())\n         return -1;\n "
      },
      {
        "sha": "754300714e55ab5a95049f786014b58d947ff86c",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -97,9 +97,9 @@ class TransactionTablePriv\n         qDebug() << \"TransactionTablePriv::updateWallet: \" + QString::fromStdString(hash.ToString()) + \" \" + QString::number(status);\n \n         // Find bounds of this transaction in model\n-        QList<TransactionRecord>::iterator lower = qLowerBound(\n+        auto lower = qLowerBound(\n             cachedWallet.begin(), cachedWallet.end(), hash, TxLessThan());\n-        QList<TransactionRecord>::iterator upper = qUpperBound(\n+        auto upper = qUpperBound(\n             cachedWallet.begin(), cachedWallet.end(), hash, TxLessThan());\n         int lowerIndex = (lower - cachedWallet.begin());\n         int upperIndex = (upper - cachedWallet.begin());"
      },
      {
        "sha": "4001bca9cbb89ea3a6553315863b5688104a99dc",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -46,7 +46,7 @@ void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n {\n     const CTransaction* walletTransaction = &wtx->get();\n     int i = 0;\n-    for (QList<SendCoinsRecipient>::iterator it = recipients.begin(); it != recipients.end(); ++it)\n+    for (auto it = recipients.begin(); it != recipients.end(); ++it)\n     {\n         SendCoinsRecipient& rcp = (*it);\n "
      },
      {
        "sha": "684fb9923163c1236a03ef3c914254776130581b",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -1435,7 +1435,7 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n         }\n     }\n \n-    for (std::set<const CBlockIndex*>::iterator it = setOrphans.begin(); it != setOrphans.end(); ++it)\n+    for (auto it = setOrphans.begin(); it != setOrphans.end(); ++it)\n     {\n         if (setPrevs.erase(*it) == 0) {\n             setTips.insert(*it);"
      },
      {
        "sha": "9f360cda7435dd511f4f0a179395d0242bf68e1f",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -794,7 +794,7 @@ void Unserialize(Stream& is, std::map<K, T, Pred, A>& m)\n {\n     m.clear();\n     unsigned int nSize = ReadCompactSize(is);\n-    typename std::map<K, T, Pred, A>::iterator mi = m.begin();\n+    auto mi = m.begin();\n     for (unsigned int i = 0; i < nSize; i++)\n     {\n         std::pair<K, T> item;\n@@ -821,7 +821,7 @@ void Unserialize(Stream& is, std::set<K, Pred, A>& m)\n {\n     m.clear();\n     unsigned int nSize = ReadCompactSize(is);\n-    typename std::set<K, Pred, A>::iterator it = m.begin();\n+    auto it = m.begin();\n     for (unsigned int i = 0; i < nSize; i++)\n     {\n         K key;"
      },
      {
        "sha": "9015b0d0d103918ff7d1602d9a69dfd0c7f32fa5",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -185,13 +185,13 @@ void DeleteLock(void* cs)\n     }\n     std::lock_guard<std::mutex> lock(lockdata.dd_mutex);\n     std::pair<void*, void*> item = std::make_pair(cs, nullptr);\n-    LockOrders::iterator it = lockdata.lockorders.lower_bound(item);\n+    auto it = lockdata.lockorders.lower_bound(item);\n     while (it != lockdata.lockorders.end() && it->first.first == cs) {\n         std::pair<void*, void*> invitem = std::make_pair(it->first.second, it->first.first);\n         lockdata.invlockorders.erase(invitem);\n         lockdata.lockorders.erase(it++);\n     }\n-    InvLockOrders::iterator invit = lockdata.invlockorders.lower_bound(item);\n+    auto invit = lockdata.invlockorders.lower_bound(item);\n     while (invit != lockdata.invlockorders.end() && invit->first == cs) {\n         std::pair<void*, void*> invinvitem = std::make_pair(invit->second, invit->first);\n         lockdata.lockorders.erase(invinvitem);"
      },
      {
        "sha": "21f41e8e61597856eef551d873d56680bf1daf99",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -55,7 +55,7 @@ class CCoinsViewTest : public CCoinsView\n \n     bool BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock) override\n     {\n-        for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n+        for (auto it = mapCoins.begin(); it != mapCoins.end(); ) {\n             if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n                 // Same optimization used in CCoinsViewDB is to only write dirty entries.\n                 map_[it->first] = it->second.coin;"
      },
      {
        "sha": "b46678f6cb03a48143d0ac7c7a2e05371dd0a25f",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -110,7 +110,7 @@ static void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, b\n     BOOST_CHECK_MESSAGE(decrypted == in, HexStr(decrypted) + std::string(\" != \") + hexin);\n \n     // Encrypt and re-decrypt substrings of the plaintext and verify that they equal each-other\n-    for(std::vector<unsigned char>::iterator i(in.begin()); i != in.end(); ++i)\n+    for (auto i = in.begin(); i != in.end(); ++i)\n     {\n         std::vector<unsigned char> sub(i, in.end());\n         std::vector<unsigned char> subout(sub.size() + AES_BLOCKSIZE);"
      },
      {
        "sha": "9a7e6cddb4116f85c4d1bf3e362540e7e4dd09c7",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -110,7 +110,7 @@ template<typename name>\n static void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     BOOST_CHECK_EQUAL(pool.size(), sortedOrder.size());\n-    typename CTxMemPool::indexed_transaction_set::index<name>::type::iterator it = pool.mapTx.get<name>().begin();\n+    auto it = pool.mapTx.get<name>().begin();\n     int count=0;\n     for (; it != pool.mapTx.get<name>().end(); ++it, ++count) {\n         BOOST_CHECK_EQUAL(it->GetTx().GetHash().ToString(), sortedOrder[count]);"
      },
      {
        "sha": "355704b42cde9675a203aab5bc6751d67d3e206d",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -105,7 +105,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     batch.Erase(DB_BEST_BLOCK);\n     batch.Write(DB_HEAD_BLOCKS, std::vector<uint256>{hashBlock, old_tip});\n \n-    for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n+    for (auto it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             CoinEntry entry(&it->first);\n             if (it->second.coin.IsSpent())\n@@ -115,7 +115,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n             changed++;\n         }\n         count++;\n-        CCoinsMap::iterator itOld = it++;\n+        auto itOld = it++;\n         mapCoins.erase(itOld);\n         if (batch.SizeEstimate() > batch_size) {\n             LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));"
      },
      {
        "sha": "3a6386794121b2ed3b66cdf06bad1423ae85e820",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -67,7 +67,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n         stageEntries.erase(cit);\n         const setEntries &setChildren = GetMemPoolChildren(cit);\n         for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n+            auto cacheIt = cachedDescendants.find(childEntry);\n             if (cacheIt != cachedDescendants.end()) {\n                 // We've already calculated this one, just add the entries for this set\n                 // but don't traverse again.\n@@ -358,7 +358,7 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n-    indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n+    auto newit = mapTx.insert(entry).first;\n     mapLinks.insert(make_pair(newit, TxLinks()));\n \n     // Update transaction for any feeDelta created by PrioritiseTransaction\n@@ -554,7 +554,7 @@ void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigne\n     {\n         uint256 hash = tx->GetHash();\n \n-        indexed_transaction_set::iterator i = mapTx.find(hash);\n+        auto i = mapTx.find(hash);\n         if (i != mapTx.end())\n             entries.push_back(&*i);\n     }\n@@ -757,7 +757,7 @@ std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::Get\n \n     iters.reserve(mapTx.size());\n \n-    for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi) {\n+    for (auto mi = mapTx.begin(); mi != mapTx.end(); ++mi) {\n         iters.push_back(mi);\n     }\n     std::sort(iters.begin(), iters.end(), DepthAndScoreComparator());\n@@ -924,7 +924,7 @@ void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPool\n \n int CTxMemPool::Expire(int64_t time) {\n     LOCK(cs);\n-    indexed_transaction_set::index<entry_time>::type::iterator it = mapTx.get<entry_time>().begin();\n+    auto it = mapTx.get<entry_time>().begin();\n     setEntries toremove;\n     while (it != mapTx.get<entry_time>().end() && it->GetTime() < time) {\n         toremove.insert(mapTx.project<0>(it));\n@@ -1021,7 +1021,7 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpends\n     unsigned nTxnRemoved = 0;\n     CFeeRate maxFeeRateRemoved(0);\n     while (!mapTx.empty() && DynamicMemoryUsage() > sizelimit) {\n-        indexed_transaction_set::index<descendant_score>::type::iterator it = mapTx.get<descendant_score>().begin();\n+        auto it = mapTx.get<descendant_score>().begin();\n \n         // We set the new mempool min fee to the feerate of the removed set, plus the\n         // \"minimum reasonable fee rate\" (ie some value under which we consider txn"
      },
      {
        "sha": "416850ee3163046a64608574279816bd366545a0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -2131,13 +2131,13 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n             {\n                 std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;\n                 vFiles.reserve(setDirtyFileInfo.size());\n-                for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n+                for (auto it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n                     vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));\n                     setDirtyFileInfo.erase(it++);\n                 }\n                 std::vector<const CBlockIndex*> vBlocks;\n                 vBlocks.reserve(setDirtyBlockIndex.size());\n-                for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n+                for (auto it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n                     vBlocks.push_back(*it);\n                     setDirtyBlockIndex.erase(it++);\n                 }\n@@ -2508,7 +2508,7 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n void CChainState::PruneBlockIndexCandidates() {\n     // Note that we can't delete the current block itself, as we may need to return to it later in case a\n     // reorganization to a better block fails.\n-    std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();\n+    auto it = setBlockIndexCandidates.begin();\n     while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {\n         setBlockIndexCandidates.erase(it++);\n     }\n@@ -2842,7 +2842,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n \n         // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n         // add it again.\n-        BlockMap::iterator it = mapBlockIndex.begin();\n+        auto it = mapBlockIndex.begin();\n         while (it != mapBlockIndex.end()) {\n             if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n                 setBlockIndexCandidates.insert(it->second);\n@@ -2870,7 +2870,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     int nHeight = pindex->nHeight;\n \n     // Remove the invalidity flag from this block and all its descendants.\n-    BlockMap::iterator it = mapBlockIndex.begin();\n+    auto it = mapBlockIndex.begin();\n     while (it != mapBlockIndex.end()) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n@@ -2908,7 +2908,7 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n \n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator it = mapBlockIndex.find(hash);\n+    auto it = mapBlockIndex.find(hash);\n     if (it != mapBlockIndex.end())\n         return it->second;\n \n@@ -2918,9 +2918,9 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n+    auto mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n+    auto miPrev = mapBlockIndex.find(block.hashPrevBlock);\n     if (miPrev != mapBlockIndex.end())\n     {\n         pindexNew->pprev = (*miPrev).second;\n@@ -2970,9 +2970,9 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n             if (chainActive.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n+            auto range = mapBlocksUnlinked.equal_range(pindex);\n             while (range.first != range.second) {\n-                std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n+                auto it = range.first;\n                 queue.push_back(it->second);\n                 range.first++;\n                 mapBlocksUnlinked.erase(it);\n@@ -3337,7 +3337,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n+    auto miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n         if (miSelf != mapBlockIndex.end()) {\n@@ -3355,7 +3355,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n+        auto mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n             return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n@@ -3628,9 +3628,9 @@ void PruneOneBlockFile(const int fileNumber)\n             // to be downloaded again in order to consider its chain, at which\n             // point it would be considered as a candidate for\n             // mapBlocksUnlinked or setBlockIndexCandidates.\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);\n+            auto range = mapBlocksUnlinked.equal_range(pindex->pprev);\n             while (range.first != range.second) {\n-                std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n+                auto _it = range.first;\n                 range.first++;\n                 if (_it->second == pindex) {\n                     mapBlocksUnlinked.erase(_it);\n@@ -3646,7 +3646,7 @@ void PruneOneBlockFile(const int fileNumber)\n \n void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune)\n {\n-    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n+    for (auto it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n         FlatFilePos pos(*it, 0);\n         fs::remove(BlockFileSeq().FileName(pos));\n         fs::remove(UndoFileSeq().FileName(pos));\n@@ -3789,7 +3789,7 @@ CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n         return nullptr;\n \n     // Return existing\n-    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+    auto mi = mapBlockIndex.find(hash);\n     if (mi != mapBlockIndex.end())\n         return (*mi).second;\n \n@@ -3883,7 +3883,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_RE\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n     }\n-    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)\n+    for (auto it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)\n     {\n         FlatFilePos pos(*it, 0);\n         if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {\n@@ -4160,7 +4160,7 @@ void CChainState::EraseBlockData(CBlockIndex* index)\n     setDirtyBlockIndex.insert(index);\n     // Update indexes\n     setBlockIndexCandidates.erase(index);\n-    std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(index->pprev);\n+    auto ret = mapBlocksUnlinked.equal_range(index->pprev);\n     while (ret.first != ret.second) {\n         if (ret.first->second == index) {\n             mapBlocksUnlinked.erase(ret.first++);\n@@ -4462,9 +4462,9 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n                 while (!queue.empty()) {\n                     uint256 head = queue.front();\n                     queue.pop_front();\n-                    std::pair<std::multimap<uint256, FlatFilePos>::iterator, std::multimap<uint256, FlatFilePos>::iterator> range = mapBlocksUnknownParent.equal_range(head);\n+                    auto range = mapBlocksUnknownParent.equal_range(head);\n                     while (range.first != range.second) {\n-                        std::multimap<uint256, FlatFilePos>::iterator it = range.first;\n+                        auto it = range.first;\n                         std::shared_ptr<CBlock> pblockrecursive = std::make_shared<CBlock>();\n                         if (ReadBlockFromDisk(*pblockrecursive, it->second, chainparams.GetConsensus()))\n                         {\n@@ -4519,7 +4519,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n \n     assert(forward.size() == mapBlockIndex.size());\n \n-    std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(nullptr);\n+    auto rangeGenesis = forward.equal_range(nullptr);\n     CBlockIndex *pindex = rangeGenesis.first->second;\n     rangeGenesis.first++;\n     assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent nullptr.\n@@ -4596,7 +4596,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             assert(setBlockIndexCandidates.count(pindex) == 0);\n         }\n         // Check whether this block is in mapBlocksUnlinked.\n-        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);\n+        auto rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);\n         bool foundInUnlinked = false;\n         while (rangeUnlinked.first != rangeUnlinked.second) {\n             assert(rangeUnlinked.first->first == pindex->pprev);\n@@ -4633,7 +4633,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         // End: actual consistency checks.\n \n         // Try descending into the first subnode.\n-        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> range = forward.equal_range(pindex);\n+        auto range = forward.equal_range(pindex);\n         if (range.first != range.second) {\n             // A subnode was found.\n             pindex = range.first->second;\n@@ -4655,7 +4655,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             // Find our parent.\n             CBlockIndex* pindexPar = pindex->pprev;\n             // Find which child we just visited.\n-            std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangePar = forward.equal_range(pindexPar);\n+            auto rangePar = forward.equal_range(pindexPar);\n             while (rangePar.first->second != pindex) {\n                 assert(rangePar.first != rangePar.second); // Our parent must have at least the node we're coming from as child.\n                 rangePar.first++;\n@@ -4866,7 +4866,7 @@ class CMainCleanup\n     CMainCleanup() {}\n     ~CMainCleanup() {\n         // block headers\n-        BlockMap::iterator it1 = mapBlockIndex.begin();\n+        auto it1 = mapBlockIndex.begin();\n         for (; it1 != mapBlockIndex.end(); it1++)\n             delete (*it1).second;\n         mapBlockIndex.clear();"
      },
      {
        "sha": "3f7b0d56320964fa3bc34f9fc8cc84d271e467ba",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -780,7 +780,7 @@ void BerkeleyEnvironment::Flush(bool fShutdown)\n         return;\n     {\n         LOCK(cs_db);\n-        std::map<std::string, int>::iterator mi = mapFileUseCount.begin();\n+        auto mi = mapFileUseCount.begin();\n         while (mi != mapFileUseCount.end()) {\n             std::string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n@@ -825,7 +825,7 @@ bool BerkeleyBatch::PeriodicFlush(BerkeleyDatabase& database)\n     {\n         // Don't do this if any databases are in use\n         int nRefCount = 0;\n-        std::map<std::string, int>::iterator mit = env->mapFileUseCount.begin();\n+        auto mit = env->mapFileUseCount.begin();\n         while (mit != env->mapFileUseCount.end())\n         {\n             nRefCount += (*mit).second;\n@@ -835,7 +835,7 @@ bool BerkeleyBatch::PeriodicFlush(BerkeleyDatabase& database)\n         if (nRefCount == 0)\n         {\n             boost::this_thread::interruption_point();\n-            std::map<std::string, int>::iterator mi = env->mapFileUseCount.find(strFile);\n+            auto mi = env->mapFileUseCount.find(strFile);\n             if (mi != env->mapFileUseCount.end())\n             {\n                 LogPrint(BCLog::DB, \"Flushing %s\\n\", strFile);"
      },
      {
        "sha": "6d5267ff3691b00709bea5b3a50811c655a87143",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -1494,9 +1494,9 @@ UniValue listtransactions(const JSONRPCRequest& request)\n \n     std::vector<UniValue> arrTmp = ret.getValues();\n \n-    std::vector<UniValue>::iterator first = arrTmp.begin();\n+    auto first = arrTmp.begin();\n     std::advance(first, nFrom);\n-    std::vector<UniValue>::iterator last = arrTmp.begin();\n+    auto last = arrTmp.begin();\n     std::advance(last, nFrom+nCount);\n \n     if (last != arrTmp.end()) arrTmp.erase(last, arrTmp.end());\n@@ -3636,7 +3636,7 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n     // so the API remains stable if we allow multiple labels to be associated with\n     // an address.\n     UniValue labels(UniValue::VARR);\n-    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(dest);\n+    auto mi = pwallet->mapAddressBook.find(dest);\n     if (mi != pwallet->mapAddressBook.end()) {\n         labels.push_back(AddressBookDataToJSON(mi->second, true));\n     }"
      },
      {
        "sha": "2e3c40ad0c73157c46f11b3ecd7241daaaeaf357",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -57,7 +57,7 @@ bool RemoveWallet(const std::shared_ptr<CWallet>& wallet)\n {\n     LOCK(cs_wallets);\n     assert(wallet);\n-    std::vector<std::shared_ptr<CWallet>>::iterator i = std::find(vpwallets.begin(), vpwallets.end(), wallet);\n+    auto i = std::find(vpwallets.begin(), vpwallets.end(), wallet);\n     if (i == vpwallets.end()) return false;\n     vpwallets.erase(i);\n     return true;\n@@ -646,7 +646,7 @@ void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> ran\n \n     int nMinOrderPos = std::numeric_limits<int>::max();\n     const CWalletTx* copyFrom = nullptr;\n-    for (TxSpends::iterator it = range.first; it != range.second; ++it) {\n+    for (auto it = range.first; it != range.second; ++it) {\n         const CWalletTx* wtx = &mapWallet.at(it->second);\n         if (wtx->nOrderPos < nMinOrderPos) {\n             nMinOrderPos = wtx->nOrderPos;\n@@ -659,7 +659,7 @@ void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> ran\n     }\n \n     // Now copy data from copyFrom to rest:\n-    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n+    for (auto it = range.first; it != range.second; ++it)\n     {\n         const uint256& hash = it->second;\n         CWalletTx* copyTo = &mapWallet.at(hash);\n@@ -840,7 +840,7 @@ DBErrors CWallet::ReorderTransactions()\n \n     nOrderPosNext = 0;\n     std::vector<int64_t> nOrderPosOffsets;\n-    for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n+    for (auto it = txByTime.begin(); it != txByTime.end(); ++it)\n     {\n         CWalletTx *const pwtx = (*it).second;\n         int64_t& nOrderPos = pwtx->nOrderPos;\n@@ -2514,7 +2514,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     }\n \n     // remove preset inputs from vCoins\n-    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n+    for (auto it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n     {\n         if (setPresetCoins.count(it->GetInputCoin()))\n             it = vCoins.erase(it);\n@@ -2915,7 +2915,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                             return false;\n                         }\n \n-                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                        auto position = txNew.vout.begin()+nChangePosInOut;\n                         txNew.vout.insert(position, newTxOut);\n                     }\n                 } else {\n@@ -2974,7 +2974,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                     // If we have change output already, just increase it\n                     if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                         CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n-                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n+                        auto change_position = txNew.vout.begin()+nChangePosInOut;\n                         change_position->nValue += extraFeePaid;\n                         nFeeRet -= extraFeePaid;\n                     }\n@@ -2992,7 +2992,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                 // Try to reduce change to include necessary fee\n                 if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                     CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n-                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n+                    auto change_position = txNew.vout.begin()+nChangePosInOut;\n                     // Only reduce change if remaining amount is still a large enough output.\n                     if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n                         change_position->nValue -= additionalFeeNeeded;\n@@ -3228,7 +3228,7 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const std::string& s\n     bool fUpdated = false;\n     {\n         LOCK(cs_wallet);\n-        std::map<CTxDestination, CAddressBookData>::iterator mi = mapAddressBook.find(address);\n+        auto mi = mapAddressBook.find(address);\n         fUpdated = mi != mapAddressBook.end();\n         mapAddressBook[address].name = strName;\n         if (!strPurpose.empty()) /* update purpose only if requested */\n@@ -3775,7 +3775,7 @@ bool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n {\n     AssertLockHeld(cs_wallet);\n-    for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n+    for (auto it = setLockedCoins.begin();\n          it != setLockedCoins.end(); it++) {\n         COutPoint outpt = (*it);\n         vOutpts.push_back(outpt);\n@@ -3818,7 +3818,7 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n                 // iterate over all their outputs\n                 for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *this)) {\n                     // ... and all their affected keys\n-                    std::map<CKeyID, int>::iterator rit = mapKeyFirstBlock.find(keyid);\n+                    auto rit = mapKeyFirstBlock.find(keyid);\n                     if (rit != mapKeyFirstBlock.end() && *height < rit->second)\n                         rit->second = *height;\n                 }\n@@ -4305,7 +4305,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n             for (const CWalletTx& wtxOld : vWtx)\n             {\n                 uint256 hash = wtxOld.GetHash();\n-                std::map<uint256, CWalletTx>::iterator mi = walletInstance->mapWallet.find(hash);\n+                auto mi = walletInstance->mapWallet.find(hash);\n                 if (mi != walletInstance->mapWallet.end())\n                 {\n                     const CWalletTx* copyFrom = &wtxOld;"
      },
      {
        "sha": "327651e03591c9628d2936066972d0329f38d45f",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -626,7 +626,7 @@ DBErrors WalletBatch::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<u\n \n     // erase each matching wallet TX\n     bool delerror = false;\n-    std::vector<uint256>::iterator it = vTxHashIn.begin();\n+    auto it = vTxHashIn.begin();\n     for (const uint256& hash : vTxHash) {\n         while (it < vTxHashIn.end() && (*it) < hash) {\n             it++;"
      },
      {
        "sha": "6408115bf948e321b6635e8f995080016a4387f7",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -23,7 +23,7 @@ CZMQNotificationInterface::~CZMQNotificationInterface()\n {\n     Shutdown();\n \n-    for (std::list<CZMQAbstractNotifier*>::iterator i=notifiers.begin(); i!=notifiers.end(); ++i)\n+    for (auto i = notifiers.begin(); i != notifiers.end(); ++i)\n     {\n         delete *i;\n     }\n@@ -97,7 +97,7 @@ bool CZMQNotificationInterface::Initialize()\n         return false;\n     }\n \n-    std::list<CZMQAbstractNotifier*>::iterator i=notifiers.begin();\n+    auto i = notifiers.begin();\n     for (; i!=notifiers.end(); ++i)\n     {\n         CZMQAbstractNotifier *notifier = *i;\n@@ -126,7 +126,7 @@ void CZMQNotificationInterface::Shutdown()\n     LogPrint(BCLog::ZMQ, \"zmq: Shutdown notification interface\\n\");\n     if (pcontext)\n     {\n-        for (std::list<CZMQAbstractNotifier*>::iterator i=notifiers.begin(); i!=notifiers.end(); ++i)\n+        for (auto i = notifiers.begin(); i != notifiers.end(); ++i)\n         {\n             CZMQAbstractNotifier *notifier = *i;\n             LogPrint(BCLog::ZMQ, \"zmq: Shutdown notifier %s at %s\\n\", notifier->GetType(), notifier->GetAddress());\n@@ -143,7 +143,7 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, co\n     if (fInitialDownload || pindexNew == pindexFork) // In IBD or blocks were disconnected without any new ones\n         return;\n \n-    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )\n+    for (auto i = notifiers.begin(); i != notifiers.end(); )\n     {\n         CZMQAbstractNotifier *notifier = *i;\n         if (notifier->NotifyBlock(pindexNew))\n@@ -164,7 +164,7 @@ void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef&\n     // all the same external callback.\n     const CTransaction& tx = *ptx;\n \n-    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )\n+    for (auto i = notifiers.begin(); i != notifiers.end(); )\n     {\n         CZMQAbstractNotifier *notifier = *i;\n         if (notifier->NotifyTransaction(tx))"
      },
      {
        "sha": "e2ccd1599946c8a00dcfb9149f8e23625a1da846",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dd46a2766a548e8d7d96fbe7ec8af2c956244e/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=b0dd46a2766a548e8d7d96fbe7ec8af2c956244e",
        "patch": "@@ -65,7 +65,7 @@ bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n     assert(!psocket);\n \n     // check if address is being used by other publish notifier\n-    std::multimap<std::string, CZMQAbstractPublishNotifier*>::iterator i = mapPublishNotifiers.find(address);\n+    auto i = mapPublishNotifiers.find(address);\n \n     if (i==mapPublishNotifiers.end())\n     {\n@@ -120,7 +120,7 @@ void CZMQAbstractPublishNotifier::Shutdown()\n     typedef std::multimap<std::string, CZMQAbstractPublishNotifier*>::iterator iterator;\n     std::pair<iterator, iterator> iterpair = mapPublishNotifiers.equal_range(address);\n \n-    for (iterator it = iterpair.first; it != iterpair.second; ++it)\n+    for (auto it = iterpair.first; it != iterpair.second; ++it)\n     {\n         if (it->second==this)\n         {"
      }
    ]
  }
]