4tar,2014-06-07T03:03:24Z,"Aha, can't understand the failure log, just pushed a null commit to trigger it again for checking whether it was a random accident in the test box...\n",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45399593,45399593,
4tar,2014-06-07T03:55:33Z,"Great, looks I guess right:)\n",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45400395,45400395,
laanwj,2014-06-07T08:23:22Z,Looks good apart from my above nit. A lot less cluttered than the previous implementation.\n,https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45404699,45404699,
4tar,2014-06-07T09:26:45Z,"@laanwj Yes the code is simpler than calling getaddrinfo_a(), but as I've mentioned in the PR message, it doesn't fully achieve our purpose because:\n1. There is a lacking of timed wait in asio model, so without refactoring the caller we cannot make it work in an really efficient way, but fall into the waiting loop and face the problem of choosing a suitable waiting interval;\n2. Inside the asio::",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45405731,45405731,
sipa,2014-06-07T10:24:34Z,"I know boost::asio to judge whether we should be using it for DNS resolving, but I'd really prefer not to make netbase dependent on it.\n",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45406666,45406666,
laanwj,2014-06-07T10:45:07Z,"@sipa Agreed\n\n@4tar So boost::asio doesn't even provide a solution in this case, we can't do without the polling loop? Too bad we realize it so late, let's go back to the other pull then.\n",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45407025,45407025,
4tar,2014-06-07T11:16:52Z,"@laanwj @sipa Yes, the boost::asio really doesn't fit in our case, I'd still suggest we pick PR 4259 (https://github.com/bitcoin/bitcoin/pull/4259) for the solution, although it looks a littble bit complicated, or even ugly...\n",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45407570,45407570,
4tar,2014-06-07T11:26:48Z,"This latest commit doesn't fullfill our purpose as discussed above, but just push it to show that we can remove the wait loop with ios.poll() inside LookupIntern() by placing interruption_point in the resolve_handler, which makes the code a little bit cleaner and simpler...\n",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45407749,45407749,
BitcoinPullTester,2014-06-07T11:58:15Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/387bfd2c268bc3d49c21019e16c3cbded67ea4a8 for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/cu",https://github.com/bitcoin/bitcoin/pull/4299#issuecomment-45408282,45408282,
laanwj,2014-06-07T08:22:27Z,The whole reason for proposing the use of boost::asio was that you don't need a polling loop. There must surely be a better way to wait?\n,https://github.com/bitcoin/bitcoin/pull/4299#discussion_r13518633,13518633,src/netbase.cpp
4tar,2014-06-07T08:52:45Z,"If we want to fully leverage the asio facility, then we have to refactor all caller to be working in a real async way, so when the result has not been delivered, the caller can do some other useful work without waiting, which unfortunately is not our case.  Now they just want an simple but working utility function which gives back the resolving result.  To refactor them all looks an overkill for o",https://github.com/bitcoin/bitcoin/pull/4299#discussion_r13518699,13518699,src/netbase.cpp
laanwj,2014-06-07T09:21:58Z,"Well, let's keep the impact of this change as small as possible. Let's not refactor anything.\nBut a boost::asio event loop stops after all work items are completed (or at least can be configured as such) and AFAIK is naturally interruptible.\nWouldn't it be enough to just replace this with ios.run() ?\n",https://github.com/bitcoin/bitcoin/pull/4299#discussion_r13518771,13518771,src/netbase.cpp
4tar,2014-06-07T11:15:04Z,"@laanwj Yes the asio internal event loop is naturally interruptible, the problem is that it really is only when the interruption is _natural_, e.g. a SIGTERM signal from the OS.  But in our cases, where the event loop resides, say dnsseed thread, generally speaking, would have no chance to receive such a signal, but rely on boost::thread::interrupt() call to notify it the interruption request, so ",https://github.com/bitcoin/bitcoin/pull/4299#discussion_r13519056,13519056,src/netbase.cpp
