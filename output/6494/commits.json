[
  {
    "sha": "9fa8c48abbee1fe9d765705897e105274421d385",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZmE4YzQ4YWJiZWUxZmU5ZDc2NTcwNTg5N2UxMDUyNzQ0MjFkMzg1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2014-11-18T21:16:32Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-11-23T20:42:40Z"
      },
      "message": "Allow block announcements with headers\n\nThis replaces using inv messages to announce new blocks, when a peer requests\n(via the new \"sendheaders\" message) that blocks be announced with headers\ninstead of inv's.\n\nSince headers-first was introduced, peers send getheaders messages in response\nto an inv, which requires generating a block locator that is large compared to\nthe size of the header being requested, and requires an extra round-trip before\na reorg can be relayed.  Save time by tracking headers that a peer is likely to\nknow about, and send a headers chain that would connect to a peer's known\nheaders, unless the chain would be too big, in which case we revert to sending\nan inv instead.\n\nBased off of @sipa's commit to announce all blocks in a reorg via inv,\nwhich has been squashed into this commit.",
      "tree": {
        "sha": "eeca2bab4afba7c1f3d199f77180f720f1501b6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eeca2bab4afba7c1f3d199f77180f720f1501b6c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9fa8c48abbee1fe9d765705897e105274421d385",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9fa8c48abbee1fe9d765705897e105274421d385",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9fa8c48abbee1fe9d765705897e105274421d385",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9fa8c48abbee1fe9d765705897e105274421d385/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24c4841d16862c201bf62218280c2194a85a81ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24c4841d16862c201bf62218280c2194a85a81ca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24c4841d16862c201bf62218280c2194a85a81ca"
      }
    ],
    "stats": {
      "total": 792,
      "additions": 780,
      "deletions": 12
    },
    "files": [
      {
        "sha": "d96efa7b36ca7ecf78f16496a6fefb58f923a24e",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -90,6 +90,7 @@\n     'p2p-fullblocktest.py',\n     'blockchain.py',\n     'disablewallet.py',\n+    'sendheaders.py',\n ]\n testScriptsExt = [\n     'bip65-cltv.py',"
      },
      {
        "sha": "d7f4292090d01454a87cba91945b2f15f5d34c7d",
        "filename": "qa/rpc-tests/sendheaders.py",
        "status": "added",
        "additions": 519,
        "deletions": 0,
        "changes": 519,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/qa/rpc-tests/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/qa/rpc-tests/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sendheaders.py?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -0,0 +1,519 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+SendHeadersTest -- test behavior of headers messages to announce blocks.\n+\n+Setup: \n+\n+- Two nodes, two p2p connections to node0. One p2p connection should only ever\n+  receive inv's (omitted from testing description below, this is our control).\n+  Second node is used for creating reorgs.\n+\n+Part 1: No headers announcements before \"sendheaders\"\n+a. node mines a block [expect: inv]\n+   send getdata for the block [expect: block]\n+b. node mines another block [expect: inv]\n+   send getheaders and getdata [expect: headers, then block]\n+c. node mines another block [expect: inv]\n+   peer mines a block, announces with header [expect: getdata]\n+d. node mines another block [expect: inv]\n+\n+Part 2: After \"sendheaders\", headers announcements should generally work.\n+a. peer sends sendheaders [expect: no response]\n+   peer sends getheaders with current tip [expect: no response]\n+b. node mines a block [expect: tip header]\n+c. for N in 1, ..., 10:\n+   * for announce-type in {inv, header}\n+     - peer mines N blocks, announces with announce-type\n+       [ expect: getheaders/getdata or getdata, deliver block(s) ]\n+     - node mines a block [ expect: 1 header ]\n+\n+Part 3: Headers announcements stop after large reorg and resume after getheaders or inv from peer.\n+- For response-type in {inv, getheaders}\n+  * node mines a 7 block reorg [ expect: headers announcement of 8 blocks ]\n+  * node mines an 8-block reorg [ expect: inv at tip ]\n+  * peer responds with getblocks/getdata [expect: inv, blocks ]\n+  * node mines another block [ expect: inv at tip, peer sends getdata, expect: block ]\n+  * node mines another block at tip [ expect: inv ]\n+  * peer responds with getheaders with an old hashstop more than 8 blocks back [expect: headers]\n+  * peer requests block [ expect: block ]\n+  * node mines another block at tip [ expect: inv, peer sends getdata, expect: block ]\n+  * peer sends response-type [expect headers if getheaders, getheaders/getdata if mining new block]\n+  * node mines 1 block [expect: 1 header, peer responds with getdata]\n+\n+Part 4: Test direct fetch behavior\n+a. Announce 2 old block headers.\n+   Expect: no getdata requests.\n+b. Announce 3 new blocks via 1 headers message.\n+   Expect: one getdata request for all 3 blocks.\n+   (Send blocks.)\n+c. Announce 1 header that forks off the last two blocks.\n+   Expect: no response.\n+d. Announce 1 more header that builds on that fork.\n+   Expect: one getdata request for two blocks.\n+e. Announce 16 more headers that build on that fork.\n+   Expect: getdata request for 14 more blocks.\n+f. Announce 1 more header that builds on that fork.\n+   Expect: no response.\n+'''\n+\n+class BaseNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.connection = None\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.last_getdata = None\n+        self.sleep_time = 0.05\n+        self.block_announced = False\n+\n+    def clear_last_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Request data for a list of block hashes\n+    def get_data(self, block_hashes):\n+        msg = msg_getdata()\n+        for x in block_hashes:\n+            msg.inv.append(CInv(2, x))\n+        self.connection.send_message(msg)\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_block_inv(self, blockhash):\n+        msg = msg_inv()\n+        msg.inv = [CInv(2, blockhash)]\n+        self.connection.send_message(msg)\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    # Test whether the last announcement we received had the\n+    # right header or the right inv\n+    # inv and headers should be lists of block hashes\n+    def check_last_announcement(self, headers=None, inv=None):\n+        expect_headers = headers if headers != None else []\n+        expect_inv = inv if inv != None else []\n+        test_function = lambda: self.block_announced\n+        self.sync(test_function)\n+        with mininode_lock:\n+            self.block_announced = False\n+\n+            success = True\n+            compare_inv = []\n+            if self.last_inv != None:\n+                compare_inv = [x.hash for x in self.last_inv.inv]\n+            if compare_inv != expect_inv:\n+                success = False\n+\n+            hash_headers = []\n+            if self.last_headers != None:\n+                # treat headers as a list of block hashes\n+                hash_headers = [ x.sha256 for x in self.last_headers.headers ]\n+            if hash_headers != expect_headers:\n+                success = False\n+\n+            self.last_inv = None\n+            self.last_headers = None\n+        return success\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+    def send_getblocks(self, locator):\n+        getblocks_message = msg_getblocks()\n+        getblocks_message.locator.vHave = locator\n+        self.send_message(getblocks_message)\n+\n+# InvNode: This peer should only ever receive inv's, because it doesn't ever send a\n+# \"sendheaders\" message.\n+class InvNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class SendHeadersTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes = start_nodes(2, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\"]]*2)\n+        connect_nodes(self.nodes[0], 1)\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count):\n+        self.nodes[0].generate(count)\n+        return int(self.nodes[0].getbestblockhash(), 16)\n+\n+    # mine a reorg that invalidates length blocks (replacing them with\n+    # length+1 blocks).\n+    # peers is the p2p nodes we're using; we clear their state after the\n+    # to-be-reorged-out blocks are mined, so that we don't break later tests.\n+    # return the list of block hashes newly mined\n+    def mine_reorg(self, length, peers):\n+        self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n+        sync_blocks(self.nodes, wait=0.1)\n+        [x.clear_last_announcement() for x in peers]\n+\n+        tip_height = self.nodes[1].getblockcount()\n+        hash_to_invalidate = self.nodes[1].getblockhash(tip_height-(length-1))\n+        self.nodes[1].invalidateblock(hash_to_invalidate)\n+        all_hashes = self.nodes[1].generate(length+1) # Must be longer than the orig chain\n+        sync_blocks(self.nodes, wait=0.1)\n+        return [int(x, 16) for x in all_hashes]\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        inv_node = InvNode()\n+        test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], inv_node))\n+        # Set nServices to 0 for test_node, so no block download will occur outside of\n+        # direct fetching\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node, services=0))\n+        inv_node.add_connection(connections[0])\n+        test_node.add_connection(connections[1])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        inv_node.wait_for_verack()\n+        test_node.wait_for_verack()\n+\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+\n+        # PART 1\n+        # 1. Mine a block; expect inv announcements each time\n+        print \"Part 1: headers don't start before sendheaders message...\"\n+        for i in xrange(4):\n+            old_tip = tip\n+            tip = self.mine_blocks(1)\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+            # Try a few different responses; none should affect next announcement\n+            if i == 0:\n+                # first request the block\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip, timeout=5)\n+            elif i == 1:\n+                # next try requesting header and block\n+                test_node.get_headers(locator=[old_tip], hashstop=tip)\n+                test_node.get_data([tip])\n+                test_node.wait_for_block(tip)\n+                test_node.clear_last_announcement() # since we requested headers...\n+            elif i == 2:\n+                # this time announce own block via headers\n+                height = self.nodes[0].getblockcount()\n+                last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+                block_time = last_time + 1\n+                new_block = create_block(tip, create_coinbase(height+1), block_time)\n+                new_block.solve()\n+                test_node.send_header_for_blocks([new_block])\n+                test_node.wait_for_getdata([new_block.sha256], timeout=5)\n+                test_node.send_message(msg_block(new_block))\n+                test_node.sync_with_ping() # make sure this block is processed\n+                inv_node.clear_last_announcement()\n+                test_node.clear_last_announcement()\n+\n+        print \"Part 1: success!\"\n+        print \"Part 2: announce blocks with headers after sendheaders message...\"\n+        # PART 2\n+        # 2. Send a sendheaders message and test that headers announcements\n+        # commence and keep working.\n+        test_node.send_message(msg_sendheaders())\n+        prev_tip = int(self.nodes[0].getbestblockhash(), 16)\n+        test_node.get_headers(locator=[prev_tip], hashstop=0L)\n+        test_node.sync_with_ping()\n+        test_node.clear_last_announcement() # Clear out empty headers response\n+\n+        # Now that we've synced headers, headers announcements should work\n+        tip = self.mine_blocks(1)\n+        assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+        assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+\n+        height = self.nodes[0].getblockcount()+1\n+        block_time += 10  # Advance far enough ahead\n+        for i in xrange(10):\n+            # Mine i blocks, and alternate announcing either via\n+            # inv (of tip) or via headers. After each, new blocks\n+            # mined by the node should successfully be announced\n+            # with block header, even though the blocks are never requested\n+            for j in xrange(2):\n+                blocks = []\n+                for b in xrange(i+1):\n+                    blocks.append(create_block(tip, create_coinbase(height), block_time))\n+                    blocks[-1].solve()\n+                    tip = blocks[-1].sha256\n+                    block_time += 1\n+                    height += 1\n+                if j == 0:\n+                    # Announce via inv\n+                    test_node.send_block_inv(tip)\n+                    test_node.wait_for_getdata([tip], timeout=5)\n+                    # Test that duplicate inv's won't result in duplicate\n+                    # getdata requests, or duplicate headers announcements\n+                    inv_node.send_block_inv(tip)\n+                    # Should have received a getheaders as well!\n+                    test_node.send_header_for_blocks(blocks)\n+                    test_node.wait_for_getdata([x.sha256 for x in blocks[0:-1]], timeout=5)\n+                    [ inv_node.send_block_inv(x.sha256) for x in blocks[0:-1] ]\n+                    inv_node.sync_with_ping()\n+                else:\n+                    # Announce via headers\n+                    test_node.send_header_for_blocks(blocks)\n+                    test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=5)\n+                    # Test that duplicate headers won't result in duplicate\n+                    # getdata requests (the check is further down)\n+                    inv_node.send_header_for_blocks(blocks)\n+                    inv_node.sync_with_ping()\n+                [ test_node.send_message(msg_block(x)) for x in blocks ]\n+                test_node.sync_with_ping()\n+                inv_node.sync_with_ping()\n+                # This block should not be announced to the inv node (since it also\n+                # broadcast it)\n+                assert_equal(inv_node.last_inv, None)\n+                assert_equal(inv_node.last_headers, None)\n+                inv_node.clear_last_announcement()\n+                test_node.clear_last_announcement()\n+                tip = self.mine_blocks(1)\n+                assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+                assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+                height += 1\n+                block_time += 1\n+\n+        print \"Part 2: success!\"\n+\n+        print \"Part 3: headers announcements can stop after large reorg, and resume after headers/inv from peer...\"\n+\n+        # PART 3.  Headers announcements can stop after large reorg, and resume after\n+        # getheaders or inv from peer.\n+        for j in xrange(2):\n+            # First try mining a reorg that can propagate with header announcement\n+            new_block_hashes = self.mine_reorg(length=7, peers=[test_node, inv_node])\n+            tip = new_block_hashes[-1]\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(headers=new_block_hashes), True)\n+\n+            block_time += 8 \n+\n+            # Mine a too-large reorg, which should be announced with a single inv\n+            new_block_hashes = self.mine_reorg(length=8, peers=[test_node, inv_node])\n+            tip = new_block_hashes[-1]\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+\n+            block_time += 9\n+\n+            fork_point = self.nodes[0].getblock(\"%02x\" % new_block_hashes[0])[\"previousblockhash\"]\n+            fork_point = int(fork_point, 16)\n+\n+            # Use getblocks/getdata\n+            test_node.send_getblocks(locator = [fork_point])\n+            assert_equal(test_node.check_last_announcement(inv=new_block_hashes[0:-1]), True)\n+            test_node.get_data(new_block_hashes)\n+            test_node.wait_for_block(new_block_hashes[-1])\n+\n+            for i in xrange(3):\n+                # Mine another block, still should get only an inv\n+                tip = self.mine_blocks(1)\n+                assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+                assert_equal(test_node.check_last_announcement(inv=[tip]), True)\n+                if i == 0:\n+                    # Just get the data -- shouldn't cause headers announcements to resume\n+                    test_node.get_data([tip])\n+                    test_node.wait_for_block(tip)\n+                elif i == 1:\n+                    # Send a getheaders message that shouldn't trigger headers announcements\n+                    # to resume (best header sent will be too old)\n+                    test_node.get_headers(locator=[fork_point], hashstop=new_block_hashes[1])\n+                    test_node.get_data([tip])\n+                    test_node.wait_for_block(tip)\n+                    test_node.clear_last_announcement()\n+                elif i == 2:\n+                    test_node.get_data([tip])\n+                    test_node.wait_for_block(tip)\n+                    # This time, try sending either a getheaders to trigger resumption\n+                    # of headers announcements, or mine a new block and inv it, also \n+                    # triggering resumption of headers announcements.\n+                    if j == 0:\n+                        test_node.get_headers(locator=[tip], hashstop=0L)\n+                        test_node.sync_with_ping()\n+                    else:\n+                        test_node.send_block_inv(tip)\n+                        test_node.sync_with_ping()\n+            # New blocks should now be announced with header\n+            tip = self.mine_blocks(1)\n+            assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n+            assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n+\n+        print \"Part 3: success!\"\n+\n+        print \"Part 4: Testing direct fetch behavior...\"\n+        tip = self.mine_blocks(1)\n+        height = self.nodes[0].getblockcount() + 1\n+        last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+        block_time = last_time + 1\n+\n+        # Create 2 blocks.  Send the blocks, then send the headers.\n+        blocks = []\n+        for b in xrange(2):\n+            blocks.append(create_block(tip, create_coinbase(height), block_time))\n+            blocks[-1].solve()\n+            tip = blocks[-1].sha256\n+            block_time += 1\n+            height += 1\n+            inv_node.send_message(msg_block(blocks[-1]))\n+\n+        inv_node.sync_with_ping() # Make sure blocks are processed\n+        test_node.last_getdata = None\n+        test_node.send_header_for_blocks(blocks);\n+        test_node.sync_with_ping()\n+        # should not have received any getdata messages\n+        with mininode_lock:\n+            assert_equal(test_node.last_getdata, None)\n+\n+        # This time, direct fetch should work\n+        blocks = []\n+        for b in xrange(3):\n+            blocks.append(create_block(tip, create_coinbase(height), block_time))\n+            blocks[-1].solve()\n+            tip = blocks[-1].sha256\n+            block_time += 1\n+            height += 1\n+\n+        test_node.send_header_for_blocks(blocks)\n+        test_node.sync_with_ping()\n+        test_node.wait_for_getdata([x.sha256 for x in blocks], timeout=test_node.sleep_time)\n+\n+        [ test_node.send_message(msg_block(x)) for x in blocks ]\n+\n+        test_node.sync_with_ping()\n+\n+        # Now announce a header that forks the last two blocks\n+        tip = blocks[0].sha256\n+        height -= 1\n+        blocks = []\n+\n+        # Create extra blocks for later\n+        for b in xrange(20):\n+            blocks.append(create_block(tip, create_coinbase(height), block_time))\n+            blocks[-1].solve()\n+            tip = blocks[-1].sha256\n+            block_time += 1\n+            height += 1\n+\n+        # Announcing one block on fork should not trigger direct fetch\n+        # (less work than tip)\n+        test_node.last_getdata = None\n+        test_node.send_header_for_blocks(blocks[0:1])\n+        test_node.sync_with_ping()\n+        with mininode_lock:\n+            assert_equal(test_node.last_getdata, None)\n+\n+        # Announcing one more block on fork should trigger direct fetch for\n+        # both blocks (same work as tip)\n+        test_node.send_header_for_blocks(blocks[1:2])\n+        test_node.sync_with_ping()\n+        test_node.wait_for_getdata([x.sha256 for x in blocks[0:2]], timeout=test_node.sleep_time)\n+\n+        # Announcing 16 more headers should trigger direct fetch for 14 more\n+        # blocks\n+        test_node.send_header_for_blocks(blocks[2:18])\n+        test_node.sync_with_ping()\n+        test_node.wait_for_getdata([x.sha256 for x in blocks[2:16]], timeout=test_node.sleep_time)\n+\n+        # Announcing 1 more header should not trigger any response\n+        test_node.last_getdata = None\n+        test_node.send_header_for_blocks(blocks[18:19])\n+        test_node.sync_with_ping()\n+        with mininode_lock:\n+            assert_equal(test_node.last_getdata, None)\n+\n+        print \"Part 4: success!\"\n+\n+        # Finally, check that the inv node never received a getdata request,\n+        # throughout the test\n+        assert_equal(inv_node.last_getdata, None)\n+\n+if __name__ == '__main__':\n+    SendHeadersTest().main()"
      },
      {
        "sha": "64985d58e2f56b95258aae524d8f79d7063ac421",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 29,
        "deletions": 3,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -751,8 +751,8 @@ def __repr__(self):\n class msg_getdata(object):\n     command = \"getdata\"\n \n-    def __init__(self):\n-        self.inv = []\n+    def __init__(self, inv=None):\n+        self.inv = inv if inv != None else []\n \n     def deserialize(self, f):\n         self.inv = deser_vector(f, CInv)\n@@ -905,6 +905,20 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_mempool()\"\n \n+class msg_sendheaders(object):\n+    command = \"sendheaders\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_sendheaders()\"\n \n # getheaders message has\n # number of entries\n@@ -990,6 +1004,17 @@ class NodeConnCB(object):\n     def __init__(self):\n         self.verack_received = False\n \n+    # Spin until verack message is received from the node.\n+    # Tests may want to use this as a signal that the test can begin.\n+    # This can be called from the testing thread, so it needs to acquire the\n+    # global lock.\n+    def wait_for_verack(self):\n+        while True:\n+            with mininode_lock:\n+                if self.verack_received:\n+                    return\n+            time.sleep(0.05)\n+\n     # Derived classes should call this function once to set the message map\n     # which associates the derived classes' functions to incoming messages\n     def create_callback_map(self):\n@@ -1084,7 +1109,7 @@ class NodeConn(asyncore.dispatcher):\n         \"regtest\": \"\\xfa\\xbf\\xb5\\xda\"    # regtest\n     }\n \n-    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n+    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=1):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n         self.dstaddr = dstaddr\n@@ -1102,6 +1127,7 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n \n         # stuff version msg into sendbuf\n         vt = msg_version()\n+        vt.nServices = services\n         vt.addrTo.ip = self.dstaddr\n         vt.addrTo.port = self.dstport\n         vt.addrFrom.ip = \"0.0.0.0\""
      },
      {
        "sha": "3450ed6c3f3655cb20fbd0bdea841b73a711a729",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -51,6 +51,9 @@ CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n }\n \n const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n+    if (pindex == NULL) {\n+        return NULL;\n+    }\n     if (pindex->nHeight > Height())\n         pindex = pindex->GetAncestor(Height());\n     while (pindex && !Contains(pindex))"
      },
      {
        "sha": "8af0ae2efc97fe46592cbc8d30d7c0a88b81e06b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 213,
        "deletions": 8,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -246,6 +246,8 @@ struct CNodeState {\n     uint256 hashLastUnknownBlock;\n     //! The last full block we both have.\n     CBlockIndex *pindexLastCommonBlock;\n+    //! The best header we have sent our peer.\n+    CBlockIndex *pindexBestHeaderSent;\n     //! Whether we've started headers synchronization with this peer.\n     bool fSyncStarted;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n@@ -255,6 +257,8 @@ struct CNodeState {\n     int nBlocksInFlightValidHeaders;\n     //! Whether we consider this a preferred download peer.\n     bool fPreferredDownload;\n+    //! Whether this peer wants invs or headers (when possible) for block announcements.\n+    bool fPreferHeaders;\n \n     CNodeState() {\n         fCurrentlyConnected = false;\n@@ -263,11 +267,13 @@ struct CNodeState {\n         pindexBestKnownBlock = NULL;\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = NULL;\n+        pindexBestHeaderSent = NULL;\n         fSyncStarted = false;\n         nStallingSince = 0;\n         nBlocksInFlight = 0;\n         nBlocksInFlightValidHeaders = 0;\n         fPreferredDownload = false;\n+        fPreferHeaders = false;\n     }\n };\n \n@@ -397,6 +403,22 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n+// Requires cs_main\n+bool CanDirectFetch(const Consensus::Params &consensusParams)\n+{\n+    return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n+}\n+\n+// Requires cs_main\n+bool PeerHasHeader(CNodeState *state, CBlockIndex *pindex)\n+{\n+    if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n+        return true;\n+    if (state->pindexBestHeaderSent && pindex == state->pindexBestHeaderSent->GetAncestor(pindex->nHeight))\n+        return true;\n+    return false;\n+}\n+\n /** Find the last common ancestor two blocks have.\n  *  Both pa and pb must be non-NULL. */\n CBlockIndex* LastCommonAncestor(CBlockIndex* pa, CBlockIndex* pb) {\n@@ -2356,15 +2378,17 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n  * that is already loaded (to avoid loading it again from disk).\n  */\n bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n-    CBlockIndex *pindexNewTip = NULL;\n     CBlockIndex *pindexMostWork = NULL;\n     const CChainParams& chainparams = Params();\n     do {\n         boost::this_thread::interruption_point();\n \n+        CBlockIndex *pindexNewTip = NULL;\n+        const CBlockIndex *pindexFork;\n         bool fInitialDownload;\n         {\n             LOCK(cs_main);\n+            CBlockIndex *pindexOldTip = chainActive.Tip();\n             pindexMostWork = FindMostWorkChain();\n \n             // Whether we have anything to do at all.\n@@ -2375,26 +2399,44 @@ bool ActivateBestChain(CValidationState &state, const CBlock *pblock) {\n                 return false;\n \n             pindexNewTip = chainActive.Tip();\n+            pindexFork = chainActive.FindFork(pindexOldTip);\n             fInitialDownload = IsInitialBlockDownload();\n         }\n         // When we reach this point, we switched to a new tip (stored in pindexNewTip).\n \n         // Notifications/callbacks that can run without cs_main\n         if (!fInitialDownload) {\n-            uint256 hashNewTip = pindexNewTip->GetBlockHash();\n+            // Find the hashes of all blocks that weren't previously in the best chain.\n+            std::vector<uint256> vHashes;\n+            CBlockIndex *pindexToAnnounce = pindexNewTip;\n+            while (pindexToAnnounce != pindexFork) {\n+                vHashes.push_back(pindexToAnnounce->GetBlockHash());\n+                pindexToAnnounce = pindexToAnnounce->pprev;\n+                if (vHashes.size() == MAX_BLOCKS_TO_ANNOUNCE) {\n+                    // Limit announcements in case of a huge reorganization.\n+                    // Rely on the peer's synchronization mechanism in that case.\n+                    break;\n+                }\n+            }\n             // Relay inventory, but don't relay old inventory during initial block download.\n             int nBlockEstimate = 0;\n             if (fCheckpointsEnabled)\n                 nBlockEstimate = Checkpoints::GetTotalBlocksEstimate(chainparams.Checkpoints());\n             {\n                 LOCK(cs_vNodes);\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                    if (chainActive.Height() > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                        pnode->PushInventory(CInv(MSG_BLOCK, hashNewTip));\n+                BOOST_FOREACH(CNode* pnode, vNodes) {\n+                    if (chainActive.Height() > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate)) {\n+                        BOOST_REVERSE_FOREACH(const uint256& hash, vHashes) {\n+                            pnode->PushBlockHash(hash);\n+                        }\n+                    }\n+                }\n             }\n             // Notify external listeners about the new tip.\n-            GetMainSignals().UpdatedBlockTip(pindexNewTip);\n-            uiInterface.NotifyBlockTip(hashNewTip);\n+            if (!vHashes.empty()) {\n+                GetMainSignals().UpdatedBlockTip(pindexNewTip);\n+                uiInterface.NotifyBlockTip(vHashes.front());\n+            }\n         }\n     } while(pindexMostWork != chainActive.Tip());\n     CheckBlockIndex(chainparams.GetConsensus());\n@@ -4124,6 +4166,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             LOCK(cs_main);\n             State(pfrom->GetId())->fCurrentlyConnected = true;\n         }\n+\n+        if (pfrom->nVersion >= SENDHEADERS_VERSION) {\n+            // Tell our peer we prefer to receive headers rather than inv's\n+            // We send this to non-NODE NETWORK peers as well, because even\n+            // non-NODE NETWORK peers can announce blocks (such as pruning\n+            // nodes)\n+            pfrom->PushMessage(\"sendheaders\");\n+        }\n     }\n \n \n@@ -4193,6 +4243,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->fDisconnect = true;\n     }\n \n+    else if (strCommand == \"sendheaders\")\n+    {\n+        LOCK(cs_main);\n+        State(pfrom->GetId())->fPreferHeaders = true;\n+    }\n+\n \n     else if (strCommand == \"inv\")\n     {\n@@ -4234,7 +4290,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // not a direct successor.\n                     pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexBestHeader), inv.hash);\n                     CNodeState *nodestate = State(pfrom->GetId());\n-                    if (chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - chainparams.GetConsensus().nPowTargetSpacing * 20 &&\n+                    if (CanDirectFetch(chainparams.GetConsensus()) &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         vToFetch.push_back(inv);\n                         // Mark block as in flight already, even though the actual \"getdata\" message only goes out\n@@ -4335,6 +4391,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             LogPrint(\"net\", \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n             return true;\n         }\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n         CBlockIndex* pindex = NULL;\n         if (locator.IsNull())\n         {\n@@ -4362,6 +4420,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                 break;\n         }\n+        // pindex can be NULL either if we sent chainActive.Tip() OR\n+        // if our peer has chainActive.Tip() (and thus we are sending an empty\n+        // headers message). In both cases it's safe to update\n+        // pindexBestHeaderSent to be our tip.\n+        nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n         pfrom->PushMessage(\"headers\", vHeaders);\n     }\n \n@@ -4521,6 +4584,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 Misbehaving(pfrom->GetId(), 20);\n                 return error(\"non-continuous headers sequence\");\n             }\n+            BlockMap::iterator it = mapBlockIndex.find(header.GetHash());\n             if (!AcceptBlockHeader(header, state, chainparams, &pindexLast)) {\n                 int nDoS;\n                 if (state.IsInvalid(nDoS)) {\n@@ -4542,6 +4606,53 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256());\n         }\n \n+        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        // If this set of headers is valid and ends in a block with at least as\n+        // much work as our tip, download as much as possible.\n+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n+            vector<CBlockIndex *> vToFetch;\n+            CBlockIndex *pindexWalk = pindexLast;\n+            // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n+            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n+                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash())) {\n+                    // We don't have this block, and it's not yet in flight.\n+                    vToFetch.push_back(pindexWalk);\n+                }\n+                pindexWalk = pindexWalk->pprev;\n+            }\n+            // If pindexWalk still isn't on our main chain, we're looking at a\n+            // very large reorg at a time we think we're close to caught up to\n+            // the main chain -- this shouldn't really happen.  Bail out on the\n+            // direct fetch and rely on parallel download instead.\n+            if (!chainActive.Contains(pindexWalk)) {\n+                LogPrint(\"net\", \"Large reorg, won't direct fetch to %s (%d)\\n\",\n+                        pindexLast->GetBlockHash().ToString(),\n+                        pindexLast->nHeight);\n+            } else {\n+                vector<CInv> vGetData;\n+                // Download as much as possible, from earliest to latest.\n+                BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vToFetch) {\n+                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                        // Can't download any more from this peer\n+                        break;\n+                    }\n+                    vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n+                    LogPrint(\"net\", \"Requesting block %s from  peer=%d\\n\",\n+                            pindex->GetBlockHash().ToString(), pfrom->id);\n+                }\n+                if (vGetData.size() > 1) {\n+                    LogPrint(\"net\", \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n+                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n+                }\n+                if (vGetData.size() > 0) {\n+                    pfrom->PushMessage(\"getdata\", vGetData);\n+                }\n+            }\n+        }\n+\n         CheckBlockIndex(chainparams.GetConsensus());\n     }\n \n@@ -5082,6 +5193,100 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             GetMainSignals().Broadcast(nTimeBestReceived);\n         }\n \n+        //\n+        // Try sending block announcements via headers\n+        //\n+        {\n+            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+            // list of block hashes we're relaying, and our peer wants\n+            // headers announcements, then find the first header\n+            // not yet known to our peer but would connect, and send.\n+            // If no header would connect, or if we have too many\n+            // blocks, or if the peer doesn't want headers, just\n+            // add all to the inv queue.\n+            LOCK(pto->cs_inventory);\n+            vector<CBlock> vHeaders;\n+            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+\n+            if (!fRevertToInv) {\n+                bool fFoundStartingHeader = false;\n+                // Try to find first header that our peer doesn't have, and\n+                // then send all headers past that one.  If we come across any\n+                // headers that aren't on chainActive, give up.\n+                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        // Bail out if we reorged away from this block\n+                        fRevertToInv = true;\n+                        break;\n+                    }\n+                    assert(pBestIndex == NULL || pindex->pprev == pBestIndex);\n+                    pBestIndex = pindex;\n+                    if (fFoundStartingHeader) {\n+                        // add this to the headers message\n+                        vHeaders.push_back(pindex->GetBlockHeader());\n+                    } else if (PeerHasHeader(&state, pindex)) {\n+                        continue; // keep looking for the first new block\n+                    } else if (pindex->pprev == NULL || PeerHasHeader(&state, pindex->pprev)) {\n+                        // Peer doesn't have this header but they do have the prior one.\n+                        // Start sending headers.\n+                        fFoundStartingHeader = true;\n+                        vHeaders.push_back(pindex->GetBlockHeader());\n+                    } else {\n+                        // Peer doesn't have this header or the prior one -- nothing will\n+                        // connect, so bail out.\n+                        fRevertToInv = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (fRevertToInv) {\n+                // If falling back to using an inv, just try to inv the tip.\n+                // The last entry in vBlockHashesToAnnounce was our tip at some point\n+                // in the past.\n+                if (!pto->vBlockHashesToAnnounce.empty()) {\n+                    const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();\n+                    BlockMap::iterator mi = mapBlockIndex.find(hashToAnnounce);\n+                    assert(mi != mapBlockIndex.end());\n+                    CBlockIndex *pindex = mi->second;\n+\n+                    // Warn if we're announcing a block that is not on the main chain.\n+                    // This should be very rare and could be optimized out.\n+                    // Just log for now.\n+                    if (chainActive[pindex->nHeight] != pindex) {\n+                        LogPrint(\"net\", \"Announcing block %s not on main chain (tip=%s)\\n\",\n+                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());\n+                    }\n+\n+                    // If the peer announced this block to us, don't inv it back.\n+                    // (Since block announcements may not be via inv's, we can't solely rely on\n+                    // setInventoryKnown to track this.)\n+                    if (!PeerHasHeader(&state, pindex)) {\n+                        pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n+                        LogPrint(\"net\", \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n+                            pto->id, hashToAnnounce.ToString());\n+                    }\n+                }\n+            } else if (!vHeaders.empty()) {\n+                if (vHeaders.size() > 1) {\n+                    LogPrint(\"net\", \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n+                            vHeaders.size(),\n+                            vHeaders.front().GetHash().ToString(),\n+                            vHeaders.back().GetHash().ToString(), pto->id);\n+                } else {\n+                    LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n+                            vHeaders.front().GetHash().ToString(), pto->id);\n+                }\n+                pto->PushMessage(\"headers\", vHeaders);\n+                state.pindexBestHeaderSent = pBestIndex;\n+            }\n+            pto->vBlockHashesToAnnounce.clear();\n+        }\n+\n         //\n         // Message: inventory\n         //"
      },
      {
        "sha": "2ba41102c22b9eab7265b843d1ef459b7b41c48e",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -85,6 +85,8 @@ static const unsigned int DATABASE_WRITE_INTERVAL = 60 * 60;\n static const unsigned int DATABASE_FLUSH_INTERVAL = 24 * 60 * 60;\n /** Maximum length of reject messages. */\n static const unsigned int MAX_REJECT_MESSAGE_LENGTH = 111;\n+/** Maximum number of headers to announce when relaying blocks with headers message.*/\n+static const unsigned int MAX_BLOCKS_TO_ANNOUNCE = 8;\n \n struct BlockHasher\n {"
      },
      {
        "sha": "3faa8543475856ef1abc873ed04582fdecb55aa2",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -378,6 +378,9 @@ class CNode\n     std::vector<CInv> vInventoryToSend;\n     CCriticalSection cs_inventory;\n     std::multimap<int64_t, CInv> mapAskFor;\n+    // Used for headers announcements - unfiltered blocks to relay\n+    // Also protected by cs_inventory\n+    std::vector<uint256> vBlockHashesToAnnounce;\n \n     // Ping time measurement:\n     // The pong reply we're expecting, or 0 if no pong expected.\n@@ -492,6 +495,12 @@ class CNode\n         }\n     }\n \n+    void PushBlockHash(const uint256 &hash)\n+    {\n+        LOCK(cs_inventory);\n+        vBlockHashesToAnnounce.push_back(hash);\n+    }\n+\n     void AskFor(const CInv& inv);\n \n     // TODO: Document the postcondition of this function.  Is cs_vSend locked?"
      },
      {
        "sha": "f7cf18d0b68ca6240928d4364e093baf039ee7a6",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9fa8c48abbee1fe9d765705897e105274421d385/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9fa8c48abbee1fe9d765705897e105274421d385/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=9fa8c48abbee1fe9d765705897e105274421d385",
        "patch": "@@ -9,7 +9,7 @@\n  * network protocol versioning\n  */\n \n-static const int PROTOCOL_VERSION = 70011;\n+static const int PROTOCOL_VERSION = 70012;\n \n //! initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;\n@@ -37,4 +37,7 @@ static const int MEMPOOL_GD_VERSION = 60002;\n //! \"filter*\" commands are disabled without NODE_BLOOM after and including this version\n static const int NO_BLOOM_VERSION = 70011;\n \n+//! \"sendheaders\" command and announcing blocks with headers starts with this version\n+static const int SENDHEADERS_VERSION = 70012;\n+\n #endif // BITCOIN_VERSION_H"
      }
    ]
  }
]